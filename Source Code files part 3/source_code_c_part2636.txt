TRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)

#if (WINVER >= 0x500)

/* RasGetEapUserIdentity bit flags.
** These have the same values as the RAS_EAP_FLAG_ flags in raseapif.h
*/
#define RASEAPF_NonInteractive          0x00000002
#define RASEAPF_Logon                   0x00000004
#define RASEAPF_Preview                 0x00000008

/* RasGetEapUserIdentity structure.
*/
#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

typedef DWORD (WINAPI *PFNRASGETBUFFER) (
                            PBYTE *ppBuffer,
                            PDWORD pdwSize
                            );

typedef DWORD (WINAPI *PFNRASFREEBUFFER) (
                            PBYTE pBufer);

typedef DWORD (WINAPI *PFNRASSENDBUFFER) (
                            HANDLE hPort,
                            PBYTE  pBuffer,
                            DWORD  dwSize
                            );

typedef DWORD (WINAPI *PFNRASRECEIVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize,
                            DWORD  dwTimeOut,
                            HANDLE hEvent
                            );

typedef DWORD (WINAPI *PFNRASRETRIEVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize
                            );

typedef  DWORD (WINAPI *RasCustomScriptExecuteFn) (
                            HANDLE hPort,
                            LPCWSTR lpszPhonebook,
                            LPCWSTR lpszEntryName,
                            PFNRASGETBUFFER pfnRasGetBuffer,
                            PFNRASFREEBUFFER pfnRasFreeBuffer,
                            PFNRASSENDBUFFER pfnRasSendBuffer,
                            PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
                            PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
                            HWND hWnd,
                            RASDIALPARAMS *pRasDialParams,
                            PVOID pvReserved
                            );
                            
                            
                            
                            

#endif // (WINVER >= 0x500)

#if (WINVER >= 0x0501)

#define RASCOMMSETTINGS struct tagRASCOMMSETTINGS
RASCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
};

typedef DWORD (WINAPI *PFNRASSETCOMMSETTINGS) (
                            HANDLE hPort,
                            RASCOMMSETTINGS *pRasCommSettings,
                            PVOID  pvReserved
                            );

#define RASCUSTOMSCRIPTEXTENSIONS struct tagRASCUSTOMSCRIPTEXTENSIONS
RASCUSTOMSCRIPTEXTENSIONS
{
    DWORD                    dwSize;                  
    PFNRASSETCOMMSETTINGS    pfnRasSetCommSettings;
};

#endif


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPCSTR, LPRASDIALPARAMSA, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPCWSTR, LPRASDIALPARAMSW, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPCSTR, LPCSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPCWSTR, LPCWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT, LPSTR, DWORD );

DWORD APIENTRY RasGetErrorStringW( UINT, LPWSTR, DWORD );

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPCSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPCWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPCSTR, LPCSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPCSTR, LPCSTR, LPCSTR );

DWORD APIENTRY RasRenameEntryW( LPCWSTR, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasDeleteEntryA( LPCSTR, LPCSTR );

DWORD APIENTRY RasDeleteEntryW( LPCWSTR, LPCWSTR );

DWORD APIENTRY RasValidateEntryNameA( LPCSTR, LPCSTR );

DWORD APIENTRY RasValidateEntryNameW( LPCWSTR, LPCWSTR );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPCSTR, LPCSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPCWSTR, LPCWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPCSTR, LPCSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPCWSTR, LPCWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPCSTR, LPCSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPCWSTR, LPCWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPCSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPCWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPCSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPCWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );
#endif

#if (WINVER >= 0x500)

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;


typedef DWORD (WINAPI *RasCustomHangUpFn) (
                            HRASCONN hRasConn
                            );

typedef DWORD (WINAPI *RasCustomDialFn) (
		HINSTANCE           hInstDll,
		LPRASDIALEXTENSIONS lpRasDialExtensions,
		LPCTSTR              lpszPhonebook,
		LPRASDIALPARAMS     lpRasDialParams,
		DWORD               dwNotifierType,
		LPVOID              lpvNotifier,
		LPHRASCONN          lphRasConn,
		DWORD               dwFlags
        );

typedef DWORD (WINAPI *RasCustomDeleteEntryNotifyFn) (
        LPCTSTR             lpszPhonebook,
        LPCTSTR             lpszEntry,
        DWORD               dwFlags);


#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002

DWORD APIENTRY RasInvokeEapUI( HRASCONN, DWORD, LPRASDIALEXTENSIONS, HWND);

DWORD APIENTRY RasGetLinkStatistics(HRASCONN hRasConn,
                                    DWORD dwSubEntry,
                                    RAS_STATS *lpStatistics);

DWORD APIENTRY RasGetConnectionStatistics(HRASCONN hRasConn,
                                          RAS_STATS *lpStatistics);

DWORD APIENTRY RasClearLinkStatistics(HRASCONN hRasConn,
                                      DWORD dwSubEntry);


DWORD APIENTRY RasClearConnectionStatistics(HRASCONN hRasConn);

DWORD APIENTRY RasGetEapUserDataA(
                   HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  *pdwSizeofEapData);


DWORD APIENTRY RasGetEapUserDataW(
                   HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   *pdwSizeofEapData);

DWORD APIENTRY RasSetEapUserDataA(
                   HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  dwSizeofEapData);

DWORD APIENTRY RasSetEapUserDataW(
                   HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   dwSizeofEapData);

DWORD APIENTRY RasGetCustomAuthDataA(
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbCustomAuthData,
                   DWORD  *pdwSizeofCustomAuthData);


DWORD APIENTRY RasGetCustomAuthDataW(
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbCustomAuthData,
                   DWORD   *pdwSizeofCustomAuthData);

DWORD APIENTRY RasSetCustomAuthDataA(
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbCustomAuthData,
                   DWORD  dwSizeofCustomAuthData
                   );

DWORD APIENTRY RasSetCustomAuthDataW(
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbCustomAuthData,
                   DWORD   dwSizeofCustomAuthData
                   );
DWORD APIENTRY RasGetEapUserIdentityW(
                   LPCWSTR                  pszPhonebook,
                   LPCWSTR                  pszEntry,
                   DWORD                    dwFlags,
                   HWND                     hwnd,
                   LPRASEAPUSERIDENTITYW*   ppRasEapUserIdentity
);
DWORD APIENTRY RasGetEapUserIdentityA(
                   LPCSTR                   pszPhonebook,
                   LPCSTR                   pszEntry,
                   DWORD                    dwFlags,
                   HWND                     hwnd,
                   LPRASEAPUSERIDENTITYA*   ppRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityW(
                   LPRASEAPUSERIDENTITYW    pRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityA(
                   LPRASEAPUSERIDENTITYA    pRasEapUserIdentity
);
#endif

#if (WINVER >= 0x501)

DWORD APIENTRY  RasDeleteSubEntryA(
                LPCSTR pszPhonebook,
                LPCSTR pszEntry,
                DWORD  dwSubentryId);

DWORD APIENTRY  RasDeleteSubEntryW(
                LPCWSTR pszPhonebook,
                LPCWSTR pszEntry,
                DWORD   dwSubEntryId);
#endif

#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataW
#define RasSetEapUserData           RasSetEapUserDataW
#define RasGetCustomAuthData        RasGetCustomAuthDataW
#define RasSetCustomAuthData        RasSetCustomAuthDataW
#define RasGetEapUserIdentity       RasGetEapUserIdentityW
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityW
#endif
#if(WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryW
#endif
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataA
#define RasSetEapUserData           RasSetEapUserDataA
#define RasGetCustomAuthData        RasGetCustomAuthDataA
#define RasSetCustomAuthData        RasSetCustomAuthDataA
#define RasGetEapUserIdentity       RasGetEapUserIdentityA
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityA
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryA
#endif
#endif

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\raserror.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    raserror.h

Abstract:

    RAS specific error codes
    
--*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
/*
 * An operation is pending.%0
 */

#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
/*
 * An invalid port handle was detected.%0
 */

#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
/*
 * The specified port is already open.%0
 */

#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
/*
 * The caller's buffer is too small.%0
 */

#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
/*
 * Incorrect information was specified.%0
 */

#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
/*
 * The port information cannot be set.%0
 */

#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
/*
 * The specified port is not connected.%0
 */

#define ERROR_EVENT_INVALID                  (RASBASE+7)
/*
 * An invalid event was detected.%0
 */

#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
/*
 * A device was specified that does not exist.%0
 */

#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
/*
 * A device type was specified that does not exist.%0
 */

#define ERROR_BUFFER_INVALID                 (RASBASE+10)
/*
 * An invalid buffer was specified.%0
 */

#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
/*
 * A route was specified that is not available.%0
 */

#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
/*
 * A route was specified that is not allocated.%0
 */

#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
/*
 * An invalid compression was specified.%0
 */

#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
/*
 * There were insufficient buffers available.%0
 */

#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
/*
 * The specified port was not found.%0
 */ 

#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
/*
 * An asynchronous request is pending.%0
 */

#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
/*
 * The modem (or other connecting device) is already disconnecting.%0
 */

#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
/*
 * The specified port is not open.%0
 */ 

#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
/*
 * The specified port is not connected.%0
 */

#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
/*
 * No endpoints could be determined.%0
 */

#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
/*
 * The system could not open the phone book file.%0
 */ 

#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
/*
 * The system could not load the phone book file.%0
 */

#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
/*
 * The system could not find the phone book entry for this connection.%0
 */

#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
/*
 * The system could not update the phone book file.%0
 */

#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
/*
 * The system found invalid information in the phone book file.%0
 */

#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
/*
 * A string could not be loaded.%0
 */

#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
/*
 * A key could not be found.%0
 */

#define ERROR_DISCONNECTION                  (RASBASE+28)
/*
 * The connection was closed.%0
 */ 

#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
/*
 * The connection was closed by the remote computer.%0
 */

#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
/*
 * The modem (or other connecting device) was disconnected due to hardware failure.%0
 */

#define ERROR_USER_DISCONNECTION             (RASBASE+31)
/*
 * The user disconnected the modem (or other connecting device).%0
 */

#define ERROR_INVALID_SIZE                   (RASBASE+32)
/*
 * An incorrect structure size was detected.%0
 */

#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
/*
 * The modem (or other connecting device) is already in use or is not configured properly.%0 
 */

#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
/*
 * Your computer could not be registered on the remote network.%0
 */ 

#define ERROR_UNKNOWN                        (RASBASE+35)
/*
 * There was an unknown error.%0
 */

#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
/*
 * The device attached to the port is not the one expected.%0
 */

#define ERROR_BAD_STRING                     (RASBASE+37)
/*
 * A string was detected that could not be converted.%0
 */

#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
/*
 * The request has timed out.%0
 */

#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
/*
 * No asynchronous net is available.%0
 */

#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
/*
 * An error has occurred involving NetBIOS.%0
 */

#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
/*
 * The server cannot allocate NetBIOS resources needed to support the client.%0
 */

#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
/*
 * One of your computer's NetBIOS names is already registered on the remote network.%0
 */

#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
/*
 * A network adapter at the server failed.%0
 */

#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
/*
 * You will not receive network message popups.%0
 */

#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
/*
 * There was an internal authentication error.%0
 */

#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
/*
 * The account is not permitted to log on at this time of day.%0
 */

#define ERROR_ACCT_DISABLED                  (RASBASE+47)
/*
 * The account is disabled.%0
 */

#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
/*
 * The password for this account has expired.%0
 */

#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
/*
 * The account does not have permission to dial in.%0
 */

#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
/*
 * The remote access server is not responding.%0
 */

#define ERROR_FROM_DEVICE                    (RASBASE+51)
/*
 * The modem (or other connecting device) has reported an error.%0
 */

#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
/*
 * There was an unrecognized response from the modem (or other connecting device).%0
 */

#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
/*
 * A macro required by the modem (or other connecting device) was not found in the device.INF file.%0
 */

#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
/*
 * A command or response in the device.INF file section refers to an undefined macro.%0
 */

#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
/*
 * The <message> macro was not found in the device.INF file section.%0
 */

#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
/*
 * The <defaultoff> macro in the device.INF file section contains an undefined macro.%0
 */

#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
/*
 * The device.INF file could not be opened.%0
 */

#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
/*
 * The device name in the device.INF or media.INI file is too long.%0
 */

#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
/*
 * The media.INI file refers to an unknown device name.%0
 */

#define ERROR_NO_RESPONSES                   (RASBASE+60)
/*
 * The device.INF file contains no responses for the command.%0
 */

#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
/*
 * The device.INF file is missing a command.%0
 */

#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
/*
 * There was an attempt to set a macro not listed in device.INF file section.%0
 */

#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
/*
 * The media.INI file refers to an unknown device type.%0
 */

#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
/*
 * The system has run out of memory.%0
 */

#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
/*
 * The modem (or other connecting device) is not properly configured.%0
 */

#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
/*
 * The modem (or other connecting device) is not functioning.%0
 */

#define ERROR_READING_INI_FILE               (RASBASE+67)
/*
 * The system was unable to read the media.INI file.%0
 */

#define ERROR_NO_CONNECTION                  (RASBASE+68)
/*
 * The connection was terminated.%0
 */

#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
/*
 * The usage parameter in the media.INI file is invalid.%0
 */

#define ERROR_READING_SECTIONNAME            (RASBASE+70)
/*
 * The system was unable to read the section name from the media.INI file.%0
 */

#define ERROR_READING_DEVICETYPE             (RASBASE+71)
/*
 * The system was unable to read the device type from the media.INI file.%0
 */

#define ERROR_READING_DEVICENAME             (RASBASE+72)
/*
 * The system was unable to read the device name from the media.INI file.%0
 */

#define ERROR_READING_USAGE                  (RASBASE+73)
/*
 * The system was unable to read the usage from the media.INI file.%0
 */

#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
/*
 * The system was unable to read the maximum connection BPS rate from the media.INI file.%0
 */

#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
/*
 * The system was unable to read the maximum carrier connection speed from the media.INI file.%0
 */

#define ERROR_LINE_BUSY                      (RASBASE+76)
/*
 * The phone line is busy.%0
 */

#define ERROR_VOICE_ANSWER                   (RASBASE+77)
/*
 * A person answered instead of a modem (or other connecting device).%0
 */

#define ERROR_NO_ANSWER                      (RASBASE+78)
/*
 * There was no answer.%0
 */

#define ERROR_NO_CARRIER                     (RASBASE+79)
/*
 * The system could not detect the carrier.%0
 */

#define ERROR_NO_DIALTONE                    (RASBASE+80)
/*
 * There was no dial tone.%0
 */

#define ERROR_IN_COMMAND                     (RASBASE+81)
/*
 * The modem (or other connecting device) reported a general error.%0
 */

#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
/*
 * There was an error in writing the section name.%0
 */

#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
/*
 * There was an error in writing the device type.%0
 */

#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
/*
 * There was an error in writing the device name.%0
 */

#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
/*
 * There was an error in writing the maximum connection speed.
 */

#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
/*
 * There was an error in writing the maximum carrier speed.%0
 */

#define ERROR_WRITING_USAGE                  (RASBASE+87)
/*
 * There was an error in writing the usage.%0
 */

#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
/*
 *  There was an error in writing the default-off.%0
 */

#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
/*
 *  There was an error in reading the default-off.%0
 */

#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
/*
 * ERROR_EMPTY_INI_FILE%0
 */

#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
/*
 * Access was denied because the username and/or password was invalid on the domain.%0
 */

#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
/*
 * There was a hardware failure in the modem (or other connecting device).%0
 */

#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
/*
 * ERROR_NOT_BINARY_MACRO%0
 */

#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
/*
 * ERROR_DCB_NOT_FOUND%0
 */

#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
/*
 * The state machines are not started.%0
 */

#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
/*
 * The state machines are already started.%0
 */

#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
/*
 * The response looping did not complete.%0
 */

#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
/*
 * A response keyname in the device.INF file is not in the expected format.%0
 */

#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
/*
 * The modem (or other connecting device) response caused a buffer overflow.%0
 */

#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
/*
 * The expanded command in the device.INF file is too long.%0
 */

#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
/*
 * The modem moved to a connection speed not supported by the COM driver.%0
 */

#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
/*
 * Device response received when none expected.%0
 */

#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
/*
 * The connection needs information from you, but the application does not allow user interaction.%0
 */

#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
/*
 * The callback number is invalid.%0
 */

#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
/*
 * The authorization state is invalid.%0
 */

#define ERROR_WRITING_INITBPS                (RASBASE+106)
/*
 * ERROR_WRITING_INITBPS%0
 */

#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
/*
 * There was an error related to the X.25 protocol.%0
 */

#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
/*
 * The account has expired.%0
 */

#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
/*
 * There was an error changing the password on the domain.  The password might have been too short or might have matched a previously used password.%0
 */

#define ERROR_OVERRUN                        (RASBASE+110)
/*
 * Serial overrun errors were detected while communicating with the modem.%0
 */

#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
/*
 * The Remote Access Service Manager could not start. Additional information is provided in the event log.%0
 */

#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
/*
 * The two-way port is initializing.  Wait a few seconds and redial.%0
 */

#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
/*
 * No active ISDN lines are available.%0
 */

#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
/*
 * No ISDN channels are available to make the call.%0
 */

#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
/*
 * Too many errors occurred because of poor phone line quality.%0
 */

#define ERROR_IP_CONFIGURATION               (RASBASE+116)
/*
 * The Remote Access Service IP configuration is unusable.%0
 */

#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
/*
 * No IP addresses are available in the static pool of Remote Access Service IP addresses.%0
 */

#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
/*
 * The connection timed out waiting for a valid response from the remote computer.%0
 */

#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
/*
 * The connection was terminated by the remote computer.%0
 */

#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
/*
 * The connection attempt failed because your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
/*
 * The remote computer is not responding.%0
 */

#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
/*
 * Invalid data was received from the remote computer. This data was ignored.%0
 */

#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
/*
 * The phone number, including prefix and suffix, is too long.%0
 */

#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
/*
 * The IPX protocol cannot dial out on the modem (or other connecting device) because this computer is not configured for dialing out (it is an IPX router).%0
 */

#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
/*
 * The IPX protocol cannot dial in on the modem (or other connecting device) because this computer is not configured for dialing in (the IPX router is not installed).%0
 */

#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
/*
 * The IPX protocol cannot be used for dialing out on more than one modem (or other connecting device) at a time.%0
 */

#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
/*
 * Cannot access TCPCFG.DLL.%0
 */

#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
/*
 * The system cannot find an IP adapter.%0
 */

#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
/*
 * SLIP cannot be used unless the IP protocol is installed.%0
 */

#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
/*
 * Computer registration is not complete.%0
 */

#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
/*
 * The protocol is not configured.%0
 */

#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
/*
 *Your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
/*
 * Your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
/*
 * The PPP link control protocol was terminated.%0
 */

#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
/*
 * The requested address was rejected by the server.%0
 */

#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
/*
 * The remote computer terminated the control protocol.%0
 */

#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
/*
 * Loopback was detected.%0
 */

#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
/*
 * The server did not assign an address.%0
 */

#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
/*
 * The authentication protocol required by the remote server cannot use the stored password.  Redial, entering the password explicitly.%0
 */

#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
/*
 * An invalid dialing rule was detected.%0
 */

#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
/*
 * The local computer does not support the required data encryption type.%0
 */

#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
/*
 * The remote computer does not support the required data encryption type.%0
 */

#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
/*
 * The remote computer requires data encryption.%0
 */

#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
/*
 * The system cannot use the IPX network number assigned by the remote computer.  Additional information is provided in the event log.%0
 */

#define ERROR_INVALID_SMM                    (RASBASE+145)
/*
 * ERROR_INVALID_SMM%0
 */

#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
/*
 * ERROR_SMM_UNINITIALIZED%0
 */

#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
/*
 * ERROR_NO_MAC_FOR_PORT%0
 */

#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
/*
 * ERROR_SMM_TIMEOUT%0
 */

#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
/*
 * ERROR_BAD_PHONE_NUMBER%0
 */

#define ERROR_WRONG_MODULE                   (RASBASE+150)
/*
 * ERROR_WRONG_MODULE%0
 */

#define ERROR_INVALID_CALLBACK_NUMBER        (RASBASE+151)
/*
 * The callback number contains an invalid character.  Only the following 18 characters are allowed:  0 to 9, T, P, W, (, ), -, @, and space.%0
 */

#define ERROR_SCRIPT_SYNTAX                  (RASBASE+152)
/*
 * A syntax error was encountered while processing a script.%0
 */

#define ERROR_HANGUP_FAILED                  (RASBASE+153)
/*
 * The connection could not be disconnected because it was created by the multi-protocol router.%0
 */

#define ERROR_BUNDLE_NOT_FOUND               (RASBASE+154)
/*
 * The system could not find the multi-link bundle.%0
 */

#define ERROR_CANNOT_DO_CUSTOMDIAL           (RASBASE+155)
/*
 * The system cannot perform automated dial because this connection  has a custom dialer specified.%0
 */ 

#define ERROR_DIAL_ALREADY_IN_PROGRESS      (RASBASE+156)
/*
 * This connection is already being dialed.%0
 */

#define ERROR_RASAUTO_CANNOT_INITIALIZE	    (RASBASE+157)
/*
 * Remote Access Services could not be started automatically. Additional information is provided in the event log.%0
 */

#define ERROR_CONNECTION_ALREADY_SHARED     (RASBASE+158)
/*
 * Internet Connection Sharing is already enabled on the connection.%0
 */

#define ERROR_SHARING_CHANGE_FAILED         (RASBASE+159)
/*
 * An error occurred while the existing Internet Connection Sharing
 * settings were being changed.%0
 */

#define ERROR_SHARING_ROUTER_INSTALL        (RASBASE+160)
/*
 * An error occurred while routing capabilities were being enabled.%0
 */

#define ERROR_SHARE_CONNECTION_FAILED       (RASBASE+161)
/*
 * An error occurred while Internet Connection Sharing was being enabled
 * for the connection.%0
 */

#define ERROR_SHARING_PRIVATE_INSTALL       (RASBASE+162)
/*
 * An error occurred while the local network was being configured for sharing.%0
 */

#define ERROR_CANNOT_SHARE_CONNECTION       (RASBASE+163)
/*
 * Internet Connection Sharing cannot be enabled.
 * There is more than one LAN connection other than the connection
 * to be shared.%0
 */

#define ERROR_NO_SMART_CARD_READER          (RASBASE+164)
/*
 * No smart card reader is installed.%0
 */

#define ERROR_SHARING_ADDRESS_EXISTS        (RASBASE+165)
/*
 * Internet Connection Sharing cannot be enabled.
 * A LAN connection is already configured with the IP address
 * that is required for automatic IP addressing.%0
 */

#define ERROR_NO_CERTIFICATE                (RASBASE+166)
/*
 * A certificate could not be found. Connections that use the L2TP protocol over IPSec require the installation of a machine certificate, also known as a computer certificate.%0
 */

#define ERROR_SHARING_MULTIPLE_ADDRESSES    (RASBASE+167)
/*
 * Internet Connection Sharing cannot be enabled. The LAN connection selected
 * as the private network has more than one IP address configured.
 * Please reconfigure the LAN connection with a single IP address
 * before enabling Internet Connection Sharing.%0
 */

#define ERROR_FAILED_TO_ENCRYPT             (RASBASE+168)
/*
 * The connection attempt failed because of failure to encrypt data.%0
 */

#define ERROR_BAD_ADDRESS_SPECIFIED         (RASBASE+169)
/*
 * The specified destination is not reachable.%0
 */

#define ERROR_CONNECTION_REJECT             (RASBASE+170)
/*
 * The remote computer rejected the connection attempt.%0
 */

#define ERROR_CONGESTION                    (RASBASE+171)
/*
 * The connection attempt failed because the network is busy.%0
 */

#define ERROR_INCOMPATIBLE                  (RASBASE+172)
/*
 * The remote computer's network hardware is incompatible with the type of call requested.%0
 */

#define ERROR_NUMBERCHANGED                 (RASBASE+173)
/*
 * The connection attempt failed because the destination number has changed.%0
 */

#define ERROR_TEMPFAILURE                   (RASBASE+174)
/*
 * The connection attempt failed because of a temporary failure.  Try connecting again.%0
 */ 

#define ERROR_BLOCKED                       (RASBASE+175)
/*
 * The call was blocked by the remote computer.%0
 */

#define ERROR_DONOTDISTURB                  (RASBASE+176)
/*
 * The call could not be connected because the remote computer has invoked the Do Not Disturb feature.%0
 */

#define ERROR_OUTOFORDER                    (RASBASE+177)
/*
 * The connection attempt failed because the modem (or other connecting device) on the remote computer is out of order.%0
 */

#define ERROR_UNABLE_TO_AUTHENTICATE_SERVER (RASBASE+178)
/*
 * It was not possible to verify the identity of the server.%0
 */

#define ERROR_SMART_CARD_REQUIRED           (RASBASE+179)
/*
 * To dial out using this connection you must use a smart card.%0
 */

#define ERROR_INVALID_FUNCTION_FOR_ENTRY    (RASBASE+180)
/*
 * An attempted function is not valid for this connection.%0
 */

#define ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND (RASBASE+181)
/*
 * The encryption attempt failed because no valid certificate was found.%0
 */

#define ERROR_SHARING_RRAS_CONFLICT         (RASBASE+182)
/*
 * Connection Sharing (NAT) is currently installed as a routing protocol, and must be 
 * removed before enabling Internet Connection Sharing.%0
 */

#define ERROR_SHARING_NO_PRIVATE_LAN        (RASBASE+183)
/*
 * Internet Connection Sharing cannot be enabled. The LAN connection selected
 * as the private network is either not present, or is disconnected
 * from the network. Please ensure that the LAN adapter is connected
 * before enabling Internet Connection Sharing.%0
 */

#define ERROR_NO_DIFF_USER_AT_LOGON         (RASBASE+184)
/*
 * You cannot dial using this connection at logon time, because it is
 * configured to use a user name different than the one on the smart
 * card. If you want to use it at logon time, you must configure it to
 * use the user name on the smart card.%0
 */

#define ERROR_NO_REG_CERT_AT_LOGON          (RASBASE+185)
/*
 * You cannot dial using this connection at logon time, because it is
 * not configured to use a smart card. If you want to use it at logon
 * time, you must edit the properties of this connection so that it uses
 * a smart card.%0
 */

#define ERROR_OAKLEY_NO_CERT                (RASBASE+186)
/*
 * The L2TP connection attempt failed because there is no valid machine certificate on your computer for security authentication.%0
 */

#define ERROR_OAKLEY_AUTH_FAIL              (RASBASE+187)
/*
 * The L2TP connection attempt failed because the security layer could not authenticate the remote computer.%0
 */

#define ERROR_OAKLEY_ATTRIB_FAIL            (RASBASE+188)
/*
 * The L2TP connection attempt failed because the security layer could not negotiate compatible parameters with the remote computer.%0
 */

#define ERROR_OAKLEY_GENERAL_PROCESSING     (RASBASE+189)
/*
 * The L2TP connection attempt failed because the security layer encountered a processing error during initial negotiations with the remote computer.%0
 */

#define ERROR_OAKLEY_NO_PEER_CERT           (RASBASE+190)
/*
 * The L2TP connection attempt failed because certificate validation on the remote computer failed.%0
 */

#define ERROR_OAKLEY_NO_POLICY              (RASBASE+191)
/*
 * The L2TP connection attempt failed because security policy for the connection was not found.%0
 */

#define ERROR_OAKLEY_TIMED_OUT              (RASBASE+192)
/*
 * The L2TP connection attempt failed because security negotiation timed out.%0
 */

#define ERROR_OAKLEY_ERROR                  (RASBASE+193)
/*
 * The L2TP connection attempt failed because an error occurred while negotiating security.%0
 */

#define ERROR_UNKNOWN_FRAMED_PROTOCOL       (RASBASE+194)
/*
 * The Framed Protocol RADIUS attribute for this user is not PPP.%0
 */

#define ERROR_WRONG_TUNNEL_TYPE             (RASBASE+195)
/*
 * The Tunnel Type RADIUS attribute for this user is not correct.%0
 */

#define ERROR_UNKNOWN_SERVICE_TYPE          (RASBASE+196)
/*
 * The Service Type RADIUS attribute for this user is neither Framed nor Callback Framed.%0
 */

#define ERROR_CONNECTING_DEVICE_NOT_FOUND   (RASBASE+197)
/*
 * The connection failed because the modem (or other connecting device) was not found. Please make sure that the modem or other connecting device is installed.%0
 */

#define ERROR_NO_EAPTLS_CERTIFICATE          (RASBASE+198)
/*
 * A certificate could not be found that can be used with this Extensible Authentication Protocol.%0
 */

#define ERROR_SHARING_HOST_ADDRESS_CONFLICT (RASBASE+199)
/*
 * Internet Connection Sharing (ICS) cannot be enabled due to an IP 
 * address conflict on the network. ICS requires the host be configured to use 
 * 192.168.0.1. Please ensure that no other client on the network is
 * configured to use 192.168.0.1.%0
 */

#define RASBASEEND                          (RASBASE+199)

#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rasshost.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    rasshost.h

Abstract:

    This header defines the interface between third party security
    DLLs and the RAS server.
    
--*/

#ifndef _RASSHOST_
#define _RASSHOST_

#if _MSC_VER > 1000
#pragma once
#endif

#include <mprapi.h>

typedef DWORD  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;

    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h
    CHAR  UserName[UNLEN+1];        // Should always contain username if
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[MAX_DEVICE_NAME+1];


}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// The following entrypoints should be loaded by calling GetProcAddress from
// RasMan.lib
//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\recguids.h ===
// Copyright (C) Microsoft Corporation, 1990-1999
#if _MSC_VER > 1000
#pragma once
#endif

/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\reconcil.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__

#if _MSC_VER > 1000
#pragma once
#endif

/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rating.h ===
/***********************************************************************
**      R A T I N G . H                                                *
**                                                                     *
************************************************************************
** Copyright (C) 1996 - 1999 by Microsoft Corporation                  *
**                 All Rights Reserved                                 *
************************************************************************/
/*

        RATING.H

        Rating record object class definitions for Microsoft Guide



*/



#ifndef _RATING_H_
#define _RATING_H_


#include "dbsets.h"


/*

Rating objects are constructed from database records of the Rating table.

The CRatingRecordset class is used to select and create CRating objects
from the Rating table via functions in the CDatabaseRecordset parent class.

*/



class COMMMSTVEXPORT CRatingRecordset : public CDatabaseRecordset
{

// This class provides Rating recordset manipulation via parent functions


virtual CString GetTableName( VOID);

virtual BOOL    SetRecordsetObject( VOID* cRecordsetObject);

public:
virtual VOID*   GetRecordsetObject( VOID);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, LONG lRatingID);
};




class COMMMSTVEXPORT CRating : public CObject
{

    friend class CRatingRecordset; // generates the CRating record object


public:

			CRating(LONG lRatingID = AFX_RFX_LONG_PSEUDO_NULL,
					LONG lRatingSystemID = 0,
					FLOAT flRating = 0,
					CString cszDescription = "",
					CString cszPictogramMoniker = "") :
				    m_lRatingID(lRatingID),
				    m_lRatingSystemID(lRatingSystemID),
				    m_flRating(flRating),
					m_cszDescription(cszDescription),
					m_cszPictogramMoniker(cszPictogramMoniker) { }
			~CRating(VOID) { }

    VOID    SetRatingSystemID( LONG lRatingSystemID) { m_lRatingSystemID = lRatingSystemID; }
    VOID    SetRating( FLOAT flRating) { m_flRating = flRating; }
    VOID    SetDescription( LPCTSTR cszDescription) { m_cszDescription = cszDescription; }
    VOID    SetPictogramMoniker( LPCTSTR cszPictogramMoniker) { m_cszPictogramMoniker = cszPictogramMoniker; }

    LONG            RatingID() { return m_lRatingID; }
    LONG            RatingSystemID() { return m_lRatingSystemID; }
    FLOAT           Rating() { return m_flRating; }
    CString         Description() { return m_cszDescription; }
    CString         PictogramMoniker() { return m_cszPictogramMoniker; }


private:

    LONG            m_lRatingID;
    LONG            m_lRatingSystemID;
    FLOAT           m_flRating;
    CString         m_cszDescription;
    CString         m_cszPictogramMoniker;


};

// Table: Rating

#define  TBL_Rating  _T("Rating")

//      Field:                          Name                     Type    Size

#define FLD_Rating_RatingID         _T("R Rating ID")         // AutoLong  4
#define FLD_Rating_RatingSystemID   _T("R Rating System ID")  // Long      4
#define FLD_Rating_Rating           _T("R Rating")            // Float     4
#define FLD_Rating_Description      _T("R Description")       // Text     50
#define FLD_Rating_PictogramMoniker _T("R Pictogram Moniker") // Text    255


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rclsid.h ===
// --rclsid.h------------------------------------------------------------------
//
// Defines the identifiers for the Rules Class.
//          
// Identifiers defined:
//  
//          LIBID_rulecls
//
//          IID_IExchangeFolderRules
//
// Copyright 1986 - 1999 Microsoft Corporation.  All rights reserved.
//
// ----------------------------------------------------------------------------

#if !defined(_RCLSID_H)
#define _RCLSID_H

// Identifiers for the EDKFolderRules foundation class.

DEFINE_GUID(LIBID_rulecls,0xF111A8E6,0x4462,0x11CE,0xA8,0xDE,0x00,0xAA,0x00,0x4A,0xC5,0xC1);
DEFINE_GUID(IID_IExchangeFolderRules,0xF111A8E7,0x4462,0x11CE,0xA8,0xDE,0x00,0xAA,0x00,0x4A,0xC5,0xC1);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rassapi.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    rassapi.h

Description:

    This file contains the RASADMIN structures, defines and
    function prototypes for the following APIs and they can
    be imported from RASSAPI.DLL:

     RasAdminServerGetInfo
     RasAdminGetUserAccountServer
     RasAdminUserSetInfo
     RasAdminUserGetInfo
     RasAdminPortEnum
     RasAdminPortGetInfo
     RasAdminPortClearStatistics
     RasAdminPortDisconnect
     RasAdminFreeBuffer

Note:

    This header file and the sources containing the APIs will work
    only with UNICODE strings.

--*/

#ifndef _RASSAPI_H_
#define _RASSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#define RASSAPI_MAX_PHONENUMBER_SIZE     128
#define RASSAPI_MAX_MEDIA_NAME	         16
#define RASSAPI_MAX_PORT_NAME	            16
#define RASSAPI_MAX_DEVICE_NAME          128
#define RASSAPI_MAX_DEVICETYPE_NAME       16
#define RASSAPI_MAX_PARAM_KEY_SIZE        32

// Bits indicating user's Remote Access privileges and mask to isolate
// call back privilege.
//
// Note: Bit 0 MUST represent NoCallback due to a quirk of the "userparms"
//       storage method.  When a new LAN Manager user is created, bit 0 of the
//       userparms field is set to 1 and all other bits are 0.  These bits are
//       arranged so this "no Dial-In info" state maps to the "default Dial-In
//       privilege" state.

#define RASPRIV_NoCallback        0x01
#define RASPRIV_AdminSetCallback  0x02
#define RASPRIV_CallerSetCallback 0x04
#define RASPRIV_DialinPrivilege   0x08

#define RASPRIV_CallbackType (RASPRIV_AdminSetCallback \
                              | RASPRIV_CallerSetCallback \
                              | RASPRIV_NoCallback)

//
// Modem condition codes
//
#define	RAS_MODEM_OPERATIONAL	     1	// No modem errors.
#define	RAS_MODEM_NOT_RESPONDING     2
#define	RAS_MODEM_HARDWARE_FAILURE   3
#define	RAS_MODEM_INCORRECT_RESPONSE 4
#define	RAS_MODEM_UNKNOWN 	        5
//
// Line condition codes
//
#define	RAS_PORT_NON_OPERATIONAL 1
#define	RAS_PORT_DISCONNECTED	 2
#define	RAS_PORT_CALLING_BACK    3
#define	RAS_PORT_LISTENING	    4
#define	RAS_PORT_AUTHENTICATING  5
#define	RAS_PORT_AUTHENTICATED	 6
#define	RAS_PORT_INITIALIZING	 7

// The following three structures are same as the ones
// defined in rasman.h and have been renamed to prevent
// redefinitions when both header files are included.

enum RAS_PARAMS_FORMAT {

	ParamNumber	    = 0,

	ParamString	    = 1

} ;
typedef enum RAS_PARAMS_FORMAT	RAS_PARAMS_FORMAT ;

union RAS_PARAMS_VALUE {

	DWORD	Number ;

	struct	{
		DWORD	Length ;
		PCHAR	Data ;
		} String ;
} ;
typedef union RAS_PARAMS_VALUE	RAS_PARAMS_VALUE ;

struct RAS_PARAMETERS {

    CHAR	P_Key	[RASSAPI_MAX_PARAM_KEY_SIZE] ;

    RAS_PARAMS_FORMAT	P_Type ;

    BYTE	P_Attributes ;

    RAS_PARAMS_VALUE	P_Value ;

} ;
typedef struct RAS_PARAMETERS	RAS_PARAMETERS ;

// structures used by the RASADMIN APIs

typedef struct _RAS_USER_0
{
    BYTE bfPrivilege;
    WCHAR szPhoneNumber[ RASSAPI_MAX_PHONENUMBER_SIZE + 1];
} RAS_USER_0, *PRAS_USER_0;

typedef struct _RAS_PORT_0
{
    WCHAR wszPortName[RASSAPI_MAX_PORT_NAME];
    WCHAR wszDeviceType[RASSAPI_MAX_DEVICETYPE_NAME];
    WCHAR wszDeviceName[RASSAPI_MAX_DEVICE_NAME];
    WCHAR wszMediaName[RASSAPI_MAX_MEDIA_NAME];
    DWORD reserved;
    DWORD Flags;
    WCHAR wszUserName[UNLEN + 1];
    WCHAR wszComputer[NETBIOS_NAME_LEN];
    DWORD dwStartSessionTime;          // seconds from 1/1/1970
    WCHAR wszLogonDomain[DNLEN + 1];
    BOOL fAdvancedServer;
} RAS_PORT_0, *PRAS_PORT_0;


// Possible values for MediaId

#define MEDIA_UNKNOWN       0
#define MEDIA_SERIAL        1
#define MEDIA_RAS10_SERIAL  2
#define MEDIA_X25           3
#define MEDIA_ISDN          4


// Possible bits set in Flags field

#define USER_AUTHENTICATED    0x0001
#define MESSENGER_PRESENT     0x0002
#define PPP_CLIENT            0x0004
#define GATEWAY_ACTIVE        0x0008
#define REMOTE_LISTEN         0x0010
#define PORT_MULTILINKED      0x0020


typedef ULONG IPADDR;

// The following PPP structures are same as the ones
// defined in rasppp.h and have been renamed to prevent
// redefinitions when both header files are included
// in a module.

/* Maximum length of address string, e.g. "255.255.255.255" for IP.
*/
#define RAS_IPADDRESSLEN  15
#define RAS_IPXADDRESSLEN 22
#define RAS_ATADDRESSLEN  32

typedef struct _RAS_PPP_NBFCP_RESULT
{
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];
    WCHAR wszWksta[ NETBIOS_NAME_LEN + 1 ];
} RAS_PPP_NBFCP_RESULT;

typedef struct _RAS_PPP_IPCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPADDRESSLEN + 1 ];
} RAS_PPP_IPCP_RESULT;

typedef struct _RAS_PPP_IPXCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPXADDRESSLEN + 1 ];
} RAS_PPP_IPXCP_RESULT;

typedef struct _RAS_PPP_ATCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_ATADDRESSLEN + 1 ];
} RAS_PPP_ATCP_RESULT;

typedef struct _RAS_PPP_PROJECTION_RESULT
{
    RAS_PPP_NBFCP_RESULT nbf;
    RAS_PPP_IPCP_RESULT  ip;
    RAS_PPP_IPXCP_RESULT ipx;
    RAS_PPP_ATCP_RESULT  at;
} RAS_PPP_PROJECTION_RESULT;

typedef struct _RAS_PORT_1
{
    RAS_PORT_0                 rasport0;
    DWORD                      LineCondition;
    DWORD                      HardwareCondition;
    DWORD                      LineSpeed;        // in bits/second
    WORD                       NumStatistics;
    WORD                       NumMediaParms;
    DWORD                      SizeMediaParms;
    RAS_PPP_PROJECTION_RESULT  ProjResult;
} RAS_PORT_1, *PRAS_PORT_1;

typedef struct _RAS_PORT_STATISTICS
{
    // The connection statistics are followed by port statistics
    // A connection is across multiple ports.
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwBytesXmitedUncompressed;
    DWORD   dwBytesRcvedUncompressed;
    DWORD   dwBytesXmitedCompressed;
    DWORD   dwBytesRcvedCompressed;

    // the following are the port statistics
    DWORD   dwPortBytesXmited;
    DWORD   dwPortBytesRcved;
    DWORD   dwPortFramesXmited;
    DWORD   dwPortFramesRcved;
    DWORD   dwPortCrcErr;
    DWORD   dwPortTimeoutErr;
    DWORD   dwPortAlignmentErr;
    DWORD   dwPortHardwareOverrunErr;
    DWORD   dwPortFramingErr;
    DWORD   dwPortBufferOverrunErr;
    DWORD   dwPortBytesXmitedUncompressed;
    DWORD   dwPortBytesRcvedUncompressed;
    DWORD   dwPortBytesXmitedCompressed;
    DWORD   dwPortBytesRcvedCompressed;

} RAS_PORT_STATISTICS, *PRAS_PORT_STATISTICS;

//
// Server version numbers
//
#define RASDOWNLEVEL       10    // identifies a LM RAS 1.0 server
#define RASADMIN_35        35    // Identifies a NT RAS 3.5 server or client
#define RASADMIN_CURRENT   40    // Identifies a NT RAS 4.0 server or client


typedef struct _RAS_SERVER_0
{
    WORD TotalPorts;             // Total ports configured on the server
    WORD PortsInUse;             // Ports currently in use by remote clients
    DWORD RasVersion;            // version of RAS server
} RAS_SERVER_0, *PRAS_SERVER_0;


//
// function prototypes
//

DWORD APIENTRY RasAdminServerGetInfo(
    IN const WCHAR *  lpszServer,
    OUT PRAS_SERVER_0 pRasServer0
    );

DWORD APIENTRY RasAdminGetUserAccountServer(
    IN const WCHAR * lpszDomain,
    IN const WCHAR * lpszServer,
    OUT LPWSTR       lpszUserAccountServer
    );

DWORD APIENTRY RasAdminUserGetInfo(
    IN const WCHAR   * lpszUserAccountServer,
    IN const WCHAR   * lpszUser,
    OUT PRAS_USER_0    pRasUser0
    );

DWORD APIENTRY RasAdminUserSetInfo(
    IN const WCHAR       * lpszUserAccountServer,
    IN const WCHAR       * lpszUser,
    IN const PRAS_USER_0   pRasUser0
    );

DWORD APIENTRY RasAdminPortEnum(
    IN  const WCHAR * lpszServer,
    OUT PRAS_PORT_0 * ppRasPort0,
    OUT WORD *        pcEntriesRead
    );

DWORD APIENTRY RasAdminPortGetInfo(
    IN const WCHAR *            lpszServer,
    IN const WCHAR *            lpszPort,
    OUT RAS_PORT_1 *            pRasPort1,
    OUT RAS_PORT_STATISTICS *   pRasStats,
    OUT RAS_PARAMETERS **       ppRasParams
    );

DWORD APIENTRY RasAdminPortClearStatistics(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminPortDisconnect(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminFreeBuffer(
    PVOID Pointer
    );

DWORD APIENTRY RasAdminGetErrorString(
    IN  UINT    ResourceId,
    OUT WCHAR * lpszString,
    IN  DWORD   InBufSize );

BOOL APIENTRY RasAdminAcceptNewConnection (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

VOID APIENTRY RasAdminConnectionHangupNotification (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

DWORD APIENTRY RasAdminGetIpAddressForUser (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN OUT 	IPADDR *	   pipAddress,
	OUT		BOOL	 *    bNotifyRelease
	);

VOID APIENTRY RasAdminReleaseIpAddress (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN 		IPADDR *	   pipAddress
	);

// The following two APIs are used to get/set
// RAS user permissions in to a UsrParms buffer
// obtained by a call to NetUserGetInfo.
//
// Note that RasAdminUserGetInfo and RasAdminUserSetInfo
// are the APIs you should be using for getting and
// setting RAS permissions.

DWORD APIENTRY RasAdminGetUserParms(
    IN  WCHAR          * lpszParms,
    OUT PRAS_USER_0      pRasUser0
    );

DWORD APIENTRY RasAdminSetUserParms(
    IN OUT   WCHAR    * lpszParms,
    IN DWORD          cchNewParms,
    IN PRAS_USER_0    pRasUser0
    );

#ifdef __cplusplus
}
#endif

#endif // _RASSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ratingsy.h ===
/***********************************************************************
**      R A T I N G . H                                                *
**                                                                     *
************************************************************************
** Copyright (C) 1996 - 1999 by Microsoft Corporation                  *
**                 All Rights Reserved                                 *
************************************************************************/
/*

        RATING.H

        Rating record object class definitions for Microsoft Guide



*/



#ifndef _RATINGSYSTEM_H_
#define _RATINGSYSTEM_H_


#include "dbsets.h"


/*

Rating objects are constructed from database records of the RatingSystem table.

The CRatingSystemRecordset class is used to select and create CRatingSystem objects
from the RatingSystem table via functions in the CDatabaseRecordset parent class.

*/


class COMMMSTVEXPORT CRatingSystemRecordset : public CDatabaseRecordset
{
// This class provides RatingSystem recordset manipulation via parent functions

	virtual CString GetTableName(VOID);

	virtual BOOL    SetRecordsetObject(VOID *cRecordsetObject);

public:
virtual VOID*   GetRecordsetObject(VOID);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, LONG lRatingSystemID);
};


class COMMMSTVEXPORT CRatingSystem : public CObject
{
    friend class CRatingSystemRecordset; // generates the CRating record object

private:

    LONG            m_lRatingSystemID;
	LONG            m_lTuningSpace;
    CString         m_cszName;
    CString         m_cszDescription;
    
public:
			CRatingSystem(LONG lRatingSystemID = AFX_RFX_LONG_PSEUDO_NULL,
							LONG lTuningSpace = 0,
							CString cszName = "",
							CString cszDescription = "") :
						    m_lRatingSystemID(lRatingSystemID),
						    m_lTuningSpace(lTuningSpace),
							m_cszName(cszName),
							m_cszDescription(cszDescription){ }
			~CRatingSystem(VOID) { }

    VOID    SetTuningSpace( LONG lTuningSpace) { m_lTuningSpace = lTuningSpace; }
    VOID    SetName( LPCTSTR cszName) { m_cszName = cszName; }
    VOID    SetDescription( LPCTSTR cszDescription) { m_cszDescription = cszDescription; }

    LONG            RatingSystemID() { return m_lRatingSystemID; }
    LONG            TuningSpace() { return m_lTuningSpace; }
    CString         Name() { return m_cszName; }
    CString         Description() { return m_cszDescription; }
};


// Table: Rating

#define  TBL_RatingSystem  _T("[Rating System]")

//      Field:									Name					Type		Size

#define FLD_RatingSystem_RatingSystemID		_T("RS Rating System ID")	// Long		4
#define FLD_RatingSystem_TuningSpace		_T("RS Tuning Space")		// Long		4
#define FLD_RatingSystem_Name				_T("RS Name")				// Text		255
#define FLD_RatingSystem_Description		_T("RS Description")		// Text     50

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1999               **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\regstr.h ===
/*** regstr.h - Registry string definitions
 *
 *  This module contains public registry string definitions.
 *
 *  Copyright (c) 1992-1999 Microsoft Corporation
 *  Created     12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_REGSTR
#define _INC_REGSTR

#if _MSC_VER > 1000
#pragma once
#endif


/*** Public registry key names
 */

#define REGSTR_KEY_CLASS        TEXT("Class")      // under LOCAL_MACHINE
#define REGSTR_KEY_CONFIG       TEXT("Config")     // under LOCAL_MACHINE
#define REGSTR_KEY_ENUM         TEXT("Enum")       // under LOCAL_MACHINE
#define REGSTR_KEY_ROOTENUM     TEXT("Root")       // child of ENUM
#define REGSTR_KEY_BIOSENUM     TEXT("BIOS")       // child of ENUM
#define REGSTR_KEY_ACPIENUM     TEXT("ACPI")       // child of ENUM
#define REGSTR_KEY_PCMCIAENUM   TEXT("PCMCIA")     // child of ENUM
#define REGSTR_KEY_PCIENUM      TEXT("PCI")        // child of ENUM
#define REGSTR_KEY_VPOWERDENUM  TEXT("VPOWERD")    // child of ENUM
#ifndef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("ISAPnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("EISA")       // child of ENUM
#else // ifdef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("C98PnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("NESA")       // child of ENUM
#endif // ifdef NEC_98
#define REGSTR_KEY_LOGCONFIG    TEXT("LogConfig")  // child of enum\<enumerator>\<deviceid>\<instanceid>
#define REGSTR_KEY_SYSTEMBOARD  TEXT("*PNP0C01")   // child of enum\root
#define REGSTR_KEY_APM          TEXT("*PNP0C05")   // child of enum\root

#define REGSTR_KEY_INIUPDATE    TEXT("IniUpdate")
#define REG_KEY_INSTDEV         TEXT("Installed")  // child of hklm\class\classname (Win98-only)

#define REGSTR_KEY_DOSOPTCDROM  TEXT("CD-ROM")
#define REGSTR_KEY_DOSOPTMOUSE  TEXT("MOUSE")

#define REGSTR_KEY_KNOWNDOCKINGSTATES TEXT("Hardware Profiles")
#define REGSTR_KEY_DEVICEPARAMETERS   TEXT("Device Parameters")


/*** Public registry paths
 */

#define REGSTR_DEFAULT_INSTANCE          TEXT("0000")
#define REGSTR_PATH_MOTHERBOARD          REGSTR_KEY_SYSTEMBOARD TEXT("\\") REGSTR_DEFAULT_INSTANCE
#define REGSTR_PATH_SETUP                TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_DRIVERSIGN           TEXT("Software\\Microsoft\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN        TEXT("Software\\Microsoft\\Non-Driver Signing")
#define REGSTR_PATH_DRIVERSIGN_POLICY    TEXT("Software\\Policies\\Microsoft\\Windows NT\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN_POLICY TEXT("Software\\Policies\\Microsoft\\Windows NT\\Non-Driver Signing")
#define REGSTR_PATH_PIFCONVERT           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PIFConvert")
#define REGSTR_PATH_MSDOSOPTS            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSOptions")
#define REGSTR_PATH_NOSUGGMSDOS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NoMSDOSWarn")
#define REGSTR_PATH_NEWDOSBOX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSSpecialConfig")
#define REGSTR_PATH_RUNONCE              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define REGSTR_PATH_RUNONCEEX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define REGSTR_PATH_RUN                  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REGSTR_PATH_RUNSERVICESONCE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define REGSTR_PATH_RUNSERVICES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_PATH_DETECT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Detect")
#define REGSTR_PATH_APPPATHS             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_UNINSTALL            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REGSTR_PATH_REALMODENET          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net")
#define REGSTR_PATH_NETEQUIV             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Equivalent")
#define REGSTR_PATH_CVNETWORK            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network")
#define REGSTR_PATH_RELIABILITY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")
#define REGSTR_PATH_NT_CURRENTVERSION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#define REGSTR_PATH_VOLUMECACHE TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define REGSTR_VAL_DISPLAY      TEXT("display")


#define REGSTR_PATH_IDCONFIGDB  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB")
#define REGSTR_PATH_CRITICALDEVICEDATABASE  TEXT("System\\CurrentControlSet\\Control\\CriticalDeviceDatabase")
#define REGSTR_PATH_CLASS       TEXT("System\\CurrentControlSet\\Services\\Class")
#define REGSTR_PATH_DISPLAYSETTINGS TEXT("Display\\Settings")
#define REGSTR_PATH_FONTS           TEXT("Display\\Fonts")
#define REGSTR_PATH_ENUM        TEXT("Enum")
#define REGSTR_PATH_ROOT        TEXT("Enum\\Root")

#define REGSTR_PATH_CURRENTCONTROLSET TEXT("System\\CurrentControlSet")
#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum")
#define REGSTR_PATH_HWPROFILES  TEXT("System\\CurrentControlSet\\Hardware Profiles")
#define REGSTR_PATH_HWPROFILESCURRENT TEXT("System\\CurrentControlSet\\Hardware Profiles\\Current")
#define REGSTR_PATH_CLASS_NT    TEXT("System\\CurrentControlSet\\Control\\Class")

#define REGSTR_PATH_DEVICE_CLASSES TEXT("System\\CurrentControlSet\\Control\\DeviceClasses")

#define REGSTR_PATH_CODEVICEINSTALLERS TEXT("System\\CurrentControlSet\\Control\\CoDeviceInstallers")
#define REGSTR_PATH_BUSINFORMATION TEXT("System\\CurrentControlSet\\Control\\PnP\\BusInformation")

#define REGSTR_PATH_SERVICES    TEXT("System\\CurrentControlSet\\Services")
#define REGSTR_PATH_VXD         TEXT("System\\CurrentControlSet\\Services\\VxD")
#define REGSTR_PATH_IOS     TEXT("System\\CurrentControlSet\\Services\\VxD\\IOS")
#define REGSTR_PATH_VMM         TEXT("System\\CurrentControlSet\\Services\\VxD\\VMM")
#define REGSTR_PATH_VPOWERD     TEXT("System\\CurrentControlSet\\Services\\VxD\\VPOWERD")
#define REGSTR_PATH_VNETSUP     TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define REGSTR_PATH_NWREDIR     TEXT("System\\CurrentControlSet\\Services\\VxD\\NWREDIR")
#define REGSTR_PATH_NCPSERVER   TEXT("System\\CurrentControlSet\\Services\\NcpServer\\Parameters")
#define REGSTR_PATH_VCOMM       TEXT("System\\CurrentControlSet\\Services\\VxD\\VCOMM")

#define REGSTR_PATH_IOARB       TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IOArb")
#define REGSTR_PATH_ADDRARB     TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\AddrArb")
#define REGSTR_PATH_DMAARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\DMAArb")
#define REGSTR_PATH_IRQARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IRQArb")

#define REGSTR_PATH_CODEPAGE                            TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage")
#define REGSTR_PATH_FILESYSTEM                          TEXT("System\\CurrentControlSet\\Control\\FileSystem")
#define REGSTR_PATH_FILESYSTEM_NOVOLTRACK       TEXT("System\\CurrentControlSet\\Control\\FileSystem\\NoVolTrack")
#define REGSTR_PATH_CDFS                                        TEXT("System\\CurrentControlSet\\Control\\FileSystem\\CDFS")
#define REGSTR_PATH_WINBOOT                                 TEXT("System\\CurrentControlSet\\Control\\WinBoot")
#define REGSTR_PATH_INSTALLEDFILES                      TEXT("System\\CurrentControlSet\\Control\\InstalledFiles")
#define REGSTR_PATH_VMM32FILES                          TEXT("System\\CurrentControlSet\\Control\\VMM32Files")

//
// Reasonable Limit for Values Names
//
#define REGSTR_MAX_VALUE_LENGTH     256

//
// Values used by user mode Pnp Manager
//

#define REGSTR_VAL_SLOTNUMBER                      TEXT("SlotNumber")
#define REGSTR_VAL_ATTACHEDCOMPONENTS              TEXT("AttachedComponents")
#define REGSTR_VAL_BASEDEVICEPATH                  TEXT("BaseDevicePath")
#define REGSTR_VAL_SYSTEMBUSNUMBER                 TEXT("SystemBusNumber")
#define REGSTR_VAL_BUSDATATYPE                     TEXT("BusDataType")
#define REGSTR_VAL_INTERFACETYPE                   TEXT("InterfaceType")
#define REGSTR_VAL_SERVICE                         TEXT("Service")
#define REGSTR_VAL_DETECTSIGNATURE                 TEXT("DetectSignature")
#define REGSTR_VAL_CLASSGUID                       TEXT("ClassGUID")
#define REGSTR_VAL_INSTANCEIDENTIFIER              TEXT("InstanceIdentifier")
#define REGSTR_VAL_DUPLICATEOF                     TEXT("DuplicateOf")
#define REGSTR_VAL_STATUSFLAGS                     TEXT("StatusFlags")
#define REGSTR_VAL_DISABLECOUNT                    TEXT("DisableCount")
#define REGSTR_VAL_UNKNOWNPROBLEMS                 TEXT("UnknownProblem")
#define REGSTR_VAL_DOCKSTATE                       TEXT("DockState")
#define REGSTR_VAL_PREFERENCEORDER                 TEXT("PreferenceOrder")
#define REGSTR_VAL_USERWAITINTERVAL                TEXT("UserWaitInterval")
#define REGSTR_VAL_DEVICE_INSTANCE                 TEXT("DeviceInstance")
#define REGSTR_VAL_SYMBOLIC_LINK                   TEXT("SymbolicLink")
#define REGSTR_VAL_DEFAULT                         TEXT("Default")
#define REGSTR_VAL_LOWERFILTERS                    TEXT("LowerFilters")
#define REGSTR_VAL_UPPERFILTERS                    TEXT("UpperFilters")
#define REGSTR_VAL_LOCATION_INFORMATION            TEXT("LocationInformation")
#define REGSTR_VAL_UI_NUMBER                       TEXT("UINumber")
#define REGSTR_VAL_UI_NUMBER_DESC_FORMAT           TEXT("UINumberDescFormat")
#define REGSTR_VAL_CAPABILITIES                    TEXT("Capabilities")
#define REGSTR_VAL_DEVICE_TYPE                     TEXT("DeviceType")
#define REGSTR_VAL_DEVICE_CHARACTERISTICS          TEXT("DeviceCharacteristics")
#define REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR      TEXT("Security")
#define REGSTR_VAL_DEVICE_EXCLUSIVE                TEXT("Exclusive")
#define REGSTR_KEY_DEVICE_PROPERTIES               TEXT("Properties")
#define REGSTR_VAL_RESOURCE_PICKER_TAGS            TEXT("ResourcePickerTags")
#define REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS      TEXT("ResourcePickerExceptions")

//
// Values used by kernel mode Pnp Manager
//

#define REGSTR_VALUE_DEVICE_OBJECT_NAME              TEXT("DeviceObjectName")
#define REGSTR_VALUE_DEVICE_SYMBOLIC_NAME            TEXT("DeviceSymbolicName")

//
// Values used by both kernel-mode and user-mode PnP Managers
//

#define REGSTR_KEY_CONTROL                           TEXT("Control")
#define REGSTR_VAL_ACTIVESERVICE                     TEXT("ActiveService")
#define REGSTR_VAL_LINKED                            TEXT("Linked")
#define REGSTR_VAL_PHYSICALDEVICEOBJECT              TEXT("PhysicalDeviceObject")

//
// Values under REGSTR_PATH_NT_CURRENTVERSION
//

#define REGSTR_VAL_CURRENT_VERSION  TEXT("CurrentVersion")
#define REGSTR_VAL_CURRENT_BUILD    TEXT("CurrentBuildNumber")
#define REGSTR_VAL_CURRENT_CSDVERSION TEXT("CSDVersion")
#define REGSTR_VAL_CURRENT_TYPE     TEXT("CurrentType")

//
// Values under REGSTR_PATH_DISPLAYSETTINGS
//

#define REGSTR_VAL_BITSPERPIXEL  TEXT("BitsPerPixel")
#define REGSTR_VAL_RESOLUTION    TEXT("Resolution")
#define REGSTR_VAL_DPILOGICALX   TEXT("DPILogicalX")
#define REGSTR_VAL_DPILOGICALY   TEXT("DPILogicalY")
#define REGSTR_VAL_DPIPHYSICALX  TEXT("DPIPhysicalX")
#define REGSTR_VAL_DPIPHYSICALY  TEXT("DPIPhysicalY")
#define REGSTR_VAL_REFRESHRATE   TEXT("RefreshRate")
#define REGSTR_VAL_DISPLAYFLAGS  TEXT("DisplayFlags")


// under HKEY_CURRENT_USER
#define REGSTR_PATH_CONTROLPANEL    TEXT("Control Panel")

// under HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROLSFOLDER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder")

//
// Entries under REGSTR_PATH_CODEPAGE
//

#define REGSTR_VAL_DOSCP        TEXT("OEMCP")
#define REGSTR_VAL_WINCP        TEXT("ACP")

#define REGSTR_PATH_DYNA_ENUM   TEXT("Config Manager\\Enum")

//
// Entries under REGSTR_PATH_DYNA_ENUM
//
#define REGSTR_VAL_HARDWARE_KEY TEXT("HardWareKey")
#define REGSTR_VAL_ALLOCATION   TEXT("Allocation")
#define REGSTR_VAL_PROBLEM      TEXT("Problem")
#define REGSTR_VAL_STATUS       TEXT("Status")

//
//  Used by address arbitrator
//
#define REGSTR_VAL_DONTUSEMEM   TEXT("DontAllocLastMem")

//
//  Entries under REGSTR_PATH_SETUP
//
#define REGSTR_VAL_SYSTEMROOT           TEXT("SystemRoot")
#define REGSTR_VAL_BOOTCOUNT            TEXT("BootCount")
#define REGSTR_VAL_REALNETSTART         TEXT("RealNetStart")
#define REGSTR_VAL_MEDIA                TEXT("MediaPath")
#define REGSTR_VAL_CONFIG               TEXT("ConfigPath")
#define REGSTR_VAL_DEVICEPATH           TEXT("DevicePath")      //default search path for .INFs
#define REGSTR_VAL_SRCPATH              TEXT("SourcePath")      //last source files path during setup.
#define REGSTR_VAL_SVCPAKSRCPATH        TEXT("ServicePackSourcePath") //last service pack source path
#define REGSTR_VAL_DRIVERCACHEPATH      TEXT("DriverCachePath") //location of driver cache

#define REGSTR_VAL_OLDWINDIR            TEXT("OldWinDir")       //old windows location
#define REGSTR_VAL_SETUPFLAGS           TEXT("SetupFlags")      //flags that setup passes on after install.
#define REGSTR_VAL_REGOWNER             TEXT("RegisteredOwner")
#define REGSTR_VAL_REGORGANIZATION      TEXT("RegisteredOrganization")
#define REGSTR_VAL_LICENSINGINFO        TEXT("LicensingInfo")
#define REGSTR_VAL_OLDMSDOSVER          TEXT("OldMSDOSVer") // will be DOS ver < 7 (when Setup run)
#define REGSTR_VAL_FIRSTINSTALLDATETIME TEXT("FirstInstallDateTime") // will Win 95 install date-time

#define REGSTR_VAL_INSTALLTYPE          TEXT("InstallType")

#define REGSTR_VAL_WRAPPER              TEXT("Wrapper")

#define REGSTR_VAL_LASTALIVEINTERVAL    TEXT("TimeStampInterval")
#define REGSTR_VAL_LASTALIVESTAMP       TEXT("LastAliveStamp")
#define REGSTR_VAL_SHUTDOWNREASON       TEXT("ShutdownReason")
#define REGSTR_VAL_SHUTDOWNREASON_CODE       	TEXT("ShutdownReasonCode")
#define REGSTR_VAL_SHUTDOWNREASON_COMMENT       TEXT("ShutdownReasonComment")
#define REGSTR_VAL_SHUTDOWNREASON_PROCESS       TEXT("ShutdownReasonProcess")
#define REGSTR_VAL_SHUTDOWNREASON_USERNAME      TEXT("ShutdownReasonUserName")
#define REGSTR_VAL_SHOWREASONUI         TEXT("ShutdownReasonUI")

//  Values for InstallType
#define IT_COMPACT          0x0000
#define IT_TYPICAL          0x0001
#define IT_PORTABLE         0x0002
#define IT_CUSTOM           0x0003

#define REGSTR_KEY_SETUP                TEXT("\\Setup")
#define REGSTR_VAL_BOOTDIR              TEXT("BootDir")
#define REGSTR_VAL_WINBOOTDIR           TEXT("WinbootDir")
#define REGSTR_VAL_WINDIR               TEXT("WinDir")

#define REGSTR_VAL_APPINSTPATH          TEXT("AppInstallPath")    // Used by install wizard

// Values for international startup disk
#define REGSTR_PATH_EBD          REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\EBD")
// Keys under REGSTR_KEY_EBD
#define REGSTR_KEY_EBDFILESLOCAL     TEXT("EBDFilesLocale")
#define REGSTR_KEY_EBDFILESKEYBOARD     TEXT("EBDFilesKeyboard")
#define REGSTR_KEY_EBDAUTOEXECBATLOCAL TEXT("EBDAutoexecBatLocale")
#define REGSTR_KEY_EBDAUTOEXECBATKEYBOARD TEXT("EBDAutoexecBatKeyboard")
#define REGSTR_KEY_EBDCONFIGSYSLOCAL   TEXT("EBDConfigSysLocale")
#define REGSTR_KEY_EBDCONFIGSYSKEYBOARD   TEXT("EBDConfigSysKeyboard")


// Values under REGSTR_PATH_DRIVERSIGN and REGSTR_PATH_NONDRIVERSIGN
#define REGSTR_VAL_POLICY                     TEXT("Policy")

// Values under REGSTR_PATH_DRIVERSIGN_POLICY and REGSTR_PATH_NONDRIVERSIGN_POLICY
#define REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY  TEXT("BehaviorOnFailedVerify")

// Types of driver signing policies (apply to both preference and policy values
// defined above)
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002

//
//  Entries under REGSTR_PATH_PIFCONVERT
//
#define REGSTR_VAL_MSDOSMODE            TEXT("MSDOSMode")
#define REGSTR_VAL_MSDOSMODEDISCARD     TEXT("Discard")

//
//  Entries under REGSTR_PATH_MSDOSOPTS (global settings)
//
#define REGSTR_VAL_DOSOPTGLOBALFLAGS    TEXT("GlobalFlags")
//  Flags for GlobalFlags
#define DOSOPTGF_DEFCLEAN   0x00000001L // Default action is clean config

//
//  Entries under REGSTR_PATH_MSDOSOPTS \ OptionSubkey
//
#define REGSTR_VAL_DOSOPTFLAGS          TEXT("Flags")
#define REGSTR_VAL_OPTORDER             TEXT("Order")
#define REGSTR_VAL_CONFIGSYS            TEXT("Config.Sys")
#define REGSTR_VAL_AUTOEXEC             TEXT("Autoexec.Bat")
#define REGSTR_VAL_STDDOSOPTION         TEXT("StdOption")
#define REGSTR_VAL_DOSOPTTIP            TEXT("TipText")

//  Flags for DOSOPTFLAGS
#define DOSOPTF_DEFAULT     0x00000001L // Default enabled for clean config
#define DOSOPTF_SUPPORTED   0x00000002L // Option actually supported
#define DOSOPTF_ALWAYSUSE   0x00000004L // Always use this option
#define DOSOPTF_USESPMODE   0x00000008L // Option puts machine in Prot Mode
#define DOSOPTF_PROVIDESUMB 0x00000010L // Can load drivers high
#define DOSOPTF_NEEDSETUP   0x00000020L // Need to configure option
#define DOSOPTF_INDOSSTART  0x00000040L // Suppored by DOSSTART.BAT
#define DOSOPTF_MULTIPLE    0x00000080L // Load multiple configuration lines

//
//  Flags returned by SUGetSetSetupFlags and in the registry
//
#define SUF_FIRSTTIME   0x00000001L // First boot into Win95.
#define SUF_EXPRESS     0x00000002L // User Setup via express mode (vs customize).
#define SUF_BATCHINF    0x00000004L // Setup using batch file (MSBATCH.INF).
#define SUF_CLEAN       0x00000008L // Setup was done to a clean directory.
#define SUF_INSETUP     0x00000010L // You're in Setup.
#define SUF_NETSETUP    0x00000020L // Doing a net (workstation) setup.
#define SUF_NETHDBOOT   0x00000040L // Workstation boots from local harddrive
#define SUF_NETRPLBOOT  0x00000080L // Workstation boots via RPL (vs floppy)
#define SUF_SBSCOPYOK   0x00000100L // Can copy to LDID_SHARED (SBS)

//
//  Entries under REGSTR_PATH_VMM
//
#define REGSTR_VAL_DOSPAGER     TEXT("DOSPager")
#define REGSTR_VAL_VXDGROUPS    TEXT("VXDGroups")

//
//  Entries under REGSTR_PATH_VPOWERD
//
#define REGSTR_VAL_VPOWERDFLAGS TEXT("Flags")
#define VPDF_DISABLEPWRMGMT         0x00000001  // Don't load device
#define VPDF_FORCEAPM10MODE         0x00000002  // Always go into 1.0 mode
#define VPDF_SKIPINTELSLCHECK       0x00000004  // Don't detect Intel SL chipset
#define VPDF_DISABLEPWRSTATUSPOLL   0x00000008  // Don't poll power status
#define VPDF_DISABLERINGRESUME      0x00000010  // Don't let the modem wake the machine (APM 1.2 only)
#define VPDF_SHOWMULTIBATT          0x00000020  // Show all batteries checkbox in power control panel

//
// Entries under REGSTR_PATH_BUSINFORMATION
//
#define BIF_SHOWSIMILARDRIVERS      0x00000001  // Show similar drivers instead of all class drivers in UI.

//
//  Entries under REGSTR_PATH_VNETSUP
//
#define REGSTR_VAL_WORKGROUP TEXT("Workgroup")
#define REGSTR_VAL_DIRECTHOST TEXT("DirectHost")
#define REGSTR_VAL_FILESHARING          TEXT("FileSharing")
#define REGSTR_VAL_PRINTSHARING         TEXT("PrintSharing")

//
//  Entries under REGSTR_PATH_NWREDIR
//
#define REGSTR_VAL_FIRSTNETDRIVE        TEXT("FirstNetworkDrive")
#define REGSTR_VAL_MAXCONNECTIONS       TEXT("MaxConnections")
#define REGSTR_VAL_APISUPPORT           TEXT("APISupport")
#define REGSTR_VAL_MAXRETRY             TEXT("MaxRetry")
#define REGSTR_VAL_MINRETRY             TEXT("MinRetry")
#define REGSTR_VAL_SUPPORTLFN           TEXT("SupportLFN")
#define REGSTR_VAL_SUPPORTBURST         TEXT("SupportBurst")
#define REGSTR_VAL_SUPPORTTUNNELLING    TEXT("SupportTunnelling")
#define REGSTR_VAL_FULLTRACE            TEXT("FullTrace")
#define REGSTR_VAL_READCACHING          TEXT("ReadCaching")
#define REGSTR_VAL_SHOWDOTS             TEXT("ShowDots")
#define REGSTR_VAL_GAPTIME              TEXT("GapTime")
#define REGSTR_VAL_SEARCHMODE           TEXT("SearchMode")
#define REGSTR_VAL_SHELLVERSION     TEXT("ShellVersion")
#define REGSTR_VAL_MAXLIP           TEXT("MaxLIP")
#define REGSTR_VAL_PRESERVECASE     TEXT("PreserveCase")
#define REGSTR_VAL_OPTIMIZESFN      TEXT("OptimizeSFN")

//
//  Entries under REGSTR_PATH_NCPSERVER
//
#define REGSTR_VAL_NCP_BROWSEMASTER     TEXT("BrowseMaster")
#define REGSTR_VAL_NCP_USEPEERBROWSING  TEXT("Use_PeerBrowsing")
#define REGSTR_VAL_NCP_USESAP           TEXT("Use_Sap")

//
// Entries under REGSTR_PATH_VCOMM
//

#define REGSTR_VAL_PCCARD_POWER         TEXT("EnablePowerManagement")

//
//  Entries under REGSTR_PATH_FILESYSTEM
//
#define REGSTR_VAL_WIN31FILESYSTEM              TEXT("Win31FileSystem")
#define REGSTR_VAL_PRESERVELONGNAMES            TEXT("PreserveLongNames")
#define REGSTR_VAL_DRIVEWRITEBEHIND             TEXT("DriveWriteBehind")
#define REGSTR_VAL_ASYNCFILECOMMIT              TEXT("AsyncFileCommit")
#define REGSTR_VAL_PATHCACHECOUNT               TEXT("PathCache")
#define REGSTR_VAL_NAMECACHECOUNT               TEXT("NameCache")
#define REGSTR_VAL_CONTIGFILEALLOC              TEXT("ContigFileAllocSize")
#define REGSTR_VAL_FREESPACERATIO               TEXT("FreeSpaceRatio")
#define REGSTR_VAL_VOLIDLETIMEOUT               TEXT("VolumeIdleTimeout")
#define REGSTR_VAL_BUFFIDLETIMEOUT              TEXT("BufferIdleTimeout")
#define REGSTR_VAL_BUFFAGETIMEOUT               TEXT("BufferAgeTimeout")
#define REGSTR_VAL_NAMENUMERICTAIL              TEXT("NameNumericTail")
#define REGSTR_VAL_READAHEADTHRESHOLD           TEXT("ReadAheadThreshold")
#define REGSTR_VAL_DOUBLEBUFFER                 TEXT("DoubleBuffer")
#define REGSTR_VAL_SOFTCOMPATMODE               TEXT("SoftCompatMode")
#define REGSTR_VAL_DRIVESPINDOWN                TEXT("DriveSpinDown")
#define REGSTR_VAL_FORCEPMIO                    TEXT("ForcePMIO")
#define REGSTR_VAL_FORCERMIO                    TEXT("ForceRMIO")
#define REGSTR_VAL_LASTBOOTPMDRVS               TEXT("LastBootPMDrvs")
#define REGSTR_VAL_ACSPINDOWNPREVIOUS           TEXT("ACSpinDownPrevious")
#define REGSTR_VAL_BATSPINDOWNPREVIOUS          TEXT("BatSpinDownPrevious")
#define REGSTR_VAL_VIRTUALHDIRQ                 TEXT("VirtualHDIRQ")
#define REGSTR_VAL_SRVNAMECACHECOUNT            TEXT("ServerNameCacheMax")
#define REGSTR_VAL_SRVNAMECACHE                 TEXT("ServerNameCache")
#define REGSTR_VAL_SRVNAMECACHENETPROV          TEXT("ServerNameCacheNumNets")
#define REGSTR_VAL_AUTOMOUNT                    TEXT("AutoMountDrives")
#define REGSTR_VAL_COMPRESSIONMETHOD            TEXT("CompressionAlgorithm")
#define REGSTR_VAL_COMPRESSIONTHRESHOLD         TEXT("CompressionThreshold")
#define REGSTR_VAL_ACDRIVESPINDOWN              TEXT("ACDriveSpinDown")
#define REGSTR_VAL_BATDRIVESPINDOWN             TEXT("BatDriveSpinDown")

//
//      Entries under REGSTR_PATH_FILESYSTEM_NOVOLTRACK
//
//      A sub-key under which a variable number of variable length structures are stored.
//
//      Each structure contains an offset followed by a number of pattern bytes.
//      The pattern in each structure is compared at the specified offset within
//      the boot record at the time a volume is mounted.  If any pattern in this
//      set of patterns matches a pattern already in the boot record, VFAT will not
//      write a volume tracking serial number in the OEM_SerialNum field of the
//      boot record on the volume being mounted.
//

//
//  Entries under REGSTR_PATH_CDFS
//
#define REGSTR_VAL_CDCACHESIZE  TEXT("CacheSize")       // Number of 2K cache sectors
#define REGSTR_VAL_CDPREFETCH   TEXT("Prefetch")        // Number of 2K cache sectors for prefetching
#define REGSTR_VAL_CDPREFETCHTAIL TEXT("PrefetchTail")// Number of LRU1 prefetch sectors
#define REGSTR_VAL_CDRAWCACHE   TEXT("RawCache")        // Number of 2352-byte cache sectors
#define REGSTR_VAL_CDEXTERRORS  TEXT("ExtendedErrors")// Return extended error codes
#define REGSTR_VAL_CDSVDSENSE   TEXT("SVDSense")        // 0=PVD, 1=Kanji, 2=Unicode
#define REGSTR_VAL_CDSHOWVERSIONS TEXT("ShowVersions")// Show file version numbers
#define REGSTR_VAL_CDCOMPATNAMES TEXT("MSCDEXCompatNames")// Disable Numeric Tails on long file names
#define REGSTR_VAL_CDNOREADAHEAD TEXT("NoReadAhead")    // Disable Read Ahead if set to 1

//
//      define values for IOS devices
//
#define REGSTR_VAL_SCSI TEXT("SCSI\\")
#define REGSTR_VAL_ESDI TEXT("ESDI\\")
#define REGSTR_VAL_FLOP TEXT("FLOP\\")

//
// define defs for IOS device types and values for IOS devices
//

#define REGSTR_VAL_DISK TEXT("GenDisk")
#define REGSTR_VAL_CDROM        TEXT("GenCD")
#define REGSTR_VAL_TAPE TEXT("TAPE")
#define REGSTR_VAL_SCANNER TEXT("SCANNER")
#define REGSTR_VAL_FLOPPY       TEXT("FLOPPY")

#define REGSTR_VAL_SCSITID TEXT("SCSITargetID")
#define REGSTR_VAL_SCSILUN TEXT("SCSILUN")
#define REGSTR_VAL_REVLEVEL TEXT("RevisionLevel")
#define REGSTR_VAL_PRODUCTID TEXT("ProductId")
#define REGSTR_VAL_PRODUCTTYPE TEXT("ProductType")
#define REGSTR_VAL_DEVTYPE TEXT("DeviceType")
#define REGSTR_VAL_REMOVABLE TEXT("Removable")
#define  REGSTR_VAL_CURDRVLET TEXT("CurrentDriveLetterAssignment")
#define REGSTR_VAL_USRDRVLET TEXT("UserDriveLetterAssignment")
#define REGSTR_VAL_SYNCDATAXFER TEXT("SyncDataXfer")
#define REGSTR_VAL_AUTOINSNOTE  TEXT("AutoInsertNotification")
#define REGSTR_VAL_DISCONNECT TEXT("Disconnect")
#define REGSTR_VAL_INT13 TEXT("Int13")
#define REGSTR_VAL_PMODE_INT13 TEXT("PModeInt13")
#define REGSTR_VAL_USERSETTINGS TEXT("AdapterSettings")
#define REGSTR_VAL_NOIDE TEXT("NoIDE")

// The foll. clase name definitions should be the same as in dirkdrv.inx and
// cdrom.inx
#define REGSTR_VAL_DISKCLASSNAME        TEXT("DiskDrive")
#define REGSTR_VAL_CDROMCLASSNAME       TEXT("CDROM")

// The foll. value determines whether a port driver should be force loaded
// or not.

#define REGSTR_VAL_FORCELOAD    TEXT("ForceLoadPD")

// The foll. value determines whether or not the FIFO is used on the Floppy
// controller.

#define REGSTR_VAL_FORCEFIFO    TEXT("ForceFIFO")
#define REGSTR_VAL_FORCECL              TEXT("ForceChangeLine")

//
// Generic CLASS Entries
//
#define REGSTR_VAL_NOUSECLASS       TEXT("NoUseClass")            // Don't include this class in PnP functions
#define REGSTR_VAL_NOINSTALLCLASS   TEXT("NoInstallClass")        // Don't include this class in New Device Wizard
#define REGSTR_VAL_NODISPLAYCLASS   TEXT("NoDisplayClass")        // Don't include this class in Device Manager
#define REGSTR_VAL_SILENTINSTALL    TEXT("SilentInstall")         // Always Silent Install devices of this class.
//
//  Class Names
//
#define REGSTR_KEY_PCMCIA_CLASS     TEXT("PCMCIA")              //child of PATH_CLASS
#define REGSTR_KEY_SCSI_CLASS       TEXT("SCSIAdapter")
#define REGSTR_KEY_PORTS_CLASS      TEXT("ports")
#define REGSTR_KEY_MEDIA_CLASS      TEXT("MEDIA")
#define REGSTR_KEY_DISPLAY_CLASS    TEXT("Display")
#define REGSTR_KEY_KEYBOARD_CLASS   TEXT("Keyboard")
#define REGSTR_KEY_MOUSE_CLASS      TEXT("Mouse")
#define REGSTR_KEY_MONITOR_CLASS    TEXT("Monitor")
#define REGSTR_KEY_MODEM_CLASS      TEXT("Modem")

//
//  Values under PATH_CLASS\PCMCIA
//
#define REGSTR_VAL_PCMCIA_OPT   TEXT("Options")
#define PCMCIA_OPT_HAVE_SOCKET  0x00000001l
//#define PCMCIA_OPT_ENABLED    0x00000002l
#define PCMCIA_OPT_AUTOMEM      0x00000004l
#define PCMCIA_OPT_NO_SOUND     0x00000008l
#define PCMCIA_OPT_NO_AUDIO     0x00000010l
#define PCMCIA_OPT_NO_APMREMOVE 0x00000020l

#define REGSTR_VAL_PCMCIA_MEM   TEXT("Memory")  // Card services shared mem range
#define PCMCIA_DEF_MEMBEGIN     0x000C0000      // default 0xC0000 - 0x00FFFFFF
#define PCMCIA_DEF_MEMEND       0x00FFFFFF      // (0 - 16meg)
#define PCMCIA_DEF_MEMLEN       0x00001000      // default 4k window

#define REGSTR_VAL_PCMCIA_ALLOC TEXT("AllocMemWin")     // PCCard alloced memory Window
#define REGSTR_VAL_PCMCIA_ATAD  TEXT("ATADelay")        // ATA device config start delay

#define REGSTR_VAL_PCMCIA_SIZ   TEXT("MinRegionSize") // Minimum region size
#define PCMCIA_DEF_MIN_REGION   0x00010000      // 64K minimum region size

// Values in LPTENUM keys
#define REGSTR_VAL_P1284MDL     TEXT("Model")
#define REGSTR_VAL_P1284MFG     TEXT("Manufacturer")

//
//  Values under PATH_CLASS\ISAPNP
//
#define REGSTR_VAL_ISAPNP               TEXT("ISAPNP")  // ISAPNP VxD name
#define REGSTR_VAL_ISAPNP_RDP_OVERRIDE  TEXT("RDPOverRide")     // ReadDataPort OverRide

//
//  Values under PATH_CLASS\PCI
//
#define REGSTR_VAL_PCI                  TEXT("PCI")             // PCI VxD name
#define REGSTR_PCI_OPTIONS              TEXT("Options") // Possible PCI options
#define REGSTR_PCI_DUAL_IDE             TEXT("PCIDualIDE")      // Dual IDE flag
#define PCI_OPTIONS_USE_BIOS            0x00000001l
#define PCI_OPTIONS_USE_IRQ_STEERING    0x00000002l

#define PCI_FLAG_NO_VIDEO_IRQ           0x00000001l
#define PCI_FLAG_PCMCIA_WANT_IRQ        0x00000002l
#define PCI_FLAG_DUAL_IDE               0x00000004l
#define PCI_FLAG_NO_ENUM_AT_ALL         0x00000008l
#define PCI_FLAG_ENUM_NO_RESOURCE       0x00000010l
#define PCI_FLAG_NEED_DWORD_ACCESS      0x00000020l
#define PCI_FLAG_SINGLE_FUNCTION        0x00000040l
#define PCI_FLAG_ALWAYS_ENABLED         0x00000080l
#define PCI_FLAG_IS_IDE                 0x00000100l
#define PCI_FLAG_IS_VIDEO               0x00000200l
#define PCI_FLAG_FAIL_START             0x00000400l
#define PCI_FLAG_GHOST                  0x00000800l
#define PCI_FLAG_DOUBLE_DECKER          0x00001000l
#define PCI_FLAG_ONE_CHILD              0x00002000l
#define PCI_FLAG_PRESERVE_COMMAND       0x00004000l
#define PCI_FLAG_IS_VGA                 0x00008000l
#define PCI_FLAG_CB_SHARE_CMD_BITS      0x00010000l
#define PCI_FLAG_STRAIGHT_IRQ_ROUTING   0x00020000l
#define PCI_FLAG_SUBTRACTIVE_DECODE     0x00040000l
#define PCI_FLAG_FDMA_ISA               0x00080000l
#define PCI_FLAG_EXCLUSIVE              0x00100000l
#define PCI_FLAG_EDGE                   0x00200000l
#define PCI_FLAG_NO_SUBSYSTEM           0x00400000l
#define PCI_FLAG_NO_WPE                 0x00800000l
#define PCI_FLAG_OLD_ID                 0x01000000l
#define PCI_FLAG_DONT_SHRINK_BRIDGE     0x02000000l
#define PCI_FLAG_TURN_OFF_PARITY        0x04000000l
#define PCI_FLAG_NO_NON_PCI_CHILD_BAR   0x08000000l
#define PCI_FLAG_NO_ENUM_WITH_DISABLE   0x10000000l
#define PCI_FLAG_NO_PM_CAPS             0x20000000l
#define PCI_FLAG_NO_DISABLE_DECODES     0x40000000l
#define PCI_FLAG_NO_SUBSYSTEM_AFTER_D3  0x80000000l
#define PCI_FLAG_VIDEO_LEGACY_DECODE    0x0000000100000000L

//
//  Values under PATH_CLASS\AGPxxxx
//
#define AGP_FLAG_NO_AGP                 0x00000001l
#define AGP_FLAG_NO_1X_RATE             0x00000002l
#define AGP_FLAG_NO_2X_RATE             0x00000004l
#define AGP_FLAG_NO_4X_RATE             0x00000008l

#define AGP_FLAG_NO_SBA_ENABLE          0x00000100l

//
// Detection related values
//
#define REGSTR_KEY_CRASHES      TEXT("Crashes") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DANGERS      TEXT("Dangers") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DETMODVARS   TEXT("DetModVars")      // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_NDISINFO     TEXT("NDISInfo")        // key of netcard hw entry
#define REGSTR_VAL_PROTINIPATH  TEXT("ProtIniPath")     // protocol.ini path
#define REGSTR_VAL_RESOURCES    TEXT("Resources")       // resources of crash func.
#define REGSTR_VAL_CRASHFUNCS   TEXT("CrashFuncs")      // detfunc caused the crash
#define REGSTR_VAL_CLASS        TEXT("Class")   // device class
#define REGSTR_VAL_DEVDESC      TEXT("DeviceDesc")      // device description
#define REGSTR_VAL_BOOTCONFIG   TEXT("BootConfig")      // detected configuration
#define REGSTR_VAL_DETFUNC      TEXT("DetFunc") // specifies detect mod/func.
#define REGSTR_VAL_DETFLAGS     TEXT("DetFlags")        // detection flags
#define REGSTR_VAL_COMPATIBLEIDS TEXT("CompatibleIDs") //value of enum\dev\inst
#define REGSTR_VAL_DETCONFIG    TEXT("DetConfig")       // detected configuration
#define REGSTR_VAL_VERIFYKEY    TEXT("VerifyKey")       // key used in verify mode
#define REGSTR_VAL_COMINFO      TEXT("ComInfo") // com info. for serial mouse
#define REGSTR_VAL_INFNAME      TEXT("InfName") // INF filename
#define REGSTR_VAL_CARDSPECIFIC TEXT("CardSpecific")    // Netcard specific info (WORD)
#define REGSTR_VAL_NETOSTYPE    TEXT("NetOSType")       // NetOS type associate w/ card
#define REGSTR_DATA_NETOS_NDIS  TEXT("NDIS")            // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_ODI   TEXT("ODI")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_IPX   TEXT("IPX")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_VAL_MFG      TEXT("Mfg")
#define REGSTR_VAL_SCAN_ONLY_FIRST      TEXT("ScanOnlyFirstDrive")      // used with IDE driver
#define REGSTR_VAL_SHARE_IRQ    TEXT("ForceIRQSharing") // used with IDE driver
#define REGSTR_VAL_NONSTANDARD_ATAPI    TEXT("NonStandardATAPI")        // used with IDE driver
#define REGSTR_VAL_IDE_FORCE_SERIALIZE  TEXT("ForceSerialization")      // used with IDE driver
#define REGSTR_VAL_MAX_HCID_LEN 1024            // Maximum hardware/compat ID len
#define REGSTR_VAL_HWREV            TEXT("HWRevision")
#define REGSTR_VAL_ENABLEINTS  TEXT("EnableInts")
//
// Bit values of REGSTR_VAL_DETFLAGS
//
#define REGDF_NOTDETIO          0x00000001      //cannot detect I/O resource
#define REGDF_NOTDETMEM         0x00000002      //cannot detect mem resource
#define REGDF_NOTDETIRQ         0x00000004      //cannot detect IRQ resource
#define REGDF_NOTDETDMA         0x00000008      //cannot detect DMA resource
#define REGDF_NOTDETALL         (REGDF_NOTDETIO | REGDF_NOTDETMEM | REGDF_NOTDETIRQ | REGDF_NOTDETDMA)
#define REGDF_NEEDFULLCONFIG    0x00000010      //stop devnode if lack resource
#define REGDF_GENFORCEDCONFIG   0x00000020      //also generate forceconfig
#define REGDF_NODETCONFIG       0x00008000      //don't write detconfig to reg.
#define REGDF_CONFLICTIO        0x00010000      //I/O res. in conflict
#define REGDF_CONFLICTMEM       0x00020000      //mem res. in conflict
#define REGDF_CONFLICTIRQ       0x00040000      //IRQ res. in conflict
#define REGDF_CONFLICTDMA       0x00080000      //DMA res. in conflict
#define REGDF_CONFLICTALL       (REGDF_CONFLICTIO | REGDF_CONFLICTMEM | REGDF_CONFLICTIRQ | REGDF_CONFLICTDMA)
#define REGDF_MAPIRQ2TO9        0x00100000      //IRQ2 has been mapped to 9
#define REGDF_NOTVERIFIED       0x80000000      //previous device unverified

//
//  Values in REGSTR_KEY_SYSTEMBOARD
//
#define REGSTR_VAL_APMBIOSVER           TEXT("APMBiosVer")
#define REGSTR_VAL_APMFLAGS             TEXT("APMFlags")
#define REGSTR_VAL_SLSUPPORT            TEXT("SLSupport")
#define REGSTR_VAL_MACHINETYPE          TEXT("MachineType")
#define REGSTR_VAL_SETUPMACHINETYPE TEXT("SetupMachineType")
#define REGSTR_MACHTYPE_UNKNOWN         TEXT("Unknown")
#define REGSTR_MACHTYPE_IBMPC           TEXT("IBM PC")
#define REGSTR_MACHTYPE_IBMPCJR         TEXT("IBM PCjr")
#define REGSTR_MACHTYPE_IBMPCCONV       TEXT("IBM PC Convertible")
#define REGSTR_MACHTYPE_IBMPCXT         TEXT("IBM PC/XT")
#define REGSTR_MACHTYPE_IBMPCXT_286     TEXT("IBM PC/XT 286")
#define REGSTR_MACHTYPE_IBMPCAT         TEXT("IBM PC/AT")
#define REGSTR_MACHTYPE_IBMPS2_25       TEXT("IBM PS/2-25")
#define REGSTR_MACHTYPE_IBMPS2_30_286   TEXT("IBM PS/2-30 286")
#define REGSTR_MACHTYPE_IBMPS2_30       TEXT("IBM PS/2-30")
#define REGSTR_MACHTYPE_IBMPS2_50       TEXT("IBM PS/2-50")
#define REGSTR_MACHTYPE_IBMPS2_50Z      TEXT("IBM PS/2-50Z")
#define REGSTR_MACHTYPE_IBMPS2_55SX     TEXT("IBM PS/2-55SX")
#define REGSTR_MACHTYPE_IBMPS2_60       TEXT("IBM PS/2-60")
#define REGSTR_MACHTYPE_IBMPS2_65SX     TEXT("IBM PS/2-65SX")
#define REGSTR_MACHTYPE_IBMPS2_70       TEXT("IBM PS/2-70")
#define REGSTR_MACHTYPE_IBMPS2_P70      TEXT("IBM PS/2-P70")
#define REGSTR_MACHTYPE_IBMPS2_70_80    TEXT("IBM PS/2-70/80")
#define REGSTR_MACHTYPE_IBMPS2_80       TEXT("IBM PS/2-80")
#define REGSTR_MACHTYPE_IBMPS2_90       TEXT("IBM PS/2-90")
#define REGSTR_MACHTYPE_IBMPS1          TEXT("IBM PS/1")
#define REGSTR_MACHTYPE_PHOENIX_PCAT    TEXT("Phoenix PC/AT Compatible")
#define REGSTR_MACHTYPE_HP_VECTRA       TEXT("HP Vectra")
#define REGSTR_MACHTYPE_ATT_PC          TEXT("AT&T PC")
#define REGSTR_MACHTYPE_ZENITH_PC       TEXT("Zenith PC")

#define REGSTR_VAL_APMMENUSUSPEND       TEXT("APMMenuSuspend")
#define APMMENUSUSPEND_DISABLED         0                   // always disabled
#define APMMENUSUSPEND_ENABLED          1                   // always enabled
#define APMMENUSUSPEND_UNDOCKED         2                   // enabled undocked
#define APMMENUSUSPEND_NOCHANGE     0x80        // bitflag - cannot change setting via UI

#define REGSTR_VAL_APMACTIMEOUT         TEXT("APMACTimeout")
#define REGSTR_VAL_APMBATTIMEOUT        TEXT("APMBatTimeout")
#define APMTIMEOUT_DISABLED             0

#define REGSTR_VAL_APMSHUTDOWNPOWER TEXT("APMShutDownPower")

#define REGSTR_VAL_BUSTYPE          TEXT("BusType")
#define REGSTR_VAL_CPU              TEXT("CPU")
#define REGSTR_VAL_NDP              TEXT("NDP")
#define REGSTR_VAL_PNPBIOSVER       TEXT("PnPBIOSVer")
#define REGSTR_VAL_PNPSTRUCOFFSET   TEXT("PnPStrucOffset")
#define REGSTR_VAL_PCIBIOSVER       TEXT("PCIBIOSVer")
#define REGSTR_VAL_HWMECHANISM      TEXT("HWMechanism")
#define REGSTR_VAL_LASTPCIBUSNUM    TEXT("LastPCIBusNum")
#define REGSTR_VAL_CONVMEM          TEXT("ConvMem")
#define REGSTR_VAL_EXTMEM           TEXT("ExtMem")
#define REGSTR_VAL_COMPUTERNAME     TEXT("ComputerName")
#define REGSTR_VAL_BIOSNAME         TEXT("BIOSName")
#define REGSTR_VAL_BIOSVERSION      TEXT("BIOSVersion")
#define REGSTR_VAL_BIOSDATE         TEXT("BIOSDate")
#define REGSTR_VAL_MODEL            TEXT("Model")
#define REGSTR_VAL_SUBMODEL         TEXT("Submodel")
#define REGSTR_VAL_REVISION         TEXT("Revision")

//
//  Values used in the LPT(ECP) device entry
//
#define REGSTR_VAL_FIFODEPTH            TEXT("FIFODepth")
#define REGSTR_VAL_RDINTTHRESHOLD       TEXT("RDIntThreshold")
#define REGSTR_VAL_WRINTTHRESHOLD       TEXT("WRIntThreshold")

//used in enum\xxx\<devname>\<instname>
#define REGSTR_VAL_PRIORITY     TEXT("Priority")
#define REGSTR_VAL_DRIVER       TEXT("Driver")          //
#define REGSTR_VAL_FUNCDESC     TEXT("FunctionDesc")            //
#define REGSTR_VAL_FORCEDCONFIG TEXT("ForcedConfig")            //
#define REGSTR_VAL_CONFIGFLAGS  TEXT("ConfigFlags")             // (binary ULONG)
#define REGSTR_VAL_CSCONFIGFLAGS TEXT("CSConfigFlags")  // (binary ULONG)

#define CONFIGFLAG_DISABLED             0x00000001      // Set if disabled
#define CONFIGFLAG_REMOVED              0x00000002      // Set if a present hardware enum device deleted
#define CONFIGFLAG_MANUAL_INSTALL       0x00000004      // Set if the devnode was manually installed
#define CONFIGFLAG_IGNORE_BOOT_LC       0x00000008      // Set if skip the boot config
#define CONFIGFLAG_NET_BOOT             0x00000010      // Load this devnode when in net boot
#define CONFIGFLAG_REINSTALL            0x00000020      // Redo install
#define CONFIGFLAG_FAILEDINSTALL        0x00000040      // Failed the install
#define CONFIGFLAG_CANTSTOPACHILD       0x00000080      // Can't stop/remove a single child
#define CONFIGFLAG_OKREMOVEROM          0x00000100      // Can remove even if rom.
#define CONFIGFLAG_NOREMOVEEXIT         0x00000200      // Don't remove at exit.
#define CONFIGFLAG_FINISH_INSTALL       0x00000400      // Complete install for devnode running 'raw'
#define CONFIGFLAG_NEEDS_FORCED_CONFIG  0x00000800      // This devnode requires a forced config
#if defined(REMOTE_BOOT)
#define CONFIGFLAG_NETBOOT_CARD         0x00001000      // This is the remote boot network card
#endif // defined(REMOTE_BOOT)
#define CONFIGFLAG_PARTIAL_LOG_CONF     0x00002000      // This device has a partial logconfig

#define CSCONFIGFLAG_BITS               0x00000007      // OR of below bits
#define CSCONFIGFLAG_DISABLED           0x00000001      // Set if
#define CSCONFIGFLAG_DO_NOT_CREATE      0x00000002      // Set if
#define CSCONFIGFLAG_DO_NOT_START       0x00000004      // Set if

#define DMSTATEFLAG_APPLYTOALL      0x00000001  // Set if Apply To All check box is checked

//
// Special devnodes name
//
#define REGSTR_VAL_ROOT_DEVNODE         TEXT("HTREE\\ROOT\\0")
#define REGSTR_VAL_RESERVED_DEVNODE     TEXT("HTREE\\RESERVED\\0")
#define REGSTR_PATH_READDATAPORT        REGSTR_KEY_ISAENUM TEXT("\\ReadDataPort\\0")

//
// Multifunction definitions
//
#define REGSTR_PATH_MULTI_FUNCTION              TEXT("MF")
#define REGSTR_VAL_RESOURCE_MAP                 TEXT("ResourceMap")
#define REGSTR_PATH_CHILD_PREFIX                TEXT("Child")
#define NUM_RESOURCE_MAP                        256
#define REGSTR_VAL_MF_FLAGS                     TEXT("MFFlags")
#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

//
// EISA multi functions add-on
//
#ifndef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("EISARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("EISAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("EISAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("EISAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("EISASimulateInt15")
#else // ifdef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("NESARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("NESAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("NESAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("NESAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("NESASimulateInt15")
#endif // ifdef NEC_98
#define EISAFLAG_NO_IO_MERGE            0x00000001
#define EISAFLAG_SLOT_IO_FIRST          0x00000002
#define EISA_NO_MAX_FUNCTION            0xFF
#define NUM_EISA_RANGES                 4


//
//  Driver entries
//
#define REGSTR_VAL_DRVDESC      TEXT("DriverDesc")      // value of enum\dev\inst\DRV
#define REGSTR_VAL_DEVLOADER    TEXT("DevLoader")       // value of DRV
#define REGSTR_VAL_STATICVXD    TEXT("StaticVxD")       // value of DRV
#define REGSTR_VAL_PROPERTIES   TEXT("Properties")      // value of DRV
#define REGSTR_VAL_MANUFACTURER TEXT("Manufacturer")
#define REGSTR_VAL_EXISTS       TEXT("Exists")  // value of HCC\HW\ENUM\ROOT\dev\inst
#define REGSTR_VAL_CMENUMFLAGS  TEXT("CMEnumFlags")     // (binary ULONG)
#define REGSTR_VAL_CMDRIVFLAGS  TEXT("CMDrivFlags")     // (binary ULONG)
#define REGSTR_VAL_ENUMERATOR   TEXT("Enumerator")      // value of DRV
#define REGSTR_VAL_DEVICEDRIVER TEXT("DeviceDriver")    // value of DRV
#define REGSTR_VAL_PORTNAME     TEXT("PortName")        // VCOMM uses this for it's port names
#define REGSTR_VAL_INFPATH      TEXT("InfPath")
#define REGSTR_VAL_INFSECTION   TEXT("InfSection")
#define REGSTR_VAL_INFSECTIONEXT TEXT("InfSectionExt")
#define REGSTR_VAL_POLLING      TEXT("Polling")             // SCSI specific
#define REGSTR_VAL_DONTLOADIFCONFLICT TEXT("DontLoadIfConflict")  // SCSI specific
#define REGSTR_VAL_PORTSUBCLASS TEXT("PortSubClass")
#define REGSTR_VAL_NETCLEAN TEXT("NetClean") // Driver required for NetClean boot
#define REGSTR_VAL_IDE_NO_SERIALIZE TEXT("IDENoSerialize") // IDE specific
#define REGSTR_VAL_NOCMOSORFDPT TEXT("NoCMOSorFDPT")       // IDE specific
#define REGSTR_VAL_COMVERIFYBASE TEXT("COMVerifyBase")     // VCD specific
#define REGSTR_VAL_MATCHINGDEVID TEXT("MatchingDeviceId")
#define REGSTR_VAL_DRIVERDATE   TEXT("DriverDate")      // value of DRV
#define REGSTR_VAL_DRIVERDATEDATA TEXT("DriverDateData")// value of DRV
#define REGSTR_VAL_DRIVERVERSION TEXT("DriverVersion")  // value of DRV
#define REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE    TEXT("LocationInformationOverride")  // value of DRV


//
//  Driver keys
//
#define REGSTR_KEY_OVERRIDE     TEXT("Override")        // key under the software section

//used by CONFIGMG
#define REGSTR_VAL_CONFIGMG     TEXT("CONFIGMG")        // Config Manager VxD name
#define REGSTR_VAL_SYSDM        TEXT("SysDM")           // The device installer DLL
#define REGSTR_VAL_SYSDMFUNC    TEXT("SysDMFunc")       // The device installer DLL function
#define REGSTR_VAL_PRIVATE      TEXT("Private") // The private library
#define REGSTR_VAL_PRIVATEFUNC  TEXT("PrivateFunc")     // The private library function
#define REGSTR_VAL_DETECT       TEXT("Detect")  // The detection library
#define REGSTR_VAL_DETECTFUNC   TEXT("DetectFunc")      // The detection library function
#define REGSTR_VAL_ASKFORCONFIG TEXT("AskForConfig")    // The AskForConfig library
#define REGSTR_VAL_ASKFORCONFIGFUNC TEXT("AskForConfigFunc") // The AskForConfig library function
#define REGSTR_VAL_WAITFORUNDOCK TEXT("WaitForUndock")  // The WaitForUndock library
#define REGSTR_VAL_WAITFORUNDOCKFUNC TEXT("WaitForUndockFunc") // The WaitForUndock library function
#define REGSTR_VAL_REMOVEROMOKAY TEXT("RemoveRomOkay")  // The RemoveRomOkay library
#define REGSTR_VAL_REMOVEROMOKAYFUNC TEXT("RemoveRomOkayFunc") // The RemoveRomOkay library function

//used in IDCONFIGDB
#define REGSTR_VAL_CURCONFIG    TEXT("CurrentConfig")           //value of idconfigdb
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")            //value of idconfigdb
#define REGSTR_VAL_CURRENTCONFIG TEXT("CurrentConfig")  //value of idconfigdb
#define REGSTR_VAL_MAP          TEXT("Map")                     //value of idconfigdb
#define REGSTR_VAL_ID           TEXT("CurrentID")               //value of idconfigdb
#define REGSTR_VAL_DOCKED       TEXT("CurrentDockedState")      //value of idconfigdb
#define REGSTR_VAL_CHECKSUM     TEXT("CurrentChecksum") //value of idconfigdb
#define REGSTR_VAL_HWDETECT     TEXT("HardwareDetect")  //value of idconfigdb
#define REGSTR_VAL_INHIBITRESULTS TEXT("InhibitResults")        //value of idconfigdb

//used in HKEY_CURRENT_CONFIG
#define REGSTR_VAL_PROFILEFLAGS TEXT("ProfileFlags")    // value of HKEY_CURRENT_CONFIG

//used in PCMCIA
#define REGSTR_KEY_PCMCIA       TEXT("PCMCIA\\")        //PCMCIA dev ID prefix
#define REGSTR_KEY_PCUNKNOWN    TEXT("UNKNOWN_MANUFACTURER")    //PCMCIA dev ID manuf
#define REGSTR_VAL_PCSSDRIVER   TEXT("Driver")  //value of DRV
#define REGSTR_KEY_PCMTD        TEXT("MTD-")            //MTD dev ID component
#define REGSTR_VAL_PCMTDRIVER   TEXT("MTD")             //value of Mem Tech DRV

//used in hardware\enum\dev\inst by Device Installer
#define REGSTR_VAL_HARDWAREID    TEXT("HardwareID")      //value of enum\dev\inst

//value names under class brach REGSTR_KEY_CLASS + class name
// and for the drivers REGSTR_KEY_CLASS\classname\xxxx
#define REGSTR_VAL_INSTALLER          TEXT("Installer")         // 16-bit class installer module/entry point
#define REGSTR_VAL_INSTALLER_32       TEXT("Installer32")       // 32-bit class installer module/entry point
#define REGSTR_VAL_INSICON            TEXT("Icon")              // value of class\name
#define REGSTR_VAL_LEGACYINFOPT       TEXT("LegacyInfOption")   // used for translating to old-style INF option names
#define REGSTR_VAL_ENUMPROPPAGES      TEXT("EnumPropPages")     // For Class/Device Properties (16-bit)
#define REGSTR_VAL_ENUMPROPPAGES_32   TEXT("EnumPropPages32")   // For Class/Device Properties (32-bit)
#define REGSTR_VAL_BASICPROPERTIES    TEXT("BasicProperties")   // For CPL basic Properties (16-bit)
#define REGSTR_VAL_BASICPROPERTIES_32 TEXT("BasicProperties32") // For CPL basic Properties (32-bit)
#define REGSTR_VAL_COINSTALLERS_32    TEXT("CoInstallers32")    // Device-specific co-installer multi-sz list (32-bit)
#define REGSTR_VAL_PRIVATEPROBLEM     TEXT("PrivateProblem")    // For Handling Private Problems

// names used for display driver set information
#define REGSTR_KEY_CURRENT      TEXT("Current") // current mode information
#define REGSTR_KEY_DEFAULT      TEXT("Default") // default configuration
#define REGSTR_KEY_MODES        TEXT("Modes")   // modes subtree

#define REGSTR_VAL_MODE         TEXT("Mode")            // default mode
#define REGSTR_VAL_BPP          TEXT("BPP")             // bits per pixel
#define REGSTR_VAL_HRES         TEXT("HRes")            // horizontal resolution
#define REGSTR_VAL_VRES         TEXT("VRes")            // vertical resolution
#define REGSTR_VAL_FONTSIZE     TEXT("FontSize")        // used in default or override
#define REGSTR_VAL_DRV          TEXT("drv")             // the driver file
#define REGSTR_VAL_GRB          TEXT("grb")             // the grabber file
#define REGSTR_VAL_VDD          TEXT("vdd")             // vdds used here
#define REGSTR_VAL_VER          TEXT("Ver")
#define REGSTR_VAL_MAXRES       TEXT("MaxResolution") // max res for monitors
#define REGSTR_VAL_DPMS         TEXT("DPMS")            // DPMS enabled
#define REGSTR_VAL_RESUMERESET  TEXT("ResumeReset")   // need reset on resume

#define REGSTR_VAL_DESCRIPTION TEXT("Description")

// keys in fontsize tree
#define REGSTR_KEY_SYSTEM       TEXT("System")  // entries for system.ini
#define REGSTR_KEY_USER         TEXT("User")            // entries for win.ini
#define REGSTR_VAL_DPI          TEXT("dpi")             // dpi of fontsize

//
// Used by PCIC socket services
//
#define REGSTR_VAL_PCICOPTIONS  TEXT("PCICOptions")     // Binary DWORD.  IRQ mask in
                                                // low word.  # skts in high
#ifndef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x4EB8          // Default IRQ masks
#else // ifdef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x1468          // Default IRQ masks
#endif // ifdef NEC_98
#define PCIC_DEFAULT_NUMSOCKETS 0               // 0 = Automatic detection
#define REGSTR_VAL_PCICIRQMAP   TEXT("PCICIRQMap")      // Binary 16 byte IRQ map table

// names used for control panel entries
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define REGSTR_VAL_CUSTOMCOLORS TEXT("CustomColors")

#define REGSTR_PATH_SCREENSAVE          TEXT("Control Panel\\Desktop")
#define REGSTR_VALUE_USESCRPASSWORD TEXT("ScreenSaveUsePassword")
#define REGSTR_VALUE_SCRPASSWORD    TEXT("ScreenSave_Data")

#define REGSTR_VALUE_LOWPOWERTIMEOUT    TEXT("ScreenSaveLowPowerTimeout")
#define REGSTR_VALUE_POWEROFFTIMEOUT    TEXT("ScreenSavePowerOffTimeout")
#define REGSTR_VALUE_LOWPOWERACTIVE     TEXT("ScreenSaveLowPowerActive")
#define REGSTR_VALUE_POWEROFFACTIVE     TEXT("ScreenSavePowerOffActive")

// used for Windows applets
#define REGSTR_PATH_WINDOWSAPPLETS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")

//
// system tray.  Flag values defined in systrap.h
//
#define REGSTR_PATH_SYSTRAY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray")
#define REGSTR_VAL_SYSTRAYSVCS TEXT("Services")
#define REGSTR_VAL_SYSTRAYBATFLAGS TEXT("PowerFlags")
#define REGSTR_VAL_SYSTRAYPCCARDFLAGS TEXT("PCMCIAFlags")

//
// Used by system networking components to store per-user values.
// All keys here are under HKCU.
//
#define REGSTR_PATH_NETWORK_USERSETTINGS        TEXT("Network")

#define REGSTR_KEY_NETWORK_PERSISTENT           TEXT("\\Persistent")
#define REGSTR_KEY_NETWORK_RECENT               TEXT("\\Recent")
#define REGSTR_VAL_REMOTE_PATH                  TEXT("RemotePath")
#define REGSTR_VAL_USER_NAME                    TEXT("UserName")
#define REGSTR_VAL_PROVIDER_NAME                TEXT("ProviderName")
#define REGSTR_VAL_CONNECTION_TYPE              TEXT("ConnectionType")
#define REGSTR_VAL_UPGRADE                      TEXT("Upgrade")

#define REGSTR_KEY_LOGON TEXT("\\Logon")
#define REGSTR_VAL_MUSTBEVALIDATED  TEXT("MustBeValidated")
#define REGSTR_VAL_RUNLOGINSCRIPT       TEXT("ProcessLoginScript")

//
// NetworkProvider entries. These entries are under
// REGSTR_PATH_SERVICES\\xxx\\NetworkProvider
//
#define REGSTR_KEY_NETWORKPROVIDER TEXT("\\NetworkProvider")
#define REGSTR_PATH_NW32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\NWNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_PATH_MS32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\MSNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_VAL_AUTHENT_AGENT TEXT("AuthenticatingAgent")

//
// Entries under REGSTR_PATH_REALMODENET
//
#define REGSTR_VAL_PREFREDIR TEXT("PreferredRedir")
#define REGSTR_VAL_AUTOSTART TEXT("AutoStart")
#define REGSTR_VAL_AUTOLOGON TEXT("AutoLogon")
#define REGSTR_VAL_NETCARD TEXT("Netcard")
#define REGSTR_VAL_TRANSPORT TEXT("Transport")
#define REGSTR_VAL_DYNAMIC TEXT("Dynamic")
#define REGSTR_VAL_TRANSITION TEXT("Transition")
#define REGSTR_VAL_STATICDRIVE TEXT("StaticDrive")
#define REGSTR_VAL_LOADHI TEXT("LoadHi")
#define REGSTR_VAL_LOADRMDRIVERS TEXT("LoadRMDrivers")
#define REGSTR_VAL_SETUPN TEXT("SetupN")
#define REGSTR_VAL_SETUPNPATH TEXT("SetupNPath")

//
// Entries under REGSTR_PATH_CVNETWORK
//
#define REGSTR_VAL_WRKGRP_FORCEMAPPING TEXT("WrkgrpForceMapping")
#define REGSTR_VAL_WRKGRP_REQUIRED TEXT("WrkgrpRequired")

//
// NT-compatible place where the name of the currently logged-on user is stored.
//
#define REGSTR_PATH_CURRENT_CONTROL_SET TEXT("System\\CurrentControlSet\\Control")
#define REGSTR_VAL_CURRENT_USER                 TEXT("Current User")

// section where password providers are installed (each provider has subkey under this key)
#define REGSTR_PATH_PWDPROVIDER         TEXT("System\\CurrentControlSet\\Control\\PwdProvider")
#define REGSTR_VAL_PWDPROVIDER_PATH TEXT("ProviderPath")
#define REGSTR_VAL_PWDPROVIDER_DESC TEXT("Description")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWD TEXT("ChangePassword")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND TEXT("ChangePasswordHwnd")
#define REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS TEXT("GetPasswordStatus")
#define REGSTR_VAL_PWDPROVIDER_ISNP TEXT("NetworkProvider")
#define REGSTR_VAL_PWDPROVIDER_CHANGEORDER TEXT("ChangeOrder")

//
// Used by administrator configuration tool and various components who enforce
// policies.
//
#define REGSTR_PATH_POLICIES    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")

// used to control remote update of administrator policies
#define REGSTR_PATH_UPDATE              TEXT("System\\CurrentControlSet\\Control\\Update")
#define REGSTR_VALUE_ENABLE             TEXT("Enable")
#define REGSTR_VALUE_VERBOSE    TEXT("Verbose")
#define REGSTR_VALUE_NETPATH    TEXT("NetworkPath")
#define REGSTR_VALUE_DEFAULTLOC TEXT("UseDefaultNetLocation")

//
//      Entries under REGSTR_PATH_POLICIES
//
#define REGSTR_KEY_NETWORK              TEXT("Network")
#define REGSTR_KEY_SYSTEM               TEXT("System")
#define REGSTR_KEY_PRINTERS             TEXT("Printers")
#define REGSTR_KEY_WINOLDAPP            TEXT("WinOldApp")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("0") if value not present)
// policies under NETWORK key
#define REGSTR_VAL_NOFILESHARING                TEXT("NoFileSharing") // TEXT("1") prevents server from loading
#define REGSTR_VAL_NOPRINTSHARING               TEXT("NoPrintSharing")
#define REGSTR_VAL_NOFILESHARINGCTRL    TEXT("NoFileSharingControl") // TEXT("1") removes sharing ui
#define REGSTR_VAL_NOPRINTSHARINGCTRL   TEXT("NoPrintSharingControl")
#define REGSTR_VAL_HIDESHAREPWDS                TEXT("HideSharePwds") // TEXT("1") hides share passwords with asterisks
#define REGSTR_VAL_DISABLEPWDCACHING    TEXT("DisablePwdCaching") // TEXT("1") disables caching
#define REGSTR_VAL_ALPHANUMPWDS                 TEXT("AlphanumPwds") // TEXT("1") forces alphanumeric passwords
#define REGSTR_VAL_NETSETUP_DISABLE                     TEXT("NoNetSetup")
#define REGSTR_VAL_NETSETUP_NOCONFIGPAGE        TEXT("NoNetSetupConfigPage")
#define REGSTR_VAL_NETSETUP_NOIDPAGE            TEXT("NoNetSetupIDPage")
#define REGSTR_VAL_NETSETUP_NOSECURITYPAGE      TEXT("NoNetSetupSecurityPage")
#define REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE  TEXT("NoVirtMemPage")
#define REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE   TEXT("NoDevMgrPage")
#define REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       TEXT("NoConfigPage")
#define REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      TEXT("NoFileSysPage")
#define REGSTR_VAL_DISPCPL_NODISPCPL            TEXT("NoDispCPL")
#define REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE TEXT("NoDispBackgroundPage")
#define REGSTR_VAL_DISPCPL_NOSCRSAVPAGE TEXT("NoDispScrSavPage")
#define REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE TEXT("NoDispAppearancePage")
#define REGSTR_VAL_DISPCPL_NOSETTINGSPAGE TEXT("NoDispSettingsPage")
#define REGSTR_VAL_SECCPL_NOSECCPL                      TEXT("NoSecCPL")
#define REGSTR_VAL_SECCPL_NOPWDPAGE                     TEXT("NoPwdPage")
#define REGSTR_VAL_SECCPL_NOADMINPAGE           TEXT("NoAdminPage")
#define REGSTR_VAL_SECCPL_NOPROFILEPAGE         TEXT("NoProfilePage")
#define REGSTR_VAL_PRINTERS_HIDETABS            TEXT("NoPrinterTabs")
#define REGSTR_VAL_PRINTERS_NODELETE            TEXT("NoDeletePrinter")
#define REGSTR_VAL_PRINTERS_NOADD                       TEXT("NoAddPrinter")
#define REGSTR_VAL_WINOLDAPP_DISABLED           TEXT("Disabled")
#define REGSTR_VAL_WINOLDAPP_NOREALMODE         TEXT("NoRealMode")
#define REGSTR_VAL_NOENTIRENETWORK                      TEXT("NoEntireNetwork")
#define REGSTR_VAL_NOWORKGROUPCONTENTS          TEXT("NoWorkgroupContents")

// REG_DWORD, 0=off, otherwise value is minimum # of chars to allow in password
#define REGSTR_VAL_MINPWDLEN                    TEXT("MinPwdLen")
// REG_DWORD, 0=off, otherwise value is # of days for pwd to expire
#define REGSTR_VAL_PWDEXPIRATION                TEXT("PwdExpiration")

#define REGSTR_VAL_WIN31PROVIDER                TEXT("Win31Provider") // REG_SZ

// policies under SYSTEM key
#define REGSTR_VAL_DISABLEREGTOOLS              TEXT("DisableRegistryTools")

#define REGSTR_PATH_WINLOGON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define REGSTR_VAL_LEGALNOTICECAPTION   TEXT("LegalNoticeCaption")      // REG_SZ
#define REGSTR_VAL_LEGALNOTICETEXT              TEXT("LegalNoticeText")         // REG_SZ
#define REGSTR_VAL_DRIVE_SPINDOWN               TEXT("NoDispSpinDown")

#define REGSTR_VAL_RESTRICTRUN  TEXT("RestrictRun")
//
//  Entries in policy file.  (Won't be in local registry, only policy hive)
#define REGSTR_KEY_POL_USERS            TEXT("Users")
#define REGSTR_KEY_POL_COMPUTERS        TEXT("Computers")
#define REGSTR_KEY_POL_USERGROUPS       TEXT("UserGroups")
#define REGSTR_KEY_POL_DEFAULT          TEXT(".default")
#define REGSTR_KEY_POL_USERGROUPDATA TEXT("GroupData\\UserGroups\\Priority")

//
//      Entries for time zone information under LOCAL_MACHINE
//
#define REGSTR_PATH_TIMEZONE        TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation")
#define REGSTR_VAL_TZBIAS           TEXT("Bias")
#define REGSTR_VAL_TZDLTBIAS        TEXT("DaylightBias")
#define REGSTR_VAL_TZSTDBIAS        TEXT("StandardBias")
#define REGSTR_VAL_TZACTBIAS        TEXT("ActiveTimeBias")
#define REGSTR_VAL_TZDLTFLAG        TEXT("DaylightFlag")
#define REGSTR_VAL_TZSTDSTART       TEXT("StandardStart")
#define REGSTR_VAL_TZDLTSTART       TEXT("DaylightStart")
#define REGSTR_VAL_TZDLTNAME        TEXT("DaylightName")
#define REGSTR_VAL_TZSTDNAME        TEXT("StandardName")
#define REGSTR_VAL_TZNOCHANGESTART  TEXT("NoChangeStart")
#define REGSTR_VAL_TZNOCHANGEEND    TEXT("NoChangeEnd")
#define REGSTR_VAL_TZNOAUTOTIME     TEXT("DisableAutoDaylightTimeSet")

//
//      Entries for floating point processor existence under LOCAL_MACHINE
//
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor")
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR0 TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor\\0")


//
//      Entries for computer name under LOCAL_MACHINE
//
#define REGSTR_PATH_COMPUTRNAME TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
#define REGSTR_VAL_COMPUTRNAME TEXT("ComputerName")

//      Entry so that we force a reboot on shutdown / single instance dos app
#define REGSTR_PATH_SHUTDOWN TEXT("System\\CurrentControlSet\\Control\\Shutdown")
#define REGSTR_VAL_FORCEREBOOT     TEXT("ForceReboot")
#define REGSTR_VAL_SETUPPROGRAMRAN TEXT("SetupProgramRan")
#define REGSTR_VAL_DOES_POLLING    TEXT("PollingSupportNeeded")

//
//      Entries for known system DLLs under LOCAL_MACHINE
//
//      The VAL keys here are the actual DLL names (FOO.DLL)
//
#define REGSTR_PATH_KNOWNDLLS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs")
#define REGSTR_PATH_KNOWN16DLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\Known16DLLs")

//      Entries here for system dlls we need to version check in case overwritten
#define REGSTR_PATH_CHECKVERDLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckVerDLLs")
#define REGSTR_PATH_WARNVERDLLS  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\WarnVerDLLs")

//      Entries here for app ini files we (msgsrv32) need to hack
#define REGSTR_PATH_HACKINIFILE  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\HackIniFiles")

//      Keys here for bad applications we want to warn the user about before running
#define REGSTR_PATH_CHECKBADAPPS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps")

//      Keys here for applications we need to patch
#define REGSTR_PATH_APPPATCH TEXT("System\\CurrentControlSet\\Control\\SessionManager\\AppPatches")

#define REGSTR_PATH_CHECKBADAPPS400 TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps400")

#define REGSTR_PATH_SHELLSERVICEOBJECT          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObject")
#define REGSTR_PATH_SHELLSERVICEOBJECTDELAYED   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad")

//
//      Entries for known system VxDs under LOCAL_MACHINE
//
//      The VAL keys here are the full path names of VxDs (c:\app\vapp.vxd)
//      It is suggested that the keynames be the same as the module name of
//      the VxD.
//      This section is used to dyna-load VxDs with
//      CreateFile(\\.\vxd_regstr_keyname).
//

#define REGSTR_PATH_KNOWNVXDS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownVxDs")

//
// Entries for values in uninstaller keys under REGSTR_PATH_UNINSTALL \ appname
//
#define REGSTR_VAL_UNINSTALLER_DISPLAYNAME     TEXT("DisplayName")
#define REGSTR_VAL_UNINSTALLER_COMMANDLINE     TEXT("UninstallString")

//
//      Entries for known per user settings: Under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DESKTOP     REGSTR_PATH_SCREENSAVE
#define REGSTR_PATH_MOUSE           TEXT("Control Panel\\Mouse")
#define REGSTR_PATH_KEYBOARD    TEXT("Control Panel\\Keyboard")
#define REGSTR_PATH_COLORS          TEXT("Control Panel\\Colors")
#define REGSTR_PATH_SOUND           TEXT("Control Panel\\Sound")
#define REGSTR_PATH_METRICS         TEXT("Control Panel\\Desktop\\WindowMetrics")
#define REGSTR_PATH_ICONS       TEXT("Control Panel\\Icons")
#define REGSTR_PATH_CURSORS     TEXT("Control Panel\\Cursors")
#define REGSTR_PATH_CHECKDISK   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive")
#define REGSTR_PATH_CHECKDISKSET    TEXT("Settings")
#define REGSTR_PATH_CHECKDISKUDRVS  TEXT("NoUnknownDDErrDrvs")
//
//  Entries under REGSTR_PATH_FAULT
//
#define REGSTR_PATH_FAULT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fault")
#define REGSTR_VAL_FAULT_LOGFILE        TEXT("LogFile")

//
//  Entries under REGSTR_PATH_AEDEBUG
//
#define REGSTR_PATH_AEDEBUG             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGSTR_VAL_AEDEBUG_DEBUGGER     TEXT("Debugger")
#define REGSTR_VAL_AEDEBUG_AUTO         TEXT("Auto")

//
//  Entries under REGSTR_PATH_GRPCONV
//
#define REGSTR_PATH_GRPCONV     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\GrpConv")

//
//  Entries under the RegItem key in a shell namespace
//
#define REGSTR_VAL_REGITEMDELETEMESSAGE TEXT("Removal Message")

//
//  Entries for the Drives Tools page
//
//  NOTE that these items are not recorded for removable drives. These
//  keys record X=DSKTLSYSTEMTIME where X is the drive letter. Since
//  these tools actually work on the disk in the drive, as opposed to
//  the drive itself, it is pointless to record them on a removable media
//  since if a different disk is inserted in the drive, the data is
//  meaningless.
//
#define REGSTR_PATH_LASTCHECK           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastCheck")
#define REGSTR_PATH_LASTOPTIMIZE        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastOptimize")
#define REGSTR_PATH_LASTBACKUP          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastBackup")
//
// The above 3 keys record with the registry value of the drive letter
// a SYSTEMTIME structure
//

//
// Entries under HKEY_LOCAL_MACHINE for Check Drive specific stuff
//
#define REGSTR_PATH_CHKLASTCHECK        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastCheck")
#define REGSTR_PATH_CHKLASTSURFAN       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastSurfaceAnalysis")

#ifndef _IN_KERNEL_

//
// The above 2 keys record the following binary structure which is
// a system time structure with the addition of a result code field.
// Note that the time part of REGSTR_PATH_CHKLASTCHECK is effectively
// identical to REGSTR_PATH_LASTCHECK under the explorer key
//
typedef struct _DSKTLSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wResult;
} DSKTLSYSTEMTIME, *PDSKTLSYSTEMTIME, *LPDSKTLSYSTEMTIME;

#endif

//
// The following are defines for the wResult field
//
#define DTRESULTOK      0       // Operation was successful, no errors
#define DTRESULTFIX     1       // Operation was successful, errors were found
                                //   but all were fixed.
#define DTRESULTPROB    2       // Operation was not successful or errors
                                //   were found and some or all were not fixed.
#define DTRESULTPART    3       // Operation was partially completed but was
                                //   terminated either by the user or an error.

//
//  Entries for persistent shares
//
#define REGSTR_KEY_SHARES             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\LanMan")
#define REGSTR_VAL_SHARES_FLAGS   TEXT("Flags")
#define REGSTR_VAL_SHARES_TYPE    TEXT("Type")
#define REGSTR_VAL_SHARES_PATH    TEXT("Path")
#define REGSTR_VAL_SHARES_REMARK  TEXT("Remark")
#define REGSTR_VAL_SHARES_RW_PASS TEXT("Parm1")
#define REGSTR_VAL_SHARES_RO_PASS TEXT("Parm2")

//
//      Entries for printer settings under LOCAL_MACHINE
//
#define REGSTR_PATH_PRINT           TEXT("System\\CurrentControlSet\\Control\\Print")
#define REGSTR_PATH_PRINTERS        TEXT("System\\CurrentControlSet\\Control\\Print\\Printers")
#define REGSTR_PATH_PROVIDERS       TEXT("System\\CurrentControlSet\\Control\\Print\\Providers")
#define REGSTR_PATH_MONITORS        TEXT("System\\CurrentControlSet\\Control\\Print\\Monitors")
#define REGSTR_PATH_ENVIRONMENTS    TEXT("System\\CurrentControlSet\\Control\\Print\\Environments")
#define REGSTR_VAL_START_ON_BOOT    TEXT("StartOnBoot")
#define REGSTR_VAL_PRINTERS_MASK    TEXT("PrintersMask")
#define REGSTR_VAL_DOS_SPOOL_MASK   TEXT("DOSSpoolMask")
#define REGSTR_KEY_CURRENT_ENV      TEXT("\\Windows 4.0")
#define REGSTR_KEY_DRIVERS          TEXT("\\Drivers")
#define REGSTR_KEY_PRINT_PROC       TEXT("\\Print Processors")

//
// Entries for MultiMedia under HKEY_CURRENT_USER
//
#define REGSTR_PATH_EVENTLABELS     TEXT("AppEvents\\EventLabels")
#define REGSTR_PATH_SCHEMES         TEXT("AppEvents\\Schemes")
#define REGSTR_PATH_APPS            REGSTR_PATH_SCHEMES TEXT("\\Apps")
#define REGSTR_PATH_APPS_DEFAULT    REGSTR_PATH_SCHEMES TEXT("\\Apps\\.Default")
#define REGSTR_PATH_NAMES           REGSTR_PATH_SCHEMES TEXT("\\Names")
#define REGSTR_PATH_MULTIMEDIA      REGSTR_PATH_SETUP TEXT("\\Multimedia")
#define REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("Software\\Microsoft\\Multimedia\\Audio")
#define REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\Images")

//
// Entries for MultiMedia under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_MEDIARESOURCES  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaResources")
#define REGSTR_PATH_MEDIAPROPERTIES REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaProperties")
#define REGSTR_PATH_PRIVATEPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PrivateProperties")
#define REGSTR_PATH_PUBLICPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PublicProperties")

// joysticks
#define REGSTR_PATH_JOYOEM           REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\OEM")
#define REGSTR_PATH_JOYCONFIG        REGSTR_PATH_MEDIARESOURCES TEXT("\\Joystick")
#define REGSTR_KEY_JOYCURR           TEXT("CurrentJoystickSettings")
#define REGSTR_KEY_JOYSETTINGS       TEXT("JoystickSettings")

// joystick values found under REGSTR_PATH_JOYCONFIG
#define REGSTR_VAL_JOYUSERVALUES     TEXT("JoystickUserValues")
#define REGSTR_VAL_JOYCALLOUT        TEXT("JoystickCallout")

// joystick values found under REGSTR_KEY_JOYCURR and REGSTR_KEY_JOYSETTINGS
#define REGSTR_VAL_JOYNCONFIG        TEXT("Joystick%dConfiguration")
#define REGSTR_VAL_JOYNOEMNAME       TEXT("Joystick%dOEMName")
#define REGSTR_VAL_JOYNOEMCALLOUT    TEXT("Joystick%dOEMCallout")

// joystick values found under keys under REGSTR_PATH_JOYOEM
#define REGSTR_VAL_JOYOEMCALLOUT        TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMNAME           TEXT("OEMName")
#define REGSTR_VAL_JOYOEMDATA           TEXT("OEMData")
#define REGSTR_VAL_JOYOEMXYLABEL        TEXT("OEMXYLabel")
#define REGSTR_VAL_JOYOEMZLABEL         TEXT("OEMZLabel")
#define REGSTR_VAL_JOYOEMRLABEL         TEXT("OEMRLabel")
#define REGSTR_VAL_JOYOEMPOVLABEL       TEXT("OEMPOVLabel")
#define REGSTR_VAL_JOYOEMULABEL         TEXT("OEMULabel")
#define REGSTR_VAL_JOYOEMVLABEL         TEXT("OEMVLabel")
#define REGSTR_VAL_JOYOEMTESTMOVEDESC   TEXT("OEMTestMoveDesc")
#define REGSTR_VAL_JOYOEMTESTBUTTONDESC TEXT("OEMTestButtonDesc")
#define REGSTR_VAL_JOYOEMTESTMOVECAP    TEXT("OEMTestMoveCap")
#define REGSTR_VAL_JOYOEMTESTBUTTONCAP  TEXT("OEMTestButtonCap")
#define REGSTR_VAL_JOYOEMTESTWINCAP     TEXT("OEMTestWinCap")
#define REGSTR_VAL_JOYOEMCALCAP         TEXT("OEMCalCap")
#define REGSTR_VAL_JOYOEMCALWINCAP      TEXT("OEMCalWinCap")
#define REGSTR_VAL_JOYOEMCAL1           TEXT("OEMCal1")
#define REGSTR_VAL_JOYOEMCAL2           TEXT("OEMCal2")
#define REGSTR_VAL_JOYOEMCAL3           TEXT("OEMCal3")
#define REGSTR_VAL_JOYOEMCAL4           TEXT("OEMCal4")
#define REGSTR_VAL_JOYOEMCAL5           TEXT("OEMCal5")
#define REGSTR_VAL_JOYOEMCAL6           TEXT("OEMCal6")
#define REGSTR_VAL_JOYOEMCAL7           TEXT("OEMCal7")
#define REGSTR_VAL_JOYOEMCAL8           TEXT("OEMCal8")
#define REGSTR_VAL_JOYOEMCAL9           TEXT("OEMCal9")
#define REGSTR_VAL_JOYOEMCAL10          TEXT("OEMCal10")
#define REGSTR_VAL_JOYOEMCAL11          TEXT("OEMCal11")
#define REGSTR_VAL_JOYOEMCAL12          TEXT("OEMCal12")

// Image values under REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")

//
// Entries for Device Installer under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DEVICEINSTALLER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Device Installer")

// Device Installer values found under REGSTR_PATH_DEVICEINSTALLER
#define REGSTR_VAL_SEARCHOPTIONS        TEXT("SearchOptions")

// BiosInfo defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_BIOSINFO            TEXT("System\\CurrentControlSet\\Control\\BiosInfo")

#else

#define REGSTR_PATH_BIOSINFO            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\BiosInfo"

#endif

// Pci Irq Routing registry defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_PCIIR               TEXT("System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting")
#define REGSTR_VAL_OPTIONS              TEXT("Options")
#define REGSTR_VAL_STAT                 TEXT("Status")
#define REGSTR_VAL_TABLE_STAT           TEXT("TableStatus")
#define REGSTR_VAL_MINIPORT_STAT        TEXT("MiniportStatus")

#else

#define REGSTR_PATH_PCIIR               L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting"
#define REGSTR_VAL_OPTIONS              L"Options"
#define REGSTR_VAL_STAT                 L"Status"
#define REGSTR_VAL_TABLE_STAT           L"TableStatus"
#define REGSTR_VAL_MINIPORT_STAT        L"MiniportStatus"

#endif

// Pci Irq Routing Option values.
#define PIR_OPTION_ENABLED                  0x00000001
#define PIR_OPTION_REGISTRY                 0x00000002
#define PIR_OPTION_MSSPEC                   0x00000004
#define PIR_OPTION_REALMODE                 0x00000008
#define PIR_OPTION_DEFAULT                  0x0000000f

// Pci Irq Routing Status values.
#define PIR_STATUS_ERROR                    0x00000000
#define PIR_STATUS_ENABLED                  0x00000001
#define PIR_STATUS_DISABLED                 0x00000002
#define PIR_STATUS_MAX                      0x00000003

#define PIR_STATUS_TABLE_REGISTRY           0x00000000
#define PIR_STATUS_TABLE_MSSPEC                     0x00000001
#define PIR_STATUS_TABLE_REALMODE                   0x00000002
#define PIR_STATUS_TABLE_NONE                   0x00000003
#define PIR_STATUS_TABLE_ERROR                      0x00000004
#define PIR_STATUS_TABLE_BAD                        0x00000005
#define PIR_STATUS_TABLE_SUCCESS            0x00000006
#define PIR_STATUS_TABLE_MAX                0x00000007

#define PIR_STATUS_MINIPORT_NORMAL                  0x00000000
#define PIR_STATUS_MINIPORT_COMPATIBLE      0x00000001
#define PIR_STATUS_MINIPORT_OVERRIDE        0x00000002
#define PIR_STATUS_MINIPORT_NONE                    0x00000003
#define PIR_STATUS_MINIPORT_ERROR                   0x00000004
#define PIR_STATUS_MINIPORT_NOKEY                   0x00000005
#define PIR_STATUS_MINIPORT_SUCCESS                 0x00000006
#define PIR_STATUS_MINIPORT_INVALID                 0x00000007
#define PIR_STATUS_MINIPORT_MAX             0x00000008

//
// entries for LastKnownGood
// each value name under this key is SubPath/File (note reversal of '\\' to '/')
// each value is an indication of post-processing to be done after files have been recovered
// LASTGOOD_OPERATION bits indicate the primary post-processing operation
// remaining bits may be used as flags (allocate flags from highest bits first)
// a value of 0 is the same as the value being omitted, ie, no post processing.
//

#ifndef _IN_KERNEL_
#define REGSTR_PATH_LASTGOOD            TEXT("System\\LastKnownGoodRecovery\\LastGood")
#define REGSTR_PATH_LASTGOODTMP         TEXT("System\\LastKnownGoodRecovery\\LastGood.Tmp")
#else
#define REGSTR_PATH_LASTGOOD            L"\\Registry\\Machine\\System\\LastKnownGoodRecovery\\LastGood"
#define REGSTR_PATH_LASTGOODTMP         L"\\Registry\\Machine\\System\\LastKnownGoodRecovery\\LastGood.Tmp"
#endif
#define LASTGOOD_OPERATION              0x000000FF // operation to perform
#define LASTGOOD_OPERATION_NOPOSTPROC   0x00000000 // no post-processing
#define LASTGOOD_OPERATION_DELETE       0x00000001 // Delete file during recovery

#endif  //_INC_REGSTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rend.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for rend.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rend_h__
#define __rend_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __IEnumDialableAddrs_FWD_DEFINED__
#define __IEnumDialableAddrs_FWD_DEFINED__
typedef interface IEnumDialableAddrs IEnumDialableAddrs;
#endif 	/* __IEnumDialableAddrs_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __IEnumDirectoryObject_FWD_DEFINED__
#define __IEnumDirectoryObject_FWD_DEFINED__
typedef interface IEnumDirectoryObject IEnumDirectoryObject;
#endif 	/* __IEnumDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __IEnumDirectory_FWD_DEFINED__
#define __IEnumDirectory_FWD_DEFINED__
typedef interface IEnumDirectory IEnumDirectory;
#endif 	/* __IEnumDirectory_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __Rendezvous_FWD_DEFINED__
#define __Rendezvous_FWD_DEFINED__

#ifdef __cplusplus
typedef class Rendezvous Rendezvous;
#else
typedef struct Rendezvous Rendezvous;
#endif /* __cplusplus */

#endif 	/* __Rendezvous_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rend_0000 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */
#define	IDISPDIROBJECT	( 0x10000 )

#define	IDISPDIROBJCONFERENCE	( 0x20000 )

#define	IDISPDIROBJUSER	( 0x30000 )

#define	IDISPDIRECTORY	( 0x10000 )

#define	IDISPILSCONFIG	( 0x20000 )

typedef 
enum DIRECTORY_TYPE
    {	DT_NTDS	= 1,
	DT_ILS	= 2
    } 	DIRECTORY_TYPE;

typedef 
enum DIRECTORY_OBJECT_TYPE
    {	OT_CONFERENCE	= 1,
	OT_USER	= 2
    } 	DIRECTORY_OBJECT_TYPE;

typedef 
enum RND_ADVERTISING_SCOPE
    {	RAS_LOCAL	= 1,
	RAS_SITE	= 2,
	RAS_REGION	= 3,
	RAS_WORLD	= 4
    } 	RND_ADVERTISING_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_rend_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_v0_0_s_ifspec;

#ifndef __ITDirectoryObjectConference_INTERFACE_DEFINED__
#define __ITDirectoryObjectConference_INTERFACE_DEFINED__

/* interface ITDirectoryObjectConference */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1029E5D-CB5B-11D0-8D59-00C04FD91AC0")
    ITDirectoryObjectConference : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ BSTR *ppProtocol) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Originator( 
            /* [retval][out] */ BSTR *ppOriginator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Originator( 
            /* [in] */ BSTR pOriginator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdvertisingScope( 
            /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AdvertisingScope( 
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ BSTR *ppUrl) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ BSTR pUrl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR pDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEncrypted( 
            /* [retval][out] */ VARIANT_BOOL *pfEncrypted) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsEncrypted( 
            /* [in] */ VARIANT_BOOL fEncrypted) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE Date) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ DATE Date) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObjectConference * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObjectConference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObjectConference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObjectConference * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObjectConference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObjectConference * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppProtocol);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Originator )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppOriginator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Originator )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pOriginator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdvertisingScope )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AdvertisingScope )( 
            ITDirectoryObjectConference * This,
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Url )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppUrl);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pUrl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ BSTR *ppDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            ITDirectoryObjectConference * This,
            /* [in] */ BSTR pDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEncrypted )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ VARIANT_BOOL *pfEncrypted);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsEncrypted )( 
            ITDirectoryObjectConference * This,
            /* [in] */ VARIANT_BOOL fEncrypted);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            ITDirectoryObjectConference * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        END_INTERFACE
    } ITDirectoryObjectConferenceVtbl;

    interface ITDirectoryObjectConference
    {
        CONST_VTBL struct ITDirectoryObjectConferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectConference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObjectConference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObjectConference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObjectConference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObjectConference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObjectConference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObjectConference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObjectConference_get_Protocol(This,ppProtocol)	\
    (This)->lpVtbl -> get_Protocol(This,ppProtocol)

#define ITDirectoryObjectConference_get_Originator(This,ppOriginator)	\
    (This)->lpVtbl -> get_Originator(This,ppOriginator)

#define ITDirectoryObjectConference_put_Originator(This,pOriginator)	\
    (This)->lpVtbl -> put_Originator(This,pOriginator)

#define ITDirectoryObjectConference_get_AdvertisingScope(This,pAdvertisingScope)	\
    (This)->lpVtbl -> get_AdvertisingScope(This,pAdvertisingScope)

#define ITDirectoryObjectConference_put_AdvertisingScope(This,AdvertisingScope)	\
    (This)->lpVtbl -> put_AdvertisingScope(This,AdvertisingScope)

#define ITDirectoryObjectConference_get_Url(This,ppUrl)	\
    (This)->lpVtbl -> get_Url(This,ppUrl)

#define ITDirectoryObjectConference_put_Url(This,pUrl)	\
    (This)->lpVtbl -> put_Url(This,pUrl)

#define ITDirectoryObjectConference_get_Description(This,ppDescription)	\
    (This)->lpVtbl -> get_Description(This,ppDescription)

#define ITDirectoryObjectConference_put_Description(This,pDescription)	\
    (This)->lpVtbl -> put_Description(This,pDescription)

#define ITDirectoryObjectConference_get_IsEncrypted(This,pfEncrypted)	\
    (This)->lpVtbl -> get_IsEncrypted(This,pfEncrypted)

#define ITDirectoryObjectConference_put_IsEncrypted(This,fEncrypted)	\
    (This)->lpVtbl -> put_IsEncrypted(This,fEncrypted)

#define ITDirectoryObjectConference_get_StartTime(This,pDate)	\
    (This)->lpVtbl -> get_StartTime(This,pDate)

#define ITDirectoryObjectConference_put_StartTime(This,Date)	\
    (This)->lpVtbl -> put_StartTime(This,Date)

#define ITDirectoryObjectConference_get_StopTime(This,pDate)	\
    (This)->lpVtbl -> get_StopTime(This,pDate)

#define ITDirectoryObjectConference_put_StopTime(This,Date)	\
    (This)->lpVtbl -> put_StopTime(This,Date)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Protocol_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppProtocol);


void __RPC_STUB ITDirectoryObjectConference_get_Protocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Originator_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppOriginator);


void __RPC_STUB ITDirectoryObjectConference_get_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Originator_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pOriginator);


void __RPC_STUB ITDirectoryObjectConference_put_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_AdvertisingScope_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ RND_ADVERTISING_SCOPE *pAdvertisingScope);


void __RPC_STUB ITDirectoryObjectConference_get_AdvertisingScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_AdvertisingScope_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);


void __RPC_STUB ITDirectoryObjectConference_put_AdvertisingScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Url_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppUrl);


void __RPC_STUB ITDirectoryObjectConference_get_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Url_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pUrl);


void __RPC_STUB ITDirectoryObjectConference_put_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_Description_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ BSTR *ppDescription);


void __RPC_STUB ITDirectoryObjectConference_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_Description_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ BSTR pDescription);


void __RPC_STUB ITDirectoryObjectConference_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_IsEncrypted_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ VARIANT_BOOL *pfEncrypted);


void __RPC_STUB ITDirectoryObjectConference_get_IsEncrypted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_IsEncrypted_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ VARIANT_BOOL fEncrypted);


void __RPC_STUB ITDirectoryObjectConference_put_IsEncrypted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_StartTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB ITDirectoryObjectConference_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_StartTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ DATE Date);


void __RPC_STUB ITDirectoryObjectConference_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_get_StopTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB ITDirectoryObjectConference_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectConference_put_StopTime_Proxy( 
    ITDirectoryObjectConference * This,
    /* [in] */ DATE Date);


void __RPC_STUB ITDirectoryObjectConference_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObjectConference_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObjectUser_INTERFACE_DEFINED__
#define __ITDirectoryObjectUser_INTERFACE_DEFINED__

/* interface ITDirectoryObjectUser */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6F-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObjectUser : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPPhonePrimary( 
            /* [retval][out] */ BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IPPhonePrimary( 
            /* [in] */ BSTR pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObjectUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObjectUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObjectUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObjectUser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObjectUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObjectUser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IPPhonePrimary )( 
            ITDirectoryObjectUser * This,
            /* [retval][out] */ BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IPPhonePrimary )( 
            ITDirectoryObjectUser * This,
            /* [in] */ BSTR pName);
        
        END_INTERFACE
    } ITDirectoryObjectUserVtbl;

    interface ITDirectoryObjectUser
    {
        CONST_VTBL struct ITDirectoryObjectUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObjectUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObjectUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObjectUser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObjectUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObjectUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObjectUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObjectUser_get_IPPhonePrimary(This,ppName)	\
    (This)->lpVtbl -> get_IPPhonePrimary(This,ppName)

#define ITDirectoryObjectUser_put_IPPhonePrimary(This,pName)	\
    (This)->lpVtbl -> put_IPPhonePrimary(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectUser_get_IPPhonePrimary_Proxy( 
    ITDirectoryObjectUser * This,
    /* [retval][out] */ BSTR *ppName);


void __RPC_STUB ITDirectoryObjectUser_get_IPPhonePrimary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObjectUser_put_IPPhonePrimary_Proxy( 
    ITDirectoryObjectUser * This,
    /* [in] */ BSTR pName);


void __RPC_STUB ITDirectoryObjectUser_put_IPPhonePrimary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObjectUser_INTERFACE_DEFINED__ */


#ifndef __IEnumDialableAddrs_INTERFACE_DEFINED__
#define __IEnumDialableAddrs_INTERFACE_DEFINED__

/* interface IEnumDialableAddrs */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDialableAddrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D70-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDialableAddrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR *ppElements,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDialableAddrs **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDialableAddrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDialableAddrs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDialableAddrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDialableAddrs * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR *ppElements,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDialableAddrs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDialableAddrs * This,
            /* [retval][out] */ IEnumDialableAddrs **ppEnum);
        
        END_INTERFACE
    } IEnumDialableAddrsVtbl;

    interface IEnumDialableAddrs
    {
        CONST_VTBL struct IEnumDialableAddrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDialableAddrs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDialableAddrs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDialableAddrs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDialableAddrs_Next(This,celt,ppElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched)

#define IEnumDialableAddrs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDialableAddrs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDialableAddrs_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Next_Proxy( 
    IEnumDialableAddrs * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ BSTR *ppElements,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDialableAddrs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Reset_Proxy( 
    IEnumDialableAddrs * This);


void __RPC_STUB IEnumDialableAddrs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Skip_Proxy( 
    IEnumDialableAddrs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDialableAddrs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDialableAddrs_Clone_Proxy( 
    IEnumDialableAddrs * This,
    /* [retval][out] */ IEnumDialableAddrs **ppEnum);


void __RPC_STUB IEnumDialableAddrs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDialableAddrs_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObject_INTERFACE_DEFINED__
#define __ITDirectoryObject_INTERFACE_DEFINED__

/* interface ITDirectoryObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6E-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectType( 
            /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddrs( 
            /* [in] */ long dwAddressType,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDialableAddrs( 
            /* [in] */ DWORD dwAddressType,
            /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityDescriptor( 
            /* [retval][out] */ IDispatch **ppSecDes) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SecurityDescriptor( 
            /* [in] */ IDispatch *pSecDes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectoryObject * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectoryObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectType )( 
            ITDirectoryObject * This,
            /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITDirectoryObject * This,
            /* [retval][out] */ BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            ITDirectoryObject * This,
            /* [in] */ BSTR pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddrs )( 
            ITDirectoryObject * This,
            /* [in] */ long dwAddressType,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDialableAddrs )( 
            ITDirectoryObject * This,
            /* [in] */ DWORD dwAddressType,
            /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityDescriptor )( 
            ITDirectoryObject * This,
            /* [retval][out] */ IDispatch **ppSecDes);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SecurityDescriptor )( 
            ITDirectoryObject * This,
            /* [in] */ IDispatch *pSecDes);
        
        END_INTERFACE
    } ITDirectoryObjectVtbl;

    interface ITDirectoryObject
    {
        CONST_VTBL struct ITDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectoryObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectoryObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectoryObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectoryObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectoryObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectoryObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectoryObject_get_ObjectType(This,pObjectType)	\
    (This)->lpVtbl -> get_ObjectType(This,pObjectType)

#define ITDirectoryObject_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITDirectoryObject_put_Name(This,pName)	\
    (This)->lpVtbl -> put_Name(This,pName)

#define ITDirectoryObject_get_DialableAddrs(This,dwAddressType,pVariant)	\
    (This)->lpVtbl -> get_DialableAddrs(This,dwAddressType,pVariant)

#define ITDirectoryObject_EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)	\
    (This)->lpVtbl -> EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)

#define ITDirectoryObject_get_SecurityDescriptor(This,ppSecDes)	\
    (This)->lpVtbl -> get_SecurityDescriptor(This,ppSecDes)

#define ITDirectoryObject_put_SecurityDescriptor(This,pSecDes)	\
    (This)->lpVtbl -> put_SecurityDescriptor(This,pSecDes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_ObjectType_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ DIRECTORY_OBJECT_TYPE *pObjectType);


void __RPC_STUB ITDirectoryObject_get_ObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_Name_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ BSTR *ppName);


void __RPC_STUB ITDirectoryObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_put_Name_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ BSTR pName);


void __RPC_STUB ITDirectoryObject_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_DialableAddrs_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ long dwAddressType,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITDirectoryObject_get_DialableAddrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_EnumerateDialableAddrs_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ DWORD dwAddressType,
    /* [out] */ IEnumDialableAddrs **ppEnumDialableAddrs);


void __RPC_STUB ITDirectoryObject_EnumerateDialableAddrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_get_SecurityDescriptor_Proxy( 
    ITDirectoryObject * This,
    /* [retval][out] */ IDispatch **ppSecDes);


void __RPC_STUB ITDirectoryObject_get_SecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectoryObject_put_SecurityDescriptor_Proxy( 
    ITDirectoryObject * This,
    /* [in] */ IDispatch *pSecDes);


void __RPC_STUB ITDirectoryObject_put_SecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectoryObject_INTERFACE_DEFINED__
#define __IEnumDirectoryObject_INTERFACE_DEFINED__

/* interface IEnumDirectoryObject */
/* [unique][restricted][hidden][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06C9B64A-306D-11D1-9774-00C04FD91AC0")
    IEnumDirectoryObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITDirectoryObject **pVal,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirectoryObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirectoryObject * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITDirectoryObject **pVal,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirectoryObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirectoryObject * This,
            /* [retval][out] */ IEnumDirectoryObject **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryObjectVtbl;

    interface IEnumDirectoryObject
    {
        CONST_VTBL struct IEnumDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirectoryObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirectoryObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirectoryObject_Next(This,celt,pVal,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,pVal,pcFetched)

#define IEnumDirectoryObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirectoryObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDirectoryObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Next_Proxy( 
    IEnumDirectoryObject * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ ITDirectoryObject **pVal,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDirectoryObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Reset_Proxy( 
    IEnumDirectoryObject * This);


void __RPC_STUB IEnumDirectoryObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Skip_Proxy( 
    IEnumDirectoryObject * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDirectoryObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectoryObject_Clone_Proxy( 
    IEnumDirectoryObject * This,
    /* [retval][out] */ IEnumDirectoryObject **ppEnum);


void __RPC_STUB IEnumDirectoryObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __ITILSConfig_INTERFACE_DEFINED__
#define __ITILSConfig_INTERFACE_DEFINED__

/* interface ITILSConfig */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITILSConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D72-6CFF-11d1-AFF7-00C04FC31FEE")
    ITILSConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ long *pPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ long Port) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITILSConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITILSConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITILSConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITILSConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITILSConfig * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITILSConfig * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITILSConfig * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITILSConfig * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            ITILSConfig * This,
            /* [retval][out] */ long *pPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            ITILSConfig * This,
            /* [in] */ long Port);
        
        END_INTERFACE
    } ITILSConfigVtbl;

    interface ITILSConfig
    {
        CONST_VTBL struct ITILSConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITILSConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITILSConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITILSConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITILSConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITILSConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITILSConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITILSConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITILSConfig_get_Port(This,pPort)	\
    (This)->lpVtbl -> get_Port(This,pPort)

#define ITILSConfig_put_Port(This,Port)	\
    (This)->lpVtbl -> put_Port(This,Port)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITILSConfig_get_Port_Proxy( 
    ITILSConfig * This,
    /* [retval][out] */ long *pPort);


void __RPC_STUB ITILSConfig_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITILSConfig_put_Port_Proxy( 
    ITILSConfig * This,
    /* [in] */ long Port);


void __RPC_STUB ITILSConfig_put_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITILSConfig_INTERFACE_DEFINED__ */


#ifndef __ITDirectory_INTERFACE_DEFINED__
#define __ITDirectory_INTERFACE_DEFINED__

/* interface ITDirectory */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6C-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectory : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryType( 
            /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDynamic( 
            /* [retval][out] */ VARIANT_BOOL *pfDynamic) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultObjectTTL( 
            /* [retval][out] */ long *pTTL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultObjectTTL( 
            /* [in] */ long TTL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableAutoRefresh( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ BSTR pDomainName,
            /* [in] */ BSTR pUserName,
            /* [in] */ BSTR pPassword,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModifyDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteDirectoryObject( 
            /* [in] */ ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [out] */ IEnumDirectoryObject **ppEnumObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDirectory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDirectory * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDirectory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDirectory * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryType )( 
            ITDirectory * This,
            /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            ITDirectory * This,
            /* [retval][out] */ BSTR *pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDynamic )( 
            ITDirectory * This,
            /* [retval][out] */ VARIANT_BOOL *pfDynamic);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultObjectTTL )( 
            ITDirectory * This,
            /* [retval][out] */ long *pTTL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultObjectTTL )( 
            ITDirectory * This,
            /* [in] */ long TTL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableAutoRefresh )( 
            ITDirectory * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ITDirectory * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Bind )( 
            ITDirectory * This,
            /* [in] */ BSTR pDomainName,
            /* [in] */ BSTR pUserName,
            /* [in] */ BSTR pPassword,
            /* [in] */ long lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ModifyDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteDirectoryObject )( 
            ITDirectory * This,
            /* [in] */ ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryObjects )( 
            ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDirectoryObjects )( 
            ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [out] */ IEnumDirectoryObject **ppEnumObject);
        
        END_INTERFACE
    } ITDirectoryVtbl;

    interface ITDirectory
    {
        CONST_VTBL struct ITDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDirectory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDirectory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDirectory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDirectory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDirectory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDirectory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDirectory_get_DirectoryType(This,pDirectoryType)	\
    (This)->lpVtbl -> get_DirectoryType(This,pDirectoryType)

#define ITDirectory_get_DisplayName(This,pName)	\
    (This)->lpVtbl -> get_DisplayName(This,pName)

#define ITDirectory_get_IsDynamic(This,pfDynamic)	\
    (This)->lpVtbl -> get_IsDynamic(This,pfDynamic)

#define ITDirectory_get_DefaultObjectTTL(This,pTTL)	\
    (This)->lpVtbl -> get_DefaultObjectTTL(This,pTTL)

#define ITDirectory_put_DefaultObjectTTL(This,TTL)	\
    (This)->lpVtbl -> put_DefaultObjectTTL(This,TTL)

#define ITDirectory_EnableAutoRefresh(This,fEnable)	\
    (This)->lpVtbl -> EnableAutoRefresh(This,fEnable)

#define ITDirectory_Connect(This,fSecure)	\
    (This)->lpVtbl -> Connect(This,fSecure)

#define ITDirectory_Bind(This,pDomainName,pUserName,pPassword,lFlags)	\
    (This)->lpVtbl -> Bind(This,pDomainName,pUserName,pPassword,lFlags)

#define ITDirectory_AddDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> AddDirectoryObject(This,pDirectoryObject)

#define ITDirectory_ModifyDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> ModifyDirectoryObject(This,pDirectoryObject)

#define ITDirectory_RefreshDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> RefreshDirectoryObject(This,pDirectoryObject)

#define ITDirectory_DeleteDirectoryObject(This,pDirectoryObject)	\
    (This)->lpVtbl -> DeleteDirectoryObject(This,pDirectoryObject)

#define ITDirectory_get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)	\
    (This)->lpVtbl -> get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)

#define ITDirectory_EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)	\
    (This)->lpVtbl -> EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DirectoryType_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ DIRECTORY_TYPE *pDirectoryType);


void __RPC_STUB ITDirectory_get_DirectoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DisplayName_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ BSTR *pName);


void __RPC_STUB ITDirectory_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_IsDynamic_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ VARIANT_BOOL *pfDynamic);


void __RPC_STUB ITDirectory_get_IsDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DefaultObjectTTL_Proxy( 
    ITDirectory * This,
    /* [retval][out] */ long *pTTL);


void __RPC_STUB ITDirectory_get_DefaultObjectTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITDirectory_put_DefaultObjectTTL_Proxy( 
    ITDirectory * This,
    /* [in] */ long TTL);


void __RPC_STUB ITDirectory_put_DefaultObjectTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_EnableAutoRefresh_Proxy( 
    ITDirectory * This,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB ITDirectory_EnableAutoRefresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_Connect_Proxy( 
    ITDirectory * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB ITDirectory_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_Bind_Proxy( 
    ITDirectory * This,
    /* [in] */ BSTR pDomainName,
    /* [in] */ BSTR pUserName,
    /* [in] */ BSTR pPassword,
    /* [in] */ long lFlags);


void __RPC_STUB ITDirectory_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_AddDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_AddDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_ModifyDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_ModifyDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_RefreshDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_RefreshDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_DeleteDirectoryObject_Proxy( 
    ITDirectory * This,
    /* [in] */ ITDirectoryObject *pDirectoryObject);


void __RPC_STUB ITDirectory_DeleteDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDirectory_get_DirectoryObjects_Proxy( 
    ITDirectory * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITDirectory_get_DirectoryObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITDirectory_EnumerateDirectoryObjects_Proxy( 
    ITDirectory * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [out] */ IEnumDirectoryObject **ppEnumObject);


void __RPC_STUB ITDirectory_EnumerateDirectoryObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDirectory_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectory_INTERFACE_DEFINED__
#define __IEnumDirectory_INTERFACE_DEFINED__

/* interface IEnumDirectory */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6D-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDirectory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ITDirectory **ppElements,
            /* [full][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirectory **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirectory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirectory * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ITDirectory **ppElements,
            /* [full][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirectory * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirectory * This,
            /* [retval][out] */ IEnumDirectory **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryVtbl;

    interface IEnumDirectory
    {
        CONST_VTBL struct IEnumDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirectory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirectory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirectory_Next(This,celt,ppElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched)

#define IEnumDirectory_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirectory_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDirectory_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirectory_Next_Proxy( 
    IEnumDirectory * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ITDirectory **ppElements,
    /* [full][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumDirectory_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Reset_Proxy( 
    IEnumDirectory * This);


void __RPC_STUB IEnumDirectory_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Skip_Proxy( 
    IEnumDirectory * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDirectory_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirectory_Clone_Proxy( 
    IEnumDirectory * This,
    /* [retval][out] */ IEnumDirectory **ppEnum);


void __RPC_STUB IEnumDirectory_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirectory_INTERFACE_DEFINED__ */


#ifndef __ITRendezvous_INTERFACE_DEFINED__
#define __ITRendezvous_INTERFACE_DEFINED__

/* interface ITRendezvous */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITRendezvous;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6B-6CFF-11d1-AFF7-00C04FC31FEE")
    ITRendezvous : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDirectories( 
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDefaultDirectories( 
            /* [out] */ IEnumDirectory **ppEnumDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectory( 
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectory **ppDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectoryObject( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectoryObject **ppDirectoryObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRendezvousVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITRendezvous * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITRendezvous * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITRendezvous * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITRendezvous * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITRendezvous * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITRendezvous * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRendezvous * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultDirectories )( 
            ITRendezvous * This,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDefaultDirectories )( 
            ITRendezvous * This,
            /* [out] */ IEnumDirectory **ppEnumDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectory )( 
            ITRendezvous * This,
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectory **ppDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryObject )( 
            ITRendezvous * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ BSTR pName,
            /* [retval][out] */ ITDirectoryObject **ppDirectoryObject);
        
        END_INTERFACE
    } ITRendezvousVtbl;

    interface ITRendezvous
    {
        CONST_VTBL struct ITRendezvousVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRendezvous_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRendezvous_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRendezvous_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRendezvous_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRendezvous_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRendezvous_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRendezvous_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRendezvous_get_DefaultDirectories(This,pVariant)	\
    (This)->lpVtbl -> get_DefaultDirectories(This,pVariant)

#define ITRendezvous_EnumerateDefaultDirectories(This,ppEnumDirectory)	\
    (This)->lpVtbl -> EnumerateDefaultDirectories(This,ppEnumDirectory)

#define ITRendezvous_CreateDirectory(This,DirectoryType,pName,ppDir)	\
    (This)->lpVtbl -> CreateDirectory(This,DirectoryType,pName,ppDir)

#define ITRendezvous_CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)	\
    (This)->lpVtbl -> CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRendezvous_get_DefaultDirectories_Proxy( 
    ITRendezvous * This,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB ITRendezvous_get_DefaultDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_EnumerateDefaultDirectories_Proxy( 
    ITRendezvous * This,
    /* [out] */ IEnumDirectory **ppEnumDirectory);


void __RPC_STUB ITRendezvous_EnumerateDefaultDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_CreateDirectory_Proxy( 
    ITRendezvous * This,
    /* [in] */ DIRECTORY_TYPE DirectoryType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ ITDirectory **ppDir);


void __RPC_STUB ITRendezvous_CreateDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRendezvous_CreateDirectoryObject_Proxy( 
    ITRendezvous * This,
    /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
    /* [in] */ BSTR pName,
    /* [retval][out] */ ITDirectoryObject **ppDirectoryObject);


void __RPC_STUB ITRendezvous_CreateDirectoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITRendezvous_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rend_0480 */
/* [local] */ 



/***************************************************************/
/* Rend constants -- defined here for C apps                   */
/* The subsequent definitions that MIDL generates from the     */
/* module declaration are not used. The module declaration is  */
/* retained, however, so that the constants show up in the     */
/* type library.                                               */
/***************************************************************/

#define RENDBIND_AUTHENTICATE       0x00000001
#define RENDBIND_DEFAULTDOMAINNAME  0x00000002
#define RENDBIND_DEFAULTUSERNAME    0x00000004
#define RENDBIND_DEFAULTPASSWORD    0x00000008
/* this is just the previous three |'ed together for convenience. */
#define RENDBIND_DEFAULTCREDENTIALS 0x0000000e

#define __RendConstants_MODULE_DEFINED__

/***************************************************************/
/* end of rend constants section                               */
/***************************************************************/




extern RPC_IF_HANDLE __MIDL_itf_rend_0480_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0480_v0_0_s_ifspec;


#ifndef __RENDLib_LIBRARY_DEFINED__
#define __RENDLib_LIBRARY_DEFINED__

/* library RENDLib */
/* [helpstring][version][uuid] */ 








EXTERN_C const IID LIBID_RENDLib;

EXTERN_C const CLSID CLSID_Rendezvous;

#ifdef __cplusplus

class DECLSPEC_UUID("F1029E5B-CB5B-11D0-8D59-00C04FD91AC0")
Rendezvous;
#endif


#ifndef __RendConstants_MODULE_DEFINED__
#define __RendConstants_MODULE_DEFINED__


/* module RendConstants */
/* [helpstring][dllname][uuid] */ 

const long RENDBIND_AUTHENTICATE	=	0x1;

const long RENDBIND_DEFAULTDOMAINNAME	=	0x2;

const long RENDBIND_DEFAULTUSERNAME	=	0x4;

const long RENDBIND_DEFAULTPASSWORD	=	0x8;

const long RENDBIND_DEFAULTCREDENTIALS	=	0xe;

#endif /* __RendConstants_MODULE_DEFINED__ */
#endif /* __RENDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ReplDist.h ===
#ifndef _REPLDIST_H_
#define _REPLDIST_H_

// OLEDB header
#include "oledb.h"

#ifndef __IDistributionStore_FWD_DEFINED__
#define __IDistributionStore_FWD_DEFINED__
typedef interface IDistributionStore IDistributionStore;
#endif 	/* __IDistributionStore_FWD_DEFINED__ */

#ifndef __IDistributionStore_INTERFACE_DEFINED__
#define __IDistributionStore_INTERFACE_DEFINED__

//	SQLDistributionStore's CLSID
// {16D9A8E2-C326-11d0-94E9-00C04FC2DB9C}
DEFINE_GUID(CLSID_SQLDistribution, 
0x16d9a8e2, 0xc326, 0x11d0, 0x94, 0xe9, 0x0, 0xc0, 0x4f, 0xc2, 0xdb, 0x9c);

 // {63797CA0-9684-11d0-94DD-00C04FC2DB9C}
DEFINE_GUID(IID_IDistributionStore, 
0x63797ca0, 0x9684, 0x11d0, 0x94, 0xdd, 0x0, 0xc0, 0x4f, 0xc2, 0xdb, 0x9c);

// {074EACFD-A791-11d0-94E0-00C04FC2DB9C}
DEFINE_GUID(IID_IDistributionLog, 
0x74eacfd, 0xa791, 0x11d0, 0x94, 0xe0, 0x0, 0xc0, 0x4f, 0xc2, 0xdb, 0x9c);

typedef DWORD DISTCMDTYPE;

class DistByteArray 
{
private:
	BYTE rgDistByteArray[16];
public:
	DistByteArray(){memset(rgDistByteArray, 0, sizeof(rgDistByteArray));}
	~DistByteArray(){}

	BYTE* operator& ()
	{
		return rgDistByteArray;
	}

	// Pre-increment
	DistByteArray& operator++ ()
	{
		return Increment();
	}

	// Post-increment
	DistByteArray& operator++ (int dummy)
	{
		return Increment();
	}

	DistByteArray& Increment()
	{
		for (int i=sizeof(rgDistByteArray)-1; i>=0; i--)
		{
			UCHAR *pByte = ((UCHAR *) rgDistByteArray + i);
			if (0xFF == *pByte)
			{
				*pByte = 0;
				continue;
			}
			else
			{
				(*pByte)++;
				break;
			}
		}
		return *this;
	}
};

enum DISTCMDTYPEENUM
    {	
	DISTCMDTYPE_SQL	= 1,
	DISTCMDTYPE_SCRIPT = 2,
	DISTCMDTYPE_NATIVE_BCP = 3,
	DISTCMDTYPE_CHAR_BCP = 4,
	DISTCMDTYPE_SQL_WORKINGDIR = 7
    };

typedef struct  tagDISTCOMMANDDESC
    {
    INT		PublicationId;
    INT		ArticleId;
	INT		CommandId;
	DISTCMDTYPE	CommandType;
	BOOL	fPartialCommand;
	LPSTR	szCommand;
	BYTE*	pXactId;
	BYTE*	pXactSeqno;
	LPSTR	szOriginator;
	LPSTR	szOriginatorDB;
    }	DISTCOMMANDDESC;


// Error source type
typedef enum {
	DIST_SOURCE_NULL		= 0,
	DIST_SOURCE_COMMAND		= 1,
	DIST_SOURCE_AGENT		= 2,
	DIST_SOURCE_OS			= 3,
	DIST_SOURCE_ODBC		= 4,
	DIST_SOURCE_SQLSERVER	= 5
} DISTERRSRCTYPE;


typedef struct  tagDISTERRORDESC
    {
    DISTERRSRCTYPE		SourceType; 
	CHAR				szSourceName[31]; 
	CHAR				szErrorCode[31];
	BSTR				bstrErrorText;
    }	DISTERRORDESC;

typedef DWORD DISTLOGSTATUS;

enum DISTLOGSTATUSENUM
    {	
	DISTLOG_STARTUP = 1,
	DISTLOG_SUCCESS = 2,
	DISTLOG_INPROGRESS = 3,
	DISTLOG_IDLE = 4,
	DISTLOG_RETRY = 5,
	DISTLOG_FAILURE = 6
    };

typedef BYTE DISTAPPTYPE;

enum DISTTYPEENUM
    {	
	DISTTYPE_SNAPSHOT = 0,
	DISTTYPE_LOGREADER = 1
    };


enum DISTPROPENUM  
    {	DBPROP_INIT_PUBLISHER_NAME = 0xFF1,
		DBPROP_INIT_PUBLISHER_DATASOURCE = 0xFF2,
		DBPROP_INIT_XACTID_SIZE = 0xFF3,
		DBPROP_INIT_XACT_SEQNO_SIZE = 0xFF4,
		DBPROP_PUBLICATION_NAME = 0xFF5,
		DBPROP_APPLICATION_NAME = 0xFF6,
		DBPROP_APPLICATION_TYPE = 0xFF7
    };

EXTERN_C const IID IID_IDistributionStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDistributionStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetLastTransaction(
			/* [out] */ BYTE* pXactId,
			/* [out] */ BYTE* pXactSeqno) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddTransactionCommands( 
            /* [in] */ ULONG cCommandDescs,
            /* [size_is][in] */ const DISTCOMMANDDESC __RPC_FAR rgCommandDescs[  ]) = 0;
        virtual HRESULT STDMETHODCALLTYPE StartTransaction( void) = 0;
    };
    
#else 	/* C style interface */

    typedef struct IDistributionStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDistributionStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDistributionStore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDistributionStore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IDistributionStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IDistributionStore __RPC_FAR * This);
        
		HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastTransaction )( 
            IDistributionStore __RPC_FAR * This,
			/* [out] */ BYTE* pXactId,
			/* [out] */ BYTE* pXactSeqno);
        
		HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTransactionCommands )( 
            IDistributionStore __RPC_FAR * This,
            /* [in] */ ULONG cCommandDescs,
            /* [size_is][in] */ const DISTCOMMANDDESC __RPC_FAR rgCommandDescs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartTransaction )( 
            IDistributionStore __RPC_FAR * This);

        END_INTERFACE
    } IDistributionStoreVtbl;

    interface IDistributionStore
    {
        CONST_VTBL struct IDistributionStoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS

#define IDistributionStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDistributionStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDistributionStore_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define IDistributionStore_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IDistributionStore_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IDistributionStore_GetLastTransaction(This)	\
    (This)->lpVtbl -> GetLastTransaction(This, pXactId, pXactSeqno)

#define IDistributionStore_AddTransactionCommands(This)	\
    (This)->lpVtbl -> AddTransactionCommands(This, cCommandDescs, rgCommandDescs)

#define IDistributionStore_StartTransaction(This)	\
    (This)->lpVtbl -> StartTransaction(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDistributionStore_Abort_Proxy( 
    IDistributionStore __RPC_FAR * This);


void __RPC_STUB IDistributionStore_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

HRESULT STDMETHODCALLTYPE IDistributionStore_Commit_Proxy( 
    IDistributionStore __RPC_FAR * This);


void __RPC_STUB IDistributionStore_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributionStore_GetLastTransaction_Proxy( 
    IDistributionStore __RPC_FAR * This,
	BYTE* pXactId,
	BYTE* pXactSeqno);


void __RPC_STUB IDistributionStore_GetLastTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributionStore_AddTransactionCommands_Proxy( 
    IDistributionStore __RPC_FAR * This,
    ULONG cCommandDescs,
    const DISTCOMMANDDESC __RPC_FAR rgCommandDescs[  ]);


void __RPC_STUB IDistributionStore_AddTransactionCommands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributionStore_StartTransaction_Proxy( 
    IDistributionStore __RPC_FAR * This);


void __RPC_STUB IDistributionStore_StartTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


#endif 	/* __IDistributionStore_INTERFACE_DEFINED__ */

#ifndef __IDistributionLog_FWD_DEFINED__
#define __IDistributionLog_FWD_DEFINED__
typedef interface IDistributionLog IDistributionLog;
#endif 	/* __IDistributionLog_FWD_DEFINED__ */

#ifndef __IDistributionLog_INTERFACE_DEFINED__
#define __IDistributionLog_INTERFACE_DEFINED__

EXTERN_C const IID IID_IDistributionLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDistributionLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddLog( 
            /* [in] */ DWORD dwStatusId,
            /* [in] */ LPSTR szComment,
			/* [in] */ BYTE* pXactSeqno,
			/* [in] */ ULONG ulTransactions,
			/* [in] */ ULONG ulCommands,
            /* [in] */ ULONG cErrorDescs,
            /* [size_is][in] */ const DISTERRORDESC __RPC_FAR rgErrorDescs[  ]) = 0;
    };
    
#else 	/* C style interface */

    typedef struct IDistributionLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDistributionLog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDistributionLog __RPC_FAR * This);
        
       	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLog )( 
            IDistributionLog __RPC_FAR * This,
            /* [in] */ DWORD dwStatusId,
            /* [in] */ LPSTR szComment,
			/* [in] */ BYTE* pXactSeqno,
			/* [in] */ ULONG ulTransactions,
			/* [in] */ ULONG ulCommands,
            /* [in] */ ULONG cErrorDescs,
            /* [size_is][in] */ const DISTERRORDESC __RPC_FAR rgErrorDescs[  ]);
        
        END_INTERFACE
    } IDistributionLogVtbl;

    interface IDistributionLog
    {
        CONST_VTBL struct IDistributionLogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS

#define IDistributionLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDistributionLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDistributionLog_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define IDistributionLog_AddLog(This)	\
    (This)->lpVtbl -> AddLog(This, dwStatusId, szComment, pXactSeqno, cTransactions, cCommands, cErrorDescs, rgErrorDescs)

#endif /* COBJMACROS */


#endif 	/* C style interface */


HRESULT STDMETHODCALLTYPE IDistributionLog_AddLog_Proxy( 
    IDistributionLog __RPC_FAR * This,
	DWORD dwStatusId,
    LPSTR szComment,
	BYTE* pXactSeqno,
	ULONG ulTransactions,
	ULONG ulCommands,
    ULONG cErrorDescs,
    const DISTERRORDESC __RPC_FAR rgErrorDescs[  ]);


void __RPC_STUB IDistributionLog_AddLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IDistributionLog_INTERFACE_DEFINED__ */


#ifndef __IGetCustomErrorInfo_FWD_DEFINED__
#define __IGetCustomErrorInfo_FWD_DEFINED__
typedef interface IGetCustomErrorInfo IGetCustomErrorInfo ;
#endif 	/* __IGetCustomErrorInfo_FWD_DEFINED__ */


#ifndef __IGetCustomErrorInfo_INTERFACE_DEFINED__
#define __IGetCustomErrorInfo_INTERFACE_DEFINED__

// @msg IID_IGetCustomErrorInfo |  {D83B7C8D-F22F-11d0-9AE8-00C04FB6B6EF}
// Interface ID to the IGetCustomErrorInfo interface
DEFINE_GUID(IID_IGetCustomErrorInfo, 0xd83b7c8d, 0xf22f, 0x11d0, 0x9a, 0xe8, 0x0, 0xc0, 0x4f, 0xb6, 0xb6, 0xef);

// @msg CLSID_DistErrorLookup | {246CBC55-F3E8-11d0-9AEB-00C04FB6B6EF}
// ID of the Distribution Error Lookup Service class
DEFINE_GUID(CLSID_DistErrorLookup,0x246cbc55, 0xf3e8, 0x11d0, 0x9a, 0xeb, 0x0, 0xc0, 0x4f, 0xb6, 0xb6, 0xef);


EXTERN_C const IID IID_IGetCustomErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGetCustomErrorInfo : public IUnknown
    {
    public:
		virtual HRESULT STDMETHODCALLTYPE GetCustomErrorInfo(DISTERRORDESC * pDistErrorDesc) = 0;
    };
    
#else 	/* C style interface */

    typedef struct IGetCustomErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetCustomErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetCustomErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetCustomErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCustomErrorInfo )( 
            IGetCustomErrorInfo __RPC_FAR * This,
			/* out */ REPL_ERROR * pReplError);
        
        END_INTERFACE
    } IGetCustomErrorInfoVtbl;

    interface IGetCustomErrorInfo
    {
        CONST_VTBL struct IGetCustomErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetCustomErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetCustomErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetCustomErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define IGetCustomErrorInfo_GetCustomErrorInfo(This,pReplError)	\
    (This)->lpVtbl -> GetCustomErrorInfo(This,pReplError)

#endif /* COBJMACROS */


#endif 	/* C style interface */

#endif 	/* __IGetCustomErrorInfo_INTERFACE_DEFINED__ */

#endif // _REPLDIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rmfacade.h ===
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1996	Microsoft Corporation.	All Rights Reserved

@doc

@module		RMFacade.h	|

			Contains helper API and interfaces for RMFacade which faciliates
			OLE TX to XA protocol mapping

-------------------------------------------------------------------------------
@rev 	0 	| 23rd-Nov-1996	|	GaganC		| Created with API
----------------------------------------------------------------------------- */
#ifndef __RMFACADE_H__
#define __RMFACADE_H__


//---------------------------------------------------------
//		ALL INCLUDE FILES GO HERE
//---------------------------------------------------------
#include <windows.h>
#include "transact.h"
#include "txcoord.h"
#include "xa.h"


//---------------------------------------------------------
//			Typedefs
//---------------------------------------------------------
typedef enum _XactStatus
	{
		XACT_STATUS_NONE = 0,		//should never be encountered
		XACT_STATUS_ABORTED,
		XACT_STATUS_COMMITTED,		
		XACT_STATUS_NOT_MY_TRANSACTION,
		XACT_STATUS_TIMEOUT
	} XACT_STATUS;



//---------------------------------------------------------
//			Function Prototypes
//---------------------------------------------------------

extern "C"
{
	HRESULT __stdcall GetDtcTxToXaMapperHelper
									(
									 /* [in] */		REFIID riid, 
									 /* [out] */	void ** ppv
									);

	HRESULT	__stdcall GetXARMClient 
									(
									 /* [in] */		REFIID riid, 
									 /* [out] */	void ** ppv
									);
} //end all 'C' language API




//---------------------------------------------------------
//			ALL Errors Go Here
//---------------------------------------------------------
#define E_FAILED_TO_LOAD_DLL		0x8004D201L



//---------------------------------------------------------
//			All	Interface IIDs go here 
//---------------------------------------------------------

//IID_IResourceManagerFacade {EE5FF7B1-4572-11d0-9452-00A0C905416E}
DEFINE_GUID(IID_IResourceManagerFacade, 
			0xee5ff7b1,
			0x4572,
			0x11d0,
			0x94, 0x52, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x6e);


//IID_IResourceManagerClient {EE5FF7B2-4572-11d0-9452-00A0C905416E}
DEFINE_GUID(IID_IResourceManagerClient, 
			0xee5ff7b2,
			0x4572,
			0x11d0,
			0x94, 0x52, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x6e);


//---------------------------------------------------------
//			All	Interfaces go here 
//---------------------------------------------------------


/* ----------------------------------------------------------------------------
@interface <IResourceManagerFacade>

	Implemented by DTC Proxy for use by the client libraries of the XA RMs so 
	they can get the OLE TX to XA Mapping
---------------------------------------------------------------------------- */
#undef INTERFACE
#define INTERFACE IResourceManagerFacade

DECLARE_INTERFACE_ (IResourceManagerFacade, IUnknown)
{
	// IUnknown interface methods:
	STDMETHOD	(QueryInterface)	(THIS_ REFIID riid, LPVOID FAR * ppv) PURE;
 	STDMETHOD_	(ULONG, AddRef)		(THIS) 	PURE;
 	STDMETHOD_	(ULONG, Release)	(THIS) 	PURE;

	//methods for this interface
	STDMETHOD (CreateNewResourceManager) 
								(
									/*[in]*/ char * pszDSN,
									/*[in]*/ char * pszClientDllName,
									/* [in-out] */ DWORD * pdwRMCookie
								) PURE;

	STDMETHOD (EnlistOnTransaction)
								(
									/* [in] */ DWORD dwRMCookie,
									/* [in] */ ITransaction * pITransaction,
									/* [in-out] */ XID * pxid,
									/* [in] */ ITransactionResource * pITransRes
								) PURE;

	STDMETHOD (FindTransactionOutcome)
								(
									/* [in] */ DWORD dwRMCookie,
									/* [in] */ XID * pxid,
									/* [in-out] */ XACT_STATUS * pXactStatus
								) PURE;

	STDMETHOD (RecoveryComplete)
								(
									/* [in] */ DWORD dwRMCookie
								) PURE;

}; //end interface IResourceManagerFacade



/* ----------------------------------------------------------------------------
@interface <IID_IResourceManagerClient>

	Implemented by the client libraries of the XA RMs which are providing the
	OLE TX to XA Mapping. This interface will be used by DTC to drive recovery
---------------------------------------------------------------------------- */
#undef INTERFACE
#define INTERFACE IID_IResourceManagerClient

DECLARE_INTERFACE_ (IID_IResourceManagerClient, IUnknown)
{
	// IUnknown interface methods:
	STDMETHOD	(QueryInterface)	(THIS_ REFIID riid, LPVOID FAR * ppv) PURE;
 	STDMETHOD_	(ULONG, AddRef)		(THIS) 	PURE;
 	STDMETHOD_	(ULONG, Release)	(THIS) 	PURE;

	STDMETHOD (DoRecovery)
								(
									/* [in] */ DWORD dwRMCookie,
									/* [in] */ char * pszDSN
								) PURE;

}; //end interface IResourceManagerClient



#endif __RMFACADE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ReplErrx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Nov 13 00:28:52 1998
 */
/* Compiler settings for r:\SPHINX\SQLREPL\common\inc\replerrx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __replerrx_h__
#define __replerrx_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISQLReplError_FWD_DEFINED__
#define __ISQLReplError_FWD_DEFINED__
typedef interface ISQLReplError ISQLReplError;
#endif 	/* __ISQLReplError_FWD_DEFINED__ */


#ifndef __ISQLReplErrors_FWD_DEFINED__
#define __ISQLReplErrors_FWD_DEFINED__
typedef interface ISQLReplErrors ISQLReplErrors;
#endif 	/* __ISQLReplErrors_FWD_DEFINED__ */


#ifndef __SQLReplErrors_FWD_DEFINED__
#define __SQLReplErrors_FWD_DEFINED__

#ifdef __cplusplus
typedef class SQLReplErrors SQLReplErrors;
#else
typedef struct SQLReplErrors SQLReplErrors;
#endif /* __cplusplus */

#endif 	/* __SQLReplErrors_FWD_DEFINED__ */


#ifndef __SQLReplError_FWD_DEFINED__
#define __SQLReplError_FWD_DEFINED__

#ifdef __cplusplus
typedef class SQLReplError SQLReplError;
#else
typedef struct SQLReplError SQLReplError;
#endif /* __cplusplus */

#endif 	/* __SQLReplError_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_replerrx_0000
 * at Fri Nov 13 00:28:52 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef 
enum ERRORSOURCE_TYPE
    {	INVALID_SOURCE_TYPE	= 0,
	SQL_COMMAND	= 1,
	REPL_CONTROL	= 2,
	OPERATING_SYSTEM	= 3,
	ODBC_API	= 4,
	SQLSERVER_ENGINE	= 5,
	NET_LIBRARY	= 6,
	SQLDMO	= 7
    }	REPL_ERRORSOURCE_TYPE;

#define REPLX_E_DBEXISTS				MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e00)
#define REPLX_E_DBNOTFOUND			MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e01)
#define REPLX_E_SUBEXISTS			MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e02)
#define REPLX_E_SUBNOTFOUND			MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e03)
#define REPLX_E_SUBEXPIRED			MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e04)
#define REPLX_E_DEADLOCK				MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e05)
#define REPLX_E_PROFILENOTFOUND		MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e06)
#define REPLX_E_RETRYFAILURE			MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x0e07)
#define REPLX_S_VALIDATIONFAILED		MAKE_SCODE(SEVERITY_SUCCESS,FACILITY_ITF,0x0100)
#define REPLX_S_CONFLICTSOCCURRED	MAKE_SCODE(SEVERITY_SUCCESS,FACILITY_ITF,0x0101)


extern RPC_IF_HANDLE __MIDL_itf_replerrx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_replerrx_0000_v0_0_s_ifspec;

#ifndef __ISQLReplError_INTERFACE_DEFINED__
#define __ISQLReplError_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLReplError
 * at Fri Nov 13 00:28:52 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISQLReplError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("35CE087C-2E4E-11D2-B6D4-00C04FB93D6B")
    ISQLReplError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorNumber( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorNumber( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceType( 
            /* [retval][out] */ REPL_ERRORSOURCE_TYPE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceType( 
            /* [in] */ REPL_ERRORSOURCE_TYPE newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLReplErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLReplError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLReplError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISQLReplError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            ISQLReplError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][restricted][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            ISQLReplError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][restricted][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorNumber )( 
            ISQLReplError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][restricted][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ErrorNumber )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceType )( 
            ISQLReplError __RPC_FAR * This,
            /* [retval][out] */ REPL_ERRORSOURCE_TYPE __RPC_FAR *pVal);
        
        /* [helpstring][restricted][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceType )( 
            ISQLReplError __RPC_FAR * This,
            /* [in] */ REPL_ERRORSOURCE_TYPE newVal);
        
        END_INTERFACE
    } ISQLReplErrorVtbl;

    interface ISQLReplError
    {
        CONST_VTBL struct ISQLReplErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLReplError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLReplError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLReplError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLReplError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISQLReplError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISQLReplError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISQLReplError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISQLReplError_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define ISQLReplError_put_Description(This,newVal)	\
    (This)->lpVtbl -> put_Description(This,newVal)

#define ISQLReplError_get_Source(This,pVal)	\
    (This)->lpVtbl -> get_Source(This,pVal)

#define ISQLReplError_put_Source(This,newVal)	\
    (This)->lpVtbl -> put_Source(This,newVal)

#define ISQLReplError_get_ErrorNumber(This,pVal)	\
    (This)->lpVtbl -> get_ErrorNumber(This,pVal)

#define ISQLReplError_put_ErrorNumber(This,newVal)	\
    (This)->lpVtbl -> put_ErrorNumber(This,newVal)

#define ISQLReplError_get_SourceType(This,pVal)	\
    (This)->lpVtbl -> get_SourceType(This,pVal)

#define ISQLReplError_put_SourceType(This,newVal)	\
    (This)->lpVtbl -> put_SourceType(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplError_get_Description_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISQLReplError_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE ISQLReplError_put_Description_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISQLReplError_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplError_get_Source_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISQLReplError_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE ISQLReplError_put_Source_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISQLReplError_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplError_get_ErrorNumber_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ISQLReplError_get_ErrorNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE ISQLReplError_put_ErrorNumber_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ISQLReplError_put_ErrorNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplError_get_SourceType_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [retval][out] */ REPL_ERRORSOURCE_TYPE __RPC_FAR *pVal);


void __RPC_STUB ISQLReplError_get_SourceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id][propput] */ HRESULT STDMETHODCALLTYPE ISQLReplError_put_SourceType_Proxy( 
    ISQLReplError __RPC_FAR * This,
    /* [in] */ REPL_ERRORSOURCE_TYPE newVal);


void __RPC_STUB ISQLReplError_put_SourceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLReplError_INTERFACE_DEFINED__ */


#ifndef __ISQLReplErrors_INTERFACE_DEFINED__
#define __ISQLReplErrors_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLReplErrors
 * at Fri Nov 13 00:28:52 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISQLReplErrors;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("35CE087B-2E4E-11D2-B6D4-00C04FB93D6B")
    ISQLReplErrors : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get_NewEnum( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *ppvObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *cMembers) = 0;
        
        virtual /* [helpstring][restricted][id] */ HRESULT STDMETHODCALLTYPE AddReplError( 
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrSource,
            /* [in] */ long lErrorNumber,
            /* [in] */ REPL_ERRORSOURCE_TYPE ErrorSourceType) = 0;
        
        virtual /* [helpstring][restricted][id] */ HRESULT STDMETHODCALLTYPE ClearErrors( void) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ISQLReplError __RPC_FAR *__RPC_FAR *ppobj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLReplErrorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLReplErrors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLReplErrors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NewEnum )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *ppvObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *cMembers);
        
        /* [helpstring][restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddReplError )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrSource,
            /* [in] */ long lErrorNumber,
            /* [in] */ REPL_ERRORSOURCE_TYPE ErrorSourceType);
        
        /* [helpstring][restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearErrors )( 
            ISQLReplErrors __RPC_FAR * This);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ISQLReplErrors __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ISQLReplError __RPC_FAR *__RPC_FAR *ppobj);
        
        END_INTERFACE
    } ISQLReplErrorsVtbl;

    interface ISQLReplErrors
    {
        CONST_VTBL struct ISQLReplErrorsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLReplErrors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLReplErrors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLReplErrors_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLReplErrors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISQLReplErrors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISQLReplErrors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISQLReplErrors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISQLReplErrors_get_NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> get_NewEnum(This,ppvObject)

#define ISQLReplErrors_get_Count(This,cMembers)	\
    (This)->lpVtbl -> get_Count(This,cMembers)

#define ISQLReplErrors_AddReplError(This,bstrDescription,bstrSource,lErrorNumber,ErrorSourceType)	\
    (This)->lpVtbl -> AddReplError(This,bstrDescription,bstrSource,lErrorNumber,ErrorSourceType)

#define ISQLReplErrors_ClearErrors(This)	\
    (This)->lpVtbl -> ClearErrors(This)

#define ISQLReplErrors_get_Item(This,varIndex,ppobj)	\
    (This)->lpVtbl -> get_Item(This,varIndex,ppobj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplErrors_get_NewEnum_Proxy( 
    ISQLReplErrors __RPC_FAR * This,
    /* [retval][out] */ LPUNKNOWN __RPC_FAR *ppvObject);


void __RPC_STUB ISQLReplErrors_get_NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplErrors_get_Count_Proxy( 
    ISQLReplErrors __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *cMembers);


void __RPC_STUB ISQLReplErrors_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id] */ HRESULT STDMETHODCALLTYPE ISQLReplErrors_AddReplError_Proxy( 
    ISQLReplErrors __RPC_FAR * This,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrSource,
    /* [in] */ long lErrorNumber,
    /* [in] */ REPL_ERRORSOURCE_TYPE ErrorSourceType);


void __RPC_STUB ISQLReplErrors_AddReplError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][id] */ HRESULT STDMETHODCALLTYPE ISQLReplErrors_ClearErrors_Proxy( 
    ISQLReplErrors __RPC_FAR * This);


void __RPC_STUB ISQLReplErrors_ClearErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ISQLReplErrors_get_Item_Proxy( 
    ISQLReplErrors __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ISQLReplError __RPC_FAR *__RPC_FAR *ppobj);


void __RPC_STUB ISQLReplErrors_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLReplErrors_INTERFACE_DEFINED__ */



#ifndef __REPLERRXLib_LIBRARY_DEFINED__
#define __REPLERRXLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: REPLERRXLib
 * at Fri Nov 13 00:28:52 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_REPLERRXLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SQLReplErrors;

class DECLSPEC_UUID("A784FF38-2E3B-11D2-B6D4-00C04FB93D6B")
SQLReplErrors;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SQLReplError;

class DECLSPEC_UUID("35CE087D-2E4E-11D2-B6D4-00C04FB93D6B")
SQLReplError;
#endif
#endif /* __REPLERRXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\retcode.h ===
// --retcode.h------------------------------------------------------------------
//
// Copyright (c) Microsoft Corp. 1986-1999. All Rights Reserved.
//
//  Header file for return codes and exit codes.
// 
// -----------------------------------------------------------------------------
#if !defined(_RETCODE_H)
#define _RETCODE_H

//$--_Rc-----------------------------------------------------------------------
//  Available return codes.
// ----------------------------------------------------------------------------
typedef enum _rc {
    RC_SUCCESS = 0,   
    RC_ERROR,               // general error
    RC_PROTOCOL,            // protocol error 
    RC_SYNTAX,              // syntax error
    RC_EOF,                 // end of file
    RC_IMPLEMENTATION,      // not implemented yet
    RC_SOFTWARE,            // error in software
    RC_CONFIG,              // configuration error
    RC_MEMORY,              // memory allocation error 
    RC_CONTENTION,          // contention error
    RC_NOTFOUND,            // not found
    RC_DISKSPACE,           // out of disk space
    RC_SHUTDOWN,            // service shutdown
    RC_EXPIRED,             // expired
    RC_TIMEOUT,             // timeout
    RC_INVALID_PARAMETER,   // invalid parameter
    RC_LAST                 // all errors are less than this
} RC;

//$--_Ec-----------------------------------------------------------------------
//  Available exit codes.
// ----------------------------------------------------------------------------
typedef enum _ec {
    EC_SUCCESS = 0,   
    EC_ERROR,           // general error
    EC_LAST             // all errors are less than this
} EC;

// ----------------------------------------------------------------------------
//  Macros.
// ----------------------------------------------------------------------------

#define RC_SUCCEEDED(x) \
    ((x) == RC_SUCCESS)

#define RC_FAILED(x) \
    ((x) != RC_SUCCESS)

#define EC_SUCCEEDED(x) \
    ((x) == EC_SUCCESS)

#define EC_FAILED(x) \
    ((x) != EC_SUCCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rndnot.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Wed Sep 03 19:09:22 1997
 */
/* Compiler settings for rndnot.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rndnot_h__
#define __rndnot_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITNotification_FWD_DEFINED__
#define __ITNotification_FWD_DEFINED__
typedef interface ITNotification ITNotification;
#endif 	/* __ITNotification_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_rndnot_0000
 * at Wed Sep 03 19:09:22 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef 
enum RND_NOTIFICATION_ID
    {	NI_SUB_TYPE	= 1,
	NI_ORIGINATOR	= 2,
	NI_ANNOUNCEMENT_SCOPE	= 3,
	NI_ADVERTISING_SCOPE	= 4,
	NI_URL	= 5,
	NI_DESCRIPTION	= 6,
	NI_START_TIME	= 7,
	NI_STOP_TIME	= 8,
	NI_CONFERENCE_BLOB	= 9
    }	RND_NOTIFICATION_ID;

typedef 
enum RND_ADVERTISING_SCOPE
    {	AS_LOCAL	= 1,
	AS_SITE	= 2,
	AS_REGION	= 3,
	AS_WORLD	= 4
    }	RND_ADVERTISING_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_rndnot_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rndnot_0000_v0_0_s_ifspec;

#ifndef __ITNotification_INTERFACE_DEFINED__
#define __ITNotification_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITNotification
 * at Wed Sep 03 19:09:22 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ITNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dda68522-b6a5-11d0-a489-00c04fd91ac0")
    ITNotification : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeNotification( 
            /* [in] */ RND_NOTIFICATION_ID NotificationId,
            /* [in] */ VARIANT newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITNotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITNotification __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITNotification __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITNotification __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITNotification __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeNotification )( 
            ITNotification __RPC_FAR * This,
            /* [in] */ RND_NOTIFICATION_ID NotificationId,
            /* [in] */ VARIANT newVal);
        
        END_INTERFACE
    } ITNotificationVtbl;

    interface ITNotification
    {
        CONST_VTBL struct ITNotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITNotification_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITNotification_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITNotification_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITNotification_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITNotification_ChangeNotification(This,NotificationId,newVal)	\
    (This)->lpVtbl -> ChangeNotification(This,NotificationId,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITNotification_ChangeNotification_Proxy( 
    ITNotification __RPC_FAR * This,
    /* [in] */ RND_NOTIFICATION_ID NotificationId,
    /* [in] */ VARIANT newVal);


void __RPC_STUB ITNotification_ChangeNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITNotification_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\RefPtrCo.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( ... )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpc.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AXP64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#endif

#define __RPC_FAR

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined(__RPC_MAC__)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\resapi.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    resapi.h

Abstract:

    This module defines the interface exported by Windows Clusters resources.

Revision History:

--*/

#ifndef _RESAPI_DEFINES_
#define _RESAPI_DEFINES_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <winsvc.h>
#include <clusapi.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT

//
// Definitions for entrypoints exported by a resource DLL.
//
#define STARTUP_ROUTINE "Startup"

#define CLRES_V1_FUNCTION_SIZE   sizeof(CLRES_V1_FUNCTIONS)
#define CLRES_VERSION_V1_00    0x100

#define CLRES_V1_FUNCTION_TABLE( _Name,                     \
                                 _Version,                  \
                                 _Prefix,                   \
                                 _Arbitrate,                \
                                 _Release,                  \
                                 _ResControl,               \
                                 _ResTypeControl            \
                                 )                          \
CLRES_FUNCTION_TABLE _Name = { CLRES_V1_FUNCTION_SIZE,      \
                               _Version,                    \
                               _Prefix##Open,               \
                               _Prefix##Close,              \
                               _Prefix##Online,             \
                               _Prefix##Offline,            \
                               _Prefix##Terminate,          \
                               _Prefix##LooksAlive,         \
                               _Prefix##IsAlive,            \
                               _Arbitrate,                  \
                               _Release,                    \
                               _ResControl,                 \
                               _ResTypeControl }

#endif // ifndef _RESAPI_DEFINES_

#ifndef _RESAPI_
#define _RESAPI_

//
// Define a RESID
//

typedef PVOID RESID;

//
// Define a RESOURCE_HANDLE
//

typedef HANDLE   RESOURCE_HANDLE;

//
// Define the Resource Status structure.
//

typedef struct RESOURCE_STATUS {
    CLUSTER_RESOURCE_STATE  ResourceState;
    DWORD           CheckPoint;
    DWORD           WaitHint;
    HANDLE          EventHandle;
} RESOURCE_STATUS, *PRESOURCE_STATUS;


#define ResUtilInitializeResourceStatus( _resource_status_ ) \
    ZeroMemory( _resource_status_, sizeof(RESOURCE_STATUS) )

//
// Define Resource DLL callback method for updating the state of a resource.
//

typedef
DWORD
(_stdcall *PSET_RESOURCE_STATUS_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

//
// Define Resource DLL callback method for notifying that a quorum
// resource DLL failed to hold the quorum resource.
//
typedef
VOID
(_stdcall *PQUORUM_RESOURCE_LOST) (
    IN RESOURCE_HANDLE Resource
    );

//
// Define Resource DLL callback method for logging events.
//
typedef enum LOG_LEVEL {
    LOG_INFORMATION,
    LOG_WARNING,
    LOG_ERROR,
    LOG_SEVERE
} LOG_LEVEL, *PLOG_LEVEL;

typedef
VOID
(_stdcall *PLOG_EVENT_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    );

typedef
RESID
(_stdcall *POPEN_ROUTINE) (
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

typedef
VOID
(_stdcall *PCLOSE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PONLINE_ROUTINE) (
    IN RESID Resource,
    IN OUT LPHANDLE EventHandle
    );

typedef
DWORD
(_stdcall *POFFLINE_ROUTINE) (
    IN RESID Resource
    );

typedef
VOID
(_stdcall *PTERMINATE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PIS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PLOOKS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PARBITRATE_ROUTINE) (
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    );

typedef
DWORD
(_stdcall *PRELEASE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PRESOURCE_CONTROL_ROUTINE) (
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef
DWORD
(_stdcall *PRESOURCE_TYPE_CONTROL_ROUTINE) (
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef enum _RESOURCE_EXIT_STATE {
    ResourceExitStateContinue,
    ResourceExitStateTerminate,
    ResourceExitStateMax
} RESOURCE_EXIT_STATE;


//***************************************************************
//
// Define the Function Table Format
//
//***************************************************************

//
// Version 1 Resource DLL Interface definition
//
typedef struct CLRES_V1_FUNCTIONS {
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PIS_ALIVE_ROUTINE IsAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
} CLRES_V1_FUNCTIONS, *PCLRES_V1_FUNCTIONS;

//
// Resource DLL Function Table definition
//
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLRES_FUNCTION_TABLE {
    DWORD   TableSize;
    DWORD   Version;
    union {
        CLRES_V1_FUNCTIONS V1Functions;
    };
} CLRES_FUNCTION_TABLE, *PCLRES_FUNCTION_TABLE;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union
#endif

//
// Define the Resource DLL Startup routine. This is the only routine
// that should be exported from a resource DLL.
//

//
// Calculate the byte offset of a field in a structure of type type.
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

//
// Property list structures and functions
//
typedef struct RESUTIL_PROPERTY_ITEM {
    LPWSTR  Name;               // Property name
    LPWSTR  KeyName;            // Name of value in cluster database
    DWORD   Format;             // Format: REG_SZ, REG_DWORD, etc.
    union {
        DWORD_PTR  DefaultPtr;
        DWORD      Default;     // Default value
        LPVOID     lpDefault;
    };
    DWORD   Minimum;            // Minimum value
    DWORD   Maximum;            // Maximum value
    DWORD   Flags;              // Flags for this item
#define RESUTIL_PROPITEM_READ_ONLY  0x00000001  // Property is read-only
#define RESUTIL_PROPITEM_REQUIRED   0x00000002  // Property is required
#define RESUTIL_PROPITEM_SIGNED     0x00000004  // Numeric property is signed (defaults to unsigned)

    DWORD   Offset;             // Byte offset to value in parameter block
                                //   Assumes MULTI_SZ and BINARY parameters
                                //   are LPWSTRs followed by DWORDs for length
} RESUTIL_PROPERTY_ITEM, *PRESUTIL_PROPERTY_ITEM;


typedef
DWORD
(_stdcall *PSTARTUP_ROUTINE) (
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

//
// Define layout of shared memory used for tracking Resource Monitor state.
//
typedef enum RESOURCE_MONITOR_STATE {
    RmonInitializing,
    RmonIdle,
    RmonStartingResource,
    RmonInitializingResource,
    RmonOnlineResource,
    RmonOfflineResource,
    RmonShutdownResource,
    RmonDeletingResource,
    RmonIsAlivePoll,
    RmonLooksAlivePoll,
    RmonArbitrateResource,
    RmonReleaseResource,
    RmonResourceControl,
    RmonResourceTypeControl
} RESOURCE_MONITOR_STATE;

typedef struct MONITOR_STATE {
    LARGE_INTEGER LastUpdate;
    RESOURCE_MONITOR_STATE State;
    HANDLE ActiveResource;
    BOOL   ResmonStop;
} MONITOR_STATE, *PMONITOR_STATE;


//
// Resource Utility Routines
//

DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    );

BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    );

DWORD
WINAPI
ResUtilEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilEnumPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetAllProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

DWORD
WINAPI
ResUtilGetProperty(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ResUtilVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTable(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    IN HKEY hkeyClusterKey,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

PWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    );

DWORD
WINAPI
ResUtilGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT DWORD * pcbOutValueSize
    );

LPWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

LPWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

FORCEINLINE
DWORD
WINAPI
ResUtilGetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize
    )
{
    return ResUtilGetBinaryValue( hkeyClusterKey, pszValueName, (LPBYTE *) ppszOutValue, pcbOutValueSize );
}

DWORD
WINAPI
ResUtilGetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPDWORD pdwOutValue,
    IN DWORD dwDefaultValue OPTIONAL
    );

DWORD
WINAPI
ResUtilSetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const LPBYTE pbNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPBYTE * ppbOutValue,
    IN OUT LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutString
    );

DWORD
WINAPI
ResUtilSetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutString
    );

DWORD
WINAPI
ResUtilSetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPWSTR * ppszOutValue,
    IN OUT LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

DWORD
WINAPI
ResUtilGetBinaryProperty(
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_BINARY pValueStruct,
    IN const LPBYTE pbOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetSzProperty(
    OUT LPWSTR * ppszOutValue,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetMultiSzProperty(
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    IN HRESOURCE hResource
    );

DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    );

LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
ResUtilSetResourceServiceEnvironment(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilSetResourceServiceStartParameters(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ResUtilFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValueSize
    );


//
// Common worker thread routines that allow a pending operation to
// be cancelled with CORRECT synchronization.
//
typedef struct CLUS_WORKER {
    HANDLE hThread;
    BOOL Terminate;
} CLUS_WORKER, *PCLUS_WORKER;

typedef DWORD (WINAPI *PWORKER_START_ROUTINE)(
    PCLUS_WORKER pWorker,
    LPVOID lpThreadParameter
    );

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    );

VOID
WINAPI
ClusWorkerTerminate(
    IN PCLUS_WORKER lpWorker
    );


//Define enumerate resource callback function. This gets called for each resource enumerated
//by ResUtilEnumResources
typedef   DWORD (*LPRESOURCE_CALLBACK)( HRESOURCE, HRESOURCE , PVOID );
typedef   DWORD (*LPRESOURCE_CALLBACK_EX)( HCLUSTER, HRESOURCE, HRESOURCE , PVOID );


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );

BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

DWORD
WINAPI
ResUtilGetResourceDependentIPAddressProps(
    IN      HRESOURCE   hResource,
    OUT     LPWSTR      pszAddress,
    IN OUT  DWORD *     pcchAddress,
    OUT     LPWSTR      pszSubnetMask,
    IN OUT  DWORD *     pcchSubnetMask,
    OUT     LPWSTR      pszNetwork,
    IN OUT  DWORD *     pcchNetwork
    );

DWORD
WINAPI
ResUtilFindDependentDiskResourceDriveLetter(
    IN     HCLUSTER  hCluster,             // handle to cluster
    IN     HRESOURCE hResource,            // handle to resource to query for dependencies
    IN     LPWSTR    pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    IN OUT DWORD *   pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    IN  DWORD               dwServicePid,
    IN  BOOL                bOffline,
    OUT PDWORD              pdwResourceState,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

#ifdef __cplusplus
}
#endif


#endif // ifdef _RESAPI_DEFINES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcbak.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0104 */
/* at Tue Jul 09 17:56:02 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcbak_h__
#define __rpcbak_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __TriggerBackupRPC_INTERFACE_DEFINED__
#define __TriggerBackupRPC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: TriggerBackupRPC
 * at Tue Jul 09 17:56:02 1996
 * using MIDL 2.00.0104
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


#ifndef RPC_COMMON_IDL
#define RPC_COMMON_IDL
#define		szTriggerRPCProtocol		TEXT("ncacn_np")
#define		szTriggerRPCSecurity		TEXT("Security=impersonation dynamic true")
			/* size is 4 */
typedef long RPC_BOOL;

			/* size is 1 */
typedef small RPC_BYTE;

			/* size is 4 */
typedef long RPC_INT;

			/* size is 4 */
typedef long RPC_SC;

			/* size is 4 */
typedef long RPC_EC;

			/* size is 4 */
typedef long RPC_DWORD;

			/* size is 2 */
typedef wchar_t RPC_CHAR;

			/* size is 4 */
typedef /* [string] */ RPC_CHAR __RPC_FAR *RPC_SZ;

			/* size is 16 */
typedef struct  __MIDL_TriggerBackupRPC_0001
    {
    short rgwSystemTime[ 8 ];
    }	RPC_SYSTEMTIME;

			/* size is 172 */
typedef struct  __MIDL_TriggerBackupRPC_0002
    {
    RPC_BYTE rgbTzi[ 172 ];
    }	RPC_TIME_ZONE_INFORMATION;

			/* size is 28 */
typedef struct  __MIDL_TriggerBackupRPC_0003
    {
    long rgdwServiceStatus[ 7 ];
    }	RPC_SERVICE_STATUS;

#define		ecOK						0		// no error
#define		ecGeneralFailure			50001	// a failure occurred that caused proxy generation to stop
#define		ecSomeProxiesFailed			50002	// some proxies failed to get generated
#define		ecTargetNotValid			50003	// supplied target address not valid
#define		ecTargetNotUnique			50004	// supplied target address not unique
#define		ecProxyDLLNotImplemented	50005	// not implemented yet
#define		ecProxyDLLOOM				50006	// memory allocation error
#define		ecProxyDLLError				50007	// general error
#define		ecProxyDLLProtocol			50008	// protocol error
#define		ecProxyDLLSyntax			50009	// syntax error
#define		ecProxyDLLEOF				50010   // end of file
#define		ecProxyDLLSoftware			50011	// error in software
#define		ecProxyDLLConfig			50012	// configuration error
#define		ecProxyDLLContention		50013	// contention error
#define		ecProxyDLLNotFound			50014	// not found
#define		ecProxyDLLDiskSpace			50015	// out of disk space
#define		ecProxyDLLException			50016	// exception thrown
#define		ecProxyDLLDefault			50017	// unknown error
#define		ecProxyNotValid				50018	// supplied proxy not valid
#define		ecProxyNotUnique			50019	// supplied proxy not unique or unable to generate a unique proxy
#define		ecProxyDuplicate			50020	// a primary proxy of the same type was also supplied
			/* size is 16 */
typedef struct  _PROXYNODE
    {
    struct _PROXYNODE __RPC_FAR *pnodeNext;
    RPC_SZ wszProxy;
    RPC_EC ec;
    RPC_SZ wszDN;
    }	PROXYNODE;

			/* size is 4 */
typedef struct _PROXYNODE __RPC_FAR *PPROXYNODE;

			/* size is 48 */
typedef struct  _PROXYINFO
    {
    RPC_BOOL fContinueOnError;
    RPC_BOOL fIgnoreOldSecondaries;
    RPC_SZ wszDN;
    RPC_SZ wszNickName;
    RPC_SZ wszCommonName;
    RPC_SZ wszDisplayName;
    RPC_SZ wszSurName;
    RPC_SZ wszGivenName;
    RPC_SZ wszInitials;
    RPC_SZ wszTargetAddress;
    PROXYNODE __RPC_FAR *pPNVerifyProxy;
    PROXYNODE __RPC_FAR *pPNExcludeProxy;
    }	PROXYINFO;

			/* size is 4 */
typedef struct _PROXYINFO __RPC_FAR *PPROXYINFO;

			/* size is 8 */
typedef struct  _PROXYLIST
    {
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNProxy;
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNFailedProxyType;
    }	PROXYLIST;

			/* size is 4 */
typedef struct _PROXYLIST __RPC_FAR *PPROXYLIST;

			/* size is 192 */
typedef struct  __MIDL_TriggerBackupRPC_0004
    {
    RPC_SYSTEMTIME st;
    RPC_TIME_ZONE_INFORMATION tzi;
    RPC_DWORD dwReturn;
    }	RemoteSystemTimeInfo;

			/* size is 48 */
typedef struct  _RemoteServiceStatus
    {
    RPC_SC sc;
    RPC_SZ szShortName;
    RPC_SZ szDisplayName;
    RPC_SZ szVersion;
    RPC_SERVICE_STATUS ss;
    struct _RemoteServiceStatus __RPC_FAR *prssNext;
    }	RemoteServiceStatus;

#define		rmsSuspendRepair	0x0001
#define		rmsSuspendNotif		0x0002
			/* size is 24 */
typedef struct  _RemoteMaintenanceStatus
    {
    RPC_DWORD dwStatus;
    RPC_SYSTEMTIME st;
    RPC_SZ szUser;
    }	RemoteMaintenanceStatus;

			/* size is 12 */
typedef struct  _BackupListNode
    {
    struct _BackupListNode __RPC_FAR *pnodeNext;
    struct _BackupListNode __RPC_FAR *pnodeChildren;
    RPC_SZ szName;
    }	BackupListNode;

			/* size is 44 */
typedef struct  _DistributedLockOwner
    {
    RPC_CHAR rgchComputer[ 17 ];
    RPC_DWORD dwPID;
    RPC_DWORD dwTID;
    }	DistributedLockOwner;

#define	DLR_NO_WAIT		0x00000001
#define	cchMaxLockName	17
			/* size is 84 */
typedef struct  _DistributedLockRequest
    {
    RPC_CHAR rgchLockName[ 17 ];
    RPC_DWORD dwFlags;
    DistributedLockOwner dlo;
    }	DistributedLockRequest;

			/* size is 48 */
typedef struct  _DistributedLockReply
    {
    RPC_BOOL fGranted;
    DistributedLockOwner dlo;
    }	DistributedLockReply;

#endif  // #ifndef RPC_COMMON_IDL
			/* size is 4 */
RPC_SC __cdecl ScGetBackupListNode( 
    /* [in] */ handle_t h,
    /* [out][in] */ BackupListNode __RPC_FAR *__RPC_FAR *ppnode);



extern RPC_IF_HANDLE TriggerBackupRPC_ClientIfHandle;
extern RPC_IF_HANDLE TriggerBackupRPC_ServerIfHandle;
#endif /* __TriggerBackupRPC_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0 public definitions.  Note that there is additional
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) 1993-1998, Microsoft Corporation
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value */
/*		Version 1.0		0x0100	*/
/*		Version 2.0		0x0200	*/
/*		Version 2.1		0x0210	*/
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

/* RichEdit 2.0 Window Class. */
// For Windows CE to avoid possible conflicts on Win95.
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	/*----------------------MACPORT */
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	/* MACPORT change */
#endif /* MACPORT  */

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif /* UNICODE */
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif /* _RICHEDIT_VER >= 0x0200 */

/* RichEdit messages */

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

/* RichEdit 2.0 messages */
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

/* enum for use with EM_GET/SETTEXTMODE */
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	/* default behavior */
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	/* default behavior */
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	/* default behavior */
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

/* Far East specific messages */
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

/* RE3.0 FE messages */
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

/* BiDi specific messages */
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

/* Extended edit style specific messages */
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

/* Extended edit style masks */
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS				8
#define SES_EMULATE10			16
#define	SES_USECRLF				32
#define SES_USEAIMM				64
#define SES_NOIME				128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384


/* Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS */
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// high completes comp string when aborting, low cancels.
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080

/* Values for EM_GETIMECOMPMODE */
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004

/* Options for EM_SETTYPOGRAPHYOPTIONS */
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2

/* Pegasus outline mode messages (RE 3.0) */

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)

// Outline mode wparam values
#define EMO_EXIT                0       // enter normal mode,  lparam ignored
#define EMO_ENTER               1       // enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        // promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        // promote/demote current selection
                                        // by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        // -> expands selection to level
                                        // indicated in LOWORD(lparam)
                                        // LOWORD(lparam) = -1/+1 corresponds
                                        // to collapse/expand button presses
                                        // in winword (other values are
                                        // equivalent to having pressed these
                                        // buttons more than once)
                                        // HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        // -> expands whole document to
                                        // indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        // selection up/down by indicated
                                        // amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1
#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2

/* New notifications */
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			/* PenWin specific */
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			/* Far East specific */
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d

/* BiDi specific notifications */
#define EN_ALIGNLTR				0x0710
#define EN_ALIGNRTL				0x0711

/* Event notification masks */
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		/* PenWin specific */
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020

/* Far East specific notification mask */
#define ENM_IMECHANGE			0x00800000		/* unused by RE2.0 */
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000

/* New edit control styles */
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
/* same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value */
#define ES_SELECTIONBAR			0x01000000
/* same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop */
#define ES_NOOLEDRAGDROP		0x00000008

/* Edit control extended style */
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		/* Not supported in RE 2.0/3.0 */
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

/* These flags are used in FE Windows */
#define ES_VERTICAL				0x00400000		/* Not supported in RE 2.0/3.0 */
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

/* Edit control options */
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		/* FE specific */


/* ECO operations */
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

/* New word break function actions */
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

/* Far East specific flags */
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

/* Far East specific flags */
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

/* Word break flags (used with WB_CLASSIFY) */
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


/* new data types */

#ifdef _WIN32
/* extended edit word break proc (character set aware) */
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

/* All character format measurements are in twips */
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif /* UNICODE */
#else
#define CHARFORMAT CHARFORMATA
#endif /* _RICHEDIT_VER >= 0x0200 */

/* CHARFORMAT masks */
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020		/* Exchange hyperlink extension */
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

/* CHARFORMAT effects */
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000		/* NOTE: this corresponds to */
										/* CFM_COLOR, which controls it */
#define yHeightCharPtsMost 1638

/* EM_SETCHARFORMAT wParam masks */
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000		// Set default charformat or paraformat
#define SCF_ALL				0x0004		// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008		// Modifier for SCF_SELECTION; says that
										//  format came from a toolbar, etc., and
										//  hence UI formatting rules should be
										//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010		// Associate fontname with bCharSet (one
										//  possible for each of Western, ME, FE,
										//  Thai)
#define SCF_NOKBUPDATE		0x0020		// Do not update the KB layput for this change
										// even if autokeyboard is on.
typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	/* allocated by caller, zero terminated by RichEdit */
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	/* allocated by caller, zero terminated by RichEdit */
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif /* UNICODE */
#else
#define TEXTRANGE	TEXTRANGEA
#endif /* _RICHEDIT_VER >= 0x0200 */


typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		/* user value passed to callback as first parameter */
	DWORD	  dwError;		/* last error */
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;

/* Stream formats. Flags are all in low word, since high word gives
   possible codepage choice. */

#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		/* Write only */
#define SF_TEXTIZED		0x0004		/* Write only */

#define SF_UNICODE		0x0010		/* Unicode file (UCS2 little endian) */
#define SF_USECODEPAGE	0x0020		/* CodePage given by high word */
#define SF_NCRFORNONASCII 0x40		/* Output /uN for nonASCII */

/* Flag telling stream operations to operate on selection only */
/* EM_STREAMIN  will replace current selection */
/* EM_STREAMOUT will stream out current selection */
#define SFF_SELECTION	0x8000

/* Flag telling stream operations to ignore some FE control words */
/* having to do with FE word breaking and horiz vs vertical text. */
/* Not used in RichEdit 2.0 and later	*/
#define SFF_PLAINRTF	0x4000

/* Flag telling file stream output (SFF_SELECTION flag not set) to persist */
/* \viewscaleN control word. */
#define SFF_PERSISTVIEWSCALE 0x2000

/* Flag telling file stream input with SFF_SELECTION flag not set not to */
/* close the document */
#define SFF_KEEPDOCINFO	0x1000

/* Flag telling stream operations to output in Pocket Word format */
#define SFF_PWD			0x0800

/* 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN */
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif /* UNICODE */
#else
#define FINDTEXT	FINDTEXTA
#endif /* _RICHEDIT_VER >= 0x0200 */

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif /* UNICODE */
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif /* _RICHEDIT_VER >= 0x0200 */


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

/* All paragraph measurements are in twips */

#define MAX_TAB_STOPS 32
#define lDefaultTab 720

/* This is a hack to make PARAFORMAT compatible with RE 1.0 */
#define	wReserved	wEffects

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

/* PARAFORMAT mask values */
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

/* PARAFORMAT numbering options */
#define PFN_BULLET		0x0001

/* PARAFORMAT alignment options */
#define PFA_LEFT	0x0001
#define PFA_RIGHT	0x0002
#define PFA_CENTER	0x0003

/* CHARFORMAT2 and PARAFORMAT2 structures */

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			/* Font weight (LOGFONT value)		*/
	SHORT		sSpacing;			/* Amount to space between letters	*/
	COLORREF	crBackColor;		/* Background color					*/
	LCID		lcid;				/* Locale ID						*/
	DWORD		dwReserved;			/* Reserved. Must be 0				*/
	SHORT		sStyle;				/* Style handle						*/
	WORD		wKerning;			/* Twip size above which to kern char pair*/
	BYTE		bUnderlineType;		/* Underline type					*/
	BYTE		bAnimation;			/* Animated text like marching ants */
	BYTE		bRevAuthor;			/* Revision author index			*/
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			/* Font weight (LOGFONT value)		*/
	SHORT		sSpacing;			/* Amount to space between letters	*/
	COLORREF	crBackColor;		/* Background color					*/
	LCID		lcid;				/* Locale ID						*/
	DWORD		dwReserved;			/* Reserved. Must be 0				*/
	SHORT		sStyle;				/* Style handle						*/
	WORD		wKerning;			/* Twip size above which to kern char pair*/
	BYTE		bUnderlineType;		/* Underline type					*/
	BYTE		bAnimation;			/* Animated text like marching ants	*/
	BYTE		bRevAuthor;			/* Revision author index			*/
};

#else	/* regular C-style  */

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			/* > 0 for superscript, < 0 for subscript */
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			/* Font weight (LOGFONT value)		*/
	SHORT		sSpacing;			/* Amount to space between letters	*/
	COLORREF	crBackColor;		/* Background color					*/
	LCID		lcid;				/* Locale ID						*/
	DWORD		dwReserved;			/* Reserved. Must be 0				*/
	SHORT		sStyle;				/* Style handle						*/
	WORD		wKerning;			/* Twip size above which to kern char pair*/
	BYTE		bUnderlineType;		/* Underline type					*/
	BYTE		bAnimation;			/* Animated text like marching ants	*/
	BYTE		bRevAuthor;			/* Revision author index			*/
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			/* > 0 for superscript, < 0 for subscript */
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			/* Font weight (LOGFONT value)		*/
	SHORT		sSpacing;			/* Amount to space between letters	*/
	COLORREF	crBackColor;		/* Background color					*/
	LCID		lcid;				/* Locale ID						*/
	DWORD		dwReserved;			/* Reserved. Must be 0				*/
	SHORT		sStyle;				/* Style handle						*/
	WORD		wKerning;			/* Twip size above which to kern char pair*/
	BYTE		bUnderlineType;		/* Underline type					*/
	BYTE		bAnimation;			/* Animated text like marching ants	*/
	BYTE		bRevAuthor;			/* Revision author index			*/
} CHARFORMAT2A;

#endif /* C++ */

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


/* CHARFORMAT and PARAFORMAT "ALL" masks
   CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor*/

#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

/* New masks and effects -- a parenthesized asterisk indicates that
   the data is stored by RichEdit 2.0/3.0, but not displayed */

#define CFM_SMALLCAPS		0x0040			/* (*)	*/
#define	CFM_ALLCAPS			0x0080			/* Displayed by 3.0	*/
#define	CFM_HIDDEN			0x0100			/* Hidden by 3.0 */
#define	CFM_OUTLINE			0x0200			/* (*)	*/
#define	CFM_SHADOW			0x0400			/* (*)	*/
#define	CFM_EMBOSS			0x0800			/* (*)	*/
#define	CFM_IMPRINT			0x1000			/* (*)	*/
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		/* Many displayed by 3.0 */
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		/* Displayed by 3.0	*/
#define CFM_KERNING			0x00100000		/* (*)	*/
#define CFM_STYLE			0x00080000		/* (*)	*/
#define CFM_ANIMATION		0x00040000		/* (*)	*/
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		/* Superscript and subscript are */
#define CFE_SUPERSCRIPT		0x00020000		/*  mutually exclusive			 */

#define CFM_SUBSCRIPT		CFE_SUBSCRIPT | CFE_SUPERSCRIPT
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

/* NOTE: CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
   CFM_BACKCOLOR, respectively, which control them */
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

/* Underline types. RE 1.0 displays only CFU_UNDERLINE */
#define CFU_CF1UNDERLINE	0xFF	/* map charformat's bit underline to CF2.*/
#define CFU_INVERT			0xFE	/* For IME composition fake a selection.*/
#define CFU_UNDERLINEHAIRLINE	10	/* (*) displayed as ordinary underline	*/
#define CFU_UNDERLINETHICK		9
#define CFU_UNDERLINEWAVE		8
#define	CFU_UNDERLINEDASHDOTDOT	7
#define	CFU_UNDERLINEDASHDOT	6
#define	CFU_UNDERLINEDASH		5
#define	CFU_UNDERLINEDOTTED		4
#define	CFU_UNDERLINEDOUBLE		3	/* (*) displayed as ordinary underline	*/
#define CFU_UNDERLINEWORD		2	/* (*) displayed as ordinary underline	*/
#define CFU_UNDERLINE			1
#define CFU_UNDERLINENONE		0

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			/* Vertical spacing before para			*/
	LONG	dySpaceAfter;			/* Vertical spacing after para			*/	
	LONG	dyLineSpacing;			/* Line spacing depending on Rule		*/
	SHORT	sStyle;					/* Style handle							*/
	BYTE	bLineSpacingRule;		/* Rule for line spacing (see tom.doc)	*/
	BYTE	bOutlineLevel;			/* Outline level						*/
	WORD	wShadingWeight;			/* Shading in hundredths of a per cent	*/
	WORD	wShadingStyle;			/* Nibble 0: style, 1: cfpat, 2: cbpat	*/
	WORD	wNumberingStart;		/* Starting value for numbering			*/
	WORD	wNumberingStyle;		/* Alignment, roman/arabic, (), ), ., etc.*/
	WORD	wNumberingTab;			/* Space bet FirstIndent & 1st-line text*/
	WORD	wBorderSpace;			/* Border-text spaces (nbl/bdr in pts)	*/
	WORD	wBorderWidth;			/* Pen widths (nbl/bdr in half pts)		*/
	WORD	wBorders;				/* Border styles (nibble/border)		*/
};

#else	/* regular C-style	*/

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			/* Vertical spacing before para			*/
	LONG	dySpaceAfter;			/* Vertical spacing after para			*/
	LONG	dyLineSpacing;			/* Line spacing depending on Rule		*/
	SHORT	sStyle;					/* Style handle							*/
	BYTE	bLineSpacingRule;		/* Rule for line spacing (see tom.doc)	*/
	BYTE	bOutlineLevel;			/* Outline Level						*/
	WORD	wShadingWeight;			/* Shading in hundredths of a per cent	*/
	WORD	wShadingStyle;			/* Byte 0: style, nib 2: cfpat, 3: cbpat*/
	WORD	wNumberingStart;		/* Starting value for numbering			*/	
	WORD	wNumberingStyle;		/* Alignment, Roman/Arabic, (), ), ., etc.*/
	WORD	wNumberingTab;			/* Space bet 1st indent and 1st-line text*/
	WORD	wBorderSpace;			/* Border-text spaces (nbl/bdr in pts)	*/
	WORD	wBorderWidth;			/* Pen widths (nbl/bdr in half twips)	*/
	WORD	wBorders;				/* Border styles (nibble/border)		*/
} PARAFORMAT2;

#endif /* C++	*/


/* PARAFORMAT 2.0 masks and effects */

#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	/* (*)	*/
#define PFM_SHADING				0x00001000	/* (*)	*/
#define PFM_NUMBERINGSTYLE		0x00002000	/* RE 3.0	*/
#define PFM_NUMBERINGTAB		0x00004000	/* RE 3.0	*/
#define PFM_NUMBERINGSTART		0x00008000	/* RE 3.0	*/

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	/* (*)	*/
#define PFM_KEEPNEXT			0x00040000	/* (*)	*/
#define PFM_PAGEBREAKBEFORE		0x00080000	/* (*)	*/
#define PFM_NOLINENUMBER		0x00100000	/* (*)	*/
#define PFM_NOWIDOWCONTROL		0x00200000	/* (*)	*/
#define PFM_DONOTHYPHEN			0x00400000	/* (*)	*/
#define PFM_SIDEBYSIDE			0x00800000	/* (*)	*/
#define PFM_TABLE				0x40000000	/* RE 3.0 */

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	/* RE 3.0 */
#define PFM_OUTLINELEVEL		0x02000000	/* RE 3.0 */
#define PFM_BOX					0x04000000	/* RE 3.0 */


/* Note: PARAFORMAT has no effects */
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	/* (*)	*/
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	/* (*)	*/
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	/* (*)	*/
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	/* (*)	*/
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	/* (*)	*/
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	/* (*)	*/
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	/* (*)	*/

// The following four effects are read only
#define PFE_OUTLINELEVEL		(PFM_OUTLINELEVEL	 >> 16)	/* (+)	*/
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	/* (+)	*/
#define PFE_BOX					(PFM_BOX			 >> 16)	/* (+)	*/
#define PFE_TABLE				0x4000		/* Para is a table row. RE 3.0 */

/* PARAFORMAT2 wNumbering options (see also PFN_BULLET) */
#define PFN_ARABIC		2		/* tomListNumberAsArabic:   0, 1, 2,	...*/
#define PFN_LCLETTER	3		/* tomListNumberAsLCLetter: a, b, c,	...*/
#define	PFN_UCLETTER	4		/* tomListNumberAsUCLetter: A, B, C,	...*/
#define	PFN_LCROMAN		5		/* tomListNumberAsLCRoman:  i, ii, iii,	...*/
#define	PFN_UCROMAN		6		/* tomListNumberAsUCRoman:  I, II, III,	...*/

/* PARAFORMAT2 wNumberingStyle options */
#define PFNS_PAREN		0x000	/* default, e.g.,				  1)	*/
#define	PFNS_PARENS		0x100	/* tomListParentheses/256, e.g., (1)	*/
#define PFNS_PERIOD		0x200	/* tomListPeriod/256, e.g.,		  1.	*/
#define PFNS_PLAIN		0x300	/* tomListPlain/256, e.g.,		  1		*/
#define PFNS_NONUMBER	0x400	/* Used for continuation w/o number		*/

#define	PFA_JUSTIFY			 4	/* New paragraph-alignment option 2.0 (*) */
#define PFA_FULL_INTERWORD	 4
#define PFA_FULL_INTERLETTER 5
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8

/* Notification structures */

#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  /* !WM_NOTIFY */

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;

#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

/* Used with IRichEditOleCallback::GetContextMenu, this flag will be
   passed as a "selection type".  It indicates that a context menu for
   a right-mouse drag drop should be generated.  The IOleObject parameter
   will really be the IDataObject for the drop
 */
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

/* PenWin specific */
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

/* Far East specific */
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

/* Far East specific */
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


/* Clipboard formats - use as parameter to RegisterClipboardFormat() */
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

/* Paste Special */
typedef struct _repastespecial
{
	DWORD		dwAspect;
	DWORD_PTR	dwParam;
} REPASTESPECIAL;

/*	UndoName info */
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5
} UNDONAMEID;

/* Flags for the SETEXTEX data structure */
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2

/* EM_SETTEXTEX info; this struct is passed in the wparam of the message */
typedef struct _settextex
{
	DWORD	flags;			/* flags (see the ST_XXX defines			*/
	UINT	codepage;		/* code page for translation (CP_ACP for sys default;
						       1200 for Unicode, -1 for control default	*/
} SETTEXTEX;

/* Flags for the GETEXTEX data structure */
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2

/* EM_GETTEXTEX info; this struct is passed in the wparam of the message */
typedef struct _gettextex
{
	DWORD	cb;				/* count of bytes in the string				*/
	DWORD	flags;			/* flags (see the GT_XXX defines			*/
	UINT	codepage;		/* code page for translation (CP_ACP for sys default,
						       1200 for Unicode, -1 for control default	*/
	LPCSTR	lpDefaultChar;	/* replacement for unmappable chars			*/
	LPBOOL	lpUsedDefChar;	/* pointer to flag set when def char used	*/
} GETTEXTEX;

/* Flags for the GETTEXTLENGTHEX data structure							*/
#define GTL_DEFAULT		0	/* do the default (return # of chars)		*/
#define GTL_USECRLF		1	/* compute answer using CRLFs for paragraphs*/
#define GTL_PRECISE		2	/* compute a precise answer					*/
#define GTL_CLOSE		4	/* fast computation of a "close" answer		*/
#define GTL_NUMCHARS	8	/* return the number of characters			*/
#define GTL_NUMBYTES	16	/* return the number of _bytes_				*/

/* EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg */
typedef struct _gettextlengthex
{
	DWORD	flags;			/* flags (see GTL_XXX defines)				*/
	UINT	codepage;		/* code page for translation (CP_ACP for default,
							   1200 for Unicode							*/
} GETTEXTLENGTHEX;
	
/* BiDi specific features */
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

/* BIDIOPTIONS masks */
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	/* Default paragraph direction (implies alignment) (obsolete) */
#define BOM_PLAINTEXT			0x0002	/* Use plain text layout (obsolete) */
#endif /* _RICHEDIT_VER == 0x0100 */
#define BOM_NEUTRALOVERRIDE		0x0004	/* Override neutral layout (obsolete) */
#define BOM_CONTEXTREADING		0x0008	/* Context reading order */
#define BOM_CONTEXTALIGNMENT	0x0010	/* Context alignment */

/* BIDIOPTIONS effects */
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	/* Default paragraph direction (implies alignment) (obsolete) */
#define BOE_PLAINTEXT			0x0002	/* Use plain text layout (obsolete) */
#endif /* _RICHEDIT_VER == 0x0100 */
#define BOE_NEUTRALOVERRIDE		0x0004	/* Override neutral layout (obsolete) */
#define BOE_CONTEXTREADING		0x0008	/* Context reading order */
#define BOE_CONTEXTALIGNMENT	0x0010	/* Context alignment */

/* Additional EM_FINDTEXT[EX] flags */
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
/* UNICODE embedding character */
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif /* WCH_EMBEDDING */
		

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_RICHEDIT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rmxfguid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rmxfguid.h
 *
 *  Content:    Defines GUIDs of D3DRM's templates.
 *
 ***************************************************************************/

#ifndef __RMXFGUID_H_
#define __RMXFGUID_H_

/* {2B957100-9E9A-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInfo,
0x2b957100, 0x9e9a, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB44-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMesh,
0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5E-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMVector,
0x3d82ab5e, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMeshFace,
0x3d82ab5f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB4D-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMaterial,
0x3d82ab4d, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {35FF44E1-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialArray,
0x35ff44e1, 0x6c7c, 0x11cf, 0x8F, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB46-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMFrame,
0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {F6F23F41-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameTransformMatrix,
0xf6f23f41, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F42-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshMaterialList,
0xf6f23f42, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F40-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshTextureCoords,
0xf6f23f40, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F43-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshNormals,
0xf6f23f43, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F44-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMCoords2d,
0xf6f23f44, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F45-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMatrix4x4,
0xf6f23f45, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimation,
0x3d82ab4f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB50-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimationSet,
0x3d82ab50, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {10DD46A8-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationKey,
0x10dd46a8, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {10DD46A9-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFloatKeys,
0x10dd46a9, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411840-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialAmbientColor,
0x01411840, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411841-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialDiffuseColor,
0x01411841, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411842-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialSpecularColor,
0x01411842, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E80-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialEmissiveColor,
0xd3e16e80, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {01411843-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialPower,
0x01411843, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {35FF44E0-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGBA,
0x35ff44e0, 0x6c7c, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E81-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGB,
0xd3e16e81, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E0-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMGuid,
0xa42790e0, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E1-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureFilename,
0xa42790e1, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E2-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureReference,
0xa42790e2, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B820-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMIndexedColor,
0x1630b820, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B821-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshVertexColors,
0x1630b821, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {4885AE60-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialWrap,
0x4885ae60, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {537DA6A0-CA37-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMBoolean,
0x537da6a0, 0xca37, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {ED1EC5C0-C0A8-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMMeshFaceWraps,
0xed1ec5c0, 0xc0a8, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {4885AE63-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMBoolean2d,
0x4885ae63, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F406B180-7B3B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTimedFloatKeys,
0xf406b180, 0x7b3b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C0-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationOptions,
0xe2bf56c0, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C1-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFramePosition,
0xe2bf56c1, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C2-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameVelocity,
0xe2bf56c2, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C3-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameRotation,
0xe2bf56c3, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4A-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMLight,
0x3d82ab4a, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB51-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMCamera,
0x3d82ab51, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {E5745280-B24F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMAppData,
0xe5745280, 0xb24f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22740-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightUmbra,
0xaed22740, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22742-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightRange,
0xaed22742, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22741-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightPenumbra,
0xaed22741, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {A8A98BA0-C5E5-11cf-B941-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMLightAttenuation,
0xa8a98ba0, 0xc5e5, 0x11cf, 0xb9, 0x41, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {3A23EEA0-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInlineData,
0x3a23eea0, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3A23EEA1-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMUrl,
0x3a23eea1, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {8A63C360-997D-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMProgressiveMesh,
0x8A63C360, 0x997D, 0x11d0, 0x94, 0x1C, 0x0, 0x80, 0xC8, 0x0C, 0xFA, 0x7B);

/* {98116AA0-BDBA-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMExternalVisual,
0x98116AA0, 0xBDBA, 0x11d1, 0x82, 0xC0, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x71);

/* {7F0F21E0-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMStringProperty, 
0x7f0f21e0, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

/* {7F0F21E1-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMPropertyBag, 
0x7f0f21e1, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

// {7F5D5EA0-D53A-11d1-82C0-00A0C9697271}
DEFINE_GUID(TID_D3DRMRightHanded, 
0x7f5d5ea0, 0xd53a, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

#endif /* __RMXFGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rnderr.h ===
/*

    Copyright (c) 1997-1999  Microsoft Corporation

    Module Name:
        rnderr.h

*/

#ifndef __RND_ERROR_CODES__
#define __RND_ERROR_CODES__

#include <blberr.h>


// rendezvous component error codes

// First four bits - SEVERITY(11), CUSTOMER FLAG(1), RESERVED(0)
#define RND_INVALID_TIME                  0xe0000200
#define RND_NULL_SERVER_NAME              0xe0000201
#define RND_ALREADY_CONNECTED             0xe0000202
#define RND_NOT_CONNECTED                 0xe0000203

#endif // __RND_ERROR_CODES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcnsip.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

RPCNSAPI
void
RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsServerBindSearch(
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsClientBindSearch(
    );

RPCNSAPI
void
RPC_ENTRY
I_NsClientBindDone(
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rmxftmpl.h ===
/* D3DRM XFile templates in binary form */

#ifndef _RMXFTMPL_H_
#define _RMXFTMPL_H_

unsigned char D3DRM_XTEMPLATES[] = {
	0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
	0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
	0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
	0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
	0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
	0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
	0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
	0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
	0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
	0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
	0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
	0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
	0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
	0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
	0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
	0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
	0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
	0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
	0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
	0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
	0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
	0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
	0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
	0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
	0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
	0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
	0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
	0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
	0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
	0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
	0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
	0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
	0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
	0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
	0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
	0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
	0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
	0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
	0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
	0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
	0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
	0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
	0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
	0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
	0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
	0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
	0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
	0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
	0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
	0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
	0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
	0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
	0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
	0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
	0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
	0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
	0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
	0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
	0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
	0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
	0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
	0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
	0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
	0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
	0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
	0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
	0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
	0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
	0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
	0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
	0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
	0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
	0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
	0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
	0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
	0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
	0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
	0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
	0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
	0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
	0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
	0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
	0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
	0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
	0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
	0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
	0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
	0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
	0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
	0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
	0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
	0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
	0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
	0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
	0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
	0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
	0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
	0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
	0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
	0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
	0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
	0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
	0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
	0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
	0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
	0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
	0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
	0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
	0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
	0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
	0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
	0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
	0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
	0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
	0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
	0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
	0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
	0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
	0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
	0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
	0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
	0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
	0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
	0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
	0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
	0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
	0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
	0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
	0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
	0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
	0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
	0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
	0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
	0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
	0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
	0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
	0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
	0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
	0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
	0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
	0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
	0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
	0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
	0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
	0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
	0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
	0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
	0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
	0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
	0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
	0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
	0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
	0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
	0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
	0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
	0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
	0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
	0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
	0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
	0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
	0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
	0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#endif /* _RMXFTMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcnterr.h ===
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1999       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change rpcerr.h.
*/

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY
#define RPC_S_ASYNC_CALL_PENDING          ERROR_IO_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL           ERROR_NONE_MAPPED
#define RPC_S_TIMEOUT                     ERROR_TIMEOUT

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER
#define RPC_X_PIPE_APP_MEMORY             ERROR_OUTOFMEMORY
#define RPC_X_INVALID_PIPE_OPERATION      RPC_X_WRONG_PIPE_ORDER

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\routprot.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    routprot.h

Abstract:
    Include file for Routing Protocol inteface to Router Managers

--*/


#ifndef _ROUTPROT_H_
#define _ROUTPROT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include "stm.h"

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#pragma warning(disable:4200)

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Supported functionality flags                                            //
//                                                                          //
// ROUTING 		            Imports Routing Table Manager APIs              //
// SERVICES		            Exports Service Table Manager APIs              //
// DEMAND_UPDATE_ROUTES     IP and IPX RIP support for Autostatic           //
// DEMAND_UPDATE_SERVICES   IPX SAP, NLSP support for Autostatic            //
// ADD_ALL_INTERFACES       Adds all interfaces, even if no info is present //
// MULTICAST                Supports multicast                              //
// POWER                    Power Manageable                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RF_ROUTING 		        0x00000001
#define RF_DEMAND_UPDATE_ROUTES 0x00000004
#define RF_ADD_ALL_INTERFACES   0x00000010
#define RF_MULTICAST            0x00000020
#define RF_POWER                0x00000040

#if MPR50
#define MS_ROUTER_VERSION       0x00000500
#else
#error Router version not defined
#endif

typedef enum _ROUTING_PROTOCOL_EVENTS
{
    ROUTER_STOPPED,              // Result is empty
    SAVE_GLOBAL_CONFIG_INFO,     // Result is empty
    SAVE_INTERFACE_CONFIG_INFO,  // Result is interface index
                                 // for which config info is to be saved.
    UPDATE_COMPLETE,             // Result is UPDATE_COMPLETE_MESSAGE structure
}ROUTING_PROTOCOL_EVENTS;


typedef enum _NET_INTERFACE_TYPE
{
    PERMANENT,
    DEMAND_DIAL,
    LOCAL_WORKSTATION_DIAL,
    REMOTE_WORKSTATION_DIAL
} NET_INTERFACE_TYPE;

//
// Interface Receive Types
//

#define IR_PROMISCUOUS                  0
#define IR_PROMISCUOUS_MULTICAST        1

typedef struct _SUPPORT_FUNCTIONS
{
    union
    {
        ULONGLONG   _Align8;

        struct
        {
            DWORD   dwVersion;
            DWORD   dwReserved;
        };
    };

    //
    // Function called by routing protocol to initiate demand dial connection
    //

    OUT DWORD
    (WINAPI *DemandDialRequest)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex
        ) ;

    //
    // Can be called to set the interface's receive capability
    // See IR_Xxx values above
    //

    OUT DWORD
    (WINAPI *SetInterfaceReceiveType)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex,
        IN      DWORD           InterfaceReceiveType,
        IN      BOOL            bActivate
        );

    //
    // Must be called by every protocol to set the route preference
    // and perform other validation
    //

    OUT DWORD
    (WINAPI *ValidateRoute)(
        IN      DWORD           ProtocolId,
        IN      PVOID           RouteInfo,
        IN      PVOID           DestAddress OPTIONAL
        );


    //
    // The following entrypoints are provided as a way for getting
    // information that spans components
    //

    OUT DWORD
    (WINAPI *MIBEntryCreate)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryDelete)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntrySet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetFirst)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetNext)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    //
    // Can be called to get the router ID value
    //

    OUT DWORD
    (WINAPI *GetRouterId)(VOID);

    OUT BOOL
    (WINAPI *HasMulticastBoundary)(
        IN      DWORD           dwIfIndex,
        IN      DWORD           dwGroupAddress
        );

} SUPPORT_FUNCTIONS, *PSUPPORT_FUNCTIONS ;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All IP Protocols must use the protocol ids defined in the range below.   //
// Protocols not identified below can use any unassigned number BELOW       //
// 0xffff0000                                                               //
//                                                                          //
// NOTE: These numbers have been chosen to coincide with MIB-II protocol    //
// numbers. Allocation should not be arbitrary.                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define PROTO_IP_OTHER      1
#define PROTO_IP_LOCAL      2
#define PROTO_IP_NETMGMT    3
#define PROTO_IP_ICMP       4
#define PROTO_IP_EGP        5
#define PROTO_IP_GGP        6
#define PROTO_IP_HELLO      7
#define PROTO_IP_RIP        8
#define PROTO_IP_IS_IS      9
#define PROTO_IP_ES_IS      10
#define PROTO_IP_CISCO      11
#define PROTO_IP_BBN        12
#define PROTO_IP_OSPF       13
#define PROTO_IP_BGP        14

//
// The multicast protocol IDs
//

#define PROTO_IP_MSDP        9
#define PROTO_IP_IGMP       10
#define PROTO_IP_BGMP       11

//
// The IPRTRMGR_PID is 10000 // 0x00002710
//

#define PROTO_IP_VRRP               112
#define PROTO_IP_BOOTP              9999    // 0x0000270F
#define PROTO_IP_NT_AUTOSTATIC      10002   // 0x00002712
#define PROTO_IP_DNS_PROXY          10003   // 0x00002713
#define PROTO_IP_DHCP_ALLOCATOR     10004   // 0x00002714
#define PROTO_IP_NAT                10005   // 0x00002715
#define PROTO_IP_NT_STATIC          10006   // 0x00002716
#define PROTO_IP_NT_STATIC_NON_DOD  10007   // 0x00002717
#define PROTO_IP_DIFFSERV           10008   // 0x00002718
#define PROTO_IP_MGM                10009   // 0x00002719
#define PROTO_IP_DTP                10010   // 0x0000271A
#define PROTO_IP_H323               10011   // 0x0000271B
#define PROTO_IP_FTP                10012   // 0x0000271C

//
// For all future development, the following macro must be used to generate
// Ids
//

//
//  Type            -   2 bits
//  Vendor          -  14 bits
//  ProtocolId      -  16 bits
//

#define PROTOCOL_ID(Type, VendorId, ProtocolId) \
    (((Type & 0x03)<<30)|((VendorId & 0x3FFF)<<16)|(ProtocolId & 0xFFFF))

//
//  |----|----|----|----|----|----|----|----|
//   Ty*** Vendor Id *** StandardProtocolId
//

#define TYPE_FROM_PROTO_ID(X)       (((X) >> 30) & 0x03)
#define VENDOR_FROM_PROTO_ID(X)     (((X) >> 16) & 0x3FFF)
#define PROTO_FROM_PROTO_ID(X)      ((X) & 0xFFFF)

//
// Types MS0 and MS1 are Microsoft Reserved
// A protocol that supports both unicast and multicast should use type
// MCAST
//

#define PROTO_TYPE_UCAST            0
#define PROTO_TYPE_MCAST            1
#define PROTO_TYPE_MS0              2
#define PROTO_TYPE_MS1              3

#define PROTO_VENDOR_MS0            0x0000
#define PROTO_VENDOR_MS1            0x137   // 311
#define PROTO_VENDOR_MS2            0x3FFF


#define MS_IP_BOOTP                 \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_BOOTP)

#define MS_IP_RIP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_RIP)

#define MS_IP_OSPF                  \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_OSPF)

#define MS_IP_BGP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS1, PROTO_IP_BGP)

#define MS_IP_IGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_IGMP)

#define MS_IP_BGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_BGMP)

#define MS_IP_MSDP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_MSDP)

#define MS_IP_DNS_PROXY             \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DNS_PROXY)

#define MS_IP_DHCP_ALLOCATOR        \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DHCP_ALLOCATOR)

#define MS_IP_NAT                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_NAT)

#define MS_IP_DIFFSERV              \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DIFFSERV)

#define MS_IP_MGM                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_MGM)

#define MS_IP_VRRP                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_VRRP)

#define MS_IP_DTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DTP)

#define MS_IP_H323                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_H323)

#define MS_IP_FTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_FTP)
//
// All IPX Protocols must use the protocol ids defined in the range below.
// Protocols not identified below can use any unassigned number greater than
// IPX_PROTOCOL_BASE.
//

#define IPX_PROTOCOL_BASE   0x0001ffff
#define IPX_PROTOCOL_RIP    IPX_PROTOCOL_BASE + 1
#define IPX_PROTOCOL_SAP    IPX_PROTOCOL_BASE + 2
#define IPX_PROTOCOL_NLSP   IPX_PROTOCOL_BASE + 3

typedef struct _UPDATE_COMPLETE_MESSAGE
{
    ULONG	InterfaceIndex;
    ULONG	UpdateType;	       // DEMAND_UPDATE_ROUTES, DEMAND_UPDATE_SERVICES
    ULONG	UpdateStatus;	   // NO_ERROR if successfull

}   UPDATE_COMPLETE_MESSAGE, *PUPDATE_COMPLETE_MESSAGE;

//
//  Message returned in Result parameter to GET_EVENT_MESSAGE api call.
//  UpdateCompleteMessage   returned for UPDATE_COMPLETE message
//  InterfaceIndex          returned for SAVE_INTERFACE_CONFIG_INFO message
//

typedef union _MESSAGE
{
    UPDATE_COMPLETE_MESSAGE UpdateCompleteMessage;
    DWORD                   InterfaceIndex;

}   MESSAGE, *PMESSAGE;

//
// Routing Interface Status types
//

#define RIS_INTERFACE_ADDRESS_CHANGE            0
#define RIS_INTERFACE_ENABLED                   1
#define RIS_INTERFACE_DISABLED                  2
#define RIS_INTERFACE_MEDIA_PRESENT             3
#define RIS_INTERFACE_MEDIA_ABSENT              4

//
// IPX Adapter Binding Info
//

typedef struct	IPX_ADAPTER_BINDING_INFO
{
    ULONG	AdapterIndex;
    UCHAR	Network[4];
    UCHAR	LocalNode[6];
    UCHAR	RemoteNode[6];
    ULONG	MaxPacketSize;
    ULONG	LinkSpeed;

}IPX_ADAPTER_BINDING_INFO, *PIPX_ADAPTER_BINDING_INFO;

//
// IP Adapter Binding Info
// This is the information associated with an ADDRESS_ARRIVAL event
// An address arrival may have AddressCount == 0, this implies a unnumbered
// interface
//

typedef struct IP_LOCAL_BINDING
{
    DWORD   Address;
    DWORD   Mask;
}IP_LOCAL_BINDING, *PIP_LOCAL_BINDING;

typedef struct	IP_ADAPTER_BINDING_INFO
{
    ULONG               AddressCount;
    DWORD               RemoteAddress;
    ULONG               Mtu;
    ULONGLONG           Speed;
    IP_LOCAL_BINDING    Address[0];
}IP_ADAPTER_BINDING_INFO, *PIP_ADAPTER_BINDING_INFO;

#define SIZEOF_IP_BINDING(X)                                \
    (FIELD_OFFSET(IP_ADAPTER_BINDING_INFO,Address[0]) +     \
     ((X) * sizeof(IP_LOCAL_BINDING)))



typedef
DWORD
(WINAPI * PSTART_PROTOCOL) (
    IN HANDLE 	            NotificationEvent,
    IN PSUPPORT_FUNCTIONS   SupportFunctions,
    IN LPVOID               GlobalInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PSTART_COMPLETE) (
    VOID
    );

typedef
DWORD
(WINAPI * PSTOP_PROTOCOL) (
    VOID
    );

typedef
DWORD
(WINAPI * PADD_INTERFACE) (
    IN LPWSTR               InterfaceName,
    IN ULONG	            InterfaceIndex,
    IN NET_INTERFACE_TYPE   InterfaceType,
    IN DWORD                MediaType,
    IN WORD                 AccessType,
    IN WORD                 ConnectionType,
    IN PVOID	            InterfaceInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PDELETE_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PGET_EVENT_MESSAGE) (
    OUT ROUTING_PROTOCOL_EVENTS  *Event,
    OUT MESSAGE                  *Result
    );

typedef
DWORD
(WINAPI * PGET_INTERFACE_INFO) (
    IN      ULONG	InterfaceIndex,
    IN      PVOID   InterfaceInfo,
    IN  OUT PULONG  BufferSize,
    OUT     PULONG	StructureVersion,
    IN      PULONG	StructureSize,
    OUT     PULONG	StructureCount
    );

typedef
DWORD
(WINAPI * PSET_INTERFACE_INFO) (
    IN ULONG	InterfaceIndex,
    IN PVOID	InterfaceInfo,
    IN ULONG    StructureVersion,
    IN ULONG    StructureSize,
    IN ULONG    StructureCount
    );

typedef
DWORD
(WINAPI * PINTERFACE_STATUS) (
    IN ULONG	InterfaceIndex,
    IN BOOL     InterfaceActive,
    IN DWORD    StatusType,
    IN PVOID	StatusInfo
    );

typedef
DWORD
(WINAPI * PQUERY_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PSET_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PGET_GLOBAL_INFO) (
    IN     PVOID 	GlobalInfo,
    IN OUT PULONG   BufferSize,
    OUT    PULONG	StructureVersion,
    OUT    PULONG   StructureSize,
    OUT    PULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PSET_GLOBAL_INFO) (
    IN  PVOID 	GlobalInfo,
    IN  ULONG	StructureVersion,
    IN  ULONG   StructureSize,
    IN  ULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PDO_UPDATE_ROUTES) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PMIB_CREATE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_DELETE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET) (
    IN ULONG 	InputDataSize,
    IN PVOID	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_FIRST) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID   OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_NEXT) (
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET_TRAP_INFO) (
    IN  HANDLE  Event,
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_TRAP_INFO) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI *PCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

typedef
DWORD
(WINAPI *PDISCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

//
// InterfaceFlags used with the GetNeighbors() call below
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_PIM_FLAG      0x04
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

typedef
DWORD
(WINAPI *PGET_NEIGHBORS) (
    IN     DWORD  InterfaceIndex,
    IN     PDWORD NeighborList,
    IN OUT PDWORD NeighborListSize,
       OUT PBYTE  InterfaceFlags
    );

//
// StatusCode values used with the GetMfeStatus() call below.
// The protocol should return the highest-valued one that applies.
//

#define MFE_NO_ERROR          0 // none of the below events
#define MFE_REACHED_CORE      1 // this router is an RP/core for the group

//
// StatusCode values set by oif owner only
//

#define MFE_OIF_PRUNED        5 // no downstream receivers exist on oif

//
// StatusCode values set by iif owner only
//

#define MFE_PRUNED_UPSTREAM   4 // a prune was send upstream
#define MFE_OLD_ROUTER       11 // upstream nbr doesn't support mtrace

//
// StatusCode values which are used only by the Router Manager itself:
//

#define MFE_NOT_FORWARDING    2 // not fwding for an unspecified reason
#define MFE_WRONG_IF          3 // mtrace received on iif
#define MFE_BOUNDARY_REACHED  6 // iif or oif is admin scope boundary
#define MFE_NO_MULTICAST      7 // oif is not multicast-enabled
#define MFE_IIF               8 // mtrace arrived on iif
#define MFE_NO_ROUTE          9 // router has no route that matches
#define MFE_NOT_LAST_HOP     10 // router is not the proper last-hop router
#define MFE_PROHIBITED       12 // mtrace is administratively prohibited
#define MFE_NO_SPACE         13 // not enough room in packet

typedef
DWORD
(WINAPI *PGET_MFE_STATUS) (
    IN     DWORD  InterfaceIndex,
    IN     DWORD  GroupAddress,
    IN     DWORD  SourceAddress,
    OUT    PBYTE  StatusCode
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the structure passed between the router manager and a protocol   //
// upon registration.                                                       //
//                                                                          //
// IN OUT DWORD dwVersion                                                   //
// This is filled by the router manager to indicate the version it supports.//
// The DLL MUST set this to the version that the protocol will support.     //
//                                                                          //
// IN DWORD dwProtocolId                                                    //
// This the protocol the router manager is expecting the DLL to register.   //
// If the DLL does not support this protocol, it MUST return                //
// ERROR_NOT_SUPPORTED                                                      //
// A DLL will be called once for every protocol it supports                 //
//                                                                          //
// IN OUT DWORD fSupportedFunctionality                                     //
// These are the flags denoting the functionality the router manager        //
// supports. The DLL MUST reset this to the functionality that it supports. //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MPR50_ROUTING_CHARACTERISTICS
{
    DWORD               dwVersion;
    DWORD               dwProtocolId;
    DWORD               fSupportedFunctionality;

    PSTART_PROTOCOL     pfnStartProtocol;
    PSTART_COMPLETE     pfnStartComplete;
    PSTOP_PROTOCOL      pfnStopProtocol;
    PGET_GLOBAL_INFO    pfnGetGlobalInfo;
    PSET_GLOBAL_INFO    pfnSetGlobalInfo;
    PQUERY_POWER        pfnQueryPower;
    PSET_POWER          pfnSetPower;

    PADD_INTERFACE      pfnAddInterface;
    PDELETE_INTERFACE   pfnDeleteInterface;
    PINTERFACE_STATUS   pfnInterfaceStatus;
    PGET_INTERFACE_INFO pfnGetInterfaceInfo;
    PSET_INTERFACE_INFO pfnSetInterfaceInfo;

    PGET_EVENT_MESSAGE  pfnGetEventMessage;

    PDO_UPDATE_ROUTES   pfnUpdateRoutes;

    PCONNECT_CLIENT     pfnConnectClient;
    PDISCONNECT_CLIENT  pfnDisconnectClient;

    PGET_NEIGHBORS      pfnGetNeighbors;
    PGET_MFE_STATUS     pfnGetMfeStatus;

    PMIB_CREATE         pfnMibCreateEntry;
    PMIB_DELETE         pfnMibDeleteEntry;
    PMIB_GET            pfnMibGetEntry;
    PMIB_SET            pfnMibSetEntry;
    PMIB_GET_FIRST      pfnMibGetFirstEntry;
    PMIB_GET_NEXT       pfnMibGetNextEntry;
    PMIB_SET_TRAP_INFO  pfnMibSetTrapInfo;
    PMIB_GET_TRAP_INFO  pfnMibGetTrapInfo;

}MPR50_ROUTING_CHARACTERISTICS;

#if MPR50
typedef MPR50_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
#endif

typedef MPR_ROUTING_CHARACTERISTICS *PMPR_ROUTING_CHARACTERISTICS;


//
// All routing protocols must export the following entry point.
// The router manager calls this function to allow the routing
// protocol to register
//

#define REGISTER_PROTOCOL_ENTRY_POINT           RegisterProtocol
#define REGISTER_PROTOCOL_ENTRY_POINT_STRING    "RegisterProtocol"

typedef
DWORD
(WINAPI * PREGISTER_PROTOCOL) (
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );


#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#pragma warning(default:4201)
#endif

#endif      // _ROUTPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcdce.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                          0x4

// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport:
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Client: RpcBindingSetOption() values for the Falcon/RPC transport:
#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_MAX_OPTIONS            14

#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    IN void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption( IN RPC_BINDING_HANDLE hBinding,
                     IN unsigned long      option,
                     IN ULONG_PTR          optionValue );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption( IN  RPC_BINDING_HANDLE hBinding,
                     IN  unsigned long      option,
                     OUT ULONG_PTR         *pOptionValue );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    IN void *ContextHandle,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID * MgrTypeUuid,
    IN RPC_MGR_EPV * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN int RundownContextHandles
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT       0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH   1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC  2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY 4

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_DPA          17
#define RPC_C_AUTHN_MSN          18
#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) ~0UL)

#define RPC_C_SECURITY_QOS_VERSION  1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;


#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;


#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS *SecurityQos OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc, OPTIONAL
    IN RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long RpcQosVersion,
    OUT RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL,
    IN  unsigned long RpcQosVersion,
    OUT RPC_SECURITY_QOS *SecurityQOS
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoA (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoW (
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExW
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExA
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientEx (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

#if !defined(_M_IA64)
typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

RPCRTAPI
DECLSPEC_NORETURN
void
RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcTestCancel(
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerTestCancel (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThread(
    IN void * Thread
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThreadEx(
    IN void * Thread,
    IN long Timeout
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateSequential (
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringA (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringW (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringW (
    IN unsigned short __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToString (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromString (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
signed int
RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    );

RPCRTAPI
int
RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
unsigned short
RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
int
RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short  * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplace (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned  char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegister (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqText (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

#define DCE_C_ERROR_STRING_LEN 256

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNext (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );


#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

#define RPC_IF_AUTOLISTEN               0x0001
#define RPC_IF_OLE                      0x0002
#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY  0x0004
#define RPC_IF_ALLOW_SECURE_ONLY  0x0008

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcndr.h ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with NT5 beta1+ env from build #1700 on.


#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 475 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#include <pshpack8.h>
#include <basetsd.h>
#include <rpcnsip.h>


#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
#define NDR_IBM_FLOAT                   (unsigned long)0X00000300L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef byte cs_byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef __RPC_WIN64__
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void  * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void  * );

#define RPC_VAR_ENTRY __cdecl


/* winnt only */
#if defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_IA64)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void  * NDR_CCONTEXT;

typedef struct
    {
    void  * pad[2];
    void  * userContext;
    }  * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER  * NDR_RUNDOWN)(void  * context);

typedef void (__RPC_USER  * NDR_NOTIFY_ROUTINE)(void);
typedef void (__RPC_USER  * NDR_NOTIFY2_ROUTINE)(boolean flag);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE,  * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    IN  NDR_CCONTEXT    CContext,
    OUT void  *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    OUT NDR_CCONTEXT        *   pCContext,
    IN  RPC_BINDING_HANDLE      hBinding,
    IN  void                *   pBuff,
    IN  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    IN  NDR_SCONTEXT    CContext,
    OUT void          * pBuff,
    IN  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    IN  void          * pBuff,
    IN  unsigned long   DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  NDR_SCONTEXT        CContext,
    OUT void              * pBuff,
    IN  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall2 (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  NDR_SCONTEXT        CContext,
    OUT void              * pBuff,
    IN  NDR_RUNDOWN         userRunDownIn,
    IN  void              * CtxGuard,
    IN unsigned long        Flags
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  void              * pBuff,
    IN  unsigned long       DataRepresentation
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall2(
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  void              * pBuff,
    IN  unsigned long       DataRepresentation,
    IN  void              * CtxGuard,
    IN unsigned long        Flags
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void  *  * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char  *  *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.

// RKK64
// these appear to be used in fossils inside MIDL
#define _midl_fa2( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+1) & ~0x1))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+3) & ~0x3))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+7) & ~0x7))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

// RKK64
// these appear to be used in fossils inside MIDL
#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

// end of unused

#define NdrFieldOffset(s,f)     (LONG_PTR)(& (((s  *)0)->f))
#define NdrFieldPad(s,f,p,t)    ((unsigned long)(NdrFieldOffset(s,f) - NdrFieldOffset(s,p)) - sizeof(t))

#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) || \
                   (RpcExceptionCode() == RPC_S_INVALID_BOUND) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char  *    RPC_BUFPTR;
typedef unsigned long       RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER  * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE  * );

typedef const unsigned char  * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long              Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long  *  BufferConformanceMark;
    unsigned long  *  BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long  *  MaxCountArray;
    unsigned long  *  OffsetArray;
    unsigned long  *  ActualCountArray;
    } ARRAY_INFO,  *PARRAY_INFO;

/*
 *  Pipe related definitions.
 */

typedef struct _NDR_PIPE_DESC     *   PNDR_PIPE_DESC;
typedef struct _NDR_PIPE_MESSAGE  *   PNDR_PIPE_MESSAGE;

typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;
typedef struct _NDR_CORRELATION_INFO *PNDR_CORRELATION_INFO;

/*
 * cs_char info in the stub message
 */

typedef struct
    {
    unsigned long   WireCodeset;
    unsigned long   DesiredReceivingCodeset;
    void           *CSArrayInfo;
    } CS_STUB_INFO;

/*
 * MIDL Stub Message
 */

typedef const unsigned char  * PFORMAT_STRING;
typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE            RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char       *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char       *   BufferStart;
    unsigned char       *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char       *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long           BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long           MemorySize;

    /* Pointer to user memory. */
    unsigned char       *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                     IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                     ReuseBuffer;

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char       *   AllocAllNodesMemory;
    unsigned char       *   AllocAllNodesMemoryEnd;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                     IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char       *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char           fBufferValid;

    unsigned char           uFlags;
    unsigned short          Unused2;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    ULONG_PTR               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long           Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long           ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void  *                 ( __RPC_API * pfnAllocate)(size_t);
    void                    ( __RPC_API * pfnFree)(void  *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char       *   StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char       *   pPresentedType;
    unsigned char       *   pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC  * StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES  * FullPtrXlatTables;
    unsigned long                   FullPtrRefId;

    unsigned long                   ulUnused1;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;
    int                             fHasExtensions    :1;
    int                             fHasNewCorrDesc   :1;
    int                             fUnused           :10;
    int                             fUnused2          :16;


    unsigned long                   dwDestContext;
    void  *                         pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer    *   pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;
    unsigned long           *       SizePtrCountArray;
    unsigned long           *       SizePtrOffsetArray;
    unsigned long           *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void                    *       pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Pipe descriptor, defined for the 4.0 release.
     */
    PNDR_PIPE_DESC                  pPipeDesc;

    /*
     *  Async message pointer, correlation data - NT 5.0 features.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;
    PNDR_CORRELATION_INFO           pCorrInfo;
    unsigned char *                 pCorrMemory;

    void *                          pMemoryList;

    /*
     *  Reserved fields up to this point present since the 3.50 release.
     *  Reserved fields below were introduced for Windows 2000 release.
     *  (but not used).
     */

    /*
     * International character support information - NT 5.1 feature.
     */

    CS_STUB_INFO *                  pCSInfo;

    unsigned char *                 ConformanceMark;
    unsigned char *                 VarianceMark;

    INT_PTR                         Unused;

    /*
     *  Reserved fields up to this point present since Windows 2000 release.
     *  Fields added for NT5.1
     */

    void *                          pContext;

    unsigned long                   LengthSave;

    /*
     *  Reserved fields up to this point present since NT5.1 release.
     */
    } MIDL_STUB_MESSAGE,  *PMIDL_STUB_MESSAGE;


typedef  struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE,   *PMIDL_STUB_MESSAGE;

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void  *
        ( __RPC_API * GENERIC_BINDING_ROUTINE)
        (void  *);
typedef void
        ( __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void  *, unsigned char  *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR,  *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void  *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO,  *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void ( __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE,  *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
( __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long  *,
     unsigned long,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  * ,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  *,
     void  * );

typedef void ( __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long  *,
     void  * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

#define USER_MARSHAL_CB_SIGNATURE 'USRC'

typedef enum _USER_MARSHAL_CB_TYPE
{
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE
} USER_MARSHAL_CB_TYPE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long           Flags;
    PMIDL_STUB_MESSAGE      pStubMsg;
    PFORMAT_STRING          pReserve;
    unsigned long           Signature;
    USER_MARSHAL_CB_TYPE    CBType;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pTypeFormat;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC              0x0100  /* aux flag: in an [async] call */
#define USER_CALL_NEW_CORRELATION_DESC  0x0200 

typedef struct _MALLOC_FREE_STRUCT
    {
    void  *     ( __RPC_USER * pfnAllocate)(size_t);
    void        ( __RPC_USER * pfnFree)(void  *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * International character support definitions
 */

typedef enum _IDL_CS_CONVERT
    {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT
    } IDL_CS_CONVERT;

typedef void
( __RPC_USER * CS_TYPE_NET_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulLocalBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulNetworkBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_LOCAL_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulNetworkBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulLocalBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_TO_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     void               *   pLocalData,
     unsigned long          ulLocalDataLength,
     byte               *   pNetworkData,
     unsigned long      *   pulNetworkDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_FROM_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     byte               *   pNetworkData,
     unsigned long          ulNetworkDataLength,
     unsigned long          ulLocalBufferSize,
     void               *   pLocalData,
     unsigned long      *   pulLocalDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TAG_GETTING_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

void __RPC_USER
RpcCsGetTags(
     RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);
     
typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
    {
    CS_TYPE_NET_SIZE_ROUTINE    pfnNetSize;
    CS_TYPE_TO_NETCS_ROUTINE    pfnToNetCs;
    CS_TYPE_LOCAL_SIZE_ROUTINE  pfnLocalSize;
    CS_TYPE_FROM_NETCS_ROUTINE  pfnFromNetCs;
    } NDR_CS_SIZE_CONVERT_ROUTINES;

typedef struct _NDR_CS_ROUTINES
    {
    NDR_CS_SIZE_CONVERT_ROUTINES   *pSizeConvertRoutines;
    CS_TAG_GETTING_ROUTINE         *pTagGettingRoutines;
    } NDR_CS_ROUTINES;

/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {
    void  *    RpcInterfaceInformation;

    void  *    ( __RPC_API * pfnAllocate)(size_t);
    void       ( __RPC_API * pfnFree)(void  *);

    union
        {
        handle_t  *             pAutoHandle;
        handle_t  *             pPrimitiveHandle;
        PGENERIC_BINDING_INFO   pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN  *                    apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR  *   aGenericBindingRoutinePairs;
    const EXPR_EVAL  *                      apfnExprEval;
    const XMIT_ROUTINE_QUINTUPLE  *         aXmitQuintuple;

    const unsigned char  *                  pFormatTypes;

    int                                     fCheckBounds;

    /* Ndr library version. */
    unsigned long                           Version;

    MALLOC_FREE_STRUCT  *                   pMallocFreeStruct;

    long                                    MIDLVersion;

    const COMM_FAULT_OFFSETS  *    CommFaultOffsets;

    // New fields for version 3.0+
    const USER_MARSHAL_ROUTINE_QUADRUPLE  * aUserMarshalQuadruple;

    // Notify routines - added for NT5, MIDL 5.0
    const NDR_NOTIFY_ROUTINE  *             NotifyRoutineTable;

    /*
     * Reserved for future use.
     */

    ULONG_PTR                               mFlags;

    // International support routines - added for 64bit post NT5
    const NDR_CS_ROUTINES *                 CsRoutineTables;

    void *                                  Reserved4;
    ULONG_PTR                               Reserved5;

    // Fields up to now present in win2000 release.

    } MIDL_STUB_DESC;


typedef const MIDL_STUB_DESC  * PMIDL_STUB_DESC;

typedef void  * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void ( __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long ( __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC                     pStubDesc;
    const SERVER_ROUTINE     *          DispatchTable;
    PFORMAT_STRING                      ProcString;
    const unsigned short *              FmtStringOffset;
    const STUB_THUNK *                  ThunkTable;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

#undef _MIDL_STUBLESS_PROXY_INFO

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short            *   FormatStringOffset;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO  * PMIDL_STUBLESS_PROXY_INFO;

/*
 *  Multiple transfer syntax information.
 */
typedef struct _MIDL_SYNTAX_INFO
{
RPC_SYNTAX_IDENTIFIER               TransferSyntax;
RPC_DISPATCH_TABLE *                DispatchTable;
PFORMAT_STRING                      ProcString;
const unsigned short *              FmtStringOffset;
PFORMAT_STRING                      TypeString;
const void           *              aUserMarshalQuadruple;
ULONG_PTR                           pReserved1;
ULONG_PTR                           pReserved2;
} MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

typedef unsigned short * PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void  *         Pointer;
    LONG_PTR        Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT  *  Next;

    void  *             Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT,  *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void  * *           XlatTable;
        unsigned char  *    StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT  *   XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid
     * translation whenever we insert a refid-to-pointer translation, and
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES,  *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    IN RPC_CLIENT_INTERFACE * pInf,
    OUT unsigned long       * pCount,
    OUT MIDL_SYNTAX_INFO   ** pArr );


RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    IN RPC_SERVER_INTERFACE * pInf,
    OUT unsigned long       * pCount,
    OUT MIDL_SYNTAX_INFO   ** pArr,
    OUT unsigned long       * pPreferSyntaxIndex);

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsTagMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT            ContextHandle,
    int                     fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine,
    PFORMAT_STRING          pFormat
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void  *                 pMemory,
    unsigned long           CacheSize,
    unsigned long           flags
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT        *   pContextHandle,
    RPC_BINDING_HANDLE      BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

/* New context handle flavors */

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrContextHandleInitialize(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextNewUnmarshall(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* cs_char things */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    long                    NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long *         pFlags,
    unsigned char *         pBuffer,
    unsigned char           FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pBufferEnd
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pBufferEnd,
    RPC_BINDING_HANDLE  *   pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE      pStubMsg,
    RPC_VERSION *           pVersion );


/*
 * Interpreter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

// Raw RPC only
RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

// old dcom async scheme
RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

// async uuid
RPCRTAPI
long
RPC_ENTRY
NdrDcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer  *    pThis,
    struct IRpcChannelBuffer  * pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer  *    pThis,
    struct IRpcChannelBuffer  * pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer  * pChannel,
    PRPC_MESSAGE                pRpcMsg,
    PMIDL_STUB_MESSAGE          pStubMsg,
    PMIDL_STUB_DESC             pStubDescriptor,
    PFORMAT_STRING              pFormat,
    void  *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer  *    pThis,
    struct IRpcChannelBuffer  * pChannel,
    PMIDL_STUB_MESSAGE          pStubMsg,
    PFORMAT_STRING              pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned long  *            pCommStatus,
    unsigned long  *            pFaultStatus,
    RPC_STATUS                  Status
    );

/* Helper routines */

RPCRTAPI
int
RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    RPC_BUFPTR                  pBuffer
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char          * *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSH_Copy(
    unsigned char            *  pStubMsg,
    unsigned char            *  pPtrInMem,
    unsigned long               Count
    );

RPCRTAPI
void
RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE          pMessage,
    unsigned char            *  pPtr );


RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE          pMessage,
    unsigned char            *  pMemory,
    unsigned long               Count,
    int                         Size );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE          pMessage,
    unsigned char          * *  pMemory,
    int                         Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void  * RPC_SS_THREAD_HANDLE;

typedef void  * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void  * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    IN void  * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC  * ClientAlloc,
    IN RPC_CLIENT_FREE   * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     * ClientAlloc,
    IN RPC_CLIENT_FREE      * ClientFree,
    OUT RPC_CLIENT_ALLOC *  * OldClientAlloc,
    OUT RPC_CLIENT_FREE  *  * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    IN  void        *   pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    IN void         * * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    IN void         *   NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     *   ClientAlloc,
    IN RPC_CLIENT_FREE      *   ClientFree,
    OUT RPC_CLIENT_ALLOC    * * OldClientAlloc,
    OUT RPC_CLIENT_FREE     * * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    IN void  * NodeToFree
    );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void  * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryPointer(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void  *                 pPointer,
    unsigned char           QueryType,
    unsigned long  *        pRefId
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void  * *               ppPointer
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerInsertRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void  *                 pPointer
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void  *                 Pointer
    );

RPCRTAPI
void  *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void  *                 ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void  *
RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    IN void  * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * Special things for VC5 Com support
 ****************************************************************************/

/* BUGBUG: Define DECLSPEC_xxx here for now */
/* temp until old winnt.h's are no longer supported */

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_UUID(x) __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define MIDL_INTERFACE(x)   struct DECLSPEC_UUID(x) DECLSPEC_NOVTABLE

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID DECLSPEC_SELECTANY itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif

/****************************************************************************
 * UserMarshal information
 ****************************************************************************/

typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
{
    void *                      Buffer;
    unsigned long               BufferSize;
    void *(__RPC_API * pfnAllocate)(size_t);
    void (__RPC_API * pfnFree)(void *);
    struct IRpcChannelBuffer *  pRpcChannelBuffer;
    ULONG_PTR                   Reserved[5];
} NDR_USER_MARSHAL_INFO_LEVEL1;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif

typedef struct _NDR_USER_MARSHAL_INFO 
{
    unsigned long InformationLevel;
    union {
        NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
    };
} NDR_USER_MARSHAL_INFO;       

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    IN unsigned long        *   pFlags,
    IN unsigned long            InformationLevel,
    OUT NDR_USER_MARSHAL_INFO * pMarshalInfo
    );

/****************************************************************************
* Generic 32 bit type functions
******************************************************************************/

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferAlignment( 
    unsigned char FormatChar
    );

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferSize( 
    unsigned char FormatChar
    );

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeMemorySize( 
    unsigned char FormatChar
    );

RPCRTAPI
unsigned long 
RPC_ENTRY
NdrGetTypeFlags( 
    unsigned char FormatChar
    );

RPCRTAPI
void 
RPC_ENTRY
NdrTypeSize( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char *
RPC_ENTRY
NdrTypeMarshall( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat 
    );

RPCRTAPI
unsigned char * 
RPC_ENTRY
NdrTypeUnmarshall( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  **       ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fSkipRefCheck 
    );

/****************************************************************************
 * 64bit APIs
 ****************************************************************************/
RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            IN struct IRpcStubBuffer* pStub,
            IN OUT RPC_SERVER_INTERFACE *pServerIf );

/*
 * Interpreter calls
 */
CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
Ndr64AsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

/* async uuid */
RPCRTAPI
long
RPC_ENTRY
Ndr64DcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall3 (
    struct IRpcStubBuffer  *    pThis,
    struct IRpcChannelBuffer  * pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE                pRpcMsg
    );


RPCRTAPI
void
RPC_ENTRY
NdrServerCall3(
    PRPC_MESSAGE                pRpcMsg
    );


/* [partial_ignore] functions*/
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );
    
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory 
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory 
    );
    
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory,
    PFORMAT_STRING              pFormat
    );
    
    
#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcnsi.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

#if _MSC_VER > 1000
#pragma once
#endif

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_ALL_ELTS RPC_C_PROFILE_ALL_ELT
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );


RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#endif

/* Server PnP APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
     IN UUID_VECTOR * ObjectVector OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    );

#endif

/* Client APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );
#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation OPTIONAL
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation OPTIONAL
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW
#define RpcNsBindingExportPnP RpcNsBindingExportPnPW
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA
#define RpcNsBindingExportPnP RpcNsBindingExportPnPA
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPA
#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcdcep.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS
RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE
};

typedef void
RPC_ENTRY RPC_ADDRESS_CHANGE_FN(
                        IN void * arg
                        );

/*
*  New context handle flavors.
*/

#define RPC_CONTEXT_HANDLE_DEFAULT_GUARD    ((void *)0xFFFFF00D)

#define RPC_CONTEXT_HANDLE_DEFAULT_FLAGS    0x00000000UL
#define RPC_CONTEXT_HANDLE_FLAGS            0x30000000UL
#define RPC_CONTEXT_HANDLE_SERIALIZE        0x10000000UL
#define RPC_CONTEXT_HANDLE_DONT_SERIALIZE   0x20000000UL

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */
#define RPC_BUFFER_ASYNC            0x00008000 /* used by async rpc */
#define RPC_BUFFER_NONOTIFY         0x00010000 /* used by async pipes */

#define RPCFLG_MESSAGE              0x01000000UL
#define RPCFLG_AUTO_COMPLETE        0x08000000UL
#define RPCFLG_LOCAL_CALL           0x10000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_NON_NDR              0x80000000UL

#define RPCFLG_HAS_MULTI_SYNTAXES   0x02000000UL
#define RPCFLG_HAS_CALLBACK         0x04000000UL

#define RPC_FLAGS_VALID_BIT 0x00008000

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    LONG_PTR                          Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER   InterfaceId;
    RPC_SYNTAX_IDENTIFIER   TransferSyntax;
    PRPC_DISPATCH_TABLE     DispatchTable;
    unsigned int            RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT   RpcProtseqEndpoint;
    ULONG_PTR               Reserved;
    void const __RPC_FAR *  InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN UUID * ObjectUuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    ) ;

typedef void * I_RPC_MUTEX;

RPCRTAPI
void
RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetExtendedError (
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetAssociationContext (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPCRTAPI
void *
RPC_ENTRY
I_RpcGetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void * ServerContextList
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short **StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char *WireId
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    );

RPC_STATUS
RPC_ENTRY
I_RpcSaveNdrInfo( void * pStubMsg );

RPC_STATUS
RPC_ENTRY
I_RpcRetrieveNdrInfo( void ** ppStubMsg);

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2A (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void *Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2W (
    IN unsigned short __RPC_FAR * NetworkAddress,
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2W (
    IN unsigned short __RPC_FAR * NetworkAddress,
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2A (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );


#ifdef UNICODE
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameW
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2W
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2W
#else
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameA
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2A
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2A
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2 (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );
#endif

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#ifdef UNICODE
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointW
#else
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointA
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#endif

#define TRANSPORT_TYPE_CN        0x01
#define TRANSPORT_TYPE_DG        0x02
#define TRANSPORT_TYPE_LPC       0x04
#define TRANSPORT_TYPE_WMSG      0x08

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT int *pfFirstCall
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION  * pForwardFunction
    );

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn();

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );

typedef
void
(*RPCLT_PDU_FILTER_FUNC) (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN int fDatagram
    );

typedef
void
(__cdecl *RPC_SETFILTER_FUNC) (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    );

#ifndef WINNT
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartListening(
    void * hWnd
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStopListening(
    ) ;

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void * hWnd,
    IN void * Context,
    IN OPTIONAL void * hSyncEvent
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn,
    IN unsigned long ServerTid
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSetThreadParams(
    IN int fClientFree,
    IN OPTIONAL void *Context,
    IN OPTIONAL void * hWndClient
    );

RPCRTAPI
unsigned int
RPC_ENTRY
I_RpcWindowProc(
    IN void * hWnd,
    IN unsigned int Message,
    IN unsigned int wParam,
    IN unsigned long lParam
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    IN unsigned char * Protseq,
    IN unsigned char * Endpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    IN unsigned short * Protseq,
    IN unsigned short * Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif
#endif // WINNT

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    ) ;

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );


#ifdef __cplusplus
}
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcasync.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete
    } RPC_ASYNC_EVENT;

struct _RPC_ASYNC_STATE;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;

typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    union {
        //
        // Notification by APC
        //
        struct {
            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
            HANDLE hThread;
            } APC;

        //
        // Notification by IO completion port
        //
        struct {
            HANDLE hIOPort;
            DWORD dwNumberOfBytesTransferred;
            DWORD_PTR dwCompletionKey;
            LPOVERLAPPED lpOverlapped;
            } IOC;

        //
        // Notification by window message
        //
        struct {
            HWND hWnd;
            UINT Msg;
            } HWND;


        //
        // Notification by event
        //
        HANDLE hEvent;

        //
        // Notification by callback function
        //
        // This option is available only to OLE
        //
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        } u;

    LONG_PTR Reserved[4];
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    PRPC_ASYNC_STATE pAsync,
    unsigned int     Size
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    PRPC_ASYNC_STATE pAsync,
    void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    PRPC_ASYNC_STATE pAsync,
    unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCleanupThread (
    IN DWORD dwTimeout
    );

typedef enum tagExtendedErrorParamTypes
{
    eeptAnsiString = 1,
    eeptUnicodeString,
    eeptLongVal,
    eeptShortVal,
    eeptPointerVal,
    eeptNone
} ExtendedErrorParamTypes;

#define MaxNumberOfEEInfoParams    4
#define RPC_EEINFO_VERSION         1

typedef struct tagRPC_EE_INFO_PARAM
{
    ExtendedErrorParamTypes ParameterType;
    union
        {
        LPSTR AnsiString;
        LPWSTR UnicodeString;
        long LVal;
        short SVal;
        ULONGLONG PVal;
        } u;
} RPC_EE_INFO_PARAM;

#define EEInfoPreviousRecordsMissing     1
#define EEInfoNextRecordsMissing         2
#define EEInfoUseFileTime                4

typedef struct tagRPC_EXTENDED_ERROR_INFO
{
    ULONG Version;
    LPWSTR ComputerName;
    ULONG ProcessID;
    union
        {
        SYSTEMTIME SystemTime;
        FILETIME FileTime;
        } u;
    ULONG GeneratingComponent;
    ULONG Status;
    USHORT DetectionLocation;
    USHORT Flags;
    int NumberOfParameters;
    RPC_EE_INFO_PARAM Parameters[MaxNumberOfEEInfoParams];
} RPC_EXTENDED_ERROR_INFO;

typedef struct tagRPC_ERROR_ENUM_HANDLE
{
    ULONG Signature;
    void *CurrentPos;
    void *Head;
} RPC_ERROR_ENUM_HANDLE;

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    IN BOOL CopyStrings, 
    OUT RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT int *Records
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT PVOID *ErrorBlob, 
    OUT size_t *BlobSize
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    IN PVOID ErrorBlob, 
    IN size_t BlobSize, 
    OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    IN RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcGetAuthorizationContextForClient (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL,
    IN BOOL ImpersonateOnReturn,
    IN PVOID Reserved1,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Reserved2,
    IN DWORD Reserved3,
    IN PVOID Reserved4,
    OUT PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcFreeAuthorizationContext (
    IN OUT PVOID *pAuthzClientContext
    );

//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    ) ;

#ifdef __cplusplus
}
#endif

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#endif /* __RPCASYNC_H__ */


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    // General User API

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    // User API
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    // Power User/library API


    /* Init functions */

    // These functions all call _CRT_RTC_INIT
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    // If you're not using the CRT, you have to implement _CRT_RTC_INIT
    // Just return either null, or your error reporting function
    // *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    // Compiler generated calls (unlikely to be used, even by power users...)
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif // _INC_RTCAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcpri.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0104 */
/* at Tue Jul 09 17:56:05 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcpri_h__
#define __rpcpri_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __TriggerPrivateRPC_INTERFACE_DEFINED__
#define __TriggerPrivateRPC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: TriggerPrivateRPC
 * at Tue Jul 09 17:56:05 1996
 * using MIDL 2.00.0104
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


#ifndef RPC_COMMON_IDL
#define RPC_COMMON_IDL
#define		szTriggerRPCProtocol		TEXT("ncacn_np")
#define		szTriggerRPCSecurity		TEXT("Security=impersonation dynamic true")
			/* size is 4 */
typedef long RPC_BOOL;

			/* size is 1 */
typedef small RPC_BYTE;

			/* size is 4 */
typedef long RPC_INT;

			/* size is 4 */
typedef long RPC_SC;

			/* size is 4 */
typedef long RPC_EC;

			/* size is 4 */
typedef long RPC_DWORD;

			/* size is 2 */
typedef wchar_t RPC_CHAR;

			/* size is 4 */
typedef /* [string] */ RPC_CHAR __RPC_FAR *RPC_SZ;

			/* size is 16 */
typedef struct  __MIDL_TriggerPrivateRPC_0001
    {
    short rgwSystemTime[ 8 ];
    }	RPC_SYSTEMTIME;

			/* size is 172 */
typedef struct  __MIDL_TriggerPrivateRPC_0002
    {
    RPC_BYTE rgbTzi[ 172 ];
    }	RPC_TIME_ZONE_INFORMATION;

			/* size is 28 */
typedef struct  __MIDL_TriggerPrivateRPC_0003
    {
    long rgdwServiceStatus[ 7 ];
    }	RPC_SERVICE_STATUS;

#define		ecOK						0		// no error
#define		ecGeneralFailure			50001	// a failure occurred that caused proxy generation to stop
#define		ecSomeProxiesFailed			50002	// some proxies failed to get generated
#define		ecTargetNotValid			50003	// supplied target address not valid
#define		ecTargetNotUnique			50004	// supplied target address not unique
#define		ecProxyDLLNotImplemented	50005	// not implemented yet
#define		ecProxyDLLOOM				50006	// memory allocation error
#define		ecProxyDLLError				50007	// general error
#define		ecProxyDLLProtocol			50008	// protocol error
#define		ecProxyDLLSyntax			50009	// syntax error
#define		ecProxyDLLEOF				50010   // end of file
#define		ecProxyDLLSoftware			50011	// error in software
#define		ecProxyDLLConfig			50012	// configuration error
#define		ecProxyDLLContention		50013	// contention error
#define		ecProxyDLLNotFound			50014	// not found
#define		ecProxyDLLDiskSpace			50015	// out of disk space
#define		ecProxyDLLException			50016	// exception thrown
#define		ecProxyDLLDefault			50017	// unknown error
#define		ecProxyNotValid				50018	// supplied proxy not valid
#define		ecProxyNotUnique			50019	// supplied proxy not unique or unable to generate a unique proxy
#define		ecProxyDuplicate			50020	// a primary proxy of the same type was also supplied
			/* size is 16 */
typedef struct  _PROXYNODE
    {
    struct _PROXYNODE __RPC_FAR *pnodeNext;
    RPC_SZ wszProxy;
    RPC_EC ec;
    RPC_SZ wszDN;
    }	PROXYNODE;

			/* size is 4 */
typedef struct _PROXYNODE __RPC_FAR *PPROXYNODE;

			/* size is 48 */
typedef struct  _PROXYINFO
    {
    RPC_BOOL fContinueOnError;
    RPC_BOOL fIgnoreOldSecondaries;
    RPC_SZ wszDN;
    RPC_SZ wszNickName;
    RPC_SZ wszCommonName;
    RPC_SZ wszDisplayName;
    RPC_SZ wszSurName;
    RPC_SZ wszGivenName;
    RPC_SZ wszInitials;
    RPC_SZ wszTargetAddress;
    PROXYNODE __RPC_FAR *pPNVerifyProxy;
    PROXYNODE __RPC_FAR *pPNExcludeProxy;
    }	PROXYINFO;

			/* size is 4 */
typedef struct _PROXYINFO __RPC_FAR *PPROXYINFO;

			/* size is 8 */
typedef struct  _PROXYLIST
    {
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNProxy;
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNFailedProxyType;
    }	PROXYLIST;

			/* size is 4 */
typedef struct _PROXYLIST __RPC_FAR *PPROXYLIST;

			/* size is 192 */
typedef struct  __MIDL_TriggerPrivateRPC_0004
    {
    RPC_SYSTEMTIME st;
    RPC_TIME_ZONE_INFORMATION tzi;
    RPC_DWORD dwReturn;
    }	RemoteSystemTimeInfo;

			/* size is 48 */
typedef struct  _RemoteServiceStatus
    {
    RPC_SC sc;
    RPC_SZ szShortName;
    RPC_SZ szDisplayName;
    RPC_SZ szVersion;
    RPC_SERVICE_STATUS ss;
    struct _RemoteServiceStatus __RPC_FAR *prssNext;
    }	RemoteServiceStatus;

#define		rmsSuspendRepair	0x0001
#define		rmsSuspendNotif		0x0002
			/* size is 24 */
typedef struct  _RemoteMaintenanceStatus
    {
    RPC_DWORD dwStatus;
    RPC_SYSTEMTIME st;
    RPC_SZ szUser;
    }	RemoteMaintenanceStatus;

			/* size is 12 */
typedef struct  _BackupListNode
    {
    struct _BackupListNode __RPC_FAR *pnodeNext;
    struct _BackupListNode __RPC_FAR *pnodeChildren;
    RPC_SZ szName;
    }	BackupListNode;

			/* size is 44 */
typedef struct  _DistributedLockOwner
    {
    RPC_CHAR rgchComputer[ 17 ];
    RPC_DWORD dwPID;
    RPC_DWORD dwTID;
    }	DistributedLockOwner;

#define	DLR_NO_WAIT		0x00000001
#define	cchMaxLockName	17
			/* size is 84 */
typedef struct  _DistributedLockRequest
    {
    RPC_CHAR rgchLockName[ 17 ];
    RPC_DWORD dwFlags;
    DistributedLockOwner dlo;
    }	DistributedLockRequest;

			/* size is 48 */
typedef struct  _DistributedLockReply
    {
    RPC_BOOL fGranted;
    DistributedLockOwner dlo;
    }	DistributedLockReply;

#endif  // #ifndef RPC_COMMON_IDL
			/* size is 4 */
RPC_SC __cdecl ScGetMaintenanceMode( 
    /* [in] */ handle_t h,
    /* [out] */ RPC_DWORD __RPC_FAR *pdw,
    /* [out] */ RPC_SYSTEMTIME __RPC_FAR *pst,
    /* [out] */ RPC_SZ __RPC_FAR *pszUser);

			/* size is 4 */
RPC_SC __cdecl ScSetMaintenanceMode( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_DWORD dw,
    /* [in] */ RPC_SZ szUser);

			/* size is 4 */
RPC_SC __cdecl ScGetRemoteSystemTime( 
    /* [in] */ handle_t h,
    /* [out] */ RPC_SYSTEMTIME __RPC_FAR *pst);

			/* size is 4 */
RPC_SC __cdecl ScSetRemoteSystemTime( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SYSTEMTIME __RPC_FAR *pst);

#define		dwServerFlagMapiRunning			0x00000001
#define		dwServerFlagNoPrivateStore		0x00000002
			/* size is 4 */
RPC_SC __cdecl ScGetRemoteServerStatus( 
    /* [in] */ handle_t h,
    /* [out] */ RPC_DWORD __RPC_FAR *pdwServerFlags,
    /* [out] */ RemoteSystemTimeInfo __RPC_FAR *prsti,
    /* [out][in] */ RemoteServiceStatus __RPC_FAR *prss,
    /* [out] */ RemoteMaintenanceStatus __RPC_FAR *prms);

			/* size is 4 */
RPC_SC __cdecl ScRunOffLineABTask( 
    /* [in] */ handle_t h);

			/* size is 4 */
RPC_SC __cdecl ScGetDistributedLock( 
    /* [in] */ handle_t h,
    /* [in] */ DistributedLockRequest __RPC_FAR *pdlRequest,
    /* [out] */ DistributedLockReply __RPC_FAR *pdlReply);

			/* size is 4 */
RPC_SC __cdecl ScReleaseDistributedLock( 
    /* [in] */ handle_t h,
    /* [in] */ DistributedLockRequest __RPC_FAR *pdlRequest);

			/* size is 4 */
RPC_SC __cdecl ScKillDistributedLock( 
    /* [in] */ handle_t h,
    /* [in] */ DistributedLockRequest __RPC_FAR *pdlRequest,
    /* [out] */ DistributedLockReply __RPC_FAR *pdlReply);

			/* size is 4 */
RPC_SC __cdecl ScRasEnumEntries( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cb,
    /* [size_is][out] */ RPC_BYTE __RPC_FAR rgbRasEnumEntries[  ],
    /* [out] */ RPC_INT __RPC_FAR *pcEntries);

			/* size is 4 */
RPC_SC __cdecl ScGetExtensionPath( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szExtensionName,
    /* [in] */ RPC_SZ szExtensionCPU,
    /* [out] */ RPC_SZ __RPC_FAR *pszExtensionPath);



extern RPC_IF_HANDLE TriggerPrivateRPC_ClientIfHandle;
extern RPC_IF_HANDLE TriggerPrivateRPC_ServerIfHandle;
#endif /* __TriggerPrivateRPC_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcproxy.h ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs.

Compiler switches:

    -DREGISTER_PROXY_DLL
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DENTRY_PREFIX=<prefix>
        String to be prepended on all the DllGetClassObject etc routines
        in dlldata.c.  This includes: DllGetClassObject, DllCanUnloadNow
        and DllMain, DllRegisterServer, and DllUnregisterServer.

    -DNT35_STRICT
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with NT5 beta1+ env from build #1700 on.

#ifndef __RPCPROXY_H_VERSION__
#define __RPCPROXY_H_VERSION__      ( 475 )
#endif // __RPCPROXY_H_VERSION__


#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define __midl_proxy

#ifdef __REQUIRED_RPCPROXY_H_VERSION__
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif

// If this is the first file included __RPC_WIN64__ is not defined yet.
#if defined(_M_IA64) || defined(_M_AXP64)
#include <pshpack8.h>
#endif

#include <basetsd.h>

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if defined(WIN32) || defined(__RPC_WIN64__)

//We need to define REFIID, REFCLSID, REFGUID, & REFFMTID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#if defined(__cplusplus)
extern "C"
{
#endif

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int __stdcall IIDLookupRtn( const IID * pIID, int * pIndex );
typedef IIDLookupRtn * PIIDLookup;

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList  *pStubVtblList;
    const PCInterfaceName *         pNamesArray;
    const IID **                    pDelegatedIIDs;
    const PIIDLookup                pIIDLookupRtn;
    unsigned short                  TableSize;
    unsigned short                  TableVersion;
    const IID **                    pAsyncIIDLookup;
    LONG_PTR                        Filler2;
    LONG_PTR                        Filler3;
    LONG_PTR                        Filler4;
}ProxyFileInfo;

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

// Macro used for ANSI compatible stubs.

#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void *Vtbl[ n ];                  \
}

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
#if defined( _MSC_VER )
    void *Vtbl[];
#else
    void *Vtbl[1];
#endif
} CInterfaceProxyVtbl;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif

typedef
void
(__RPC_STUB * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer          *   This,
    IRpcChannelBuffer       *   _pRpcChannelBuffer,
    PRPC_MESSAGE                _pRpcMessage,
    DWORD *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID               *   piid;
    const MIDL_SERVER_INFO  *   pServerInfo;
    unsigned long               DispatchTableCount;
    const PRPC_STUB_FUNCTION *  pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader        header;
    IRpcStubBufferVtbl          Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl  *   lpVtbl;
    long                            RefCount;
    const ProxyFileInfo **          pProxyFileList;
    long                            Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

RPCRTAPI
void
RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

RPCRTAPI
void
RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitializePartial(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer,
    unsigned long       RequestedBufferSize);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

RPCRTAPI
void
RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer,
    PMIDL_STUB_MESSAGE  pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrStubErrorHandler(
    DWORD               dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer  *   This,
    REFIID              riid,
    void            **  ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *    This,
    IPSFactoryBuffer *  pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *    This,
    IUnknown *          pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *    This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer  *   This,
    RPCOLEMESSAGE   *   pRpcMsg,
    IRpcChannelBuffer * pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer  *   This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer  *   This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer  *   This,
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer  *   This,
    void *pv);

#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease

#define CStdAsyncStubBuffer_METHODS              0,0,0,0,0,0,0,0,0,0
#define CStdAsyncStubBuffer_DELEGATING_METHODS   0,0,0,0,0,0,0,0,0,0

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    result = name##_CHECK_IID( split );               \
    if ( result > 0 )                                 \
        { low = sz - split; }                         \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )      \
        result = name##_CHECK_IID( low + split );  \
        if ( result >= 0 )                         \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )  \
    low = low + 1;                                     \
    if (low >= sz)                                     \
        goto not_found_label;                          \
    result = name##_CHECK_IID( low );                  \
    if (result)                                        \
        goto not_found_label;                          \
    found_label: (index) = low; return 1;              \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

// if the user specified a routine prefix, pick it up...
//     if not, add nothing

#ifndef ENTRY_PREFIX

#ifndef DllMain
#define DISABLE_THREAD_LIBRARY_CALLS(x) DisableThreadLibraryCalls(x)
#endif

#define ENTRY_PREFIX
#define DLLREGISTERSERVER_ENTRY DllRegisterServer
#define DLLUNREGISTERSERVER_ENTRY DllUnregisterServer
#define DLLMAIN_ENTRY DllMain

#define DLLGETCLASSOBJECT_ENTRY DllGetClassObject
#define DLLCANUNLOADNOW_ENTRY DllCanUnloadNow

#else   // ENTRY_PREFIX

#define __rpc_macro_expand2(a, b) a##b
#define __rpc_macro_expand(a, b) __rpc_macro_expand2(a,b)
#define DLLREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllRegisterServer)
#define DLLUNREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllUnregisterServer)
#define DLLMAIN_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllMain)

#define DLLGETCLASSOBJECT_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllGetClassObject)
#define DLLCANUNLOADNOW_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllCanUnloadNow)

#endif  // ENTRY_PREFIX

#ifndef DISABLE_THREAD_LIBRARY_CALLS
#define DISABLE_THREAD_LIBRARY_CALLS(x)
#endif

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
*************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            { \
            hProxyDll = hinstDLL; \
            DISABLE_THREAD_LIBRARY_CALLS(hinstDLL); \
            } \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID



#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DLLGETCLASSOBJECT_ENTRY ( \
     REFCLSID rclsid, \
     REFIID riid, \
     void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DLLCANUNLOADNOW_ENTRY()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }


#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#if defined(__cplusplus)
} // extern "C"
#endif 

#endif // WIN32 or _WIN64_

#if defined(_M_IA64) || defined(_M_AXP64)
#include <poppack.h>
#endif

#endif // __RPCPROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rpcpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0104 */
/* at Tue Jul 09 17:55:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcpub_h__
#define __rpcpub_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __TriggerPublicRPC_INTERFACE_DEFINED__
#define __TriggerPublicRPC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: TriggerPublicRPC
 * at Tue Jul 09 17:55:57 1996
 * using MIDL 2.00.0104
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


#ifndef RPC_COMMON_IDL
#define RPC_COMMON_IDL
#define		szTriggerRPCProtocol		TEXT("ncacn_np")
#define		szTriggerRPCSecurity		TEXT("Security=impersonation dynamic true")
			/* size is 4 */
typedef long RPC_BOOL;

			/* size is 1 */
typedef small RPC_BYTE;

			/* size is 4 */
typedef long RPC_INT;

			/* size is 4 */
typedef long RPC_SC;

			/* size is 4 */
typedef long RPC_EC;

			/* size is 4 */
typedef long RPC_DWORD;

			/* size is 2 */
typedef wchar_t RPC_CHAR;

			/* size is 4 */
typedef /* [string] */ RPC_CHAR __RPC_FAR *RPC_SZ;

			/* size is 16 */
typedef struct  __MIDL_TriggerPublicRPC_0001
    {
    short rgwSystemTime[ 8 ];
    }	RPC_SYSTEMTIME;

			/* size is 172 */
typedef struct  __MIDL_TriggerPublicRPC_0002
    {
    RPC_BYTE rgbTzi[ 172 ];
    }	RPC_TIME_ZONE_INFORMATION;

			/* size is 28 */
typedef struct  __MIDL_TriggerPublicRPC_0003
    {
    long rgdwServiceStatus[ 7 ];
    }	RPC_SERVICE_STATUS;

#define		ecOK						0		// no error
#define		ecGeneralFailure			50001	// a failure occurred that caused proxy generation to stop
#define		ecSomeProxiesFailed			50002	// some proxies failed to get generated
#define		ecTargetNotValid			50003	// supplied target address not valid
#define		ecTargetNotUnique			50004	// supplied target address not unique
#define		ecProxyDLLNotImplemented	50005	// not implemented yet
#define		ecProxyDLLOOM				50006	// memory allocation error
#define		ecProxyDLLError				50007	// general error
#define		ecProxyDLLProtocol			50008	// protocol error
#define		ecProxyDLLSyntax			50009	// syntax error
#define		ecProxyDLLEOF				50010   // end of file
#define		ecProxyDLLSoftware			50011	// error in software
#define		ecProxyDLLConfig			50012	// configuration error
#define		ecProxyDLLContention		50013	// contention error
#define		ecProxyDLLNotFound			50014	// not found
#define		ecProxyDLLDiskSpace			50015	// out of disk space
#define		ecProxyDLLException			50016	// exception thrown
#define		ecProxyDLLDefault			50017	// unknown error
#define		ecProxyNotValid				50018	// supplied proxy not valid
#define		ecProxyNotUnique			50019	// supplied proxy not unique or unable to generate a unique proxy
#define		ecProxyDuplicate			50020	// a primary proxy of the same type was also supplied
			/* size is 16 */
typedef struct  _PROXYNODE
    {
    struct _PROXYNODE __RPC_FAR *pnodeNext;
    RPC_SZ wszProxy;
    RPC_EC ec;
    RPC_SZ wszDN;
    }	PROXYNODE;

			/* size is 4 */
typedef struct _PROXYNODE __RPC_FAR *PPROXYNODE;

			/* size is 48 */
typedef struct  _PROXYINFO
    {
    RPC_BOOL fContinueOnError;
    RPC_BOOL fIgnoreOldSecondaries;
    RPC_SZ wszDN;
    RPC_SZ wszNickName;
    RPC_SZ wszCommonName;
    RPC_SZ wszDisplayName;
    RPC_SZ wszSurName;
    RPC_SZ wszGivenName;
    RPC_SZ wszInitials;
    RPC_SZ wszTargetAddress;
    PROXYNODE __RPC_FAR *pPNVerifyProxy;
    PROXYNODE __RPC_FAR *pPNExcludeProxy;
    }	PROXYINFO;

			/* size is 4 */
typedef struct _PROXYINFO __RPC_FAR *PPROXYINFO;

			/* size is 8 */
typedef struct  _PROXYLIST
    {
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNProxy;
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNFailedProxyType;
    }	PROXYLIST;

			/* size is 4 */
typedef struct _PROXYLIST __RPC_FAR *PPROXYLIST;

			/* size is 192 */
typedef struct  __MIDL_TriggerPublicRPC_0004
    {
    RPC_SYSTEMTIME st;
    RPC_TIME_ZONE_INFORMATION tzi;
    RPC_DWORD dwReturn;
    }	RemoteSystemTimeInfo;

			/* size is 48 */
typedef struct  _RemoteServiceStatus
    {
    RPC_SC sc;
    RPC_SZ szShortName;
    RPC_SZ szDisplayName;
    RPC_SZ szVersion;
    RPC_SERVICE_STATUS ss;
    struct _RemoteServiceStatus __RPC_FAR *prssNext;
    }	RemoteServiceStatus;

#define		rmsSuspendRepair	0x0001
#define		rmsSuspendNotif		0x0002
			/* size is 24 */
typedef struct  _RemoteMaintenanceStatus
    {
    RPC_DWORD dwStatus;
    RPC_SYSTEMTIME st;
    RPC_SZ szUser;
    }	RemoteMaintenanceStatus;

			/* size is 12 */
typedef struct  _BackupListNode
    {
    struct _BackupListNode __RPC_FAR *pnodeNext;
    struct _BackupListNode __RPC_FAR *pnodeChildren;
    RPC_SZ szName;
    }	BackupListNode;

			/* size is 44 */
typedef struct  _DistributedLockOwner
    {
    RPC_CHAR rgchComputer[ 17 ];
    RPC_DWORD dwPID;
    RPC_DWORD dwTID;
    }	DistributedLockOwner;

#define	DLR_NO_WAIT		0x00000001
#define	cchMaxLockName	17
			/* size is 84 */
typedef struct  _DistributedLockRequest
    {
    RPC_CHAR rgchLockName[ 17 ];
    RPC_DWORD dwFlags;
    DistributedLockOwner dlo;
    }	DistributedLockRequest;

			/* size is 48 */
typedef struct  _DistributedLockReply
    {
    RPC_BOOL fGranted;
    DistributedLockOwner dlo;
    }	DistributedLockReply;

#endif  // #ifndef RPC_COMMON_IDL
			/* size is 4 */
RPC_SC __cdecl ScNetworkTimingTest( 
    /* [in] */ handle_t h,
    /* [in] */ long cbSend,
    /* [size_is][in] */ small __RPC_FAR rgbSend[  ],
    /* [in] */ long cbReceive,
    /* [size_is][out] */ small __RPC_FAR rgbReceive[  ]);

			/* size is 4 */
RPC_SC __cdecl ScRunRID( 
    /* [in] */ handle_t h);

			/* size is 4 */
RPC_SC __cdecl ScRunRIDEx( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fProxySpace,
    /* [in] */ RPC_BOOL fGwart);

			/* size is 4 */
RPC_SC __cdecl ScRunDRACheck( 
    /* [in] */ handle_t h,
    RPC_DWORD dw);

#define		BPTAdd			1
#define		BPTRemove		2
#define		BPTUpdate		3
			/* size is 4 */
RPC_SC __cdecl ScBulkCreateProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szHeader,
    /* [in] */ RPC_DWORD dwOptions);

			/* size is 4 */
RPC_SC __cdecl ScBulkCreateMultiProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cszHeader,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszRecipients[  ],
    /* [in] */ RPC_DWORD dwOptions);

			/* size is 4 */
RPC_SC __cdecl ScBulkUpdateMultiProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cszSiteAddress,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszOldSiteAddress[  ],
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszNewSiteAddress[  ],
    /* [in] */ RPC_BOOL fSaveSiteAddress);

			/* size is 4 */
RPC_SC __cdecl ScGetBulkProxyStatus( 
    /* [in] */ handle_t h,
    /* [out] */ RPC_SYSTEMTIME __RPC_FAR *pstTimeStart,
    /* [out] */ RPC_DWORD __RPC_FAR *pdwTimeStart,
    /* [out] */ RPC_DWORD __RPC_FAR *pdwTimeCur,
    /* [out] */ RPC_INT __RPC_FAR *piRecipients,
    /* [out] */ RPC_INT __RPC_FAR *pcRecipients);

			/* size is 4 */
RPC_SC __cdecl ScBulkProxyHalt( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fWaitForShutdown);

			/* size is 4 */
RPC_EC __cdecl EcGetProxies( 
    /* [in] */ handle_t h,
    /* [in] */ PPROXYINFO pProxyInfo,
    /* [out][in] */ PPROXYLIST pProxyList);

			/* size is 4 */
RPC_SC __cdecl ScIsProxyUnique( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfUnique,
    /* [out] */ RPC_SZ __RPC_FAR *pszOwner);

			/* size is 4 */
RPC_SC __cdecl ScProxyValidate( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfValid,
    /* [out] */ RPC_SZ __RPC_FAR *pszProxyCorrected);

			/* size is 4 */
RPC_SC __cdecl ScSiteProxyValidate( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szSiteProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfValid,
    /* [out] */ RPC_SZ __RPC_FAR *pszSiteProxyCorrected);

			/* size is 4 */
RPC_SC __cdecl ScProxyReset( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fWaitUntilCompleted);

#define		scNoError			0
#define		scInvalidData		1
#define		scCannotLogData		2
			/* size is 4 */
RPC_SC __cdecl ScSaveTrackingData( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cb,
    /* [size_is][in] */ RPC_BYTE __RPC_FAR pb[  ],
    /* [in] */ RPC_DWORD dwFlags);

#define		tevtMessageTransferIn		0
#define		tevtReportTransferIn		2
#define		tevtMessageSubmission		4
#define		tevtMessageTransferOut		7
#define		tevtReportTransferOut		8
#define		tevtMessageDelivery			9
#define		tevtReportDelivery			10
#define		tevtStartAssocByMTSUser		18
#define		tevtReleaseAssocByMTSUser	23
#define		tevtDLExpansion				26
#define		tevtRedirection				28
#define		tevtRerouting				29
#define		tevtDowngrading				31
#define		tevtReportAbsorption		33
#define		tevtReportGenerated			34
#define		tevtUnroutableReportDiscard	43
#define		tevtMessageLocalDelivery		1000
#define		tevtMessageBackboneTransferIn	1001
#define		tevtMessageBackboneTransferOut	1002
#define		tevtMessageGatewayTransferOut	1003
#define		tevtMessageGatewayTransferIn	1004
#define		tevtReportGatewayTransferIn		1005
#define		tevtReportGatewayTransferOut	1006
#define		tevtReportGatewayGenerated		1007
#define		tevtUserMin		2000
			/* size is 60 */
typedef struct  __MIDL_TriggerPublicRPC_0005
    {
    RPC_INT nEventType;
    RPC_SYSTEMTIME stEvent;
    RPC_SZ szGatewayName;
    RPC_SZ szPartner;
    RPC_SZ szMTSID;
    RPC_SZ szRemoteID;
    RPC_SZ szOriginator;
    RPC_INT nPriority;
    RPC_INT nLength;
    RPC_INT nSeconds;
    RPC_INT nCost;
    RPC_SZ szSubjectID;
    }	RPC_GATEWAY_TRACK_INFORMATION;

			/* size is 4 */
RPC_SC __cdecl ScSaveGatewayTrackingData( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_GATEWAY_TRACK_INFORMATION __RPC_FAR *pgti,
    /* [in] */ RPC_INT cszRecipients,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszRecipients[  ]);



extern RPC_IF_HANDLE TriggerPublicRPC_ClientIfHandle;
extern RPC_IF_HANDLE TriggerPublicRPC_ServerIfHandle;
#endif /* __TriggerPublicRPC_INTERFACE_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0001
 * at Tue Jul 09 17:55:57 1996
 * using MIDL 2.00.0104
 ****************************************/
/* [local] */ 


#define		szTrackReportRecipientInfoDelivered	L("\t0")
#define		szTrackReportRecipientInfoNonDelivered	L("\t1")


extern RPC_IF_HANDLE __MIDL__intf_0001_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL__intf_0001_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtflib.h ===
/*
 *	R T F L I B . H
 *
 *	Definitions for RTF library.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef RTFLIB_H
#define RTFLIB_H

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32)
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif


/*
 * RTFLIB only looks at the first cchBodyTagMax characters of the body tag.
 */
#define cchBodyTagMax	100

typedef struct _RTFSYNCINFO
{
	LONG lBodyCRC;
	LONG lBodyCount;
	LONG lPrefixCount;
	LONG lTrailingCount;
	char szBodyTag[cchBodyTagMax + 2];
} RTFSYNCINFO;

// header for compressed stream
typedef struct _lzfuhdr
{
	ULONG cbSize;		// total number of bytes following this field
	ULONG cbRawSize;	// size before compression
	DWORD dwMagic;		// identifies this as a compressed stream
	DWORD dwCRC;		// CRC-32 of the compressed data for error checking
} LZFUHDR;

// magic number that identifies the stream as a compressed stream
#define dwMagicCompressedRTF 0x75465a4c

// magic number that identifies the stream as a uncompressed stream
#define dwMagicUncompressedRTF 0x414c454d

// array used for CRC calculations
extern const DWORD rgdwCRC[];

/* IMPORTED FUNCTIONS */

/* 
 * LogInvalidCpid
 *
 * Imported callback function for logging code page conversion
 * errors. A stub function is provided if a function is
 * not provided by the project linking with RTFLIB
 *
 * The cpid parameter is the unsupported code page ID.
 *
 */

STDAPI_(void) LogInvalidCpid( ULONG cpid );


/* MAIN RTF ROUTINES */

/*
 * HrTextFromCompressedRTFStream
 *
 * Takes compressed RTF stream (pstmRTF) and returns a wrapper
 * stream (*ppstmText) giving access to the plain text. The text
 * stream supports Read and CopyTo methods.
 * 
 * The pointer psi must be valid until *ppstmText is released.
 * It is updated as *ppstmText is read and is not accurate until
 * all of the text has been read.
 *
 * cpid is the code page for the text stream. It can be any code page
 * INCLUDING unicode. cpid=0 means current system code page. If	the
 * requested code page is not supported, S_FALSE warning may be
 * returned during Read or CopyTo operation.
 */

STDAPI_(HRESULT) HrTextFromCompressedRTFStream(LPSTREAM pstmCompressed,
			LPSTREAM FAR *ppstmText, RTFSYNCINFO FAR *psi, ULONG cpid);


/*
 * HrTextFromCompressedRTFStreamEx()
 *
 * Takes compressed RTF stream (pstmRTF) and returns a wrapper
 * stream (*ppstmText) giving access to the plain text. The text
 * stream supports Read and CopyTo methods.
 * 
 * The pointer psi must be valid until *ppstmText is released.
 * It is updated as *ppstmText is read and is not accurate until
 * all of the text has been read.
 *
 * rgAttachPos is an array of attachment positions. It must be 
 * initialized to the current attachment positions before 
 * HrTextFromCompressedRTFStreamEx() is called. 
 *
 * cAttach must contain the number of elements in rgAttachPos
 *
 * The pointer to rgAttachPos must be valid until *ppstmText is 
 * released. It is updated as *ppstmText is read with the new 
 * attachment positions and is not accurate until all of the text
 * has been read.
 *
 * cpid is the code page for the text stream. It can be any code page
 * INCLUDING unicode. cpid=0 means current system code page. If	the
 * requested code page is not supported, S_FALSE warning may be
 * returned during Read or CopyTo operation.
 */

STDAPI_(HRESULT) HrTextFromCompressedRTFStreamEx( LPSTREAM pstmCompressed,
			LPSTREAM FAR *ppstmText, RTFSYNCINFO FAR *psi, ULONG cpid,
            ULONG cAttach, ULONG FAR *rgAttachPos );

/*
 * HrRTFFromTextStream
 *
 * This function takes a text stream and returns a wrapper 
 * stream interface that converts the text to RTF. The 
 * stream wrapper is read only and only supports  
 * a minimum stream interface.
 *
 * The pointer to rgAttachPos must be valid until *ppstmRTF is 
 * released. This array is used to allow the insertion of 
 * attachment tags in the RTF. 
 *
 * cpid is the code page for the text stream. It is used to 
 * set the charset and font in the RTF. No code page conversion
 * is currently done inside this function.
 */

STDAPI_(HRESULT) HrRTFFromTextStream( LPSTREAM pstmText,
										LPSTREAM *ppstmRTF,										
										ULONG cpid,
										ULONG cAttach,
										ULONG FAR *rgAttachPos );

/*
 * WrapCompressedRTFStream
 *
 * Takes compressed RTF stream (pstmCompressed) and returns a wrapper
 * stream (*ppstmRTF) giving access to uncompressed RTF. The RTF
 * stream can support both Read and Write operations, but to get
 * write access the flag ulFlags must have MAPI_MODIFY bit set.
 *
 * This function also supports reading and writing uncompressed
 * RTF through the use of the STORE_UNCOMPRESSED_RTF flag. For reading,
 * uncompressed RTF streams are detected automatically and thus the 
 * STORE_UNCOMPRESSED_RTF flag only has meaning if MAPI_MODIFY is set.
 * If this flag is used, the data will be written in uncompressed form.
 */

STDAPI_(HRESULT) WrapCompressedRTFStream(LPSTREAM pstmCompressed,
			ULONG ulFlags, LPSTREAM FAR *ppstmRTF);

/*
 * RTFSync
 * RTFSyncCpid
 *
 * Perforts body and RTF synchronization.
 * 
 * If synchronization cannot be performed, RTF properties are removed.
 * It is up to the caller to create new RTF from PR_BODY.
 *
 * cpid is the code page for the body property. It can be any code page
 * EXCLUDING unicode. cpid=0 means current system code page. If	the
 * requested code page is not supported, S_FALSE warning is returned.
 * RTFSync is the same as RTFSyncCpid(cpid=0).
 */

STDAPI_(HRESULT) RTFSync(LPMESSAGE lpMessage, ULONG ulFlags,
			BOOL FAR *pfMessageUpdated);

STDAPI_(HRESULT) RTFSyncCpid(LPMESSAGE lpMessage, ULONG ulFlags,
			BOOL FAR *pfMessageUpdated, ULONG cpid);

/* ulFlags for RTFSync */
#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

/*
 * ScUpdateRTFAux
 *
 * Calculates and updates RTF auxiliary properties.
 */

STDAPI_(SCODE) ScUpdateRTFAux(LPMESSAGE lpMessage,
			BOOL FAR *lpfMessageUpdated);

STDAPI_(SCODE) ScUpdateRTFAuxCpid(LPMESSAGE lpMessage,
			BOOL FAR *lpfMessageUpdated, ULONG cpid);

/*
 * HrAppendTextToCompressedRTF
 *
 * Takes a text buffer (pbText, cchText) and appends it to the compressed
 * RTF property of the message (lpMessage) appying default text formatting.
 *
 * The text can be added either at the beginning of the message
 * (RTF_APPEND_BEGIN) or at the end (RTF_APPEND_END).
 * The text can be treated as a plain text (RTF_APPEND_PLAIN_TEXT)
 * or as a piece of text with some RTF formatting in it
 * (RTF_APPEND_RTF_TEXT).
 *
 * If case of RTF text, cchText is the number of plain text characters.
 *
 * cpid is the code page for the text stream. It should be one of
 * Windows code pages EXCLUDING unicode. cpid=0 means current system
 * code page. If the requested code page is not supported,
 * S_FALSE warning is returned.
 */

STDAPI_(HRESULT) HrAppendTextToCompressedRTF(LPMESSAGE lpMessage,
			LPSTR strText, ULONG cchText, ULONG ulFlags, ULONG cpid);

/* ulFlags for HrAppendTextToCompressedRTF */
	/* text properties (mutually exclusive) */
#define RTF_APPEND_RTF_TEXT	((ULONG) 0x00000001)
#define RTF_APPEND_PLAIN_TEXT ((ULONG) 0x00000000)
	/* append position (mutually exclusive) */
#define RTF_APPEND_BEGIN ((ULONG) 0x00000002)
#define RTF_APPEND_END ((ULONG) 0x00000000)

/* ATTACHMENT TABLE HANDLING ROUTINES */

/*
 * ScGetAttachTable()
 *
 * Takes a message and returns a pointer to the set of rows in
 * the attachment table (ppRowSet), the number of attachments 
 * (pcAttach), and a pointer to an array of ULONGs containing
 * the PR_RENDERING_POSITIONs for the attachments in sorted
 * order.
 *
 */

STDAPI_(SCODE) ScGetAttachTable(LPMESSAGE pmsg, LPSRowSet *ppRowSet,
				UINT *pcAttach, ULONG **prgAttachPos);

/*
 * ScUpdateAttachTable()
 *
 * Takes a message, a rowset for the attachment table, the 
 * number of attachments, and an array of rendering positions
 * to update the attachment table with. This function is 
 * designed to be used in conjunction with ScGetAttachTable().
 * The BOOLEAN pointed to by pfUpdated will be set to TRUE if
 * the attachment table was modified.
 *
 */

STDAPI_(SCODE) ScUpdateAttachTable(LPMESSAGE pmsg, LPSRowSet pRowSet,
				UINT cAttach, ULONG *rgAttachPos, BOOL *pfUpdated);


/* CPID CONVERSION ROUTINES */

/*
 * These functions are in a separate object file (cpmap.obj),
 * since on the store side they are linked into a different DLL.
 */

STDAPI_(ULONG) WinCpidFromCpid (ULONG cpid);
STDAPI_(ULONG) CharsetFromCpid (ULONG cpid);
STDAPI_(ULONG) CpidFromCharset (ULONG charset);
STDAPI_(CHAR FAR*) SzDefFontFmtFromCpid (ULONG cpid);


#endif /* RTFLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtinfo.h ===
/*++

Copyright (c) 1995 - 1997 Microsoft Corporation

Module Name:

    rtinfo.h

Abstract:
	Definitions of information block structuers used to exchange
	information in router API

--*/

#ifndef __ROUTING_RTINFO_H__
#define __ROUTING_RTINFO_H__

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Information is passed to and from the Router Managers using a set of     //
// RTR_TOC_ENTRY structures. These structures are encapsulated by an        //
// RTR_INFO_BLOCK_HEADER.                                                   //
// The general structure of this is:                                        //
//                                                                          //
//           ---    |-----------------------|   ---                         //
//            |     |                       |    |                          //
//            |     | RTR_INFO_BLOCK_HEADER |    |                          //
//            |     |                       |    |                          //
//            |     | TocEntriesCount = N   |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[0]      |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |<------  Associated Data     |    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     Z                       Z    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[N-1]    |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |     |   Associated Data  ------->|                          //
//            |     |                       |    |                          //
//           ---    |-----------------------|    |                          //
//                  |  Data for TocEntry[0] |    |                          //
//                  |-----------------------|    |                          //
//                  Z                       Z    |                          //
//                  |-----------------------|   ---                         //
//                  | Data for TocEntry[N-1]|                               //
//                  |-----------------------|                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each of the blocks of data must begin at a quadword aligned boundary. To //
// get QUADWORD alignment, use the following macros.                        //
//                                                                          //
// The block of data pointed to by an InfoBlock MUST be aligned.            //
// Use the alignment macro when writing the data portion  into an infobase. //
// This implies that for each ALIGN_POINTER operation done on a chunk       //
// of memory, the requested allocation must be ALIGN_SIZE greater           //
// than what is actually required (to be on the safe side)                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define ALIGN_SIZE      0x00000008
#define ALIGN_SHIFT     (ALIGN_SIZE - 0x00000001)   // 0x00000007
#define ALIGN_MASK      (~ALIGN_SHIFT)              // 0xfffffff8

#define ALIGN_POINTER(ptr) {                \
    ((DWORD) (ptr)) += ALIGN_SHIFT;     \
    ((DWORD) (ptr)) &= ALIGN_MASK;      \
}

#define IS_ALIGNED(ptr)  (((DWORD)(ptr) & ALIGN_SHIFT) == 0x00000000)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Table of Contents Entry 	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each entry describes a structure type, location within the information   //
// block and number of entries of the same type.                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _RTR_TOC_ENTRY 
{
    ULONG	    InfoType;	// Info structure type
    ULONG	    InfoSize;	// Size of the info structure
    ULONG	    Count;		// How many info structures of this type
    ULONG	    Offset;		// Offset of the first structure, from the start 
							// of the info block header.
}RTR_TOC_ENTRY, *PRTR_TOC_ENTRY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Info Block Header        	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All Router information blocks start with this header                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RTR_INFO_BLOCK_VERSION	1

typedef struct _RTR_INFO_BLOCK_HEADER 
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;

//
// PVOID
// GetInfoFromTocEntry(
//                     IN PRTR_INFO_BLOCK_HEADER pInfoHdr,
//                     IN PRTR_TOC_ENTRY         pToc
//                     )
//

#define GetInfoFromTocEntry(hdr,toc)            \
    (((toc)->Offset < (hdr)->Size) ? ((PVOID)(((PBYTE)(hdr)) + (toc)->Offset)) : NULL)

#endif //__ROUTING_RTINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\RrasCfg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Fri Nov 20 18:57:15 1998
 */
/* Compiler settings for rrascfg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rrascfg_h__
#define __rrascfg_h__

/* Forward Declarations */ 

#ifndef __IRouterProtocolConfig_FWD_DEFINED__
#define __IRouterProtocolConfig_FWD_DEFINED__
typedef interface IRouterProtocolConfig IRouterProtocolConfig;
#endif 	/* __IRouterProtocolConfig_FWD_DEFINED__ */


#ifndef __IAuthenticationProviderConfig_FWD_DEFINED__
#define __IAuthenticationProviderConfig_FWD_DEFINED__
typedef interface IAuthenticationProviderConfig IAuthenticationProviderConfig;
#endif 	/* __IAuthenticationProviderConfig_FWD_DEFINED__ */


#ifndef __IAccountingProviderConfig_FWD_DEFINED__
#define __IAccountingProviderConfig_FWD_DEFINED__
typedef interface IAccountingProviderConfig IAccountingProviderConfig;
#endif 	/* __IAccountingProviderConfig_FWD_DEFINED__ */


#ifndef __IEAPProviderConfig_FWD_DEFINED__
#define __IEAPProviderConfig_FWD_DEFINED__
typedef interface IEAPProviderConfig IEAPProviderConfig;
#endif 	/* __IEAPProviderConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "wtypes.h"
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_rrascfg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// RRasCfg.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
 
typedef BYTE __RPC_FAR *PBYTE;



extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_s_ifspec;

#ifndef __IRouterProtocolConfig_INTERFACE_DEFINED__
#define __IRouterProtocolConfig_INTERFACE_DEFINED__

/* interface IRouterProtocolConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IRouterProtocolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB16-D706-11D0-A37B-00C04FC9DA04")
    IRouterProtocolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRouterProtocolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        END_INTERFACE
    } IRouterProtocolConfigVtbl;

    interface IRouterProtocolConfig
    {
        CONST_VTBL struct IRouterProtocolConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRouterProtocolConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRouterProtocolConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRouterProtocolConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRouterProtocolConfig_AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#define IRouterProtocolConfig_RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_AddProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_AddProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_RemoveProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_RemoveProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRouterProtocolConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0011 */
/* [local] */ 

#define DeclareIRouterProtocolConfigMembers(IPURE) \
	STDMETHOD(AddProtocol)(THIS_ LPCOLESTR pszMachineName,\
					   DWORD dwTransportId,\
					   DWORD dwProtocolId,\
					   HWND hWnd,\
					   DWORD dwFlags,\
					   IUnknown *pRouter,\
					   ULONG_PTR uReserved1) IPURE;\
	STDMETHOD(RemoveProtocol)(THIS_ LPCOLESTR pszMachineName,\
						 DWORD dwTransportId,\
						 DWORD dwProtocolId,\
						 HWND hWnd,\
						 DWORD dwFlags,\
						 IUnknown *pRouter,\
						 ULONG_PTR uReserved2) IPURE;\
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_s_ifspec;

#ifndef __IAuthenticationProviderConfig_INTERFACE_DEFINED__
#define __IAuthenticationProviderConfig_INTERFACE_DEFINED__

/* interface IAuthenticationProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAuthenticationProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB17-D706-11D0-A37B-00C04FC9DA04")
    IAuthenticationProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticationProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAuthenticationProviderConfigVtbl;

    interface IAuthenticationProviderConfig
    {
        CONST_VTBL struct IAuthenticationProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticationProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticationProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticationProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticationProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAuthenticationProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAuthenticationProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Initialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Uninitialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Configure_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Activate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Deactivate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticationProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0013 */
/* [local] */ 

#define DeclareIAuthenticationProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	 \
	STDMETHOD(Configure)(THIS_ \
							ULONG_PTR uConnectionParam, \
							HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_s_ifspec;

#ifndef __IAccountingProviderConfig_INTERFACE_DEFINED__
#define __IAccountingProviderConfig_INTERFACE_DEFINED__

/* interface IAccountingProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAccountingProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB18-D706-11D0-A37B-00C04FC9DA04")
    IAccountingProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountingProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAccountingProviderConfigVtbl;

    interface IAccountingProviderConfig
    {
        CONST_VTBL struct IAccountingProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountingProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountingProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountingProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountingProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAccountingProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAccountingProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAccountingProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAccountingProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Initialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Uninitialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Configure_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Activate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Deactivate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountingProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0015 */
/* [local] */ 

#define DeclareIAccountingProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	STDMETHOD(Configure)(THIS_ \
						ULONG_PTR uConnectionParam, \
						HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_s_ifspec;

#ifndef __IEAPProviderConfig_INTERFACE_DEFINED__
#define __IEAPProviderConfig_INTERFACE_DEFINED__

/* interface IEAPProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IEAPProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB19-D706-11D0-A37B-00C04FC9DA04")
    IEAPProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServerInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeCredentialsUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEAPProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServerInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeCredentialsUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);
        
        END_INTERFACE
    } IEAPProviderConfigVtbl;

    interface IEAPProviderConfig
    {
        CONST_VTBL struct IEAPProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEAPProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEAPProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEAPProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEAPProviderConfig_Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)

#define IEAPProviderConfig_Uninitialize(This,dwEapTypeId,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,dwEapTypeId,uConnectionParam)

#define IEAPProviderConfig_ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)	\
    (This)->lpVtbl -> ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)

#define IEAPProviderConfig_RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)	\
    (This)->lpVtbl -> RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)

#define IEAPProviderConfig_RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)	\
    (This)->lpVtbl -> RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Initialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwEapTypeId,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IEAPProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Uninitialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IEAPProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_ServerInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IEAPProviderConfig_ServerInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeCredentialsUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
    /* [in] */ DWORD dwSizeOfUserDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeCredentialsUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEAPProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0017 */
/* [local] */ 

#define DeclareIEAPProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
		LPCOLESTR 	pszMachineName, \
 	DWORD       dwEapTypeId, \
		ULONG_PTR*	puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam) IPURE; \
	STDMETHOD(ServerInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
		HWND 		hWnd, \
		ULONG_PTR 	dwRes1, \
		ULONG_PTR 	dwRes2) IPURE; \
 STDMETHOD(RouterInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND        hwndParent, \
 	DWORD       dwFlags, \
 	BYTE* 		pConnectionDataIn, \
 	DWORD		dwSizeOfConnectionDataIn, \
 	BYTE**		ppConnectionDataOut, \
 	DWORD*		pdwSizeOfConnectionDataOut) IPURE; \
 STDMETHOD(RouterInvokeCredentialsUI)(THIS_  \
 	DWORD   	dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND    	hwndParent, \
 	DWORD   	dwFlags, \
 	BYTE*   	pConnectionDataIn, \
 	DWORD   	dwSizeOfConnectionDataIn, \
 	BYTE*   	pUserDataIn, \
 	DWORD   	dwSizeOfUserDataIn, \
 	BYTE**  	ppUserDataOut, \
 	DWORD*  	pdwSizeOfUserDataOut) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sac.h ===
#ifndef __SAC_H__
#define __SAC_H__

typedef DWORD HMAC;

#define RSA_KEY_LEN 64
#define SAC_SESSION_KEYLEN 8

#define SAC_PROTOCOL_WMDM 1
#define SAC_PROTOCOL_V1 2

#define SAC_CERT_X509 1
#define SAC_CERT_V1 2

typedef struct __MACINFO
{
	BOOL fUsed;
	BYTE abMacState[36];
} MACINFO;

#endif //__SAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtmv2.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rtmv2.h

Abstract:
    Interface for Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  01-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_RTMv2_H__
#define __ROUTING_RTMv2_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// General Constants defined by the API
//

// Max addr size for an address family
#define RTM_MAX_ADDRESS_SIZE         16

//
// Supported Route Table Views
//
#define RTM_MAX_VIEWS                 32

#define RTM_VIEW_ID_UCAST              0
#define RTM_VIEW_ID_MCAST              1

#define RTM_VIEW_MASK_SIZE          0x20

#define RTM_VIEW_MASK_NONE    0x00000000
#define RTM_VIEW_MASK_ANY     0x00000000

#define RTM_VIEW_MASK_UCAST   0x00000001
#define RTM_VIEW_MASK_MCAST   0x00000002

#define RTM_VIEW_MASK_ALL     0xFFFFFFFF

// Identifies a particular view
typedef INT   RTM_VIEW_ID, *PRTM_VIEW_ID;

// Set of views expressed as a mask
typedef DWORD RTM_VIEW_SET, *PRTM_VIEW_SET;


//
// Profile returned during registration
//
typedef struct _RTM_REGN_PROFILE
{
    UINT            MaxNextHopsInRoute; // Max. number of equal cost nexthops
                                        // in a route, & Max. number of local
                                        // nexthops in any one remote nexthop

    UINT            MaxHandlesInEnum;   // Max. handles returned in one call to
                                        // RtmGetEnumDests, RtmGetChangedDests,
                                        // RtmGetEnumRoutes,RtmGetRoutesInElist

    RTM_VIEW_SET    ViewsSupported;     // Views supported by this addr family

    UINT            NumberOfViews;      // Number of views (# 1s in above mask)
}
RTM_REGN_PROFILE, *PRTM_REGN_PROFILE;


//
// Handles pointing to RTMv2 blocks
//
typedef HANDLE      RTM_ENTITY_HANDLE,
                   *PRTM_ENTITY_HANDLE,
                    RTM_DEST_HANDLE,
                   *PRTM_DEST_HANDLE,
                    RTM_ROUTE_HANDLE,
                   *PRTM_ROUTE_HANDLE,
                    RTM_NEXTHOP_HANDLE,
                   *PRTM_NEXTHOP_HANDLE,
                    RTM_ENUM_HANDLE,
                   *PRTM_ENUM_HANDLE,
                    RTM_ROUTE_LIST_HANDLE,
                   *PRTM_ROUTE_LIST_HANDLE,
                    RTM_NOTIFY_HANDLE,
                   *PRTM_NOTIFY_HANDLE;

//
// Network Address struct for any
// address family that works with
// only contiguous address masks
//
typedef struct _RTM_NET_ADDRESS
{
    USHORT AddressFamily;                  // Type of this net address (IPv4..)

    USHORT NumBits;                        // Number of leading bits in prefix

    UCHAR  AddrBits[RTM_MAX_ADDRESS_SIZE]; // Array of bits that form prefix
}
RTM_NET_ADDRESS, *PRTM_NET_ADDRESS;


//
// IPv4 macros to work on addresses
//

#define RTM_IPV4_MAKE_NET_ADDRESS(NetAddress, Addr, Len)           \
        RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)


#define RTM_CHECK_NTH_BIT(Value, N, Len)                           \
        if ((Value) & (1 << (N)))                                  \
        {                                                          \
            (Len) += (N); (Value) <<= (N);                         \
        }                                                          \

#define RTM_IPV4_LEN_FROM_MASK(Len, Mask)                          \
        {                                                          \
            ULONG _Temp_ = ntohl(Mask);                            \
                                                                   \
            (Len) = 0;                                             \
                                                                   \
            RTM_CHECK_NTH_BIT(_Temp_, 16, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  8, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  4, (Len));                  \
                                                                   \
            while (_Temp_)                                         \
            {                                                      \
                (Len) +=  1; _Temp_ <<=  1;                        \
            }                                                      \
        }                                                          \

#define RTM_IPV4_MASK_FROM_LEN(Len)                                \
        ((Len) ? htonl(~0 << (32 - (Len))): 0);                    \


#define RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)           \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (NetAddress)->NumBits  = (USHORT) (Len);                   \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \

#define RTM_IPV4_GET_ADDR_AND_LEN(Addr, Len, NetAddress)           \
        (Len) = (NetAddress)->NumBits;                             \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \


#define RTM_IPV4_SET_ADDR_AND_MASK(NetAddress, Addr, Mask)         \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \
        RTM_IPV4_LEN_FROM_MASK((NetAddress)->NumBits, Mask)

#define RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, NetAddress)         \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \
        (Mask) = RTM_IPV4_MASK_FROM_LEN((NetAddress)->NumBits);    \


//
// This structure encapsulates info
// used in comparing any two routes
// [Preference is impt than metric]
//
typedef struct _RTM_PREF_INFO
{
    ULONG               Metric;         // Routing protocol specific metric
    ULONG               Preference;     // Determined by the router policy
}
RTM_PREF_INFO, *PRTM_PREF_INFO;


//
// List of nexthops used for equal
// cost path in a route or nexthop
//
typedef struct _RTM_NEXTHOP_LIST
{
    USHORT              NumNextHops;    // Num of equal cost next hops in list
    RTM_NEXTHOP_HANDLE  NextHops[1];    // NumNextHops num of next hop handles
}
RTM_NEXTHOP_LIST, *PRTM_NEXTHOP_LIST;


//
// Structure used to exchange dest
// information with RTM entities
//
typedef struct _RTM_DEST_INFO
{
    RTM_DEST_HANDLE     DestHandle;       // Handle to the destination

    RTM_NET_ADDRESS     DestAddress;      // Destination network Address

    FILETIME            LastChanged;      // Last time dest was modified

    RTM_VIEW_SET        BelongsToViews;   // View that dest belongs too

    UINT                NumberOfViews;    // Number of view info slots
    struct
    {
        RTM_VIEW_ID         ViewId;       // View ID for this view info block
        UINT                NumRoutes;    // Number of routes,
        RTM_ROUTE_HANDLE    Route;        // Best route with matching criteria
        RTM_ENTITY_HANDLE   Owner;        // Best Route's Owner,
        DWORD               DestFlags;    // Best Route's Flags, and
        RTM_ROUTE_HANDLE    HoldRoute;    // Holddown route,
    }                   ViewInfo[1];      // in each one of the supported views
}
RTM_DEST_INFO, *PRTM_DEST_INFO;

//
// Macros useful in working on dests
//
#define RTM_BASIC_DEST_INFO_SIZE                                         \
    FIELD_OFFSET(RTM_DEST_INFO, ViewInfo)

#define RTM_DEST_VIEW_INFO_SIZE                                          \
    (sizeof(RTM_DEST_INFO) - RTM_BASIC_DEST_INFO_SIZE)

#define RTM_SIZE_OF_DEST_INFO(NumViews)                                  \
    (RTM_BASIC_DEST_INFO_SIZE + (NumViews) * RTM_DEST_VIEW_INFO_SIZE)

//
// Destination Flags
//
#define RTM_DEST_FLAG_NATURAL_NET   0x01
#define RTM_DEST_FLAG_FWD_ENGIN_ADD 0x02
#define RTM_DEST_FLAG_DONT_FORWARD  0x04

//
// Structure used to exchange route
// information with RTM entities
//
typedef struct _RTM_ROUTE_INFO
{
    //
    // Information that the owner can
    // directly access for read only
    //

    RTM_DEST_HANDLE     DestHandle;       // Handle to owning destination

    RTM_ENTITY_HANDLE   RouteOwner;       // Entity the owns this route

    RTM_NEXTHOP_HANDLE  Neighbour;        // Neighbour we learnt route from

    UCHAR               State;            // See RTM_ROUTE_STATE_* below

    //
    // Information that the owner can
    // directly access for read/write
    //

    UCHAR               Flags1;           // RTM v1 compatibility flags (temp)

    USHORT              Flags;            // See RTM_ROUTE_FLAGS_* below

    RTM_PREF_INFO       PrefInfo;         // Preference and metric for route

    RTM_VIEW_SET        BelongsToViews;   // Views that route belongs to

    PVOID               EntitySpecificInfo; // Owning Entity's private info

    RTM_NEXTHOP_LIST    NextHopsList;     // List of equal cost next-hops
}
RTM_ROUTE_INFO, *PRTM_ROUTE_INFO;

//
// Macros useful in working on routes
//
#define RTM_BASIC_ROUTE_INFO_SIZE                                        \
    FIELD_OFFSET(RTM_ROUTE_INFO, NextHopsList.NumNextHops)

#define RTM_SIZE_OF_ROUTE_INFO(NumHops)                                  \
    (RTM_BASIC_ROUTE_INFO_SIZE + (NumHops) * sizeof(RTM_NEXTHOP_HANDLE))

//
// State of the Route
//
#define RTM_ROUTE_STATE_CREATED        0
#define RTM_ROUTE_STATE_DELETING       1
#define RTM_ROUTE_STATE_DELETED        2


//
// Route Information Flags
//

// Forwarding Flags

#define RTM_ROUTE_FLAGS_MARTIAN        0x0001
#define RTM_ROUTE_FLAGS_BLACKHOLE      0x0002
#define RTM_ROUTE_FLAGS_DISCARD        0x0004
#define RTM_ROUTE_FLAGS_INACTIVE       0x0008

// Unicast Flags

#define RTM_ROUTE_FLAGS_LOCAL          0x0010
#define RTM_ROUTE_FLAGS_REMOTE         0x0020
#define RTM_ROUTE_FLAGS_MYSELF         0x0040

#define RTM_ROUTE_FLAGS_LOOPBACK       0x0080

// Bcast, Mcast Flags

#define RTM_ROUTE_FLAGS_MCAST          0x0100
#define RTM_ROUTE_FLAGS_LOCAL_MCAST    0x0200

#define RTM_ROUTE_FLAGS_LIMITED_BC     0x0400

#define RTM_ROUTE_FLAGS_ZEROS_NETBC    0x1000
#define RTM_ROUTE_FLAGS_ZEROS_SUBNETBC 0x2000
#define RTM_ROUTE_FLAGS_ONES_NETBC     0x4000
#define RTM_ROUTE_FLAGS_ONES_SUBNETBC  0x8000

// Grouping of Flags

#define RTM_ROUTE_FLAGS_FORWARDING        \
        (RTM_ROUTE_FLAGS_MARTIAN        | \
         RTM_ROUTE_FLAGS_BLACKHOLE      | \
         RTM_ROUTE_FLAGS_DISCARD        | \
         RTM_ROUTE_FLAGS_INACTIVE)

#define RTM_ROUTE_FLAGS_ANY_UNICAST       \
        (RTM_ROUTE_FLAGS_LOCAL          | \
         RTM_ROUTE_FLAGS_REMOTE         | \
         RTM_ROUTE_FLAGS_MYSELF)

#define RTM_ROUTE_FLAGS_ANY_MCAST         \
        (RTM_ROUTE_FLAGS_MCAST          | \
         RTM_ROUTE_FLAGS_LOCAL_MCAST)

#define RTM_ROUTE_FLAGS_SUBNET_BCAST      \
        (RTM_ROUTE_FLAGS_ONES_SUBNET_BC | \
         RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)

#define RTM_ROUTE_FLAGS_NET_BCAST         \
        (RTM_ROUTE_FLAGS_ONES_NETBC     | \
         RTM_ROUTE_FLAGS_ZEROS_NETBC)

#define RTM_ROUTE_FLAGS_ANY_BCAST         \
        (RTM_ROUTE_FLAGS_LIMITED_BC     | \
         RTM_ROUTE_FLAGS_ONES_NETBC     | \
         RTM_ROUTE_FLAGS_ONES_SUBNET_BC | \
         RTM_ROUTE_FLAGS_ZEROS_NETBC    | \
         RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)

//
// Structure used to exchange next-hop
// information with RTM entities
//
typedef struct _RTM_NEXTHOP_INFO
{
    //
    // Information that the owner can
    // directly access for read only
    //

    RTM_NET_ADDRESS     NextHopAddress;   // Net Address for this next hop

    RTM_ENTITY_HANDLE   NextHopOwner;     // Entity that owns this next hop

    ULONG               InterfaceIndex;   // Outgoing interface index
                                          // '0' for a remote nexthop

    USHORT              State;            // See RTM_NEXTHOP_STATE_* below

    //
    // Information that the owner can
    // directly access for read/write
    //

    USHORT              Flags;            // See RTM_NEXTHOP_FLAGS_* below

    PVOID               EntitySpecificInfo; // Owning Entity's private info

    RTM_DEST_HANDLE     RemoteNextHop;    // Handle to dest with nexthop addr
                                          // [ Not used for a local nexthop ]
}
RTM_NEXTHOP_INFO, *PRTM_NEXTHOP_INFO;

//
// Next Hop State
//

#define RTM_NEXTHOP_STATE_CREATED      0
#define RTM_NEXTHOP_STATE_DELETED      1

//
// Next Hop Flags
//

#define RTM_NEXTHOP_FLAGS_REMOTE  0x0001
#define RTM_NEXTHOP_FLAGS_DOWN    0x0002


//
// Entity Registration Related Defns
//

//
// Info that uniquely identifies an entity
//

// Disable warnings for unnamed structs
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable : 4201)

typedef struct _RTM_ENTITY_ID
{
    union
    {
        struct
        {
            ULONG    EntityProtocolId;  // Entity's Protocol ID (RIP,OSPF...)
            ULONG    EntityInstanceId;  // Entity's Protocol Instance
        };

        ULONGLONG    EntityId;          // Protocol ID and Instance
    };
}
RTM_ENTITY_ID, *PRTM_ENTITY_ID;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default : 4201)
#endif

//
// Structure used to exchange entity
// information with RTM entities
//
typedef struct _RTM_ENTITY_INFO
{
    USHORT         RtmInstanceId;       // RTM Instance that it registered with
    USHORT         AddressFamily;       // Entity's Address Family

    RTM_ENTITY_ID  EntityId;            // Uniquely identifies an entity
}
RTM_ENTITY_INFO, *PRTM_ENTITY_INFO;


//
// Event in the RTM involving an entity
//
typedef enum _RTM_EVENT_TYPE
{
    RTM_ENTITY_REGISTERED,
    RTM_ENTITY_DEREGISTERED,
    RTM_ROUTE_EXPIRED,
    RTM_CHANGE_NOTIFICATION
}
RTM_EVENT_TYPE, *PRTM_EVENT_TYPE;

//
// Entity event inform callback
//
// Used to inform entities of
// new entities registering,
// or entities deregistering
//
typedef
DWORD
(WINAPI * _EVENT_CALLBACK) (
     IN  RTM_ENTITY_HANDLE    RtmRegHandle,  // Callee's Registration Handle
     IN  RTM_EVENT_TYPE       EventType,
     IN  PVOID                Context1,
     IN  PVOID                Context2
     );

typedef _EVENT_CALLBACK RTM_EVENT_CALLBACK,
                      *PRTM_EVENT_CALLBACK;


//
// Methods exported by a registered entity
//

#define METHOD_TYPE_ALL_METHODS      0xFFFFFFFF

#define METHOD_RIP2_NEIGHBOUR_ADDR   0x00000001
#define METHOD_RIP2_OUTBOUND_INTF    0x00000002
#define METHOD_RIP2_ROUTE_TAG        0x00000004
#define METHOD_RIP2_ROUTE_TIMESTAMP  0x00000008

#define METHOD_OSPF_ROUTE_TYPE       0x00000001
#define METHOD_OSPF_ROUTE_METRIC     0x00000002
#define METHOD_OSPF_LSDB_TYPE        0x00000004
#define METHOD_OSPF_ROUTE_TAG        0x00000008
#define METHOD_OSPF_ROUTE_AREA       0x00000010
#define METHOD_OSPF_FWD_ADDRESS      0x00000020

#define METHOD_BGP4_AS_PATH          0x00000001
#define METHOD_BGP4_PEER_ID          0x00000002
#define METHOD_BGP4_PA_ORIGIN        0x00000004
#define METHOD_BGP4_NEXTHOP_ATTR     0x00000008

typedef DWORD      RTM_ENTITY_METHOD_TYPE,
                 *PRTM_ENTITY_METHOD_TYPE;


//
// Generic Input Structure for entity methods
//
typedef struct _RTM_ENTITY_METHOD_INPUT
{
    RTM_ENTITY_METHOD_TYPE MethodType;    // Type identifying the method
    UINT                   InputSize;     // Input Data Size
    UCHAR                  InputData[1];  // Input Data Buffer
}
RTM_ENTITY_METHOD_INPUT, *PRTM_ENTITY_METHOD_INPUT;

//
// Generic Output Structure for entity methods
//
typedef struct _RTM_ENTITY_METHOD_OUTPUT
{
    RTM_ENTITY_METHOD_TYPE MethodType;    // Type identifying the method
    DWORD                  MethodStatus;  // Return Status of method
    UINT                   OutputSize;    // Output Data Size
    UCHAR                  OutputData[1]; // Output Data Buffer
}
RTM_ENTITY_METHOD_OUTPUT, *PRTM_ENTITY_METHOD_OUTPUT;

//
// Common prototype for entity methods
//
typedef
VOID
(WINAPI * _ENTITY_METHOD) (
    IN  RTM_ENTITY_HANDLE         CallerHandle,
    IN  RTM_ENTITY_HANDLE         CalleeHandle,
    IN  RTM_ENTITY_METHOD_INPUT  *Input,
    OUT RTM_ENTITY_METHOD_OUTPUT *Output
    );

typedef _ENTITY_METHOD RTM_ENTITY_EXPORT_METHOD,
                     *PRTM_ENTITY_EXPORT_METHOD;

//
// Set of exported entity methods
//
typedef struct _RTM_ENTITY_EXPORT_METHODS
{
    UINT                     NumMethods;
    RTM_ENTITY_EXPORT_METHOD Methods[1];
}
RTM_ENTITY_EXPORT_METHODS, *PRTM_ENTITY_EXPORT_METHODS;

//
// To toggle method blocking on dests, routes and nexthops
//
#define RTM_RESUME_METHODS             0
#define RTM_BLOCK_METHODS              1


//
// I/O Flags when route is added/updated
//
typedef DWORD    RTM_ROUTE_CHANGE_FLAGS,
               *PRTM_ROUTE_CHANGE_FLAGS;

#define RTM_ROUTE_CHANGE_FIRST      0x01
#define RTM_ROUTE_CHANGE_NEW        0x02
#define RTM_ROUTE_CHANGE_BEST 0x00010000

//
// Output flags when nexthop is added
//
typedef DWORD  RTM_NEXTHOP_CHANGE_FLAGS,
             *PRTM_NEXTHOP_CHANGE_FLAGS;

#define RTM_NEXTHOP_CHANGE_NEW      0x01


//
// Definitions relating to RIB queries
//

//
// Flags used to matching routes in RIB
//
typedef DWORD           RTM_MATCH_FLAGS,
                      *PRTM_MATCH_FLAGS;

#define RTM_MATCH_NONE        0x00000000
#define RTM_MATCH_OWNER       0x00000001
#define RTM_MATCH_NEIGHBOUR   0x00000002
#define RTM_MATCH_PREF        0x00000004
#define RTM_MATCH_NEXTHOP     0x00000008
#define RTM_MATCH_INTERFACE   0x00000010
#define RTM_MATCH_FULL        0x0000FFFF

//
// Flags to specify route being queried
//
#define RTM_BEST_PROTOCOL    (ULONG)   0
#define RTM_THIS_PROTOCOL    (ULONG)  ~0


//
// Definitions relating to enumerations
//

typedef DWORD            RTM_ENUM_FLAGS,
                       *PRTM_ENUM_FLAGS;

// Enumeration Flags

#define RTM_ENUM_START        0x00000000
#define RTM_ENUM_NEXT         0x00000001
#define RTM_ENUM_RANGE        0x00000002

#define RTM_ENUM_ALL_DESTS    0x00000000
#define RTM_ENUM_OWN_DESTS    0x01000000

#define RTM_ENUM_ALL_ROUTES   0x00000000
#define RTM_ENUM_OWN_ROUTES   0x00010000


//
// Definitions relating to notifications
//

// Notify Flags is composed as follows -
// (Change Types | Dests) interested in.

typedef DWORD          RTM_NOTIFY_FLAGS,
                     *PRTM_NOTIFY_FLAGS;

// Change Types to notify about

#define RTM_NUM_CHANGE_TYPES            3

#define RTM_CHANGE_TYPE_ALL        0x0001
#define RTM_CHANGE_TYPE_BEST       0x0002
#define RTM_CHANGE_TYPE_FORWARDING 0x0004

// Dests whose changes to notify

#define RTM_NOTIFY_ONLY_MARKED_DESTS 0x00010000


//
// Registration API Prototypes
//

DWORD
WINAPI
RtmRegisterEntity (
    IN      PRTM_ENTITY_INFO                RtmEntityInfo,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    IN      BOOL                            ReserveOpaquePointer,
    OUT     PRTM_REGN_PROFILE               RtmRegProfile,
    OUT     PRTM_ENTITY_HANDLE              RtmRegHandle
    );

DWORD
WINAPI
RtmDeregisterEntity (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle
    );

DWORD
WINAPI
RtmGetRegisteredEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_HANDLE              EntityHandles,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    );

DWORD
WINAPI
RtmReleaseEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumEntities,
    IN      PRTM_ENTITY_HANDLE              EntityHandles
    );

//
// Opaque Ptr APIs
//

DWORD
WINAPI
RtmLockDestination(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockDest
    );

DWORD
WINAPI
RtmGetOpaqueInformationPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PVOID                          *OpaqueInfoPointer
    );

//
// Export Method API Prototypes
//

DWORD
WINAPI
RtmGetEntityMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN OUT  PUINT                           NumMethods,
    OUT     PRTM_ENTITY_EXPORT_METHOD       ExptMethods
    );

DWORD
WINAPI
RtmInvokeMethod (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN      PRTM_ENTITY_METHOD_INPUT        Input,
    IN OUT  PUINT                           OutputSize,
    OUT     PRTM_ENTITY_METHOD_OUTPUT       Output
    );

DWORD
WINAPI
RtmBlockMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      HANDLE                          TargetHandle OPTIONAL,
    IN      UCHAR                           TargetType   OPTIONAL,
    IN      DWORD                           BlockingFlag
    );

//
// Handle to Info Structures
//

DWORD
WINAPI
RtmGetEntityInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    OUT     PRTM_ENTITY_INFO                EntityInfo
    );

DWORD
WINAPI
RtmGetDestInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetRouteInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                 RouteInfo   OPTIONAL,
    OUT     PRTM_NET_ADDRESS                DestAddress OPTIONAL
    );

DWORD
WINAPI
RtmGetNextHopInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO               NextHopInfo
    );

DWORD
WINAPI
RtmReleaseEntityInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ENTITY_INFO               EntityInfo
    );

DWORD
WINAPI
RtmReleaseDestInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_DEST_INFO                 DestInfo
    );

DWORD
WINAPI
RtmReleaseRouteInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ROUTE_INFO                RouteInfo
    );

DWORD
WINAPI
RtmReleaseNextHopInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO              NextHopInfo
    );


//
// RIB Insert/Delete API Prototypes
//

DWORD
WINAPI
RtmAddRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PRTM_ROUTE_HANDLE               RouteHandle     OPTIONAL,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                NotifyType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    IN OUT  PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

DWORD
WINAPI
RtmDeleteRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

DWORD
WINAPI
RtmHoldDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      ULONG                           HoldTime
    );

DWORD
WINAPI
RtmGetRoutePointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                *RoutePointer
    );

DWORD
WINAPI
RtmLockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockRoute,
    OUT     PRTM_ROUTE_INFO                *RoutePointer OPTIONAL
    );

DWORD
WINAPI
RtmUpdateAndUnlockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                NotifyType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

//
// RIB Query API Prototypes
//

DWORD
WINAPI
RtmGetExactMatchDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetMostSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetLessSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetExactMatchRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN OUT  PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           InterfaceIndex,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_ROUTE_HANDLE               RouteHandle
    );

DWORD
WINAPI
RtmIsBestRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_VIEW_SET                   BestInViews
    );

//
// NextHop Object API Prototypes
//

DWORD
WINAPI
RtmAddNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN OUT  PRTM_NEXTHOP_HANDLE             NextHopHandle OPTIONAL,
    OUT     PRTM_NEXTHOP_CHANGE_FLAGS       ChangeFlags
    );

DWORD
WINAPI
RtmFindNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    );

DWORD
WINAPI
RtmDeleteNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle  OPTIONAL,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo
    );

DWORD
WINAPI
RtmGetNextHopPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer
    );

DWORD
WINAPI
RtmLockNextHop(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockNextHop,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    );


//
// Enumeration API Prototypes
//

DWORD
WINAPI
RtmCreateDestEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    IN      ULONG                           ProtocolId,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  DestInfos
    );

DWORD
WINAPI
RtmReleaseDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  DestInfos
    );

DWORD
WINAPI
RtmCreateRouteEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle        OPTIONAL,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                StartDest         OPTIONAL,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRoute     OPTIONAL,
    IN      ULONG                           CriteriaInterface OPTIONAL,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmReleaseRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmCreateNextHopEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumNextHops,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandles
    );

DWORD
WINAPI
RtmReleaseNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumNextHops,
    IN      PRTM_NEXTHOP_HANDLE             NextHopHandles
    );

DWORD
WINAPI
RtmDeleteEnumHandle (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle
    );


//
// Change Notification APIs
//

DWORD
WINAPI
RtmRegisterForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_NOTIFY_FLAGS                NotifyFlags,
    IN      PVOID                           NotifyContext,
    OUT     PRTM_NOTIFY_HANDLE              NotifyHandle
    );

DWORD
WINAPI
RtmGetChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  ChangedDests
    );

DWORD
WINAPI
RtmReleaseChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  ChangedDests
    );

DWORD
WINAPI
RtmIgnoreChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_HANDLE                ChangedDests
    );

DWORD
WINAPI
RtmGetChangeStatus (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           ChangeStatus
    );

DWORD
WINAPI
RtmMarkDestForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            MarkDest
    );

DWORD
WINAPI
RtmIsMarkedForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           DestMarked
    );

DWORD
WINAPI
RtmDeregisterFromChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle
    );


//
// Entity Specific List APIs
//

DWORD
WINAPI
RtmCreateRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    OUT     PRTM_ROUTE_LIST_HANDLE          RouteListHandle
    );

DWORD
WINAPI
RtmInsertInRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmCreateRouteListEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetListEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmDeleteRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle
    );

//
// Handle Management APIs
//

DWORD
WINAPI
RtmReferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    );

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_RTMv2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scarddat_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Nov 25 10:32:38 1997
 */
/* Compiler settings for scarddat.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IByteBuffer = {0xE126F8FE,0xA7AF,0x11D0,{0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9}};


const IID IID_ISCardTypeConv = {0x53B6AA63,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID IID_ISCardCmd = {0xD5778AE3,0x43DE,0x11D0,{0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID LIBID_SCardDatLib = {0xD5778AE1,0x43DE,0x11D0,{0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_ByteBuffer = {0xE126F8FF,0xA7AF,0x11D0,{0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9}};


const CLSID CLSID_CSCardTypeConv = {0x53B6AA67,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_CSCardCmd = {0xD5778AE7,0x43DE,0x11D0,{0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtm.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rtm.h

Abstract:
	Interface for Routing Table Manager DLL

--*/

#ifndef __ROUTING_RTM_H__
#define __ROUTING_RTM_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif

// Currently supported protocol families
#define RTM_PROTOCOL_FAMILY_IPX			0
#define RTM_PROTOCOL_FAMILY_IP			1

// Error messages specific to Routing Table Manager
#define ERROR_MORE_MESSAGES				ERROR_MORE_DATA
#define ERROR_CLIENT_ALREADY_EXISTS		ERROR_ALREADY_EXISTS
#define ERROR_NO_MESSAGES				ERROR_NO_MORE_ITEMS

#define ERROR_NO_MORE_ROUTES			ERROR_NO_MORE_ITEMS
#define ERROR_NO_ROUTES					ERROR_NO_MORE_ITEMS
#define ERROR_NO_SUCH_ROUTE				ERROR_NO_MORE_ITEMS

// Protocol family dependent network number structures
typedef struct _IPX_NETWORK {
	DWORD	N_NetNumber;
	} IPX_NETWORK, *PIPX_NETWORK;


typedef struct _IP_NETWORK {
	DWORD	N_NetNumber;
	DWORD	N_NetMask;
	} IP_NETWORK, *PIP_NETWORK;



// Protocol family dependent next hop router address structures
typedef struct _IPX_NEXT_HOP_ADDRESS {
	BYTE			NHA_Mac[6];
	} IPX_NEXT_HOP_ADDRESS, *PIPX_NEXT_HOP_ADDRESS;

typedef IP_NETWORK IP_NEXT_HOP_ADDRESS, *PIP_NEXT_HOP_ADDRESS;


// Protocol family dependent specific data structures
typedef struct _IPX_SPECIFIC_DATA {
	DWORD		FSD_Flags;	// should be set to 0 if no flags are defined
	USHORT		FSD_TickCount;	// ticks to destination network
	USHORT		FSD_HopCount;	// hops to destination network
	} IPX_SPECIFIC_DATA, *PIPX_SPECIFIC_DATA;

// The following flags are defined for the IPX family dependent Flags field

#define   IPX_GLOBAL_CLIENT_WAN_ROUTE	0x00000001


typedef	struct _IP_SPECIFIC_DATA
{
    DWORD       FSD_Type;               // One of : other,invalid,local,remote (1-4)
    DWORD       FSD_Policy;             // See RFC 1354
    DWORD       FSD_NextHopAS;          // Autonomous System Number of Next Hop
    DWORD       FSD_Priority;           // For comparing Inter Protocol Metrics
    DWORD       FSD_Metric;             // For comparing Intra Protocol Metrics
	DWORD		FSD_Metric1;		    // Protocol specific metrics for MIB II
	DWORD		FSD_Metric2;		    // conformance. MIB II agents will not
	DWORD		FSD_Metric3;		    // display FSD_Metric, they will only
	DWORD		FSD_Metric4;		    // display Metrics1-5, so if you want your
	DWORD		FSD_Metric5;		    // metric displayed, put it in one of these
                                        // fields ALSO (It has to be in the
                                        // FSD_Metric field always). It is up to the
                                        // implementor to keep the fields consistent
    DWORD       FSD_Flags;              // Flags defined below
} IP_SPECIFIC_DATA, *PIP_SPECIFIC_DATA;

//
// All routing protocols MUST clear out the FSD_Flags field.
// If RTM notifies a protocol of a route and that route is marked
// invalid, the protocols MUST disregard this route. A protocol
// may mark a route as invalid, if it does not want the route to
// be indicated to other protocols or set to the stack. e.g. RIPv2
// marks summarized routes as INVALID and uses the RTM purely as
// a store for such routes. These routes are not considered when
// comparing metrics etc to decide the "best" route
//

#define IP_VALID_ROUTE      0x00000001

#define ClearRouteFlags(pRoute)         \
    ((pRoute)->RR_FamilySpecificData.FSD_Flags = 0x00000000)


#define IsRouteValid(pRoute)            \
    ((pRoute)->RR_FamilySpecificData.FSD_Flags & IP_VALID_ROUTE)



#define SetRouteValid(pRoute)          \
    ((pRoute)->RR_FamilySpecificData.FSD_Flags |= IP_VALID_ROUTE)

#define ClearRouteValid(pRoute)        \
    ((pRoute)->RR_FamilySpecificData.FSD_Flags &= ~IP_VALID_ROUTE)




#define IsRouteNonUnicast(pRoute)      \
    (((DWORD)((pRoute)->RR_Network.N_NetNumber & 0x000000FF)) >= ((DWORD)0x000000E0))

#define IsRouteLoopback(pRoute)        \
    ((((pRoute)->RR_Network.N_NetNumber & 0x000000FF) == 0x0000007F) ||     \
        ((pRoute)->RR_NextHopAddress.N_NetNumber == 0x0100007F))


// Protocol dependent specific data structure
typedef struct _PROTOCOL_SPECIFIC_DATA {
	DWORD		PSD_Data[4];
	} PROTOCOL_SPECIFIC_DATA, *PPROTOCOL_SPECIFIC_DATA;

	


#define DWORD_ALIGN(type,field)	\
	union {						\
		type	field;			\
		DWORD	field##Align;	\
		}

// Standard header associated with all types of routes
#define ROUTE_HEADER		 						\
DWORD_ALIGN (										\
	FILETIME,					RR_TimeStamp);		\
	DWORD						RR_RoutingProtocol;	\
	DWORD						RR_InterfaceID;		\
DWORD_ALIGN (										\
	PROTOCOL_SPECIFIC_DATA,		RR_ProtocolSpecificData)

	// Ensure dword aligment of all fields

// Protocol family dependent route entries
// (intended for use by protocol handlers to pass paramerters
// to and from RTM routines)
typedef struct _RTM_IPX_ROUTE {
	ROUTE_HEADER;
DWORD_ALIGN (
	IPX_NETWORK,				RR_Network);
DWORD_ALIGN (
	IPX_NEXT_HOP_ADDRESS,	RR_NextHopAddress);
DWORD_ALIGN (
	IPX_SPECIFIC_DATA,		RR_FamilySpecificData);
	} RTM_IPX_ROUTE, *PRTM_IPX_ROUTE;

typedef struct _RTM_IP_ROUTE {
	ROUTE_HEADER;
DWORD_ALIGN (
	IP_NETWORK,				RR_Network);
DWORD_ALIGN (
	IP_NEXT_HOP_ADDRESS,	RR_NextHopAddress);
DWORD_ALIGN (
	IP_SPECIFIC_DATA,		RR_FamilySpecificData);
	} RTM_IP_ROUTE, *PRTM_IP_ROUTE;



// RTM route change message flags
	// Flags to test the presence of route change information
	// in the buffers filled by RTM routines
#define RTM_CURRENT_BEST_ROUTE			0x00000001
#define RTM_PREVIOUS_BEST_ROUTE			0x00000002

	// Flags that convey what acutally happened
#define RTM_NO_CHANGE		0
#define RTM_ROUTE_ADDED		RTM_CURRENT_BEST_ROUTE
#define RTM_ROUTE_DELETED	RTM_PREVIOUS_BEST_ROUTE
#define RTM_ROUTE_CHANGED	(RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE)

// Enumeration flags limit that enumerations of routes in the table
// to only entries with the specified field(s)
#define RTM_ONLY_THIS_NETWORK           0x00000001
#define RTM_ONLY_THIS_INTERFACE    		0x00000002
#define RTM_ONLY_THIS_PROTOCOL	    	0x00000004
#define RTM_ONLY_BEST_ROUTES			0x00000008

#define RTM_PROTOCOL_SINGLE_ROUTE		0x00000001

/*++
*******************************************************************

	R t m R e g i s t e r C l i e n t

Routine Description:
	Registers client as a handler of specified protocol.
	Establishes route change notification mechanism for the client

Arguments:
	ProtocolFamily - protocol family of the routing protocol to register
	RoutingProtocol - which routing protocol is handled by the client
	ChangeEvent - this event will be signalled when best route to any
					network in the table changes
	Flags - flags that enable special features applied to routes maintained
			by the protocol:
				RTM_PROTOCOL_SINGLE_ROUTE - RTM will only keep
					one route per destination network for the protocol
Return Value:
	Handle to be used to identify the client in calls made to Rtm
	NULL - operation failed, call GetLastError() to get reason of
	failure:
		ERROR_INVALID_PARAMETER - specified protocol family is not supported
		ERROR_CLIENT_ALREADY_EXISTS - another client already registered
								to handle specified protocol
		ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the opertaion,
							try again later
		ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client
							 control block

*******************************************************************
--*/
HANDLE WINAPI
RtmRegisterClient (
	IN DWORD	  	ProtocolFamily,
    IN DWORD      	RoutingProtocol,
	IN HANDLE		ChangeEvent OPTIONAL,
	IN DWORD		Flags
	);


/*++
*******************************************************************

	R t m D e r e g i s t e r C l i e n t

Routine Description:
	Deregister client and frees associated resources (including all
	routes added by the client).

Arguments:
	ClientHandle - handle that identifies the client to deregister from RTM
Return Value:
	NO_ERROR - client was deregisterd and resources were disposed OK.
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to complete the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmDeregisterClient (
	IN HANDLE		ClientHandle
	);


/*++
*******************************************************************

	R t m D e q u e u e R o u t e C h a n g e M e s s a g e

Routine Description:
	Dequeues and returns first route change message from the queue
	associated with the client

Arguments:
	ClientHandle - handle that identifies the client for which the opertation
					is performed
	Flags - identifies what kind of change the message is about and what
			information was palced into the provided buffers:
		RTM_ROUTE_ADDED - first route was added for a destination network,
							CurBestRoute is filled with added route info
		RTM_ROUTE_DELETED - the only route available for a destination
							network was deleted, PrevBestRoute is filled
							with deleted route info
		RTM_ROUTE_CHANGED - there was a change in any of the following
							parameters of the BEST route to a destination
							network:
								RoutingProtocol,
								InterfaceID,
								Metric,
								NextHopAddress,
								FamilySpecificData.
							PrevBestRoute contains the route info as it was
							before the change, CurBestRoute contains current
							best route info.
				Note that the route change message can be generated
				both as result of protocol adding/deleting the route
				that becomes/was the best and changing best route parameters
				such that route becomes/no longer is the best route.
	CurBestRoute - buffer to receive current best route info (if any)
	PrevBestRoute - buffer to receive previous best route info (if any)
Return Value:
	NO_ERROR - this was the last (or only) message in the client's
	 			queue (event is reset)
	ERROR_MORE_MESSAGES - there are more messages awaiting client,
				this call should be made again as soon as possible
				to let RTM free resources associated with unprocessed
				messages
	ERROR_NO_MESSAGES - there are no messages in the clients queue,
				this was an unsolicited call (event is reset)
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmDequeueRouteChangeMessage (
	IN	HANDLE		ClientHandle,
	OUT	DWORD		*Flags,
	OUT PVOID		CurBestRoute	OPTIONAL,
	OUT	PVOID		PrevBestRoute	OPTIONAL
	);



/*++
*******************************************************************

	R t m A d d R o u t e

Routine Description:
	Adds or updates existing route entry and generates route change
	message if best route to a destination network has changed as the
	result of this operation.
	Note that route change message is not sent to the client that
	makes this change, but rather relevant information is returned
	by this routine directly.

Arguments:
	ClientHandle - handle that identifies the client for which the opertation
					is performed, it also supplies RoutingProtocol field
					of the new/updated route
	Route - route to be added/updated.
			The following fields of protocol family dependent
			RTM_??_ROUTE structure are used to construct/update
			route entry:
		RR_Network:			destination network
		RR_InterfaceID: 	id of interface through which route was received
		RR_NextHopAddress:	address of next hop router
		RR_FamilySpecificData: data specific to protocol's family
		RR_ProtocolSpecificData: data specific to protocol which supplies the
							route (subject to size limitation defined by
							PROTOCOL_SPECIFIC_DATA structure above)
		RR_TimeStamp:		current time, which is actually read from system
							timer (need not be supplied)
		Note that combination of
			RoutingProtocol,
			Network,
			InterfaceID, and
			NextHopAddress
								uniquely identifies route entry in the table.
		New entry is created if one of these fields does not match those of
		an existing entry, otherwise existing entry is changed (see also
		ReplaceEntry flag below).

		Regardless of whether new entry is created or old one is updated,
		this operation will generate a route change message if affected
		route becomes/is/no longer is the best route to a destination network
		and at least one of the following parameters in the best route is
		changed as the result of this operation:
								RoutingProtocol,
								InterfaceID,
								NextHopAddress,
								FamilySpecificData.
	TimeToLive -  how long route should be kept in the table in seconds.
				Pass INFINITE if route is to be kept until deleted explicitly
		Note the current limit for TimeToLive is 2147483 sec (24+ days).
	Flags - returns what change message (if any) will be generated by the
			RTM as the result of this addition/update and identifies what
			information was palced into the provided buffers:
		RTM_NO_CHANGE - this was an update that either did not change any of
						the significant route parameters (described above)
						or the route entry affected is not the best
						to the destination network
		RTM_ROUTE_ADDED - the route added is the first known route for a
							destination network,
							CurBestRoute is filled with added route info
		RTM_ROUTE_CHANGED - there was a change in any of the significant
							parameters of the BEST route to a destination
							network as the result if this operation.
							PrevBestRoute contains the route info as it was
							before the change, CurBestRoute contains current
							best route info.
				Note the the CurBestRoute does not neccessarily the same
				as added route, because if update causes route metric
				to change, another route entry may become the best for
				a given destination and its info will be returned in
				CurBestRoute buffer.  PrevBestRoute buffer in the latter
				case will contain route entry as it was before this operation
				was performed.
	CurBestRoute - buffer to receive current best route info (if any)
	PrevBestRoute - buffer to receive previous best route info (if any)
Return Value:
	NO_ERROR 				- route was added/updated OK
	ERROR_INVALID_PARAMETER - route contains invalid parameter
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NOT_ENOUGH_MEMORY - route could not be adeed because of memory
								allocation problem
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmAddRoute (
	IN HANDLE	    ClientHandle,
	IN PVOID		Route,
	IN DWORD		TimeToLive,
	OUT DWORD		*Flags,
    OUT PVOID		CurBestRoute OPTIONAL,
    OUT PVOID		PrevBestRoute OPTIONAL
    );


/*++
*******************************************************************

	R t m D e l e t e R o u t e

Routine Description:
	Deletes existing route entry and generates route change
	message if best route to a destination network has changed as the
	result of this operation.
	Note that route change message is not sent to the client that
	makes this change, but rather relevant information is returned
	by this routine directly.

Arguments:
	ClientHandle - handle that identifies the client for which the opertation
					is performed, it also supplies RoutingProtocol field
					of the route to be deleted
	Route - route to be deleted.
			The following fields of protocol family dependent
			RTM_??_ROUTE structure are used to identify
			route entry to be deleted:
		RR_Network:			destination network
		RR_InterfaceID: 	id of interface through which route was received
		RR_NextHopAddress:	address of next hop router

		If the deleted entry represented the best route to a destination
		network, this operation will generate route change message
	Flags - returns what change message (if any) will be generated by the
			RTM as the result of this deletion and identifies what
			information was palced into the provided buffer:
		RTM_NO_CHANGE - the deleted route did not affect best route to
						any destination network (there is another entry that
						represents route to the same destination nework and
						it has better metric)
		RTM_ROUTE_DELETED - the deleted route was the only route avaliable
							for the destination network
		RTM_ROUTE_CHANGED - after this route was deleted another route
						became the best to the destination network,
						CurBestRoute will be filled with that route info
	CurBestRoute - buffer to receive current best route info (if any)
Return Value:
	NO_ERROR 				- route was deleted OK
	ERROR_INVALID_PARAMETER - route contains invalid parameter
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NO_SUCH_ROUTE - there is no entry in the table that
						has specified parameters
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmDeleteRoute (
	IN HANDLE	    ClientHandle,
	IN PVOID		Route,
	OUT	DWORD		*Flags,
    OUT PVOID		CurBestRoute OPTIONAL
	);



/*++
*******************************************************************

	R t m I s R o u t e

Routine Description:
	Checks if route exists to specified network and returns best
	route info

Arguments:
	ProtocolFamily - identifies protocol family of route of interest
	Network - contains protocol family dependent network number data
			(as defined by ??_NETWORK structures above)
	BestRoute - buffer to receive current best route info (if any)
Return Value:
	TRUE - route to network of interest exists
	FALSE - not route exist or operation failed, call GetLastError()
	to obtain reason of failure:
		NO_ERROR 				- operation succeded but not route exists
		ERROR_INVALID_PARAMETER - input parameter(s) is invalid (unsupported
									protocol family)
		ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
BOOL WINAPI
RtmIsRoute (
	IN 	DWORD		ProtocolFamily,
	IN 	PVOID   	Network,
    OUT	PVOID 		BestRoute OPTIONAL
	);

	
/*++
*******************************************************************

	R t m G e t N e t w o r k C o u n t

Routine Description:
	Returns number of networks that RTM has routes to.

Arguments:
	ProtocolFamily - identifies protocol family of interest
Return Value:
	Number of known networks
	0 if no routes are availabel in the table or operation failed,
	call GetLastError () to get reason of failure:
		NO_ERROR - operation succeded but no routes available
		ERROR_INVALID_PARAMETER - input parameter is invalid (unsupported
									protocol family)

*******************************************************************
--*/
ULONG WINAPI
RtmGetNetworkCount (
	IN	DWORD		ProtocolFamily
	);

/*++
*******************************************************************

	R t m G e t R o u t e A g e

Routine Description:
	Returns route age (time since it was created or updated) in seconds
	Route structure must have been recently filled by RTM for this to
	return valid results (route age is actually computed from
	RR_TimeStamp field)

Arguments:
	Route - protocol family dependent route data (RTM_??_ROUTE data
			structure) that was obtained from RTM (returned by
			its routines)
Return Value:
	Route age in seconds
	INFINITE - if content of route is invalid (GetLastError () returns
		ERROR_INVALID_PARAMETER)

*******************************************************************
--*/
ULONG WINAPI
RtmGetRouteAge (
	IN PVOID		Route
	);





/*++
*******************************************************************

	R t m C r e a t e E n u m e r a t i o n H a n d l e

Routine Description:
	Creates a handle that will allow the caller to use fast and change
	tolerant enumeration API to scan through all routes or a subset of them
	known to the RTM. Note that scans performed by this API do not return
	routes in any particular order.

Arguments:
	ProtocolFamily - identifies protocol family of interest
	EnumerationFlags - limit routes returned by enumeration API to a subset
						members of which have same values in the fields
						specified by the flags as in CriteriaRoute
						(RTM_ONLY_BEST_ROUTES does not require a criterion)
	CriteriaRoute - protocol family dependent structure (RTM_??_ROUTE) with
					set values in fields that correspond to EnumerationFlags
Return Value:
	Handle that can be used with enumeration API below
	NULL no routes exists with specified criteria or operation failed,
			call GetLastError () to get reason of failure:
		ERROR_NO_ROUTES - no routes exist with specified criteria
		ERROR_INVALID_PARAMETER - input parameter(s) is invalid (unsupported
					protocol family, invalid enumeration flag, etc)
		ERROR_NOT_ENOUGH_MEMORY - handle could not be created because of memory
								allocation problem
		ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
HANDLE WINAPI
RtmCreateEnumerationHandle (
	IN	DWORD		ProtocolFamily,
	IN	DWORD		EnumerationFlags,
	IN	PVOID		CriteriaRoute
	);


/*++
*******************************************************************

	R t m E n u m e r a t e G e t N e x t R o u t e

Routine Description:
	Returns next route entry in enumeration started by
	RtmCreateEnumerationHandle.

Arguments:
	EnumerationHandle - handle that identifies enumeration
	Route - buffer (RTM_??_ROUTE structure) that receives next
			route in enumeration
Return Value:
	NO_ERROR - next availbale route was placed in the buffer
	ERROR_NO_MORE_ROUTES - no more routes exist with soecified criteria
	ERROR_INVALID_HANDLE - enumeration handle is not a valid RTM handle
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmEnumerateGetNextRoute (
	IN  HANDLE    	EnumerationHandle,
	OUT PVOID		Route
	);

/*++
*******************************************************************

	R t m C l o s e E n u m e r a t i o n H a n d l e

Routine Description:
	Terminates enumerationand frees associated resources

Arguments:
	EnumerationHandle - handle that identifies enumeration
Return Value:
	NO_ERROR - enumeration was termineted ok
	ERROR_INVALID_HANDLE - enumeration handle is not a valid RTM handle
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmCloseEnumerationHandle (
	IN HANDLE		EnumerationHandle
	);


/*++
*******************************************************************

	R t m B l o c k D e l e t e R o u t e s

Routine Description:
	Deletes all routes in subset specified by enumeration flags and
	corresponding criteria.  This operation can only be performed by
	the registered client and applies only to routes added by this
	client.
	Route change messages will be generated for deleted routes that
	were the best
Arguments:
	ClientHandle - handle that identifies the client and routing protocol
						of routes to be deleted
	EnumerationFlags - further limit subset of routes being deleted to only
						those that have same values in the fields
						specified by the flags as in CriteriaRoute
		Note that only RTM_ONLY_THIS_NETWORK and RTM_ONLY_THIS_INTERFACE
		can be used (RTM_ONLY_BEST_ROUTES does not apply because best
		route designation is adjusted as routes are deleted and
		all routes will be deleted anyway)
	CriteriaRoute - protocol family dependent structure (RTM_??_ROUTE) with
					set values in fields that correspond to EnumerationFlags
Return Value:
	NO_ERROR - routes were deleted ok
	ERROR_NO_ROUTES - no routes exist that match specified criteria
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
						the operation
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmBlockDeleteRoutes (
	IN HANDLE		ClientHandle,
	IN DWORD		EnumerationFlags,
	IN PVOID		CriteriaRoute
	);

/*++
*******************************************************************

	R t m G e t F i r s t R o u t e

Routine Description:
	Returns first route in the NetworkNumber.RoutingProtocol.InterfaceID.
	NextHopAddress order from the subset specifed by the enumeration flags.
	Note that this operation may consume significant processing time because
	first all recently changed routes will have to be merged into the
	ordered list, and this list will then have to be traversed to locate
	the route of interest.

Arguments:
	ProtocolFamily - identifies protocol family of interest
	EnumerationFlags - limit routes returned by enumeration API to a subset
						members of which have same values in the fields
						specified by the flags as in CriteriaRoute
						(RTM_ONLY_BEST_ROUTES does not require a criterion)
	Route - protocol family dependent structure (RTM_??_ROUTE) with
					set values in fields that correspond to EnumerationFlags
					on INPUT and first route that matches specified
					criteria on OUTPUT
Return Value:
	NO_ERROR - matching route was found
	ERROR_NO_ROUTES - no routes exist with specified criteria
	ERROR_INVALID_PARAMETER - input parameter(s) is invalid (unsupported
					protocol family, invalid enumeration flag, etc)
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmGetFirstRoute (
	IN	DWORD		ProtocolFamily,
	IN	DWORD		EnumerationFlags,
	IN OUT PVOID 	Route
	);

#define RtmGetSpecificRoute(ProtocolFamily,Route)		\
		RtmGetFirstRoute(ProtocolFamily,				\
						RTM_ONLY_THIS_NETWORK			\
							| RTM_ONLY_THIS_PROTOCOL	\
							| RTM_ONLY_THIS_INTERFACE,	\
						Route)

/*++
*******************************************************************

	R t m G e t N e x t R o u t e

Routine Description:
	Returns route that follows specified route in the NetworkNumber.
	RoutingProtocol.InterfaceID.NextHopAddress order from the subset defined
	by the enumeration flags.
	Note that this operation may consume significant processing time because
	first all recently changed routes will have to be merged into the
	ordered list, and this list may then have to be traversed to locate
	the route of interest.

Arguments:
	ProtocolFamily - identifies protocol family of interest
	EnumerationFlags - limit routes returned by enumeration API to a subset
						members of which have same values in the fields
						specified by the flags as in Route
						(RTM_ONLY_BEST_ROUTES does not require a criterion)
	Route - protocol family dependent structure (RTM_??_ROUTE) which both
					provides the route from which to start the search and
					set values in fields that correspond to EnumerationFlags
					on INPUT and route that both follows input route in
					NetworkNumber.RoutingProtocol.InterfaceID.NextHopAddress
					order and matches specified criteria on OUTPUT
Return Value:
	NO_ERROR - matching route was found
	ERROR_NO_ROUTES - no routes exist with specified criteria
	ERROR_INVALID_PARAMETER - input parameter(s) is invalid (unsupported
					protocol family, invalid enumeration flag, etc)
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmGetNextRoute (
	IN	DWORD		ProtocolFamily,
	IN	DWORD		EnumerationFlags,
	IN OUT PVOID 	Route
	);


BOOL WINAPI
RtmLookupIPDestination(
    DWORD                       dwDestAddr,
    PRTM_IP_ROUTE               prir
);


#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif //__ROUTING_RTM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scardmgr_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Nov 25 10:32:44 1997
 */
/* Compiler settings for scardmgr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ISCard = {0x1461AAC3,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID IID_ISCardDatabase = {0x1461AAC8,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID IID_ISCardLocate = {0x1461AACD,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID LIBID_SCardMgrLib = {0x1461AAC1,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_CSCard = {0x1461AAC7,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_CSCardDatabase = {0x1461AACC,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_CSCardLocate = {0x1461AAD1,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rtp.h

Abstract:

    Header for RTP/RTCP Protocol.

--*/
 
#if !defined(_INC_RTP_H_)
#define      _INC_RTP_H_

#define RTP_TYPE     2
#define RTP_VERSION  RTP_TYPE
#define RTP_MAX_SDES 256
#define RTP_MAX_EKEY 32

#define	NUM_COLLISION_ENTRIES	10
#define	MAX_ADDR_LEN			80

typedef struct _RTP_SDES_ITEM {
    BYTE Type;
    BYTE TextLength;
    BYTE Text[RTP_MAX_SDES];
} RTCP_SDES_ITEM, *PRTCP_SDES_ITEM;

// RTCP SDES (Source DEScription) types, as described in RFC1889
typedef enum
{
	RTCP_SDES_END,   // END:   SDES Items terminator
	RTCP_SDES_CNAME, // CNAME: Canonical end-point identifier SDES item
	RTCP_SDES_NAME,  // NAME:  User name SDES item
	RTCP_SDES_EMAIL, // EMAIL: Electronic mail address SDES item
	RTCP_SDES_PHONE, // PHONE: Phone number SDES item
	RTCP_SDES_LOC,   // LOC:   Geographic user location SDES item
	RTCP_SDES_TOOL,  // TOOL:  Application or tool name SDES item
	RTCP_SDES_NOTE,  // NOTE:  Notice/status SDES item
	RTCP_SDES_PRIV,  // PRIV:  Private extensions SDES
	RTCP_SDES_LAST   // just a count of the number of items
} RTCP_SDES_TYPE_T;

typedef struct _RTCP_SENDER_REPORT {
    DWORD NtpTimestampSec;
    DWORD NtpTimestampFrac;
    DWORD RtpTimestamp;
    DWORD TotalPackets;
    DWORD TotalOctets;
} RTCP_SENDER_REPORT, *PRTCP_SENDER_REPORT;
    
typedef struct _RTCP_RECEIVER_REPORT {
    DWORD FractionLost:8;
    DWORD TotalLostPackets:24;
    DWORD HighestSequenceNum;
    DWORD InterarrivalJitter;
    DWORD LastSRTimestamp;
    DWORD DelaySinceLastSR;
} RTCP_RECEIVER_REPORT, *PRTCP_RECEIVER_REPORT;

typedef struct _RTCP_PARTICIPANT_REPORT {
    DWORD                SSRC;
    RTCP_SENDER_REPORT   LastSR;
    RTCP_RECEIVER_REPORT LastIncomingRR;
    RTCP_RECEIVER_REPORT LastOutgoingRR;
} RTCP_PARTICIPANT_REPORT, *PRTCP_PARTICIPANT_REPORT;
    
typedef struct _RTP_HEADER {
//--- NETWORK BYTE ORDER BEGIN ---//
    WORD  NumCSRC:4;                                      
    WORD  fExtHeader:1;                                   
    WORD  fPadding:1;                                     
    WORD  Version:2;                                      
    WORD  PayloadType:7;
    WORD  fMarker:1;
//---- NETWORK BYTE ORDER END ----//
    WORD  SequenceNum;
    DWORD Timestamp;
    DWORD SSRC;
} RTP_HEADER, *PRTP_HEADER;

typedef struct _RTP_HEADER_X {
    WORD  Identifier;
    WORD  DataLength;
    DWORD Data[1];
} RTP_HEADER_X, *PRTP_HEADER_X;

typedef struct _RTP_ENCRYPTION_INFO {
    DWORD Scheme;
    DWORD Key[RTP_MAX_EKEY];
} RTP_ENCRYPTION_INFO, *PRTP_ENCRYPTION_INFO;


/////////////////////////////////////////////////
// DXMRTP RTP/RTCP events
/////////////////////////////////////////////////
// The real event received is e.g. for "new source",
// DXMRTP_EVENTBASE + DXMRTP_NEW_SOURCE_EVENT
/////////////////////////////////////////////////

#define B2M(b) (1 << (b))

#define DXMRTP_EVENTBASE (EC_USER+0)

typedef enum 
{
	DXMRTP_NO_EVENT,
	DXMRTP_NEW_SOURCE_EVENT,			// New SSRC detected
	DXMRTP_RECV_RTCP_RECV_REPORT_EVENT,	// RTCP RR received
	DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT,	// RTCP SR received
	DXMRTP_LOCAL_COLLISION_EVENT,		// Collision detected
	DXMRTP_REMOTE_COLLISION_EVENT,		// Remote collision detected
	DXMRTP_TIMEOUT_EVENT,				// SSRC timed-out
	DXMRTP_BYE_EVENT,					// RTCP Bye received
	DXMRTP_RTCP_WS_RCV_ERROR,			// Winsock error on RTCP rcv
	DXMRTP_RTCP_WS_XMT_ERROR, 			// Winsock error on RTCP xmt
	DXMRTP_INACTIVE_EVENT,				// SSRC has been silent
	DXMRTP_ACTIVE_AGAIN_EVENT,			// SSRC has been heard again
    DXMRTP_LOSS_RATE_RR_EVENT,          // Loss rate as reported in an RR
    DXMRTP_LOSS_RATE_LOCAL_EVENT,       // Loss rate locally detected
	DXMRTP_LAST_EVENT
} DXMRTP_EVENT_T;

typedef struct _SDES_DATA
{
	DWORD				dwSdesType;			// SDES type: CNAME/NAME/...
	char				sdesBfr[RTP_MAX_SDES];
	DWORD				dwSdesLength;		// SDES length
	DWORD				dwSdesFrequency;	// SDES frequency
	DWORD				dwSdesEncrypted;	// SDES encrypted Y/N ?
} SDES_DATA, *PSDES_DATA;

/////////////////////////////////////////////////
// DXMRTP QOS events
/////////////////////////////////////////////////
// The real event received is e.g. for "receivers",
// DXMRTP_QOSEVENTBASE + DXMRTP_QOSEVENT_RECEIVERS
/////////////////////////////////////////////////

#define DXMRTP_QOSEVENTBASE (DXMRTP_EVENTBASE + 32)

//
// NOTE!:
// Other events may be added related to trying to set up QoS
// (before any QoS event could be fired)
//
typedef enum
{
	DXMRTP_QOSEVENT_NOQOS,
	/* no QoS support is available */
	DXMRTP_QOSEVENT_RECEIVERS,
	/* at least one Reserve has arrived */
	DXMRTP_QOSEVENT_SENDERS,
	/* at least one Path has arrived */
	DXMRTP_QOSEVENT_NO_SENDERS,
	/* there are no senders */
	DXMRTP_QOSEVENT_NO_RECEIVERS,
	/* there are no receivers */
	DXMRTP_QOSEVENT_REQUEST_CONFIRMED,
	/* Reserve has been confirmed */
	DXMRTP_QOSEVENT_ADMISSION_FAILURE,
	/* error due to lack of resources */
	DXMRTP_QOSEVENT_POLICY_FAILURE,
	/* rejected for administrative reasons - bad credentials */
	DXMRTP_QOSEVENT_BAD_STYLE,
	/* unknown or conflicting style */
	DXMRTP_QOSEVENT_BAD_OBJECT,
	/* problem with some part of the filterspec or providerspecific
	 * buffer in general */
	DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR,
	/* problem with some part of the flowspec */
	DXMRTP_QOSEVENT_GENERIC_ERROR,
	/* general error */
	DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND,
	/* sender is not allowed to send */
	DXMRTP_QOSEVENT_ALLOWEDTOSEND,
	/* sender is not allowed to send */
	DXMRTP_QOSEVENT_LAST
} DXMRTP_QOSEVENT_T;

/////////////////////////////////////////////////
// DXMRTP DEMUX events
/////////////////////////////////////////////////
// The real event received is e.g. for "ssrc mapped",
// RTPDMX_EVENTBASE + RTPDEMUX_SSRC_MAPPED
/////////////////////////////////////////////////
#if !defined(RTPDMX_EVENTBASE)
#define RTPDMX_EVENTBASE (EC_USER+100)

typedef enum {
	RTPDEMUX_SSRC_MAPPED,       // The specific SSRC has been mapped
	RTPDEMUX_SSRC_UNMAPPED,     // The specific SSRC has been unmapped
	RTPDEMUX_PIN_MAPPED,        // The specific Pin has been mapped
	RTPDEMUX_PIN_UNMAPPED,      // The specific Pin has been unmapped
	RTPDEMUX_NO_PINS_AVAILABLE, // PT was found, but pin was already mapped
	RTPDEMUX_NO_PAYLOAD_TYPE    // PT was not found
} RTPDEMUX_EVENT_t;
// The Pin passed as a parameter along with PIN_MAPPED and PIN_UNMAPPED
// is a pointer to the connected pin

#endif

// Maximum number of classes per CPU in
// in the RTP Source Shared Thread scheme
#define RTP_MAX_CLASSES 4

// Actually two classes are defined
enum {
	RTP_CLASS_AUDIO,
	RTP_CLASS_VIDEO
};

// Reservation styles
enum {
	DXMRTP_RESERVE_WILCARD,  // Usually for N times the AUDIO flow spec
	DXMRTP_RESERVE_EXPLICIT  // Usually for designated VIDEO streams
};

#endif // _INC_RTP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scardsrv_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Nov 25 10:32:49 1997
 */
/* Compiler settings for scardsrv.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ISCardISO7816 = {0x53B6AA68,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const IID LIBID_SCardSrvLib = {0x53B6AA61,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}};


const CLSID CLSID_CSCardISO7816 = {0x53B6AA6C,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scarddat.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scarddat

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scarddat.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rulecls.h ===
// --rulecls.h-----------------------------------------------------------------
//
// Rule class interface header.
//
// Copyright (C) Microsoft Corp. 1986-1998. All rights reserved.
//
// ----------------------------------------------------------------------------

#if !defined(_RULECLS_H_)
#define _RULECLS_H_

// $$--LPACTIONS---------------------------------------------------------------
//
// Pointer to ACTIONS structure defined in edkmdb.h.
//
// ----------------------------------------------------------------------------

typedef ACTIONS FAR *   LPACTIONS;  // should be moved to edkmdb.h

// $$--IExchangeFolderRules----------------------------------------------------
//
// Definition of interface for folder rules class CFolderRules.
//
// ----------------------------------------------------------------------------

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFolderRules

// Manifest for cursor position indicating we are at the end of the rules table.

#define	RULE_PAST_END		((LONG) -1)

DECLARE_INTERFACE_(IExchangeFolderRules, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */

	STDMETHOD(QueryInterface)(
		THIS_
		REFIID					riid,
		LPVOID FAR *			ppvObj
		)										PURE;

    STDMETHOD_(ULONG, AddRef)(
		THIS
		)										PURE;

    STDMETHOD_(ULONG, Release)(
		THIS
		)										PURE;

#endif

    /* IExchangeFolderRules methods */

    STDMETHOD(HrDelete)(
		THIS
		)													PURE;

    STDMETHOD(HrDisable)(
		THIS
		)													PURE;

    STDMETHOD(HrEnable)(
		THIS
		)													PURE;

    STDMETHOD(HrGet)(
		THIS_
		LPLONG					lplState,
		LPSRestriction FAR *	lppRestriction,
		LPACTIONS FAR *			lppActions,
		LPLONG					lplLevel,
		LPSTR FAR *				lppszName
		)													PURE;

    STDMETHOD(HrInsert)(
		THIS_
		LONG					lState,
		LPSRestriction			lpRestriction,
		LPACTIONS				lpActions,
		LONG					lLevel,
		LPSTR					lpszName
		)													PURE;

    STDMETHOD(HrSeek)(
		THIS_
		LONG					lPos
		)													PURE;

    STDMETHOD(HrTell)(
		THIS_
		LPLONG					lplPos
		)													PURE;
};

// $$--LPFOLDERRULES-----------------------------------------------------------
//
// Pointer to IExchangeFolderRules interface.
//
// ----------------------------------------------------------------------------

typedef IExchangeFolderRules FAR* LPFOLDERRULES;

//
// Helper functions defined in module RULECLS.
//

// $--HrCopyActions------------------------------------------------------------
//
// DESCRIPTION:	Make a copy of an ACTIONS structure and all its subelements.
//
// INPUT:
//
//	[lpActsSrc]		-- Ptr to ACTIONS structure to be copied.
//	[lpObject]		-- Ptr to an existing MAPI buffer allocated by 
//					   MAPIAllocateBuffer(), or NULL if the returned structure
//					   is to be allocated using MAPIAllocateBuffer().
// OUTPUT:
//
//	[lppActsDest]	-- Ptr to be set to copy of ACTIONS structure.
//
// RETURNS:     HRESULT --  NOERROR			if successful;
//							E_INVALIDARG	if bad input;
//							E_OUTOFMEMORY	if insufficient memory;
//              			E_FAIL			otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrCopyActions(							// RETURNS: HRESULT
	IN		LPACTIONS		lpActsSrc,  // source action ptr
	IN		LPVOID			lpObject,	// ptr to existing MAPI buffer
	OUT		LPACTIONS FAR *	lppActsDest // ptr to destination ACTIONS buffer
	);


// $--HrCopyRestriction--------------------------------------------------------
//
// DESCRIPTION:	Make a copy of an SRestriction structure and all its
//				subelements.
//
// INPUT:
//
//	[lpResSrc]		-- Ptr to restriction to be copied.
//	[lpObject]		-- Ptr to an existing MAPI buffer allocated by 
//					   MAPIAllocateBuffer(), or NULL if the returned structure
//					   is to be allocated using MAPIAllocateBuffer().
//
// OUTPUT:
//
//	[lppResDest]	-- Ptr to be set to copy of restriction.
//
// RETURNS:     NOERROR			if successful;
//				E_INVALIDARG	if bad input;
//				E_OUTOFMEMORY	if insufficient memory;
//              E_FAIL			otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrCopyRestriction(								// RETURNS: HRESULT
	IN		LPSRestriction			lpResSrc,   // source restriction ptr
	IN		LPVOID					lpObject,	// ptr to existing MAPI buffer
	OUT		LPSRestriction FAR *	lppResDest  // dest restriction buffer ptr
	);


// $--HrFolderRulesGetProviders------------------------------------------------
//
// DESCRIPTION:	Get an array of rules provider names for a given folder.
//
// INPUT:
//
//	[lpMDB]				-- Pointer to message store containing folder.
//  [cbentryid]			-- Number of bytes in folder's entry identifier.
//  [lpentryid]			-- Folder's entry identifier.
//
// OUTPUT:
//
//  [lpcProviders]		-- Pointer to ulong that will be set to count of
//						   providers on successful return.
//	[lpppszProviders]	-- Pointer to array of string pointers that will be set
//						   to point at an array of provider name string pointers
//						   on successful return.
//
// RETURNS:     NOERROR				if successful;
//				E_INVALIDARG		if bad input;
//				E_OUTOFMEMORY		if not enough memory;
//				E_NOINTERFACE		if rules table does not exist on folder;
//              E_FAIL 				otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrFolderRulesGetProviders(						// RETURNS: HRESULT
	IN		LPMDB				lpMDB,			// MAPI MDB store ptr
	IN		ULONG				cbentryid,		// # bytes in entry ID
	IN		LPENTRYID			lpentryid,		// entry ID ptr
	OUT		LPULONG				lpcProviders,	// count of providers
	OUT		LPSTR FAR * FAR *	lpppszProviders	// ptr to array of providers
	);


// $--HrFolderRulesOpen--------------------------------------------------------
//
// DESCRIPTION:	Get a pointer to an object which implements the
//				IExchangeFolderRules interface defined in rulecls.h.
//
// INPUT:
//
//	[lpMDB]				-- Pointer to message store containing folder.
//  [cbentryid]			-- Number of bytes in folder's entry identifier.
//  [lpentryid]			-- Folder's entry identifier.
//  [lpszProvider]		-- Provider for rules.  Multiple providers may have
//						   rules on a folder. The IExchangeFolderRules interface
//						   provides access to the rules associated with a
//						   single specified provider.
//
// OUTPUT:
//
//  [lppFolderRules]	-- Pointer to object which supports interface.
//
// RETURNS:     NOERROR				if successful;
//				E_INVALIDARG		if bad input;
//				E_OUTOFMEMORY		if not enough memory;
//				E_NOINTERFACE		if rules table does not exist on folder;
//              E_FAIL 				otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrFolderRulesOpen(								// RETURNS: HRESULT
	IN		LPMDB				lpMDB,			// MAPI MDB store ptr
	IN		ULONG				cbentryid,		// # bytes in entry ID
	IN		LPENTRYID			lpentryid,		// entry ID ptr
	IN		LPSTR				lpszProvider,	// provider name
	OUT		LPFOLDERRULES FAR *	lppFolderRules  // ptr to folder rules buffer
	);


// $--HrActionToString---------------------------------------------------------
//
// DESCRIPTION:	Get a string representation of an ACTION.
//
// INPUT:
//
//  [lpSession]		-- MAPI session ptr.
//	[lpAction]		-- Ptr to ACTION.
//
// OUTPUT:
//
//	[lppszString]	-- Ptr to ptr that will be set to point at generated
//					   string representation on successful return.
//
// RETURNS:     NOERROR             if successful;
//              E_INVALIDARG    	if bad input;
//              E_OUTOFMEMORY		if not enough memory;
//              E_FAIL				otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrActionToString(							// RETURNS: HRESULT
	IN		LPMAPISESSION	lpSession,  	// MAPI session ptr
	IN		LPACTION		lpAction,		// action ptr
	OUT		LPSTR FAR *		lppszString		// string ptr ptr
	);


// $--HrRestrictionToString----------------------------------------------------
//
// DESCRIPTION:	Get a string representation of an SRestriction.
//
// INPUT:
//
//	[lpRestriction]	-- Ptr to restriction.
//
// OUTPUT:
//
//	[lppszString]	-- Ptr to ptr that will be set to point at generated
//					   string representation on successful return.
//
// RETURNS:     NOERROR             if successful;
//              E_INVALIDARG    	if bad input;
//              E_OUTOFMEMORY		if not enough memory;
//              E_FAIL				otherwise.
//
//-----------------------------------------------------------------------------

STDAPI
HrRestrictionToString(						// RETURNS: HRESULT
	IN		LPSRestriction	lpRestriction,	// restriction ptr
	OUT		LPSTR FAR *		lppszString		// string ptr ptr
	);


// $--HrStringToAction---------------------------------------------------------
//
// DESCRIPTION:	Generate an ACTION structure that describes the action
//				provided in *lpszString.
//
// INPUT:
//
//	[lpSession]		-- Ptr to MAPI session.
//	[lpFolder]		-- Ptr to MAPI folder action applies to.  MUST have been
//					   opened with MAPI_MODIFY access.
//	[lpszString]	-- Action string specifying ACTION to be generated.
//	[lpObject]		-- Ptr to an existing MAPI buffer allocated by 
//					   MAPIAllocateBuffer().  NULL is not permitted. Ideally,
//					   this is a ptr to the parent ACTIONS structure.
//
// INPUT/OUTPUT:
//
//	[lpAction]		-- Ptr to ACTION structure that will be filled in.  This
//					   is allocated by the caller.  Ideally, this is a ptr to
//					   an ACTION array element that was allocated by the caller
//					   using a MAPIAllocateMore() that referenced the parent
//					   ACTIONS structure.
//
// RETURNS:     NOERROR				if successful;
//				E_INVALIDARG		if bad input;
//              E_OUTOFMEMORY		if out of memory;
//              E_FAIL				otherwise.
//-----------------------------------------------------------------------------

STDAPI
HrStringToAction(							// RETURNS: HRESULT
	IN		LPMAPISESSION	lpSession,		// ptr to MAPI session
	IN		LPMAPIFOLDER	lpFolder,		// ptr to MAPI folder
	IN		LPSTR			lpszString,		// string ptr
	IN		LPVOID			lpObject,		// ptr to existing MAPI buf
	IN OUT	LPACTION		lpAction  		// ACTION ptr
	);


// $--HrStringToRestriction----------------------------------------------------
//
// DESCRIPTION:	Generate an SRestriction structure that describes the 
//				restriction condition provided in *lpszString.
//
// INPUT:
//
//	[lpszString]	-- Condition string specifying restriction to be generated.
//	[lpObject]		-- Ptr to an existing MAPI buffer allocated by 
//					   MAPIAllocateBuffer(), or NULL if the returned structure
//					   is to be allocated using MAPIAllocateBuffer().
//
// OUTPUT:
//
//	[lppRestriction]	-- Ptr to ptr that will be set to point at generated
//						   restriction on successful return.
//
// RETURNS:     NOERROR			if successful;
//				E_INVALIDARG	if bad input;
//              E_FAIL 			otherwise.
//
// Conditional expression grammar used for HrStringToRestriction()
// lpszString parameter:
// 
// Condition ::=	SimpleCondition						|
//					Condition "|" Condition				|
//					Condition "&" Condition				|
//					"(" Condition ")"					|
//					"!" Condition
//
// "|" is the logical OR operator.
// "&" is the logical AND operator.
// "!" is the logical NOT operator.
//
// Conditional expressions are evaluated from left to right with "|" and "&"
// having equal precedence. "!" is a unary operator that applies to the operand
// to its immediate right.
//
// SimpleCondition ::=	BooleanCondition				|
//						NumericCondition				|
//						StringCondition					|
//						TimeCondition
//
// BooleanCondition ::=	BoolTag "=" BooleanLiteral
//
// NumericCondition ::=	NumericTag "=" NumericLiteral	|
//						NumericTag "#" NumericLiteral	|
//						NumericTag ">" NumericLiteral	|
//						NumericTag "<" NumericLiteral
//
// The meaning of the NumericCondition operators should be evident.
//
// StringCondition ::=	StringTag "=" StringLiteral		|
//						StringTag "#" StringLiteral		|
//						StringTag "}" StringLiteral
//
// "=" is the equality operator.
// "#" is the inequality operator.
// "}" is the contains operator (a "}" b means a contains b).
//
// TimeCondition ::=	TimeTag "=" TimeLiteral			|
//						TimeTag "#" TimeLiteral			|
//						TimeTag ">" TimeLiteral			|
//						TimeTag "<" TimeLiteral
//
// Note that time literals have a resolution of 1 second, so equality and 
// inequality may not be the best conditional tests.
//
// BoolTag ::=		PT_xxx for a property with a boolean (PT_BOOLEAN) value	|
//					"[B" HexNumber "]"
//
// NumericTag ::=	PR_xxxx for a property with a numeric (PT_LONG) value	|
//					"[N" HexNumber "]"
//
// StringTag ::=	PR_xxxx for a property with a string
//                  (PT_STRING8 or PT_UNICODE) value						|
//					"[S" HexNumber "]"
//
// TimeTag ::=		PR_xxxx for a property with a time (PT_SYSTIME) value	|
//					"[T" HexNumber "]"
//
// BooleanLiteral ::=	"0"					|
//						"1"
//
// NumericLiteral ::=	DecimalNumber
//
// StringLiteral ::=	String enclosed in quotes ("xxx").
//
// TimeLiteral ::=		HH:MM{:SS} YYYY-MM-DD (24 hour clock, local time)
//
// DecimalNumber ::= 	DecimalDigit...		|
//						+DecimalDigit...	|
//						-DecimalDigit...
//
// HexNumber ::=		HexDigit...
//
//-----------------------------------------------------------------------------

STDAPI
HrStringToRestriction(								// RETURNS: HRESULT
	IN		LPSTR					lpszString,		// string
	IN		LPVOID					lpObject,		// ptr to existing MAPI buf
	OUT		LPSRestriction FAR *	lppRestriction  // restriction buffer ptr
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sadapi.h ===
/*
 *	sadapi.h
 *
 *	Copyright (c) Microsoft Corp. 1986-1999. All Rights Reserved.
 *
 *	Definition of the public RPC APIs from the SAD Exchange service
 *
 */


#ifndef _SADLIB_H_
#define _SADLIB_H_

#include <rpcpub.h>

#ifdef __cplusplus
extern "C"
{
#endif


/* 
 * Return codes for all functions except SAD_EcGetProxies() and SAD_EcGetProxiesBI().
 * In addition to this list are all normal NT error codes...
 */
typedef enum _SC_RETURN_VALUES
{
	SC_OK = 0,					// no error
	SC_Error = 49001,			// general error
	SC_BPActive,				// bulk proxy generation is currently running
	SC_BPInactive,				// bulk proxy generation is not currently running
	SC_BPShutdownPending,		// a shutdown in bulk proxy generation is in progress
	SC_BPSiteAddressMismatch,	// a Site Address Mismatch between rgszOldSiteAddress
								//   and rgszNewSiteAddress lists in ScBulkUpdateMultiProxy
} SC_RETURN_VALUES;


#define cchMaxServer		(MAX_COMPUTERNAME_LENGTH + 1)

typedef	struct _RPCBINDINFO
{
	handle_t 		h;
	WCHAR			wszServer[cchMaxServer];
	RPC_IF_HANDLE	hClientIfHandle;
} RPCBINDINFO, *PRPCBINDINFO;


//	Utility entry points
RPC_SC WINAPI SAD_ScBindA(PRPCBINDINFO pBI, LPSTR szServer);
RPC_SC WINAPI SAD_ScBindW(PRPCBINDINFO pBI, LPWSTR wszServer);
void WINAPI SAD_Unbind(PRPCBINDINFO pBI);

#ifdef UNICODE
#define	SAD_ScBind		SAD_ScBindW
#else
#define	SAD_ScBind		SAD_ScBindA
#endif



// Message Tracking group
RPC_SC WINAPI SAD_ScSaveGatewayTrackingData(PRPCBINDINFO pBI,
											RPC_GATEWAY_TRACK_INFORMATION *	pgti,
											INT	cszRecipients,
											LPWSTR	rgwszRecipients[]);

// for Microsoft Internal Use ONLY
RPC_SC WINAPI SAD_ScSaveTrackingData(PRPCBINDINFO pBI, INT cb, BYTE pb[], DWORD dwFlags);


// for Gateways - cause the routing table to be recalculated
RPC_SC WINAPI SAD_ScRunRIDA(LPSTR szServer);
RPC_SC WINAPI SAD_ScRunRIDW(LPWSTR wszServer);
RPC_SC WINAPI SAD_ScRunRIDExA(LPSTR szServer, RPC_BOOL fProxySpace, RPC_BOOL fGwart);
RPC_SC WINAPI SAD_ScRunRIDExW(LPWSTR wszServer, RPC_BOOL fProxySpace, RPC_BOOL fGwart);

#ifdef UNICODE
#define	SAD_ScRunRID		SAD_ScRunRIDW
#define	SAD_ScRunRIDEx		SAD_ScRunRIDExW
#else
#define	SAD_ScRunRID		SAD_ScRunRIDA
#define	SAD_ScRunRIDEx		SAD_ScRunRIDExA
#endif



//	Proxy Entry points

RPC_EC WINAPI SAD_EcGetProxies(LPWSTR wszServer, PPROXYINFO pProxyInfo, PPROXYLIST pProxyList);
RPC_EC WINAPI SAD_EcGetProxiesBI(PRPCBINDINFO pBI, PPROXYINFO pProxyInfo, PPROXYLIST pProxyList);
void   WINAPI SAD_FreeProxyListNode(PPROXYNODE pnode);
RPC_SC WINAPI SAD_ScIsProxyUniqueA(LPSTR szServer,
		LPSTR szProxy, RPC_BOOL * pfUnique, LPSTR * pszExisting);
RPC_SC WINAPI SAD_ScIsProxyUniqueW(LPWSTR wszServer,
		LPWSTR szProxy, RPC_BOOL * pfUnique, LPWSTR * pszExisting);

// dwOptions values for SAD_ScBulkCreateProxy() and SAD_ScBulkCreateMultiProxy()
#define		BPTAdd			1
#define		BPTRemove		2
#define		BPTUpdate		3

RPC_SC WINAPI SAD_ScBulkCreateProxyA(LPSTR szServer, LPSTR szHeader, DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateProxyW(LPWSTR wszServer, LPWSTR wszHeader, DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateMultiProxyA(LPSTR szServer,
										  INT cszHeader,
										  LPSTR rgszHeader[],
										  DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateMultiProxyW(LPWSTR wszServer,
										  INT cwszHeader,
										  LPWSTR rgwszHeader[],
										  DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkUpdateMultiProxy(LPWSTR wszServer,
										 INT cwszSiteAddress,
										 LPWSTR rgwszOldSiteAddress[],
										 LPWSTR rgwszNewSiteAddress[],
										 RPC_BOOL fSaveSiteAddress);


RPC_SC WINAPI SAD_ScGetBulkProxyStatusA(LPSTR szServer,
									    RPC_SYSTEMTIME * pstTimeStart,
									    DWORD * pdwTimeStart,
									    DWORD * pdwTimeCur,
									    INT * piRecipients,
									    INT * pcRecipients);
RPC_SC WINAPI SAD_ScGetBulkProxyStatusW(LPWSTR wszServer,
										RPC_SYSTEMTIME * pstTimeStart,
									    DWORD * pdwTimeStart,
									    DWORD * pdwTimeCur,
									    INT * piRecipients,
									    INT * pcRecipients);
RPC_SC WINAPI SAD_ScBulkProxyHaltA(LPSTR szServer, RPC_BOOL fWaitForShutdown);
RPC_SC WINAPI SAD_ScBulkProxyHaltW(LPWSTR wszServer, RPC_BOOL fWaitForShutdown);

#ifdef UNICODE
#define	SAD_ScIsProxyUnique			SAD_ScIsProxyUniqueW
#define SAD_ScBulkCreateProxy		SAD_ScBulkCreateProxyW
#define SAD_ScBulkCreateMultiProxy	SAD_ScBulkCreateMultiProxyW
#define	SAD_ScGetBulkProxyStatus	SAD_ScGetBulkProxyStatusW
#define	SAD_ScBulkProxyHalt			SAD_ScBulkProxyHaltW
#else
#define	SAD_ScIsProxyUnique			SAD_ScIsProxyUniqueA
#define SAD_ScBulkCreateProxy		SAD_ScBulkCreateProxyA
#define SAD_ScBulkCreateMultiProxy	SAD_ScBulkCreateMultiProxyA
#define	SAD_ScGetBulkProxyStatus	SAD_ScGetBulkProxyStatusA
#define	SAD_ScBulkProxyHalt			SAD_ScBulkProxyHaltA
#endif






//	Backup entry point	(available only in UNICODE!)

RPC_SC WINAPI	SAD_ScGetBackupListNodeW(LPWSTR wszServer, BackupListNode ** ppnode);
void WINAPI		SAD_FreeBackupListNode(BackupListNode * pnode);


// Run DRA Check calling parameters (dwCheck)
#define INTRASITE_CHECK 0
#define INTERSITE_CHECK 1

RPC_SC WINAPI	SAD_ScRunDRACheck(LPWSTR wszServer, RPC_DWORD dwCheck);



// These few lines (or equivalent) need to be supplied by the application that links
// with SADAPI.LIB.
#ifdef _SAMPLE_CODE
void __RPC_FAR * __RPC_API midl_user_allocate(size_t cb)
{
	void *	pv;

	pv = GlobalAlloc(GMEM_FIXED, cb);
	if (!pv)
		RpcRaiseException(RPC_S_OUT_OF_MEMORY);

	return pv;
}

void __RPC_API midl_user_free(void __RPC_FAR * pv)
{
	GlobalFree(pv);
}
#endif







#ifdef __cplusplus
}
#endif

#endif		// #ifndef _SADLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\rtutils.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    rtutils.h

Abstract:
     Public declarations for the Router process  utility functions.

--*/

#ifndef __ROUTING_RTUTILS_H__
#define __ROUTING_RTUTILS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// TRACING FUNCTION PROTOTYPES                                              //
//                                                                          //
// See DOCUMENT for more information                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Definitions for flags and constants                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TRACE_USE_FILE      0x00000001
#define TRACE_USE_CONSOLE   0x00000002
#define TRACE_NO_SYNCH      0x00000004

#define TRACE_NO_STDINFO    0x00000001
#define TRACE_USE_MASK      0x00000002
#define TRACE_USE_MSEC      0x00000004

#define INVALID_TRACEID     0xFFFFFFFF


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExA(
    IN  LPCSTR      lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterA(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleA(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
__cdecl
TracePrintfA(
    IN  DWORD       dwTraceID,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
__cdecl
TracePrintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszString
    );

DWORD
APIENTRY
TraceDumpExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCSTR      lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points macros                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterA(a)               TraceRegisterExA(a,0)
#define TraceVprintfA(a,b,c)            TraceVprintfExA(a,0,b,c)
#define TracePutsA(a,b)                 TracePutsExA(a,0,b)
#define TraceDumpA(a,b,c,d,e,f)         TraceDumpExA(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExW(
    IN  LPCWSTR     lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterW(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleW(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
__cdecl
TracePrintfW(
    IN  DWORD       dwTraceID,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
__cdecl
TracePrintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszString
    );

DWORD
APIENTRY
TraceDumpExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCWSTR     lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points macros                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterW(a)               TraceRegisterExW(a,0)
#define TraceVprintfW(a,b,c)            TraceVprintfExW(a,0,b,c)
#define TracePutsW(a,b)                 TracePutsExW(a,0,b)
#define TraceDumpW(a,b,c,d,e,f)         TraceDumpExW(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Code-page dependent entry-point macros                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
#define TraceRegister           TraceRegisterW
#define TraceDeregister         TraceDeregisterW
#define TraceDeregisterEx       TraceDeregisterExW
#define TraceGetConsole         TraceGetConsoleW
#define TracePrintf             TracePrintfW
#define TraceVprintf            TraceVprintfW
#define TracePuts               TracePutsW
#define TraceDump               TraceDumpW
#define TraceRegisterEx         TraceRegisterExW
#define TracePrintfEx           TracePrintfExW
#define TraceVprintfEx          TraceVprintfExW
#define TracePutsEx             TracePutsExW
#define TraceDumpEx             TraceDumpExW
#else
#define TraceRegister           TraceRegisterA
#define TraceDeregister         TraceDeregisterA
#define TraceDeregisterEx       TraceDeregisterExA
#define TraceGetConsole         TraceGetConsoleA
#define TracePrintf             TracePrintfA
#define TraceVprintf            TraceVprintfA
#define TracePuts               TracePutsA
#define TraceDump               TraceDumpA
#define TraceRegisterEx         TraceRegisterExA
#define TracePrintfEx           TracePrintfExA
#define TraceVprintfEx          TraceVprintfExA
#define TracePutsEx             TracePutsExA
#define TraceDumpEx             TraceDumpExA
#endif



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// EVENT LOGGING FUNCTION PROTOTYPES                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


VOID
APIENTRY
LogErrorA(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    IN LPSTR   *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
APIENTRY
LogEventA(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    IN LPSTR  *plpwsSubStrings
);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
LogErrorW(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    IN LPWSTR  *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
LogEventW(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    IN LPWSTR *plpwsSubStrings
);


#ifdef UNICODE
#define LogError                LogErrorW
#define LogEvent                LogEventW
#else
#define LogError                LogErrorA
#define LogEvent                LogEventA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following functions allow the caller to specify the event source.    //
//                                                                          //
// Call RouterLogRegister with the strings which would be passed to         //
// RegisterEventSource; this returns a handle which can be passed           //
// to the functions RouterLogEvent and RouterLogEventData.                  //
//                                                                          //
// Call RouterLogDeregister to close the handle.                            //
//                                                                          //
// Macros are provided for the different kinds of event log entrys:         //
//  RouterLogError          logs an error (EVENTLOG_ERROR_TYPE)             //
//  RouterLogWarning        logs a warning (EVENTLOG_WARNING_TYPE)          //
//  RouterLogInformation    logs information (EVENTLOG_INFORMATION_TYPE)    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterA(
    LPCSTR lpszSource
    );

VOID
RouterLogDeregisterA(
    HANDLE hLogHandle
    );

VOID
RouterLogEventA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
__cdecl
RouterLogEventExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    ...
    );

VOID
RouterLogEventValistExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringA(
    IN  DWORD   dwErrorCode,
    OUT LPSTR * lplpszErrorString
    );

#define RouterLogErrorA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_ERROR_TYPE,msg,count,array, err,index)
#define RouterLogWarningStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringA(h,msg,count,array, err,index) \
        RouterLogEventStringA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterW(
    LPCWSTR lpszSource
    );

VOID
RouterLogDeregisterW(
    HANDLE hLogHandle
    );

VOID
RouterLogEventW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
__cdecl
RouterLogEventExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    ...
    );

VOID
RouterLogEventValistExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringW(
    IN  DWORD    dwErrorCode,
    OUT LPWSTR * lplpwszErrorString
    );


#define RouterLogErrorW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err,index)
#define RouterLogWarningStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


#ifdef UNICODE
#define RouterLogRegister           RouterLogRegisterW
#define RouterLogDeregister         RouterLogDeregisterW
#define RouterLogEvent              RouterLogEventW
#define RouterLogError              RouterLogErrorW
#define RouterLogWarning            RouterLogWarningW
#define RouterLogInformation        RouterLogInformationW
#define RouterLogEventData          RouterLogEventDataW
#define RouterLogErrorData          RouterLogErrorDataW
#define RouterLogWarningData        RouterLogWarningDataW
#define RouterLogInformationData    RouterLogInformationDataW
#define RouterLogEventString        RouterLogEventStringW
#define RouterLogEventEx            RouterLogEventExW
#define RouterLogEventValistEx      RouterLogEventValistExW
#define RouterLogErrorString        RouterLogErrorStringW
#define RouterLogWarningString      RouterLogWarningStringW
#define RouterLogInformationString  RouterLogInformationStringW
#define RouterGetErrorString        RouterGetErrorStringW
#
#else
#define RouterLogRegister           RouterLogRegisterA
#define RouterLogDeregister         RouterLogDeregisterA
#define RouterLogEvent              RouterLogEventA
#define RouterLogError              RouterLogErrorA
#define RouterLogWarning            RouterLogWarningA
#define RouterLogInformation        RouterLogInformationA
#define RouterLogEventData          RouterLogEventDataA
#define RouterLogErrorData          RouterLogErrorDataA
#define RouterLogWarningData        RouterLogWarningDataA
#define RouterLogInformationData    RouterLogInformationDataA
#define RouterLogEventString        RouterLogEventStringA
#define RouterLogEventEx            RouterLogEventExA
#define RouterLogEventValistEx      RouterLogEventValistExA
#define RouterLogErrorString        RouterLogErrorStringA
#define RouterLogWarningString      RouterLogWarningStringA
#define RouterLogInformationString  RouterLogInformationStringA
#define RouterGetErrorString        RouterGetErrorStringA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// WORKER THREAD POOL FUNCTIONS                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// definition of worker function passed in QueueWorkItem API                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef VOID (APIENTRY * WORKERFUNCTION)(PVOID);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Function: Queues the supplied work item in the work queue.              //
//                                                                          //
//  functionptr: function to be called must be of WORKERFUNCTION type       //
//  context:     opaque ptr                                                 //
//  serviceinalertablethread: if TRUE gets scheduled in                     //
//               a alertably waiting thread that never dies                 //
//  Returns:  0 (success)                                                   //
//            Win32 error codes for cases like out of memory                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
QueueWorkItem(
    IN WORKERFUNCTION functionptr,
    IN PVOID context,
    IN BOOL serviceinalertablethread
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Function:        Associates file handle with the completion port (all    //
//                  asynchronous i/o on this handle will be queued to       //
//			        the completion port)                                    //
//                                                                          //
// FileHandle:	    File handle to be associated with completion port       //
//                                                                          //
// CompletionProc:  Procedure to be called when io associated with the file //
//				    handle completes. This function will be executed in     //
//				    the context of non-alertable worker thread              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
SetIoCompletionProc (
	IN HANDLE							FileHandle,
	IN LPOVERLAPPED_COMPLETION_ROUTINE	CompletionProc
	);



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following defines are included here as a hint on how the worker      //
// thread pool is managed:                                                  //
//                                                                          //
// There are NUM_ALERTABLE_THREADS permanent threads that never quit and    //
// wait alertably on a alertable worker queue.  These threads should solely //
// be used for work items that intiate asyncronous operation (file io,      //
// waitable timer) that ABSOLUTELY require APCs to complete (preferable     //
// method for IO is the usage of completio port API)                        //
//                                                                          //
// There is a pool of the threads that wait on completion port              //
// that used both for processing of IO and non-IO related work items        //
//                                                                          //
// The minimum number of threads is Number of processors                    //
// The maximum number of threads is MAX_WORKER_THREADS                      //
//                                                                          //
// A new thread is created if worker queue has not been served for more     //
// that WORK_QUEUE_TIMEOUT                                                  //
// The existing thread will be shut down if it is not used for more than    //
// THREAD_IDLE_TIMEOUT                                                      //
//                                                                          //
// Note that worker threads age guaranteed to be alive for at least         //
// THREAD_IDLE_TIMEOUT after the last work item is executed.  This timeout  //
// is chosen such that bulk of IO request could be completed before it      //
// expires.  If it is not enough for your case, use alertable thread with   //
// APC, or create your own thread.                                          //
//                                                                          //
// Note: changing these flags will not change anything.                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Number of alertable threads                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define NUM_ALERTABLE_THREADS		2

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Max number of threads at any time                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_WORKER_THREADS          10

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Time that the worker queue is not served before starting new thread      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define WORK_QUEUE_TIMEOUT			1 //sec

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Time that thread has to be idle before exiting                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define THREAD_IDLE_TIMEOUT			10 //sec


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ROUTER ASSERT DECLARATION                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
RouterAssert(
    IN PSTR pszFailedAssertion,
    IN PSTR pszFileName,
    IN DWORD dwLineNumber,
    IN PSTR pszMessage OPTIONAL
    );


#if DBG
#define RTASSERT(exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, NULL)
#define RTASSERTMSG(msg, exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, msg)
#else
#define RTASSERT(exp)
#define RTASSERTMSG(msg, exp)
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// REGISTRY CONFIGURATION FUNCTIONS                                         //
//                                                                          //
// The following definitions are used to read configuration information     //
// about installed protocols.                                               //
//                                                                          //
// Call 'MprSetupProtocolEnum' to enumerate the routing-protocols           //
// for transport 'dwTransportId'. This fills an array with entries          //
// of type 'MPR_PROTOCOL_0'.                                                //
//                                                                          //
// The array loaded can be destroyed by calling 'MprSetupProtocolFree'.     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_PROTOCOL_NAME_LEN                           40
#define MAX_PROTOCOL_DLL_LEN                            48

typedef struct _MPR_PROTOCOL_0 {

    DWORD       dwProtocolId;                           // e.g. IP_RIP
    WCHAR       wszProtocol[MAX_PROTOCOL_NAME_LEN+1];   // e.g. "IPRIP"
    WCHAR       wszDLLName[MAX_PROTOCOL_DLL_LEN+1];     // e.g. "iprip2.dll"

} MPR_PROTOCOL_0;


DWORD APIENTRY
MprSetupProtocolEnum(
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE*                 lplpBuffer,         // MPR_PROTOCOL_0
    OUT     LPDWORD                 lpdwEntriesRead
    );


DWORD APIENTRY
MprSetupProtocolFree(
    IN      LPVOID                  lpBuffer
    );


//////////////////////////////////////////////////////////////////////////////
// Extensions to Rtutils to improve worker thread utilization.				//
// 																			//
//////////////////////////////////////////////////////////////////////////////

#define ROUTING_RESERVED
#define OPT1_1
#define OPT1_2
#define OPT2_1
#define OPT2_2
#define OPT3_1
#define OPT3_2


//
// When everyone is migrated to using Winsock2
//

#if 0


//==========================================================================================================//
//==========================================================================================================//

// ASYNC_SOCKET_DATA structure is used to pass / receive back data from an    	//
// asynchronous wait recv from call												//

typedef struct _ASYNC_SOCKET_DATA {
			OVERLAPPED		Overlapped;			// reserved. not to be used
	IN		WSABUF			WsaBuf;				// WsaBuf.buf to be initialized to point to buffer
												// WsaBuf.len set to the length of the buffer
	OUT		SOCKADDR_IN		SrcAddress;			// AsyncWsaRecvFrom fills this with the source address of the packet
	OUT		DWORD			NumBytesReceived;	// AsyncWsaRecvFrom fills this with the number of bytes returned in the packet
	IN OUT	DWORD			Flags;				// Used to set flags for WSARecvFrom, and returns the flags set by WSARecvFrom
	OUT		DWORD			Status;				// status returned by IO Completion Port

	IN		WORKERFUNCTION	pFunction;			// Function to be executed on receiving packet
	IN		PVOID			pContext;			// context for the above function
} ASYNC_SOCKET_DATA, *PASYNC_SOCKET_DATA;



// AsyncSocketInit() binds the socket to the IOCompletionPort. This should be called//
// after the socket is created and before AsyncWsaRecvFrom() call is made			//
DWORD
APIENTRY
AsyncSocketInit (
	SOCKET	sock
	);


// This should be called only after the appropriate fields in SockData are initialized	//
// This sets up an asynchronous WSARecvFrom(), and on its return dispatches the 		//
// function to a worker thread. It should be remembered that the function will run in 	//
// a worker thread which might later on be deleted. So SetWaitableTimer() and 			//
// asynchronous receive calls should be avoided unless you are sure that it would not be//
// a problem. It is adviced that if you want the function to run in an alertable thread,//
// then have the callback function queue a work item to alertable thread. Queue work 	//
// items to alertable worker threads for SetWaitableTimer() and async receives. 		//
// One must not make many AsyncWSArecvFrom() calls, as the buffer are non-paged			//
DWORD
APIENTRY
AsyncWSARecvFrom (
	SOCKET		sock,
	PASYNC_SOCKET_DATA	pSockData
	);

#endif // all winsock2 functions

//==========================================================================================================//
//==========================================================================================================//


// forward declarations
struct _WAIT_THREAD_ENTRY;
struct _WT_EVENT_ENTRY;


typedef struct _WT_TIMER_ENTRY {
	LONGLONG		    te_Timeout;

	WORKERFUNCTION	    te_Function;
	PVOID			    te_Context;
	DWORD			    te_ContextSz;
	BOOL			    te_RunInServer;
	
	DWORD			    te_Status;

	#define 		TIMER_INACTIVE  3
	#define 		TIMER_ACTIVE	4

	DWORD			    te_ServerId;
	struct _WAIT_THREAD_ENTRY *teP_wte;	
	LIST_ENTRY		    te_ServerLinks;
	
	LIST_ENTRY		    te_Links;

	BOOL			    te_Flag;		//todo: not used
	DWORD			    te_TimerId;
} WT_TIMER_ENTRY, *PWT_TIMER_ENTRY;

	
typedef struct _WT_WORK_ITEM {
    WORKERFUNCTION      wi_Function;    			// function to call
    PVOID               wi_Context;    				// context passed into function call
	DWORD			    wi_ContextSz;				// size of context, used for allocating
	BOOL			    wi_RunInServer;				// run in wait server thread or get queued to some worker thread

	struct _WT_EVENT_ENTRY	*wiP_ee;
	LIST_ENTRY		wi_ServerLinks;
    LIST_ENTRY      wi_Links;  					//todo not req    // link to next and prev element
} WT_WORK_ITEM, *PWT_WORK_ITEM;

#define WT_EVENT_BINDING 	WT_WORK_ITEM
#define PWT_EVENT_BINDING 	PWT_WORK_ITEM


//
// WT_EVENT_ENTRY
//
typedef struct _WT_EVENT_ENTRY {
	HANDLE			ee_Event;
	BOOL			ee_bManualReset;							// is the event manually reset
	BOOL			ee_bInitialState;						// is the initial state of the event active
	BOOL			ee_bDeleteEvent;						// was the event created as part of createWaitEvent
	
	DWORD			ee_Status;								// current status of the event entry
	BOOL			ee_bHighPriority;
	
	LIST_ENTRY		eeL_wi;
	
	BOOL			ee_bSignalSingle;						// signal single function or multiple functions						// how many functions to activate when event signalled (default:1)
	BOOL			ee_bOwnerSelf;							// the owner if the client which create this event

	INT				ee_ArrayIndex;							// index in the events array if active
	
	DWORD			ee_ServerId;							// Id of server: used while deleting
	struct _WAIT_THREAD_ENTRY *eeP_wte;						// pointer to wait thread entry
	LIST_ENTRY		ee_ServerLinks;							// used by wait server thread
	LIST_ENTRY		ee_Links;								// used by client

	DWORD			ee_RefCount;
	BOOL			ee_bFlag;		//todo: notused								// reserved for use during deletion
	DWORD			ee_EventId;		//todo: remove it, being used only for testing/debugging	

} WT_EVENT_ENTRY, *PWT_EVENT_ENTRY;




// PROTOTYPES OF FUNCTIONS USED IN THIS FILE ONLY
//


// used by client to create a wait event
// context size should be 0 if you are passing a dword instead of a pointer
// if pEvent field is set, then lpName and security attributes are ignored
// if pFunction is NULL, then pContext, dwContextSz, and bRunInServerContext are ignored
PWT_EVENT_ENTRY
APIENTRY
CreateWaitEvent (
	//IN	PWT_EVENT_ENTRY	pEventEntry,					// handle to event entry if initialized by others
	IN	HANDLE			pEvent 				OPT1_1,			// handle to event if already created

	IN	LPSECURITY_ATTRIBUTES lpEventAttributes OPT1_2, 	// pointer to security attributes
	IN	BOOL			bManualReset,
	IN	BOOL			bInitialState,
	IN	LPCTSTR 		lpName 				OPT1_2, 		// pointer to event-object name

	IN  BOOL			bHighPriority,						// create high priority event

	IN	WORKERFUNCTION 	pFunction 			OPT2_1,			// if null, means will be set by other clients
	IN	PVOID 			pContext  			OPT2_1,			// can be null
	IN  DWORD			dwContextSz			OPT2_1,			// size of context: used for allocating context to functions
	IN 	BOOL			bRunInServerContext	OPT2_1			// run in server thread or get dispatched to worker thread
	);



//dwContextSz should be 0 if a dword is being passed. >0 only if pointer to block of that size is being passed.
PWT_EVENT_BINDING
APIENTRY
CreateWaitEventBinding (
	IN	PWT_EVENT_ENTRY	pee,
	IN 	WORKERFUNCTION 	pFunction,
	IN 	PVOID			pContext,
	IN	DWORD			dwContextSz,
	IN	BOOL			bRunInServerContext
	);

	
PWT_TIMER_ENTRY
APIENTRY
CreateWaitTimer (
	IN	WORKERFUNCTION	pFunction,
	IN	PVOID			pContext,
	IN	DWORD			dwContextSz,
	IN	BOOL			bRunInServerContext
	);

DWORD
APIENTRY
DeRegisterWaitEventBindingSelf (
	IN	PWT_EVENT_BINDING	pwiWorkItem
	);

	
DWORD
APIENTRY
DeRegisterWaitEventBinding (
	IN	PWT_EVENT_BINDING	pwiWorkItem
	);


//all the events and timers should be registered with one waitThread server
//todo: change the above requirement
DWORD
APIENTRY
DeRegisterWaitEventsTimers (
	PLIST_ENTRY	pLEvents,	// list of events linked by ee_Links field
	PLIST_ENTRY pLTimers	// list of timers linked by te_Links field:
	//these lists can be a single list entry, or a multiple entry list with a list header entry.
	);

// this should be used only when called within a server thread
DWORD
APIENTRY
DeRegisterWaitEventsTimersSelf (
	IN	PLIST_ENTRY pLEvents,
	IN	PLIST_ENTRY	pLTimers
	);

	
DWORD
APIENTRY
RegisterWaitEventBinding (
	IN	PWT_EVENT_BINDING	pwiWorkItem
	);
	
// Register the client with the wait thread
DWORD
APIENTRY
RegisterWaitEventsTimers (
	IN	PLIST_ENTRY pLEventsToAdd,
	IN	PLIST_ENTRY	pLTimersToAdd
	);

DWORD
APIENTRY
UpdateWaitTimer (
	IN	PWT_TIMER_ENTRY	pte,
	IN	LONGLONG 		*time
	);

VOID
APIENTRY
WTFree (
	PVOID ptr
	);


//used to free wait-event. Should be deallocated using DeRegisterWaitEventsTimers
//This function is to be used only when the events have not been registered
VOID
APIENTRY
WTFreeEvent (
	IN	PWT_EVENT_ENTRY	peeEvent
	);


//used to free wait-timer. Should be deallocated using DeRegisterWaitEventsTimers
//This function is to be used only when the timers have not been registered
VOID
APIENTRY
WTFreeTimer (
	IN PWT_TIMER_ENTRY pteTimer
	);

	
VOID
APIENTRY
DebugPrintWaitWorkerThreads (
	DWORD	dwDebugLevel
	);

#define DEBUGPRINT_FILTER_NONCLIENT_EVENTS	0x2
#define DEBUGPRINT_FILTER_EVENTS			0x4
#define DEBUGPRINT_FILTER_TIMERS			0x8


//
//ERROR VALUES
//
#define ERROR_WAIT_THREAD_UNAVAILABLE 	1

#define ERROR_WT_EVENT_ALREADY_DELETED 	2




#define TIMER_HIGH(time) \
	(((LARGE_INTEGER*)&time)->HighPart)

#define TIMER_LOW(time) \
	(((LARGE_INTEGER*)&time)->LowPart)


#ifdef __cplusplus
}
#endif

#endif // ___ROUTING_RTUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scclient.h ===
#ifndef _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#include "des.h"

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelClient
{
public:
       CSecureChannelClient();
       ~CSecureChannelClient();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       void SetInterface(IComponentAuthenticate *pComponentAuth);
       HRESULT Authenticate(DWORD dwProtocolID);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]);
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
	   BOOL fIsAuthenticated();
private:
       BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
	   BOOL m_TableInit;
	   DESTable m_DesTable;
       IComponentAuthenticate *m_pAuth;
	   DWORD m_dwCertFlags;
#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;
       HRESULT Protocol1();
	   HRESULT Protocol2();
};

#endif // _CSECURECHANNELCLIENT_H_2AD99356-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scarderr.h ===
/*
 scarderr.mc

   Error message codes from the Smart Card Resource Manager
   These messages must be reconciled with winerror.w
   They exist here to provide error messages on pre-Win2K systems.

   30-Jun-97 - DBarlow Created.  */
#ifndef SCARD_S_SUCCESS
//
// =============================
// Facility SCARD Error Messages
// =============================
//
#define SCARD_S_SUCCESS NO_ERROR
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_SCARD                   0x10


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SCARD_F_INTERNAL_ERROR
//
// MessageText:
//
//  An internal consistency check failed.
//
#define SCARD_F_INTERNAL_ERROR           ((DWORD)0x80100001L)

//
// MessageId: SCARD_E_CANCELLED
//
// MessageText:
//
//  The action was cancelled by an SCardCancel request.
//
#define SCARD_E_CANCELLED                ((DWORD)0x80100002L)

//
// MessageId: SCARD_E_INVALID_HANDLE
//
// MessageText:
//
//  The supplied handle was invalid.
//
#define SCARD_E_INVALID_HANDLE           ((DWORD)0x80100003L)

//
// MessageId: SCARD_E_INVALID_PARAMETER
//
// MessageText:
//
//  One or more of the supplied parameters could not be properly interpreted.
//
#define SCARD_E_INVALID_PARAMETER        ((DWORD)0x80100004L)

//
// MessageId: SCARD_E_INVALID_TARGET
//
// MessageText:
//
//  Registry startup information is missing or invalid.
//
#define SCARD_E_INVALID_TARGET           ((DWORD)0x80100005L)

//
// MessageId: SCARD_E_NO_MEMORY
//
// MessageText:
//
//  Not enough memory available to complete this command.
//
#define SCARD_E_NO_MEMORY                ((DWORD)0x80100006L)

//
// MessageId: SCARD_F_WAITED_TOO_LONG
//
// MessageText:
//
//  An internal consistency timer has expired.
//
#define SCARD_F_WAITED_TOO_LONG          ((DWORD)0x80100007L)

//
// MessageId: SCARD_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data buffer to receive returned data is too small for the returned data.
//
#define SCARD_E_INSUFFICIENT_BUFFER      ((DWORD)0x80100008L)

//
// MessageId: SCARD_E_UNKNOWN_READER
//
// MessageText:
//
//  The specified reader name is not recognized.
//
#define SCARD_E_UNKNOWN_READER           ((DWORD)0x80100009L)

//
// MessageId: SCARD_E_TIMEOUT
//
// MessageText:
//
//  The user-specified timeout value has expired.
//
#define SCARD_E_TIMEOUT                  ((DWORD)0x8010000AL)

//
// MessageId: SCARD_E_SHARING_VIOLATION
//
// MessageText:
//
//  The smart card cannot be accessed because of other connections outstanding.
//
#define SCARD_E_SHARING_VIOLATION        ((DWORD)0x8010000BL)

//
// MessageId: SCARD_E_NO_SMARTCARD
//
// MessageText:
//
//  The operation requires a Smart Card, but no Smart Card is currently in the device.
//
#define SCARD_E_NO_SMARTCARD             ((DWORD)0x8010000CL)

//
// MessageId: SCARD_E_UNKNOWN_CARD
//
// MessageText:
//
//  The specified smart card name is not recognized.
//
#define SCARD_E_UNKNOWN_CARD             ((DWORD)0x8010000DL)

//
// MessageId: SCARD_E_CANT_DISPOSE
//
// MessageText:
//
//  The system could not dispose of the media in the requested manner.
//
#define SCARD_E_CANT_DISPOSE             ((DWORD)0x8010000EL)

//
// MessageId: SCARD_E_PROTO_MISMATCH
//
// MessageText:
//
//  The requested protocols are incompatible with the protocol currently in use with the smart card.
//
#define SCARD_E_PROTO_MISMATCH           ((DWORD)0x8010000FL)

//
// MessageId: SCARD_E_NOT_READY
//
// MessageText:
//
//  The reader or smart card is not ready to accept commands.
//
#define SCARD_E_NOT_READY                ((DWORD)0x80100010L)

//
// MessageId: SCARD_E_INVALID_VALUE
//
// MessageText:
//
//  One or more of the supplied parameters values could not be properly interpreted.
//
#define SCARD_E_INVALID_VALUE            ((DWORD)0x80100011L)

//
// MessageId: SCARD_E_SYSTEM_CANCELLED
//
// MessageText:
//
//  The action was cancelled by the system, presumably to log off or shut down.
//
#define SCARD_E_SYSTEM_CANCELLED         ((DWORD)0x80100012L)

//
// MessageId: SCARD_F_COMM_ERROR
//
// MessageText:
//
//  An internal communications error has been detected.
//
#define SCARD_F_COMM_ERROR               ((DWORD)0x80100013L)

//
// MessageId: SCARD_F_UNKNOWN_ERROR
//
// MessageText:
//
//  An internal error has been detected, but the source is unknown.
//
#define SCARD_F_UNKNOWN_ERROR            ((DWORD)0x80100014L)

//
// MessageId: SCARD_E_INVALID_ATR
//
// MessageText:
//
//  An ATR obtained from the registry is not a valid ATR string.
//
#define SCARD_E_INVALID_ATR              ((DWORD)0x80100015L)

//
// MessageId: SCARD_E_NOT_TRANSACTED
//
// MessageText:
//
//  An attempt was made to end a non-existent transaction.
//
#define SCARD_E_NOT_TRANSACTED           ((DWORD)0x80100016L)

//
// MessageId: SCARD_E_READER_UNAVAILABLE
//
// MessageText:
//
//  The specified reader is not currently available for use.
//
#define SCARD_E_READER_UNAVAILABLE       ((DWORD)0x80100017L)

//
// MessageId: SCARD_P_SHUTDOWN
//
// MessageText:
//
//  The operation has been aborted to allow the server application to exit.
//
#define SCARD_P_SHUTDOWN                 ((DWORD)0x80100018L)

//
// MessageId: SCARD_E_PCI_TOO_SMALL
//
// MessageText:
//
//  The PCI Receive buffer was too small.
//
#define SCARD_E_PCI_TOO_SMALL            ((DWORD)0x80100019L)

//
// MessageId: SCARD_E_READER_UNSUPPORTED
//
// MessageText:
//
//  The reader driver does not meet minimal requirements for support.
//
#define SCARD_E_READER_UNSUPPORTED       ((DWORD)0x8010001AL)

//
// MessageId: SCARD_E_DUPLICATE_READER
//
// MessageText:
//
//  The reader driver did not produce a unique reader name.
//
#define SCARD_E_DUPLICATE_READER         ((DWORD)0x8010001BL)

//
// MessageId: SCARD_E_CARD_UNSUPPORTED
//
// MessageText:
//
//  The smart card does not meet minimal requirements for support.
//
#define SCARD_E_CARD_UNSUPPORTED         ((DWORD)0x8010001CL)

//
// MessageId: SCARD_E_NO_SERVICE
//
// MessageText:
//
//  The Smart card resource manager is not running.
//
#define SCARD_E_NO_SERVICE               ((DWORD)0x8010001DL)

//
// MessageId: SCARD_E_SERVICE_STOPPED
//
// MessageText:
//
//  The Smart card resource manager has shut down.
//
#define SCARD_E_SERVICE_STOPPED          ((DWORD)0x8010001EL)

//
// MessageId: SCARD_E_UNEXPECTED
//
// MessageText:
//
//  An unexpected card error has occurred.
//
#define SCARD_E_UNEXPECTED               ((DWORD)0x8010001FL)

//
// MessageId: SCARD_E_ICC_INSTALLATION
//
// MessageText:
//
//  No Primary Provider can be found for the smart card.
//
#define SCARD_E_ICC_INSTALLATION         ((DWORD)0x80100020L)

//
// MessageId: SCARD_E_ICC_CREATEORDER
//
// MessageText:
//
//  The requested order of object creation is not supported.
//
#define SCARD_E_ICC_CREATEORDER          ((DWORD)0x80100021L)

//
// MessageId: SCARD_E_UNSUPPORTED_FEATURE
//
// MessageText:
//
//  This smart card does not support the requested feature.
//
#define SCARD_E_UNSUPPORTED_FEATURE      ((DWORD)0x80100022L)

//
// MessageId: SCARD_E_DIR_NOT_FOUND
//
// MessageText:
//
//  The identified directory does not exist in the smart card.
//
#define SCARD_E_DIR_NOT_FOUND            ((DWORD)0x80100023L)

//
// MessageId: SCARD_E_FILE_NOT_FOUND
//
// MessageText:
//
//  The identified file does not exist in the smart card.
//
#define SCARD_E_FILE_NOT_FOUND           ((DWORD)0x80100024L)

//
// MessageId: SCARD_E_NO_DIR
//
// MessageText:
//
//  The supplied path does not represent a smart card directory.
//
#define SCARD_E_NO_DIR                   ((DWORD)0x80100025L)

//
// MessageId: SCARD_E_NO_FILE
//
// MessageText:
//
//  The supplied path does not represent a smart card file.
//
#define SCARD_E_NO_FILE                  ((DWORD)0x80100026L)

//
// MessageId: SCARD_E_NO_ACCESS
//
// MessageText:
//
//  Access is denied to this file.
//
#define SCARD_E_NO_ACCESS                ((DWORD)0x80100027L)

//
// MessageId: SCARD_E_WRITE_TOO_MANY
//
// MessageText:
//
//  An attempt was made to write more data than would fit in the target object.
//
#define SCARD_E_WRITE_TOO_MANY           ((DWORD)0x80100028L)

//
// MessageId: SCARD_E_BAD_SEEK
//
// MessageText:
//
//  There was an error trying to set the smart card file object pointer.
//
#define SCARD_E_BAD_SEEK                 ((DWORD)0x80100029L)

//
// MessageId: SCARD_E_INVALID_CHV
//
// MessageText:
//
//  The supplied PIN is incorrect.
//
#define SCARD_E_INVALID_CHV              ((DWORD)0x8010002AL)

//
// MessageId: SCARD_E_UNKNOWN_RES_MNG
//
// MessageText:
//
//  An unrecognized error code was returned from a layered component.
//
#define SCARD_E_UNKNOWN_RES_MNG          ((DWORD)0x8010002BL)

//
// MessageId: SCARD_E_NO_SUCH_CERTIFICATE
//
// MessageText:
//
//  The requested certificate does not exist.
//
#define SCARD_E_NO_SUCH_CERTIFICATE      ((DWORD)0x8010002CL)

//
// MessageId: SCARD_E_CERTIFICATE_UNAVAILABLE
//
// MessageText:
//
//  The requested certificate could not be obtained.
//
#define SCARD_E_CERTIFICATE_UNAVAILABLE  ((DWORD)0x8010002DL)

//
// MessageId: SCARD_E_NO_READERS_AVAILABLE
//
// MessageText:
//
//  Cannot find a smart card reader.
//
#define SCARD_E_NO_READERS_AVAILABLE     ((DWORD)0x8010002EL)

//
// MessageId: SCARD_E_COMM_DATA_LOST
//
// MessageText:
//
//  A communications error with the smart card has been detected.  Retry the operation.
//
#define SCARD_E_COMM_DATA_LOST           ((DWORD)0x8010002FL)

//
// These are warning codes.
//
//
// MessageId: SCARD_W_UNSUPPORTED_CARD
//
// MessageText:
//
//  The reader cannot communicate with the smart card, due to ATR configuration conflicts.
//
#define SCARD_W_UNSUPPORTED_CARD         ((DWORD)0x80100065L)

//
// MessageId: SCARD_W_UNRESPONSIVE_CARD
//
// MessageText:
//
//  The smart card is not responding to a reset.
//
#define SCARD_W_UNRESPONSIVE_CARD        ((DWORD)0x80100066L)

//
// MessageId: SCARD_W_UNPOWERED_CARD
//
// MessageText:
//
//  Power has been removed from the smart card, so that further communication is not possible.
//
#define SCARD_W_UNPOWERED_CARD           ((DWORD)0x80100067L)

//
// MessageId: SCARD_W_RESET_CARD
//
// MessageText:
//
//  The smart card has been reset, so any shared state information is invalid.
//
#define SCARD_W_RESET_CARD               ((DWORD)0x80100068L)

//
// MessageId: SCARD_W_REMOVED_CARD
//
// MessageText:
//
//  The smart card has been removed, so that further communication is not possible.
//
#define SCARD_W_REMOVED_CARD             ((DWORD)0x80100069L)

//
// MessageId: SCARD_W_SECURITY_VIOLATION
//
// MessageText:
//
//  Access was denied because of a security violation.
//
#define SCARD_W_SECURITY_VIOLATION       ((DWORD)0x8010006AL)

//
// MessageId: SCARD_W_WRONG_CHV
//
// MessageText:
//
//  The card cannot be accessed because the wrong PIN was presented.
//
#define SCARD_W_WRONG_CHV                ((DWORD)0x8010006BL)

//
// MessageId: SCARD_W_CHV_BLOCKED
//
// MessageText:
//
//  The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
//
#define SCARD_W_CHV_BLOCKED              ((DWORD)0x8010006CL)

//
// MessageId: SCARD_W_EOF
//
// MessageText:
//
//  The end of the smart card file has been reached.
//
#define SCARD_W_EOF                      ((DWORD)0x8010006DL)

//
// MessageId: SCARD_W_CANCELLED_BY_USER
//
// MessageText:
//
//  The action was cancelled by the user.
//
#define SCARD_W_CANCELLED_BY_USER        ((DWORD)0x8010006EL)

#endif // SCARD_S_SUCCESS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Schedule.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    schedule.h

Abstract:

    This file defines a common schedule structure for use by various NT
    components.

--*/

#ifndef _SCHEDULE_H_
#define _SCHEDULE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The DS and FRS use the same structure to represent different schedules.
// The DS uses a 15-minute polling schedule. FRS uses a 60-minute
// start/stop schedule. Hence, the schedule for the system volume is
// a special case because we only have the DS schedule to work from.
// We will work around this problem by treating the 15
// -minute polling schedule as a 60-minute start/stop schedule.
// Replication is enabled for any hour that has any of the four
// 15-minute bits set.
//
// When the ReplicationSchedule is not present the default is
// "always replicate."
//

//
// Only the interval schedule is currently implemented. Others are ignored.
//
#define SCHEDULE_INTERVAL       0 // schedule as understood by NT5
#define SCHEDULE_BANDWIDTH      1 // bandwidth as understood by NT5
#define SCHEDULE_PRIORITY       2 // priority as understood by NT5

//
// Schedule Header
//
// Each schedule blob begins with n array of schedule headers that
// specify the number and type of schedules contained in the blob.
//
typedef struct _SCHEDULE_HEADER {
    ULONG   Type;       // one of the SCHEDULE_ ordinals
    ULONG   Offset;     // offset from start of schedule structure
} SCHEDULE_HEADER, *PSCHEDULE_HEADER;

//
// Schedule
//
typedef struct _SCHEDULE {
    ULONG           Size;           // inclusive size in bytes
    ULONG           Bandwidth;
    ULONG           NumberOfSchedules;
    SCHEDULE_HEADER Schedules[1];
} SCHEDULE, *PSCHEDULE;
// The above structure is followed by the Data buffer and the
// SCHEDULE_HEADER contains offsets to refer to the appropriate
// parts in the data buffer.

#define SCHEDULE_DATA_ENTRIES   (7 * 24)    // 7 days X 24 hours

#ifdef __cplusplus
}
#endif

#endif // _SCHEDULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scardsrv.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardsrv

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardsrv.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scardmgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardmgr

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardmgr.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scode.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    scode.h

Abstract:

    Obsolete SCODE header file.  Use WINERROR.H

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef  _WINERROR_
#include <winerror.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SCardSsp_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 01 16:58:17 1999
 */
/* Compiler settings for scardssp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IByteBuffer,0xE126F8FE,0xA7AF,0x11D0,0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9);


MIDL_DEFINE_GUID(IID, IID_ISCardTypeConv,0x53B6AA63,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardCmd,0xD5778AE3,0x43DE,0x11D0,0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardISO7816,0x53B6AA68,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCard,0x1461AAC3,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardDatabase,0x1461AAC8,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardLocate,0x1461AACD,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, LIBID_SCARDSSPLib,0x82C38704,0x19F1,0x11D3,0xA1,0x1F,0x00,0xC0,0x4F,0x79,0xF8,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_CByteBuffer,0xE126F8FF,0xA7AF,0x11D0,0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardTypeConv,0x53B6AA67,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardCmd,0xD5778AE7,0x43DE,0x11D0,0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardISO7816,0x53B6AA6C,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCard,0x1461AAC7,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardDatabase,0x1461AACC,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardLocate,0x1461AAD1,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 01 16:58:17 1999
 */
/* Compiler settings for scardssp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IByteBuffer,0xE126F8FE,0xA7AF,0x11D0,0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9);


MIDL_DEFINE_GUID(IID, IID_ISCardTypeConv,0x53B6AA63,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardCmd,0xD5778AE3,0x43DE,0x11D0,0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardISO7816,0x53B6AA68,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCard,0x1461AAC3,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardDatabase,0x1461AAC8,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, IID_ISCardLocate,0x1461AACD,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(IID, LIBID_SCARDSSPLib,0x82C38704,0x19F1,0x11D3,0xA1,0x1F,0x00,0xC0,0x4F,0x79,0xF8,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_CByteBuffer,0xE126F8FF,0xA7AF,0x11D0,0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardTypeConv,0x53B6AA67,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardCmd,0xD5778AE7,0x43DE,0x11D0,0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardISO7816,0x53B6AA6C,0x3F56,0x11D0,0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCard,0x1461AAC7,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardDatabase,0x1461AACC,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CSCardLocate,0x1461AAD1,0x6810,0x11D0,0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scesvc.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    scesvc.h

Abstract:

    Wrapper APIs for services

Revision History:

--*/

#ifndef _scesvc_
#define _scesvc_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _SCE_SHARED_HEADER
#define _SCE_SHARED_HEADER

typedef DWORD                   SCESTATUS;

#define SCESTATUS_SUCCESS              0L
#define SCESTATUS_INVALID_PARAMETER    1L
#define SCESTATUS_RECORD_NOT_FOUND     2L
#define SCESTATUS_INVALID_DATA         3L
#define SCESTATUS_OBJECT_EXIST         4L
#define SCESTATUS_BUFFER_TOO_SMALL     5L
#define SCESTATUS_PROFILE_NOT_FOUND    6L
#define SCESTATUS_BAD_FORMAT           7L
#define SCESTATUS_NOT_ENOUGH_RESOURCE  8L
#define SCESTATUS_ACCESS_DENIED        9L
#define SCESTATUS_CANT_DELETE          10L
#define SCESTATUS_PREFIX_OVERFLOW      11L
#define SCESTATUS_OTHER_ERROR          12L
#define SCESTATUS_ALREADY_RUNNING      13L
#define SCESTATUS_SERVICE_NOT_SUPPORT  14L
#define SCESTATUS_MOD_NOT_FOUND        15L
#define SCESTATUS_EXCEPTION_IN_SERVER  16L
#define SCESTATUS_NO_TEMPLATE_GIVEN    17L
#define SCESTATUS_NO_MAPPING           18L
#define SCESTATUS_TRUST_FAIL           19L

typedef struct _SCESVC_CONFIGURATION_LINE_ {

    LPTSTR  Key;
    LPTSTR  Value;
    DWORD   ValueLen; // number of bytes

} SCESVC_CONFIGURATION_LINE, *PSCESVC_CONFIGURATION_LINE;

typedef struct _SCESVC_CONFIGURATION_INFO_ {

    DWORD   Count;
    PSCESVC_CONFIGURATION_LINE Lines;

} SCESVC_CONFIGURATION_INFO, *PSCESVC_CONFIGURATION_INFO;

typedef PVOID SCE_HANDLE;
typedef ULONG SCE_ENUMERATION_CONTEXT, *PSCE_ENUMERATION_CONTEXT;

typedef enum _SCESVC_INFO_TYPE {

    SceSvcConfigurationInfo,
    SceSvcMergedPolicyInfo,
    SceSvcAnalysisInfo,
    SceSvcInternalUse                   // !!!do not use this type!!!

} SCESVC_INFO_TYPE;

#define SCE_ROOT_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit")

#define SCE_ROOT_SERVICE_PATH   \
            SCE_ROOT_PATH TEXT("\\SvcEngs")

#endif

typedef PVOID SCESVC_HANDLE;

typedef struct _SCESVC_ANALYSIS_LINE_ {

    LPTSTR  Key;
    PBYTE   Value;
    DWORD   ValueLen; // number of bytes

} SCESVC_ANALYSIS_LINE, *PSCESVC_ANALYSIS_LINE;

typedef struct _SCESVC_ANALYSIS_INFO_ {

    DWORD   Count;
    PSCESVC_ANALYSIS_LINE Lines;

} SCESVC_ANALYSIS_INFO, *PSCESVC_ANALYSIS_INFO;


#define SCESVC_ENUMERATION_MAX  100L

typedef
SCESTATUS
(CALLBACK *PFSCE_QUERY_INFO)(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
);


typedef
SCESTATUS
(CALLBACK *PFSCE_SET_INFO)(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
);

typedef
SCESTATUS
(CALLBACK *PFSCE_FREE_INFO)(
    IN PVOID                pvServiceInfo
);

#define SCE_LOG_LEVEL_ALWAYS      0
#define SCE_LOG_LEVEL_ERROR       1
#define SCE_LOG_LEVEL_DETAIL      2
#define SCE_LOG_LEVEL_DEBUG       3

typedef
SCESTATUS
(CALLBACK *PFSCE_LOG_INFO)(
    IN INT ErrLevel,
    IN DWORD  Win32rc,
    IN LPTSTR pErrFmt,
    ...
);

typedef struct _SCESVC_CALLBACK_INFO_ {

    SCE_HANDLE              sceHandle;
    PFSCE_QUERY_INFO        pfQueryInfo;
    PFSCE_SET_INFO          pfSetInfo;
    PFSCE_FREE_INFO         pfFreeInfo;
    PFSCE_LOG_INFO          pfLogInfo;

} SCESVC_CALLBACK_INFO, *PSCESVC_CALLBACK_INFO;


typedef
SCESTATUS
(*PF_ConfigAnalyzeService)(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo
);

typedef
SCESTATUS
(*PF_UpdateService)(
    IN PSCESVC_CALLBACK_INFO      pSceCbInfo,
    IN PSCESVC_CONFIGURATION_INFO ServiceInfo
);

#ifdef __cplusplus
}
#endif

#endif

//#if _WIN32_WINNT==0x0500
//
// headers for extension snap-ins
// only define this for NT5
//

#ifndef _UUIDS_SCE_ATTACHMENT_
#define _UUIDS_SCE_ATTACHMENT_

#include "rpc.h"
#include "rpcndr.h"

//#ifndef __RPCNDR_H_VERSION__
//#error this stub requires an updated version of <rpcndr.h>
//#endif // __RPCNDR_H_VERSION__

#if __RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440

#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) interface
#endif

#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C" {
#endif

#define struuidNodetypeSceTemplateServices      "{24a7f717-1f0c-11d1-affb-00c04fb984f9}"

#define lstruuidNodetypeSceTemplateServices      L"{24a7f717-1f0c-11d1-affb-00c04fb984f9}"

const GUID cNodetypeSceTemplateServices = { 0x24a7f717, 0x1f0c, 0x11d1, { 0xaf, 0xfb, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

#define struuidNodetypeSceAnalysisServices      "{678050c7-1ff8-11d1-affb-00c04fb984f9}"

#define lstruuidNodetypeSceAnalysisServices      L"{678050c7-1ff8-11d1-affb-00c04fb984f9}"

const GUID cNodetypeSceAnalysisServices = { 0x678050c7, 0x1ff8, 0x11d1, { 0xaf, 0xfb, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };


#define struuidNodetypeSceEventLog      "{2ce06698-4bf3-11d1-8c30-00c04fb984f9}"
#define lstruuidNodetypeSceEventLog      L"{2ce06698-4bf3-11d1-8c30-00c04fb984f9}"
const GUID cNodetypeSceEventLog = { 0x2ce06698, 0x4bf3, 0x11d1, {0x8c, 0x30, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

typedef PSCESVC_CONFIGURATION_INFO __RPC_FAR *LPSCESVC_CONFIGURATION_INFO;
typedef PSCESVC_ANALYSIS_INFO __RPC_FAR *LPSCESVC_ANALYSIS_INFO;

#define CCF_SCESVC_ATTACHMENT        L"CCF_SCESVC_ATTACHMENT"
#define CCF_SCESVC_ATTACHMENT_DATA   L"CCF_SCESVC_ATTACHMENT_DATA"

//
// implemented by service attachment
//
typedef interface ISceSvcAttachmentPersistInfo ISceSvcAttachmentPersistInfo;
typedef ISceSvcAttachmentPersistInfo __RPC_FAR *LPSCESVCATTACHMENTPERSISTINFO;

//extern const IID IID_ISceSvcAttachmentPersistInfo;
const IID IID_ISceSvcAttachmentPersistInfo = {0x6d90e0d0, 0x200d, 0x11d1, {0xaf, 0xfb, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9}};

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6d90e0d0-200d-11d1-affb-00c04fb984f9")

    ISceSvcAttachmentPersistInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Save(
            /* [in] */  LPTSTR lpTemplateName,
            /* [out] */ SCESVC_HANDLE *scesvcHandle,
            /* [out] */ PVOID *ppvData,
            /* [out] */ PBOOL pbOverwriteAll ) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsDirty(
            /* [in] */  LPTSTR lpTemplateName ) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FreeBuffer(
            /* [in] */ PVOID pvData) = 0;

    };

#else

    // c style interface

    typedef struct ISceSvcAttachmentPersistInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ISceSvcAttachmentPersistInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ISceSvcAttachmentPersistInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ISceSvcAttachmentPersistInfo __RPC_FAR * This);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            /* [in] */ ISceSvcAttachmentPersistInfo __RPC_FAR * This,
            /* [in] */ LPTSTR lpTemplateName,
            /* [in] */ SCESVC_HANDLE scesvcHandle,
            /* [out] */ PVOID *ppvData,
            /* [in out] */ PBOOL pbOverwriteAll );

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )(
            /* [in] */ ISceSvcAttachmentPersistInfo __RPC_FAR * This,
            /* [in] */ PVOID pvData);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            /* [in] */ ISceSvcAttachmentPersistInfo __RPC_FAR * This,
            /* [in] */ LPTSTR lpTemplateName );

        END_INTERFACE
    } ISceSvcAttachmentPersistInfoVtbl;

    interface ISceSvcAttachmentPersistInfo
    {
        CONST_VTBL struct ISceSvcAttachmentPersistInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IData_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISceSvcAttachmentPersistInfo_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISceSvcAttachmentPersistInfo_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISceSvcAttachmentPersistInfo_Save(This, lpTemplateName, scesvcHandle, ppvData, pbOverwriteAll) \
    (This)->lpVtbl -> Save(lpTemplateName, scesvcHandle, ppvData, pbOverwriteAll)

#define ISceSvcAttachmentPersistInfo_FreeBuffer(This,pvData)    \
    (This)->lpVtbl -> FreeBuffer(pvData)

#define ISceSvcAttachmentPersistInfo_CloseHandle(This, lpTemplateName)  \
    (This)->lpVtbl -> IsDirty(lpTemplateName)

#endif /* COBJMACROS */

#endif

//
// implemented by SecEdit
//
typedef interface ISceSvcAttachmentData ISceSvcAttachmentData;
typedef ISceSvcAttachmentData __RPC_FAR *LPSCESVCATTACHMENTDATA;

//extern const IID IID_ISceSvcAttachmentData;
const IID IID_ISceSvcAttachmentData = {0x17c35fde, 0x200d, 0x11d1, {0xaf, 0xfb, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9}};

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("17c35fde-200d-11d1-affb-00c04fb984f9")

    ISceSvcAttachmentData  : public IUnknown
    {
    public:

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetData(
            /* [in] */ SCESVC_HANDLE scesvcHandle,
            /* [in] */ SCESVC_INFO_TYPE sceType,
            /* [out] */ PVOID *ppvData,
            /* [in out] */ PSCE_ENUMERATION_CONTEXT psceEnumHandle ) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
            /* [in] */ LPCTSTR lpServiceName,
            /* [in] */ LPCTSTR lpTemplateName,
            /* [in] */ LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
            /* [out] */ SCESVC_HANDLE *pscesvcHandle) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FreeBuffer(
            /* [in] */ PVOID pvData) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CloseHandle(
            /* [in] */ SCESVC_HANDLE scesvcHandle) = 0;

    };
#else
    // c style interface

    typedef struct ISceSvcAttachmentDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ISceSvcAttachmentData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ISceSvcAttachmentData __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ISceSvcAttachmentData __RPC_FAR * This);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )(
            /* [in] */ ISceSvcAttachmentData __RPC_FAR * This,
            /* [in] */ LPCTSTR lpServiceName,
            /* [in] */ LPCTSTR lpTemplateName,
            /* [in] */ LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
            /* [out] */ SCESVC_HANDLE *pscesvcHandle);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )(
            /* [in] */ ISceSvcAttachmentData __RPC_FAR * This,
            /* [in] */ SCESVC_HANDLE scesvcHandle,
            /* [in] */ SCESVC_INFO_TYPE sceType,
            /* [out] */ PVOID *ppvData,
            /* [in out] */ PSCE_ENUMERATION_CONTEXT psceEnumHandle );

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )(
            /* [in] */ ISceSvcAttachmentData __RPC_FAR * This,
            /* [in] */ PVOID pvData);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseHandle )(
            /* [in] */ ISceSvcAttachmentData __RPC_FAR * This,
            /* [in] */ SCESVC_HANDLE scesvcHandle);

        END_INTERFACE
    } ISceSvcAttachmentDataVtbl;

    interface ISceSvcAttachmentData
    {
        CONST_VTBL struct ISceSvcAttachmentDataVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IData_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISceSvcAttachmentData_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define ISceSvcAttachmentData_Release(This) \
    (This)->lpVtbl -> Release(This)


#define ISceSvcAttachmentData_Initialize(This, lpServiceName, lpTemplateName, lpSceSvcPersistInfo, pscesvcHandle)    \
    (This)->lpVtbl -> Initialize(lpServiceName, lpTemplateName, lpSceSvcPersistInfo, pscesvcHandle)

#define ISceSvcAttachmentData_GetData(This, scesvcHandle, sceType, ppvData, psceEnumHandle) \
    (This)->lpVtbl -> GetData(scesvcHandle, sceType, ppvData, psceEnumHandle)

#define ISceSvcAttachmentData_FreeBuffer(This,pvData)   \
    (This)->lpVtbl -> FreeBuffer(pvData)

#define ISceSvcAttachmentData_CloseHandle(This, scesvcHandle)  \
    (This)->lpVtbl -> CloseHandle(scesvcHandle)

#endif /* COBJMACROS */


#endif


#ifdef __cplusplus
}
#endif

#endif // _UUIDS_COMPUTER_MANAGEMENT_

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SChannel.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       schannel.h
//
//  Contents:   Public Definitions for SCHANNEL Security Provider
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------



#ifndef __SCHANNEL_H__
#define __SCHANNEL_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <wincrypt.h>


//
// Security package names.
//

#define UNISP_NAME_A    "Microsoft Unified Security Protocol Provider"
#define UNISP_NAME_W    L"Microsoft Unified Security Protocol Provider"

#define SSL2SP_NAME_A    "Microsoft SSL 2.0"
#define SSL2SP_NAME_W    L"Microsoft SSL 2.0"

#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
#define SSL3SP_NAME_W    L"Microsoft SSL 3.0"

#define TLS1SP_NAME_A    "Microsoft TLS 1.0"
#define TLS1SP_NAME_W    L"Microsoft TLS 1.0"

#define PCT1SP_NAME_A    "Microsoft PCT 1.0"
#define PCT1SP_NAME_W    L"Microsoft PCT 1.0"


#ifdef UNICODE

#define UNISP_NAME  UNISP_NAME_W
#define PCT1SP_NAME  PCT1SP_NAME_W
#define SSL2SP_NAME  SSL2SP_NAME_W
#define SSL3SP_NAME  SSL3SP_NAME_W
#define TLS1SP_NAME  TLS1SP_NAME_W

#else

#define UNISP_NAME  UNISP_NAME_A
#define PCT1SP_NAME  PCT1SP_NAME_A
#define SSL2SP_NAME  SSL2SP_NAME_A
#define SSL3SP_NAME  SSL3SP_NAME_A
#define TLS1SP_NAME  TLS1SP_NAME_A

#endif


//
// RPC constants.
//

#define UNISP_RPC_ID    14


//
// QueryContextAttributes/QueryCredentialsAttribute extensions
//

#define SECPKG_ATTR_ISSUER_LIST          0x50   // (OBSOLETE) returns SecPkgContext_IssuerListInfo
#define SECPKG_ATTR_REMOTE_CRED          0x51   // (OBSOLETE) returns SecPkgContext_RemoteCredentialInfo
#define SECPKG_ATTR_LOCAL_CRED           0x52   // (OBSOLETE) returns SecPkgContext_LocalCredentialInfo
#define SECPKG_ATTR_REMOTE_CERT_CONTEXT  0x53   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_LOCAL_CERT_CONTEXT   0x54   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_ROOT_STORE           0x55   // returns HCERTCONTEXT to the root store
#define SECPKG_ATTR_SUPPORTED_ALGS       0x56   // returns SecPkgCred_SupportedAlgs
#define SECPKG_ATTR_CIPHER_STRENGTHS     0x57   // returns SecPkgCred_CipherStrengths
#define SECPKG_ATTR_SUPPORTED_PROTOCOLS  0x58   // returns SecPkgCred_SupportedProtocols
#define SECPKG_ATTR_ISSUER_LIST_EX       0x59   // returns SecPkgContext_IssuerListInfoEx
#define SECPKG_ATTR_CONNECTION_INFO      0x5a   // returns SecPkgContext_ConnectionInfo
#define SECPKG_ATTR_EAP_KEY_BLOCK        0x5b   // returns SecPkgContext_EapKeyBlock
#define SECPKG_ATTR_MAPPED_CRED_ATTR     0x5c   // returns SecPkgContext_MappedCredAttr
#define SECPKG_ATTR_CACHE_INFO_ATTR      0x5d   // returns SecPkgCred_CacheInfo


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_IssuerListInfo
{
    DWORD   cbIssuerList;
    PBYTE   pIssuerList;
} SecPkgContext_IssuerListInfo, *PSecPkgContext_IssuerListInfo;


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_RemoteCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_RemoteCredentialInfo, *PSecPkgContext_RemoteCredentialInfo;

typedef SecPkgContext_RemoteCredentialInfo SecPkgContext_RemoteCredenitalInfo, *PSecPkgContext_RemoteCredenitalInfo;

#define RCRED_STATUS_NOCRED          0x00000000
#define RCRED_CRED_EXISTS            0x00000001
#define RCRED_STATUS_UNKNOWN_ISSUER  0x00000002


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_LocalCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_LocalCredentialInfo, *PSecPkgContext_LocalCredentialInfo;

typedef SecPkgContext_LocalCredentialInfo SecPkgContext_LocalCredenitalInfo, *PSecPkgContext_LocalCredenitalInfo;

#define LCRED_STATUS_NOCRED          0x00000000
#define LCRED_CRED_EXISTS            0x00000001
#define LCRED_STATUS_UNKNOWN_ISSUER  0x00000002


typedef struct _SecPkgCred_SupportedAlgs
{
    DWORD		cSupportedAlgs;
    ALG_ID		*palgSupportedAlgs;
} SecPkgCred_SupportedAlgs, *PSecPkgCred_SupportedAlgs;


typedef struct _SecPkgCred_CipherStrengths
{
    DWORD       dwMinimumCipherStrength;
    DWORD       dwMaximumCipherStrength;
} SecPkgCred_CipherStrengths, *PSecPkgCred_CipherStrengths;


typedef struct _SecPkgCred_SupportedProtocols
{
    DWORD      	grbitProtocol;
} SecPkgCred_SupportedProtocols, *PSecPkgCred_SupportedProtocols;


typedef struct _SecPkgContext_IssuerListInfoEx
{
    PCERT_NAME_BLOB   	aIssuers;
    DWORD           	cIssuers;
} SecPkgContext_IssuerListInfoEx, *PSecPkgContext_IssuerListInfoEx;


typedef struct _SecPkgContext_ConnectionInfo
{
    DWORD   dwProtocol;
    ALG_ID  aiCipher;
    DWORD   dwCipherStrength;
    ALG_ID  aiHash;
    DWORD   dwHashStrength;
    ALG_ID  aiExch;
    DWORD   dwExchStrength;
} SecPkgContext_ConnectionInfo, *PSecPkgContext_ConnectionInfo;


typedef struct _SecPkgContext_EapKeyBlock
{
    BYTE    rgbKeys[128];
    BYTE    rgbIVs[64];
} SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;


typedef struct _SecPkgContext_MappedCredAttr
{
    DWORD   dwAttribute;
    PVOID   pvBuffer;
} SecPkgContext_MappedCredAttr, *PSecPkgContext_MappedCredAttr;


typedef struct _SecPkgCred_CacheInfo
{
    DWORD cbBytesCommitted;
    DWORD cMaxCacheEntries;
    DWORD cEntries;
    DWORD cUsed;
    DWORD cOrphans;
    DWORD cExpiredOrphans;
    DWORD cExpiredAbortedOrphans;
    DWORD cHandshaking;
} SecPkgCred_CacheInfo, *PSecPkgCred_CacheInfo;


//
// Schannel credentials data structure.
//

#define SCH_CRED_V1              0x00000001
#define SCH_CRED_V2              0x00000002  // for legacy code
#define SCH_CRED_VERSION         0x00000002  // for legacy code
#define SCH_CRED_V3              0x00000003  // for legacy code
#define SCHANNEL_CRED_VERSION    0x00000004


struct _HMAPPER;

typedef struct _SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           reserved;
} SCHANNEL_CRED, *PSCHANNEL_CRED;


//+-------------------------------------------------------------------------
// Flags for use with SCHANNEL_CRED
//
// SCH_CRED_NO_SYSTEM_MAPPER
//      This flag is intended for use by server applications only. If this
//      flag is set, then schannel does *not* attempt to map received client
//      certificate chains to an NT user account using the built-in system
//      certificate mapper.This flag is ignored by non-NT5 versions of
//      schannel.
//
// SCH_CRED_NO_SERVERNAME_CHECK
//      This flag is intended for use by client applications only. If this
//      flag is set, then when schannel validates the received server
//      certificate chain, is does *not* compare the passed in target name
//      with the subject name embedded in the certificate. This flag is
//      ignored by non-NT5 versions of schannel. This flag is also ignored
//      if the SCH_CRED_MANUAL_CRED_VALIDATION flag is set.
//
// SCH_CRED_MANUAL_CRED_VALIDATION
//      This flag is intended for use by client applications only. If this
//      flag is set, then schannel will *not* automatically attempt to
//      validate the received server certificate chain. This flag is
//      ignored by non-NT5 versions of schannel, but all client applications
//      that wish to validate the certificate chain themselves should
//      specify this flag, so that there's at least a chance they'll run
//      correctly on NT5.
//
// SCH_CRED_NO_DEFAULT_CREDS
//      This flag is intended for use by client applications only. If this
//      flag is set, and the server requests client authentication, then
//      schannel will *not* attempt to automatically acquire a suitable
//      default client certificate chain. This flag is ignored by non-NT5
//      versions of schannel, but all client applications that wish to
//      manually specify their certicate chains should specify this flag,
//      so that there's at least a chance they'll run correctly on NT5.
//
// SCH_CRED_AUTO_CRED_VALIDATION
//      This flag is the opposite of SCH_CRED_MANUAL_CRED_VALIDATION.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_USE_DEFAULT_CREDS
//      This flag is the opposite of SCH_CRED_NO_DEFAULT_CREDS.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_REVOCATION_CHECK_END_CERT
// SCH_CRED_REVOCATION_CHECK_CHAIN
// SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
//      These flags specify that when schannel automatically validates a
//      received certificate chain, some or all of the certificates are to
//      be checked for revocation. Only one of these flags may be specified.
//      See the CertGetCertificateChain function. These flags are ignored by
//      non-NT5 versions of schannel.
//
// SCH_CRED_IGNORE_NO_REVOCATION_CHECK
// SCH_CRED_IGNORE_REVOCATION_OFFLINE
//      These flags instruct schannel to ignore the
//      CRYPT_E_NO_REVOCATION_CHECK and CRYPT_E_REVOCATION_OFFLINE errors
//      respectively if they are encountered when attempting to check the
//      revocation status of a received certificate chain. These flags are
//      ignored if none of the above flags are set.
//
//+-------------------------------------------------------------------------
#define SCH_CRED_NO_SYSTEM_MAPPER                    0x00000002
#define SCH_CRED_NO_SERVERNAME_CHECK                 0x00000004
#define SCH_CRED_MANUAL_CRED_VALIDATION              0x00000008
#define SCH_CRED_NO_DEFAULT_CREDS                    0x00000010
#define SCH_CRED_AUTO_CRED_VALIDATION                0x00000020
#define SCH_CRED_USE_DEFAULT_CREDS                   0x00000040

#define SCH_CRED_REVOCATION_CHECK_END_CERT           0x00000100
#define SCH_CRED_REVOCATION_CHECK_CHAIN              0x00000200
#define SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x00000400
#define SCH_CRED_IGNORE_NO_REVOCATION_CHECK          0x00000800
#define SCH_CRED_IGNORE_REVOCATION_OFFLINE           0x00001000


//
//
// ApplyControlToken PkgParams types
//
// These identifiers are the DWORD types
// to be passed into ApplyControlToken
// through a PkgParams buffer.

#define SCHANNEL_RENEGOTIATE    0   // renegotiate a connection
#define SCHANNEL_SHUTDOWN       1   // gracefully close down a connection
#define SCHANNEL_ALERT          2   // build an error message


// Alert token structure.
typedef struct _SCHANNEL_ALERT_TOKEN
{
    DWORD   dwTokenType;            // SCHANNEL_ALERT
    DWORD   dwAlertType;
    DWORD   dwAlertNumber;
} SCHANNEL_ALERT_TOKEN;

// Alert types.
#define TLS1_ALERT_WARNING              1
#define TLS1_ALERT_FATAL                2

// Alert messages.
#define TLS1_ALERT_CLOSE_NOTIFY         0       // warning
#define TLS1_ALERT_UNEXPECTED_MESSAGE   10      // error
#define TLS1_ALERT_BAD_RECORD_MAC       20      // error
#define TLS1_ALERT_DECRYPTION_FAILED    21      // error
#define TLS1_ALERT_RECORD_OVERFLOW      22      // error
#define TLS1_ALERT_DECOMPRESSION_FAIL   30      // error
#define TLS1_ALERT_HANDSHAKE_FAILURE    40      // error
#define TLS1_ALERT_BAD_CERTIFICATE      42      // warning or error
#define TLS1_ALERT_UNSUPPORTED_CERT     43      // warning or error
#define TLS1_ALERT_CERTIFICATE_REVOKED  44      // warning or error
#define TLS1_ALERT_CERTIFICATE_EXPIRED  45      // warning or error
#define TLS1_ALERT_CERTIFICATE_UNKNOWN  46      // warning or error
#define TLS1_ALERT_ILLEGAL_PARAMETER    47      // error
#define TLS1_ALERT_UNKNOWN_CA           48      // error
#define TLS1_ALERT_ACCESS_DENIED        49      // error
#define TLS1_ALERT_DECODE_ERROR         50      // error
#define TLS1_ALERT_DECRYPT_ERROR        51      // error
#define TLS1_ALERT_EXPORT_RESTRICTION   60      // error
#define TLS1_ALERT_PROTOCOL_VERSION     70      // error
#define TLS1_ALERT_INSUFFIENT_SECURITY  71      // error
#define TLS1_ALERT_INTERNAL_ERROR       80      // error
#define TLS1_ALERT_USER_CANCELED        90      // warning or error
#define TLS1_ALERT_NO_RENEGOTIATATION   100     // warning


//
//
// ADDITIONAL SCHANNEL CERTIFICATE PROPERTIES
//
//


// This property specifies the DER private key data associated with this
// certificate.  It is for use with legacy IIS style private keys.
//
// PBYTE
//
#define CERT_SCHANNEL_IIS_PRIVATE_KEY_PROP_ID  (CERT_FIRST_USER_PROP_ID + 0)

// The password used to crack the private key associated with the certificate.
// It is for use with legacy IIS style private keys.
//
// PBYTE
#define CERT_SCHANNEL_IIS_PASSWORD_PROP_ID  (CERT_FIRST_USER_PROP_ID + 1)

// This is the unique ID of a Server Gated Cryptography certificate associated
// with this certificate.
//
// CRYPT_BIT_BLOB
#define CERT_SCHANNEL_SGC_CERTIFICATE_PROP_ID  (CERT_FIRST_USER_PROP_ID + 2)



//
// Flags for identifying the various different protocols.
//

/* flag/identifiers for protocols we support */
#define SP_PROT_PCT1_SERVER             0x00000001
#define SP_PROT_PCT1_CLIENT             0x00000002
#define SP_PROT_PCT1                    (SP_PROT_PCT1_SERVER | SP_PROT_PCT1_CLIENT)

#define SP_PROT_SSL2_SERVER             0x00000004
#define SP_PROT_SSL2_CLIENT             0x00000008
#define SP_PROT_SSL2                    (SP_PROT_SSL2_SERVER | SP_PROT_SSL2_CLIENT)

#define SP_PROT_SSL3_SERVER             0x00000010
#define SP_PROT_SSL3_CLIENT             0x00000020
#define SP_PROT_SSL3                    (SP_PROT_SSL3_SERVER | SP_PROT_SSL3_CLIENT)

#define SP_PROT_TLS1_SERVER             0x00000040
#define SP_PROT_TLS1_CLIENT             0x00000080
#define SP_PROT_TLS1                    (SP_PROT_TLS1_SERVER | SP_PROT_TLS1_CLIENT)

#define SP_PROT_SSL3TLS1_CLIENTS        (SP_PROT_TLS1_CLIENT | SP_PROT_SSL3_CLIENT)
#define SP_PROT_SSL3TLS1_SERVERS        (SP_PROT_TLS1_SERVER | SP_PROT_SSL3_SERVER)
#define SP_PROT_SSL3TLS1                (SP_PROT_SSL3 | SP_PROT_TLS1)

#define SP_PROT_UNI_SERVER              0x40000000
#define SP_PROT_UNI_CLIENT              0x80000000
#define SP_PROT_UNI                     (SP_PROT_UNI_SERVER | SP_PROT_UNI_CLIENT)

#define SP_PROT_ALL                     0xffffffff
#define SP_PROT_NONE                    0
#define SP_PROT_CLIENTS                 (SP_PROT_PCT1_CLIENT | SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_UNI_CLIENT | SP_PROT_TLS1_CLIENT)
#define SP_PROT_SERVERS                 (SP_PROT_PCT1_SERVER | SP_PROT_SSL2_SERVER | SP_PROT_SSL3_SERVER | SP_PROT_UNI_SERVER | SP_PROT_TLS1_SERVER)


// A call for IIS to empty the cache.
BOOL
SslEmptyCache(VOID);


//
//
//  Support for legacy applications
//  NOTE: Do not use the following
//  API's and structures for new code.
//

#define SSLOLD_NAME_A    "Microsoft SSL"
#define SSLOLD_NAME_W    L"Microsoft SSL"
#define PCTOLD_NAME_A    "Microsoft PCT"
#define PCTOLD_NAME_W    L"Microsoft PCT"

#ifdef UNICODE
#define SSLOLD_NAME SSLOLD_NAME_W
#define PCTOLD_NAME PCTOLD_NAME_W
#else
#define SSLOLD_NAME SSLOLD_NAME_A
#define PCTOLD_NAME PCTOLD_NAME_A
#endif

#define NETWORK_DREP    0x00000000



// Structures for compatability with the
// NT 4.0 SP2 / IE 3.0 schannel interface, do
// not use.

typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;




// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
#define SCHANNEL_SECRET_TYPE_CAPI   0x00000001
#define SCHANNEL_SECRET_PRIVKEY     0x00000002
#define SCH_CRED_X509_CERTCHAIN     0x00000001
#define SCH_CRED_X509_CAPI          0x00000002
#define SCH_CRED_CERT_CONTEXT       0x00000003

struct _HMAPPER;
typedef struct _SCH_CRED
{
    DWORD     dwVersion;                // always SCH_CRED_VERSION.
    DWORD     cCreds;                   // Number of credentials.
    PVOID     *paSecret;                // Array of SCH_CRED_SECRET_* pointers
    PVOID     *paPublic;                // Array of SCH_CRED_PUBLIC_* pointers
    DWORD     cMappers;                 // Number of credential mappers.
    struct _HMAPPER   **aphMappers;     // pointer to an array of pointers to credential mappers
} SCH_CRED, * PSCH_CRED;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_CAPI
{
    DWORD           dwType;      // SCHANNEL_SECRET_TYPE_CAPI
    HCRYPTPROV      hProv;       // credential secret information.

} SCH_CRED_SECRET_CAPI, * PSCH_CRED_SECRET_CAPI;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_PRIVKEY
{
    DWORD           dwType;       // SCHANNEL_SECRET_PRIVKEY
    PBYTE           pPrivateKey;   // Der encoded private key
    DWORD           cbPrivateKey;
    PSTR            pszPassword;  // Password to crack the private key.

} SCH_CRED_SECRET_PRIVKEY, * PSCH_CRED_SECRET_PRIVKEY;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD       dwType;
    DWORD       cbCertChain;
    PBYTE       pCertChain;
} SCH_CRED_PUBLIC_CERTCHAIN, *PSCH_CRED_PUBLIC_CERTCHAIN;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_PUBLIC_CAPI
{
    DWORD           dwType;      // SCH_CRED_X509_CAPI
    HCRYPTPROV      hProv;       // CryptoAPI handle (usually a token CSP)

} SCH_CRED_PUBLIC_CAPI, * PSCH_CRED_PUBLIC_CAPI;




// Structures needed for Pre NT4.0 SP2 calls.
typedef struct _PctPublicKey
{
    DWORD Type;
    DWORD cbKey;
    UCHAR pKey[1];
} PctPublicKey;

typedef struct _X509Certificate {
    DWORD           Version;
    DWORD           SerialNumber[4];
    ALG_ID          SignatureAlgorithm;
    FILETIME        ValidFrom;
    FILETIME        ValidUntil;
    PSTR            pszIssuer;
    PSTR            pszSubject;
    PctPublicKey    *pPublicKey;
} X509Certificate, * PX509Certificate;



// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
SslFreeCertificate(
    PX509Certificate    pCertificate
    );

DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved );

BOOL
SslGetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

#define SSL_CRACK_CERTIFICATE_NAME  TEXT("SslCrackCertificate")
#define SSL_FREE_CERTIFICATE_NAME   TEXT("SslFreeCertificate")

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef BOOL
(WINAPI * SSL_CRACK_CERTIFICATE_FN)
(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    BOOL                VerifySignature,
    PX509Certificate *  ppCertificate
);


// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef VOID
(WINAPI * SSL_FREE_CERTIFICATE_FN)
(
    PX509Certificate    pCertificate
);


#endif //__SCHANNEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scserver.h ===
#ifndef _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#include "des.h"

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelServer
{
public:
	   CSecureChannelServer();
       ~CSecureChannelServer();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       HRESULT SACAuth(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
       HRESULT SACGetProtocols(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]); 
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
	   BOOL fIsAuthenticated();
private:
	   BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
       BYTE m_abCallerChallenge[4];
       BYTE m_abIssuedChallenge[4];
	   BOOL m_TableInit;
	   DESTable m_DesTable;
#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   DWORD m_dwCertFlags;
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;
       HRESULT Protocol1(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);

       HRESULT Protocol2(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);
};

#endif // _CSECURECHANNELSERVER_H_2AD99357-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SCardSsp_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 01 16:58:17 1999
 */
/* Compiler settings for scardssp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "scardssp.h"

#define TYPE_FORMAT_STRING_SIZE   1313                              
#define PROC_FORMAT_STRING_SIZE   3859                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   3            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Standard interface: __MIDL_itf_scardssp_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IByteBuffer, ver. 0.0,
   GUID={0xE126F8FE,0xA7AF,0x11D0,{0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IByteBuffer_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short IByteBuffer_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    36,
    72,
    108,
    144,
    198,
    240,
    288,
    336,
    366,
    414,
    450,
    492,
    540
    };

static const MIDL_SERVER_INFO IByteBuffer_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IByteBuffer_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IByteBuffer_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IByteBuffer_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(21) _IByteBufferProxyVtbl = 
{
    &IByteBuffer_ProxyInfo,
    &IID_IByteBuffer,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IByteBuffer::get_Stream */ ,
    (void *)-1 /* IByteBuffer::put_Stream */ ,
    (void *)-1 /* IByteBuffer::Clone */ ,
    (void *)-1 /* IByteBuffer::Commit */ ,
    (void *)-1 /* IByteBuffer::CopyTo */ ,
    (void *)-1 /* IByteBuffer::Initialize */ ,
    (void *)-1 /* IByteBuffer::LockRegion */ ,
    (void *)-1 /* IByteBuffer::Read */ ,
    (void *)-1 /* IByteBuffer::Revert */ ,
    (void *)-1 /* IByteBuffer::Seek */ ,
    (void *)-1 /* IByteBuffer::SetSize */ ,
    (void *)-1 /* IByteBuffer::Stat */ ,
    (void *)-1 /* IByteBuffer::UnlockRegion */ ,
    (void *)-1 /* IByteBuffer::Write */
};


static const PRPC_STUB_FUNCTION IByteBuffer_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IByteBufferStubVtbl =
{
    &IID_IByteBuffer,
    &IByteBuffer_ServerInfo,
    21,
    &IByteBuffer_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0244, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardTypeConv, ver. 0.0,
   GUID={0x53B6AA63,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardTypeConv_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardTypeConv_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    588,
    636,
    678,
    720,
    762,
    804,
    846,
    888,
    930,
    972
    };

static const MIDL_SERVER_INFO ISCardTypeConv_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardTypeConv_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardTypeConv_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardTypeConv_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(17) _ISCardTypeConvProxyVtbl = 
{
    &ISCardTypeConv_ProxyInfo,
    &IID_ISCardTypeConv,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteArrayToByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteBufferToByteArray */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteBufferToSafeArray */ ,
    (void *)-1 /* ISCardTypeConv::ConvertSafeArrayToByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::CreateByteArray */ ,
    (void *)-1 /* ISCardTypeConv::CreateByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::CreateSafeArray */ ,
    (void *)-1 /* ISCardTypeConv::FreeIStreamMemoryPtr */ ,
    (void *)-1 /* ISCardTypeConv::GetAtIStreamMemory */ ,
    (void *)-1 /* ISCardTypeConv::SizeOfIStream */
};


static const PRPC_STUB_FUNCTION ISCardTypeConv_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardTypeConvStubVtbl =
{
    &IID_ISCardTypeConv,
    &ISCardTypeConv_ServerInfo,
    17,
    &ISCardTypeConv_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0245, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardCmd, ver. 0.0,
   GUID={0xD5778AE3,0x43DE,0x11D0,{0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardCmd_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardCmd_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1014,
    1050,
    1086,
    1122,
    1158,
    1194,
    1230,
    1266,
    1302,
    1338,
    1374,
    1410,
    1446,
    1482,
    1518,
    1554,
    1590,
    1626,
    1662,
    1698,
    1734,
    1770,
    1806,
    1842,
    1878,
    1914,
    1950,
    1986,
    2022,
    2088,
    2118,
    2160,
    2196
    };

static const MIDL_SERVER_INFO ISCardCmd_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardCmd_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardCmd_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardCmd_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(40) _ISCardCmdProxyVtbl = 
{
    &ISCardCmd_ProxyInfo,
    &IID_ISCardCmd,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardCmd::get_Apdu */ ,
    (void *)-1 /* ISCardCmd::put_Apdu */ ,
    (void *)-1 /* ISCardCmd::get_ApduLength */ ,
    (void *)-1 /* ISCardCmd::get_ApduReply */ ,
    (void *)-1 /* ISCardCmd::put_ApduReply */ ,
    (void *)-1 /* ISCardCmd::get_ApduReplyLength */ ,
    (void *)-1 /* ISCardCmd::put_ApduReplyLength */ ,
    (void *)-1 /* ISCardCmd::get_ClassId */ ,
    (void *)-1 /* ISCardCmd::put_ClassId */ ,
    (void *)-1 /* ISCardCmd::get_Data */ ,
    (void *)-1 /* ISCardCmd::put_Data */ ,
    (void *)-1 /* ISCardCmd::get_InstructionId */ ,
    (void *)-1 /* ISCardCmd::put_InstructionId */ ,
    (void *)-1 /* ISCardCmd::get_LeField */ ,
    (void *)-1 /* ISCardCmd::get_P1 */ ,
    (void *)-1 /* ISCardCmd::put_P1 */ ,
    (void *)-1 /* ISCardCmd::get_P2 */ ,
    (void *)-1 /* ISCardCmd::put_P2 */ ,
    (void *)-1 /* ISCardCmd::get_P3 */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatus */ ,
    (void *)-1 /* ISCardCmd::put_ReplyStatus */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatusSW1 */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatusSW2 */ ,
    (void *)-1 /* ISCardCmd::get_Type */ ,
    (void *)-1 /* ISCardCmd::get_Nad */ ,
    (void *)-1 /* ISCardCmd::put_Nad */ ,
    (void *)-1 /* ISCardCmd::get_ReplyNad */ ,
    (void *)-1 /* ISCardCmd::put_ReplyNad */ ,
    (void *)-1 /* ISCardCmd::BuildCmd */ ,
    (void *)-1 /* ISCardCmd::Clear */ ,
    (void *)-1 /* ISCardCmd::Encapsulate */ ,
    (void *)-1 /* ISCardCmd::get_AlternateClassId */ ,
    (void *)-1 /* ISCardCmd::put_AlternateClassId */
};


static const PRPC_STUB_FUNCTION ISCardCmd_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardCmdStubVtbl =
{
    &IID_ISCardCmd,
    &ISCardCmd_ServerInfo,
    40,
    &ISCardCmd_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0246, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardISO7816, ver. 0.0,
   GUID={0x53B6AA68,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardISO7816_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardISO7816_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    2232,
    2280,
    2334,
    2388,
    2430,
    2484,
    2538,
    2598,
    2646,
    2700,
    2754,
    2808,
    1446,
    2868,
    2922,
    2976,
    3024,
    3078
    };

static const MIDL_SERVER_INFO ISCardISO7816_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardISO7816_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardISO7816_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardISO7816_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(25) _ISCardISO7816ProxyVtbl = 
{
    &ISCardISO7816_ProxyInfo,
    &IID_ISCardISO7816,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardISO7816::AppendRecord */ ,
    (void *)-1 /* ISCardISO7816::EraseBinary */ ,
    (void *)-1 /* ISCardISO7816::ExternalAuthenticate */ ,
    (void *)-1 /* ISCardISO7816::GetChallenge */ ,
    (void *)-1 /* ISCardISO7816::GetData */ ,
    (void *)-1 /* ISCardISO7816::GetResponse */ ,
    (void *)-1 /* ISCardISO7816::InternalAuthenticate */ ,
    (void *)-1 /* ISCardISO7816::ManageChannel */ ,
    (void *)-1 /* ISCardISO7816::PutData */ ,
    (void *)-1 /* ISCardISO7816::ReadBinary */ ,
    (void *)-1 /* ISCardISO7816::ReadRecord */ ,
    (void *)-1 /* ISCardISO7816::SelectFile */ ,
    (void *)-1 /* ISCardISO7816::SetDefaultClassId */ ,
    (void *)-1 /* ISCardISO7816::UpdateBinary */ ,
    (void *)-1 /* ISCardISO7816::UpdateRecord */ ,
    (void *)-1 /* ISCardISO7816::Verify */ ,
    (void *)-1 /* ISCardISO7816::WriteBinary */ ,
    (void *)-1 /* ISCardISO7816::WriteRecord */
};


static const PRPC_STUB_FUNCTION ISCardISO7816_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardISO7816StubVtbl =
{
    &IID_ISCardISO7816,
    &ISCardISO7816_ServerInfo,
    25,
    &ISCardISO7816_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0247, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCard, ver. 0.0,
   GUID={0x1461AAC3,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCard_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCard_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1014,
    3132,
    1086,
    3168,
    3204,
    3240,
    3276,
    3324,
    336,
    3360,
    3402,
    3438
    };

static const MIDL_SERVER_INFO ISCard_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCard_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCard_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCard_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(19) _ISCardProxyVtbl = 
{
    &ISCard_ProxyInfo,
    &IID_ISCard,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCard::get_Atr */ ,
    (void *)-1 /* ISCard::get_CardHandle */ ,
    (void *)-1 /* ISCard::get_Context */ ,
    (void *)-1 /* ISCard::get_Protocol */ ,
    (void *)-1 /* ISCard::get_Status */ ,
    (void *)-1 /* ISCard::AttachByHandle */ ,
    (void *)-1 /* ISCard::AttachByReader */ ,
    (void *)-1 /* ISCard::Detach */ ,
    (void *)-1 /* ISCard::LockSCard */ ,
    (void *)-1 /* ISCard::ReAttach */ ,
    (void *)-1 /* ISCard::Transaction */ ,
    (void *)-1 /* ISCard::UnlockSCard */
};


static const PRPC_STUB_FUNCTION ISCard_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardStubVtbl =
{
    &IID_ISCard,
    &ISCard_ServerInfo,
    19,
    &ISCard_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0248, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardDatabase, ver. 0.0,
   GUID={0x1461AAC8,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardDatabase_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardDatabase_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    3474,
    3516,
    3558,
    3612,
    3654
    };

static const MIDL_SERVER_INFO ISCardDatabase_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardDatabase_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardDatabase_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardDatabase_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(12) _ISCardDatabaseProxyVtbl = 
{
    &ISCardDatabase_ProxyInfo,
    &IID_ISCardDatabase,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardDatabase::GetProviderCardId */ ,
    (void *)-1 /* ISCardDatabase::ListCardInterfaces */ ,
    (void *)-1 /* ISCardDatabase::ListCards */ ,
    (void *)-1 /* ISCardDatabase::ListReaderGroups */ ,
    (void *)-1 /* ISCardDatabase::ListReaders */
};


static const PRPC_STUB_FUNCTION ISCardDatabase_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardDatabaseStubVtbl =
{
    &IID_ISCardDatabase,
    &ISCardDatabase_ServerInfo,
    12,
    &ISCardDatabase_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0249, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardLocate, ver. 0.0,
   GUID={0x1461AACD,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardLocate_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardLocate_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    3696,
    3750,
    3804
    };

static const MIDL_SERVER_INFO ISCardLocate_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardLocate_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardLocate_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardLocate_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(10) _ISCardLocateProxyVtbl = 
{
    &ISCardLocate_ProxyInfo,
    &IID_ISCardLocate,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardLocate::ConfigureCardGuidSearch */ ,
    (void *)-1 /* ISCardLocate::ConfigureCardNameSearch */ ,
    (void *)-1 /* ISCardLocate::FindCard */
};


static const PRPC_STUB_FUNCTION ISCardLocate_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardLocateStubVtbl =
{
    &IID_ISCardLocate,
    &ISCardLocate_ServerInfo,
    10,
    &ISCardLocate_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0250, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x5030117, /* MIDL Version 5.3.279 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HGLOBAL_UserSize
            ,HGLOBAL_UserMarshal
            ,HGLOBAL_UserUnmarshal
            ,HGLOBAL_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure get_Stream */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppStream */

/* 24 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 26 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 28 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 32 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Stream */

/* 36 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 52 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStream */

/* 60 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 62 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 64 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 68 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 88 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppByteBuffer */

/* 96 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 98 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 100 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Commit */

/* 108 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 122 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 124 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter grfCommitFlags */

/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 134 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 140 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CopyTo */

/* 144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 152 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 154 */	NdrFcShort( 0x18 ),	/* 24 */
/* 156 */	NdrFcShort( 0x18 ),	/* 24 */
/* 158 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 160 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppByteBuffer */

/* 168 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 172 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Parameter cb */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 176 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 180 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 182 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 186 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 188 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 194 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 198 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 206 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 208 */	NdrFcShort( 0xd ),	/* 13 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 214 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lSize */

/* 222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 224 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pData */

/* 228 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
#ifndef _ALPHA_
/* 230 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 232 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 236 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LockRegion */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 248 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 250 */	NdrFcShort( 0x18 ),	/* 24 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 256 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libOffset */

/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 266 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cb */

/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLockType */

/* 276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 278 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Read */

/* 288 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 296 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 298 */	NdrFcShort( 0x15 ),	/* 21 */
/* 300 */	NdrFcShort( 0x15 ),	/* 21 */
/* 302 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 304 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pByte */

/* 312 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 314 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 316 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter cb */

/* 318 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 320 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 324 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 330 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 334 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LockSCard */


	/* Procedure Revert */

/* 336 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
/* 350 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 352 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */


	/* Return value */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 362 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Seek */

/* 366 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 374 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 376 */	NdrFcShort( 0x18 ),	/* 24 */
/* 378 */	NdrFcShort( 0x10 ),	/* 16 */
/* 380 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 382 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dLibMove */

/* 390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 392 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwOrigin */

/* 396 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 398 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pLibnewPosition */

/* 402 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 404 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSize */

/* 414 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 424 */	NdrFcShort( 0x8 ),	/* 8 */
/* 426 */	NdrFcShort( 0x8 ),	/* 8 */
/* 428 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 430 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libNewSize */

/* 438 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 440 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 442 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 446 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stat */

/* 450 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 458 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 460 */	NdrFcShort( 0x24 ),	/* 36 */
/* 462 */	NdrFcShort( 0x24 ),	/* 36 */
/* 464 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pstatstg */

/* 474 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
#ifndef _ALPHA_
/* 476 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 478 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Parameter grfStatFlag */

/* 480 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 482 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 488 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnlockRegion */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 500 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 502 */	NdrFcShort( 0x18 ),	/* 24 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libOffset */

/* 516 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 518 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 520 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cb */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 524 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLockType */

/* 528 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 530 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 536 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Write */

/* 540 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 550 */	NdrFcShort( 0x15 ),	/* 21 */
/* 552 */	NdrFcShort( 0x15 ),	/* 21 */
/* 554 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 556 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	NdrFcShort( 0x0 ),	/* 0 */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pByte */

/* 564 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 566 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 568 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter cb */

/* 570 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 572 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 576 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 578 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 582 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 584 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 586 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteArrayToByteBuffer */

/* 588 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 590 */	NdrFcLong( 0x0 ),	/* 0 */
/* 594 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 596 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 598 */	NdrFcShort( 0xd ),	/* 13 */
/* 600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 602 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 604 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyArray */

/* 612 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
#ifndef _ALPHA_
/* 614 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 616 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwArraySize */

/* 618 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 620 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyBuffer */

/* 624 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 626 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 628 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 632 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteBufferToByteArray */

/* 636 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 638 */	NdrFcLong( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 644 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0x8 ),	/* 8 */
/* 650 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 652 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 654 */	NdrFcShort( 0x3 ),	/* 3 */
/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyBuffer */

/* 660 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 662 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 664 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppArray */

/* 666 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 668 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 670 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Return value */

/* 672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 674 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteBufferToSafeArray */

/* 678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 684 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 686 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 692 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 694 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 696 */	NdrFcShort( 0x12 ),	/* 18 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyBuffer */

/* 702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 704 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 706 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppbyArray */

/* 708 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 710 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 712 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 716 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertSafeArrayToByteBuffer */

/* 720 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 726 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 728 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 736 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0x12 ),	/* 18 */
/* 742 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyArray */

/* 744 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 746 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 748 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter ppbyBuff */

/* 750 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 752 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 754 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 756 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 758 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 760 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateByteArray */

/* 762 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 764 */	NdrFcLong( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 770 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	NdrFcShort( 0x15 ),	/* 21 */
/* 776 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 778 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x0 ),	/* 0 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwAllocSize */

/* 786 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 788 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyArray */

/* 792 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 794 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 796 */	NdrFcShort( 0x4c2 ),	/* Type Offset=1218 */

	/* Return value */

/* 798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 800 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateByteBuffer */

/* 804 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 806 */	NdrFcLong( 0x0 ),	/* 0 */
/* 810 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 812 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 814 */	NdrFcShort( 0x8 ),	/* 8 */
/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
/* 818 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 820 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwAllocSize */

/* 828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 830 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyBuff */

/* 834 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 836 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 838 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 840 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 842 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateSafeArray */

/* 846 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 848 */	NdrFcLong( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 854 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	NdrFcShort( 0x8 ),	/* 8 */
/* 860 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 862 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 864 */	NdrFcShort( 0x12 ),	/* 18 */
/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
/* 868 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter nAllocSize */

/* 870 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 872 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 874 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppArray */

/* 876 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 878 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 880 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 882 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 884 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FreeIStreamMemoryPtr */

/* 888 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 896 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 898 */	NdrFcShort( 0x5 ),	/* 5 */
/* 900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 902 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 904 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 910 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 912 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 914 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 916 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter pMem */

/* 918 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
#ifndef _ALPHA_
/* 920 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 922 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 924 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 926 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 928 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAtIStreamMemory */

/* 930 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 932 */	NdrFcLong( 0x0 ),	/* 0 */
/* 936 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 938 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 946 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 948 */	NdrFcShort( 0x3 ),	/* 3 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 954 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 956 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 958 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppMem */

/* 960 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 962 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 964 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Return value */

/* 966 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 968 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SizeOfIStream */

/* 972 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 974 */	NdrFcLong( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 980 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 982 */	NdrFcShort( 0x0 ),	/* 0 */
/* 984 */	NdrFcShort( 0x18 ),	/* 24 */
/* 986 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 988 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 990 */	NdrFcShort( 0x0 ),	/* 0 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 996 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 998 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1000 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter puliSize */

/* 1002 */	NdrFcShort( 0x2112 ),	/* Flags:  must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1004 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1006 */	NdrFcShort( 0x2ce ),	/* Type Offset=718 */

	/* Return value */

/* 1008 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1010 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1012 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Atr */


	/* Procedure get_Apdu */

/* 1014 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1016 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1020 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 1022 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1026 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1028 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1030 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1032 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppAtr */


	/* Parameter ppApdu */

/* 1038 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 1040 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1042 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */


	/* Return value */

/* 1044 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1046 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Apdu */

/* 1050 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1052 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 1058 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1066 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pApdu */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1076 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1078 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1080 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1082 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Context */


	/* Procedure get_ApduLength */

/* 1086 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1088 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 1094 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1100 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1102 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pContext */


	/* Parameter plSize */

/* 1110 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1112 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1114 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 1116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1118 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ApduReply */

/* 1122 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1124 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 1130 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1134 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1136 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1138 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppReplyApdu */

/* 1146 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 1148 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1150 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 1152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1154 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ApduReply */

/* 1158 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1160 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1164 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 1166 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1170 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1172 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1174 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1180 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pReplyApdu */

/* 1182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1184 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1186 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1190 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ApduReplyLength */

/* 1194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1200 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 1202 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1208 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1210 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plSize */

/* 1218 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1220 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1224 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1226 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ApduReplyLength */

/* 1230 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1232 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 1238 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1240 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1244 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1246 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lSize */

/* 1254 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1256 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1262 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ClassId */

/* 1266 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 1274 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1278 */	NdrFcShort( 0xd ),	/* 13 */
/* 1280 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1282 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1288 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyClass */

/* 1290 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1292 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1294 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1296 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1298 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1300 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ClassId */

/* 1302 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1304 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1308 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 1310 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1312 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1316 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1318 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1324 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */

/* 1326 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1328 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1330 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1332 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1334 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1336 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Data */

/* 1338 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1340 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1344 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 1346 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1348 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1352 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1354 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppData */

/* 1362 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 1364 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1366 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 1368 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1370 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Data */

/* 1374 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1380 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 1382 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1388 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1390 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1396 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pData */

/* 1398 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1400 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1402 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1404 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1406 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1408 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_InstructionId */

/* 1410 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1412 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1416 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 1418 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0xd ),	/* 13 */
/* 1424 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1426 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyIns */

/* 1434 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1436 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1438 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1442 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDefaultClassId */


	/* Procedure put_InstructionId */

/* 1446 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1452 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 1454 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1456 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1458 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1460 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1462 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1464 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */


	/* Parameter byIns */

/* 1470 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1472 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1474 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 1476 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1478 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1480 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_LeField */

/* 1482 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1484 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1488 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 1490 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1494 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1496 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1498 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plSize */

/* 1506 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1508 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1512 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1514 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P1 */

/* 1518 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1520 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1524 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 1526 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0xd ),	/* 13 */
/* 1532 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1534 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP1 */

/* 1542 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1544 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1546 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1548 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1550 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_P1 */

/* 1554 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1556 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1560 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 1562 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1564 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1566 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1568 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1570 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 1578 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1580 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1582 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1584 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1586 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P2 */

/* 1590 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1592 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1596 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 1598 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1602 */	NdrFcShort( 0xd ),	/* 13 */
/* 1604 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1606 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP2 */

/* 1614 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1616 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1618 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1620 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1622 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_P2 */

/* 1626 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1632 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 1634 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1636 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1638 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1640 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1642 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP2 */

/* 1650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1652 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1654 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1656 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1658 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P3 */

/* 1662 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1664 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1668 */	NdrFcShort( 0x19 ),	/* 25 */
#ifndef _ALPHA_
/* 1670 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1674 */	NdrFcShort( 0xd ),	/* 13 */
/* 1676 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1678 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1684 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP3 */

/* 1686 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1688 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1690 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1692 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1694 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1696 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatus */

/* 1698 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1700 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x1a ),	/* 26 */
#ifndef _ALPHA_
/* 1706 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1710 */	NdrFcShort( 0xe ),	/* 14 */
/* 1712 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1714 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1720 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwStatus */

/* 1722 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1724 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1726 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1728 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1730 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1732 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ReplyStatus */

/* 1734 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1736 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1740 */	NdrFcShort( 0x1b ),	/* 27 */
#ifndef _ALPHA_
/* 1742 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1744 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1746 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1748 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1750 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1752 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wStatus */

/* 1758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1760 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1762 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1764 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1766 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatusSW1 */

/* 1770 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1772 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1776 */	NdrFcShort( 0x1c ),	/* 28 */
#ifndef _ALPHA_
/* 1778 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0xd ),	/* 13 */
/* 1784 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1786 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1792 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbySW1 */

/* 1794 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1796 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1798 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1800 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1802 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatusSW2 */

/* 1806 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1808 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1812 */	NdrFcShort( 0x1d ),	/* 29 */
#ifndef _ALPHA_
/* 1814 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0xd ),	/* 13 */
/* 1820 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1822 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1828 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbySW2 */

/* 1830 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1832 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1834 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1836 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1838 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Type */

/* 1842 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1844 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1848 */	NdrFcShort( 0x1e ),	/* 30 */
#ifndef _ALPHA_
/* 1850 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1852 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1854 */	NdrFcShort( 0xe ),	/* 14 */
/* 1856 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1858 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1864 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pType */

/* 1866 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1868 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1870 */	NdrFcShort( 0x4d6 ),	/* Type Offset=1238 */

	/* Return value */

/* 1872 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1874 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1876 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Nad */

/* 1878 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1880 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1884 */	NdrFcShort( 0x1f ),	/* 31 */
#ifndef _ALPHA_
/* 1886 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0xd ),	/* 13 */
/* 1892 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1894 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbNad */

/* 1902 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1904 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1906 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1908 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1910 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Nad */

/* 1914 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1916 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x20 ),	/* 32 */
#ifndef _ALPHA_
/* 1922 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1924 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1928 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1930 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bNad */

/* 1938 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1940 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1942 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1944 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1946 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyNad */

/* 1950 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1952 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1956 */	NdrFcShort( 0x21 ),	/* 33 */
#ifndef _ALPHA_
/* 1958 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0xd ),	/* 13 */
/* 1964 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1966 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1972 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbNad */

/* 1974 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1976 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1978 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1982 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ReplyNad */

/* 1986 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1992 */	NdrFcShort( 0x22 ),	/* 34 */
#ifndef _ALPHA_
/* 1994 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1996 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2000 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2002 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2008 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bNad */

/* 2010 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2012 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2014 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2018 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BuildCmd */

/* 2022 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2028 */	NdrFcShort( 0x23 ),	/* 35 */
#ifndef _ALPHA_
/* 2030 */	NdrFcShort( 0x20 ),	/* x86, MIPS, PPC Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 2032 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2034 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2036 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 2038 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2044 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClassId */

/* 2046 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2048 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2050 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byInsId */

/* 2052 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2054 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2056 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP1 */

/* 2058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2060 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2062 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2064 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2066 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2068 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pbyData */

/* 2070 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2072 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2074 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter plLe */

/* 2076 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
#ifndef _ALPHA_
/* 2078 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2080 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2082 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2084 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clear */

/* 2088 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2090 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2094 */	NdrFcShort( 0x24 ),	/* 36 */
#ifndef _ALPHA_
/* 2096 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2100 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2102 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 2104 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2110 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 2112 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2114 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Encapsulate */

/* 2118 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2120 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2124 */	NdrFcShort( 0x25 ),	/* 37 */
#ifndef _ALPHA_
/* 2126 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2128 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2132 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2134 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2140 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pApdu */

/* 2142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2144 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2146 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ApduType */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2150 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2152 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2156 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_AlternateClassId */

/* 2160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x26 ),	/* 38 */
#ifndef _ALPHA_
/* 2168 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2172 */	NdrFcShort( 0xd ),	/* 13 */
/* 2174 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2176 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2182 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyClass */

/* 2184 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2186 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2188 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2190 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2192 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_AlternateClassId */

/* 2196 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2198 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x27 ),	/* 39 */
#ifndef _ALPHA_
/* 2204 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2206 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2210 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2212 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2218 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */

/* 2220 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2222 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2224 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2226 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2228 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AppendRecord */

/* 2232 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2234 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2238 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 2240 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2242 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2244 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2246 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2248 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2254 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRefCtrl */

/* 2256 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2258 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2260 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2262 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2264 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2266 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2268 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2270 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2272 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2274 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2276 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EraseBinary */

/* 2280 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2286 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 2288 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2290 */	NdrFcShort( 0xa ),	/* 10 */
/* 2292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2294 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2296 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2306 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2308 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2312 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2314 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2316 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2318 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2320 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2322 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2324 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2326 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2330 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExternalAuthenticate */

/* 2334 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 2342 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2344 */	NdrFcShort( 0xa ),	/* 10 */
/* 2346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2348 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2350 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2356 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byAlgorithmRef */

/* 2358 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2360 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2362 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bySecretRef */

/* 2364 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2366 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2368 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pChallenge */

/* 2370 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2372 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2374 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2376 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2378 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2380 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2382 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2384 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2386 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetChallenge */

/* 2388 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2390 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2394 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 2396 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2400 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2402 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2404 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2410 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lBytesExpected */

/* 2412 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2414 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2418 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2420 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2422 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2424 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2426 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetData */

/* 2430 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2436 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 2438 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2440 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2442 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2444 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2446 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2452 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2456 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2458 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2460 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2462 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2464 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToGet */

/* 2466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2468 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2472 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2474 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2476 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2478 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2480 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResponse */

/* 2484 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2490 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 2492 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2494 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2496 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2498 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2500 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2506 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2508 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2510 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2512 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2514 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2516 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2518 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lDataLength */

/* 2520 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2522 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2526 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2528 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2530 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2532 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2534 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InternalAuthenticate */

/* 2538 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2540 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2544 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 2546 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2548 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2550 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2552 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 2554 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2560 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byAlgorithmRef */

/* 2562 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2564 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2566 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bySecretRef */

/* 2568 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2570 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2572 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pChallenge */

/* 2574 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2576 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2578 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter lReplyBytes */

/* 2580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2582 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2586 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2588 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2590 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2594 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ManageChannel */

/* 2598 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2604 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 2606 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2608 */	NdrFcShort( 0xa ),	/* 10 */
/* 2610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2612 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2614 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2620 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byChannelState */

/* 2622 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2624 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2626 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byChannel */

/* 2628 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2630 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2632 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2634 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2636 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2638 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2640 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2642 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2644 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure PutData */

/* 2646 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2648 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2652 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 2654 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2656 */	NdrFcShort( 0xa ),	/* 10 */
/* 2658 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2660 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2662 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2668 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2670 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2672 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2674 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2676 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2678 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2680 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2682 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2684 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2686 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2688 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2690 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2692 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2696 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadBinary */

/* 2700 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2702 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2706 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 2708 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2710 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2714 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2716 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2722 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2724 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2726 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2728 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2730 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2732 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2734 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToRead */

/* 2736 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2738 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2742 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2744 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2746 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2748 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2750 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadRecord */

/* 2754 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2760 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 2762 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2764 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2766 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2768 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2770 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2776 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 2778 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2780 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2782 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 2784 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2786 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2788 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToRead */

/* 2790 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2792 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2794 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2796 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2798 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2800 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2802 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2804 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2806 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SelectFile */

/* 2808 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2810 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2814 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 2816 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2818 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2820 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2822 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 2824 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2830 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2834 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2836 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2838 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2840 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2842 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2844 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2846 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2848 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter lBytesToRead */

/* 2850 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2852 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2854 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2856 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2858 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2860 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2862 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2864 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateBinary */

/* 2868 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2870 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2874 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 2876 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2878 */	NdrFcShort( 0xa ),	/* 10 */
/* 2880 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2882 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2884 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2890 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2892 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2894 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2896 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2898 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2900 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2902 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2904 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2906 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2908 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2910 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2912 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2914 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2916 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2918 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateRecord */

/* 2922 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2924 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2928 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 2930 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2932 */	NdrFcShort( 0xa ),	/* 10 */
/* 2934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2936 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2938 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2944 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 2946 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2948 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2950 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 2952 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2954 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2956 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2958 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2960 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2962 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2964 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2966 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2968 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 2970 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2972 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2974 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Verify */

/* 2976 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2978 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2982 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 2984 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2986 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2988 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2990 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2992 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2998 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRefCtrl */

/* 3000 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3002 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3004 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3006 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 3008 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3010 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3012 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3014 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3016 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 3018 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3020 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3022 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteBinary */

/* 3024 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3026 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3030 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 3032 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3034 */	NdrFcShort( 0xa ),	/* 10 */
/* 3036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3038 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3040 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3046 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 3048 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3050 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3052 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 3054 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3056 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3058 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3060 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 3062 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3064 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3066 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3068 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3070 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 3072 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3074 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3076 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteRecord */

/* 3078 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3080 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3084 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 3086 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3088 */	NdrFcShort( 0xa ),	/* 10 */
/* 3090 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3092 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3094 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 3102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3104 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3106 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 3108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3110 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3112 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3114 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 3116 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3118 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3120 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3122 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3124 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 3126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3128 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CardHandle */

/* 3132 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3138 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 3140 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3144 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3148 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3154 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pHandle */

/* 3156 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3158 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3164 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Protocol */

/* 3168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3174 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 3176 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3180 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3182 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3184 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3190 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pProtocol */

/* 3192 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3194 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3196 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3198 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3200 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Status */

/* 3204 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3206 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3210 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 3212 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3216 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3218 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3220 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3226 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStatus */

/* 3228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3230 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3232 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3236 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AttachByHandle */

/* 3240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3246 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 3248 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3256 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hCard */

/* 3264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3266 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3272 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AttachByReader */

/* 3276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3282 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 3284 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3286 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3290 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3292 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3296 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3298 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrReaderName */

/* 3300 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3302 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3304 */	NdrFcShort( 0x4f8 ),	/* Type Offset=1272 */

	/* Parameter ShareMode */

/* 3306 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3308 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3310 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter PrefProtocol */

/* 3312 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3314 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3316 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3320 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Detach */

/* 3324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3330 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 3332 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3338 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3340 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3346 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Disposition */

/* 3348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3350 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3352 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3354 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3356 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReAttach */

/* 3360 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3362 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3366 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 3368 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3370 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3372 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3374 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 3376 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3382 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ShareMode */

/* 3384 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3386 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3388 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter InitState */

/* 3390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3392 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3394 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3398 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Transaction */

/* 3402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3408 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 3410 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3416 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 3418 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3424 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppCmd */

/* 3426 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3428 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3430 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 3432 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3434 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnlockSCard */

/* 3438 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3440 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3444 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 3446 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3448 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3452 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3454 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Disposition */

/* 3462 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3464 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3466 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3468 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3470 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProviderCardId */

/* 3474 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3476 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3480 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 3482 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3486 */	NdrFcShort( 0x30 ),	/* 48 */
/* 3488 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3490 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3494 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3496 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCardName */

/* 3498 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3500 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3502 */	NdrFcShort( 0x4f8 ),	/* Type Offset=1272 */

	/* Parameter ppguidProviderId */

/* 3504 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3506 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3508 */	NdrFcShort( 0x502 ),	/* Type Offset=1282 */

	/* Return value */

/* 3510 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3512 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3514 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListCardInterfaces */

/* 3516 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3518 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3522 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 3524 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3528 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3530 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3532 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3534 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3536 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3538 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCardName */

/* 3540 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3542 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3544 */	NdrFcShort( 0x4f8 ),	/* Type Offset=1272 */

	/* Parameter ppInterfaceGuids */

/* 3546 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3548 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3550 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 3552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3554 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListCards */

/* 3558 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3564 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 3566 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3568 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3570 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3572 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3574 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3576 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3578 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3580 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pAtr */

/* 3582 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 3584 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3586 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter pInterfaceGuids */

/* 3588 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3590 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3592 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter localeId */

/* 3594 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3596 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCardNames */

/* 3600 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3602 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3604 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 3606 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3608 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListReaderGroups */

/* 3612 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3614 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3618 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 3620 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3624 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3626 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 3628 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3630 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter localeId */

/* 3636 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3638 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppReaderGroups */

/* 3642 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3644 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3646 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 3648 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3650 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListReaders */

/* 3654 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3656 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3660 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 3662 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3668 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 3670 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3672 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter localeId */

/* 3678 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3680 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppReaders */

/* 3684 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 3686 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3688 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 3690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3692 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConfigureCardGuidSearch */

/* 3696 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3702 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 3704 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3710 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3712 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3716 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3718 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCardGuids */

/* 3720 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3722 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3724 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter pGroupNames */

/* 3726 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3728 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3730 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter bstrTitle */

/* 3732 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3734 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3736 */	NdrFcShort( 0x4f8 ),	/* Type Offset=1272 */

	/* Parameter lFlags */

/* 3738 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3740 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3746 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConfigureCardNameSearch */

/* 3750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3756 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 3758 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3764 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3766 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3770 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3772 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCardNames */

/* 3774 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3776 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3778 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter pGroupNames */

/* 3780 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3782 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3784 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter bstrTitle */

/* 3786 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 3788 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3790 */	NdrFcShort( 0x4f8 ),	/* Type Offset=1272 */

	/* Parameter lFlags */

/* 3792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3794 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3800 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FindCard */

/* 3804 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3806 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3810 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 3812 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 3814 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3816 */	NdrFcShort( 0x38 ),	/* 56 */
/* 3818 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x5,		/* 5 */
/* 3820 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3826 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ShareMode */

/* 3828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3830 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 3832 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter Protocols */

/* 3834 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3836 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 3838 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter lFlags */

/* 3840 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 3842 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 3844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCardInfo */

/* 3846 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 3848 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 3850 */	NdrFcShort( 0x50a ),	/* Type Offset=1290 */

	/* Return value */

/* 3852 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 3854 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 3856 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
/*  6 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  8 */	NdrFcLong( 0xc ),	/* 12 */
/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 20 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 22 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 24 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 30 */	NdrFcLong( 0xe126f8fe ),	/* -517539586 */
/* 34 */	NdrFcShort( 0xa7af ),	/* -22609 */
/* 36 */	NdrFcShort( 0x11d0 ),	/* 4560 */
/* 38 */	0xb8,		/* 184 */
			0x8a,		/* 138 */
/* 40 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 42 */	0x4f,		/* 79 */
			0xd4,		/* 212 */
/* 44 */	0x24,		/* 36 */
			0xb9,		/* 185 */
/* 46 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 48 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 50 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 52 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 54 */	
			0x11, 0x0,	/* FC_RP */
/* 56 */	NdrFcShort( 0x2 ),	/* Offset= 2 (58) */
/* 58 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 60 */	NdrFcShort( 0x14 ),	/* 20 */
/* 62 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 64 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 66 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 68 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 70 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (28) */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x13, 0x0,	/* FC_OP */
/* 78 */	NdrFcShort( 0x50 ),	/* Offset= 80 (158) */
/* 80 */	
			0x13, 0x0,	/* FC_OP */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x88,		/* 136 */
/* 86 */	NdrFcShort( 0x8 ),	/* 8 */
/* 88 */	NdrFcShort( 0x3 ),	/* 3 */
/* 90 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
/* 94 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 96 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
/* 100 */	NdrFcShort( 0xa ),	/* Offset= 10 (110) */
/* 102 */	NdrFcLong( 0x50746457 ),	/* 1349805143 */
/* 106 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 108 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (107) */
/* 110 */	
			0x13, 0x0,	/* FC_OP */
/* 112 */	NdrFcShort( 0xe ),	/* Offset= 14 (126) */
/* 114 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0x1 ),	/* 1 */
/* 118 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 120 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 122 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 124 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 126 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (114) */
/* 132 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 134 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 136 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x4 ),	/* 4 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (80) */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 148 */	NdrFcShort( 0x1 ),	/* 1 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x4 ),	/* 4 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 158 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 160 */	NdrFcShort( 0xc ),	/* 12 */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 172 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 174 */	
			0x13, 0x0,	/* FC_OP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 180 */	NdrFcShort( 0x3f2 ),	/* Offset= 1010 (1190) */
/* 182 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 184 */	NdrFcShort( 0x2 ),	/* Offset= 2 (186) */
/* 186 */	
			0x13, 0x0,	/* FC_OP */
/* 188 */	NdrFcShort( 0x3d8 ),	/* Offset= 984 (1172) */
/* 190 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 192 */	NdrFcShort( 0x18 ),	/* 24 */
/* 194 */	NdrFcShort( 0xa ),	/* 10 */
/* 196 */	NdrFcLong( 0x8 ),	/* 8 */
/* 200 */	NdrFcShort( 0x70 ),	/* Offset= 112 (312) */
/* 202 */	NdrFcLong( 0xd ),	/* 13 */
/* 206 */	NdrFcShort( 0xa6 ),	/* Offset= 166 (372) */
/* 208 */	NdrFcLong( 0x9 ),	/* 9 */
/* 212 */	NdrFcShort( 0xd8 ),	/* Offset= 216 (428) */
/* 214 */	NdrFcLong( 0xc ),	/* 12 */
/* 218 */	NdrFcShort( 0x2bc ),	/* Offset= 700 (918) */
/* 220 */	NdrFcLong( 0x24 ),	/* 36 */
/* 224 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (966) */
/* 226 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 230 */	NdrFcShort( 0x302 ),	/* Offset= 770 (1000) */
/* 232 */	NdrFcLong( 0x10 ),	/* 16 */
/* 236 */	NdrFcShort( 0x31c ),	/* Offset= 796 (1032) */
/* 238 */	NdrFcLong( 0x2 ),	/* 2 */
/* 242 */	NdrFcShort( 0x336 ),	/* Offset= 822 (1064) */
/* 244 */	NdrFcLong( 0x3 ),	/* 3 */
/* 248 */	NdrFcShort( 0x350 ),	/* Offset= 848 (1096) */
/* 250 */	NdrFcLong( 0x14 ),	/* 20 */
/* 254 */	NdrFcShort( 0x36a ),	/* Offset= 874 (1128) */
/* 256 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (255) */
/* 258 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 264 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 266 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 268 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 270 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (258) */
/* 276 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 278 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 280 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 282 */	NdrFcShort( 0x4 ),	/* 4 */
/* 284 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 290 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 292 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 298 */	NdrFcShort( 0x1 ),	/* 1 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	0x13, 0x0,	/* FC_OP */
/* 306 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (270) */
/* 308 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 312 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 316 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 318 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 320 */	NdrFcShort( 0x4 ),	/* 4 */
/* 322 */	NdrFcShort( 0x4 ),	/* 4 */
/* 324 */	0x11, 0x0,	/* FC_RP */
/* 326 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (280) */
/* 328 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 330 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 332 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 342 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 344 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 346 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 348 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 350 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 354 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 360 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 364 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (332) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x6 ),	/* Offset= 6 (384) */
/* 380 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 382 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 384 */	
			0x11, 0x0,	/* FC_RP */
/* 386 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (350) */
/* 388 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 390 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 400 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 402 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 404 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 406 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 416 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 420 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (388) */
/* 426 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 428 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x6 ),	/* Offset= 6 (440) */
/* 436 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 438 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 440 */	
			0x11, 0x0,	/* FC_RP */
/* 442 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (406) */
/* 444 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 446 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 448 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 450 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 452 */	NdrFcShort( 0x2 ),	/* Offset= 2 (454) */
/* 454 */	NdrFcShort( 0x10 ),	/* 16 */
/* 456 */	NdrFcShort( 0x2b ),	/* 43 */
/* 458 */	NdrFcLong( 0x3 ),	/* 3 */
/* 462 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 464 */	NdrFcLong( 0x11 ),	/* 17 */
/* 468 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 470 */	NdrFcLong( 0x2 ),	/* 2 */
/* 474 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 476 */	NdrFcLong( 0x4 ),	/* 4 */
/* 480 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 482 */	NdrFcLong( 0x5 ),	/* 5 */
/* 486 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 488 */	NdrFcLong( 0xb ),	/* 11 */
/* 492 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 494 */	NdrFcLong( 0xa ),	/* 10 */
/* 498 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 500 */	NdrFcLong( 0x6 ),	/* 6 */
/* 504 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (718) */
/* 506 */	NdrFcLong( 0x7 ),	/* 7 */
/* 510 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 512 */	NdrFcLong( 0x8 ),	/* 8 */
/* 516 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (724) */
/* 518 */	NdrFcLong( 0xd ),	/* 13 */
/* 522 */	NdrFcShort( 0xffffff42 ),	/* Offset= -190 (332) */
/* 524 */	NdrFcLong( 0x9 ),	/* 9 */
/* 528 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (388) */
/* 530 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 534 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (728) */
/* 536 */	NdrFcLong( 0x24 ),	/* 36 */
/* 540 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (736) */
/* 542 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 546 */	NdrFcShort( 0xbe ),	/* Offset= 190 (736) */
/* 548 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 552 */	NdrFcShort( 0xee ),	/* Offset= 238 (790) */
/* 554 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 558 */	NdrFcShort( 0xec ),	/* Offset= 236 (794) */
/* 560 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 564 */	NdrFcShort( 0xea ),	/* Offset= 234 (798) */
/* 566 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 570 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (802) */
/* 572 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 576 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (806) */
/* 578 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 582 */	NdrFcShort( 0xd4 ),	/* Offset= 212 (794) */
/* 584 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 588 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (798) */
/* 590 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 594 */	NdrFcShort( 0xd8 ),	/* Offset= 216 (810) */
/* 596 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 600 */	NdrFcShort( 0xce ),	/* Offset= 206 (806) */
/* 602 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 606 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (814) */
/* 608 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 612 */	NdrFcShort( 0xce ),	/* Offset= 206 (818) */
/* 614 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 618 */	NdrFcShort( 0xcc ),	/* Offset= 204 (822) */
/* 620 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 624 */	NdrFcShort( 0xca ),	/* Offset= 202 (826) */
/* 626 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 630 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (838) */
/* 632 */	NdrFcLong( 0x10 ),	/* 16 */
/* 636 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 638 */	NdrFcLong( 0x12 ),	/* 18 */
/* 642 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 644 */	NdrFcLong( 0x13 ),	/* 19 */
/* 648 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 650 */	NdrFcLong( 0x16 ),	/* 22 */
/* 654 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 656 */	NdrFcLong( 0x17 ),	/* 23 */
/* 660 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 662 */	NdrFcLong( 0xe ),	/* 14 */
/* 666 */	NdrFcShort( 0xb4 ),	/* Offset= 180 (846) */
/* 668 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 672 */	NdrFcShort( 0xba ),	/* Offset= 186 (858) */
/* 674 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 678 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (862) */
/* 680 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 684 */	NdrFcShort( 0x6e ),	/* Offset= 110 (794) */
/* 686 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 690 */	NdrFcShort( 0x6c ),	/* Offset= 108 (798) */
/* 692 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 696 */	NdrFcShort( 0x66 ),	/* Offset= 102 (798) */
/* 698 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 702 */	NdrFcShort( 0x60 ),	/* Offset= 96 (798) */
/* 704 */	NdrFcLong( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0x0 ),	/* Offset= 0 (708) */
/* 710 */	NdrFcLong( 0x1 ),	/* 1 */
/* 714 */	NdrFcShort( 0x0 ),	/* Offset= 0 (714) */
/* 716 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (715) */
/* 718 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 720 */	NdrFcShort( 0x8 ),	/* 8 */
/* 722 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 724 */	
			0x13, 0x0,	/* FC_OP */
/* 726 */	NdrFcShort( 0xfffffe38 ),	/* Offset= -456 (270) */
/* 728 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 730 */	NdrFcShort( 0x2 ),	/* Offset= 2 (732) */
/* 732 */	
			0x13, 0x0,	/* FC_OP */
/* 734 */	NdrFcShort( 0x1b6 ),	/* Offset= 438 (1172) */
/* 736 */	
			0x13, 0x0,	/* FC_OP */
/* 738 */	NdrFcShort( 0x20 ),	/* Offset= 32 (770) */
/* 740 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 742 */	NdrFcLong( 0x2f ),	/* 47 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 752 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 754 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 756 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 758 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 760 */	NdrFcShort( 0x1 ),	/* 1 */
/* 762 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 764 */	NdrFcShort( 0x4 ),	/* 4 */
/* 766 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 768 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 770 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 772 */	NdrFcShort( 0x10 ),	/* 16 */
/* 774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 776 */	NdrFcShort( 0xa ),	/* Offset= 10 (786) */
/* 778 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 780 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 782 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (740) */
/* 784 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 786 */	
			0x13, 0x0,	/* FC_OP */
/* 788 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (758) */
/* 790 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 792 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 794 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 796 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 798 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 800 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 802 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 804 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 806 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 808 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 810 */	
			0x13, 0x0,	/* FC_OP */
/* 812 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (718) */
/* 814 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 816 */	NdrFcShort( 0xffffffa4 ),	/* Offset= -92 (724) */
/* 818 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 820 */	NdrFcShort( 0xfffffe18 ),	/* Offset= -488 (332) */
/* 822 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 824 */	NdrFcShort( 0xfffffe4c ),	/* Offset= -436 (388) */
/* 826 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 828 */	NdrFcShort( 0x2 ),	/* Offset= 2 (830) */
/* 830 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 832 */	NdrFcShort( 0x2 ),	/* Offset= 2 (834) */
/* 834 */	
			0x13, 0x0,	/* FC_OP */
/* 836 */	NdrFcShort( 0x150 ),	/* Offset= 336 (1172) */
/* 838 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 840 */	NdrFcShort( 0x2 ),	/* Offset= 2 (842) */
/* 842 */	
			0x13, 0x0,	/* FC_OP */
/* 844 */	NdrFcShort( 0x16 ),	/* Offset= 22 (866) */
/* 846 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 852 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 854 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 856 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 858 */	
			0x13, 0x0,	/* FC_OP */
/* 860 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (846) */
/* 862 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 864 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 866 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 868 */	NdrFcShort( 0x20 ),	/* 32 */
/* 870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 872 */	NdrFcShort( 0x0 ),	/* Offset= 0 (872) */
/* 874 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 876 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 878 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 880 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 882 */	NdrFcShort( 0xfffffe4a ),	/* Offset= -438 (444) */
/* 884 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 886 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 888 */	NdrFcShort( 0x4 ),	/* 4 */
/* 890 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 896 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 900 */	NdrFcShort( 0x4 ),	/* 4 */
/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 904 */	NdrFcShort( 0x1 ),	/* 1 */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 910 */	0x13, 0x0,	/* FC_OP */
/* 912 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (866) */
/* 914 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 916 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 918 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x6 ),	/* Offset= 6 (930) */
/* 926 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x11, 0x0,	/* FC_RP */
/* 932 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (886) */
/* 934 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 936 */	NdrFcShort( 0x4 ),	/* 4 */
/* 938 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 942 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 944 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 946 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 948 */	NdrFcShort( 0x4 ),	/* 4 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x1 ),	/* 1 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 958 */	0x13, 0x0,	/* FC_OP */
/* 960 */	NdrFcShort( 0xffffff42 ),	/* Offset= -190 (770) */
/* 962 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 966 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 968 */	NdrFcShort( 0x8 ),	/* 8 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x6 ),	/* Offset= 6 (978) */
/* 974 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 976 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 978 */	
			0x11, 0x0,	/* FC_RP */
/* 980 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (934) */
/* 982 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 984 */	NdrFcShort( 0x8 ),	/* 8 */
/* 986 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 988 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 990 */	NdrFcShort( 0x10 ),	/* 16 */
/* 992 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 994 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 996 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (982) */
			0x5b,		/* FC_END */
/* 1000 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1002 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0xa ),	/* Offset= 10 (1016) */
/* 1008 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1010 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1012 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (988) */
/* 1014 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1016 */	
			0x11, 0x0,	/* FC_RP */
/* 1018 */	NdrFcShort( 0xfffffd64 ),	/* Offset= -668 (350) */
/* 1020 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1022 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1024 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1030 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1032 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1034 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1036 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1038 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1040 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1042 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1044 */	0x13, 0x0,	/* FC_OP */
/* 1046 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1020) */
/* 1048 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1050 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1052 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1054 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1056 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1060 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1062 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1064 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1068 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1070 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1072 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1074 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1076 */	0x13, 0x0,	/* FC_OP */
/* 1078 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1052) */
/* 1080 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1082 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1084 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1088 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1094 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1096 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1102 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1104 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1106 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1108 */	0x13, 0x0,	/* FC_OP */
/* 1110 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1084) */
/* 1112 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1114 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1116 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1120 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1126 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1128 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1132 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1134 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1136 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1140 */	0x13, 0x0,	/* FC_OP */
/* 1142 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1116) */
/* 1144 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1146 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1148 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1152 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1160 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1162 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1168 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1148) */
/* 1170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1174 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1176 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1156) */
/* 1178 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1178) */
/* 1180 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1182 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 1184 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1186 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffc1b ),	/* Offset= -997 (190) */
			0x5b,		/* FC_END */
/* 1190 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1192 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1194 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	NdrFcShort( 0xfffffc08 ),	/* Offset= -1016 (182) */
/* 1200 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1202 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1204) */
/* 1204 */	
			0x12, 0x0,	/* FC_UP */
/* 1206 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (1172) */
/* 1208 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1210 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1200) */
/* 1218 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1220 */	NdrFcShort( 0xfffffe9a ),	/* Offset= -358 (862) */
/* 1222 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1224 */	NdrFcShort( 0xfffffe06 ),	/* Offset= -506 (718) */
/* 1226 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1228 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1230 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1232 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1234 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1236 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1238 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1240 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 1242 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1244 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1246) */
/* 1246 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1248 */	NdrFcLong( 0xd5778ae3 ),	/* -713585949 */
/* 1252 */	NdrFcShort( 0x43de ),	/* 17374 */
/* 1254 */	NdrFcShort( 0x11d0 ),	/* 4560 */
/* 1256 */	0x91,		/* 145 */
			0x71,		/* 113 */
/* 1258 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 1260 */	0x0,		/* 0 */
			0xc1,		/* 193 */
/* 1262 */	0x80,		/* 128 */
			0x68,		/* 104 */
/* 1264 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1266 */	0xe,		/* FC_ENUM32 */
			0x5c,		/* FC_PAD */
/* 1268 */	
			0x12, 0x0,	/* FC_UP */
/* 1270 */	NdrFcShort( 0xfffffc18 ),	/* Offset= -1000 (270) */
/* 1272 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1274 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1276 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1280 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1268) */
/* 1282 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1284 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1286) */
/* 1286 */	
			0x13, 0x0,	/* FC_OP */
/* 1288 */	NdrFcShort( 0xfffffed4 ),	/* Offset= -300 (988) */
/* 1290 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1292 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1294) */
/* 1294 */	
			0x13, 0x0,	/* FC_OP */
/* 1296 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1298) */
/* 1298 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1300 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1302 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1304 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 1306 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1308 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

const CInterfaceProxyVtbl * _scardssp_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISCardTypeConvProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardISO7816ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardDatabaseProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardLocateProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardCmdProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IByteBufferProxyVtbl,
    0
};

const CInterfaceStubVtbl * _scardssp_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISCardTypeConvStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardISO7816StubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardDatabaseStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardLocateStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardCmdStubVtbl,
    ( CInterfaceStubVtbl *) &_IByteBufferStubVtbl,
    0
};

PCInterfaceName const _scardssp_InterfaceNamesList[] = 
{
    "ISCardTypeConv",
    "ISCardISO7816",
    "ISCard",
    "ISCardDatabase",
    "ISCardLocate",
    "ISCardCmd",
    "IByteBuffer",
    0
};

const IID *  _scardssp_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _scardssp_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _scardssp, pIID, n)

int __stdcall _scardssp_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _scardssp, 7, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _scardssp, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _scardssp, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _scardssp, 7, *pIndex )
    
}

const ExtendedProxyFileInfo scardssp_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _scardssp_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _scardssp_StubVtblList,
    (const PCInterfaceName * ) & _scardssp_InterfaceNamesList,
    (const IID ** ) & _scardssp_BaseIIDList,
    & _scardssp_IID_Lookup, 
    7,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 01 16:58:17 1999
 */
/* Compiler settings for scardssp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "scardssp.h"

#define TYPE_FORMAT_STRING_SIZE   1273                              
#define PROC_FORMAT_STRING_SIZE   4079                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   3            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Standard interface: __MIDL_itf_scardssp_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IByteBuffer, ver. 0.0,
   GUID={0xE126F8FE,0xA7AF,0x11D0,{0xB8,0x8A,0x00,0xC0,0x4F,0xD4,0x24,0xB9}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IByteBuffer_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short IByteBuffer_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    38,
    76,
    114,
    152,
    208,
    252,
    302,
    352,
    384,
    434,
    472,
    516,
    566
    };

static const MIDL_SERVER_INFO IByteBuffer_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IByteBuffer_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IByteBuffer_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IByteBuffer_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(21) _IByteBufferProxyVtbl = 
{
    &IByteBuffer_ProxyInfo,
    &IID_IByteBuffer,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IByteBuffer::get_Stream */ ,
    (void *)-1 /* IByteBuffer::put_Stream */ ,
    (void *)-1 /* IByteBuffer::Clone */ ,
    (void *)-1 /* IByteBuffer::Commit */ ,
    (void *)-1 /* IByteBuffer::CopyTo */ ,
    (void *)-1 /* IByteBuffer::Initialize */ ,
    (void *)-1 /* IByteBuffer::LockRegion */ ,
    (void *)-1 /* IByteBuffer::Read */ ,
    (void *)-1 /* IByteBuffer::Revert */ ,
    (void *)-1 /* IByteBuffer::Seek */ ,
    (void *)-1 /* IByteBuffer::SetSize */ ,
    (void *)-1 /* IByteBuffer::Stat */ ,
    (void *)-1 /* IByteBuffer::UnlockRegion */ ,
    (void *)-1 /* IByteBuffer::Write */
};


static const PRPC_STUB_FUNCTION IByteBuffer_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IByteBufferStubVtbl =
{
    &IID_IByteBuffer,
    &IByteBuffer_ServerInfo,
    21,
    &IByteBuffer_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0244, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardTypeConv, ver. 0.0,
   GUID={0x53B6AA63,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardTypeConv_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardTypeConv_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    616,
    666,
    710,
    754,
    798,
    842,
    886,
    930,
    974,
    1018
    };

static const MIDL_SERVER_INFO ISCardTypeConv_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardTypeConv_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardTypeConv_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardTypeConv_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(17) _ISCardTypeConvProxyVtbl = 
{
    &ISCardTypeConv_ProxyInfo,
    &IID_ISCardTypeConv,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteArrayToByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteBufferToByteArray */ ,
    (void *)-1 /* ISCardTypeConv::ConvertByteBufferToSafeArray */ ,
    (void *)-1 /* ISCardTypeConv::ConvertSafeArrayToByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::CreateByteArray */ ,
    (void *)-1 /* ISCardTypeConv::CreateByteBuffer */ ,
    (void *)-1 /* ISCardTypeConv::CreateSafeArray */ ,
    (void *)-1 /* ISCardTypeConv::FreeIStreamMemoryPtr */ ,
    (void *)-1 /* ISCardTypeConv::GetAtIStreamMemory */ ,
    (void *)-1 /* ISCardTypeConv::SizeOfIStream */
};


static const PRPC_STUB_FUNCTION ISCardTypeConv_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardTypeConvStubVtbl =
{
    &IID_ISCardTypeConv,
    &ISCardTypeConv_ServerInfo,
    17,
    &ISCardTypeConv_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0245, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardCmd, ver. 0.0,
   GUID={0xD5778AE3,0x43DE,0x11D0,{0x91,0x71,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardCmd_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardCmd_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1062,
    1100,
    1138,
    1176,
    1214,
    1252,
    1290,
    1328,
    1366,
    1404,
    1442,
    1480,
    1518,
    1556,
    1594,
    1632,
    1670,
    1708,
    1746,
    1784,
    1822,
    1860,
    1898,
    1936,
    1974,
    2012,
    2050,
    2088,
    2126,
    2194,
    2226,
    2270,
    2308
    };

static const MIDL_SERVER_INFO ISCardCmd_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardCmd_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardCmd_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardCmd_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(40) _ISCardCmdProxyVtbl = 
{
    &ISCardCmd_ProxyInfo,
    &IID_ISCardCmd,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardCmd::get_Apdu */ ,
    (void *)-1 /* ISCardCmd::put_Apdu */ ,
    (void *)-1 /* ISCardCmd::get_ApduLength */ ,
    (void *)-1 /* ISCardCmd::get_ApduReply */ ,
    (void *)-1 /* ISCardCmd::put_ApduReply */ ,
    (void *)-1 /* ISCardCmd::get_ApduReplyLength */ ,
    (void *)-1 /* ISCardCmd::put_ApduReplyLength */ ,
    (void *)-1 /* ISCardCmd::get_ClassId */ ,
    (void *)-1 /* ISCardCmd::put_ClassId */ ,
    (void *)-1 /* ISCardCmd::get_Data */ ,
    (void *)-1 /* ISCardCmd::put_Data */ ,
    (void *)-1 /* ISCardCmd::get_InstructionId */ ,
    (void *)-1 /* ISCardCmd::put_InstructionId */ ,
    (void *)-1 /* ISCardCmd::get_LeField */ ,
    (void *)-1 /* ISCardCmd::get_P1 */ ,
    (void *)-1 /* ISCardCmd::put_P1 */ ,
    (void *)-1 /* ISCardCmd::get_P2 */ ,
    (void *)-1 /* ISCardCmd::put_P2 */ ,
    (void *)-1 /* ISCardCmd::get_P3 */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatus */ ,
    (void *)-1 /* ISCardCmd::put_ReplyStatus */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatusSW1 */ ,
    (void *)-1 /* ISCardCmd::get_ReplyStatusSW2 */ ,
    (void *)-1 /* ISCardCmd::get_Type */ ,
    (void *)-1 /* ISCardCmd::get_Nad */ ,
    (void *)-1 /* ISCardCmd::put_Nad */ ,
    (void *)-1 /* ISCardCmd::get_ReplyNad */ ,
    (void *)-1 /* ISCardCmd::put_ReplyNad */ ,
    (void *)-1 /* ISCardCmd::BuildCmd */ ,
    (void *)-1 /* ISCardCmd::Clear */ ,
    (void *)-1 /* ISCardCmd::Encapsulate */ ,
    (void *)-1 /* ISCardCmd::get_AlternateClassId */ ,
    (void *)-1 /* ISCardCmd::put_AlternateClassId */
};


static const PRPC_STUB_FUNCTION ISCardCmd_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardCmdStubVtbl =
{
    &IID_ISCardCmd,
    &ISCardCmd_ServerInfo,
    40,
    &ISCardCmd_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0246, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardISO7816, ver. 0.0,
   GUID={0x53B6AA68,0x3F56,0x11D0,{0x91,0x6B,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardISO7816_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardISO7816_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    2346,
    2396,
    2452,
    2508,
    2552,
    2608,
    2664,
    2726,
    2776,
    2832,
    2888,
    2944,
    1518,
    3006,
    3062,
    3118,
    3168,
    3224
    };

static const MIDL_SERVER_INFO ISCardISO7816_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardISO7816_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardISO7816_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardISO7816_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(25) _ISCardISO7816ProxyVtbl = 
{
    &ISCardISO7816_ProxyInfo,
    &IID_ISCardISO7816,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardISO7816::AppendRecord */ ,
    (void *)-1 /* ISCardISO7816::EraseBinary */ ,
    (void *)-1 /* ISCardISO7816::ExternalAuthenticate */ ,
    (void *)-1 /* ISCardISO7816::GetChallenge */ ,
    (void *)-1 /* ISCardISO7816::GetData */ ,
    (void *)-1 /* ISCardISO7816::GetResponse */ ,
    (void *)-1 /* ISCardISO7816::InternalAuthenticate */ ,
    (void *)-1 /* ISCardISO7816::ManageChannel */ ,
    (void *)-1 /* ISCardISO7816::PutData */ ,
    (void *)-1 /* ISCardISO7816::ReadBinary */ ,
    (void *)-1 /* ISCardISO7816::ReadRecord */ ,
    (void *)-1 /* ISCardISO7816::SelectFile */ ,
    (void *)-1 /* ISCardISO7816::SetDefaultClassId */ ,
    (void *)-1 /* ISCardISO7816::UpdateBinary */ ,
    (void *)-1 /* ISCardISO7816::UpdateRecord */ ,
    (void *)-1 /* ISCardISO7816::Verify */ ,
    (void *)-1 /* ISCardISO7816::WriteBinary */ ,
    (void *)-1 /* ISCardISO7816::WriteRecord */
};


static const PRPC_STUB_FUNCTION ISCardISO7816_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardISO7816StubVtbl =
{
    &IID_ISCardISO7816,
    &ISCardISO7816_ServerInfo,
    25,
    &ISCardISO7816_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0247, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCard, ver. 0.0,
   GUID={0x1461AAC3,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCard_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCard_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1062,
    3280,
    3318,
    3356,
    3394,
    3432,
    3470,
    3520,
    352,
    3558,
    3602,
    3640
    };

static const MIDL_SERVER_INFO ISCard_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCard_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCard_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCard_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(19) _ISCardProxyVtbl = 
{
    &ISCard_ProxyInfo,
    &IID_ISCard,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCard::get_Atr */ ,
    (void *)-1 /* ISCard::get_CardHandle */ ,
    (void *)-1 /* ISCard::get_Context */ ,
    (void *)-1 /* ISCard::get_Protocol */ ,
    (void *)-1 /* ISCard::get_Status */ ,
    (void *)-1 /* ISCard::AttachByHandle */ ,
    (void *)-1 /* ISCard::AttachByReader */ ,
    (void *)-1 /* ISCard::Detach */ ,
    (void *)-1 /* ISCard::LockSCard */ ,
    (void *)-1 /* ISCard::ReAttach */ ,
    (void *)-1 /* ISCard::Transaction */ ,
    (void *)-1 /* ISCard::UnlockSCard */
};


static const PRPC_STUB_FUNCTION ISCard_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardStubVtbl =
{
    &IID_ISCard,
    &ISCard_ServerInfo,
    19,
    &ISCard_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0248, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardDatabase, ver. 0.0,
   GUID={0x1461AAC8,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardDatabase_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardDatabase_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    3678,
    3722,
    3766,
    3822,
    3866
    };

static const MIDL_SERVER_INFO ISCardDatabase_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardDatabase_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardDatabase_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardDatabase_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(12) _ISCardDatabaseProxyVtbl = 
{
    &ISCardDatabase_ProxyInfo,
    &IID_ISCardDatabase,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardDatabase::GetProviderCardId */ ,
    (void *)-1 /* ISCardDatabase::ListCardInterfaces */ ,
    (void *)-1 /* ISCardDatabase::ListCards */ ,
    (void *)-1 /* ISCardDatabase::ListReaderGroups */ ,
    (void *)-1 /* ISCardDatabase::ListReaders */
};


static const PRPC_STUB_FUNCTION ISCardDatabase_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardDatabaseStubVtbl =
{
    &IID_ISCardDatabase,
    &ISCardDatabase_ServerInfo,
    12,
    &ISCardDatabase_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0249, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISCardLocate, ver. 0.0,
   GUID={0x1461AACD,0x6810,0x11D0,{0x91,0x8F,0x00,0xAA,0x00,0xC1,0x80,0x68}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISCardLocate_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISCardLocate_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    3910,
    3966,
    4022
    };

static const MIDL_SERVER_INFO ISCardLocate_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISCardLocate_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISCardLocate_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISCardLocate_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(10) _ISCardLocateProxyVtbl = 
{
    &ISCardLocate_ProxyInfo,
    &IID_ISCardLocate,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISCardLocate::ConfigureCardGuidSearch */ ,
    (void *)-1 /* ISCardLocate::ConfigureCardNameSearch */ ,
    (void *)-1 /* ISCardLocate::FindCard */
};


static const PRPC_STUB_FUNCTION ISCardLocate_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISCardLocateStubVtbl =
{
    &IID_ISCardLocate,
    &ISCardLocate_ServerInfo,
    10,
    &ISCardLocate_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Standard interface: __MIDL_itf_scardssp_0250, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x5030117, /* MIDL Version 5.3.279 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HGLOBAL_UserSize
            ,HGLOBAL_UserMarshal
            ,HGLOBAL_UserUnmarshal
            ,HGLOBAL_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure get_Stream */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppStream */

/* 26 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Stream */

/* 38 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 54 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStream */

/* 64 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 66 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 68 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 72 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 76 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 78 */	NdrFcLong( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x9 ),	/* 9 */
/* 84 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
/* 90 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 92 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppByteBuffer */

/* 102 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 104 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 106 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Return value */

/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 110 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Commit */

/* 114 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0xa ),	/* 10 */
/* 122 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 130 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter grfCommitFlags */

/* 140 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 142 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 146 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 148 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 150 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CopyTo */

/* 152 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 154 */	NdrFcLong( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0xb ),	/* 11 */
/* 160 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 162 */	NdrFcShort( 0x18 ),	/* 24 */
/* 164 */	NdrFcShort( 0x18 ),	/* 24 */
/* 166 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 168 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppByteBuffer */

/* 178 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 180 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 182 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Parameter cb */

/* 184 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 186 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 188 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 190 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 192 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 196 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 198 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 204 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 208 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0xc ),	/* 12 */
/* 216 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 218 */	NdrFcShort( 0xd ),	/* 13 */
/* 220 */	NdrFcShort( 0x8 ),	/* 8 */
/* 222 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 224 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lSize */

/* 234 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 236 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pData */

/* 240 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 242 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 244 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 248 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LockRegion */

/* 252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0xd ),	/* 13 */
/* 260 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 262 */	NdrFcShort( 0x18 ),	/* 24 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 268 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libOffset */

/* 278 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 280 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cb */

/* 284 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 286 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLockType */

/* 290 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 292 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 294 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 296 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 298 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 300 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Read */

/* 302 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 304 */	NdrFcLong( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0xe ),	/* 14 */
/* 310 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 312 */	NdrFcShort( 0x15 ),	/* 21 */
/* 314 */	NdrFcShort( 0x15 ),	/* 21 */
/* 316 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 318 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pByte */

/* 328 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 330 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 332 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter cb */

/* 334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 336 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 340 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 342 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LockSCard */


	/* Procedure Revert */

/* 352 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0xf ),	/* 15 */
/* 360 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 364 */	NdrFcShort( 0x8 ),	/* 8 */
/* 366 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 368 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */


	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Seek */

/* 384 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x10 ),	/* 16 */
/* 392 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 394 */	NdrFcShort( 0x18 ),	/* 24 */
/* 396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 398 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 400 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 402 */	NdrFcShort( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dLibMove */

/* 410 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 412 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 414 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwOrigin */

/* 416 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 418 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pLibnewPosition */

/* 422 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 424 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 428 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 430 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 432 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSize */

/* 434 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 436 */	NdrFcLong( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x11 ),	/* 17 */
/* 442 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	NdrFcShort( 0x8 ),	/* 8 */
/* 448 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 450 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libNewSize */

/* 460 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 462 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stat */

/* 472 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 474 */	NdrFcLong( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x12 ),	/* 18 */
/* 480 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 482 */	NdrFcShort( 0x24 ),	/* 36 */
/* 484 */	NdrFcShort( 0x24 ),	/* 36 */
/* 486 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 488 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 496 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pstatstg */

/* 498 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 500 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 502 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Parameter grfStatFlag */

/* 504 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 506 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 508 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 510 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 512 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 514 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnlockRegion */

/* 516 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 518 */	NdrFcLong( 0x0 ),	/* 0 */
/* 522 */	NdrFcShort( 0x13 ),	/* 19 */
/* 524 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 526 */	NdrFcShort( 0x18 ),	/* 24 */
/* 528 */	NdrFcShort( 0x8 ),	/* 8 */
/* 530 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 532 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter libOffset */

/* 542 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 544 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 546 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cb */

/* 548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 550 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLockType */

/* 554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 556 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 560 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 562 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 564 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Write */

/* 566 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 568 */	NdrFcLong( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x14 ),	/* 20 */
/* 574 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 576 */	NdrFcShort( 0x15 ),	/* 21 */
/* 578 */	NdrFcShort( 0x15 ),	/* 21 */
/* 580 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 582 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pByte */

/* 592 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 594 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 596 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter cb */

/* 598 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 600 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 602 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 604 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 606 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 610 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 612 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 614 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteArrayToByteBuffer */

/* 616 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 618 */	NdrFcLong( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x7 ),	/* 7 */
/* 624 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 626 */	NdrFcShort( 0xd ),	/* 13 */
/* 628 */	NdrFcShort( 0x8 ),	/* 8 */
/* 630 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 632 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyArray */

/* 642 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 644 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 646 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwArraySize */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyBuffer */

/* 654 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 656 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 658 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 662 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteBufferToByteArray */

/* 666 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 674 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 682 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 684 */	NdrFcShort( 0x3 ),	/* 3 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyBuffer */

/* 692 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 694 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 696 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppArray */

/* 698 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 700 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 702 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Return value */

/* 704 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 706 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertByteBufferToSafeArray */

/* 710 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x9 ),	/* 9 */
/* 718 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x8 ),	/* 8 */
/* 724 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 726 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 728 */	NdrFcShort( 0x12 ),	/* 18 */
/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyBuffer */

/* 736 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 738 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 740 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppbyArray */

/* 742 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 744 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 746 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 748 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 750 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConvertSafeArrayToByteBuffer */

/* 754 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0xa ),	/* 10 */
/* 762 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 766 */	NdrFcShort( 0x8 ),	/* 8 */
/* 768 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 770 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 774 */	NdrFcShort( 0x12 ),	/* 18 */
/* 776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 778 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyArray */

/* 780 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 782 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 784 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter ppbyBuff */

/* 786 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 788 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 790 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 792 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 794 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateByteArray */

/* 798 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 800 */	NdrFcLong( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0xb ),	/* 11 */
/* 806 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 810 */	NdrFcShort( 0x15 ),	/* 21 */
/* 812 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 814 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 820 */	NdrFcShort( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwAllocSize */

/* 824 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 826 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 828 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyArray */

/* 830 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
/* 832 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 834 */	NdrFcShort( 0x492 ),	/* Type Offset=1170 */

	/* Return value */

/* 836 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 838 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateByteBuffer */

/* 842 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 844 */	NdrFcLong( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0xc ),	/* 12 */
/* 850 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 852 */	NdrFcShort( 0x8 ),	/* 8 */
/* 854 */	NdrFcShort( 0x8 ),	/* 8 */
/* 856 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 858 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 864 */	NdrFcShort( 0x0 ),	/* 0 */
/* 866 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwAllocSize */

/* 868 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 870 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppbyBuff */

/* 874 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 876 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 878 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 880 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 882 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 884 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateSafeArray */

/* 886 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 888 */	NdrFcLong( 0x0 ),	/* 0 */
/* 892 */	NdrFcShort( 0xd ),	/* 13 */
/* 894 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 896 */	NdrFcShort( 0x8 ),	/* 8 */
/* 898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 900 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 902 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 904 */	NdrFcShort( 0x12 ),	/* 18 */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 910 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter nAllocSize */

/* 912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 914 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppArray */

/* 918 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 920 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 922 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 924 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 926 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 928 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FreeIStreamMemoryPtr */

/* 930 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 932 */	NdrFcLong( 0x0 ),	/* 0 */
/* 936 */	NdrFcShort( 0xe ),	/* 14 */
/* 938 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 940 */	NdrFcShort( 0x5 ),	/* 5 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 946 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 960 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter pMem */

/* 962 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 964 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 966 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 968 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 970 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 972 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAtIStreamMemory */

/* 974 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 976 */	NdrFcLong( 0x0 ),	/* 0 */
/* 980 */	NdrFcShort( 0xf ),	/* 15 */
/* 982 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 988 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 990 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 992 */	NdrFcShort( 0x3 ),	/* 3 */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 1000 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1002 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1004 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppMem */

/* 1006 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1008 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1010 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Return value */

/* 1012 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1014 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1016 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SizeOfIStream */

/* 1018 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1020 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1024 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1026 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1030 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1032 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1034 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStrm */

/* 1044 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1046 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1048 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter puliSize */

/* 1050 */	NdrFcShort( 0x2112 ),	/* Flags:  must free, out, simple ref, srv alloc size=8 */
/* 1052 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1054 */	NdrFcShort( 0x2c0 ),	/* Type Offset=704 */

	/* Return value */

/* 1056 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1058 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Atr */


	/* Procedure get_Apdu */

/* 1062 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1064 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1068 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1070 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1078 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppAtr */


	/* Parameter ppApdu */

/* 1088 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1090 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1092 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */


	/* Return value */

/* 1094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1096 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Apdu */

/* 1100 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1108 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1114 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1116 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pApdu */

/* 1126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1128 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1130 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1134 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ApduLength */

/* 1138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1144 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1146 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1152 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1154 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plSize */

/* 1164 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1166 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1170 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1172 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1174 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ApduReply */

/* 1176 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1178 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1182 */	NdrFcShort( 0xa ),	/* 10 */
/* 1184 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1190 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1192 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1200 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppReplyApdu */

/* 1202 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1204 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1206 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 1208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1210 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ApduReply */

/* 1214 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1220 */	NdrFcShort( 0xb ),	/* 11 */
/* 1222 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1230 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1238 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pReplyApdu */

/* 1240 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1242 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1244 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1248 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ApduReplyLength */

/* 1252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1258 */	NdrFcShort( 0xc ),	/* 12 */
/* 1260 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1264 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1266 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1268 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1276 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plSize */

/* 1278 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1280 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1286 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ApduReplyLength */

/* 1290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0xd ),	/* 13 */
/* 1298 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1300 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lSize */

/* 1316 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1318 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1324 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ClassId */

/* 1328 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1334 */	NdrFcShort( 0xe ),	/* 14 */
/* 1336 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	NdrFcShort( 0xd ),	/* 13 */
/* 1342 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1344 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1348 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1352 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyClass */

/* 1354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1356 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1358 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1362 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ClassId */

/* 1366 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1372 */	NdrFcShort( 0xf ),	/* 15 */
/* 1374 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1376 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1378 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1380 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1382 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */

/* 1392 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1394 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1396 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1400 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Data */

/* 1404 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1412 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1416 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1418 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1420 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppData */

/* 1430 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1432 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1434 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 1436 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1438 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Data */

/* 1442 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1448 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1450 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1454 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1456 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1458 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1462 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1466 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pData */

/* 1468 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1470 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1472 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 1474 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1476 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_InstructionId */

/* 1480 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1482 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1486 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1488 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1492 */	NdrFcShort( 0xd ),	/* 13 */
/* 1494 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1496 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyIns */

/* 1506 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1508 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1510 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1512 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1514 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDefaultClassId */


	/* Procedure put_InstructionId */

/* 1518 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1520 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1524 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1526 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1528 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1532 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1534 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1542 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */


	/* Parameter byIns */

/* 1544 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1546 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1548 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 1550 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1552 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_LeField */

/* 1556 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1558 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1562 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1564 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1568 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1570 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1572 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1578 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plSize */

/* 1582 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1584 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1586 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1590 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P1 */

/* 1594 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1600 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1602 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1606 */	NdrFcShort( 0xd ),	/* 13 */
/* 1608 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1610 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1618 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP1 */

/* 1620 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1622 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1624 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1626 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1628 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1630 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_P1 */

/* 1632 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1634 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1640 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1642 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1644 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1646 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1648 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1650 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1656 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 1658 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1660 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1662 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1666 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P2 */

/* 1670 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1676 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1678 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0xd ),	/* 13 */
/* 1684 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1686 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1690 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1692 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1694 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP2 */

/* 1696 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1698 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1700 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1702 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1704 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1706 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_P2 */

/* 1708 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1710 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1714 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1716 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1718 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1720 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1722 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1724 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1726 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1732 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP2 */

/* 1734 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1736 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1738 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1740 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1742 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1744 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_P3 */

/* 1746 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1748 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1752 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1754 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0xd ),	/* 13 */
/* 1760 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1762 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1770 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyP3 */

/* 1772 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1774 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1776 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1778 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1780 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatus */

/* 1784 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1786 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1790 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1792 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1796 */	NdrFcShort( 0xe ),	/* 14 */
/* 1798 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1800 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1802 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1808 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwStatus */

/* 1810 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1812 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1814 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1816 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1818 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1820 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ReplyStatus */

/* 1822 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1824 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1828 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1830 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1832 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1836 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1838 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1846 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wStatus */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1850 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1852 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1854 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1856 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1858 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatusSW1 */

/* 1860 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1862 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1866 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1868 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1872 */	NdrFcShort( 0xd ),	/* 13 */
/* 1874 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1876 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1884 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbySW1 */

/* 1886 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1888 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1890 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1892 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1894 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1896 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyStatusSW2 */

/* 1898 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1900 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1906 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1910 */	NdrFcShort( 0xd ),	/* 13 */
/* 1912 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1914 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1916 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbySW2 */

/* 1924 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1926 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1928 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Type */

/* 1936 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1948 */	NdrFcShort( 0xe ),	/* 14 */
/* 1950 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1952 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pType */

/* 1962 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 1964 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1966 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 1968 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1970 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1972 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Nad */

/* 1974 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1976 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1980 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1982 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0xd ),	/* 13 */
/* 1988 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1990 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbNad */

/* 2000 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2002 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2004 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2006 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2008 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2010 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Nad */

/* 2012 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2014 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2018 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2020 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2022 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2024 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2026 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2028 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2032 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2036 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bNad */

/* 2038 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2040 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2042 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2044 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2046 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ReplyNad */

/* 2050 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2052 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2056 */	NdrFcShort( 0x21 ),	/* 33 */
/* 2058 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2062 */	NdrFcShort( 0xd ),	/* 13 */
/* 2064 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2066 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2074 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbNad */

/* 2076 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2078 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2080 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2082 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2084 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ReplyNad */

/* 2088 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2090 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2094 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2096 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2098 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2100 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2102 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2104 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bNad */

/* 2114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2116 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2118 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2122 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BuildCmd */

/* 2126 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2128 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2132 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2134 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 2136 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2138 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2140 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 2142 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2150 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClassId */

/* 2152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2154 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2156 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byInsId */

/* 2158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2160 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2162 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP1 */

/* 2164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2166 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2168 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2170 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2172 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2174 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pbyData */

/* 2176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2178 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2180 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter plLe */

/* 2182 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2184 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2190 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clear */

/* 2194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2202 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2208 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 2210 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2218 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 2220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2222 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Encapsulate */

/* 2226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2232 */	NdrFcShort( 0x25 ),	/* 37 */
/* 2234 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2236 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2240 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2242 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pApdu */

/* 2252 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2254 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2256 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ApduType */

/* 2258 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2260 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2262 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 2264 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2266 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_AlternateClassId */

/* 2270 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2272 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2276 */	NdrFcShort( 0x26 ),	/* 38 */
/* 2278 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0xd ),	/* 13 */
/* 2284 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2286 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2294 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbyClass */

/* 2296 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2298 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2300 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2302 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2304 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2306 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_AlternateClassId */

/* 2308 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2314 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2316 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2318 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2322 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2324 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2332 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byClass */

/* 2334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2336 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2338 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2342 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AppendRecord */

/* 2346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2352 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2354 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2356 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2358 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2360 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2362 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2370 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRefCtrl */

/* 2372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2374 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2376 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2378 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2380 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2382 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2384 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2386 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2388 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2392 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EraseBinary */

/* 2396 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2404 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2406 */	NdrFcShort( 0xa ),	/* 10 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2412 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2424 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2426 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2428 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2430 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2432 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2434 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2436 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2438 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2440 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2442 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2444 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2448 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExternalAuthenticate */

/* 2452 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2458 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2460 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2462 */	NdrFcShort( 0xa ),	/* 10 */
/* 2464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2466 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byAlgorithmRef */

/* 2478 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2480 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2482 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bySecretRef */

/* 2484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2486 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2488 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pChallenge */

/* 2490 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2492 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2494 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2496 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2498 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2500 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2502 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2504 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetChallenge */

/* 2508 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2510 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2514 */	NdrFcShort( 0xa ),	/* 10 */
/* 2516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2522 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2524 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2532 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lBytesExpected */

/* 2534 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2536 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2540 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2542 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2544 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2546 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2548 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetData */

/* 2552 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2554 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2558 */	NdrFcShort( 0xb ),	/* 11 */
/* 2560 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2562 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2564 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2566 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2568 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2576 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2578 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2580 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2582 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2584 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2586 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2588 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToGet */

/* 2590 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2592 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2594 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2596 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2598 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2600 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2602 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2604 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResponse */

/* 2608 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2610 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2614 */	NdrFcShort( 0xc ),	/* 12 */
/* 2616 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2618 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2620 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2622 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2624 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2626 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2632 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2634 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2636 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2638 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2640 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2642 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2644 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lDataLength */

/* 2646 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2648 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2650 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2652 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2654 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2656 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2658 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2660 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InternalAuthenticate */

/* 2664 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2666 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2670 */	NdrFcShort( 0xd ),	/* 13 */
/* 2672 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2674 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2678 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 2680 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2682 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2688 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byAlgorithmRef */

/* 2690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2692 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2694 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bySecretRef */

/* 2696 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2698 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2700 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pChallenge */

/* 2702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2704 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2706 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter lReplyBytes */

/* 2708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2710 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2714 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2716 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2718 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2722 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ManageChannel */

/* 2726 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2728 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2732 */	NdrFcShort( 0xe ),	/* 14 */
/* 2734 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2736 */	NdrFcShort( 0xa ),	/* 10 */
/* 2738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2740 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2742 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2750 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byChannelState */

/* 2752 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2754 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2756 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byChannel */

/* 2758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2760 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2762 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2764 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2766 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2768 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2772 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure PutData */

/* 2776 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2778 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2782 */	NdrFcShort( 0xf ),	/* 15 */
/* 2784 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2786 */	NdrFcShort( 0xa ),	/* 10 */
/* 2788 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2790 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2792 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2800 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2802 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2804 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2806 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2808 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2810 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2812 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2814 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2816 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2818 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 2820 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2822 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2824 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2826 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2828 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadBinary */

/* 2832 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2834 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2838 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2840 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2842 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2844 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2846 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2848 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2852 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2856 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2858 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2860 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2862 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2866 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2868 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToRead */

/* 2870 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2872 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2874 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2876 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2878 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2880 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2882 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2884 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadRecord */

/* 2888 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2894 */	NdrFcShort( 0x11 ),	/* 17 */
/* 2896 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2898 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2902 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2904 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2910 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2912 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 2914 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2916 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2918 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 2920 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2922 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2924 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter lBytesToRead */

/* 2926 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2928 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2930 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2932 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2934 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2936 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 2938 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2940 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SelectFile */

/* 2944 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2946 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2950 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2952 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2954 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2958 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 2960 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2968 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 2970 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2972 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2974 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 2976 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2978 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2980 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 2982 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2984 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2986 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter lBytesToRead */

/* 2988 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2990 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2992 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCmd */

/* 2994 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2996 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2998 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3000 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3002 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3004 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateBinary */

/* 3006 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3008 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3012 */	NdrFcShort( 0x14 ),	/* 20 */
/* 3014 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3016 */	NdrFcShort( 0xa ),	/* 10 */
/* 3018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3020 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3022 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3024 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3030 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 3032 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3034 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3036 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 3038 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3040 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3042 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3044 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3046 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3048 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3050 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3052 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3054 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3056 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3058 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateRecord */

/* 3062 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3064 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3068 */	NdrFcShort( 0x15 ),	/* 21 */
/* 3070 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3072 */	NdrFcShort( 0xa ),	/* 10 */
/* 3074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3076 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3078 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3084 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3086 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 3088 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3090 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3092 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 3094 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3096 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3098 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3100 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3102 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3104 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3106 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3108 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3110 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3112 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3114 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Verify */

/* 3118 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3120 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3124 */	NdrFcShort( 0x16 ),	/* 22 */
/* 3126 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3128 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3132 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3134 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRefCtrl */

/* 3144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3146 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3148 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3150 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3152 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3154 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3156 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3158 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3160 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3164 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteBinary */

/* 3168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3174 */	NdrFcShort( 0x17 ),	/* 23 */
/* 3176 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3178 */	NdrFcShort( 0xa ),	/* 10 */
/* 3180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3182 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3184 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3192 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byP1 */

/* 3194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3196 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3198 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byP2 */

/* 3200 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3202 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3204 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3206 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3208 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3210 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3212 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3214 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3216 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3220 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteRecord */

/* 3224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3230 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3232 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3234 */	NdrFcShort( 0xa ),	/* 10 */
/* 3236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3238 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3240 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3248 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter byRecordId */

/* 3250 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3252 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3254 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter byRefCtrl */

/* 3256 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3258 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3260 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter pData */

/* 3262 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3264 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3266 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter ppCmd */

/* 3268 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3270 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3272 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3274 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3276 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CardHandle */

/* 3280 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3288 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3292 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3294 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3296 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pHandle */

/* 3306 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3308 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3310 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Return value */

/* 3312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3314 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Context */

/* 3318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3324 */	NdrFcShort( 0x9 ),	/* 9 */
/* 3326 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3330 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3332 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3334 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3342 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pContext */

/* 3344 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3346 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3348 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Return value */

/* 3350 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3352 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Protocol */

/* 3356 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3358 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3362 */	NdrFcShort( 0xa ),	/* 10 */
/* 3364 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3368 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3370 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3372 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3380 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pProtocol */

/* 3382 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3384 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3386 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3388 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3390 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3392 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Status */

/* 3394 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3396 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3400 */	NdrFcShort( 0xb ),	/* 11 */
/* 3402 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3406 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3408 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3410 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3418 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pStatus */

/* 3420 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3422 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3424 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3428 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AttachByHandle */

/* 3432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3438 */	NdrFcShort( 0xc ),	/* 12 */
/* 3440 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3442 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3446 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3448 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3456 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hCard */

/* 3458 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3460 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3462 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Return value */

/* 3464 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3466 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AttachByReader */

/* 3470 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3472 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3476 */	NdrFcShort( 0xd ),	/* 13 */
/* 3478 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3480 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3484 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3486 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3488 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3490 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3494 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrReaderName */

/* 3496 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3498 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3500 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Parameter ShareMode */

/* 3502 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3504 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3506 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter PrefProtocol */

/* 3508 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3510 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3512 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Detach */

/* 3520 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3526 */	NdrFcShort( 0xe ),	/* 14 */
/* 3528 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3532 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3534 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3536 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3544 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Disposition */

/* 3546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3548 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3550 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3554 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReAttach */

/* 3558 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3564 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3566 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3568 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3570 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3572 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 3574 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3578 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3582 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ShareMode */

/* 3584 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3586 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3588 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter InitState */

/* 3590 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3592 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3594 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3596 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3598 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Transaction */

/* 3602 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3604 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3608 */	NdrFcShort( 0x11 ),	/* 17 */
/* 3610 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3614 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3616 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 3618 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3622 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3626 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppCmd */

/* 3628 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3630 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3632 */	NdrFcShort( 0x4aa ),	/* Type Offset=1194 */

	/* Return value */

/* 3634 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3636 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3638 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnlockSCard */

/* 3640 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3646 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3648 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3650 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3654 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3656 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3664 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Disposition */

/* 3666 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3668 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3670 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 3672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3674 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProviderCardId */

/* 3678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3684 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3686 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3690 */	NdrFcShort( 0x30 ),	/* 48 */
/* 3692 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3694 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3698 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCardName */

/* 3704 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3706 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3708 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Parameter ppguidProviderId */

/* 3710 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
/* 3712 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3714 */	NdrFcShort( 0x4d6 ),	/* Type Offset=1238 */

	/* Return value */

/* 3716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3718 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListCardInterfaces */

/* 3722 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3730 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3736 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3738 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3740 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3742 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3746 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCardName */

/* 3748 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3750 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3752 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Parameter ppInterfaceGuids */

/* 3754 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3756 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3758 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 3760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3762 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListCards */

/* 3766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3772 */	NdrFcShort( 0x9 ),	/* 9 */
/* 3774 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3780 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3782 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3784 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3786 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3790 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pAtr */

/* 3792 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3794 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3796 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter pInterfaceGuids */

/* 3798 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3800 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3802 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter localeId */

/* 3804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3806 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCardNames */

/* 3810 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3812 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3814 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 3816 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3818 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3820 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListReaderGroups */

/* 3822 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3824 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3828 */	NdrFcShort( 0xa ),	/* 10 */
/* 3830 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3832 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3836 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 3838 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3840 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3846 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter localeId */

/* 3848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3850 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppReaderGroups */

/* 3854 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3856 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3858 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 3860 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3862 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3864 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ListReaders */

/* 3866 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3868 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3872 */	NdrFcShort( 0xb ),	/* 11 */
/* 3874 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3876 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3878 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3880 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 3882 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3884 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3890 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter localeId */

/* 3892 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3894 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3896 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppReaders */

/* 3898 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3900 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3902 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 3904 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3906 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConfigureCardGuidSearch */

/* 3910 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3912 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3916 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3918 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3924 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3926 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3928 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3930 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3934 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCardGuids */

/* 3936 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3938 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3940 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter pGroupNames */

/* 3942 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3944 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 3946 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter bstrTitle */

/* 3948 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3950 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 3952 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Parameter lFlags */

/* 3954 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3956 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 3958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3962 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 3964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ConfigureCardNameSearch */

/* 3966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3972 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3974 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 3976 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3978 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3980 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3982 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3986 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3990 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCardNames */

/* 3992 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3994 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 3996 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter pGroupNames */

/* 3998 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 4000 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 4002 */	NdrFcShort( 0x488 ),	/* Type Offset=1160 */

	/* Parameter bstrTitle */

/* 4004 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 4006 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 4008 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Parameter lFlags */

/* 4010 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4012 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 4014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4018 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 4020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FindCard */

/* 4022 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4028 */	NdrFcShort( 0x9 ),	/* 9 */
/* 4030 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 4032 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4034 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4036 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 4038 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4046 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ShareMode */

/* 4048 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4050 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 4052 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter Protocols */

/* 4054 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4056 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 4058 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter lFlags */

/* 4060 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4062 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 4064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCardInfo */

/* 4066 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 4068 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 4070 */	NdrFcShort( 0x4de ),	/* Type Offset=1246 */

	/* Return value */

/* 4072 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4074 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 4076 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
/*  6 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  8 */	NdrFcLong( 0xc ),	/* 12 */
/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 20 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 22 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 24 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 30 */	NdrFcLong( 0xe126f8fe ),	/* -517539586 */
/* 34 */	NdrFcShort( 0xa7af ),	/* -22609 */
/* 36 */	NdrFcShort( 0x11d0 ),	/* 4560 */
/* 38 */	0xb8,		/* 184 */
			0x8a,		/* 138 */
/* 40 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 42 */	0x4f,		/* 79 */
			0xd4,		/* 212 */
/* 44 */	0x24,		/* 36 */
			0xb9,		/* 185 */
/* 46 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 48 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 50 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 52 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 54 */	
			0x11, 0x0,	/* FC_RP */
/* 56 */	NdrFcShort( 0x2 ),	/* Offset= 2 (58) */
/* 58 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 60 */	NdrFcShort( 0x14 ),	/* 20 */
/* 62 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 64 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 66 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 68 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 70 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (28) */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x13, 0x0,	/* FC_OP */
/* 78 */	NdrFcShort( 0x50 ),	/* Offset= 80 (158) */
/* 80 */	
			0x13, 0x0,	/* FC_OP */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x88,		/* 136 */
/* 86 */	NdrFcShort( 0x8 ),	/* 8 */
/* 88 */	NdrFcShort( 0x3 ),	/* 3 */
/* 90 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
/* 94 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 96 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
/* 100 */	NdrFcShort( 0xa ),	/* Offset= 10 (110) */
/* 102 */	NdrFcLong( 0x50746457 ),	/* 1349805143 */
/* 106 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 108 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (107) */
/* 110 */	
			0x13, 0x0,	/* FC_OP */
/* 112 */	NdrFcShort( 0xe ),	/* Offset= 14 (126) */
/* 114 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0x1 ),	/* 1 */
/* 118 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 120 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 122 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 124 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 126 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (114) */
/* 132 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 134 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 136 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (80) */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 148 */	NdrFcShort( 0x1 ),	/* 1 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 158 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 160 */	NdrFcShort( 0x18 ),	/* 24 */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 172 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 174 */	
			0x13, 0x0,	/* FC_OP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 180 */	NdrFcShort( 0x3c2 ),	/* Offset= 962 (1142) */
/* 182 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 184 */	NdrFcShort( 0x2 ),	/* Offset= 2 (186) */
/* 186 */	
			0x13, 0x0,	/* FC_OP */
/* 188 */	NdrFcShort( 0x3a8 ),	/* Offset= 936 (1124) */
/* 190 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 192 */	NdrFcShort( 0x20 ),	/* 32 */
/* 194 */	NdrFcShort( 0xa ),	/* 10 */
/* 196 */	NdrFcLong( 0x8 ),	/* 8 */
/* 200 */	NdrFcShort( 0x66 ),	/* Offset= 102 (302) */
/* 202 */	NdrFcLong( 0xd ),	/* 13 */
/* 206 */	NdrFcShort( 0x98 ),	/* Offset= 152 (358) */
/* 208 */	NdrFcLong( 0x9 ),	/* 9 */
/* 212 */	NdrFcShort( 0xca ),	/* Offset= 202 (414) */
/* 214 */	NdrFcLong( 0xc ),	/* 12 */
/* 218 */	NdrFcShort( 0x2a6 ),	/* Offset= 678 (896) */
/* 220 */	NdrFcLong( 0x24 ),	/* 36 */
/* 224 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (934) */
/* 226 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 230 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (968) */
/* 232 */	NdrFcLong( 0x10 ),	/* 16 */
/* 236 */	NdrFcShort( 0x2fc ),	/* Offset= 764 (1000) */
/* 238 */	NdrFcLong( 0x2 ),	/* 2 */
/* 242 */	NdrFcShort( 0x312 ),	/* Offset= 786 (1028) */
/* 244 */	NdrFcLong( 0x3 ),	/* 3 */
/* 248 */	NdrFcShort( 0x328 ),	/* Offset= 808 (1056) */
/* 250 */	NdrFcLong( 0x14 ),	/* 20 */
/* 254 */	NdrFcShort( 0x33e ),	/* Offset= 830 (1084) */
/* 256 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (255) */
/* 258 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 264 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 266 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 268 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 270 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (258) */
/* 276 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 278 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 280 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 290 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 294 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 296 */	
			0x13, 0x0,	/* FC_OP */
/* 298 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (270) */
/* 300 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 302 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 304 */	NdrFcShort( 0x10 ),	/* 16 */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0x6 ),	/* Offset= 6 (314) */
/* 310 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 312 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 314 */	
			0x11, 0x0,	/* FC_RP */
/* 316 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (280) */
/* 318 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 330 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 332 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 334 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 336 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 346 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 350 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 352 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 354 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (318) */
/* 356 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 358 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 364 */	NdrFcShort( 0x6 ),	/* Offset= 6 (370) */
/* 366 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 368 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 370 */	
			0x11, 0x0,	/* FC_RP */
/* 372 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (336) */
/* 374 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 376 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 386 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 388 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 390 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 406 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (374) */
/* 412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 414 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0x10 ),	/* 16 */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x6 ),	/* Offset= 6 (426) */
/* 422 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 424 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 426 */	
			0x11, 0x0,	/* FC_RP */
/* 428 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (392) */
/* 430 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 432 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 434 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 436 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 438 */	NdrFcShort( 0x2 ),	/* Offset= 2 (440) */
/* 440 */	NdrFcShort( 0x10 ),	/* 16 */
/* 442 */	NdrFcShort( 0x2b ),	/* 43 */
/* 444 */	NdrFcLong( 0x3 ),	/* 3 */
/* 448 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 450 */	NdrFcLong( 0x11 ),	/* 17 */
/* 454 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 456 */	NdrFcLong( 0x2 ),	/* 2 */
/* 460 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 462 */	NdrFcLong( 0x4 ),	/* 4 */
/* 466 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 468 */	NdrFcLong( 0x5 ),	/* 5 */
/* 472 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 474 */	NdrFcLong( 0xb ),	/* 11 */
/* 478 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 480 */	NdrFcLong( 0xa ),	/* 10 */
/* 484 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 486 */	NdrFcLong( 0x6 ),	/* 6 */
/* 490 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (704) */
/* 492 */	NdrFcLong( 0x7 ),	/* 7 */
/* 496 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 498 */	NdrFcLong( 0x8 ),	/* 8 */
/* 502 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (710) */
/* 504 */	NdrFcLong( 0xd ),	/* 13 */
/* 508 */	NdrFcShort( 0xffffff42 ),	/* Offset= -190 (318) */
/* 510 */	NdrFcLong( 0x9 ),	/* 9 */
/* 514 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (374) */
/* 516 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 520 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (714) */
/* 522 */	NdrFcLong( 0x24 ),	/* 36 */
/* 526 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (722) */
/* 528 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 532 */	NdrFcShort( 0xbe ),	/* Offset= 190 (722) */
/* 534 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 538 */	NdrFcShort( 0xf0 ),	/* Offset= 240 (778) */
/* 540 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 544 */	NdrFcShort( 0xee ),	/* Offset= 238 (782) */
/* 546 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 550 */	NdrFcShort( 0xec ),	/* Offset= 236 (786) */
/* 552 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 556 */	NdrFcShort( 0xea ),	/* Offset= 234 (790) */
/* 558 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 562 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (794) */
/* 564 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 568 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (782) */
/* 570 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 574 */	NdrFcShort( 0xd4 ),	/* Offset= 212 (786) */
/* 576 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 580 */	NdrFcShort( 0xda ),	/* Offset= 218 (798) */
/* 582 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 586 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (794) */
/* 588 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 592 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (802) */
/* 594 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 598 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (806) */
/* 600 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 604 */	NdrFcShort( 0xce ),	/* Offset= 206 (810) */
/* 606 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 610 */	NdrFcShort( 0xcc ),	/* Offset= 204 (814) */
/* 612 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 616 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (826) */
/* 618 */	NdrFcLong( 0x10 ),	/* 16 */
/* 622 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 624 */	NdrFcLong( 0x12 ),	/* 18 */
/* 628 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 630 */	NdrFcLong( 0x13 ),	/* 19 */
/* 634 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 636 */	NdrFcLong( 0x16 ),	/* 22 */
/* 640 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 642 */	NdrFcLong( 0x17 ),	/* 23 */
/* 646 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 648 */	NdrFcLong( 0xe ),	/* 14 */
/* 652 */	NdrFcShort( 0xb6 ),	/* Offset= 182 (834) */
/* 654 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 658 */	NdrFcShort( 0xbc ),	/* Offset= 188 (846) */
/* 660 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 664 */	NdrFcShort( 0xba ),	/* Offset= 186 (850) */
/* 666 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 670 */	NdrFcShort( 0x70 ),	/* Offset= 112 (782) */
/* 672 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 676 */	NdrFcShort( 0x6e ),	/* Offset= 110 (786) */
/* 678 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 682 */	NdrFcShort( 0x68 ),	/* Offset= 104 (786) */
/* 684 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 688 */	NdrFcShort( 0x62 ),	/* Offset= 98 (786) */
/* 690 */	NdrFcLong( 0x0 ),	/* 0 */
/* 694 */	NdrFcShort( 0x0 ),	/* Offset= 0 (694) */
/* 696 */	NdrFcLong( 0x1 ),	/* 1 */
/* 700 */	NdrFcShort( 0x0 ),	/* Offset= 0 (700) */
/* 702 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (701) */
/* 704 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 710 */	
			0x13, 0x0,	/* FC_OP */
/* 712 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (270) */
/* 714 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 716 */	NdrFcShort( 0x2 ),	/* Offset= 2 (718) */
/* 718 */	
			0x13, 0x0,	/* FC_OP */
/* 720 */	NdrFcShort( 0x194 ),	/* Offset= 404 (1124) */
/* 722 */	
			0x13, 0x0,	/* FC_OP */
/* 724 */	NdrFcShort( 0x20 ),	/* Offset= 32 (756) */
/* 726 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 728 */	NdrFcLong( 0x2f ),	/* 47 */
/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 736 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 738 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 740 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 742 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 744 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 746 */	NdrFcShort( 0x1 ),	/* 1 */
/* 748 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 750 */	NdrFcShort( 0x4 ),	/* 4 */
/* 752 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 754 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 756 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 758 */	NdrFcShort( 0x18 ),	/* 24 */
/* 760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0xc ),	/* Offset= 12 (774) */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 768 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (726) */
/* 770 */	0x39,		/* FC_ALIGNM8 */
			0x36,		/* FC_POINTER */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x13, 0x0,	/* FC_OP */
/* 776 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (744) */
/* 778 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 780 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 782 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 784 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 786 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 788 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 790 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 792 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 794 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 796 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 798 */	
			0x13, 0x0,	/* FC_OP */
/* 800 */	NdrFcShort( 0xffffffa0 ),	/* Offset= -96 (704) */
/* 802 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 804 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (710) */
/* 806 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 808 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (318) */
/* 810 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 812 */	NdrFcShort( 0xfffffe4a ),	/* Offset= -438 (374) */
/* 814 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 816 */	NdrFcShort( 0x2 ),	/* Offset= 2 (818) */
/* 818 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 820 */	NdrFcShort( 0x2 ),	/* Offset= 2 (822) */
/* 822 */	
			0x13, 0x0,	/* FC_OP */
/* 824 */	NdrFcShort( 0x12c ),	/* Offset= 300 (1124) */
/* 826 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 828 */	NdrFcShort( 0x2 ),	/* Offset= 2 (830) */
/* 830 */	
			0x13, 0x0,	/* FC_OP */
/* 832 */	NdrFcShort( 0x16 ),	/* Offset= 22 (854) */
/* 834 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 836 */	NdrFcShort( 0x10 ),	/* 16 */
/* 838 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 840 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 842 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 844 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 846 */	
			0x13, 0x0,	/* FC_OP */
/* 848 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (834) */
/* 850 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 852 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 854 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 856 */	NdrFcShort( 0x20 ),	/* 32 */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* Offset= 0 (860) */
/* 862 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 864 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 866 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 868 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 870 */	NdrFcShort( 0xfffffe48 ),	/* Offset= -440 (430) */
/* 872 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 874 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 878 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 884 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 888 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 890 */	
			0x13, 0x0,	/* FC_OP */
/* 892 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (854) */
/* 894 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 896 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 898 */	NdrFcShort( 0x10 ),	/* 16 */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x6 ),	/* Offset= 6 (908) */
/* 904 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 906 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 908 */	
			0x11, 0x0,	/* FC_RP */
/* 910 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (874) */
/* 912 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 914 */	NdrFcShort( 0x0 ),	/* 0 */
/* 916 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 922 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 926 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 928 */	
			0x13, 0x0,	/* FC_OP */
/* 930 */	NdrFcShort( 0xffffff52 ),	/* Offset= -174 (756) */
/* 932 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 934 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 936 */	NdrFcShort( 0x10 ),	/* 16 */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x6 ),	/* Offset= 6 (946) */
/* 942 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 944 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 946 */	
			0x11, 0x0,	/* FC_RP */
/* 948 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (912) */
/* 950 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 952 */	NdrFcShort( 0x8 ),	/* 8 */
/* 954 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 956 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 958 */	NdrFcShort( 0x10 ),	/* 16 */
/* 960 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 962 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 964 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (950) */
			0x5b,		/* FC_END */
/* 968 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 970 */	NdrFcShort( 0x20 ),	/* 32 */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0xa ),	/* Offset= 10 (984) */
/* 976 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 978 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 980 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (956) */
			0x5b,		/* FC_END */
/* 984 */	
			0x11, 0x0,	/* FC_RP */
/* 986 */	NdrFcShort( 0xfffffd76 ),	/* Offset= -650 (336) */
/* 988 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 990 */	NdrFcShort( 0x1 ),	/* 1 */
/* 992 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 998 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1000 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1002 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1012) */
/* 1008 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1010 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1012 */	
			0x13, 0x0,	/* FC_OP */
/* 1014 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (988) */
/* 1016 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1018 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1020 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1022 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1024 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1026 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1028 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1030 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1032 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1040) */
/* 1036 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1038 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1040 */	
			0x13, 0x0,	/* FC_OP */
/* 1042 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1016) */
/* 1044 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1046 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1048 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1054 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1056 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1058 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1068) */
/* 1064 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1066 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1068 */	
			0x13, 0x0,	/* FC_OP */
/* 1070 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1044) */
/* 1072 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1080 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1082 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1084 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1086 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1096) */
/* 1092 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1094 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1096 */	
			0x13, 0x0,	/* FC_OP */
/* 1098 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1072) */
/* 1100 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1104 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1108 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1110 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1112 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1114 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 1116 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1120 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1100) */
/* 1122 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1124 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1126 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1128 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1108) */
/* 1130 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1130) */
/* 1132 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1134 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 1136 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1138 */	0x4,		/* 4 */
			NdrFcShort( 0xfffffc4b ),	/* Offset= -949 (190) */
			0x5b,		/* FC_END */
/* 1142 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1144 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1146 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0xfffffc38 ),	/* Offset= -968 (182) */
/* 1152 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1154 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1156) */
/* 1156 */	
			0x12, 0x0,	/* FC_UP */
/* 1158 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (1124) */
/* 1160 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1162 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1168 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1152) */
/* 1170 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1172 */	NdrFcShort( 0xfffffebe ),	/* Offset= -322 (850) */
/* 1174 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1176 */	NdrFcShort( 0xfffffe28 ),	/* Offset= -472 (704) */
/* 1178 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1180 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1182 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1184 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1186 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1188 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1190 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1192 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 1194 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1196 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1198) */
/* 1198 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1200 */	NdrFcLong( 0xd5778ae3 ),	/* -713585949 */
/* 1204 */	NdrFcShort( 0x43de ),	/* 17374 */
/* 1206 */	NdrFcShort( 0x11d0 ),	/* 4560 */
/* 1208 */	0x91,		/* 145 */
			0x71,		/* 113 */
/* 1210 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 1212 */	0x0,		/* 0 */
			0xc1,		/* 193 */
/* 1214 */	0x80,		/* 128 */
			0x68,		/* 104 */
/* 1216 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1218 */	0xb9,		/* FC_UINT3264 */
			0x5c,		/* FC_PAD */
/* 1220 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1222 */	0xe,		/* FC_ENUM32 */
			0x5c,		/* FC_PAD */
/* 1224 */	
			0x12, 0x0,	/* FC_UP */
/* 1226 */	NdrFcShort( 0xfffffc44 ),	/* Offset= -956 (270) */
/* 1228 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1230 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1232 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1224) */
/* 1238 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1240 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1242) */
/* 1242 */	
			0x13, 0x0,	/* FC_OP */
/* 1244 */	NdrFcShort( 0xfffffee0 ),	/* Offset= -288 (956) */
/* 1246 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1248 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1250) */
/* 1250 */	
			0x13, 0x0,	/* FC_OP */
/* 1252 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1254) */
/* 1254 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1256 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1260 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1260) */
/* 1262 */	0xb9,		/* FC_UINT3264 */
			0xb9,		/* FC_UINT3264 */
/* 1264 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 1266 */	0x39,		/* FC_ALIGNM8 */
			0xb8,		/* FC_INT3264 */
/* 1268 */	0xb8,		/* FC_INT3264 */
			0xb8,		/* FC_INT3264 */
/* 1270 */	0xb8,		/* FC_INT3264 */
			0x5b,		/* FC_END */

			0x0
        }
    };

const CInterfaceProxyVtbl * _scardssp_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISCardTypeConvProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardISO7816ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardDatabaseProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardLocateProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISCardCmdProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IByteBufferProxyVtbl,
    0
};

const CInterfaceStubVtbl * _scardssp_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISCardTypeConvStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardISO7816StubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardDatabaseStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardLocateStubVtbl,
    ( CInterfaceStubVtbl *) &_ISCardCmdStubVtbl,
    ( CInterfaceStubVtbl *) &_IByteBufferStubVtbl,
    0
};

PCInterfaceName const _scardssp_InterfaceNamesList[] = 
{
    "ISCardTypeConv",
    "ISCardISO7816",
    "ISCard",
    "ISCardDatabase",
    "ISCardLocate",
    "ISCardCmd",
    "IByteBuffer",
    0
};

const IID *  _scardssp_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _scardssp_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _scardssp, pIID, n)

int __stdcall _scardssp_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _scardssp, 7, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _scardssp, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _scardssp, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _scardssp, 7, *pIndex )
    
}

const ExtendedProxyFileInfo scardssp_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _scardssp_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _scardssp_StubVtblList,
    (const PCInterfaceName * ) & _scardssp_InterfaceNamesList,
    (const IID ** ) & _scardssp_BaseIIDList,
    & _scardssp_IID_Lookup, 
    7,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SCardSsp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 01 16:58:17 1999
 */
/* Compiler settings for scardssp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __scardssp_h__
#define __scardssp_h__

/* Forward Declarations */ 

#ifndef __IByteBuffer_FWD_DEFINED__
#define __IByteBuffer_FWD_DEFINED__
typedef interface IByteBuffer IByteBuffer;
#endif 	/* __IByteBuffer_FWD_DEFINED__ */


#ifndef __ISCardTypeConv_FWD_DEFINED__
#define __ISCardTypeConv_FWD_DEFINED__
typedef interface ISCardTypeConv ISCardTypeConv;
#endif 	/* __ISCardTypeConv_FWD_DEFINED__ */


#ifndef __ISCardCmd_FWD_DEFINED__
#define __ISCardCmd_FWD_DEFINED__
typedef interface ISCardCmd ISCardCmd;
#endif 	/* __ISCardCmd_FWD_DEFINED__ */


#ifndef __ISCardISO7816_FWD_DEFINED__
#define __ISCardISO7816_FWD_DEFINED__
typedef interface ISCardISO7816 ISCardISO7816;
#endif 	/* __ISCardISO7816_FWD_DEFINED__ */


#ifndef __ISCard_FWD_DEFINED__
#define __ISCard_FWD_DEFINED__
typedef interface ISCard ISCard;
#endif 	/* __ISCard_FWD_DEFINED__ */


#ifndef __ISCardDatabase_FWD_DEFINED__
#define __ISCardDatabase_FWD_DEFINED__
typedef interface ISCardDatabase ISCardDatabase;
#endif 	/* __ISCardDatabase_FWD_DEFINED__ */


#ifndef __ISCardLocate_FWD_DEFINED__
#define __ISCardLocate_FWD_DEFINED__
typedef interface ISCardLocate ISCardLocate;
#endif 	/* __ISCardLocate_FWD_DEFINED__ */


#ifndef __CByteBuffer_FWD_DEFINED__
#define __CByteBuffer_FWD_DEFINED__

#ifdef __cplusplus
typedef class CByteBuffer CByteBuffer;
#else
typedef struct CByteBuffer CByteBuffer;
#endif /* __cplusplus */

#endif 	/* __CByteBuffer_FWD_DEFINED__ */


#ifndef __CSCardTypeConv_FWD_DEFINED__
#define __CSCardTypeConv_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCardTypeConv CSCardTypeConv;
#else
typedef struct CSCardTypeConv CSCardTypeConv;
#endif /* __cplusplus */

#endif 	/* __CSCardTypeConv_FWD_DEFINED__ */


#ifndef __CSCardCmd_FWD_DEFINED__
#define __CSCardCmd_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCardCmd CSCardCmd;
#else
typedef struct CSCardCmd CSCardCmd;
#endif /* __cplusplus */

#endif 	/* __CSCardCmd_FWD_DEFINED__ */


#ifndef __CSCardISO7816_FWD_DEFINED__
#define __CSCardISO7816_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCardISO7816 CSCardISO7816;
#else
typedef struct CSCardISO7816 CSCardISO7816;
#endif /* __cplusplus */

#endif 	/* __CSCardISO7816_FWD_DEFINED__ */


#ifndef __CSCard_FWD_DEFINED__
#define __CSCard_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCard CSCard;
#else
typedef struct CSCard CSCard;
#endif /* __cplusplus */

#endif 	/* __CSCard_FWD_DEFINED__ */


#ifndef __CSCardDatabase_FWD_DEFINED__
#define __CSCardDatabase_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCardDatabase CSCardDatabase;
#else
typedef struct CSCardDatabase CSCardDatabase;
#endif /* __cplusplus */

#endif 	/* __CSCardDatabase_FWD_DEFINED__ */


#ifndef __CSCardLocate_FWD_DEFINED__
#define __CSCardLocate_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSCardLocate CSCardLocate;
#else
typedef struct CSCardLocate CSCardLocate;
#endif /* __cplusplus */

#endif 	/* __CSCardLocate_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_scardssp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Smart Card Support
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//
// File: scardssp.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////
//
// Imports
//

//////////////////////////////////////////////////////////////////
//
// Interface declarations
//








//////////////////////////////////////////////////////////////////
//
// Types and Constants
//
#ifndef _NULL_DEFINED
#define _NULL_DEFINED
#endif // !_NULL_DEFINED
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef /* [public] */ unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _LPBYTE_DEFINED
#define _LPBYTE_DEFINED
typedef /* [public] */ BYTE __RPC_FAR *LPBYTE;

#endif // !_LPBYTE_DEFINED
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef /* [public] */ const BYTE __RPC_FAR *LPCBYTE;

#endif // !_LPCBYTE_DEFINED
#ifndef _HSCARD_DEFINED
#define _HSCARD_DEFINED
typedef /* [public] */ ULONG_PTR HSCARD;

#endif // !_HSCARD_DEFINED
#ifndef _LPHSCARD_DEFINED
#define _LPHSCARD_DEFINED
typedef /* [unique] */ HSCARD __RPC_FAR *PHSCARD;

typedef /* [unique] */ HSCARD __RPC_FAR *LPHSCARD;

#endif // !_LPHSCARD_DEFINED
#ifndef _HSCARDCONTEXT_DEFINED
#define _HSCARDCONTEXT_DEFINED
typedef /* [public] */ ULONG_PTR HSCARDCONTEXT;

#endif // !_HSCARDCONTEXT_DEFINED
#ifndef _LPHSCARDCONTEXT_DEFINED
#define _LPHSCARDCONTEXT_DEFINED
typedef /* [unique] */ __RPC_FAR *PHSCARDCONTEXT;

typedef /* [unique] */ __RPC_FAR *LPHSCARDCONTEXT;

#endif // !_LPHSCARDCONTEXT_DEFINED
#ifndef _BYTEARRAY_DEFINED
#define _BYTEARRAY_DEFINED
typedef /* [version][helpstring] */ struct tagBYTEARRAY
    {
    HGLOBAL hMem;
    DWORD dwSize;
    /* [size_is] */ LPBYTE pbyData;
    }	BYTEARRAY;

#define _CB_BYTEARRAY_DEFINED
#define CB_BYTEARRAY (sizeof(BYTEARRAY))
#define _PBYTEARRAY_DEFINED
typedef /* [public] */ BYTEARRAY __RPC_FAR *PBYTEARRAY;

#define _PCBYTEARRAY_DEFINED
typedef /* [public] */ const BYTEARRAY __RPC_FAR *PCBYTEARRAY;

#define _LPBYTEARRAY_DEFINED
typedef /* [public] */ BYTEARRAY __RPC_FAR *LPBYTEARRAY;

#define _LPCBYTEARRAY_DEFINED
typedef /* [public] */ const BYTEARRAY __RPC_FAR *LPCBYTEARRAY;

#endif // _BYTEARRAY_DEFINED
#ifndef _STATSTRUCT
#define _STATSTRUCT
typedef /* [version][helpstring] */ struct tagSTATSTRUCT
    {
    LONG type;
    LONG cbSize;
    LONG grfMode;
    LONG grfLocksSupported;
    LONG grfStateBits;
    }	STATSTRUCT;

#define _CB_STATSTRUCT_DEFINED
#define CB_STATSTRUCT    (sizeof(STATSTRUCT))
#define _LPSTATSTRUCT_DEFINED
typedef /* [public] */ STATSTRUCT __RPC_FAR *LPSTATSTRUCT;

#endif // _STATSTRUCT_DEFINED
#ifndef _ISO_APDU_TYPE
#define _ISO_APDU_TYPE
typedef /* [version][helpstring] */ 
enum tagISO_APDU_TYPE
    {	ISO_CASE_1	= 1,
	ISO_CASE_2	= 2,
	ISO_CASE_3	= 3,
	ISO_CASE_4	= 4
    }	ISO_APDU_TYPE;

#endif // _ISO_APDU_TYPE
#ifndef _SCARD_SHARE_MODES_DEFINED
#define _SCARD_SHARE_MODES_DEFINED
typedef /* [version][v1_enum][helpstring] */ 
enum tagSCARD_SHARE_MODES
    {	EXCLUSIVE	= 1,
	SHARED	= 2
    }	SCARD_SHARE_MODES;

#endif // !_SCARD_SHARE_MODES_DEFINED
#ifndef _SCARD_DISPOSITIONS_DEFINED
#define _SCARD_DISPOSITIONS_DEFINED
typedef /* [version][v1_enum][helpstring] */ 
enum tagSCARD_DISPOSITIONS
    {	LEAVE	= 0,
	RESET	= 1,
	UNPOWER	= 2,
	EJECT	= 3
    }	SCARD_DISPOSITIONS;

#endif // !_SCARD_DISPOSITIONS_DEFINED
#ifndef _SCARD_STATES_DEFINED
#define _SCARD_STATES_DEFINED
typedef /* [version][v1_enum][helpstring] */ 
enum tagSCARD_STATES
    {	ABSENT	= 1,
	PRESENT	= 2,
	SWALLOWED	= 3,
	POWERED	= 4,
	NEGOTIABLEMODE	= 5,
	SPECIFICMODE	= 6
    }	SCARD_STATES;

#endif // !_SCARD_STATES_DEFINED
#ifndef _SCARD_PROTOCOLS_DEFINED
#define _SCARD_PROTOCOLS_DEFINED
typedef /* [version][v1_enum][helpstring] */ 
enum tagSCARD_PROTOCOLS
    {	T0	= 0x1,
	T1	= 0x2,
	RAW	= 0xff
    }	SCARD_PROTOCOLS;

#endif // !_SCARD_PROTOCOLS_DEFINED
#ifndef _SCARD_INFO
#define _SCARD_INFO
typedef /* [version][helpstring] */ struct tagSCARDINFO
    {
    HSCARD hCard;
    HSCARDCONTEXT hContext;
    SCARD_PROTOCOLS ActiveProtocol;
    SCARD_SHARE_MODES ShareMode;
    LONG_PTR hwndOwner;
    LONG_PTR lpfnConnectProc;
    LONG_PTR lpfnCheckProc;
    LONG_PTR lpfnDisconnectProc;
    }	SCARDINFO;

#define _LPSCARDINFO
typedef /* [unique] */ SCARDINFO __RPC_FAR *PSCARDINFO;

typedef /* [unique] */ SCARDINFO __RPC_FAR *LPSCARDINFO;

#endif //_SCARD_INFO

//////////////////////////////////////////////////////////////////
//
// IByteBuffer Interface
//
#ifndef _LPBYTEBUFFER_DEFINED
#define _LPBYTEBUFFER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0000_v0_0_s_ifspec;

#ifndef __IByteBuffer_INTERFACE_DEFINED__
#define __IByteBuffer_INTERFACE_DEFINED__

/* interface IByteBuffer */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ IByteBuffer __RPC_FAR *LPBYTEBUFFER;

typedef /* [unique] */ const IByteBuffer __RPC_FAR *LPCBYTEBUFFER;


EXTERN_C const IID IID_IByteBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E126F8FE-A7AF-11D0-B88A-00C04FD424B9")
    IByteBuffer : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream) = 0;
        
        virtual /* [helpstring][hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_Stream( 
            /* [in] */ LPSTREAM pStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ LONG grfCommitFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
            /* [in] */ LONG cb,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [defaultvalue][in] */ LONG lSize = 1,
            /* [defaultvalue][in] */ BYTE __RPC_FAR *pData = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ LONG libOffset,
            /* [in] */ LONG cb,
            /* [in] */ LONG dwLockType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [out][in] */ BYTE __RPC_FAR *pByte,
            /* [in] */ LONG cb,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LONG dLibMove,
            /* [in] */ LONG dwOrigin,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ LONG libNewSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stat( 
            /* [out][in] */ LPSTATSTRUCT pstatstg,
            /* [in] */ LONG grfStatFlag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ LONG libOffset,
            /* [in] */ LONG cb,
            /* [in] */ LONG dwLockType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [out][in] */ BYTE __RPC_FAR *pByte,
            /* [in] */ LONG cb,
            /* [out][in] */ LONG __RPC_FAR *pcbWritten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IByteBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IByteBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IByteBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IByteBuffer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Stream )( 
            IByteBuffer __RPC_FAR * This,
            /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream);
        
        /* [helpstring][hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Stream )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LPSTREAM pStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IByteBuffer __RPC_FAR * This,
            /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LONG grfCommitFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IByteBuffer __RPC_FAR * This,
            /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
            /* [in] */ LONG cb,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IByteBuffer __RPC_FAR * This,
            /* [defaultvalue][in] */ LONG lSize,
            /* [defaultvalue][in] */ BYTE __RPC_FAR *pData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockRegion )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LONG libOffset,
            /* [in] */ LONG cb,
            /* [in] */ LONG dwLockType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IByteBuffer __RPC_FAR * This,
            /* [out][in] */ BYTE __RPC_FAR *pByte,
            /* [in] */ LONG cb,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert )( 
            IByteBuffer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LONG dLibMove,
            /* [in] */ LONG dwOrigin,
            /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LONG libNewSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stat )( 
            IByteBuffer __RPC_FAR * This,
            /* [out][in] */ LPSTATSTRUCT pstatstg,
            /* [in] */ LONG grfStatFlag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockRegion )( 
            IByteBuffer __RPC_FAR * This,
            /* [in] */ LONG libOffset,
            /* [in] */ LONG cb,
            /* [in] */ LONG dwLockType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IByteBuffer __RPC_FAR * This,
            /* [out][in] */ BYTE __RPC_FAR *pByte,
            /* [in] */ LONG cb,
            /* [out][in] */ LONG __RPC_FAR *pcbWritten);
        
        END_INTERFACE
    } IByteBufferVtbl;

    interface IByteBuffer
    {
        CONST_VTBL struct IByteBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IByteBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IByteBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IByteBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IByteBuffer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IByteBuffer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IByteBuffer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IByteBuffer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IByteBuffer_get_Stream(This,ppStream)	\
    (This)->lpVtbl -> get_Stream(This,ppStream)

#define IByteBuffer_put_Stream(This,pStream)	\
    (This)->lpVtbl -> put_Stream(This,pStream)

#define IByteBuffer_Clone(This,ppByteBuffer)	\
    (This)->lpVtbl -> Clone(This,ppByteBuffer)

#define IByteBuffer_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IByteBuffer_CopyTo(This,ppByteBuffer,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,ppByteBuffer,cb,pcbRead,pcbWritten)

#define IByteBuffer_Initialize(This,lSize,pData)	\
    (This)->lpVtbl -> Initialize(This,lSize,pData)

#define IByteBuffer_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IByteBuffer_Read(This,pByte,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pByte,cb,pcbRead)

#define IByteBuffer_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IByteBuffer_Seek(This,dLibMove,dwOrigin,pLibnewPosition)	\
    (This)->lpVtbl -> Seek(This,dLibMove,dwOrigin,pLibnewPosition)

#define IByteBuffer_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IByteBuffer_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IByteBuffer_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IByteBuffer_Write(This,pByte,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pByte,cb,pcbWritten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_get_Stream_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream);


void __RPC_STUB IByteBuffer_get_Stream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_put_Stream_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LPSTREAM pStream);


void __RPC_STUB IByteBuffer_put_Stream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Clone_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer);


void __RPC_STUB IByteBuffer_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Commit_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LONG grfCommitFlags);


void __RPC_STUB IByteBuffer_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_CopyTo_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten);


void __RPC_STUB IByteBuffer_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Initialize_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [defaultvalue][in] */ LONG lSize,
    /* [defaultvalue][in] */ BYTE __RPC_FAR *pData);


void __RPC_STUB IByteBuffer_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_LockRegion_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType);


void __RPC_STUB IByteBuffer_LockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Read_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead);


void __RPC_STUB IByteBuffer_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Revert_Proxy( 
    IByteBuffer __RPC_FAR * This);


void __RPC_STUB IByteBuffer_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Seek_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LONG dLibMove,
    /* [in] */ LONG dwOrigin,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition);


void __RPC_STUB IByteBuffer_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_SetSize_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LONG libNewSize);


void __RPC_STUB IByteBuffer_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Stat_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [out][in] */ LPSTATSTRUCT pstatstg,
    /* [in] */ LONG grfStatFlag);


void __RPC_STUB IByteBuffer_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_UnlockRegion_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType);


void __RPC_STUB IByteBuffer_UnlockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IByteBuffer_Write_Proxy( 
    IByteBuffer __RPC_FAR * This,
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [out][in] */ LONG __RPC_FAR *pcbWritten);


void __RPC_STUB IByteBuffer_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IByteBuffer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0244 */
/* [local] */ 

#endif //_LPBYTEBUFFER_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCardTypeConv Interface Definition
//
#ifndef _LPSCARDTYPECONV_DEFINED
#define _LPSCARDTYPECONV_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0244_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0244_v0_0_s_ifspec;

#ifndef __ISCardTypeConv_INTERFACE_DEFINED__
#define __ISCardTypeConv_INTERFACE_DEFINED__

/* interface ISCardTypeConv */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCardTypeConv __RPC_FAR *LPSCARDTYPECONV;


EXTERN_C const IID IID_ISCardTypeConv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53B6AA63-3F56-11D0-916B-00AA00C18068")
    ISCardTypeConv : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertByteArrayToByteBuffer( 
            /* [in] */ LPBYTE pbyArray,
            /* [in] */ DWORD dwArraySize,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertByteBufferToByteArray( 
            /* [in] */ LPBYTEBUFFER pbyBuffer,
            /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertByteBufferToSafeArray( 
            /* [in] */ LPBYTEBUFFER pbyBuffer,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertSafeArrayToByteBuffer( 
            /* [in] */ LPSAFEARRAY pbyArray,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateByteArray( 
            /* [in] */ DWORD dwAllocSize,
            /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateByteBuffer( 
            /* [in] */ DWORD dwAllocSize,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSafeArray( 
            /* [in] */ UINT nAllocSize,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FreeIStreamMemoryPtr( 
            /* [in] */ LPSTREAM pStrm,
            /* [in] */ LPBYTE pMem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAtIStreamMemory( 
            /* [in] */ LPSTREAM pStrm,
            /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SizeOfIStream( 
            /* [in] */ LPSTREAM pStrm,
            /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardTypeConvVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCardTypeConv __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCardTypeConv __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertByteArrayToByteBuffer )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPBYTE pbyArray,
            /* [in] */ DWORD dwArraySize,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertByteBufferToByteArray )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pbyBuffer,
            /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertByteBufferToSafeArray )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pbyBuffer,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertSafeArrayToByteBuffer )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPSAFEARRAY pbyArray,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateByteArray )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ DWORD dwAllocSize,
            /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateByteBuffer )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ DWORD dwAllocSize,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSafeArray )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ UINT nAllocSize,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeIStreamMemoryPtr )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPSTREAM pStrm,
            /* [in] */ LPBYTE pMem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAtIStreamMemory )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPSTREAM pStrm,
            /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SizeOfIStream )( 
            ISCardTypeConv __RPC_FAR * This,
            /* [in] */ LPSTREAM pStrm,
            /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize);
        
        END_INTERFACE
    } ISCardTypeConvVtbl;

    interface ISCardTypeConv
    {
        CONST_VTBL struct ISCardTypeConvVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCardTypeConv_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCardTypeConv_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCardTypeConv_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCardTypeConv_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCardTypeConv_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCardTypeConv_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCardTypeConv_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCardTypeConv_ConvertByteArrayToByteBuffer(This,pbyArray,dwArraySize,ppbyBuffer)	\
    (This)->lpVtbl -> ConvertByteArrayToByteBuffer(This,pbyArray,dwArraySize,ppbyBuffer)

#define ISCardTypeConv_ConvertByteBufferToByteArray(This,pbyBuffer,ppArray)	\
    (This)->lpVtbl -> ConvertByteBufferToByteArray(This,pbyBuffer,ppArray)

#define ISCardTypeConv_ConvertByteBufferToSafeArray(This,pbyBuffer,ppbyArray)	\
    (This)->lpVtbl -> ConvertByteBufferToSafeArray(This,pbyBuffer,ppbyArray)

#define ISCardTypeConv_ConvertSafeArrayToByteBuffer(This,pbyArray,ppbyBuff)	\
    (This)->lpVtbl -> ConvertSafeArrayToByteBuffer(This,pbyArray,ppbyBuff)

#define ISCardTypeConv_CreateByteArray(This,dwAllocSize,ppbyArray)	\
    (This)->lpVtbl -> CreateByteArray(This,dwAllocSize,ppbyArray)

#define ISCardTypeConv_CreateByteBuffer(This,dwAllocSize,ppbyBuff)	\
    (This)->lpVtbl -> CreateByteBuffer(This,dwAllocSize,ppbyBuff)

#define ISCardTypeConv_CreateSafeArray(This,nAllocSize,ppArray)	\
    (This)->lpVtbl -> CreateSafeArray(This,nAllocSize,ppArray)

#define ISCardTypeConv_FreeIStreamMemoryPtr(This,pStrm,pMem)	\
    (This)->lpVtbl -> FreeIStreamMemoryPtr(This,pStrm,pMem)

#define ISCardTypeConv_GetAtIStreamMemory(This,pStrm,ppMem)	\
    (This)->lpVtbl -> GetAtIStreamMemory(This,pStrm,ppMem)

#define ISCardTypeConv_SizeOfIStream(This,pStrm,puliSize)	\
    (This)->lpVtbl -> SizeOfIStream(This,pStrm,puliSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_ConvertByteArrayToByteBuffer_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPBYTE pbyArray,
    /* [in] */ DWORD dwArraySize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer);


void __RPC_STUB ISCardTypeConv_ConvertByteArrayToByteBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_ConvertByteBufferToByteArray_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray);


void __RPC_STUB ISCardTypeConv_ConvertByteBufferToByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_ConvertByteBufferToSafeArray_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray);


void __RPC_STUB ISCardTypeConv_ConvertByteBufferToSafeArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_ConvertSafeArrayToByteBuffer_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPSAFEARRAY pbyArray,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);


void __RPC_STUB ISCardTypeConv_ConvertSafeArrayToByteBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_CreateByteArray_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray);


void __RPC_STUB ISCardTypeConv_CreateByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_CreateByteBuffer_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);


void __RPC_STUB ISCardTypeConv_CreateByteBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_CreateSafeArray_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ UINT nAllocSize,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray);


void __RPC_STUB ISCardTypeConv_CreateSafeArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_FreeIStreamMemoryPtr_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPSTREAM pStrm,
    /* [in] */ LPBYTE pMem);


void __RPC_STUB ISCardTypeConv_FreeIStreamMemoryPtr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_GetAtIStreamMemory_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem);


void __RPC_STUB ISCardTypeConv_GetAtIStreamMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardTypeConv_SizeOfIStream_Proxy( 
    ISCardTypeConv __RPC_FAR * This,
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize);


void __RPC_STUB ISCardTypeConv_SizeOfIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCardTypeConv_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0245 */
/* [local] */ 

#endif // _LPSCARDTYPECONV_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCardCmd Interface Definition
//
#ifndef _LPSCARDCMD_DEFINED
#define _LPSCARDCMD_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0245_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0245_v0_0_s_ifspec;

#ifndef __ISCardCmd_INTERFACE_DEFINED__
#define __ISCardCmd_INTERFACE_DEFINED__

/* interface ISCardCmd */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCardCmd __RPC_FAR *LPSCARDCMD;


EXTERN_C const IID IID_ISCardCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5778AE3-43DE-11D0-9171-00AA00C18068")
    ISCardCmd : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Apdu( 
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Apdu( 
            /* [in] */ LPBYTEBUFFER pApdu) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ApduLength( 
            /* [retval][out] */ LONG __RPC_FAR *plSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ApduReply( 
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ApduReply( 
            /* [in] */ LPBYTEBUFFER pReplyApdu) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ApduReplyLength( 
            /* [retval][out] */ LONG __RPC_FAR *plSize) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ApduReplyLength( 
            /* [in] */ LONG lSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClassId( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyClass) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClassId( 
            /* [defaultvalue][in] */ BYTE byClass = 0) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Data( 
            /* [in] */ LPBYTEBUFFER pData) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InstructionId( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyIns) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_InstructionId( 
            /* [in] */ BYTE byIns) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LeField( 
            /* [retval][out] */ LONG __RPC_FAR *plSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_P1( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyP1) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_P1( 
            /* [in] */ BYTE byP1) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_P2( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyP2) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_P2( 
            /* [in] */ BYTE byP2) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_P3( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyP3) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyStatus( 
            /* [retval][out] */ LPWORD pwStatus) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReplyStatus( 
            /* [in] */ WORD wStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyStatusSW1( 
            /* [retval][out] */ BYTE __RPC_FAR *pbySW1) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyStatusSW2( 
            /* [retval][out] */ BYTE __RPC_FAR *pbySW2) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Nad( 
            /* [retval][out] */ BYTE __RPC_FAR *pbNad) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Nad( 
            /* [in] */ BYTE bNad) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReplyNad( 
            /* [retval][out] */ BYTE __RPC_FAR *pbNad) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReplyNad( 
            /* [in] */ BYTE bNad) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BuildCmd( 
            /* [in] */ BYTE byClassId,
            /* [in] */ BYTE byInsId,
            /* [defaultvalue][in] */ BYTE byP1 = 0,
            /* [defaultvalue][in] */ BYTE byP2 = 0,
            /* [defaultvalue][in] */ LPBYTEBUFFER pbyData = 0,
            /* [defaultvalue][in] */ LONG __RPC_FAR *plLe = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encapsulate( 
            /* [in] */ LPBYTEBUFFER pApdu,
            /* [in] */ ISO_APDU_TYPE ApduType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AlternateClassId( 
            /* [retval][out] */ BYTE __RPC_FAR *pbyClass) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AlternateClassId( 
            /* [in] */ BYTE byClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCardCmd __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCardCmd __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCardCmd __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Apdu )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Apdu )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pApdu);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ApduLength )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ApduReply )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ApduReply )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pReplyApdu);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ApduReplyLength )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plSize);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ApduReplyLength )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ LONG lSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClassId )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyClass);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClassId )( 
            ISCardCmd __RPC_FAR * This,
            /* [defaultvalue][in] */ BYTE byClass);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Data )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Data )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pData);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InstructionId )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyIns);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_InstructionId )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE byIns);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LeField )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_P1 )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyP1);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_P1 )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE byP1);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_P2 )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyP2);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_P2 )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE byP2);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_P3 )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyP3);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyStatus )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ LPWORD pwStatus);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReplyStatus )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ WORD wStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyStatusSW1 )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbySW1);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyStatusSW2 )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbySW2);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Nad )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbNad);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Nad )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE bNad);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyNad )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbNad);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReplyNad )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE bNad);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BuildCmd )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE byClassId,
            /* [in] */ BYTE byInsId,
            /* [defaultvalue][in] */ BYTE byP1,
            /* [defaultvalue][in] */ BYTE byP2,
            /* [defaultvalue][in] */ LPBYTEBUFFER pbyData,
            /* [defaultvalue][in] */ LONG __RPC_FAR *plLe);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ISCardCmd __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Encapsulate )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ LPBYTEBUFFER pApdu,
            /* [in] */ ISO_APDU_TYPE ApduType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AlternateClassId )( 
            ISCardCmd __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbyClass);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AlternateClassId )( 
            ISCardCmd __RPC_FAR * This,
            /* [in] */ BYTE byClass);
        
        END_INTERFACE
    } ISCardCmdVtbl;

    interface ISCardCmd
    {
        CONST_VTBL struct ISCardCmdVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCardCmd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCardCmd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCardCmd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCardCmd_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCardCmd_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCardCmd_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCardCmd_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCardCmd_get_Apdu(This,ppApdu)	\
    (This)->lpVtbl -> get_Apdu(This,ppApdu)

#define ISCardCmd_put_Apdu(This,pApdu)	\
    (This)->lpVtbl -> put_Apdu(This,pApdu)

#define ISCardCmd_get_ApduLength(This,plSize)	\
    (This)->lpVtbl -> get_ApduLength(This,plSize)

#define ISCardCmd_get_ApduReply(This,ppReplyApdu)	\
    (This)->lpVtbl -> get_ApduReply(This,ppReplyApdu)

#define ISCardCmd_put_ApduReply(This,pReplyApdu)	\
    (This)->lpVtbl -> put_ApduReply(This,pReplyApdu)

#define ISCardCmd_get_ApduReplyLength(This,plSize)	\
    (This)->lpVtbl -> get_ApduReplyLength(This,plSize)

#define ISCardCmd_put_ApduReplyLength(This,lSize)	\
    (This)->lpVtbl -> put_ApduReplyLength(This,lSize)

#define ISCardCmd_get_ClassId(This,pbyClass)	\
    (This)->lpVtbl -> get_ClassId(This,pbyClass)

#define ISCardCmd_put_ClassId(This,byClass)	\
    (This)->lpVtbl -> put_ClassId(This,byClass)

#define ISCardCmd_get_Data(This,ppData)	\
    (This)->lpVtbl -> get_Data(This,ppData)

#define ISCardCmd_put_Data(This,pData)	\
    (This)->lpVtbl -> put_Data(This,pData)

#define ISCardCmd_get_InstructionId(This,pbyIns)	\
    (This)->lpVtbl -> get_InstructionId(This,pbyIns)

#define ISCardCmd_put_InstructionId(This,byIns)	\
    (This)->lpVtbl -> put_InstructionId(This,byIns)

#define ISCardCmd_get_LeField(This,plSize)	\
    (This)->lpVtbl -> get_LeField(This,plSize)

#define ISCardCmd_get_P1(This,pbyP1)	\
    (This)->lpVtbl -> get_P1(This,pbyP1)

#define ISCardCmd_put_P1(This,byP1)	\
    (This)->lpVtbl -> put_P1(This,byP1)

#define ISCardCmd_get_P2(This,pbyP2)	\
    (This)->lpVtbl -> get_P2(This,pbyP2)

#define ISCardCmd_put_P2(This,byP2)	\
    (This)->lpVtbl -> put_P2(This,byP2)

#define ISCardCmd_get_P3(This,pbyP3)	\
    (This)->lpVtbl -> get_P3(This,pbyP3)

#define ISCardCmd_get_ReplyStatus(This,pwStatus)	\
    (This)->lpVtbl -> get_ReplyStatus(This,pwStatus)

#define ISCardCmd_put_ReplyStatus(This,wStatus)	\
    (This)->lpVtbl -> put_ReplyStatus(This,wStatus)

#define ISCardCmd_get_ReplyStatusSW1(This,pbySW1)	\
    (This)->lpVtbl -> get_ReplyStatusSW1(This,pbySW1)

#define ISCardCmd_get_ReplyStatusSW2(This,pbySW2)	\
    (This)->lpVtbl -> get_ReplyStatusSW2(This,pbySW2)

#define ISCardCmd_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define ISCardCmd_get_Nad(This,pbNad)	\
    (This)->lpVtbl -> get_Nad(This,pbNad)

#define ISCardCmd_put_Nad(This,bNad)	\
    (This)->lpVtbl -> put_Nad(This,bNad)

#define ISCardCmd_get_ReplyNad(This,pbNad)	\
    (This)->lpVtbl -> get_ReplyNad(This,pbNad)

#define ISCardCmd_put_ReplyNad(This,bNad)	\
    (This)->lpVtbl -> put_ReplyNad(This,bNad)

#define ISCardCmd_BuildCmd(This,byClassId,byInsId,byP1,byP2,pbyData,plLe)	\
    (This)->lpVtbl -> BuildCmd(This,byClassId,byInsId,byP1,byP2,pbyData,plLe)

#define ISCardCmd_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ISCardCmd_Encapsulate(This,pApdu,ApduType)	\
    (This)->lpVtbl -> Encapsulate(This,pApdu,ApduType)

#define ISCardCmd_get_AlternateClassId(This,pbyClass)	\
    (This)->lpVtbl -> get_AlternateClassId(This,pbyClass)

#define ISCardCmd_put_AlternateClassId(This,byClass)	\
    (This)->lpVtbl -> put_AlternateClassId(This,byClass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_Apdu_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu);


void __RPC_STUB ISCardCmd_get_Apdu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_Apdu_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pApdu);


void __RPC_STUB ISCardCmd_put_Apdu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ApduLength_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plSize);


void __RPC_STUB ISCardCmd_get_ApduLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ApduReply_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu);


void __RPC_STUB ISCardCmd_get_ApduReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_ApduReply_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pReplyApdu);


void __RPC_STUB ISCardCmd_put_ApduReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ApduReplyLength_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plSize);


void __RPC_STUB ISCardCmd_get_ApduReplyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_ApduReplyLength_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ LONG lSize);


void __RPC_STUB ISCardCmd_put_ApduReplyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ClassId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass);


void __RPC_STUB ISCardCmd_get_ClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_ClassId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [defaultvalue][in] */ BYTE byClass);


void __RPC_STUB ISCardCmd_put_ClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_Data_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData);


void __RPC_STUB ISCardCmd_get_Data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_Data_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pData);


void __RPC_STUB ISCardCmd_put_Data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_InstructionId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyIns);


void __RPC_STUB ISCardCmd_get_InstructionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_InstructionId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE byIns);


void __RPC_STUB ISCardCmd_put_InstructionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_LeField_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plSize);


void __RPC_STUB ISCardCmd_get_LeField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_P1_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyP1);


void __RPC_STUB ISCardCmd_get_P1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_P1_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE byP1);


void __RPC_STUB ISCardCmd_put_P1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_P2_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyP2);


void __RPC_STUB ISCardCmd_get_P2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_P2_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE byP2);


void __RPC_STUB ISCardCmd_put_P2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_P3_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyP3);


void __RPC_STUB ISCardCmd_get_P3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ReplyStatus_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ LPWORD pwStatus);


void __RPC_STUB ISCardCmd_get_ReplyStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_ReplyStatus_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ WORD wStatus);


void __RPC_STUB ISCardCmd_put_ReplyStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ReplyStatusSW1_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbySW1);


void __RPC_STUB ISCardCmd_get_ReplyStatusSW1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ReplyStatusSW2_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbySW2);


void __RPC_STUB ISCardCmd_get_ReplyStatusSW2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_Type_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType);


void __RPC_STUB ISCardCmd_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_Nad_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbNad);


void __RPC_STUB ISCardCmd_get_Nad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_Nad_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE bNad);


void __RPC_STUB ISCardCmd_put_Nad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_ReplyNad_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbNad);


void __RPC_STUB ISCardCmd_get_ReplyNad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_ReplyNad_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE bNad);


void __RPC_STUB ISCardCmd_put_ReplyNad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_BuildCmd_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE byClassId,
    /* [in] */ BYTE byInsId,
    /* [defaultvalue][in] */ BYTE byP1,
    /* [defaultvalue][in] */ BYTE byP2,
    /* [defaultvalue][in] */ LPBYTEBUFFER pbyData,
    /* [defaultvalue][in] */ LONG __RPC_FAR *plLe);


void __RPC_STUB ISCardCmd_BuildCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_Clear_Proxy( 
    ISCardCmd __RPC_FAR * This);


void __RPC_STUB ISCardCmd_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_Encapsulate_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ LPBYTEBUFFER pApdu,
    /* [in] */ ISO_APDU_TYPE ApduType);


void __RPC_STUB ISCardCmd_Encapsulate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_get_AlternateClassId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass);


void __RPC_STUB ISCardCmd_get_AlternateClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISCardCmd_put_AlternateClassId_Proxy( 
    ISCardCmd __RPC_FAR * This,
    /* [in] */ BYTE byClass);


void __RPC_STUB ISCardCmd_put_AlternateClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCardCmd_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0246 */
/* [local] */ 

#endif //!_LPSCARDCMD_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCardISO7816 Interface Definition
//
#ifndef _LPSCARDISO7816_DEFINED
#define _LPSCARDISO7816_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0246_v0_0_s_ifspec;

#ifndef __ISCardISO7816_INTERFACE_DEFINED__
#define __ISCardISO7816_INTERFACE_DEFINED__

/* interface ISCardISO7816 */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCardISO7816 __RPC_FAR *LPSCARDISO;

typedef /* [unique] */ LPSCARDISO LPSCARDISO7816;


EXTERN_C const IID IID_ISCardISO7816;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53B6AA68-3F56-11D0-916B-00AA00C18068")
    ISCardISO7816 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AppendRecord( 
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EraseBinary( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExternalAuthenticate( 
            /* [in] */ BYTE byAlgorithmRef,
            /* [in] */ BYTE bySecretRef,
            /* [in] */ LPBYTEBUFFER pChallenge,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChallenge( 
            /* [in] */ LONG lBytesExpected,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lBytesToGet,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetResponse( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lDataLength,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InternalAuthenticate( 
            /* [in] */ BYTE byAlgorithmRef,
            /* [in] */ BYTE bySecretRef,
            /* [in] */ LPBYTEBUFFER pChallenge,
            /* [in] */ LONG lReplyBytes,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ManageChannel( 
            /* [in] */ BYTE byChannelState,
            /* [in] */ BYTE byChannel,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PutData( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadBinary( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadRecord( 
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectFile( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDefaultClassId( 
            /* [in] */ BYTE byClass) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateBinary( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateRecord( 
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Verify( 
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteBinary( 
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteRecord( 
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardISO7816Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCardISO7816 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCardISO7816 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendRecord )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EraseBinary )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExternalAuthenticate )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byAlgorithmRef,
            /* [in] */ BYTE bySecretRef,
            /* [in] */ LPBYTEBUFFER pChallenge,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChallenge )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ LONG lBytesExpected,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lBytesToGet,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResponse )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lDataLength,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InternalAuthenticate )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byAlgorithmRef,
            /* [in] */ BYTE bySecretRef,
            /* [in] */ LPBYTEBUFFER pChallenge,
            /* [in] */ LONG lReplyBytes,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ManageChannel )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byChannelState,
            /* [in] */ BYTE byChannel,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutData )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadBinary )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadRecord )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectFile )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [in] */ LONG lBytesToRead,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultClassId )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byClass);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateBinary )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateRecord )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verify )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBinary )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byP1,
            /* [in] */ BYTE byP2,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteRecord )( 
            ISCardISO7816 __RPC_FAR * This,
            /* [in] */ BYTE byRecordId,
            /* [in] */ BYTE byRefCtrl,
            /* [in] */ LPBYTEBUFFER pData,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        END_INTERFACE
    } ISCardISO7816Vtbl;

    interface ISCardISO7816
    {
        CONST_VTBL struct ISCardISO7816Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCardISO7816_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCardISO7816_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCardISO7816_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCardISO7816_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCardISO7816_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCardISO7816_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCardISO7816_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCardISO7816_AppendRecord(This,byRefCtrl,pData,ppCmd)	\
    (This)->lpVtbl -> AppendRecord(This,byRefCtrl,pData,ppCmd)

#define ISCardISO7816_EraseBinary(This,byP1,byP2,pData,ppCmd)	\
    (This)->lpVtbl -> EraseBinary(This,byP1,byP2,pData,ppCmd)

#define ISCardISO7816_ExternalAuthenticate(This,byAlgorithmRef,bySecretRef,pChallenge,ppCmd)	\
    (This)->lpVtbl -> ExternalAuthenticate(This,byAlgorithmRef,bySecretRef,pChallenge,ppCmd)

#define ISCardISO7816_GetChallenge(This,lBytesExpected,ppCmd)	\
    (This)->lpVtbl -> GetChallenge(This,lBytesExpected,ppCmd)

#define ISCardISO7816_GetData(This,byP1,byP2,lBytesToGet,ppCmd)	\
    (This)->lpVtbl -> GetData(This,byP1,byP2,lBytesToGet,ppCmd)

#define ISCardISO7816_GetResponse(This,byP1,byP2,lDataLength,ppCmd)	\
    (This)->lpVtbl -> GetResponse(This,byP1,byP2,lDataLength,ppCmd)

#define ISCardISO7816_InternalAuthenticate(This,byAlgorithmRef,bySecretRef,pChallenge,lReplyBytes,ppCmd)	\
    (This)->lpVtbl -> InternalAuthenticate(This,byAlgorithmRef,bySecretRef,pChallenge,lReplyBytes,ppCmd)

#define ISCardISO7816_ManageChannel(This,byChannelState,byChannel,ppCmd)	\
    (This)->lpVtbl -> ManageChannel(This,byChannelState,byChannel,ppCmd)

#define ISCardISO7816_PutData(This,byP1,byP2,pData,ppCmd)	\
    (This)->lpVtbl -> PutData(This,byP1,byP2,pData,ppCmd)

#define ISCardISO7816_ReadBinary(This,byP1,byP2,lBytesToRead,ppCmd)	\
    (This)->lpVtbl -> ReadBinary(This,byP1,byP2,lBytesToRead,ppCmd)

#define ISCardISO7816_ReadRecord(This,byRecordId,byRefCtrl,lBytesToRead,ppCmd)	\
    (This)->lpVtbl -> ReadRecord(This,byRecordId,byRefCtrl,lBytesToRead,ppCmd)

#define ISCardISO7816_SelectFile(This,byP1,byP2,pData,lBytesToRead,ppCmd)	\
    (This)->lpVtbl -> SelectFile(This,byP1,byP2,pData,lBytesToRead,ppCmd)

#define ISCardISO7816_SetDefaultClassId(This,byClass)	\
    (This)->lpVtbl -> SetDefaultClassId(This,byClass)

#define ISCardISO7816_UpdateBinary(This,byP1,byP2,pData,ppCmd)	\
    (This)->lpVtbl -> UpdateBinary(This,byP1,byP2,pData,ppCmd)

#define ISCardISO7816_UpdateRecord(This,byRecordId,byRefCtrl,pData,ppCmd)	\
    (This)->lpVtbl -> UpdateRecord(This,byRecordId,byRefCtrl,pData,ppCmd)

#define ISCardISO7816_Verify(This,byRefCtrl,pData,ppCmd)	\
    (This)->lpVtbl -> Verify(This,byRefCtrl,pData,ppCmd)

#define ISCardISO7816_WriteBinary(This,byP1,byP2,pData,ppCmd)	\
    (This)->lpVtbl -> WriteBinary(This,byP1,byP2,pData,ppCmd)

#define ISCardISO7816_WriteRecord(This,byRecordId,byRefCtrl,pData,ppCmd)	\
    (This)->lpVtbl -> WriteRecord(This,byRecordId,byRefCtrl,pData,ppCmd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_AppendRecord_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_AppendRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_EraseBinary_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_EraseBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_ExternalAuthenticate_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_ExternalAuthenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_GetChallenge_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ LONG lBytesExpected,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_GetChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_GetData_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToGet,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_GetResponse_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lDataLength,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_GetResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_InternalAuthenticate_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [in] */ LONG lReplyBytes,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_InternalAuthenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_ManageChannel_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byChannelState,
    /* [in] */ BYTE byChannel,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_ManageChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_PutData_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_PutData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_ReadBinary_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_ReadBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_ReadRecord_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_ReadRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_SelectFile_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_SelectFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_SetDefaultClassId_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byClass);


void __RPC_STUB ISCardISO7816_SetDefaultClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_UpdateBinary_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_UpdateBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_UpdateRecord_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_UpdateRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_Verify_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_Verify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_WriteBinary_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_WriteBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardISO7816_WriteRecord_Proxy( 
    ISCardISO7816 __RPC_FAR * This,
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCardISO7816_WriteRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCardISO7816_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0247 */
/* [local] */ 

#endif //!_LPSCARDISO7816_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCard Interface
//
#ifndef _LPSCARD_DEFINED
#define _LPSCARD_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0247_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0247_v0_0_s_ifspec;

#ifndef __ISCard_INTERFACE_DEFINED__
#define __ISCard_INTERFACE_DEFINED__

/* interface ISCard */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCard __RPC_FAR *LPSCARD;

typedef /* [unique] */ LPSCARD LPSMARTCARD;


EXTERN_C const IID IID_ISCard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1461AAC3-6810-11D0-918F-00AA00C18068")
    ISCard : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Atr( 
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CardHandle( 
            /* [retval][out] */ HSCARD __RPC_FAR *pHandle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Context( 
            /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachByHandle( 
            /* [in] */ HSCARD hCard) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachByReader( 
            /* [in] */ BSTR bstrReaderName,
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
            /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol = T0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Detach( 
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LockSCard( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReAttach( 
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState = LEAVE) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Transaction( 
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnlockSCard( 
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCard __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCard __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCard __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Atr )( 
            ISCard __RPC_FAR * This,
            /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CardHandle )( 
            ISCard __RPC_FAR * This,
            /* [retval][out] */ HSCARD __RPC_FAR *pHandle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Context )( 
            ISCard __RPC_FAR * This,
            /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Protocol )( 
            ISCard __RPC_FAR * This,
            /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            ISCard __RPC_FAR * This,
            /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachByHandle )( 
            ISCard __RPC_FAR * This,
            /* [in] */ HSCARD hCard);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachByReader )( 
            ISCard __RPC_FAR * This,
            /* [in] */ BSTR bstrReaderName,
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
            /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            ISCard __RPC_FAR * This,
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSCard )( 
            ISCard __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReAttach )( 
            ISCard __RPC_FAR * This,
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Transaction )( 
            ISCard __RPC_FAR * This,
            /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockSCard )( 
            ISCard __RPC_FAR * This,
            /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition);
        
        END_INTERFACE
    } ISCardVtbl;

    interface ISCard
    {
        CONST_VTBL struct ISCardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCard_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCard_get_Atr(This,ppAtr)	\
    (This)->lpVtbl -> get_Atr(This,ppAtr)

#define ISCard_get_CardHandle(This,pHandle)	\
    (This)->lpVtbl -> get_CardHandle(This,pHandle)

#define ISCard_get_Context(This,pContext)	\
    (This)->lpVtbl -> get_Context(This,pContext)

#define ISCard_get_Protocol(This,pProtocol)	\
    (This)->lpVtbl -> get_Protocol(This,pProtocol)

#define ISCard_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define ISCard_AttachByHandle(This,hCard)	\
    (This)->lpVtbl -> AttachByHandle(This,hCard)

#define ISCard_AttachByReader(This,bstrReaderName,ShareMode,PrefProtocol)	\
    (This)->lpVtbl -> AttachByReader(This,bstrReaderName,ShareMode,PrefProtocol)

#define ISCard_Detach(This,Disposition)	\
    (This)->lpVtbl -> Detach(This,Disposition)

#define ISCard_LockSCard(This)	\
    (This)->lpVtbl -> LockSCard(This)

#define ISCard_ReAttach(This,ShareMode,InitState)	\
    (This)->lpVtbl -> ReAttach(This,ShareMode,InitState)

#define ISCard_Transaction(This,ppCmd)	\
    (This)->lpVtbl -> Transaction(This,ppCmd)

#define ISCard_UnlockSCard(This,Disposition)	\
    (This)->lpVtbl -> UnlockSCard(This,Disposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCard_get_Atr_Proxy( 
    ISCard __RPC_FAR * This,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr);


void __RPC_STUB ISCard_get_Atr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCard_get_CardHandle_Proxy( 
    ISCard __RPC_FAR * This,
    /* [retval][out] */ HSCARD __RPC_FAR *pHandle);


void __RPC_STUB ISCard_get_CardHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCard_get_Context_Proxy( 
    ISCard __RPC_FAR * This,
    /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext);


void __RPC_STUB ISCard_get_Context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCard_get_Protocol_Proxy( 
    ISCard __RPC_FAR * This,
    /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol);


void __RPC_STUB ISCard_get_Protocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISCard_get_Status_Proxy( 
    ISCard __RPC_FAR * This,
    /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus);


void __RPC_STUB ISCard_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_AttachByHandle_Proxy( 
    ISCard __RPC_FAR * This,
    /* [in] */ HSCARD hCard);


void __RPC_STUB ISCard_AttachByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_AttachByReader_Proxy( 
    ISCard __RPC_FAR * This,
    /* [in] */ BSTR bstrReaderName,
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol);


void __RPC_STUB ISCard_AttachByReader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_Detach_Proxy( 
    ISCard __RPC_FAR * This,
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition);


void __RPC_STUB ISCard_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_LockSCard_Proxy( 
    ISCard __RPC_FAR * This);


void __RPC_STUB ISCard_LockSCard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_ReAttach_Proxy( 
    ISCard __RPC_FAR * This,
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState);


void __RPC_STUB ISCard_ReAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_Transaction_Proxy( 
    ISCard __RPC_FAR * This,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);


void __RPC_STUB ISCard_Transaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCard_UnlockSCard_Proxy( 
    ISCard __RPC_FAR * This,
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition);


void __RPC_STUB ISCard_UnlockSCard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCard_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0248 */
/* [local] */ 

#endif // !_LPSCARD_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCardDatabase Interface
//
#ifndef _LPSCARDDATABASE_DEFINED
#define _LPSCARDDATABASE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0248_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0248_v0_0_s_ifspec;

#ifndef __ISCardDatabase_INTERFACE_DEFINED__
#define __ISCardDatabase_INTERFACE_DEFINED__

/* interface ISCardDatabase */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCardDatabase __RPC_FAR *LPSCARDDATABASE;


EXTERN_C const IID IID_ISCardDatabase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1461AAC8-6810-11D0-918F-00AA00C18068")
    ISCardDatabase : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProviderCardId( 
            /* [in] */ BSTR bstrCardName,
            /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListCardInterfaces( 
            /* [in] */ BSTR bstrCardName,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListCards( 
            /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
            /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListReaderGroups( 
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListReaders( 
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardDatabaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCardDatabase __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCardDatabase __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCardDatabase __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProviderCardId )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ BSTR bstrCardName,
            /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListCardInterfaces )( 
            ISCardDatabase __RPC_FAR * This,
            /* [in] */ BSTR bstrCardName,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListCards )( 
            ISCardDatabase __RPC_FAR * This,
            /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
            /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListReaderGroups )( 
            ISCardDatabase __RPC_FAR * This,
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListReaders )( 
            ISCardDatabase __RPC_FAR * This,
            /* [defaultvalue][lcid][in] */ long localeId,
            /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders);
        
        END_INTERFACE
    } ISCardDatabaseVtbl;

    interface ISCardDatabase
    {
        CONST_VTBL struct ISCardDatabaseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCardDatabase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCardDatabase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCardDatabase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCardDatabase_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCardDatabase_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCardDatabase_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCardDatabase_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCardDatabase_GetProviderCardId(This,bstrCardName,ppguidProviderId)	\
    (This)->lpVtbl -> GetProviderCardId(This,bstrCardName,ppguidProviderId)

#define ISCardDatabase_ListCardInterfaces(This,bstrCardName,ppInterfaceGuids)	\
    (This)->lpVtbl -> ListCardInterfaces(This,bstrCardName,ppInterfaceGuids)

#define ISCardDatabase_ListCards(This,pAtr,pInterfaceGuids,localeId,ppCardNames)	\
    (This)->lpVtbl -> ListCards(This,pAtr,pInterfaceGuids,localeId,ppCardNames)

#define ISCardDatabase_ListReaderGroups(This,localeId,ppReaderGroups)	\
    (This)->lpVtbl -> ListReaderGroups(This,localeId,ppReaderGroups)

#define ISCardDatabase_ListReaders(This,localeId,ppReaders)	\
    (This)->lpVtbl -> ListReaders(This,localeId,ppReaders)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardDatabase_GetProviderCardId_Proxy( 
    ISCardDatabase __RPC_FAR * This,
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId);


void __RPC_STUB ISCardDatabase_GetProviderCardId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardDatabase_ListCardInterfaces_Proxy( 
    ISCardDatabase __RPC_FAR * This,
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids);


void __RPC_STUB ISCardDatabase_ListCardInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardDatabase_ListCards_Proxy( 
    ISCardDatabase __RPC_FAR * This,
    /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
    /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames);


void __RPC_STUB ISCardDatabase_ListCards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardDatabase_ListReaderGroups_Proxy( 
    ISCardDatabase __RPC_FAR * This,
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups);


void __RPC_STUB ISCardDatabase_ListReaderGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardDatabase_ListReaders_Proxy( 
    ISCardDatabase __RPC_FAR * This,
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders);


void __RPC_STUB ISCardDatabase_ListReaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCardDatabase_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0249 */
/* [local] */ 

#endif // !_LPSCARDDATABASE_DEFINED

//////////////////////////////////////////////////////////////////
//
// ISCardLocate Interface
//
#ifndef _LPSCARDLOCATE_DEFINED
#define _LPSCARDLOCATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0249_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0249_v0_0_s_ifspec;

#ifndef __ISCardLocate_INTERFACE_DEFINED__
#define __ISCardLocate_INTERFACE_DEFINED__

/* interface ISCardLocate */
/* [unique][helpstring][uuid][object] */ 

typedef /* [unique] */ ISCardLocate __RPC_FAR *LPSCARDLOCATE;

typedef /* [unique] */ LPSCARDLOCATE LPSCARDLOC;


EXTERN_C const IID IID_ISCardLocate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1461AACD-6810-11D0-918F-00AA00C18068")
    ISCardLocate : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConfigureCardGuidSearch( 
            /* [in] */ LPSAFEARRAY pCardGuids,
            /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
            /* [defaultvalue][in] */ BSTR bstrTitle = L"",
            /* [defaultvalue][in] */ LONG lFlags = 1) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConfigureCardNameSearch( 
            /* [in] */ LPSAFEARRAY pCardNames,
            /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
            /* [defaultvalue][in] */ BSTR bstrTitle = L"",
            /* [defaultvalue][in] */ LONG lFlags = 1) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FindCard( 
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
            /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
            /* [defaultvalue][in] */ LONG lFlags,
            /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCardLocateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCardLocate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCardLocate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISCardLocate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureCardGuidSearch )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ LPSAFEARRAY pCardGuids,
            /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureCardNameSearch )( 
            ISCardLocate __RPC_FAR * This,
            /* [in] */ LPSAFEARRAY pCardNames,
            /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindCard )( 
            ISCardLocate __RPC_FAR * This,
            /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
            /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
            /* [defaultvalue][in] */ LONG lFlags,
            /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo);
        
        END_INTERFACE
    } ISCardLocateVtbl;

    interface ISCardLocate
    {
        CONST_VTBL struct ISCardLocateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCardLocate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCardLocate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCardLocate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCardLocate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISCardLocate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISCardLocate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISCardLocate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISCardLocate_ConfigureCardGuidSearch(This,pCardGuids,pGroupNames,bstrTitle,lFlags)	\
    (This)->lpVtbl -> ConfigureCardGuidSearch(This,pCardGuids,pGroupNames,bstrTitle,lFlags)

#define ISCardLocate_ConfigureCardNameSearch(This,pCardNames,pGroupNames,bstrTitle,lFlags)	\
    (This)->lpVtbl -> ConfigureCardNameSearch(This,pCardNames,pGroupNames,bstrTitle,lFlags)

#define ISCardLocate_FindCard(This,ShareMode,Protocols,lFlags,ppCardInfo)	\
    (This)->lpVtbl -> FindCard(This,ShareMode,Protocols,lFlags,ppCardInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardLocate_ConfigureCardGuidSearch_Proxy( 
    ISCardLocate __RPC_FAR * This,
    /* [in] */ LPSAFEARRAY pCardGuids,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags);


void __RPC_STUB ISCardLocate_ConfigureCardGuidSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardLocate_ConfigureCardNameSearch_Proxy( 
    ISCardLocate __RPC_FAR * This,
    /* [in] */ LPSAFEARRAY pCardNames,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags);


void __RPC_STUB ISCardLocate_ConfigureCardNameSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISCardLocate_FindCard_Proxy( 
    ISCardLocate __RPC_FAR * This,
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
    /* [defaultvalue][in] */ LONG lFlags,
    /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo);


void __RPC_STUB ISCardLocate_FindCard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCardLocate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_scardssp_0250 */
/* [local] */ 

#endif // !_LPSCARDLOCATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_scardssp_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scardssp_0250_v0_0_s_ifspec;


#ifndef __SCARDSSPLib_LIBRARY_DEFINED__
#define __SCARDSSPLib_LIBRARY_DEFINED__

/* library SCARDSSPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SCARDSSPLib;

EXTERN_C const CLSID CLSID_CByteBuffer;

#ifdef __cplusplus

class DECLSPEC_UUID("E126F8FF-A7AF-11D0-B88A-00C04FD424B9")
CByteBuffer;
#endif

EXTERN_C const CLSID CLSID_CSCardTypeConv;

#ifdef __cplusplus

class DECLSPEC_UUID("53B6AA67-3F56-11D0-916B-00AA00C18068")
CSCardTypeConv;
#endif

EXTERN_C const CLSID CLSID_CSCardCmd;

#ifdef __cplusplus

class DECLSPEC_UUID("D5778AE7-43DE-11D0-9171-00AA00C18068")
CSCardCmd;
#endif

EXTERN_C const CLSID CLSID_CSCardISO7816;

#ifdef __cplusplus

class DECLSPEC_UUID("53B6AA6C-3F56-11D0-916B-00AA00C18068")
CSCardISO7816;
#endif

EXTERN_C const CLSID CLSID_CSCard;

#ifdef __cplusplus

class DECLSPEC_UUID("1461AAC7-6810-11D0-918F-00AA00C18068")
CSCard;
#endif

EXTERN_C const CLSID CLSID_CSCardDatabase;

#ifdef __cplusplus

class DECLSPEC_UUID("1461AACC-6810-11D0-918F-00AA00C18068")
CSCardDatabase;
#endif

EXTERN_C const CLSID CLSID_CSCardLocate;

#ifdef __cplusplus

class DECLSPEC_UUID("1461AAD1-6810-11D0-918F-00AA00C18068")
CSCardLocate;
#endif
#endif /* __SCARDSSPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HGLOBAL __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HGLOBAL_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HGLOBAL __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HGLOBAL_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HGLOBAL __RPC_FAR * ); 
void                      __RPC_USER  HGLOBAL_UserFree(     unsigned long __RPC_FAR *, HGLOBAL __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\schnlsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       schnlsp.h
//
//  Contents:   Public Definitions for SCHANNEL Security Provider
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------

#ifndef __SCHNLSP_H__
#define __SCHNLSP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <schannel.h>


#endif //__SCHNLSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scrptids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: scrptids.h
//
//--------------------------------------------------------------------------

// Invent DISPIDs for the things that don't have built-in dispid's
#define DISPID_LOAD		1
#define DISPID_UNLOAD	2
#define DISPID_SUBMIT	3
#define DISPID_FOCUS	4
#define DISPID_CHANGE	5
#define DISPID_BLUR		6
#define DISPID_SELECT	7
#define DISPID_MOUSEOVER 8
#define DISPID_PARSECOMPLETE 9
#define DISPID_ABORT	10
#define DISPID_ERROR	11
#define DISPID_MOUSEOUT 12
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SchemaEdit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Apr 22 20:05:10 1998
 */
/* Compiler settings for schemaedit.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __schemaedit_h__
#define __schemaedit_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISearchSchema_FWD_DEFINED__
#define __ISearchSchema_FWD_DEFINED__
typedef interface ISearchSchema ISearchSchema;
#endif 	/* __ISearchSchema_FWD_DEFINED__ */


#ifndef __IColumn_FWD_DEFINED__
#define __IColumn_FWD_DEFINED__
typedef interface IColumn IColumn;
#endif 	/* __IColumn_FWD_DEFINED__ */


#ifndef __IColumns_FWD_DEFINED__
#define __IColumns_FWD_DEFINED__
typedef interface IColumns IColumns;
#endif 	/* __IColumns_FWD_DEFINED__ */


#ifndef __IStoplist_FWD_DEFINED__
#define __IStoplist_FWD_DEFINED__
typedef interface IStoplist IStoplist;
#endif 	/* __IStoplist_FWD_DEFINED__ */


#ifndef __IStoplists_FWD_DEFINED__
#define __IStoplists_FWD_DEFINED__
typedef interface IStoplists IStoplists;
#endif 	/* __IStoplists_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISearchSchema_INTERFACE_DEFINED__
#define __ISearchSchema_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISearchSchema
 * at Wed Apr 22 20:05:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISearchSchema;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1F0B79D5-1B41-11D1-BCD1-00C04FB6EAD7")
    ISearchSchema : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Columns( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stoplists( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchSchemaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchSchema __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchSchema __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchSchema __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchSchema __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchSchema __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchSchema __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchSchema __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ISearchSchema __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Columns )( 
            ISearchSchema __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Stoplists )( 
            ISearchSchema __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } ISearchSchemaVtbl;

    interface ISearchSchema
    {
        CONST_VTBL struct ISearchSchemaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchSchema_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchSchema_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchSchema_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchSchema_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchSchema_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchSchema_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchSchema_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchSchema_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define ISearchSchema_get_Columns(This,pVal)	\
    (This)->lpVtbl -> get_Columns(This,pVal)

#define ISearchSchema_get_Stoplists(This,pVal)	\
    (This)->lpVtbl -> get_Stoplists(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchSchema_Save_Proxy( 
    ISearchSchema __RPC_FAR * This);


void __RPC_STUB ISearchSchema_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchSchema_get_Columns_Proxy( 
    ISearchSchema __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB ISearchSchema_get_Columns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchSchema_get_Stoplists_Proxy( 
    ISearchSchema __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB ISearchSchema_get_Stoplists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchSchema_INTERFACE_DEFINED__ */


#ifndef __IColumn_INTERFACE_DEFINED__
#define __IColumn_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IColumn
 * at Wed Apr 22 20:05:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IColumn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1F0B79D9-1B41-11D1-BCD1-00C04FB6EAD7")
    IColumn : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropGuid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PropGuid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropPid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PropPid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retrieve( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retrieve( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Length( 
            /* [in] */ LONG newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColumn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColumn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColumn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColumn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColumn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColumn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColumn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IColumn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IColumn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropGuid )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PropGuid )( 
            IColumn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropPid )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PropPid )( 
            IColumn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Retrieve )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Retrieve )( 
            IColumn __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Index )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Index )( 
            IColumn __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            IColumn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Length )( 
            IColumn __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Length )( 
            IColumn __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        END_INTERFACE
    } IColumnVtbl;

    interface IColumn
    {
        CONST_VTBL struct IColumnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColumn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColumn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColumn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IColumn_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IColumn_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IColumn_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IColumn_put_Description(This,newVal)	\
    (This)->lpVtbl -> put_Description(This,newVal)

#define IColumn_get_PropGuid(This,pVal)	\
    (This)->lpVtbl -> get_PropGuid(This,pVal)

#define IColumn_put_PropGuid(This,newVal)	\
    (This)->lpVtbl -> put_PropGuid(This,newVal)

#define IColumn_get_PropPid(This,pVal)	\
    (This)->lpVtbl -> get_PropPid(This,pVal)

#define IColumn_put_PropPid(This,newVal)	\
    (This)->lpVtbl -> put_PropPid(This,newVal)

#define IColumn_get_Retrieve(This,pVal)	\
    (This)->lpVtbl -> get_Retrieve(This,pVal)

#define IColumn_put_Retrieve(This,newVal)	\
    (This)->lpVtbl -> put_Retrieve(This,newVal)

#define IColumn_get_Index(This,pVal)	\
    (This)->lpVtbl -> get_Index(This,pVal)

#define IColumn_put_Index(This,newVal)	\
    (This)->lpVtbl -> put_Index(This,newVal)

#define IColumn_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IColumn_put_Type(This,newVal)	\
    (This)->lpVtbl -> put_Type(This,newVal)

#define IColumn_get_Length(This,pVal)	\
    (This)->lpVtbl -> get_Length(This,pVal)

#define IColumn_put_Length(This,newVal)	\
    (This)->lpVtbl -> put_Length(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Name_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Name_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IColumn_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Description_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Description_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IColumn_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_PropGuid_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_PropGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_PropGuid_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IColumn_put_PropGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_PropPid_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_PropPid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_PropPid_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IColumn_put_PropPid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Retrieve_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Retrieve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Retrieve_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IColumn_put_Retrieve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Index_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Index_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IColumn_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Type_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Type_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IColumn_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumn_get_Length_Proxy( 
    IColumn __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IColumn_get_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IColumn_put_Length_Proxy( 
    IColumn __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IColumn_put_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumn_INTERFACE_DEFINED__ */


#ifndef __IColumns_INTERFACE_DEFINED__
#define __IColumns_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IColumns
 * at Wed Apr 22 20:05:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IColumns;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FC33E907-1E62-11d1-BCD1-00C04FB6EAD7")
    IColumns : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Description,
            /* [in] */ BSTR Type,
            /* [in] */ BSTR PropGuid,
            /* [in] */ BSTR PropPid,
            /* [in] */ VARIANT_BOOL Index,
            /* [in] */ VARIANT_BOOL Retrieve,
            /* [in] */ LONG Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColumns __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColumns __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColumns __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColumns __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColumns __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColumns __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColumns __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IColumns __RPC_FAR * This,
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IColumns __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IColumns __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IColumns __RPC_FAR * This,
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IColumns __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Description,
            /* [in] */ BSTR Type,
            /* [in] */ BSTR PropGuid,
            /* [in] */ BSTR PropPid,
            /* [in] */ VARIANT_BOOL Index,
            /* [in] */ VARIANT_BOOL Retrieve,
            /* [in] */ LONG Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IColumns __RPC_FAR * This);
        
        END_INTERFACE
    } IColumnsVtbl;

    interface IColumns
    {
        CONST_VTBL struct IColumnsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumns_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumns_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumns_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumns_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColumns_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColumns_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColumns_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IColumns_get_Item(This,Key,pVal)	\
    (This)->lpVtbl -> get_Item(This,Key,pVal)

#define IColumns_get__NewEnum(This,ppUnkIter)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnkIter)

#define IColumns_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IColumns_Remove(This,Key,pVal)	\
    (This)->lpVtbl -> Remove(This,Key,pVal)

#define IColumns_Add(This,Name,Description,Type,PropGuid,PropPid,Index,Retrieve,Length,pResult)	\
    (This)->lpVtbl -> Add(This,Name,Description,Type,PropGuid,PropPid,Index,Retrieve,Length,pResult)

#define IColumns_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumns_get_Item_Proxy( 
    IColumns __RPC_FAR * This,
    /* [in] */ BSTR Key,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IColumns_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumns_get__NewEnum_Proxy( 
    IColumns __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter);


void __RPC_STUB IColumns_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IColumns_get_Count_Proxy( 
    IColumns __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IColumns_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumns_Remove_Proxy( 
    IColumns __RPC_FAR * This,
    /* [in] */ BSTR Key,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IColumns_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumns_Add_Proxy( 
    IColumns __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR Description,
    /* [in] */ BSTR Type,
    /* [in] */ BSTR PropGuid,
    /* [in] */ BSTR PropPid,
    /* [in] */ VARIANT_BOOL Index,
    /* [in] */ VARIANT_BOOL Retrieve,
    /* [in] */ LONG Length,
    /* [retval][out] */ VARIANT __RPC_FAR *pResult);


void __RPC_STUB IColumns_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumns_Clear_Proxy( 
    IColumns __RPC_FAR * This);


void __RPC_STUB IColumns_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumns_INTERFACE_DEFINED__ */


#ifndef __IStoplist_INTERFACE_DEFINED__
#define __IStoplist_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStoplist
 * at Wed Apr 22 20:05:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IStoplist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1F0B79D8-1B41-11D1-BCD1-00C04FB6EAD7")
    IStoplist : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Language( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubLanguage( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubLanguage( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStoplistVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStoplist __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStoplist __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStoplist __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IStoplist __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IStoplist __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Language )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubLanguage )( 
            IStoplist __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubLanguage )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filename )( 
            IStoplist __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Filename )( 
            IStoplist __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IStoplistVtbl;

    interface IStoplist
    {
        CONST_VTBL struct IStoplistVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStoplist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStoplist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStoplist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStoplist_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStoplist_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStoplist_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStoplist_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStoplist_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IStoplist_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IStoplist_get_Language(This,pVal)	\
    (This)->lpVtbl -> get_Language(This,pVal)

#define IStoplist_put_Language(This,newVal)	\
    (This)->lpVtbl -> put_Language(This,newVal)

#define IStoplist_get_SubLanguage(This,pVal)	\
    (This)->lpVtbl -> get_SubLanguage(This,pVal)

#define IStoplist_put_SubLanguage(This,newVal)	\
    (This)->lpVtbl -> put_SubLanguage(This,newVal)

#define IStoplist_get_Filename(This,pVal)	\
    (This)->lpVtbl -> get_Filename(This,pVal)

#define IStoplist_put_Filename(This,newVal)	\
    (This)->lpVtbl -> put_Filename(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplist_get_Name_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IStoplist_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IStoplist_put_Name_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IStoplist_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplist_get_Language_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IStoplist_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IStoplist_put_Language_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IStoplist_put_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplist_get_SubLanguage_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IStoplist_get_SubLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IStoplist_put_SubLanguage_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IStoplist_put_SubLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplist_get_Filename_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IStoplist_get_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IStoplist_put_Filename_Proxy( 
    IStoplist __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IStoplist_put_Filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStoplist_INTERFACE_DEFINED__ */


#ifndef __IStoplists_INTERFACE_DEFINED__
#define __IStoplists_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStoplists
 * at Wed Apr 22 20:05:10 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IStoplists;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("69A5414B-1F07-11D1-BCD1-00C04FB6EAD7")
    IStoplists : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Filename,
            /* [in] */ LONG Language,
            /* [in] */ LONG SubLanguage,
            /* [retval][out] */ VARIANT __RPC_FAR *pResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStoplistsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStoplists __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStoplists __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStoplists __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStoplists __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStoplists __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ BSTR Key,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IStoplists __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Filename,
            /* [in] */ LONG Language,
            /* [in] */ LONG SubLanguage,
            /* [retval][out] */ VARIANT __RPC_FAR *pResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IStoplists __RPC_FAR * This);
        
        END_INTERFACE
    } IStoplistsVtbl;

    interface IStoplists
    {
        CONST_VTBL struct IStoplistsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStoplists_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStoplists_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStoplists_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStoplists_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStoplists_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStoplists_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStoplists_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStoplists_get_Item(This,Key,pVal)	\
    (This)->lpVtbl -> get_Item(This,Key,pVal)

#define IStoplists_get__NewEnum(This,ppUnkIter)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnkIter)

#define IStoplists_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IStoplists_Remove(This,Key,pVal)	\
    (This)->lpVtbl -> Remove(This,Key,pVal)

#define IStoplists_Add(This,Name,Filename,Language,SubLanguage,pResult)	\
    (This)->lpVtbl -> Add(This,Name,Filename,Language,SubLanguage,pResult)

#define IStoplists_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplists_get_Item_Proxy( 
    IStoplists __RPC_FAR * This,
    /* [in] */ BSTR Key,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IStoplists_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplists_get__NewEnum_Proxy( 
    IStoplists __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkIter);


void __RPC_STUB IStoplists_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStoplists_get_Count_Proxy( 
    IStoplists __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IStoplists_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStoplists_Remove_Proxy( 
    IStoplists __RPC_FAR * This,
    /* [in] */ BSTR Key,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IStoplists_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStoplists_Add_Proxy( 
    IStoplists __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR Filename,
    /* [in] */ LONG Language,
    /* [in] */ LONG SubLanguage,
    /* [retval][out] */ VARIANT __RPC_FAR *pResult);


void __RPC_STUB IStoplists_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStoplists_Clear_Proxy( 
    IStoplists __RPC_FAR * This);


void __RPC_STUB IStoplists_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStoplists_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\secext.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1999
//
// File:        secext.h
//
// Contents:    Security function prototypes for functions not part of
//              the SSPI interface. This file should not be directly
//              included - include security.h instead.
//
//
// History:     22 Dec 92   RichardW    Created
//
//------------------------------------------------------------------------



#ifndef __SECEXT_H__
#define __SECEXT_H__
#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// This is the combined authentication identity structure that may be
// used with the negotiate package, NTLM, Kerberos, or SCHANNEL
//


#ifndef SEC_WINNT_AUTH_IDENTITY_VERSION
#define SEC_WINNT_AUTH_IDENTITY_VERSION 0x200

typedef struct _SEC_WINNT_AUTH_IDENTITY_EXW {
    unsigned long Version;
    unsigned long Length;
    unsigned short SEC_FAR *User;
    unsigned long UserLength;
    unsigned short SEC_FAR *Domain;
    unsigned long DomainLength;
    unsigned short SEC_FAR *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned short SEC_FAR * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXW, *PSEC_WINNT_AUTH_IDENTITY_EXW;


typedef struct _SEC_WINNT_AUTH_IDENTITY_EXA {
    unsigned long Version;
    unsigned long Length;
    unsigned char SEC_FAR *User;
    unsigned long UserLength;
    unsigned char SEC_FAR *Domain;
    unsigned long DomainLength;
    unsigned char SEC_FAR *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned char SEC_FAR * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXA, *PSEC_WINNT_AUTH_IDENTITY_EXA;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY_EX  SEC_WINNT_AUTH_IDENTITY_EXW
#else 
#define SEC_WINNT_AUTH_IDENTITY_EX  SEC_WINNT_AUTH_IDENTITY_EXA
#endif 

#endif // SEC_WINNT_AUTH_IDENTITY_VERSION


//
// Common types used by negotiable security packages
//

#define SEC_WINNT_AUTH_IDENTITY_MARSHALLED      0x4     // all data is in one buffer
#define SEC_WINNT_AUTH_IDENTITY_ONLY            0x8     // these credentials are for identity only - no PAC needed


//
// Routines for manipulating packages
//

typedef struct _SECURITY_PACKAGE_OPTIONS {
    unsigned long   Size;
    unsigned long   Type;
    unsigned long   Flags;
    unsigned long   SignatureSize;
    void SEC_FAR *  Signature;
} SECURITY_PACKAGE_OPTIONS, SEC_FAR * PSECURITY_PACKAGE_OPTIONS;

#define SECPKG_OPTIONS_TYPE_UNKNOWN 0
#define SECPKG_OPTIONS_TYPE_LSA     1
#define SECPKG_OPTIONS_TYPE_SSPI    2

#define SECPKG_OPTIONS_PERMANENT    0x00000001

SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageA(
    SEC_CHAR SEC_FAR *  pszPackageName,
    SECURITY_PACKAGE_OPTIONS SEC_FAR * Options
    );

SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageW(
    SEC_WCHAR SEC_FAR * pszPackageName,
    SECURITY_PACKAGE_OPTIONS SEC_FAR * Options
    );

#ifdef UNICODE
#define AddSecurityPackage  AddSecurityPackageW
#else
#define AddSecurityPackage  AddSecurityPackageA
#endif

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageA(
    SEC_CHAR SEC_FAR *  pszPackageName );

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageW(
    SEC_WCHAR SEC_FAR * pszPackageName );

#ifdef UNICODE
#define DeleteSecurityPackage   DeleteSecurityPackageW
#else
#define DeleteSecurityPackage   DeleteSecurityPackageA
#endif


//
// Extended Name APIs for ADS
//


typedef enum
{
    // Examples for the following formats assume a fictitous company
    // which hooks into the global X.500 and DNS name spaces as follows.
    //
    // Enterprise root domain in DNS is
    //
    //      widget.com
    //
    // Enterprise root domain in X.500 (RFC 1779 format) is
    //
    //      O=Widget, C=US
    //
    // There exists the child domain
    //
    //      engineering.widget.com
    //
    // equivalent to
    //
    //      OU=Engineering, O=Widget, C=US
    //
    // There exists a container within the Engineering domain
    //
    //      OU=Software, OU=Engineering, O=Widget, C=US
    //
    // There exists the user
    //
    //      CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US
    //
    // And this user's downlevel (pre-ADS) user name is
    //
    //      Engineering\JohnDoe

    // unknown name type
    NameUnknown = 0,

    // CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US
    NameFullyQualifiedDN = 1,

    // Engineering\JohnDoe
    NameSamCompatible = 2,

    // Probably "John Doe" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    NameDisplay = 3,


    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    NameUniqueId = 6,

    // engineering.widget.com/software/John Doe
    NameCanonical = 7,

    // johndoe@engineering.com
    NameUserPrincipal = 8,

    // Same as NameCanonical except that rightmost '/' is
    // replaced with '\n' - even in domain-only case.
    // eg: engineering.widget.com/software\nJohn Doe
    NameCanonicalEx = 9,

    // www/srv.engineering.com/engineering.com
    NameServicePrincipal = 10

} EXTENDED_NAME_FORMAT, * PEXTENDED_NAME_FORMAT ;

BOOLEAN
SEC_ENTRY
GetUserNameExA(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );
BOOLEAN
SEC_ENTRY
GetUserNameExW(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

#ifdef UNICODE
#define GetUserNameEx   GetUserNameExW
#else
#define GetUserNameEx   GetUserNameExA
#endif

BOOLEAN
SEC_ENTRY
GetComputerObjectNameA(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );
BOOLEAN
SEC_ENTRY
GetComputerObjectNameW(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

#ifdef UNICODE
#define GetComputerObjectName   GetComputerObjectNameW
#else
#define GetComputerObjectName   GetComputerObjectNameA
#endif

BOOLEAN
SEC_ENTRY
TranslateNameA(
    LPCSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPSTR lpTranslatedName,
    PULONG nSize
    );
BOOLEAN
SEC_ENTRY
TranslateNameW(
    LPCWSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPWSTR lpTranslatedName,
    PULONG nSize
    );
#ifdef UNICODE
#define TranslateName   TranslateNameW
#else
#define TranslateName   TranslateNameA
#endif

#ifdef __cplusplus
}
#endif

#endif // __SECEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows NT 3.1 screensaver defines and definitions.           *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*  Windows NT NOTE:   (Differences from Win 3.1 Screensavers)                 *
*                                                                             *
*               All Screensavers are required to have a Description string    *
*               of no more than 25 chars for display by the Control Panel's   *
*               Desktop applet.  This is string 1 in the resource string      *
*               table of the Windows 32-bit screen saver .SCR (.EXE) file.    *
*                                                                             *
*               Passwords for Windows NT Screen Savers are handled by the     *
*               Winlogon process.  If the registry value:                     *
*                                                                             *
*               HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure   *
*                                                                             *
*               is nonzero, Winlogon will ask for the User's login password   *
*               before allowing the Screen Saver to exit.  All password data  *
*               and dialogs have been removed from individual Screensavers.   *
*                                                                             *
*                                                                             *
*          Copyright (c) 1992-1999, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


/* MANDATORY string required in .RC file
 * This string should contain a less than 25 char name/description of the
 * screen saver.  This string is what will be seen by the user in the Control
 * Panel's Desktop applet screen saver listbox.
 */

#define IDS_DESCRIPTION      1

/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009
#define idsDefKeyword           1010

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
#ifdef UNICODE
LRESULT WINAPI ScreenSaverProcW (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#   define  ScreenSaverProc ScreenSaverProcW
#else
LRESULT WINAPI ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL WINAPI RegisterDialogClasses (HANDLE hInst);

/* The following functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog from the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)

#define MAXFILELEN         13
#define TITLEBARNAMELEN    40
#define APPNAMEBUFFERLEN   40
#define BUFFLEN           255

/* The following globals are defined in scrnsave.lib */
extern HINSTANCE hMainInstance;
extern HWND   hMainWindow;
extern BOOL   fChildPreview;
extern TCHAR  szName[TITLEBARNAMELEN];
extern TCHAR  szAppName[APPNAMEBUFFERLEN];
extern TCHAR  szIniFile[MAXFILELEN];
extern TCHAR  szScreenSaver[22];
extern TCHAR  szHelpFile[MAXFILELEN];
extern TCHAR  szNoHelpMemory[BUFFLEN];
extern UINT   MyHelpMessage;

/* OPTIONAL - Win95 Only */

#define SCRM_VERIFYPW   WM_APP
/*
 * This message is sent to the main screen saver window when password
 * protection is enabled and the user is trying to close the screen saver.  You
 * can process this message and provide your own validation technology.  If you
 * process this message, you should also support the ScreenSaverChangePassword
 * function, described below.  Return zero from this message if the password
 * check failed.  Return nonzero for success.  If you run out of memory or
 * encounter a similar class of error, return non-zero so the user isn't left
 * out in the cold.  The default action is to call the Windows Master
 * Password Router to validate the user's password.
 */

void WINAPI ScreenSaverChangePassword( HWND hParent );
/*
 * You supply this if you provide your own authentication.  Windows will call
 * it when the user wants to change the password.  An implementation of this
 * function should present password change UI to the user.
 * You should only supply this function if you also hook the SCRM_VERIFYPW
 * message to validate passwords.
 * The default action is to call the Windows Master Password Router.
 */


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#include <poppack.h>

#endif  /* !_INC_SCRNSAVE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\security.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1999
//
// File:        Security.h
//
// Contents:    Toplevel include file for security aware components
//
//
// History:     06 Aug 92   RichardW    Created
//              23 Sep 92   PeterWi     Add security object include files
//
//------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

// This file will go out and pull in all the header files that you need,
// based on defines that you issue.  The following macros are used.
//
// SECURITY_KERNEL      Use the kernel interface, not the usermode
//

//
// These are name that can be used to refer to the builtin packages
//

#ifndef NTLMSP_NAME_A
#define NTLMSP_NAME_A            "NTLM"
#define NTLMSP_NAME              L"NTLM"        // ntifs
#endif // NTLMSP_NAME

#ifndef MICROSOFT_KERBEROS_NAME_A
#define MICROSOFT_KERBEROS_NAME_A   "Kerberos"
#define MICROSOFT_KERBEROS_NAME_W   L"Kerberos"
#ifdef WIN32_CHICAGO
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_A
#else
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_W
#endif
#endif  // MICROSOFT_KERBEROS_NAME_A


#ifndef NEGOSSP_NAME
#define NEGOSSP_NAME_W  L"Negotiate"
#define NEGOSSP_NAME_A  "Negotiate"

#ifdef UNICODE
#define NEGOSSP_NAME    NEGOSSP_NAME_W
#else
#define NEGOSSP_NAME    NEGOSSP_NAME_A
#endif
#endif // NEGOSSP_NAME

//
// Include the master SSPI header file
//

#include <sspi.h>

#if defined(SECURITY_WIN32) || defined(SECURITY_KERNEL)
#include <secext.h>
#endif

//
// Include the error codes:
//

#if ISSP_LEVEL == 16
#include <issper16.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sehmap.h ===
/*

  SEHMAP.H - Map old-style structured exception handling to correct names.

  The mapping of structured exception handling statements from {try, except,
  finally, leave} to their proper names (prefaced by "__") has been removed
  from win32.mak.  This header is provided solely for compatibility with
  source code that used the older convention.

*/


#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try     __try
#define except  __except
#define finally __finally
#define leave   __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\semfperf.h ===
/**MOD+***********************************************************************/
/* Module:   semfperf.h                                                      */
/*                                                                           */
/* Purpose:  performance monitor dll structures                              */
/*                                                                           */
/* (C) COPYRIGHT DATA CONNECTION LIMITED 1991, 1992, 1993, 1994              */
/*                                                                           */
/*****************************************************************************/
/* SCAL SGF 16/06/94  Make default scales flexible                           */
/* MAXL AB  23/06/95  We now support 250 link services                       */
/**MOD-***********************************************************************/

#include <snapmon.h>

/************************************************************************MAXL*/
/* #define for the maximum number of LS available                       *MAXL*/
/************************************************************************MAXL*/
#define MAX_LINK_SVCS 250

typedef struct _LinkPerfShrHdr {
    ULONG          NumberOfLinkServices;
} LinkPerfShrHdr;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SensAPI.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    sensapi.h

Abstract:

    Public header file for the SENS Connectivity APIs.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/12/1997         Start.

--*/


#ifndef __SENSAPI_H__
#define __SENSAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define NETWORK_ALIVE_LAN   0x00000001
#define NETWORK_ALIVE_WAN   0x00000002
#define NETWORK_ALIVE_AOL   0x00000004


typedef struct tagQOCINFO
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwInSpeed;
    DWORD dwOutSpeed;
} QOCINFO, *LPQOCINFO;



#ifdef UNICODE
#define  IsDestinationReachable  IsDestinationReachableW
#else
#define  IsDestinationReachable  IsDestinationReachableA
#endif // UNICODE


#if !defined(__midl)

BOOL APIENTRY
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsNetworkAlive(
    LPDWORD lpdwFlags
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Sddl.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddl.w

Abstract:

    This module defines the support and conversions routines necessary for SDDL.

Revision History:

--*/

#ifndef __SDDL_H__
#define __SDDL_H__


#ifdef __cplusplus
extern "C" {
#endif

//
// SDDL Version information
//
#define SDDL_REVISION_1     1
#define SDDL_REVISION       SDDL_REVISION_1

//
// SDDL Component tags
//
#define SDDL_OWNER                          TEXT("O")       // Owner tag
#define SDDL_GROUP                          TEXT("G")       // Group tag
#define SDDL_DACL                           TEXT("D")       // DACL tag
#define SDDL_SACL                           TEXT("S")       // SACL tag

//
// SDDL Security descriptor controls
//
#define SDDL_PROTECTED                      TEXT("P")       // DACL or SACL Protected
#define SDDL_AUTO_INHERIT_REQ               TEXT("AR")      // Auto inherit request
#define SDDL_AUTO_INHERITED                 TEXT("AI")      // DACL/SACL are auto inherited

//
// SDDL Ace types
//
#define SDDL_ACCESS_ALLOWED                 TEXT("A")   // Access allowed
#define SDDL_ACCESS_DENIED                  TEXT("D")   // Access denied
#define SDDL_OBJECT_ACCESS_ALLOWED          TEXT("OA")  // Object access allowed
#define SDDL_OBJECT_ACCESS_DENIED           TEXT("OD")  // Object access denied
#define SDDL_AUDIT                          TEXT("AU")  // Audit
#define SDDL_ALARM                          TEXT("AL")  // Alarm
#define SDDL_OBJECT_AUDIT                   TEXT("OU")  // Object audit
#define SDDL_OBJECT_ALARM                   TEXT("OL")  // Object alarm

//
// SDDL Ace flags
//
#define SDDL_CONTAINER_INHERIT              TEXT("CI")  // Container inherit
#define SDDL_OBJECT_INHERIT                 TEXT("OI")  // Object inherit
#define SDDL_NO_PROPAGATE                   TEXT("NP")  // Inherit no propagate
#define SDDL_INHERIT_ONLY                   TEXT("IO")  // Inherit only
#define SDDL_INHERITED                      TEXT("ID")  // Inherited
#define SDDL_AUDIT_SUCCESS                  TEXT("SA")  // Audit success
#define SDDL_AUDIT_FAILURE                  TEXT("FA")  // Audit failure


//
// SDDL Rights
//
#define SDDL_READ_PROPERTY                  TEXT("RP")
#define SDDL_WRITE_PROPERTY                 TEXT("WP")
#define SDDL_CREATE_CHILD                   TEXT("CC")
#define SDDL_DELETE_CHILD                   TEXT("DC")
#define SDDL_LIST_CHILDREN                  TEXT("LC")
#define SDDL_SELF_WRITE                     TEXT("SW")
#define SDDL_LIST_OBJECT                    TEXT("LO")
#define SDDL_DELETE_TREE                    TEXT("DT")
#define SDDL_CONTROL_ACCESS                 TEXT("CR")
#define SDDL_READ_CONTROL                   TEXT("RC")
#define SDDL_WRITE_DAC                      TEXT("WD")
#define SDDL_WRITE_OWNER                    TEXT("WO")
#define SDDL_STANDARD_DELETE                TEXT("SD")
#define SDDL_GENERIC_ALL                    TEXT("GA")
#define SDDL_GENERIC_READ                   TEXT("GR")
#define SDDL_GENERIC_WRITE                  TEXT("GW")
#define SDDL_GENERIC_EXECUTE                TEXT("GX")
#define SDDL_FILE_ALL                       TEXT("FA")
#define SDDL_FILE_READ                      TEXT("FR")
#define SDDL_FILE_WRITE                     TEXT("FW")
#define SDDL_FILE_EXECUTE                   TEXT("FX")
#define SDDL_KEY_ALL                        TEXT("KA")
#define SDDL_KEY_READ                       TEXT("KR")
#define SDDL_KEY_WRITE                      TEXT("KW")
#define SDDL_KEY_EXECUTE                    TEXT("KX")

//
// SDDL User aliases
//
#define SDDL_DOMAIN_ADMINISTRATORS          TEXT("DA")      // Domain admins
#define SDDL_DOMAIN_GUESTS                  TEXT("DG")      // Domain guests
#define SDDL_DOMAIN_USERS                   TEXT("DU")      // Domain users
#define SDDL_ENTERPRISE_DOMAIN_CONTROLLERS  TEXT("ED")      // Enterprise domain controllers
#define SDDL_DOMAIN_DOMAIN_CONTROLLERS      TEXT("DD")      // Domain domain controllers
#define SDDL_DOMAIN_COMPUTERS               TEXT("DC")      // Domain computers
#define SDDL_BUILTIN_ADMINISTRATORS         TEXT("BA")      // Builtin (local ) administrators
#define SDDL_BUILTIN_GUESTS                 TEXT("BG")      // Builtin (local ) guests
#define SDDL_BUILTIN_USERS                  TEXT("BU")      // Builtin (local ) users
#define SDDL_LOCAL_ADMIN                    TEXT("LA")      // Local administrator account
#define SDDL_LOCAL_GUEST                    TEXT("LG")      // Local group account
#define SDDL_ACCOUNT_OPERATORS              TEXT("AO")      // Account operators
#define SDDL_BACKUP_OPERATORS               TEXT("BO")      // Backup operators
#define SDDL_PRINTER_OPERATORS              TEXT("PO")      // Printer operators
#define SDDL_SERVER_OPERATORS               TEXT("SO")      // Server operators
#define SDDL_AUTHENTICATED_USERS            TEXT("AU")      // Authenticated users
#define SDDL_PERSONAL_SELF                  TEXT("PS")      // Personal self
#define SDDL_CREATOR_OWNER                  TEXT("CO")      // Creator owner
#define SDDL_CREATOR_GROUP                  TEXT("CG")      // Creator group
#define SDDL_LOCAL_SYSTEM                   TEXT("SY")      // Local system
#define SDDL_POWER_USERS                    TEXT("PU")      // Power users
#define SDDL_EVERYONE                       TEXT("WD")      // Everyone ( World )
#define SDDL_REPLICATOR                     TEXT("RE")      // Replicator
#define SDDL_INTERACTIVE                    TEXT("IU")      // Interactive logon user
#define SDDL_NETWORK                        TEXT("NU")      // Nework logon user
#define SDDL_SERVICE                        TEXT("SU")      // Service logon user
#define SDDL_RESTRICTED_CODE                TEXT("RC")      // Restricted code
#define SDDL_SCHEMA_ADMINISTRATORS          TEXT("SA")      // Schema Administrators
#define SDDL_CERT_SERV_ADMINISTRATORS       TEXT("CA")      // Certificate Server Administrators
#define SDDL_RAS_SERVERS                    TEXT("RS")      // RAS servers group
#define SDDL_ENTERPRISE_ADMINS              TEXT("EA")      // Enterprise administrators
#define SDDL_GROUP_POLICY_ADMINS            TEXT("PA")      // Group Policy administrators
#define SDDL_ALIAS_PREW2KCOMPACC            TEXT("RU")      // alias to allow previous windows 2000
#define SDDL_LOCAL_SERVICE                  TEXT("LS")      // Local service account (for services)
#define SDDL_NETWORK_SERVICE                TEXT("NS")      // Network service account (for services)
#define SDDL_REMOTE_DESKTOP                 TEXT("RD")      // Remote desktop users (for terminal server)


//
// SDDL Seperators
//
#define SDDL_SEPERATORC                     TEXT(';')
#define SDDL_DELIMINATORC                   TEXT(':')
#define SDDL_ACE_BEGINC                     TEXT('(')
#define SDDL_ACE_ENDC                       TEXT(')')


#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
WINAPI
ConvertSidToStringSidA(
    IN  PSID     Sid,
    OUT LPSTR  *StringSid
    );
WINADVAPI
BOOL
WINAPI
ConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    );
#ifdef UNICODE
#define ConvertSidToStringSid  ConvertSidToStringSidW
#else
#define ConvertSidToStringSid  ConvertSidToStringSidA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertStringSidToSidA(
    IN LPCSTR   StringSid,
    OUT PSID   *Sid
    );
WINADVAPI
BOOL
WINAPI
ConvertStringSidToSidW(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid
    );
#ifdef UNICODE
#define ConvertStringSidToSid  ConvertStringSidToSidW
#else
#define ConvertStringSidToSid  ConvertStringSidToSidA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertStringSecurityDescriptorToSecurityDescriptorA(
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );
WINADVAPI
BOOL
WINAPI
ConvertStringSecurityDescriptorToSecurityDescriptorW(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );
#ifdef UNICODE
#define ConvertStringSecurityDescriptorToSecurityDescriptor  ConvertStringSecurityDescriptorToSecurityDescriptorW
#else
#define ConvertStringSecurityDescriptorToSecurityDescriptor  ConvertStringSecurityDescriptorToSecurityDescriptorA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ConvertSecurityDescriptorToStringSecurityDescriptorA(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );
WINADVAPI
BOOL
WINAPI
ConvertSecurityDescriptorToStringSecurityDescriptorW(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToStringSecurityDescriptor  ConvertSecurityDescriptorToStringSecurityDescriptorW
#else
#define ConvertSecurityDescriptorToStringSecurityDescriptor  ConvertSecurityDescriptorToStringSecurityDescriptorA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */


#ifdef __cplusplus
}
#endif

#endif  // endif __SDDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sdpblb.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for sdpblb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sdpblb_h__
#define __sdpblb_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITConferenceBlob_FWD_DEFINED__
#define __ITConferenceBlob_FWD_DEFINED__
typedef interface ITConferenceBlob ITConferenceBlob;
#endif 	/* __ITConferenceBlob_FWD_DEFINED__ */


#ifndef __ITMedia_FWD_DEFINED__
#define __ITMedia_FWD_DEFINED__
typedef interface ITMedia ITMedia;
#endif 	/* __ITMedia_FWD_DEFINED__ */


#ifndef __IEnumMedia_FWD_DEFINED__
#define __IEnumMedia_FWD_DEFINED__
typedef interface IEnumMedia IEnumMedia;
#endif 	/* __IEnumMedia_FWD_DEFINED__ */


#ifndef __ITMediaCollection_FWD_DEFINED__
#define __ITMediaCollection_FWD_DEFINED__
typedef interface ITMediaCollection ITMediaCollection;
#endif 	/* __ITMediaCollection_FWD_DEFINED__ */


#ifndef __ITTime_FWD_DEFINED__
#define __ITTime_FWD_DEFINED__
typedef interface ITTime ITTime;
#endif 	/* __ITTime_FWD_DEFINED__ */


#ifndef __IEnumTime_FWD_DEFINED__
#define __IEnumTime_FWD_DEFINED__
typedef interface IEnumTime IEnumTime;
#endif 	/* __IEnumTime_FWD_DEFINED__ */


#ifndef __ITTimeCollection_FWD_DEFINED__
#define __ITTimeCollection_FWD_DEFINED__
typedef interface ITTimeCollection ITTimeCollection;
#endif 	/* __ITTimeCollection_FWD_DEFINED__ */


#ifndef __ITSdp_FWD_DEFINED__
#define __ITSdp_FWD_DEFINED__
typedef interface ITSdp ITSdp;
#endif 	/* __ITSdp_FWD_DEFINED__ */


#ifndef __ITConnection_FWD_DEFINED__
#define __ITConnection_FWD_DEFINED__
typedef interface ITConnection ITConnection;
#endif 	/* __ITConnection_FWD_DEFINED__ */


#ifndef __ITAttributeList_FWD_DEFINED__
#define __ITAttributeList_FWD_DEFINED__
typedef interface ITAttributeList ITAttributeList;
#endif 	/* __ITAttributeList_FWD_DEFINED__ */


#ifndef __ITMedia_FWD_DEFINED__
#define __ITMedia_FWD_DEFINED__
typedef interface ITMedia ITMedia;
#endif 	/* __ITMedia_FWD_DEFINED__ */


#ifndef __ITTime_FWD_DEFINED__
#define __ITTime_FWD_DEFINED__
typedef interface ITTime ITTime;
#endif 	/* __ITTime_FWD_DEFINED__ */


#ifndef __ITConnection_FWD_DEFINED__
#define __ITConnection_FWD_DEFINED__
typedef interface ITConnection ITConnection;
#endif 	/* __ITConnection_FWD_DEFINED__ */


#ifndef __ITAttributeList_FWD_DEFINED__
#define __ITAttributeList_FWD_DEFINED__
typedef interface ITAttributeList ITAttributeList;
#endif 	/* __ITAttributeList_FWD_DEFINED__ */


#ifndef __SdpConferenceBlob_FWD_DEFINED__
#define __SdpConferenceBlob_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpConferenceBlob SdpConferenceBlob;
#else
typedef struct SdpConferenceBlob SdpConferenceBlob;
#endif /* __cplusplus */

#endif 	/* __SdpConferenceBlob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sdpblb_0000 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */

#define	IDISPCONFBLOB	( 0x10000 )

#define	IDISPSDP	( 0x20000 )

#define	IDISPCONNECTION	( 0x30000 )

#define	IDISPATTRLIST	( 0x40000 )

#define	IDISPMEDIA	( 0x50000 )

typedef 
enum BLOB_CHARACTER_SET
    {	BCS_ASCII	= 1,
	BCS_UTF7	= 2,
	BCS_UTF8	= 3
    } 	BLOB_CHARACTER_SET;



extern RPC_IF_HANDLE __MIDL_itf_sdpblb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdpblb_0000_v0_0_s_ifspec;

#ifndef __ITConferenceBlob_INTERFACE_DEFINED__
#define __ITConferenceBlob_INTERFACE_DEFINED__

/* interface ITConferenceBlob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITConferenceBlob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C259D7AA-C8AB-11D0-8D58-00C04FD91AC0")
    ITConferenceBlob : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ BSTR pName,
            /* [in] */ BLOB_CHARACTER_SET CharacterSet,
            /* [in] */ BSTR pBlob) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CharacterSet( 
            /* [retval][out] */ BLOB_CHARACTER_SET *pCharacterSet) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConferenceBlob( 
            /* [retval][out] */ BSTR *ppBlob) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetConferenceBlob( 
            /* [in] */ BLOB_CHARACTER_SET CharacterSet,
            /* [in] */ BSTR pBlob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITConferenceBlobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITConferenceBlob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITConferenceBlob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITConferenceBlob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITConferenceBlob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITConferenceBlob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITConferenceBlob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITConferenceBlob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            ITConferenceBlob * This,
            /* [in] */ BSTR pName,
            /* [in] */ BLOB_CHARACTER_SET CharacterSet,
            /* [in] */ BSTR pBlob);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CharacterSet )( 
            ITConferenceBlob * This,
            /* [retval][out] */ BLOB_CHARACTER_SET *pCharacterSet);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConferenceBlob )( 
            ITConferenceBlob * This,
            /* [retval][out] */ BSTR *ppBlob);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetConferenceBlob )( 
            ITConferenceBlob * This,
            /* [in] */ BLOB_CHARACTER_SET CharacterSet,
            /* [in] */ BSTR pBlob);
        
        END_INTERFACE
    } ITConferenceBlobVtbl;

    interface ITConferenceBlob
    {
        CONST_VTBL struct ITConferenceBlobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITConferenceBlob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITConferenceBlob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITConferenceBlob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITConferenceBlob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITConferenceBlob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITConferenceBlob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITConferenceBlob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITConferenceBlob_Init(This,pName,CharacterSet,pBlob)	\
    (This)->lpVtbl -> Init(This,pName,CharacterSet,pBlob)

#define ITConferenceBlob_get_CharacterSet(This,pCharacterSet)	\
    (This)->lpVtbl -> get_CharacterSet(This,pCharacterSet)

#define ITConferenceBlob_get_ConferenceBlob(This,ppBlob)	\
    (This)->lpVtbl -> get_ConferenceBlob(This,ppBlob)

#define ITConferenceBlob_SetConferenceBlob(This,CharacterSet,pBlob)	\
    (This)->lpVtbl -> SetConferenceBlob(This,CharacterSet,pBlob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConferenceBlob_Init_Proxy( 
    ITConferenceBlob * This,
    /* [in] */ BSTR pName,
    /* [in] */ BLOB_CHARACTER_SET CharacterSet,
    /* [in] */ BSTR pBlob);


void __RPC_STUB ITConferenceBlob_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConferenceBlob_get_CharacterSet_Proxy( 
    ITConferenceBlob * This,
    /* [retval][out] */ BLOB_CHARACTER_SET *pCharacterSet);


void __RPC_STUB ITConferenceBlob_get_CharacterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConferenceBlob_get_ConferenceBlob_Proxy( 
    ITConferenceBlob * This,
    /* [retval][out] */ BSTR *ppBlob);


void __RPC_STUB ITConferenceBlob_get_ConferenceBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConferenceBlob_SetConferenceBlob_Proxy( 
    ITConferenceBlob * This,
    /* [in] */ BLOB_CHARACTER_SET CharacterSet,
    /* [in] */ BSTR pBlob);


void __RPC_STUB ITConferenceBlob_SetConferenceBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITConferenceBlob_INTERFACE_DEFINED__ */


#ifndef __ITMedia_INTERFACE_DEFINED__
#define __ITMedia_INTERFACE_DEFINED__

/* interface ITMedia */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMedia;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CC1F053-CAEB-11D0-8D58-00C04FD91AC0")
    ITMedia : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaName( 
            /* [retval][out] */ BSTR *ppMediaName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaName( 
            /* [in] */ BSTR pMediaName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartPort( 
            /* [retval][out] */ LONG *pStartPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumPorts( 
            /* [retval][out] */ LONG *pNumPorts) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransportProtocol( 
            /* [retval][out] */ BSTR *ppProtocol) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransportProtocol( 
            /* [in] */ BSTR pProtocol) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FormatCodes( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FormatCodes( 
            /* [in] */ VARIANT NewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaTitle( 
            /* [retval][out] */ BSTR *ppMediaTitle) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaTitle( 
            /* [in] */ BSTR pMediaTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPortInfo( 
            /* [in] */ LONG StartPort,
            /* [in] */ LONG NumPorts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMedia * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMedia * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMedia * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMedia * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMedia * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMedia * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMedia * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaName )( 
            ITMedia * This,
            /* [retval][out] */ BSTR *ppMediaName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaName )( 
            ITMedia * This,
            /* [in] */ BSTR pMediaName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartPort )( 
            ITMedia * This,
            /* [retval][out] */ LONG *pStartPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumPorts )( 
            ITMedia * This,
            /* [retval][out] */ LONG *pNumPorts);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransportProtocol )( 
            ITMedia * This,
            /* [retval][out] */ BSTR *ppProtocol);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransportProtocol )( 
            ITMedia * This,
            /* [in] */ BSTR pProtocol);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FormatCodes )( 
            ITMedia * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FormatCodes )( 
            ITMedia * This,
            /* [in] */ VARIANT NewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTitle )( 
            ITMedia * This,
            /* [retval][out] */ BSTR *ppMediaTitle);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaTitle )( 
            ITMedia * This,
            /* [in] */ BSTR pMediaTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPortInfo )( 
            ITMedia * This,
            /* [in] */ LONG StartPort,
            /* [in] */ LONG NumPorts);
        
        END_INTERFACE
    } ITMediaVtbl;

    interface ITMedia
    {
        CONST_VTBL struct ITMediaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMedia_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITMedia_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITMedia_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITMedia_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITMedia_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITMedia_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITMedia_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITMedia_get_MediaName(This,ppMediaName)	\
    (This)->lpVtbl -> get_MediaName(This,ppMediaName)

#define ITMedia_put_MediaName(This,pMediaName)	\
    (This)->lpVtbl -> put_MediaName(This,pMediaName)

#define ITMedia_get_StartPort(This,pStartPort)	\
    (This)->lpVtbl -> get_StartPort(This,pStartPort)

#define ITMedia_get_NumPorts(This,pNumPorts)	\
    (This)->lpVtbl -> get_NumPorts(This,pNumPorts)

#define ITMedia_get_TransportProtocol(This,ppProtocol)	\
    (This)->lpVtbl -> get_TransportProtocol(This,ppProtocol)

#define ITMedia_put_TransportProtocol(This,pProtocol)	\
    (This)->lpVtbl -> put_TransportProtocol(This,pProtocol)

#define ITMedia_get_FormatCodes(This,pVal)	\
    (This)->lpVtbl -> get_FormatCodes(This,pVal)

#define ITMedia_put_FormatCodes(This,NewVal)	\
    (This)->lpVtbl -> put_FormatCodes(This,NewVal)

#define ITMedia_get_MediaTitle(This,ppMediaTitle)	\
    (This)->lpVtbl -> get_MediaTitle(This,ppMediaTitle)

#define ITMedia_put_MediaTitle(This,pMediaTitle)	\
    (This)->lpVtbl -> put_MediaTitle(This,pMediaTitle)

#define ITMedia_SetPortInfo(This,StartPort,NumPorts)	\
    (This)->lpVtbl -> SetPortInfo(This,StartPort,NumPorts)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_MediaName_Proxy( 
    ITMedia * This,
    /* [retval][out] */ BSTR *ppMediaName);


void __RPC_STUB ITMedia_get_MediaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITMedia_put_MediaName_Proxy( 
    ITMedia * This,
    /* [in] */ BSTR pMediaName);


void __RPC_STUB ITMedia_put_MediaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_StartPort_Proxy( 
    ITMedia * This,
    /* [retval][out] */ LONG *pStartPort);


void __RPC_STUB ITMedia_get_StartPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_NumPorts_Proxy( 
    ITMedia * This,
    /* [retval][out] */ LONG *pNumPorts);


void __RPC_STUB ITMedia_get_NumPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_TransportProtocol_Proxy( 
    ITMedia * This,
    /* [retval][out] */ BSTR *ppProtocol);


void __RPC_STUB ITMedia_get_TransportProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITMedia_put_TransportProtocol_Proxy( 
    ITMedia * This,
    /* [in] */ BSTR pProtocol);


void __RPC_STUB ITMedia_put_TransportProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_FormatCodes_Proxy( 
    ITMedia * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ITMedia_get_FormatCodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITMedia_put_FormatCodes_Proxy( 
    ITMedia * This,
    /* [in] */ VARIANT NewVal);


void __RPC_STUB ITMedia_put_FormatCodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMedia_get_MediaTitle_Proxy( 
    ITMedia * This,
    /* [retval][out] */ BSTR *ppMediaTitle);


void __RPC_STUB ITMedia_get_MediaTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITMedia_put_MediaTitle_Proxy( 
    ITMedia * This,
    /* [in] */ BSTR pMediaTitle);


void __RPC_STUB ITMedia_put_MediaTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITMedia_SetPortInfo_Proxy( 
    ITMedia * This,
    /* [in] */ LONG StartPort,
    /* [in] */ LONG NumPorts);


void __RPC_STUB ITMedia_SetPortInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITMedia_INTERFACE_DEFINED__ */


#ifndef __IEnumMedia_INTERFACE_DEFINED__
#define __IEnumMedia_INTERFACE_DEFINED__

/* interface IEnumMedia */
/* [hidden][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumMedia;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA8397BE-2FA4-11D1-9774-00C04FD91AC0")
    IEnumMedia : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITMedia **pVal,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMedia **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMediaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMedia * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMedia * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMedia * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMedia * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITMedia **pVal,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMedia * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMedia * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMedia * This,
            /* [retval][out] */ IEnumMedia **ppEnum);
        
        END_INTERFACE
    } IEnumMediaVtbl;

    interface IEnumMedia
    {
        CONST_VTBL struct IEnumMediaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMedia_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMedia_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMedia_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMedia_Next(This,celt,pVal,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pVal,pceltFetched)

#define IEnumMedia_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMedia_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumMedia_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMedia_Next_Proxy( 
    IEnumMedia * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITMedia **pVal,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumMedia_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMedia_Reset_Proxy( 
    IEnumMedia * This);


void __RPC_STUB IEnumMedia_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMedia_Skip_Proxy( 
    IEnumMedia * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumMedia_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMedia_Clone_Proxy( 
    IEnumMedia * This,
    /* [retval][out] */ IEnumMedia **ppEnum);


void __RPC_STUB IEnumMedia_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMedia_INTERFACE_DEFINED__ */


#ifndef __ITMediaCollection_INTERFACE_DEFINED__
#define __ITMediaCollection_INTERFACE_DEFINED__

/* interface ITMediaCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMediaCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A8E16A2-0ABC-11D1-976D-00C04FD91AC0")
    ITMediaCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG Index,
            /* [retval][out] */ ITMedia **pVal) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_EnumerationIf( 
            /* [retval][out] */ IEnumMedia **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ LONG Index,
            /* [retval][out] */ ITMedia **ppMedia) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LONG Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMediaCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMediaCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMediaCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMediaCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMediaCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMediaCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMediaCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITMediaCollection * This,
            /* [retval][out] */ LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITMediaCollection * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ ITMedia **pVal);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITMediaCollection * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumerationIf )( 
            ITMediaCollection * This,
            /* [retval][out] */ IEnumMedia **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITMediaCollection * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ ITMedia **ppMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            ITMediaCollection * This,
            /* [in] */ LONG Index);
        
        END_INTERFACE
    } ITMediaCollectionVtbl;

    interface ITMediaCollection
    {
        CONST_VTBL struct ITMediaCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITMediaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITMediaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITMediaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITMediaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITMediaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITMediaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITMediaCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ITMediaCollection_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ITMediaCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define ITMediaCollection_get_EnumerationIf(This,pVal)	\
    (This)->lpVtbl -> get_EnumerationIf(This,pVal)

#define ITMediaCollection_Create(This,Index,ppMedia)	\
    (This)->lpVtbl -> Create(This,Index,ppMedia)

#define ITMediaCollection_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_get_Count_Proxy( 
    ITMediaCollection * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB ITMediaCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_get_Item_Proxy( 
    ITMediaCollection * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ ITMedia **pVal);


void __RPC_STUB ITMediaCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_get__NewEnum_Proxy( 
    ITMediaCollection * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB ITMediaCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_get_EnumerationIf_Proxy( 
    ITMediaCollection * This,
    /* [retval][out] */ IEnumMedia **pVal);


void __RPC_STUB ITMediaCollection_get_EnumerationIf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_Create_Proxy( 
    ITMediaCollection * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ ITMedia **ppMedia);


void __RPC_STUB ITMediaCollection_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITMediaCollection_Delete_Proxy( 
    ITMediaCollection * This,
    /* [in] */ LONG Index);


void __RPC_STUB ITMediaCollection_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITMediaCollection_INTERFACE_DEFINED__ */


#ifndef __ITTime_INTERFACE_DEFINED__
#define __ITTime_INTERFACE_DEFINED__

/* interface ITTime */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITTime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2652BB78-1516-11D1-9771-00C04FD91AC0")
    ITTime : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DOUBLE *pTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DOUBLE Time) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ DOUBLE *pTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ DOUBLE Time) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTime * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTime * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTime * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTime * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTime * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTime * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTime * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            ITTime * This,
            /* [retval][out] */ DOUBLE *pTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            ITTime * This,
            /* [in] */ DOUBLE Time);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            ITTime * This,
            /* [retval][out] */ DOUBLE *pTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            ITTime * This,
            /* [in] */ DOUBLE Time);
        
        END_INTERFACE
    } ITTimeVtbl;

    interface ITTime
    {
        CONST_VTBL struct ITTimeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTime_get_StartTime(This,pTime)	\
    (This)->lpVtbl -> get_StartTime(This,pTime)

#define ITTime_put_StartTime(This,Time)	\
    (This)->lpVtbl -> put_StartTime(This,Time)

#define ITTime_get_StopTime(This,pTime)	\
    (This)->lpVtbl -> get_StopTime(This,pTime)

#define ITTime_put_StopTime(This,Time)	\
    (This)->lpVtbl -> put_StopTime(This,Time)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTime_get_StartTime_Proxy( 
    ITTime * This,
    /* [retval][out] */ DOUBLE *pTime);


void __RPC_STUB ITTime_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITTime_put_StartTime_Proxy( 
    ITTime * This,
    /* [in] */ DOUBLE Time);


void __RPC_STUB ITTime_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTime_get_StopTime_Proxy( 
    ITTime * This,
    /* [retval][out] */ DOUBLE *pTime);


void __RPC_STUB ITTime_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITTime_put_StopTime_Proxy( 
    ITTime * This,
    /* [in] */ DOUBLE Time);


void __RPC_STUB ITTime_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTime_INTERFACE_DEFINED__ */


#ifndef __IEnumTime_INTERFACE_DEFINED__
#define __IEnumTime_INTERFACE_DEFINED__

/* interface IEnumTime */
/* [hidden][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumTime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9055322E-2FA8-11D1-9774-00C04FD91AC0")
    IEnumTime : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITTime **pVal,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumTime **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTime * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTime * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTime * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTime * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITTime **pVal,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTime * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTime * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTime * This,
            /* [retval][out] */ IEnumTime **ppEnum);
        
        END_INTERFACE
    } IEnumTimeVtbl;

    interface IEnumTime
    {
        CONST_VTBL struct IEnumTimeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTime_Next(This,celt,pVal,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pVal,pceltFetched)

#define IEnumTime_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTime_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTime_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTime_Next_Proxy( 
    IEnumTime * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITTime **pVal,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumTime_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTime_Reset_Proxy( 
    IEnumTime * This);


void __RPC_STUB IEnumTime_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTime_Skip_Proxy( 
    IEnumTime * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumTime_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTime_Clone_Proxy( 
    IEnumTime * This,
    /* [retval][out] */ IEnumTime **ppEnum);


void __RPC_STUB IEnumTime_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTime_INTERFACE_DEFINED__ */


#ifndef __ITTimeCollection_INTERFACE_DEFINED__
#define __ITTimeCollection_INTERFACE_DEFINED__

/* interface ITTimeCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITTimeCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CC1F04F-CAEB-11D0-8D58-00C04FD91AC0")
    ITTimeCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG Index,
            /* [retval][out] */ ITTime **pVal) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_EnumerationIf( 
            /* [retval][out] */ IEnumTime **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ LONG Index,
            /* [retval][out] */ ITTime **ppTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LONG Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTimeCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTimeCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTimeCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTimeCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTimeCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTimeCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTimeCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTimeCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITTimeCollection * This,
            /* [retval][out] */ LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITTimeCollection * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ ITTime **pVal);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITTimeCollection * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumerationIf )( 
            ITTimeCollection * This,
            /* [retval][out] */ IEnumTime **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            ITTimeCollection * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ ITTime **ppTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            ITTimeCollection * This,
            /* [in] */ LONG Index);
        
        END_INTERFACE
    } ITTimeCollectionVtbl;

    interface ITTimeCollection
    {
        CONST_VTBL struct ITTimeCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTimeCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTimeCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTimeCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTimeCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTimeCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTimeCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTimeCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTimeCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ITTimeCollection_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ITTimeCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define ITTimeCollection_get_EnumerationIf(This,pVal)	\
    (This)->lpVtbl -> get_EnumerationIf(This,pVal)

#define ITTimeCollection_Create(This,Index,ppTime)	\
    (This)->lpVtbl -> Create(This,Index,ppTime)

#define ITTimeCollection_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_get_Count_Proxy( 
    ITTimeCollection * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB ITTimeCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_get_Item_Proxy( 
    ITTimeCollection * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ ITTime **pVal);


void __RPC_STUB ITTimeCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_get__NewEnum_Proxy( 
    ITTimeCollection * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB ITTimeCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_get_EnumerationIf_Proxy( 
    ITTimeCollection * This,
    /* [retval][out] */ IEnumTime **pVal);


void __RPC_STUB ITTimeCollection_get_EnumerationIf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_Create_Proxy( 
    ITTimeCollection * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ ITTime **ppTime);


void __RPC_STUB ITTimeCollection_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTimeCollection_Delete_Proxy( 
    ITTimeCollection * This,
    /* [in] */ LONG Index);


void __RPC_STUB ITTimeCollection_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTimeCollection_INTERFACE_DEFINED__ */


#ifndef __ITSdp_INTERFACE_DEFINED__
#define __ITSdp_INTERFACE_DEFINED__

/* interface ITSdp */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITSdp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B2719D8-B696-11D0-A489-00C04FD91AC0")
    ITSdp : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pfIsValid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProtocolVersion( 
            /* [retval][out] */ unsigned char *pProtocolVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionId( 
            /* [retval][out] */ DOUBLE *pSessionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionVersion( 
            /* [retval][out] */ DOUBLE *pSessionVersion) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SessionVersion( 
            /* [in] */ DOUBLE SessionVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MachineAddress( 
            /* [retval][out] */ BSTR *ppMachineAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MachineAddress( 
            /* [in] */ BSTR pMachineAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR pDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ BSTR *ppUrl) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ BSTR pUrl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEmailNames( 
            /* [out] */ VARIANT *pAddresses,
            /* [out] */ VARIANT *pNames) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEmailNames( 
            /* [in] */ VARIANT Addresses,
            /* [in] */ VARIANT Names) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPhoneNumbers( 
            /* [out] */ VARIANT *pNumbers,
            /* [out] */ VARIANT *pNames) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPhoneNumbers( 
            /* [in] */ VARIANT Numbers,
            /* [in] */ VARIANT Names) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Originator( 
            /* [retval][out] */ BSTR *ppOriginator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Originator( 
            /* [in] */ BSTR pOriginator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaCollection( 
            /* [retval][out] */ ITMediaCollection **ppMediaCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeCollection( 
            /* [retval][out] */ ITTimeCollection **ppTimeCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITSdpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITSdp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITSdp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITSdp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITSdp * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITSdp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITSdp * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITSdp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            ITSdp * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsValid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProtocolVersion )( 
            ITSdp * This,
            /* [retval][out] */ unsigned char *pProtocolVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionId )( 
            ITSdp * This,
            /* [retval][out] */ DOUBLE *pSessionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionVersion )( 
            ITSdp * This,
            /* [retval][out] */ DOUBLE *pSessionVersion);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionVersion )( 
            ITSdp * This,
            /* [in] */ DOUBLE SessionVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MachineAddress )( 
            ITSdp * This,
            /* [retval][out] */ BSTR *ppMachineAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MachineAddress )( 
            ITSdp * This,
            /* [in] */ BSTR pMachineAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITSdp * This,
            /* [retval][out] */ BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            ITSdp * This,
            /* [in] */ BSTR pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            ITSdp * This,
            /* [retval][out] */ BSTR *ppDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            ITSdp * This,
            /* [in] */ BSTR pDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Url )( 
            ITSdp * This,
            /* [retval][out] */ BSTR *ppUrl);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            ITSdp * This,
            /* [in] */ BSTR pUrl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEmailNames )( 
            ITSdp * This,
            /* [out] */ VARIANT *pAddresses,
            /* [out] */ VARIANT *pNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEmailNames )( 
            ITSdp * This,
            /* [in] */ VARIANT Addresses,
            /* [in] */ VARIANT Names);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPhoneNumbers )( 
            ITSdp * This,
            /* [out] */ VARIANT *pNumbers,
            /* [out] */ VARIANT *pNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPhoneNumbers )( 
            ITSdp * This,
            /* [in] */ VARIANT Numbers,
            /* [in] */ VARIANT Names);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Originator )( 
            ITSdp * This,
            /* [retval][out] */ BSTR *ppOriginator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Originator )( 
            ITSdp * This,
            /* [in] */ BSTR pOriginator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaCollection )( 
            ITSdp * This,
            /* [retval][out] */ ITMediaCollection **ppMediaCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeCollection )( 
            ITSdp * This,
            /* [retval][out] */ ITTimeCollection **ppTimeCollection);
        
        END_INTERFACE
    } ITSdpVtbl;

    interface ITSdp
    {
        CONST_VTBL struct ITSdpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITSdp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITSdp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITSdp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITSdp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITSdp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITSdp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITSdp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITSdp_get_IsValid(This,pfIsValid)	\
    (This)->lpVtbl -> get_IsValid(This,pfIsValid)

#define ITSdp_get_ProtocolVersion(This,pProtocolVersion)	\
    (This)->lpVtbl -> get_ProtocolVersion(This,pProtocolVersion)

#define ITSdp_get_SessionId(This,pSessionId)	\
    (This)->lpVtbl -> get_SessionId(This,pSessionId)

#define ITSdp_get_SessionVersion(This,pSessionVersion)	\
    (This)->lpVtbl -> get_SessionVersion(This,pSessionVersion)

#define ITSdp_put_SessionVersion(This,SessionVersion)	\
    (This)->lpVtbl -> put_SessionVersion(This,SessionVersion)

#define ITSdp_get_MachineAddress(This,ppMachineAddress)	\
    (This)->lpVtbl -> get_MachineAddress(This,ppMachineAddress)

#define ITSdp_put_MachineAddress(This,pMachineAddress)	\
    (This)->lpVtbl -> put_MachineAddress(This,pMachineAddress)

#define ITSdp_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITSdp_put_Name(This,pName)	\
    (This)->lpVtbl -> put_Name(This,pName)

#define ITSdp_get_Description(This,ppDescription)	\
    (This)->lpVtbl -> get_Description(This,ppDescription)

#define ITSdp_put_Description(This,pDescription)	\
    (This)->lpVtbl -> put_Description(This,pDescription)

#define ITSdp_get_Url(This,ppUrl)	\
    (This)->lpVtbl -> get_Url(This,ppUrl)

#define ITSdp_put_Url(This,pUrl)	\
    (This)->lpVtbl -> put_Url(This,pUrl)

#define ITSdp_GetEmailNames(This,pAddresses,pNames)	\
    (This)->lpVtbl -> GetEmailNames(This,pAddresses,pNames)

#define ITSdp_SetEmailNames(This,Addresses,Names)	\
    (This)->lpVtbl -> SetEmailNames(This,Addresses,Names)

#define ITSdp_GetPhoneNumbers(This,pNumbers,pNames)	\
    (This)->lpVtbl -> GetPhoneNumbers(This,pNumbers,pNames)

#define ITSdp_SetPhoneNumbers(This,Numbers,Names)	\
    (This)->lpVtbl -> SetPhoneNumbers(This,Numbers,Names)

#define ITSdp_get_Originator(This,ppOriginator)	\
    (This)->lpVtbl -> get_Originator(This,ppOriginator)

#define ITSdp_put_Originator(This,pOriginator)	\
    (This)->lpVtbl -> put_Originator(This,pOriginator)

#define ITSdp_get_MediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_MediaCollection(This,ppMediaCollection)

#define ITSdp_get_TimeCollection(This,ppTimeCollection)	\
    (This)->lpVtbl -> get_TimeCollection(This,ppTimeCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_IsValid_Proxy( 
    ITSdp * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsValid);


void __RPC_STUB ITSdp_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_ProtocolVersion_Proxy( 
    ITSdp * This,
    /* [retval][out] */ unsigned char *pProtocolVersion);


void __RPC_STUB ITSdp_get_ProtocolVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_SessionId_Proxy( 
    ITSdp * This,
    /* [retval][out] */ DOUBLE *pSessionId);


void __RPC_STUB ITSdp_get_SessionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_SessionVersion_Proxy( 
    ITSdp * This,
    /* [retval][out] */ DOUBLE *pSessionVersion);


void __RPC_STUB ITSdp_get_SessionVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_SessionVersion_Proxy( 
    ITSdp * This,
    /* [in] */ DOUBLE SessionVersion);


void __RPC_STUB ITSdp_put_SessionVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_MachineAddress_Proxy( 
    ITSdp * This,
    /* [retval][out] */ BSTR *ppMachineAddress);


void __RPC_STUB ITSdp_get_MachineAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_MachineAddress_Proxy( 
    ITSdp * This,
    /* [in] */ BSTR pMachineAddress);


void __RPC_STUB ITSdp_put_MachineAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_Name_Proxy( 
    ITSdp * This,
    /* [retval][out] */ BSTR *ppName);


void __RPC_STUB ITSdp_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_Name_Proxy( 
    ITSdp * This,
    /* [in] */ BSTR pName);


void __RPC_STUB ITSdp_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_Description_Proxy( 
    ITSdp * This,
    /* [retval][out] */ BSTR *ppDescription);


void __RPC_STUB ITSdp_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_Description_Proxy( 
    ITSdp * This,
    /* [in] */ BSTR pDescription);


void __RPC_STUB ITSdp_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_Url_Proxy( 
    ITSdp * This,
    /* [retval][out] */ BSTR *ppUrl);


void __RPC_STUB ITSdp_get_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_Url_Proxy( 
    ITSdp * This,
    /* [in] */ BSTR pUrl);


void __RPC_STUB ITSdp_put_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSdp_GetEmailNames_Proxy( 
    ITSdp * This,
    /* [out] */ VARIANT *pAddresses,
    /* [out] */ VARIANT *pNames);


void __RPC_STUB ITSdp_GetEmailNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSdp_SetEmailNames_Proxy( 
    ITSdp * This,
    /* [in] */ VARIANT Addresses,
    /* [in] */ VARIANT Names);


void __RPC_STUB ITSdp_SetEmailNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSdp_GetPhoneNumbers_Proxy( 
    ITSdp * This,
    /* [out] */ VARIANT *pNumbers,
    /* [out] */ VARIANT *pNames);


void __RPC_STUB ITSdp_GetPhoneNumbers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSdp_SetPhoneNumbers_Proxy( 
    ITSdp * This,
    /* [in] */ VARIANT Numbers,
    /* [in] */ VARIANT Names);


void __RPC_STUB ITSdp_SetPhoneNumbers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_Originator_Proxy( 
    ITSdp * This,
    /* [retval][out] */ BSTR *ppOriginator);


void __RPC_STUB ITSdp_get_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITSdp_put_Originator_Proxy( 
    ITSdp * This,
    /* [in] */ BSTR pOriginator);


void __RPC_STUB ITSdp_put_Originator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_MediaCollection_Proxy( 
    ITSdp * This,
    /* [retval][out] */ ITMediaCollection **ppMediaCollection);


void __RPC_STUB ITSdp_get_MediaCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSdp_get_TimeCollection_Proxy( 
    ITSdp * This,
    /* [retval][out] */ ITTimeCollection **ppTimeCollection);


void __RPC_STUB ITSdp_get_TimeCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITSdp_INTERFACE_DEFINED__ */


#ifndef __ITConnection_INTERFACE_DEFINED__
#define __ITConnection_INTERFACE_DEFINED__

/* interface ITConnection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8fa381d4-c8c2-11d0-8d58-00c04fd91ac0")
    ITConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkType( 
            /* [retval][out] */ BSTR *ppNetworkType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NetworkType( 
            /* [in] */ BSTR pNetworkType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressType( 
            /* [retval][out] */ BSTR *ppAddressType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AddressType( 
            /* [in] */ BSTR pAddressType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartAddress( 
            /* [retval][out] */ BSTR *ppStartAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumAddresses( 
            /* [retval][out] */ LONG *pNumAddresses) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Ttl( 
            /* [retval][out] */ unsigned char *pTtl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BandwidthModifier( 
            /* [retval][out] */ BSTR *ppModifier) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ DOUBLE *pBandwidth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAddressInfo( 
            /* [in] */ BSTR pStartAddress,
            /* [in] */ LONG NumAddresses,
            /* [in] */ unsigned char Ttl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetBandwidthInfo( 
            /* [in] */ BSTR pModifier,
            /* [in] */ DOUBLE Bandwidth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEncryptionKey( 
            /* [in] */ BSTR pKeyType,
            /* [in] */ BSTR *ppKeyData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEncryptionKey( 
            /* [out] */ BSTR *ppKeyType,
            /* [out] */ VARIANT_BOOL *pfValidKeyData,
            /* [out] */ BSTR *ppKeyData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITConnection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITConnection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITConnection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITConnection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkType )( 
            ITConnection * This,
            /* [retval][out] */ BSTR *ppNetworkType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkType )( 
            ITConnection * This,
            /* [in] */ BSTR pNetworkType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressType )( 
            ITConnection * This,
            /* [retval][out] */ BSTR *ppAddressType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AddressType )( 
            ITConnection * This,
            /* [in] */ BSTR pAddressType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartAddress )( 
            ITConnection * This,
            /* [retval][out] */ BSTR *ppStartAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumAddresses )( 
            ITConnection * This,
            /* [retval][out] */ LONG *pNumAddresses);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Ttl )( 
            ITConnection * This,
            /* [retval][out] */ unsigned char *pTtl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BandwidthModifier )( 
            ITConnection * This,
            /* [retval][out] */ BSTR *ppModifier);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            ITConnection * This,
            /* [retval][out] */ DOUBLE *pBandwidth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAddressInfo )( 
            ITConnection * This,
            /* [in] */ BSTR pStartAddress,
            /* [in] */ LONG NumAddresses,
            /* [in] */ unsigned char Ttl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetBandwidthInfo )( 
            ITConnection * This,
            /* [in] */ BSTR pModifier,
            /* [in] */ DOUBLE Bandwidth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEncryptionKey )( 
            ITConnection * This,
            /* [in] */ BSTR pKeyType,
            /* [in] */ BSTR *ppKeyData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEncryptionKey )( 
            ITConnection * This,
            /* [out] */ BSTR *ppKeyType,
            /* [out] */ VARIANT_BOOL *pfValidKeyData,
            /* [out] */ BSTR *ppKeyData);
        
        END_INTERFACE
    } ITConnectionVtbl;

    interface ITConnection
    {
        CONST_VTBL struct ITConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITConnection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITConnection_get_NetworkType(This,ppNetworkType)	\
    (This)->lpVtbl -> get_NetworkType(This,ppNetworkType)

#define ITConnection_put_NetworkType(This,pNetworkType)	\
    (This)->lpVtbl -> put_NetworkType(This,pNetworkType)

#define ITConnection_get_AddressType(This,ppAddressType)	\
    (This)->lpVtbl -> get_AddressType(This,ppAddressType)

#define ITConnection_put_AddressType(This,pAddressType)	\
    (This)->lpVtbl -> put_AddressType(This,pAddressType)

#define ITConnection_get_StartAddress(This,ppStartAddress)	\
    (This)->lpVtbl -> get_StartAddress(This,ppStartAddress)

#define ITConnection_get_NumAddresses(This,pNumAddresses)	\
    (This)->lpVtbl -> get_NumAddresses(This,pNumAddresses)

#define ITConnection_get_Ttl(This,pTtl)	\
    (This)->lpVtbl -> get_Ttl(This,pTtl)

#define ITConnection_get_BandwidthModifier(This,ppModifier)	\
    (This)->lpVtbl -> get_BandwidthModifier(This,ppModifier)

#define ITConnection_get_Bandwidth(This,pBandwidth)	\
    (This)->lpVtbl -> get_Bandwidth(This,pBandwidth)

#define ITConnection_SetAddressInfo(This,pStartAddress,NumAddresses,Ttl)	\
    (This)->lpVtbl -> SetAddressInfo(This,pStartAddress,NumAddresses,Ttl)

#define ITConnection_SetBandwidthInfo(This,pModifier,Bandwidth)	\
    (This)->lpVtbl -> SetBandwidthInfo(This,pModifier,Bandwidth)

#define ITConnection_SetEncryptionKey(This,pKeyType,ppKeyData)	\
    (This)->lpVtbl -> SetEncryptionKey(This,pKeyType,ppKeyData)

#define ITConnection_GetEncryptionKey(This,ppKeyType,pfValidKeyData,ppKeyData)	\
    (This)->lpVtbl -> GetEncryptionKey(This,ppKeyType,pfValidKeyData,ppKeyData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_NetworkType_Proxy( 
    ITConnection * This,
    /* [retval][out] */ BSTR *ppNetworkType);


void __RPC_STUB ITConnection_get_NetworkType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITConnection_put_NetworkType_Proxy( 
    ITConnection * This,
    /* [in] */ BSTR pNetworkType);


void __RPC_STUB ITConnection_put_NetworkType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_AddressType_Proxy( 
    ITConnection * This,
    /* [retval][out] */ BSTR *ppAddressType);


void __RPC_STUB ITConnection_get_AddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITConnection_put_AddressType_Proxy( 
    ITConnection * This,
    /* [in] */ BSTR pAddressType);


void __RPC_STUB ITConnection_put_AddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_StartAddress_Proxy( 
    ITConnection * This,
    /* [retval][out] */ BSTR *ppStartAddress);


void __RPC_STUB ITConnection_get_StartAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_NumAddresses_Proxy( 
    ITConnection * This,
    /* [retval][out] */ LONG *pNumAddresses);


void __RPC_STUB ITConnection_get_NumAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_Ttl_Proxy( 
    ITConnection * This,
    /* [retval][out] */ unsigned char *pTtl);


void __RPC_STUB ITConnection_get_Ttl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_BandwidthModifier_Proxy( 
    ITConnection * This,
    /* [retval][out] */ BSTR *ppModifier);


void __RPC_STUB ITConnection_get_BandwidthModifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITConnection_get_Bandwidth_Proxy( 
    ITConnection * This,
    /* [retval][out] */ DOUBLE *pBandwidth);


void __RPC_STUB ITConnection_get_Bandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConnection_SetAddressInfo_Proxy( 
    ITConnection * This,
    /* [in] */ BSTR pStartAddress,
    /* [in] */ LONG NumAddresses,
    /* [in] */ unsigned char Ttl);


void __RPC_STUB ITConnection_SetAddressInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConnection_SetBandwidthInfo_Proxy( 
    ITConnection * This,
    /* [in] */ BSTR pModifier,
    /* [in] */ DOUBLE Bandwidth);


void __RPC_STUB ITConnection_SetBandwidthInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConnection_SetEncryptionKey_Proxy( 
    ITConnection * This,
    /* [in] */ BSTR pKeyType,
    /* [in] */ BSTR *ppKeyData);


void __RPC_STUB ITConnection_SetEncryptionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITConnection_GetEncryptionKey_Proxy( 
    ITConnection * This,
    /* [out] */ BSTR *ppKeyType,
    /* [out] */ VARIANT_BOOL *pfValidKeyData,
    /* [out] */ BSTR *ppKeyData);


void __RPC_STUB ITConnection_GetEncryptionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITConnection_INTERFACE_DEFINED__ */


#ifndef __ITAttributeList_INTERFACE_DEFINED__
#define __ITAttributeList_INTERFACE_DEFINED__

/* interface ITAttributeList */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITAttributeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5037fb82-cae9-11d0-8d58-00c04fd91ac0")
    ITAttributeList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG Index,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ LONG Index,
            /* [in] */ BSTR pAttribute) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttributeList( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttributeList( 
            /* [in] */ VARIANT newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAttributeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAttributeList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAttributeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAttributeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAttributeList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAttributeList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAttributeList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAttributeList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITAttributeList * This,
            /* [retval][out] */ LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITAttributeList * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ITAttributeList * This,
            /* [in] */ LONG Index,
            /* [in] */ BSTR pAttribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            ITAttributeList * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttributeList )( 
            ITAttributeList * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttributeList )( 
            ITAttributeList * This,
            /* [in] */ VARIANT newVal);
        
        END_INTERFACE
    } ITAttributeListVtbl;

    interface ITAttributeList
    {
        CONST_VTBL struct ITAttributeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAttributeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAttributeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAttributeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAttributeList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAttributeList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAttributeList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAttributeList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAttributeList_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ITAttributeList_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ITAttributeList_Add(This,Index,pAttribute)	\
    (This)->lpVtbl -> Add(This,Index,pAttribute)

#define ITAttributeList_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)

#define ITAttributeList_get_AttributeList(This,pVal)	\
    (This)->lpVtbl -> get_AttributeList(This,pVal)

#define ITAttributeList_put_AttributeList(This,newVal)	\
    (This)->lpVtbl -> put_AttributeList(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAttributeList_get_Count_Proxy( 
    ITAttributeList * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB ITAttributeList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAttributeList_get_Item_Proxy( 
    ITAttributeList * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ITAttributeList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAttributeList_Add_Proxy( 
    ITAttributeList * This,
    /* [in] */ LONG Index,
    /* [in] */ BSTR pAttribute);


void __RPC_STUB ITAttributeList_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAttributeList_Delete_Proxy( 
    ITAttributeList * This,
    /* [in] */ LONG Index);


void __RPC_STUB ITAttributeList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAttributeList_get_AttributeList_Proxy( 
    ITAttributeList * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ITAttributeList_get_AttributeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAttributeList_put_AttributeList_Proxy( 
    ITAttributeList * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB ITAttributeList_put_AttributeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAttributeList_INTERFACE_DEFINED__ */



#ifndef __SDPBLBLib_LIBRARY_DEFINED__
#define __SDPBLBLib_LIBRARY_DEFINED__

/* library SDPBLBLib */
/* [helpstring][version][uuid] */ 






EXTERN_C const IID LIBID_SDPBLBLib;

EXTERN_C const CLSID CLSID_SdpConferenceBlob;

#ifdef __cplusplus

class DECLSPEC_UUID("9B2719DD-B696-11D0-A489-00C04FD91AC0")
SdpConferenceBlob;
#endif
#endif /* __SDPBLBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\seclink.h ===
/* Copyright Data Connection Ltd. 1989 */
/*****************************************************************************/
/* Link Device Driver interface constants and structures.                    */
/*****************************************************************************/
/*****************************************************************************/
/* WIN32  16/04/92  SW   Added more helpful names from WIN32 hdr file        */
/* IHV    03/06/92  MF2  Add semfisui.h                                      */
/* CDDD1  06/04/93  CD   Change TxFrame DevIoctl code                        */
/* STAT1  21/01/94  CD   Fix what we do with stats (& general cleanup)       */
/* MODEM  06/04/95  AB   Add support for the modem status program            */
/*****************************************************************************/

/*****************************************************************************/
/* This include file is used in 3 components                                 */
/*                                                                           */
/* - the NT   driver                         LINK_NTDRIVER                   */
/* - the X25  link service for NT            LINK_NTX25                      */
/* - the SDLC link service for NT            LINK_NTSDLC                     */
/*                                                                           */
/* These are distinguished based on #defines as set in the following         */
/*                                                                           */
/*****************************************************************************/

#ifdef        IMADRIVER
  #define     LINK_NTDRIVER
#else
  #ifdef      SDLC
    #define LINK_NTSDLC
  #else
    #define LINK_NTX25
  #endif
#endif


/*****************************************************************************/
/* Device function codes for DosDevIOCtl to link device driver               */
/*****************************************************************************/
#define IoctlCodeSetEvent               0x410
#define IoctlCodeSetLinkChar            0x420
#define IoctlCodeSetV24                 0x430
#define IoctlCodeTxFrame                0x441   /* Main Tx so 1         CDDD1*/
#define IoctlCodeAbortTransmit          0x450
#define IoctlCodeAbortReceiver          0x460
#define IoctlCodeSetInterfaceRecord     0x610   /* Retired                   */
#define IoctlCodeGetV24                 0x623   /* No data buffer so 3       */
#define IoctlCodeRxFrame                0x632   /* Main Rx so 2              */
#define IoctlCodeReadInterfaceRecord    0x642

/*****************************************************************************/
/* Constants for the driver-specific IOCtl return codes.                     */
/*****************************************************************************/
#define CEDNODMA 0xff80     /* Warning (NO DMA!) from set link chrctrstcs    */

/*****************************************************************************/
/* Equates for the link options byte 1.                                      */
/*****************************************************************************/
#define CEL4WIRE 0x80
#define CELNRZI  0x40
#define CELPDPLX 0x20
#define CELSDPLX 0x10
#define CELCLOCK 0x08
#define CELDSRS  0x04
#define CELSTNBY 0x02
#define CELDMA   0x01

/*****************************************************************************/
/* Equates for the driver set link characteristics byte 1.                   */
/*****************************************************************************/
#define CED4WIRE 0x80
#define CEDNRZI  0x40
#define CEDHDLC  0x20
#define CEDFDPLX 0x10
#define CEDCLOCK 0x08
#define CEDDMA   0x04
#define CEDRSTAT 0x02
#define CEDCSTAT 0x01

/* Nicer names for NT-style code */

#define LinkOption_4Wire           CED4WIRE
#define LinkOption_NRZI            CEDNRZI
#define LinkOption_HDLC            CEDHDLC
#define LinkOption_FullDuplex      CEDFDPLX
#define LinkOption_InternalClock   CEDCLOCK
#define LinkOption_DMA             CEDDMA
#define LinkOption_ResetStatistics CEDRSTAT


/*****************************************************************************/
/* Equates for the ouput V24 interface flags.                                */
/*****************************************************************************/
#define CED24RTS 0x01
#define CED24DTR 0x02
#define CED24DRS 0x04
#define CED24SLS 0x08
#define CED24TST 0x10

/* Nicer names for NT-style code */

#define IR_OV24RTS  CED24RTS
#define IR_OV24DTR  CED24DTR
#define IR_OV24DSRS CED24DRS
#define IR_OV24SlSt CED24SLS
#define IR_OV24Test CED24TST


/*****************************************************************************/
/* Equates for the input V24 interface flags.                                */
/*****************************************************************************/
#define CED24CTS 0x01
#define CED24DSR 0x02
#define CED24DCD 0x04
#define CED24RI  0x08

/* Nicer names for NT-style code */

#define IR_IV24CTS  CED24CTS
#define IR_IV24DSR  CED24DSR
#define IR_IV24DCD  CED24DCD
#define IR_IV24RI   CED24RI
#define IR_IV24Test 0x10


/*****************************************************************************/
/* Structure for the device driver interface record.                         */
/*****************************************************************************/

#define CEDSTCRC  0         /* Frames received with incorrect CRC            */
#define CEDSTOFL  1         /* Frames received longer than the maximum       */
#define CEDSTUFL  2         /* Frames received less than 4 octets long       */
#define CEDSTSPR  3         /* Frames received ending on a non-octet bndry   */
#define CEDSTABT  4         /* Aborted frames received                       */
#define CEDSTTXU  5         /* Transmitter interrupt underruns               */
#define CEDSTRXO  6         /* Receiver    interrupt overruns                */
#define CEDSTDCD  7         /* DCD (RLSD) lost during frame reception        */
#define CEDSTCTS  8         /* CTS lost while transmitting                   */
#define CEDSTDSR  9         /* DSR drops                                     */
#define CEDSTHDW 10         /* Hardware failures - adapter errors            */

#define CEDSTMAX 11

#define SA_CRC_Error       CEDSTCRC
#define SA_RxFrameTooBig   CEDSTOFL
#define SA_RxFrameTooShort CEDSTUFL
#define SA_Spare           CEDSTSPR
#define SA_RxAbort         CEDSTABT
#define SA_TxUnderrun      CEDSTTXU
#define SA_RxOverrun       CEDSTRXO
#define SA_DCDDrop         CEDSTDCD
#define SA_CTSDrop         CEDSTCTS
#define SA_DSRDrop         CEDSTDSR
#define SA_HardwareError   CEDSTHDW  /* e.g. CmdBufferFull not set  */

#define SA_Max_Stat        CEDSTMAX


typedef struct         _INTERFACE_RECORD
{
  /***************************************************************************/
  /* Note: we are here trying to mirror the OS/2 layout, complete with       */
  /*       lengths.  However, due to the (justifiable) pickiness of the 32-  */
  /*       bit compiler, all shorts have been changed to 'int's - that way   */
  /*       the results of calculations can be assigned to them without a lot */
  /*       of shenanigans (or typecasting).                                  */
  /***************************************************************************/
  int                   RxFrameCount;   /* incremented after each frame rx'd */
  int                   TxMaxFrSizeNow; /* max available frame size av. now  */
                                        /* (changes after each Tx DevIoctl   */
                                        /* to DD or after Tx completed)      */
  int                   StatusCount;    /* How many status events have been  */
                                        /* triggered.                        */
  UCHAR                 V24In;          /* Last 'getv24i/f' value got        */
  UCHAR                 V24Out;         /* Last 'setv24 outputs' value set   */

/*       The values for the indices into the link statistics array of the    */
/*       various types of statistic.                                         */
  int                   StatusArray[SA_Max_Stat];

}                       IR,
                     * PIR;

/*****************************************************************************/
/* New structure used by the link to acumulate stats                   *STAT1*/
/*****************************************************************************/
typedef struct _STATS
{
  int                   StatusCount;
  int                   StatusArray[SA_Max_Stat];
} STATS;


/*****************************************************************************/
/* Structure for the set link characteristics parameter block.               */
/*****************************************************************************/

typedef struct  _SLPARMS
{
        int     SLFrameSize;            /* max frame size on link - must be  */
                                         /* in range 270 to ?2K-ish          */
        LONG    SLDataRate;             /* not used by us - external clocks  */
        UCHAR   SLOurAddress1;          /* ) e.g C1/FF or 00/00 or 01/03     */
        UCHAR   SLOurAddress2;          /* )                                 */
        UCHAR   SLLinkOptionsByte;      /* see documentation & LinkOption_*  */
        UCHAR   SLSpare1;
}
                SLPARMS;

#ifndef IMADRIVER
/*****************************************************************************/
/* DEVICEIOCTL macros                                                        */
/*****************************************************************************/
/* NT_SUCCESS ripped of from DDK's ntdef.h, which we do not want to include  */
/* for now temporarily (12/5/92)                                             */

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define SETEVENTHANDLE(H)                                                    \
           NtDeviceIoControlFile(seldrvrh,H,NULL,NULL,&IoStatus,             \
                                   IoctlCodeSetEvent,NULL,0L,NULL,0L)

#define SETINTERFACERECORD(R)                                                \
           NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,          \
                                   IoctlCodeSetInterfaceRecord,&R,sizeof(R), \
                                   NULL,0L)

#define SETV24STATUS                                                         \
           NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,          \
                                   IoctlCodeSetV24,NULL,0L,                  \
                                   &pInterfaceRecord->V24Out,1L);            \
                                                                             \
         if (SavedIROut != (pInterfaceRecord->V24Out & 0x03))                \
         {                                                                   \
           SavedIROut = (pInterfaceRecord->V24Out & 0x03);                   \
           pModemStatus->V24Out = pInterfaceRecord->V24Out;                  \
         }

#define GETV24STATUS(rc)                                                     \
         rc |= NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,      \
                                   IoctlCodeGetV24,NULL,0L,NULL,0L);         \
         rc |= READINTERFACERECORD;                                          \
         if (SavedIRIn != (InterfaceRecord.V24In & 0x0F))                    \
         {                                                                   \
           SavedIRIn = (InterfaceRecord.V24In & 0x0F);                       \
           pModemStatus->V24In = InterfaceRecord.V24In;                      \
         }


/*****************************************************************************/
/* Check for reset stats request and reset if required                 *STAT1*/
/*****************************************************************************/
#define SETLINKCHARACTERISTICS(A,rc)                                         \
           rc = NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,     \
                                  IoctlCodeSetLinkChar,&A,sizeof(A),NULL,0L);\
           if (A.SLLinkOptionsByte & CEDRSTAT)                               \
           {                                                                 \
             memset(&Stats,0,sizeof(STATS));                                 \
           }

/*****************************************************************************/
/* Note we now pass the user buffer in the input fields, not the output      */
/* fields                                                               CDDD1*/
/*****************************************************************************/
#define TRANSMITFRAME(A,B)                                                   \
           NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,          \
                                   IoctlCodeTxFrame,A,B,NULL,0L);


#define RECEIVEFRAME(A,B)                                                    \
           NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,          \
                                   IoctlCodeRxFrame,NULL,0L,A,B);

/*****************************************************************************/
/* Due to a problem sharing a structure between the driver and link we're    */
/* going to get the driver to reset it's stats after every call to read the  */
/* interface record, and get the link to accumulate the stats          *STAT1*/
/*****************************************************************************/
#define READINTERFACERECORD                                                  \
           NtDeviceIoControlFile(seldrvrh,NULL,NULL,NULL,&IoStatus,          \
                                   IoctlCodeReadInterfaceRecord,NULL,0L,     \
                                   &InterfaceRecord,sizeof(InterfaceRecord));\
           if (!rc)                                                          \
           {                                                                 \
             int i;                                                          \
             Stats.StatusCount += InterfaceRecord.StatusCount;               \
             for (i=0;i<SA_Max_Stat;i++)                                     \
             {                                                               \
               Stats.StatusArray[i] += InterfaceRecord.StatusArray[i];       \
             }                                                               \
           }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sdperr.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdperr.h

Abstract:
    sdp error codes

Author:

*/

#ifndef __SDP_ERROR_CODES__
#define __SDP_ERROR_CODES__





// First four bits - SEVERITY(11), CUSTOMER FLAG(1), RESERVED(0)
#define SDP_INVALID_FORMAT                  0xe0000400

#define SDP_INVALID_CHARACTER_SET_FORMAT    (SDP_INVALID_FORMAT + 1)

#define SDP_INVALID_CHARACTER_SET           (SDP_INVALID_FORMAT + 2)

#define SDP_INVALID_NUMERICAL_VALUE         (SDP_INVALID_FORMAT + 3)

#define SDP_INVALID_VERSION_FIELD           (SDP_INVALID_FORMAT + 4)

#define SDP_INVALID_ORIGIN_FIELD            (SDP_INVALID_FORMAT + 5)

#define SDP_INVALID_SESSION_NAME            (SDP_INVALID_FORMAT + 6)

#define SDP_INVALID_SESSION_TITLE           (SDP_INVALID_FORMAT + 7)

#define SDP_INVALID_URI                     (SDP_INVALID_FORMAT + 8)

#define SDP_INVALID_EMAIL_FIELD             (SDP_INVALID_FORMAT + 9)

#define SDP_INVALID_PHONE_FIELD             (SDP_INVALID_FORMAT + 10)

#define SDP_INVALID_CONNECTION_FIELD        (SDP_INVALID_FORMAT + 11)

#define SDP_INVALID_BANDWIDTH_FIELD         (SDP_INVALID_FORMAT + 12)

#define SDP_INVALID_ADDRESS                 (SDP_INVALID_FORMAT + 13)

#define SDP_INVALID_TIME_PERIOD             (SDP_INVALID_FORMAT + 14)

#define SDP_INVALID_TIME_FIELD              (SDP_INVALID_FORMAT + 15)

#define SDP_INVALID_REPEAT_FIELD            (SDP_INVALID_FORMAT + 16)

#define SDP_INVALID_ADJUSTMENT_FIELD        (SDP_INVALID_FORMAT + 17)

#define SDP_INVALID_ENCRYPTION_KEY_FIELD    (SDP_INVALID_FORMAT + 18)

#define SDP_INVALID_ATTRIBUTE               (SDP_INVALID_FORMAT + 19)

#define SDP_INVALID_MEDIA_FIELD             (SDP_INVALID_FORMAT + 20)

#define SDP_INVALID_MEDIA_NAME              (SDP_INVALID_FORMAT + 21)

#define SDP_INVALID_MEDIA_TITLE             (SDP_INVALID_FORMAT + 22)

#define SDP_INTERNAL_ERROR                  (SDP_INVALID_FORMAT + 23)

#define UNABLE_TO_FREE_BSTR                 (SDP_INVALID_FORMAT + 24)

#define SDP_ALREADY_PARSED                  (SDP_INVALID_FORMAT + 25)

#define SDP_INVALID_PARAMETER               (SDP_INVALID_FORMAT + 26)

#define SDP_INVALID_VALUE                   (SDP_INVALID_FORMAT + 27)

#define SDP_OUTPUT_ERROR                    (SDP_INVALID_FORMAT + 28)


#endif // __SDP_ERROR_CODES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\session.h ===
#if !defined(SESSION_H)
#define SESSION_H

/*
================================================================================
    ========================================================================
    ========================================================================

    File:           csession.h
    Description:    
    Created:        9/3/1997
    Author:         Matthijs Gates
    Mail:           mgates@microsoft.com

    Copyright (C) 1997  Microsoft Corporation.  All Rights Reserved.

    ========================================================================
    ========================================================================
================================================================================
*/

#include "brtest.h"
#include "util.h"

//==============================================================================
//
//  Class:  CSession
//
//------------------------------------------------------------------------------
//  Description:        abstract root class for Sessions (Tunnels, Multicasts, 
//                      etc...); provides a set of primitive methods that
//                      sessions must implement
//
//  Public methods:
//                      Send()      send a CData object over the session
//
//  Public properties:
//                      - none -
//
//  9/3/1997
//  mgates
//
//==============================================================================
class CSession
{
    WSADATA m_wsaData ;
    
    enum { WINSOCK_MAJOR_VER = 2, WINSOCK_MINOR_VER = 0 } ;
    
    // P U B L I C

    public :
    
        CSession() ;
        virtual ~CSession() ;
    
        virtual INT Send(CData &data) = 0 ;

    // P R O T E C T E D

    protected :

} ;

//==============================================================================
//
//  Class:  CMulticast
//
//------------------------------------------------------------------------------
//  Description:
//
//  Public methods:
//
//  Public properties:
//
//  9/14/1997
//  mgates@microsoft.com
//
//==============================================================================
class CMulticast : public CSession
{
    CString     m_strIP ;
    CString     m_strNIC ;
    USHORT      m_usPort ;
    SOCKET      m_socket ;
    SOCKADDR_IN m_destinationAddr ;
    SOCKADDR_IN m_thisAddr ;
    USHORT      m_usTTL ;
    
    enum { DEF_TTL = 10 
         } ;
    
    // P U B L I C -------------------------------------------------------------

    public :
    
        CMulticast() ;
        virtual ~CMulticast() ;
        
        BOOL SetIP(CString &strIP) ;
        BOOL SetIP(char *szIP) ;
        
        BOOL SetPort(USHORT usPort)     { m_usPort = usPort ; return TRUE ; }
        
        BOOL SetNIC(CString &strNIC) ;
        BOOL SetNIC(char *szNIC) ;
        
        BOOL SetTTL(USHORT usTTL) { m_usTTL = usTTL ; return TRUE ; }
        USHORT GetTTL() { return m_usTTL ; }
        
        BOOL Create() ;
        INT  Send(CData &data) ;
        
        CString &GetIP()    { return m_strIP ; }
        USHORT      GetPort()   { return m_usPort ; }
        CString &GetNIC()   { return m_strNIC ; }
} ;

#endif  // SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Sens.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    sens.h

Abstract:

    This file is the master header file for Event System events published
    and subscribed by the System Event Notification service (SENS).

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/8/1997         Start.

--*/


#ifndef __SENS_H__
#define __SENS_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Constants
//

#define CONNECTION_LAN   0x00000001
#define CONNECTION_WAN   0x00000002
#define CONNECTION_AOL   0x00000004




//
// SENS Guids related to Event System
//


DEFINE_GUID(
    SENSGUID_PUBLISHER,             /* 5fee1bd6-5b9b-11d1-8dd2-00aa004abd5e */
    0x5fee1bd6,
    0x5b9b,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_LCE,        /* d3938ab0-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab0,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_WININET,    /* d3938ab5-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab5,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);





//
// Classes of Events published by SENS
//

DEFINE_GUID(
    SENSGUID_EVENTCLASS_NETWORK,        /* d5978620-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978620,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON,          /* d5978630-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978630,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_ONNOW,          /* d5978640-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978640,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON2,         /* d5978650-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978650,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);


#endif // __SENS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\setupdd.h ===
// setupdd.h - Public definitions for users of SETUPDD.DLL
//
//

#ifndef _SETUPDD_H_
#define _SETUPDD_H_

// NMInstallNTDisplayDriver
//
// The public entry point of SETUPDD.DLL.  Installs the NetMeeting display
// driver for Windows NT. 
// 
// Parameters:
//	HWND - Handle of the parent window used by the setup engine when 
//		displaying dialogs).
//
// Returns:
//	TRUE if the driver was successfully installed.  In this event,
//		the caller should prompt the user to restart the system for
//		the changes to take effect.
//  FALSE if this version of the OS does not support this driver
//		(NT 4.0 SP 3 or later, or NT 4.x, x > 0, is required) or if
//		an error occurs during installation.
//
// Limitations:
//	NetMeeting must already be installed on the system for this function
//		to work.
//	This function does not detect if the display driver is already
//		installed and enabled.

BOOL DECLSPEC_IMPORT WINAPI NMInstallNTDisplayDriver(HWND hWnd);

#endif // _SETUPDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SensEvts.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for sensevts.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __sensevts_h__
#define __sensevts_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISensNetwork_FWD_DEFINED__
#define __ISensNetwork_FWD_DEFINED__
typedef interface ISensNetwork ISensNetwork;
#endif 	/* __ISensNetwork_FWD_DEFINED__ */


#ifndef __ISensOnNow_FWD_DEFINED__
#define __ISensOnNow_FWD_DEFINED__
typedef interface ISensOnNow ISensOnNow;
#endif 	/* __ISensOnNow_FWD_DEFINED__ */


#ifndef __ISensLogon_FWD_DEFINED__
#define __ISensLogon_FWD_DEFINED__
typedef interface ISensLogon ISensLogon;
#endif 	/* __ISensLogon_FWD_DEFINED__ */


#ifndef __ISensLogon2_FWD_DEFINED__
#define __ISensLogon2_FWD_DEFINED__
typedef interface ISensLogon2 ISensLogon2;
#endif 	/* __ISensLogon2_FWD_DEFINED__ */


#ifndef __SENS_FWD_DEFINED__
#define __SENS_FWD_DEFINED__

#ifdef __cplusplus
typedef class SENS SENS;
#else
typedef struct SENS SENS;
#endif /* __cplusplus */

#endif 	/* __SENS_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __SensEvents_LIBRARY_DEFINED__
#define __SensEvents_LIBRARY_DEFINED__

/* library SensEvents */
/* [helpstring][version][uuid] */ 

typedef /* [uuid] */  DECLSPEC_UUID("d597fad1-5b9f-11d1-8dd2-00aa004abd5e") struct SENS_QOCINFO
    {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwOutSpeed;
    DWORD dwInSpeed;
    } 	SENS_QOCINFO;

typedef SENS_QOCINFO *LPSENS_QOCINFO;


EXTERN_C const IID LIBID_SensEvents;

#ifndef __ISensNetwork_INTERFACE_DEFINED__
#define __ISensNetwork_INTERFACE_DEFINED__

/* interface ISensNetwork */
/* [dual][helpstring][version][uuid][object] */ 


EXTERN_C const IID IID_ISensNetwork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d597bab1-5b9f-11d1-8dd2-00aa004abd5e")
    ISensNetwork : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectionMade( 
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType,
            /* [in] */ LPSENS_QOCINFO lpQOCInfo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectionMadeNoQOCInfo( 
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectionLost( 
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DestinationReachable( 
            /* [in] */ BSTR bstrDestination,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType,
            /* [in] */ LPSENS_QOCINFO lpQOCInfo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DestinationReachableNoQOCInfo( 
            /* [in] */ BSTR bstrDestination,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISensNetworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISensNetwork * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISensNetwork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISensNetwork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISensNetwork * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISensNetwork * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISensNetwork * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISensNetwork * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ConnectionMade )( 
            ISensNetwork * This,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType,
            /* [in] */ LPSENS_QOCINFO lpQOCInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ConnectionMadeNoQOCInfo )( 
            ISensNetwork * This,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ConnectionLost )( 
            ISensNetwork * This,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *DestinationReachable )( 
            ISensNetwork * This,
            /* [in] */ BSTR bstrDestination,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType,
            /* [in] */ LPSENS_QOCINFO lpQOCInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *DestinationReachableNoQOCInfo )( 
            ISensNetwork * This,
            /* [in] */ BSTR bstrDestination,
            /* [in] */ BSTR bstrConnection,
            /* [in] */ ULONG ulType);
        
        END_INTERFACE
    } ISensNetworkVtbl;

    interface ISensNetwork
    {
        CONST_VTBL struct ISensNetworkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISensNetwork_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISensNetwork_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISensNetwork_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISensNetwork_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISensNetwork_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISensNetwork_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISensNetwork_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISensNetwork_ConnectionMade(This,bstrConnection,ulType,lpQOCInfo)	\
    (This)->lpVtbl -> ConnectionMade(This,bstrConnection,ulType,lpQOCInfo)

#define ISensNetwork_ConnectionMadeNoQOCInfo(This,bstrConnection,ulType)	\
    (This)->lpVtbl -> ConnectionMadeNoQOCInfo(This,bstrConnection,ulType)

#define ISensNetwork_ConnectionLost(This,bstrConnection,ulType)	\
    (This)->lpVtbl -> ConnectionLost(This,bstrConnection,ulType)

#define ISensNetwork_DestinationReachable(This,bstrDestination,bstrConnection,ulType,lpQOCInfo)	\
    (This)->lpVtbl -> DestinationReachable(This,bstrDestination,bstrConnection,ulType,lpQOCInfo)

#define ISensNetwork_DestinationReachableNoQOCInfo(This,bstrDestination,bstrConnection,ulType)	\
    (This)->lpVtbl -> DestinationReachableNoQOCInfo(This,bstrDestination,bstrConnection,ulType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISensNetwork_ConnectionMade_Proxy( 
    ISensNetwork * This,
    /* [in] */ BSTR bstrConnection,
    /* [in] */ ULONG ulType,
    /* [in] */ LPSENS_QOCINFO lpQOCInfo);


void __RPC_STUB ISensNetwork_ConnectionMade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensNetwork_ConnectionMadeNoQOCInfo_Proxy( 
    ISensNetwork * This,
    /* [in] */ BSTR bstrConnection,
    /* [in] */ ULONG ulType);


void __RPC_STUB ISensNetwork_ConnectionMadeNoQOCInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensNetwork_ConnectionLost_Proxy( 
    ISensNetwork * This,
    /* [in] */ BSTR bstrConnection,
    /* [in] */ ULONG ulType);


void __RPC_STUB ISensNetwork_ConnectionLost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensNetwork_DestinationReachable_Proxy( 
    ISensNetwork * This,
    /* [in] */ BSTR bstrDestination,
    /* [in] */ BSTR bstrConnection,
    /* [in] */ ULONG ulType,
    /* [in] */ LPSENS_QOCINFO lpQOCInfo);


void __RPC_STUB ISensNetwork_DestinationReachable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensNetwork_DestinationReachableNoQOCInfo_Proxy( 
    ISensNetwork * This,
    /* [in] */ BSTR bstrDestination,
    /* [in] */ BSTR bstrConnection,
    /* [in] */ ULONG ulType);


void __RPC_STUB ISensNetwork_DestinationReachableNoQOCInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISensNetwork_INTERFACE_DEFINED__ */


#ifndef __ISensOnNow_INTERFACE_DEFINED__
#define __ISensOnNow_INTERFACE_DEFINED__

/* interface ISensOnNow */
/* [dual][helpstring][version][uuid][object] */ 


EXTERN_C const IID IID_ISensOnNow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d597bab2-5b9f-11d1-8dd2-00aa004abd5e")
    ISensOnNow : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OnACPower( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OnBatteryPower( 
            /* [in] */ DWORD dwBatteryLifePercent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BatteryLow( 
            /* [in] */ DWORD dwBatteryLifePercent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISensOnNowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISensOnNow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISensOnNow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISensOnNow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISensOnNow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISensOnNow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISensOnNow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISensOnNow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *OnACPower )( 
            ISensOnNow * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *OnBatteryPower )( 
            ISensOnNow * This,
            /* [in] */ DWORD dwBatteryLifePercent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BatteryLow )( 
            ISensOnNow * This,
            /* [in] */ DWORD dwBatteryLifePercent);
        
        END_INTERFACE
    } ISensOnNowVtbl;

    interface ISensOnNow
    {
        CONST_VTBL struct ISensOnNowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISensOnNow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISensOnNow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISensOnNow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISensOnNow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISensOnNow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISensOnNow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISensOnNow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISensOnNow_OnACPower(This)	\
    (This)->lpVtbl -> OnACPower(This)

#define ISensOnNow_OnBatteryPower(This,dwBatteryLifePercent)	\
    (This)->lpVtbl -> OnBatteryPower(This,dwBatteryLifePercent)

#define ISensOnNow_BatteryLow(This,dwBatteryLifePercent)	\
    (This)->lpVtbl -> BatteryLow(This,dwBatteryLifePercent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISensOnNow_OnACPower_Proxy( 
    ISensOnNow * This);


void __RPC_STUB ISensOnNow_OnACPower_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensOnNow_OnBatteryPower_Proxy( 
    ISensOnNow * This,
    /* [in] */ DWORD dwBatteryLifePercent);


void __RPC_STUB ISensOnNow_OnBatteryPower_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensOnNow_BatteryLow_Proxy( 
    ISensOnNow * This,
    /* [in] */ DWORD dwBatteryLifePercent);


void __RPC_STUB ISensOnNow_BatteryLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISensOnNow_INTERFACE_DEFINED__ */


#ifndef __ISensLogon_INTERFACE_DEFINED__
#define __ISensLogon_INTERFACE_DEFINED__

/* interface ISensLogon */
/* [dual][helpstring][version][uuid][object] */ 


EXTERN_C const IID IID_ISensLogon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d597bab3-5b9f-11d1-8dd2-00aa004abd5e")
    ISensLogon : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Logoff( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartShell( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayLock( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayUnlock( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartScreenSaver( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StopScreenSaver( 
            /* [in] */ BSTR bstrUserName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISensLogonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISensLogon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISensLogon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISensLogon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISensLogon * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISensLogon * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISensLogon * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISensLogon * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Logon )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Logoff )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StartShell )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *DisplayLock )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *DisplayUnlock )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StartScreenSaver )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StopScreenSaver )( 
            ISensLogon * This,
            /* [in] */ BSTR bstrUserName);
        
        END_INTERFACE
    } ISensLogonVtbl;

    interface ISensLogon
    {
        CONST_VTBL struct ISensLogonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISensLogon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISensLogon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISensLogon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISensLogon_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISensLogon_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISensLogon_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISensLogon_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISensLogon_Logon(This,bstrUserName)	\
    (This)->lpVtbl -> Logon(This,bstrUserName)

#define ISensLogon_Logoff(This,bstrUserName)	\
    (This)->lpVtbl -> Logoff(This,bstrUserName)

#define ISensLogon_StartShell(This,bstrUserName)	\
    (This)->lpVtbl -> StartShell(This,bstrUserName)

#define ISensLogon_DisplayLock(This,bstrUserName)	\
    (This)->lpVtbl -> DisplayLock(This,bstrUserName)

#define ISensLogon_DisplayUnlock(This,bstrUserName)	\
    (This)->lpVtbl -> DisplayUnlock(This,bstrUserName)

#define ISensLogon_StartScreenSaver(This,bstrUserName)	\
    (This)->lpVtbl -> StartScreenSaver(This,bstrUserName)

#define ISensLogon_StopScreenSaver(This,bstrUserName)	\
    (This)->lpVtbl -> StopScreenSaver(This,bstrUserName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_Logon_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_Logoff_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_StartShell_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_StartShell_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_DisplayLock_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_DisplayLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_DisplayUnlock_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_DisplayUnlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_StartScreenSaver_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_StartScreenSaver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon_StopScreenSaver_Proxy( 
    ISensLogon * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB ISensLogon_StopScreenSaver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISensLogon_INTERFACE_DEFINED__ */


#ifndef __ISensLogon2_INTERFACE_DEFINED__
#define __ISensLogon2_INTERFACE_DEFINED__

/* interface ISensLogon2 */
/* [dual][helpstring][version][uuid][object] */ 


EXTERN_C const IID IID_ISensLogon2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d597bab4-5b9f-11d1-8dd2-00aa004abd5e")
    ISensLogon2 : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Logoff( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SessionDisconnect( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SessionReconnect( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PostShell( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISensLogon2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISensLogon2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISensLogon2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISensLogon2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISensLogon2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISensLogon2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISensLogon2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISensLogon2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Logon )( 
            ISensLogon2 * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Logoff )( 
            ISensLogon2 * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SessionDisconnect )( 
            ISensLogon2 * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SessionReconnect )( 
            ISensLogon2 * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PostShell )( 
            ISensLogon2 * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ DWORD dwSessionId);
        
        END_INTERFACE
    } ISensLogon2Vtbl;

    interface ISensLogon2
    {
        CONST_VTBL struct ISensLogon2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISensLogon2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISensLogon2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISensLogon2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISensLogon2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISensLogon2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISensLogon2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISensLogon2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISensLogon2_Logon(This,bstrUserName,dwSessionId)	\
    (This)->lpVtbl -> Logon(This,bstrUserName,dwSessionId)

#define ISensLogon2_Logoff(This,bstrUserName,dwSessionId)	\
    (This)->lpVtbl -> Logoff(This,bstrUserName,dwSessionId)

#define ISensLogon2_SessionDisconnect(This,bstrUserName,dwSessionId)	\
    (This)->lpVtbl -> SessionDisconnect(This,bstrUserName,dwSessionId)

#define ISensLogon2_SessionReconnect(This,bstrUserName,dwSessionId)	\
    (This)->lpVtbl -> SessionReconnect(This,bstrUserName,dwSessionId)

#define ISensLogon2_PostShell(This,bstrUserName,dwSessionId)	\
    (This)->lpVtbl -> PostShell(This,bstrUserName,dwSessionId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon2_Logon_Proxy( 
    ISensLogon2 * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB ISensLogon2_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon2_Logoff_Proxy( 
    ISensLogon2 * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB ISensLogon2_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon2_SessionDisconnect_Proxy( 
    ISensLogon2 * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB ISensLogon2_SessionDisconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon2_SessionReconnect_Proxy( 
    ISensLogon2 * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB ISensLogon2_SessionReconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISensLogon2_PostShell_Proxy( 
    ISensLogon2 * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB ISensLogon2_PostShell_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISensLogon2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SENS;

#ifdef __cplusplus

class DECLSPEC_UUID("d597cafe-5b9f-11d1-8dd2-00aa004abd5e")
SENS;
#endif
#endif /* __SensEvents_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\secpkg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1997
//
// File:        secpkg.h
//
// Contents:    Global definitions for security packages
//              This file will contain everything specific to writing
//              a security package.
//
//
// History:     10 Mar 92   RichardW    Created
//              24-Mar-94   wader   Changed EstablishCredentials to SystemLogon
//
//------------------------------------------------------------------------


#ifndef __SECPKG_H__
#define __SECPKG_H__

#include <ntlsa.h> // SECURITY_LOGON_TYPE

#ifdef SECURITY_KERNEL
//
// Can't use the windows.h def'ns in kernel mode.
//
typedef PVOID                   SEC_THREAD_START;
typedef PVOID                   SEC_ATTRS;
#else
typedef LPTHREAD_START_ROUTINE  SEC_THREAD_START;
typedef LPSECURITY_ATTRIBUTES   SEC_ATTRS;
#endif




//
// The following structures are used by the helper functions
//

typedef struct _SECPKG_CLIENT_INFO {
    LUID            LogonId;            // Effective Logon Id
    ULONG           ProcessID;          // Process Id of caller
    ULONG           ThreadID;           // Thread Id of caller
    BOOLEAN         HasTcbPrivilege;    // Client has TCB
    BOOLEAN         Impersonating;      // Client is impersonating
} SECPKG_CLIENT_INFO, * PSECPKG_CLIENT_INFO;

typedef struct _SECPKG_CALL_INFO {
    ULONG           ProcessId ;
    ULONG           ThreadId ;
    ULONG           Attributes ;
    ULONG           Reserved ;
} SECPKG_CALL_INFO, * PSECPKG_CALL_INFO ;

#define SECPKG_CALL_KERNEL_MODE 0x00000001  // Call originated in kernel mode
#define SECPKG_CALL_ANSI        0x00000002  // Call came from ANSI stub
#define SECPKG_CALL_URGENT      0x00000004  // Call designated urgent


typedef struct _SECPKG_SUPPLEMENTAL_CRED {
    UNICODE_STRING PackageName;
    ULONG CredentialSize;
    PUCHAR Credentials;
} SECPKG_SUPPLEMENTAL_CRED, *PSECPKG_SUPPLEMENTAL_CRED;



//
// This flag is used for to indicate which buffers in the SPMgr are located
// in the client's address space
//

#define SECBUFFER_UNMAPPED 0x40000000

typedef NTSTATUS
(NTAPI LSA_CALLBACK_FUNCTION)(
    ULONG       Argument1,
    ULONG       Argument2,
    PSecBuffer  InputBuffer,
    PSecBuffer  OutputBuffer
    );

typedef LSA_CALLBACK_FUNCTION * PLSA_CALLBACK_FUNCTION ;


//////////////////////////////////////////////////////////////////////////
//
// The following prototypes are to functions that are provided by the SPMgr
// to security packages.
//
//////////////////////////////////////////////////////////////////////////

typedef NTSTATUS
(NTAPI LSA_IMPERSONATE_CLIENT) (
    VOID
    );


typedef NTSTATUS
(NTAPI LSA_UNLOAD_PACKAGE)(
    VOID
    );

typedef NTSTATUS
(NTAPI LSA_DUPLICATE_HANDLE)(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle);


typedef NTSTATUS
(NTAPI LSA_SAVE_SUPPLEMENTAL_CREDENTIALS)(
    IN PLUID LogonId,
    IN ULONG SupplementalCredSize,
    IN PVOID SupplementalCreds,
    IN BOOLEAN Synchronous
    );


typedef HANDLE
(NTAPI LSA_CREATE_THREAD)(
    IN SEC_ATTRS SecurityAttributes,
    IN ULONG StackSize,
    IN SEC_THREAD_START StartFunction,
    IN PVOID ThreadParameter,
    IN ULONG CreationFlags,
    OUT PULONG ThreadId
    );


typedef NTSTATUS
(NTAPI LSA_GET_CLIENT_INFO)(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    );


typedef HANDLE
(NTAPI LSA_REGISTER_NOTIFICATION)(
    IN SEC_THREAD_START StartFunction,
    IN PVOID Parameter,
    IN ULONG NotificationType,
    IN ULONG NotificationClass,
    IN ULONG NotificationFlags,
    IN ULONG IntervalMinutes,
    IN OPTIONAL HANDLE WaitEvent
    );


typedef NTSTATUS
(NTAPI LSA_CANCEL_NOTIFICATION)(
    IN HANDLE NotifyHandle
    );

typedef NTSTATUS
(NTAPI LSA_MAP_BUFFER)(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    );

typedef NTSTATUS
(NTAPI LSA_CREATE_TOKEN) (
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    IN PTOKEN_GROUPS TokenGroups,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN PUNICODE_STRING Workstation,
    OUT PHANDLE Token,
    OUT PNTSTATUS SubStatus
    );

typedef VOID
(NTAPI LSA_AUDIT_LOGON) (
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    );

typedef NTSTATUS
(NTAPI LSA_CALL_PACKAGE) (
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef NTSTATUS
(NTAPI LSA_CALL_PACKAGEEX) (
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef VOID
(NTAPI LSA_FREE_LSA_HEAP) (
    IN PVOID Base
    );

typedef BOOLEAN
(NTAPI LSA_GET_CALL_INFO) (
    OUT PSECPKG_CALL_INFO   Info
    );

typedef PVOID
(NTAPI LSA_CREATE_SHARED_MEMORY)(
    ULONG MaxSize,
    ULONG InitialSize
    );

typedef PVOID
(NTAPI LSA_ALLOCATE_SHARED_MEMORY)(
    PVOID SharedMem,
    ULONG Size
    );

typedef VOID
(NTAPI LSA_FREE_SHARED_MEMORY)(
    PVOID SharedMem,
    PVOID Memory
    );

typedef BOOLEAN
(NTAPI LSA_DELETE_SHARED_MEMORY)(
    PVOID SharedMem
    );

//
// Account Access
//

typedef enum _SECPKG_NAME_TYPE {
    SecNameSamCompatible,
    SecNameAlternateId,
    SecNameFlat,
    SecNameDN
} SECPKG_NAME_TYPE ;

typedef NTSTATUS
(NTAPI LSA_OPEN_SAM_USER)(
    PSECURITY_STRING Name,
    SECPKG_NAME_TYPE NameType,
    PSECURITY_STRING Prefix,
    BOOLEAN AllowGuest,
    ULONG Reserved,
    PVOID * UserHandle
    );

typedef NTSTATUS
(NTAPI LSA_GET_USER_CREDENTIALS)(
    PVOID UserHandle,
    PVOID * PrimaryCreds,
    PULONG PrimaryCredsSize,
    PVOID * SupplementalCreds,
    PULONG SupplementalCredsSize
    );

typedef NTSTATUS
(NTAPI LSA_GET_USER_AUTH_DATA)(
    PVOID UserHandle,
    PUCHAR * UserAuthData,
    PULONG UserAuthDataSize
    );

typedef NTSTATUS
(NTAPI LSA_CLOSE_SAM_USER)(
    PVOID UserHandle
    );

typedef NTSTATUS
(NTAPI LSA_CONVERT_AUTH_DATA_TO_TOKEN_INFO)(
    PVOID UserAuthData,
    ULONG UserAuthDataSize,
    PVOID * TokenInformation,
    PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    PSECURITY_STRING UserName
    );

typedef NTSTATUS
(NTAPI LSA_FREE_TOKEN_INFO)(
    LSA_TOKEN_INFORMATION_TYPE TokenInfoType,
    PVOID TokenInformation
    );

typedef NTSTATUS
(NTAPI LSA_CLIENT_CALLBACK)(
    PCHAR   Callback,
    ULONG   Argument1,
    ULONG   Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    );

typedef
NTSTATUS
(NTAPI LSA_REGISTER_CALLBACK)(
    ULONG   CallbackId,
    PLSA_CALLBACK_FUNCTION Callback
    );

#define NOTIFIER_FLAG_NEW_THREAD    0x00000001
#define NOTIFIER_FLAG_ONE_SHOT      0x00000002
#define NOTIFIER_FLAG_HANDLE_FREE   0x00000004
#define NOTIFIER_FLAG_SECONDS       0x80000000

#define NOTIFIER_TYPE_INTERVAL      1
#define NOTIFIER_TYPE_HANDLE_WAIT   2
#define NOTIFIER_TYPE_STATE_CHANGE  3
#define NOTIFIER_TYPE_NOTIFY_EVENT  4
#define NOTIFIER_TYPE_IMMEDIATE 16

#define NOTIFY_CLASS_PACKAGE_CHANGE 1
#define NOTIFY_CLASS_ROLE_CHANGE    2
#define NOTIFY_CLASS_DOMAIN_CHANGE  3

typedef struct _SECPKG_EVENT_PACKAGE_CHANGE {
    ULONG   ChangeType;
    ULONG   PackageId;
    SECURITY_STRING PackageName;
} SECPKG_EVENT_PACKAGE_CHANGE, * PSECPKG_EVENT_PACKAGE_CHANGE ;

#define SECPKG_PACKAGE_CHANGE_LOAD      0
#define SECPKG_PACKAGE_CHANGE_UNLOAD    1
#define SECPKG_PACKAGE_CHANGE_SELECT    2

typedef struct _SECPKG_EVENT_ROLE_CHANGE {
    ULONG   PreviousRole ;
    ULONG   NewRole ;
} SECPKG_EVENT_ROLE_CHANGE, * PSECPKG_EVENT_ROLE_CHANGE ;

typedef struct _SECPKG_PARAMETERS SECPKG_EVENT_DOMAIN_CHANGE ;
typedef struct _SECPKG_PARAMETERS * PSECPKG_EVENT_DOMAIN_CHANGE ;


typedef struct _SECPKG_EVENT_NOTIFY {
    ULONG EventClass;
    ULONG Reserved;
    ULONG EventDataSize;
    PVOID EventData;
    PVOID PackageParameter;
} SECPKG_EVENT_NOTIFY, *PSECPKG_EVENT_NOTIFY ;

typedef LSA_IMPERSONATE_CLIENT * PLSA_IMPERSONATE_CLIENT;
typedef LSA_UNLOAD_PACKAGE * PLSA_UNLOAD_PACKAGE;
typedef LSA_DUPLICATE_HANDLE * PLSA_DUPLICATE_HANDLE ;
typedef LSA_SAVE_SUPPLEMENTAL_CREDENTIALS * PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS;
typedef LSA_CREATE_THREAD * PLSA_CREATE_THREAD;
typedef LSA_GET_CLIENT_INFO * PLSA_GET_CLIENT_INFO;
typedef LSA_REGISTER_NOTIFICATION * PLSA_REGISTER_NOTIFICATION;
typedef LSA_CANCEL_NOTIFICATION * PLSA_CANCEL_NOTIFICATION;
typedef LSA_MAP_BUFFER * PLSA_MAP_BUFFER;
typedef LSA_CREATE_TOKEN * PLSA_CREATE_TOKEN;
typedef LSA_AUDIT_LOGON * PLSA_AUDIT_LOGON;
typedef LSA_CALL_PACKAGE * PLSA_CALL_PACKAGE;
typedef LSA_CALL_PACKAGEEX * PLSA_CALL_PACKAGEEX;
typedef LSA_GET_CALL_INFO * PLSA_GET_CALL_INFO ;
typedef LSA_CREATE_SHARED_MEMORY * PLSA_CREATE_SHARED_MEMORY ;
typedef LSA_ALLOCATE_SHARED_MEMORY * PLSA_ALLOCATE_SHARED_MEMORY ;
typedef LSA_FREE_SHARED_MEMORY * PLSA_FREE_SHARED_MEMORY ;
typedef LSA_DELETE_SHARED_MEMORY * PLSA_DELETE_SHARED_MEMORY ;
typedef LSA_OPEN_SAM_USER * PLSA_OPEN_SAM_USER ;
typedef LSA_GET_USER_CREDENTIALS * PLSA_GET_USER_CREDENTIALS ;
typedef LSA_GET_USER_AUTH_DATA * PLSA_GET_USER_AUTH_DATA ;
typedef LSA_CLOSE_SAM_USER * PLSA_CLOSE_SAM_USER ;
typedef LSA_CONVERT_AUTH_DATA_TO_TOKEN_INFO * PLSA_CONVERT_AUTH_DATA_TO_TOKEN_INFO ;
typedef LSA_FREE_TOKEN_INFO * PLSA_FREE_TOKEN_INFO ;
typedef LSA_CLIENT_CALLBACK * PLSA_CLIENT_CALLBACK ;

typedef LSA_REGISTER_CALLBACK * PLSA_REGISTER_CALLBACK ;

// Functions provided by the SPM to the packages:
typedef struct _LSA_SECPKG_FUNCTION_TABLE {
    PLSA_CREATE_LOGON_SESSION CreateLogonSession;
    PLSA_DELETE_LOGON_SESSION DeleteLogonSession;
    PLSA_ADD_CREDENTIAL AddCredential;
    PLSA_GET_CREDENTIALS GetCredentials;
    PLSA_DELETE_CREDENTIAL DeleteCredential;
    PLSA_ALLOCATE_LSA_HEAP AllocateLsaHeap;
    PLSA_FREE_LSA_HEAP FreeLsaHeap;
    PLSA_ALLOCATE_CLIENT_BUFFER AllocateClientBuffer;
    PLSA_FREE_CLIENT_BUFFER FreeClientBuffer;
    PLSA_COPY_TO_CLIENT_BUFFER CopyToClientBuffer;
    PLSA_COPY_FROM_CLIENT_BUFFER CopyFromClientBuffer;
    PLSA_IMPERSONATE_CLIENT ImpersonateClient;
    PLSA_UNLOAD_PACKAGE UnloadPackage;
    PLSA_DUPLICATE_HANDLE DuplicateHandle;
    PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS SaveSupplementalCredentials;
    PLSA_CREATE_THREAD CreateThread;
    PLSA_GET_CLIENT_INFO GetClientInfo;
    PLSA_REGISTER_NOTIFICATION RegisterNotification;
    PLSA_CANCEL_NOTIFICATION CancelNotification;
    PLSA_MAP_BUFFER MapBuffer;
    PLSA_CREATE_TOKEN CreateToken;
    PLSA_AUDIT_LOGON AuditLogon;
    PLSA_CALL_PACKAGE CallPackage;
    PLSA_FREE_LSA_HEAP FreeReturnBuffer;
    PLSA_GET_CALL_INFO GetCallInfo;
    PLSA_CALL_PACKAGEEX CallPackageEx;
    PLSA_CREATE_SHARED_MEMORY CreateSharedMemory;
    PLSA_ALLOCATE_SHARED_MEMORY AllocateSharedMemory;
    PLSA_FREE_SHARED_MEMORY FreeSharedMemory;
    PLSA_DELETE_SHARED_MEMORY DeleteSharedMemory;
    PLSA_OPEN_SAM_USER OpenSamUser ;
    PLSA_GET_USER_CREDENTIALS GetUserCredentials ;
    PLSA_GET_USER_AUTH_DATA GetUserAuthData ;
    PLSA_CLOSE_SAM_USER CloseSamUser ;
    PLSA_CONVERT_AUTH_DATA_TO_TOKEN_INFO ConvertAuthDataToTokenInfo ;
    PLSA_FREE_TOKEN_INFO FreeTokenInfo ;
    PLSA_CLIENT_CALLBACK ClientCallback ;
} LSA_SECPKG_FUNCTION_TABLE, *PLSA_SECPKG_FUNCTION_TABLE;

typedef struct _SECPKG_DLL_FUNCTIONS {
    PLSA_ALLOCATE_LSA_HEAP AllocateHeap;
    PLSA_FREE_LSA_HEAP FreeHeap;
    PLSA_REGISTER_CALLBACK RegisterCallback ;
} SECPKG_DLL_FUNCTIONS, * PSECPKG_DLL_FUNCTIONS;



#define PRIMARY_CRED_CLEAR_PASSWORD 0x1
#define PRIMARY_CRED_OWF_PASSWORD 0x2

typedef struct _SECPKG_PRIMARY_CRED {
    LUID LogonId;
    UNICODE_STRING DownlevelName;
    UNICODE_STRING DomainName;
    UNICODE_STRING Password;
    UNICODE_STRING OldPassword;
    PSID UserSid;
    ULONG Flags;
} SECPKG_PRIMARY_CRED, *PSECPKG_PRIMARY_CRED;

//
// Maximum size of stored credentials.
//

#define MAX_CRED_SIZE 1024

#define SECPKG_STATE_ENCRYPTION_PERMITTED               0x01
#define SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED        0x02

typedef struct _SECPKG_PARAMETERS {
    ULONG           Version;
    ULONG           MachineState;
    ULONG           SetupMode;
    PSID            DomainSid;
    UNICODE_STRING  DomainName;
    UNICODE_STRING  DnsDomainName;
} SECPKG_PARAMETERS, *PSECPKG_PARAMETERS;


//
// Extended Package information structures
//

typedef enum _SECPKG_EXTENDED_INFORMATION_CLASS {
    SecpkgGssInfo = 1,
    SecpkgContextThunks,
    SecpkgMaxInfo
} SECPKG_EXTENDED_INFORMATION_CLASS ;

typedef struct _SECPKG_GSS_INFO {
    ULONG   EncodedIdLength ;
    UCHAR   EncodedId[4] ;
} SECPKG_GSS_INFO, * PSECPKG_GSS_INFO ;

typedef struct _SECPKG_CONTEXT_THUNKS {
    ULONG   InfoLevelCount ;
    ULONG   Levels[1] ;
} SECPKG_CONTEXT_THUNKS, *PSECPKG_CONTEXT_THUNKS ;

typedef struct _SECPKG_EXTENDED_INFORMATION {
    SECPKG_EXTENDED_INFORMATION_CLASS   Class ;
    union {
        SECPKG_GSS_INFO         GssInfo ;
        SECPKG_CONTEXT_THUNKS   ContextThunks ;
    } Info ;
} SECPKG_EXTENDED_INFORMATION, * PSECPKG_EXTENDED_INFORMATION ;

//
// Setting this value as the first context thunk value will cause all
// calls to go to the LSA:
//

#define SECPKG_ATTR_THUNK_ALL   0x00010000


//
// The following prototypes are to functions that will be called only while
// in the Security Package Manager context.
//

typedef NTSTATUS
(LSA_AP_INITIALIZE_PACKAGE) (
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PLSA_STRING Database OPTIONAL,
    IN PLSA_STRING Confidentiality OPTIONAL,
    OUT PLSA_STRING *AuthenticationPackageName
    );

typedef NTSTATUS
(LSA_AP_LOGON_USER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PLSA_UNICODE_STRING *AccountName,
    OUT PLSA_UNICODE_STRING *AuthenticatingAuthority
    );

typedef NTSTATUS
(LSA_AP_LOGON_USER_EX) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName
    );

typedef NTSTATUS
(LSA_AP_CALL_PACKAGE) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef VOID
(LSA_AP_LOGON_TERMINATED) (
    IN PLUID LogonId
    );

typedef LSA_AP_CALL_PACKAGE LSA_AP_CALL_PACKAGE_UNTRUSTED;


typedef NTSTATUS
(NTAPI SpInitializeFn)(
    IN ULONG PackageId,
    IN PSECPKG_PARAMETERS Parameters,
    IN PLSA_SECPKG_FUNCTION_TABLE FunctionTable
    );

typedef NTSTATUS
(NTAPI SpShutdownFn)(
    VOID
    );

typedef NTSTATUS
(NTAPI SpGetInfoFn)(
    OUT PSecPkgInfo PackageInfo
    );

typedef NTSTATUS
(NTAPI SpGetExtendedInformationFn)(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    );

typedef NTSTATUS
(LSA_AP_LOGON_USER_EX2) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PULONG CachedCredentialCount,
    OUT PSECPKG_SUPPLEMENTAL_CRED * CachedCredentials
    );

typedef LSA_AP_LOGON_USER_EX2 *PLSA_AP_LOGON_USER_EX2;
#define LSA_AP_NAME_LOGON_USER_EX2 "LsaApLogonUserEx2\0"

typedef NTSTATUS
(NTAPI SpAcceptCredentialsFn)(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    );
#define SP_ACCEPT_CREDENTIALS_NAME "SpAcceptCredentials\0"

typedef NTSTATUS
(NTAPI SpAcquireCredentialsHandleFn)(
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID LogonId,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunciton,
    IN PVOID GetKeyArgument,
    OUT PULONG CredentialHandle,
    OUT PTimeStamp ExpirationTime
    );

typedef NTSTATUS
(NTAPI SpFreeCredentialsHandleFn)(
    IN ULONG CredentialHandle
    );

typedef NTSTATUS
(NTAPI SpQueryCredentialsAttributesFn)(
    IN ULONG CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    );

typedef NTSTATUS
(NTAPI SpSaveCredentialsFn)(
    IN ULONG CredentialHandle,
    IN PSecBuffer Credentials);

typedef NTSTATUS
(NTAPI SpGetCredentialsFn)(
    IN ULONG CredentialHandle,
    IN OUT PSecBuffer Credentials
    );

typedef NTSTATUS
(NTAPI SpDeleteCredentialsFn)(
    IN ULONG CredentialHandle,
    IN PSecBuffer Key
    );

typedef NTSTATUS
(NTAPI SpInitLsaModeContextFn)(
    IN OPTIONAL ULONG CredentialHandle,
    IN OPTIONAL ULONG ContextHandle,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputBuffers,
    OUT PULONG NewContextHandle,
    IN OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    );




typedef NTSTATUS
(NTAPI SpDeleteContextFn)(
    IN ULONG ContextHandle
    );

typedef NTSTATUS
(NTAPI SpApplyControlTokenFn)(
    IN ULONG ContextHandle,
    IN PSecBufferDesc ControlToken);


typedef NTSTATUS
(NTAPI SpAcceptLsaModeContextFn)(
    IN OPTIONAL ULONG CredentialHandle,
    IN OPTIONAL ULONG ContextHandle,
    IN PSecBufferDesc InputBuffer,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    OUT PULONG NewContextHandle,
    OUT PSecBufferDesc OutputBuffer,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    );




typedef NTSTATUS
(NTAPI SpGetUserInfoFn)(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    );

typedef NTSTATUS
(NTAPI SpQueryContextAttributesFn)(
    IN ULONG ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer);


typedef struct _SECPKG_FUNCTION_TABLE {
    PLSA_AP_INITIALIZE_PACKAGE InitializePackage;
    PLSA_AP_LOGON_USER LogonUser;
    PLSA_AP_CALL_PACKAGE CallPackage;
    PLSA_AP_LOGON_TERMINATED LogonTerminated;
    PLSA_AP_CALL_PACKAGE_UNTRUSTED CallPackageUntrusted;
    PLSA_AP_LOGON_USER_EX LogonUserEx;
    PLSA_AP_LOGON_USER_EX2 LogonUserEx2;
    SpInitializeFn * Initialize;
    SpShutdownFn * Shutdown;
    SpGetInfoFn * GetInfo;
    SpAcceptCredentialsFn * AcceptCredentials;
    SpAcquireCredentialsHandleFn * AcquireCredentialsHandle;
    SpQueryCredentialsAttributesFn * QueryCredentialsAttributes;
    SpFreeCredentialsHandleFn * FreeCredentialsHandle;
    SpSaveCredentialsFn * SaveCredentials;
    SpGetCredentialsFn * GetCredentials;
    SpDeleteCredentialsFn * DeleteCredentials;
    SpInitLsaModeContextFn * InitLsaModeContext;
    SpAcceptLsaModeContextFn * AcceptLsaModeContext;
    SpDeleteContextFn * DeleteContext;
    SpApplyControlTokenFn * ApplyControlToken;
    SpGetUserInfoFn * GetUserInfo;
    SpGetExtendedInformationFn * GetExtendedInformation ;
    SpQueryContextAttributesFn * QueryContextAttributes ;
} SECPKG_FUNCTION_TABLE, *PSECPKG_FUNCTION_TABLE;

//
// The following prototypes are to functions that will be called while in the
// context of a user process that is using the functions through the security
// DLL.
//

typedef NTSTATUS
(NTAPI SpInstanceInitFn)(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS FunctionTable,
    OUT PVOID * UserFunctions
    );


typedef NTSTATUS
(NTAPI SpInitUserModeContextFn)(
    IN ULONG ContextHandle,
    IN PSecBuffer PackedContext
    );

typedef NTSTATUS
(NTAPI SpMakeSignatureFn)(
    IN ULONG ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    );

typedef NTSTATUS
(NTAPI SpVerifySignatureFn)(
    IN ULONG ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    );

typedef NTSTATUS
(NTAPI SpSealMessageFn)(
    IN ULONG ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    );

typedef NTSTATUS
(NTAPI SpUnsealMessageFn)(
    IN ULONG ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    );


typedef NTSTATUS
(NTAPI SpGetContextTokenFn)(
    IN ULONG ContextHandle,
    OUT PHANDLE ImpersonationToken
    );


typedef NTSTATUS
(NTAPI SpExportSecurityContextFn)(
    ULONG                phContext,             // (in) context to export
    ULONG                fFlags,                // (in) option flags
    PSecBuffer           pPackedContext,        // (out) marshalled context
    PHANDLE              pToken                 // (out, optional) token handle for impersonation
    );

typedef NTSTATUS
(NTAPI SpImportSecurityContextFn)(
    PSecBuffer           pPackedContext,        // (in) marshalled context
    HANDLE               Token,                 // (in, optional) handle to token for context
    PULONG               phContext              // (out) new context handle
    );


typedef NTSTATUS
(NTAPI SpCompleteAuthTokenFn)(
    IN ULONG ContextHandle,
    IN PSecBufferDesc InputBuffer
    );


typedef NTSTATUS
(NTAPI SpFormatCredentialsFn)(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    );

typedef NTSTATUS
(NTAPI SpMarshallSupplementalCredsFn)(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds);


typedef struct _SECPKG_USER_FUNCTION_TABLE {
    SpInstanceInitFn *                      InstanceInit;
    SpInitUserModeContextFn *               InitUserModeContext;
    SpMakeSignatureFn *                     MakeSignature;
    SpVerifySignatureFn *                   VerifySignature;
    SpSealMessageFn *                       SealMessage;
    SpUnsealMessageFn *                     UnsealMessage;
    SpGetContextTokenFn *                   GetContextToken;
    SpQueryContextAttributesFn *            QueryContextAttributes;
    SpCompleteAuthTokenFn *                 CompleteAuthToken;
    SpDeleteContextFn *                     DeleteUserModeContext;
    SpFormatCredentialsFn *                 FormatCredentials;
    SpMarshallSupplementalCredsFn *         MarshallSupplementalCreds;
    SpExportSecurityContextFn *             ExportContext;
    SpImportSecurityContextFn *             ImportContext;
} SECPKG_USER_FUNCTION_TABLE, *PSECPKG_USER_FUNCTION_TABLE;

typedef NTSTATUS
(SEC_ENTRY * SpLsaModeInitializeFn)(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * ppTables,
    OUT PULONG pcTables);

typedef NTSTATUS
(SEC_ENTRY * SpUserModeInitializeFn)(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE *ppTables,
    OUT PULONG pcTables
    );



#define SECPKG_LSAMODEINIT_NAME     "SpLsaModeInitialize"
#define SECPKG_USERMODEINIT_NAME    "SpUserModeInitialize"

#define SECPKG_INTERFACE_VERSION    0x00010000



typedef struct _SECPKG_KERNEL_FUNCTIONS {
    PLSA_ALLOCATE_LSA_HEAP AllocateHeap;
    PLSA_FREE_LSA_HEAP FreeHeap;
} SECPKG_KERNEL_FUNCTIONS, *PSECPKG_KERNEL_FUNCTIONS;

typedef NTSTATUS
(NTAPI KspInitPackageFn)(
    PSECPKG_KERNEL_FUNCTIONS    FunctionTable
    );

typedef NTSTATUS
(NTAPI KspDeleteContextFn)(
    IN ULONG ContextId,
    OUT PULONG LsaContextId
    );

typedef NTSTATUS
(NTAPI KspInitContextFn)(
    IN ULONG ContextId,
    IN PSecBuffer ContextData,
    OUT PULONG NewContextId
    );

typedef NTSTATUS
(NTAPI KspMakeSignatureFn)(
    IN ULONG ContextId,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc Message,
    IN ULONG MessageSeqNo
    );

typedef NTSTATUS
(NTAPI KspVerifySignatureFn)(
    IN ULONG ContextId,
    IN OUT PSecBufferDesc Message,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    );


typedef NTSTATUS
(NTAPI KspSealMessageFn)(
    IN ULONG ContextId,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc Message,
    IN ULONG MessageSeqNo
    );

typedef NTSTATUS
(NTAPI KspUnsealMessageFn)(
    IN ULONG ContextId,
    IN OUT PSecBufferDesc Message,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    );

typedef NTSTATUS
(NTAPI KspGetTokenFn)(
    IN ULONG ContextId,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN * RawToken
    );

typedef NTSTATUS
(NTAPI KspQueryAttributesFn)(
    IN ULONG ContextId,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    );

typedef NTSTATUS
(NTAPI KspCompleteTokenFn)(
    IN ULONG ContextId,
    IN PSecBufferDesc Token
    );


typedef NTSTATUS
(NTAPI KspMapHandleFn)(
    IN ULONG ContextId,
    OUT PULONG LsaContextId
    );

typedef struct _SECPKG_KERNEL_FUNCTION_TABLE {
    KspInitPackageFn *      Initialize;
    KspDeleteContextFn *    DeleteContext;
    KspInitContextFn *      InitContext;
    KspMapHandleFn *        MapHandle;
    KspMakeSignatureFn *    Sign;
    KspVerifySignatureFn *  Verify;
    KspSealMessageFn *      Seal;
    KspUnsealMessageFn *    Unseal;
    KspGetTokenFn *         GetToken;
    KspQueryAttributesFn *  QueryAttributes;
    KspCompleteTokenFn *    CompleteToken;
} SECPKG_KERNEL_FUNCTION_TABLE, *PSECPKG_KERNEL_FUNCTION_TABLE;

SECURITY_STATUS
SEC_ENTRY
KsecRegisterSecurityProvider(
    PSECURITY_STRING    ProviderName,
    PSECPKG_KERNEL_FUNCTION_TABLE Table
    );


extern SECPKG_KERNEL_FUNCTIONS KspKernelFunctions;


//
// Common types used by negotiable security packages
//

#define SEC_WINNT_AUTH_IDENTITY_MARSHALLED      0x4
#define SEC_WINNT_AUTH_IDENTITY_EXTENDED        0x8

#endif // __SECPKG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\servprov.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for servprov.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_servprov_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/* interface IServiceProvider */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IServiceProvider *LPSERVICEPROVIDER;

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IServiceProvider;
    extern "C++"
    {
        MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
        IServiceProvider : public IUnknown
        {
        public:
            virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
                /* [in] */ REFGUID guidService,
                /* [in] */ REFIID riid,
                /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
            
            template <class Q>
            HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, Q** pp)
            {
                return QueryService(guidService, __uuidof(Q), (void **)pp);
            }
        };
    }

    /* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
        IServiceProvider __RPC_FAR * This,
        /* [in] */ REFGUID guidService,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

    void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);

#else // VC6 Hack

EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
    IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceProvider * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryService )( 
            IServiceProvider * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_servprov_0084 */
/* [local] */ 

#endif // VC6 Hack


extern RPC_IF_HANDLE __MIDL_itf_servprov_0084_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0084_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sha.h ===
//-----------------------------------------------------------------------------
//
// File:   sha.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    DWORD       FinishFlag;
    BYTE        HashVal[A_SHA_DIGEST_LEN];
    DWORD state[5];                             /* state (ABCDE) */
    DWORD count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#elif   defined(_M_MRX000)

#if     _MSC_VER >= 1100
#define _setjmpex _setjmpexVfp
#endif

#define setjmp _setjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\setupapi.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    setupapi.h

Abstract:

    Public header file for Windows NT Setup and Device Installer services Dll.

--*/

#ifndef _INC_SETUPAPI
#define _INC_SETUPAPI

#if _MSC_VER > 1000
#pragma once
#endif

//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_SETUPAPI_)
#define WINSETUPAPI DECLSPEC_IMPORT
#else
#define WINSETUPAPI
#endif

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

//
// Include commctrl.h for our use of HIMAGELIST and wizard support.
//
#include <commctrl.h>

#ifdef _WIN64
#include <pshpack8.h>   // Assume byte packing throughout
#else
#include <pshpack1.h>   // Assume byte packing throughout
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Define maximum string length constants as specified by
// Windows 95.
//
#define LINE_LEN                    256 // Win95-compatible maximum for displayable
                                        // strings coming from a device INF.
#define MAX_INF_STRING_LENGTH      4096 // Actual maximum size of an INF string
                                        // (including string substitutions).
#define MAX_TITLE_LEN                60
#define MAX_INSTRUCTION_LEN         256
#define MAX_LABEL_LEN                30
#define MAX_SERVICE_NAME_LEN        256
#define MAX_SUBTITLE_LEN            256

//
// Define maximum length of a machine name in the format expected by ConfigMgr32
// CM_Connect_Machine (i.e., "\\\\MachineName\0").
//
#define SP_MAX_MACHINENAME_LENGTH   (MAX_PATH + 3)

//
// Define type for reference to loaded inf file
//
typedef PVOID HINF;

//
// Inf context structure. Applications must not interpret or
// overwrite values in these structures.
//
typedef struct _INFCONTEXT {
    PVOID Inf;
    PVOID CurrentInf;
    UINT Section;
    UINT Line;
} INFCONTEXT, *PINFCONTEXT;

//
// Inf file information structure.
//
typedef struct _SP_INF_INFORMATION {
    DWORD InfStyle;
    DWORD InfCount;
    BYTE VersionData[ANYSIZE_ARRAY];
} SP_INF_INFORMATION, *PSP_INF_INFORMATION;

//
// Define structure for passing alternate platform info into
// SetupSetFileQueueAlternatePlatform and SetupQueryInfOriginalFileInformation.
//
typedef struct _SP_ALTPLATFORM_INFO {
    DWORD cbSize;
    //
    // platform to use (VER_PLATFORM_WIN32_WINDOWS or VER_PLATFORM_WIN32_NT)
    //
    DWORD Platform;
    //
    // major and minor version numbers to use
    //
    DWORD MajorVersion;
    DWORD MinorVersion;
    //
    // processor architecture to use (PROCESSOR_ARCHITECTURE_INTEL,
    // PROCESSOR_ARCHITECTURE_ALPHA, PROCESSOR_ARCHITECTURE_IA64, or
    // PROCESSOR_ARCHITECTURE_ALPHA64)
    //
    WORD  ProcessorArchitecture;

    WORD  Reserved; // must be zero.
} SP_ALTPLATFORM_INFO, *PSP_ALTPLATFORM_INFO;

//
// Define structure that is filled in by SetupQueryInfOriginalFileInformation
// to indicate the INF's original name and the original name of the (potentially
// platform-specific) catalog file specified by that INF.
//
typedef struct _SP_ORIGINAL_FILE_INFO_A {
    DWORD  cbSize;
    CHAR   OriginalInfName[MAX_PATH];
    CHAR   OriginalCatalogName[MAX_PATH];
} SP_ORIGINAL_FILE_INFO_A, *PSP_ORIGINAL_FILE_INFO_A;

typedef struct _SP_ORIGINAL_FILE_INFO_W {
    DWORD  cbSize;
    WCHAR  OriginalInfName[MAX_PATH];
    WCHAR  OriginalCatalogName[MAX_PATH];
} SP_ORIGINAL_FILE_INFO_W, *PSP_ORIGINAL_FILE_INFO_W;

#ifdef UNICODE
typedef SP_ORIGINAL_FILE_INFO_W SP_ORIGINAL_FILE_INFO;
typedef PSP_ORIGINAL_FILE_INFO_W PSP_ORIGINAL_FILE_INFO;
#else
typedef SP_ORIGINAL_FILE_INFO_A SP_ORIGINAL_FILE_INFO;
typedef PSP_ORIGINAL_FILE_INFO_A PSP_ORIGINAL_FILE_INFO;
#endif

//
// SP_INF_INFORMATION.InfStyle values
//
#define INF_STYLE_NONE           0x00000000       // unrecognized or non-existent
#define INF_STYLE_OLDNT          0x00000001       // winnt 3.x
#define INF_STYLE_WIN4           0x00000002       // Win95

//
// Additional InfStyle flags that may be specified when calling SetupOpenInfFile.
//
//
#define INF_STYLE_CACHE_ENABLE   0x00000010 // always cache INF, even outside of %windir%\Inf
#define INF_STYLE_CACHE_DISABLE  0x00000020 // delete cached INF information


//
// Target directory specs.
//
#define DIRID_ABSOLUTE          -1              // real 32-bit -1
#define DIRID_ABSOLUTE_16BIT     0xffff         // 16-bit -1 for compat w/setupx
#define DIRID_NULL               0
#define DIRID_SRCPATH            1
#define DIRID_WINDOWS           10
#define DIRID_SYSTEM            11              // system32
#define DIRID_DRIVERS           12
#define DIRID_IOSUBSYS          DIRID_DRIVERS
#define DIRID_INF               17
#define DIRID_HELP              18
#define DIRID_FONTS             20
#define DIRID_VIEWERS           21
#define DIRID_COLOR             23
#define DIRID_APPS              24
#define DIRID_SHARED            25
#define DIRID_BOOT              30

#define DIRID_SYSTEM16          50
#define DIRID_SPOOL             51
#define DIRID_SPOOLDRIVERS      52
#define DIRID_USERPROFILE       53
#define DIRID_LOADER            54
#define DIRID_PRINTPROCESSOR    55

#define DIRID_DEFAULT           DIRID_SYSTEM

//
// The following DIRIDs are for commonly-used shell "special folders".  The
// complete list of such folders is contained in shlobj.h.  In that headerfile,
// each folder is assigned a CSIDL_* value.  The DIRID values below are created
// by taking the CSIDL value in shlobj.h and OR'ing it with 0x4000.  Thus, if
// an INF needs to reference other special folders not defined below, it may
// generate one using the above mechanism, and setupapi will automatically deal
// with it and use the corresponding shell's path where appropriate.  (Remember
// that DIRIDs must be specified in decimal, not hex, in an INF when used for
// string substitution.)
//
#define DIRID_COMMON_STARTMENU        16406  // All Users\Start Menu
#define DIRID_COMMON_PROGRAMS         16407  // All Users\Start Menu\Programs
#define DIRID_COMMON_STARTUP          16408  // All Users\Start Menu\Programs\Startup
#define DIRID_COMMON_DESKTOPDIRECTORY 16409  // All Users\Desktop
#define DIRID_COMMON_FAVORITES        16415  // All Users\Favorites
#define DIRID_COMMON_APPDATA          16419  // All Users\Application Data

#define DIRID_PROGRAM_FILES           16422  // Program Files
#define DIRID_SYSTEM_X86              16425  // system32 on RISC
#define DIRID_PROGRAM_FILES_X86       16426  // Program Files on RISC
#define DIRID_PROGRAM_FILES_COMMON    16427  // Program Files\Common
#define DIRID_PROGRAM_FILES_COMMONX86 16428  // x86 Program Files\Common on RISC

#define DIRID_COMMON_TEMPLATES        16429  // All Users\Templates
#define DIRID_COMMON_DOCUMENTS        16430  // All Users\Documents


//
// First user-definable dirid. See SetupSetDirectoryId().
//
#define DIRID_USER              0x8000


//
// Setup callback notification routine type
//
typedef UINT (CALLBACK* PSP_FILE_CALLBACK_A)(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

typedef UINT (CALLBACK* PSP_FILE_CALLBACK_W)(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

#ifdef UNICODE
#define PSP_FILE_CALLBACK PSP_FILE_CALLBACK_W
#else
#define PSP_FILE_CALLBACK PSP_FILE_CALLBACK_A
#endif


//
// Operation/queue start/end notification. These are ordinal values.
//
#define SPFILENOTIFY_STARTQUEUE         0x00000001
#define SPFILENOTIFY_ENDQUEUE           0x00000002
#define SPFILENOTIFY_STARTSUBQUEUE      0x00000003
#define SPFILENOTIFY_ENDSUBQUEUE        0x00000004
#define SPFILENOTIFY_STARTDELETE        0x00000005
#define SPFILENOTIFY_ENDDELETE          0x00000006
#define SPFILENOTIFY_DELETEERROR        0x00000007
#define SPFILENOTIFY_STARTRENAME        0x00000008
#define SPFILENOTIFY_ENDRENAME          0x00000009
#define SPFILENOTIFY_RENAMEERROR        0x0000000a
#define SPFILENOTIFY_STARTCOPY          0x0000000b
#define SPFILENOTIFY_ENDCOPY            0x0000000c
#define SPFILENOTIFY_COPYERROR          0x0000000d
#define SPFILENOTIFY_NEEDMEDIA          0x0000000e
#define SPFILENOTIFY_QUEUESCAN          0x0000000f
//
// These are used with SetupIterateCabinet().
//
#define SPFILENOTIFY_CABINETINFO        0x00000010
#define SPFILENOTIFY_FILEINCABINET      0x00000011
#define SPFILENOTIFY_NEEDNEWCABINET     0x00000012
#define SPFILENOTIFY_FILEEXTRACTED      0x00000013
#define SPFILENOTIFY_FILEOPDELAYED      0x00000014
//
// These are used for backup operations
//
#define SPFILENOTIFY_STARTBACKUP        0x00000015
#define SPFILENOTIFY_BACKUPERROR        0x00000016
#define SPFILENOTIFY_ENDBACKUP          0x00000017
//
// Extended notification for SetupScanFileQueue(Flags=SPQ_SCAN_USE_CALLBACKEX)
//
#define SPFILENOTIFY_QUEUESCAN_EX       0x00000018

#define SPFILENOTIFY_STARTREGISTRATION  0x00000019
#define SPFILENOTIFY_ENDREGISTRATION    0x00000020

//
// Copy notification. These are bit flags that may be combined.
//
#define SPFILENOTIFY_LANGMISMATCH       0x00010000
#define SPFILENOTIFY_TARGETEXISTS       0x00020000
#define SPFILENOTIFY_TARGETNEWER        0x00040000

//
// File operation codes and callback outcomes.
//
#define FILEOP_COPY                     0
#define FILEOP_RENAME                   1
#define FILEOP_DELETE                   2
#define FILEOP_BACKUP                   3

#define FILEOP_ABORT                    0
#define FILEOP_DOIT                     1
#define FILEOP_SKIP                     2
#define FILEOP_RETRY                    FILEOP_DOIT
#define FILEOP_NEWPATH                  4

//
// Flags in inf copy sections
//
#define COPYFLG_WARN_IF_SKIP            0x00000001  // warn if user tries to skip file
#define COPYFLG_NOSKIP                  0x00000002  // disallow skipping this file
#define COPYFLG_NOVERSIONCHECK          0x00000004  // ignore versions and overwrite target
#define COPYFLG_FORCE_FILE_IN_USE       0x00000008  // force file-in-use behavior
#define COPYFLG_NO_OVERWRITE            0x00000010  // do not copy if file exists on target
#define COPYFLG_NO_VERSION_DIALOG       0x00000020  // do not copy if target is newer
#define COPYFLG_OVERWRITE_OLDER_ONLY    0x00000040  // leave target alone if version same as source
#define COPYFLG_REPLACEONLY             0x00000400  // copy only if file exists on target
#define COPYFLG_NODECOMP                0x00000800  // don't attempt to decompress file; copy as-is
#define COPYFLG_REPLACE_BOOT_FILE       0x00001000  // file must be present upon reboot (i.e., it's
                                                    // needed by the loader); this flag implies a reboot
#define COPYFLG_NOPRUNE                 0x00002000  // never prune this file

//
// Flags in inf delete sections
// New flags go in high word
//
#define DELFLG_IN_USE                   0x00000001  // queue in-use file for delete
#define DELFLG_IN_USE1                  0x00010000  // high-word version of DELFLG_IN_USE

//
// Source and file paths. Used when notifying queue callback
// of SPFILENOTIFY_STARTxxx, SPFILENOTIFY_ENDxxx, and SPFILENOTIFY_xxxERROR.
//
typedef struct _FILEPATHS_A {
    PCSTR  Target;
    PCSTR  Source;  // not used for delete operations
    UINT   Win32Error;
    DWORD  Flags;   // such as SP_COPY_NOSKIP for copy errors
} FILEPATHS_A, *PFILEPATHS_A;

typedef struct _FILEPATHS_W {
    PCWSTR Target;
    PCWSTR Source;  // not used for delete operations
    UINT   Win32Error;
    DWORD  Flags;   // such as SP_COPY_NOSKIP for copy errors
} FILEPATHS_W, *PFILEPATHS_W;

#ifdef UNICODE
typedef FILEPATHS_W FILEPATHS;
typedef PFILEPATHS_W PFILEPATHS;
#else
typedef FILEPATHS_A FILEPATHS;
typedef PFILEPATHS_A PFILEPATHS;
#endif


//
// Structure used with SPFILENOTIFY_NEEDMEDIA
//
typedef struct _SOURCE_MEDIA_A {
    PCSTR Reserved;
    PCSTR Tagfile;          // may be NULL
    PCSTR Description;
    //
    // Pathname part and filename part of source file
    // that caused us to need the media.
    //
    PCSTR SourcePath;
    PCSTR SourceFile;
    DWORD Flags;            // subset of SP_COPY_xxx
} SOURCE_MEDIA_A, *PSOURCE_MEDIA_A;

typedef struct _SOURCE_MEDIA_W {
    PCWSTR Reserved;
    PCWSTR Tagfile;         // may be NULL
    PCWSTR Description;
    //
    // Pathname part and filename part of source file
    // that caused us to need the media.
    //
    PCWSTR SourcePath;
    PCWSTR SourceFile;
    DWORD  Flags;           // subset of SP_COPY_xxx
} SOURCE_MEDIA_W, *PSOURCE_MEDIA_W;

#ifdef UNICODE
typedef SOURCE_MEDIA_W SOURCE_MEDIA;
typedef PSOURCE_MEDIA_W PSOURCE_MEDIA;
#else
typedef SOURCE_MEDIA_A SOURCE_MEDIA;
typedef PSOURCE_MEDIA_A PSOURCE_MEDIA;
#endif

//
// Structure used with SPFILENOTIFY_CABINETINFO and
// SPFILENOTIFY_NEEDNEWCABINET
//
typedef struct _CABINET_INFO_A {
    PCSTR CabinetPath;
    PCSTR CabinetFile;
    PCSTR DiskName;
    USHORT SetId;
    USHORT CabinetNumber;
} CABINET_INFO_A, *PCABINET_INFO_A;

typedef struct _CABINET_INFO_W {
    PCWSTR CabinetPath;
    PCWSTR CabinetFile;
    PCWSTR DiskName;
    USHORT SetId;
    USHORT CabinetNumber;
} CABINET_INFO_W, *PCABINET_INFO_W;

#ifdef UNICODE
typedef CABINET_INFO_W CABINET_INFO;
typedef PCABINET_INFO_W PCABINET_INFO;
#else
typedef CABINET_INFO_A CABINET_INFO;
typedef PCABINET_INFO_A PCABINET_INFO;
#endif

//
// Structure used with SPFILENOTIFY_FILEINCABINET
//
typedef struct _FILE_IN_CABINET_INFO_A {
    PCSTR NameInCabinet;
    DWORD FileSize;
    DWORD Win32Error;
    WORD  DosDate;
    WORD  DosTime;
    WORD  DosAttribs;
    CHAR  FullTargetName[MAX_PATH];
} FILE_IN_CABINET_INFO_A, *PFILE_IN_CABINET_INFO_A;

typedef struct _FILE_IN_CABINET_INFO_W {
    PCWSTR NameInCabinet;
    DWORD  FileSize;
    DWORD  Win32Error;
    WORD   DosDate;
    WORD   DosTime;
    WORD   DosAttribs;
    WCHAR  FullTargetName[MAX_PATH];
} FILE_IN_CABINET_INFO_W, *PFILE_IN_CABINET_INFO_W;

#ifdef UNICODE
typedef FILE_IN_CABINET_INFO_W FILE_IN_CABINET_INFO;
typedef PFILE_IN_CABINET_INFO_W PFILE_IN_CABINET_INFO;
#else
typedef FILE_IN_CABINET_INFO_A FILE_IN_CABINET_INFO;
typedef PFILE_IN_CABINET_INFO_A PFILE_IN_CABINET_INFO;
#endif

//
// Structure used for SPFILENOTIFY_***REGISTRATION
// callback
//


typedef struct _SP_REGISTER_CONTROL_STATUSA {
    DWORD    cbSize;
    PCSTR    FileName;
    DWORD    Win32Error;
    DWORD    FailureCode;
} SP_REGISTER_CONTROL_STATUSA, *PSP_REGISTER_CONTROL_STATUSA;

typedef struct _SP_REGISTER_CONTROL_STATUSW {
    DWORD    cbSize;
    PCWSTR   FileName;
    DWORD    Win32Error;
    DWORD    FailureCode;
} SP_REGISTER_CONTROL_STATUSW, *PSP_REGISTER_CONTROL_STATUSW;

#ifdef UNICODE
typedef SP_REGISTER_CONTROL_STATUSW SP_REGISTER_CONTROL_STATUS;
typedef PSP_REGISTER_CONTROL_STATUSW PSP_REGISTER_CONTROL_STATUS;
#else
typedef SP_REGISTER_CONTROL_STATUSA SP_REGISTER_CONTROL_STATUS;
typedef PSP_REGISTER_CONTROL_STATUSA PSP_REGISTER_CONTROL_STATUS;
#endif


//
// valid values for SP_REGISTER_CONTROL_STATUS.FailureCode field
//

#define SPREG_SUCCESS   0x00000000
#define SPREG_LOADLIBRARY   0x00000001
#define SPREG_GETPROCADDR   0x00000002
#define SPREG_REGSVR        0x00000003
#define SPREG_DLLINSTALL    0x00000004
#define SPREG_TIMEOUT   0x00000005
#define SPREG_UNKNOWN   0xFFFFFFFF

//
// Define type for setup file queue
//
typedef PVOID HSPFILEQ;

//
// Structure used with SetupQueueCopyIndirect
//
typedef struct _SP_FILE_COPY_PARAMS_A {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCSTR    SourceRootPath;     OPTIONAL
    PCSTR    SourcePath;         OPTIONAL
    PCSTR    SourceFilename;
    PCSTR    SourceDescription;  OPTIONAL
    PCSTR    SourceTagfile;      OPTIONAL
    PCSTR    TargetDirectory;
    PCSTR    TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCSTR    SecurityDescriptor; OPTIONAL
} SP_FILE_COPY_PARAMS_A, *PSP_FILE_COPY_PARAMS_A;

typedef struct _SP_FILE_COPY_PARAMS_W {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCWSTR   SourceRootPath;     OPTIONAL
    PCWSTR   SourcePath;         OPTIONAL
    PCWSTR   SourceFilename;
    PCWSTR   SourceDescription;  OPTIONAL
    PCWSTR   SourceTagfile;      OPTIONAL
    PCWSTR   TargetDirectory;
    PCWSTR   TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCWSTR   SecurityDescriptor; OPTIONAL
} SP_FILE_COPY_PARAMS_W, *PSP_FILE_COPY_PARAMS_W;

#ifdef UNICODE
typedef SP_FILE_COPY_PARAMS_W SP_FILE_COPY_PARAMS;
typedef PSP_FILE_COPY_PARAMS_W PSP_FILE_COPY_PARAMS;
#else
typedef SP_FILE_COPY_PARAMS_A SP_FILE_COPY_PARAMS;
typedef PSP_FILE_COPY_PARAMS_A PSP_FILE_COPY_PARAMS;
#endif


//
// Define type for setup disk space list
//
typedef PVOID HDSKSPC;

//
// Define type for reference to device information set
//
typedef PVOID HDEVINFO;

//
// Device information structure (references a device instance
// that is a member of a device information set)
//
typedef struct _SP_DEVINFO_DATA {
    DWORD cbSize;
    GUID  ClassGuid;
    DWORD DevInst;    // DEVINST handle
    ULONG_PTR Reserved;
} SP_DEVINFO_DATA, *PSP_DEVINFO_DATA;

//
// Device interface information structure (references a device
// interface that is associated with the device information
// element that owns it).
//
typedef struct _SP_DEVICE_INTERFACE_DATA {
    DWORD cbSize;
    GUID  InterfaceClassGuid;
    DWORD Flags;
    ULONG_PTR Reserved;
} SP_DEVICE_INTERFACE_DATA, *PSP_DEVICE_INTERFACE_DATA;

//
// Flags for SP_DEVICE_INTERFACE_DATA.Flags field.
//
#define SPINT_ACTIVE  0x00000001
#define SPINT_DEFAULT 0x00000002
#define SPINT_REMOVED 0x00000004

//
// Backward compatibility--do not use.
//
typedef SP_DEVICE_INTERFACE_DATA  SP_INTERFACE_DEVICE_DATA;
typedef PSP_DEVICE_INTERFACE_DATA PSP_INTERFACE_DEVICE_DATA;
#define SPID_ACTIVE               SPINT_ACTIVE
#define SPID_DEFAULT              SPINT_DEFAULT
#define SPID_REMOVED              SPINT_REMOVED


typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_A {
    DWORD  cbSize;
    CHAR   DevicePath[ANYSIZE_ARRAY];
} SP_DEVICE_INTERFACE_DETAIL_DATA_A, *PSP_DEVICE_INTERFACE_DETAIL_DATA_A;

typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_W {
    DWORD  cbSize;
    WCHAR  DevicePath[ANYSIZE_ARRAY];
} SP_DEVICE_INTERFACE_DETAIL_DATA_W, *PSP_DEVICE_INTERFACE_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_W SP_DEVICE_INTERFACE_DETAIL_DATA;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_W PSP_DEVICE_INTERFACE_DETAIL_DATA;
#else
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_A SP_DEVICE_INTERFACE_DETAIL_DATA;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_A PSP_DEVICE_INTERFACE_DETAIL_DATA;
#endif

//
// Backward compatibility--do not use.
//
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_W SP_INTERFACE_DEVICE_DETAIL_DATA_W;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_W PSP_INTERFACE_DEVICE_DETAIL_DATA_W;
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_A SP_INTERFACE_DEVICE_DETAIL_DATA_A;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_A PSP_INTERFACE_DEVICE_DETAIL_DATA_A;
#ifdef UNICODE
typedef SP_INTERFACE_DEVICE_DETAIL_DATA_W SP_INTERFACE_DEVICE_DETAIL_DATA;
typedef PSP_INTERFACE_DEVICE_DETAIL_DATA_W PSP_INTERFACE_DEVICE_DETAIL_DATA;
#else
typedef SP_INTERFACE_DEVICE_DETAIL_DATA_A SP_INTERFACE_DEVICE_DETAIL_DATA;
typedef PSP_INTERFACE_DEVICE_DETAIL_DATA_A PSP_INTERFACE_DEVICE_DETAIL_DATA;
#endif


//
// Structure for detailed information on a device information set (used for
// SetupDiGetDeviceInfoListDetail which supercedes the functionality of
// SetupDiGetDeviceInfoListClass).
//
typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_A {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    CHAR   RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
} SP_DEVINFO_LIST_DETAIL_DATA_A, *PSP_DEVINFO_LIST_DETAIL_DATA_A;

typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_W {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    WCHAR  RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
} SP_DEVINFO_LIST_DETAIL_DATA_W, *PSP_DEVINFO_LIST_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DEVINFO_LIST_DETAIL_DATA_W SP_DEVINFO_LIST_DETAIL_DATA;
typedef PSP_DEVINFO_LIST_DETAIL_DATA_W PSP_DEVINFO_LIST_DETAIL_DATA;
#else
typedef SP_DEVINFO_LIST_DETAIL_DATA_A SP_DEVINFO_LIST_DETAIL_DATA;
typedef PSP_DEVINFO_LIST_DETAIL_DATA_A PSP_DEVINFO_LIST_DETAIL_DATA;
#endif


//
// Class installer function codes
//
#define DIF_SELECTDEVICE                    0x00000001
#define DIF_INSTALLDEVICE                   0x00000002
#define DIF_ASSIGNRESOURCES                 0x00000003
#define DIF_PROPERTIES                      0x00000004
#define DIF_REMOVE                          0x00000005
#define DIF_FIRSTTIMESETUP                  0x00000006
#define DIF_FOUNDDEVICE                     0x00000007
#define DIF_SELECTCLASSDRIVERS              0x00000008
#define DIF_VALIDATECLASSDRIVERS            0x00000009
#define DIF_INSTALLCLASSDRIVERS             0x0000000A
#define DIF_CALCDISKSPACE                   0x0000000B
#define DIF_DESTROYPRIVATEDATA              0x0000000C
#define DIF_VALIDATEDRIVER                  0x0000000D
#define DIF_MOVEDEVICE                      0x0000000E
#define DIF_DETECT                          0x0000000F
#define DIF_INSTALLWIZARD                   0x00000010
#define DIF_DESTROYWIZARDDATA               0x00000011
#define DIF_PROPERTYCHANGE                  0x00000012
#define DIF_ENABLECLASS                     0x00000013
#define DIF_DETECTVERIFY                    0x00000014
#define DIF_INSTALLDEVICEFILES              0x00000015
#define DIF_UNREMOVE                        0x00000016
#define DIF_SELECTBESTCOMPATDRV             0x00000017
#define DIF_ALLOW_INSTALL                   0x00000018
#define DIF_REGISTERDEVICE                  0x00000019
#define DIF_NEWDEVICEWIZARD_PRESELECT       0x0000001A
#define DIF_NEWDEVICEWIZARD_SELECT          0x0000001B
#define DIF_NEWDEVICEWIZARD_PREANALYZE      0x0000001C
#define DIF_NEWDEVICEWIZARD_POSTANALYZE     0x0000001D
#define DIF_NEWDEVICEWIZARD_FINISHINSTALL   0x0000001E
#define DIF_UNUSED1                         0x0000001F
#define DIF_INSTALLINTERFACES               0x00000020
#define DIF_DETECTCANCEL                    0x00000021
#define DIF_REGISTER_COINSTALLERS           0x00000022
#define DIF_ADDPROPERTYPAGE_ADVANCED        0x00000023
#define DIF_ADDPROPERTYPAGE_BASIC           0x00000024
#define DIF_RESERVED1                       0x00000025
#define DIF_TROUBLESHOOTER                  0x00000026
#define DIF_POWERMESSAGEWAKE                0x00000027
#define DIF_ADDREMOTEPROPERTYPAGE_ADVANCED  0x00000028

typedef UINT        DI_FUNCTION;    // Function type for device installer


//
// Device installation parameters structure (associated with a
// particular device information element, or globally with a device
// information set)
//
typedef struct _SP_DEVINSTALL_PARAMS_A {
    DWORD             cbSize;
    DWORD             Flags;
    DWORD             FlagsEx;
    HWND              hwndParent;
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    HSPFILEQ          FileQueue;
    ULONG_PTR         ClassInstallReserved;
    DWORD             Reserved;
    CHAR              DriverPath[MAX_PATH];
} SP_DEVINSTALL_PARAMS_A, *PSP_DEVINSTALL_PARAMS_A;

typedef struct _SP_DEVINSTALL_PARAMS_W {
    DWORD             cbSize;
    DWORD             Flags;
    DWORD             FlagsEx;
    HWND              hwndParent;
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    HSPFILEQ          FileQueue;
    ULONG_PTR         ClassInstallReserved;
    DWORD             Reserved;
    WCHAR             DriverPath[MAX_PATH];
} SP_DEVINSTALL_PARAMS_W, *PSP_DEVINSTALL_PARAMS_W;

#ifdef UNICODE
typedef SP_DEVINSTALL_PARAMS_W SP_DEVINSTALL_PARAMS;
typedef PSP_DEVINSTALL_PARAMS_W PSP_DEVINSTALL_PARAMS;
#else
typedef SP_DEVINSTALL_PARAMS_A SP_DEVINSTALL_PARAMS;
typedef PSP_DEVINSTALL_PARAMS_A PSP_DEVINSTALL_PARAMS;
#endif


//
// SP_DEVINSTALL_PARAMS.Flags values
//
// Flags for choosing a device
//
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L     // both class & compat list shown
#define DI_NOVCP                    0x00000008L     // don't create a new copy queue--use
                                                    // caller-supplied FileQueue
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L     // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Reboot required to take effect
#define DI_NEEDREBOOT               0x00000100L     // ""

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildDriverInfoList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list

// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

// Flag to indicate that only the the INF specified by SP_DEVINSTALL_PARAMS.DriverPath
// should be searched.
#define DI_ENUMSINGLEINF            0x00010000L

// Flag that prevents ConfigMgr from removing/re-enumerating devices during device
// registration, installation, and deletion.
#define DI_DONOTCALLCONFIGMG        0x00020000L

// The following flag can be used to install a device disabled
#define DI_INSTALLDISABLED          0x00040000L

// Flag that causes SetupDiBuildDriverInfoList to build a device's compatible driver
// list from its existing class driver list, instead of the normal INF search.
#define DI_COMPAT_FROM_CLASS        0x00080000L

// This flag is set if the Class Install params should be used.
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// returns ERROR_DI_DO_DEFAULT.
#define DI_NODI_DEFAULTACTION       0x00200000L

// The setupx flag, DI_NOSYNCPROCESSING (0x00400000L) is not support in the Setup APIs.

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop provider added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS            0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS              0x80000000L     // Don't write HW & Compat IDs on install


//
// SP_DEVINSTALL_PARAMS.FlagsEx values
//
#define DI_FLAGSEX_USEOLDINFSEARCH          0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0          0x00000002L  // SetupDiSelectDevice doesn't prompt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED                0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST              0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO            0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES            0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL         0x00000080L
#define DI_FLAGSEX_DEVICECHANGE             0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS           0x00000200L
#define DI_FLAGSEX_PROPCHANGE_PENDING       0x00000400L  // One or more device property sheets have had changes made
                                                         // to them, and need to have a DIF_PROPERTYCHANGE occur.
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS        0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE        0x00001000L
#define DI_FLAGSEX_USECLASSFORCOMPAT        0x00002000L  // Use the device's class when building compat drv list.
                                                         // (Ignored if DI_COMPAT_FROM_CLASS flag is specified.)
#define DI_FLAGSEX_OLDINF_IN_CLASSLIST      0x00004000L  // Search legacy INFs when building class driver list.
#define DI_FLAGSEX_NO_DRVREG_MODIFY         0x00008000L  // Don't run AddReg and DelReg for device's software (driver) key.
#define DI_FLAGSEX_IN_SYSTEM_SETUP          0x00010000L  // Installation is occurring during initial system setup.
#define DI_FLAGSEX_INET_DRIVER              0x00020000L  // Driver came from Windows Update
#define DI_FLAGSEX_APPENDDRIVERLIST         0x00040000L  // Cause SetupDiBuildDriverInfoList to append
                                                         // a new driver list to an existing list.
#define DI_FLAGSEX_PREINSTALLBACKUP         0x00080000L  // backup all files required by old inf before install
#define DI_FLAGSEX_BACKUPONREPLACE          0x00100000L  // backup files required by old inf as they are replaced
#define DI_FLAGSEX_DRIVERLIST_FROM_URL      0x00200000L  // build driver list from INF(s) retrieved from URL specified
                                                         // in SP_DEVINSTALL_PARAMS.DriverPath (empty string means
                                                         // Windows Update website)
#define DI_FLAGSEX_RESERVED1                0x00400000L
#define DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS 0x00800000L  // Don't include old Internet drivers when building
                                                         // a driver list.
#define DI_FLAGSEX_POWERPAGE_ADDED          0x01000000L  // class installer added their own power page
#define DI_FLAGSEX_FILTERSIMILARDRIVERS     0x02000000L  // only include similar drivers in class list
#define DI_FLAGSEX_INSTALLEDDRIVER          0x04000000L  // only add the installed driver to the class or compat
                                                         // driver list.  Used in calls to SetupDiBuildDriverInfoList
#define DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE  0X08000000L  // Don't remove identical driver nodes from the class list                                                         

//
// Class installation parameters header.  This must be the first field of any
// class install parameter structure.  The InstallFunction field must be set to
// the function code corresponding to the structure, and the cbSize field must
// be set to the size of the header structure.  E.g.,
//
// SP_ENABLECLASS_PARAMS EnableClassParams;
//
// EnableClassParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
// EnableClassParams.ClassInstallHeader.InstallFunction = DIF_ENABLECLASS;
//
typedef struct _SP_CLASSINSTALL_HEADER {
    DWORD       cbSize;
    DI_FUNCTION InstallFunction;
} SP_CLASSINSTALL_HEADER, *PSP_CLASSINSTALL_HEADER;


//
// Structure corresponding to a DIF_ENABLECLASS install function.
//
typedef struct _SP_ENABLECLASS_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    GUID                   ClassGuid;
    DWORD                  EnableMessage;
} SP_ENABLECLASS_PARAMS, *PSP_ENABLECLASS_PARAMS;

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2


//
// Structure corresponding to a DIF_MOVEDEVICE install function.
//
typedef struct _SP_MOVEDEV_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    SP_DEVINFO_DATA        SourceDeviceInfoData;
} SP_MOVEDEV_PARAMS, *PSP_MOVEDEV_PARAMS;


//
// Values indicating a change in a device's state
//
#define DICS_ENABLE      0x00000001
#define DICS_DISABLE     0x00000002
#define DICS_PROPCHANGE  0x00000003
#define DICS_START       0x00000004
#define DICS_STOP        0x00000005
//
// Values specifying the scope of a device property change
//
#define DICS_FLAG_GLOBAL         0x00000001  // make change in all hardware profiles
#define DICS_FLAG_CONFIGSPECIFIC 0x00000002  // make change in specified profile only
#define DICS_FLAG_CONFIGGENERAL  0x00000004  // 1 or more hardware profile-specific
                                             // changes to follow.
//
// Structure corresponding to a DIF_PROPERTYCHANGE install function.
//
typedef struct _SP_PROPCHANGE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD                  StateChange;
    DWORD                  Scope;
    DWORD                  HwProfile;
} SP_PROPCHANGE_PARAMS, *PSP_PROPCHANGE_PARAMS;


//
// Structure corresponding to a DIF_REMOVE install function.
//
typedef struct _SP_REMOVEDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD Scope;
    DWORD HwProfile;
} SP_REMOVEDEVICE_PARAMS, *PSP_REMOVEDEVICE_PARAMS;

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002


//
// Structure corresponding to a DIF_UNREMOVE install function.
//
typedef struct _SP_UNREMOVEDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD Scope;
    DWORD HwProfile;
} SP_UNREMOVEDEVICE_PARAMS, *PSP_UNREMOVEDEVICE_PARAMS;

#define DI_UNREMOVEDEVICE_CONFIGSPECIFIC        0x00000002


//
// Structure corresponding to a DIF_SELECTDEVICE install function.
//
typedef struct _SP_SELECTDEVICE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   Title[MAX_TITLE_LEN];
    CHAR                   Instructions[MAX_INSTRUCTION_LEN];
    CHAR                   ListLabel[MAX_LABEL_LEN];
    CHAR                   SubTitle[MAX_SUBTITLE_LEN];
    BYTE                   Reserved[2];                  // DWORD size alignment
} SP_SELECTDEVICE_PARAMS_A, *PSP_SELECTDEVICE_PARAMS_A;

typedef struct _SP_SELECTDEVICE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  Title[MAX_TITLE_LEN];
    WCHAR                  Instructions[MAX_INSTRUCTION_LEN];
    WCHAR                  ListLabel[MAX_LABEL_LEN];
    WCHAR                  SubTitle[MAX_SUBTITLE_LEN];
} SP_SELECTDEVICE_PARAMS_W, *PSP_SELECTDEVICE_PARAMS_W;

#ifdef UNICODE
typedef SP_SELECTDEVICE_PARAMS_W SP_SELECTDEVICE_PARAMS;
typedef PSP_SELECTDEVICE_PARAMS_W PSP_SELECTDEVICE_PARAMS;
#else
typedef SP_SELECTDEVICE_PARAMS_A SP_SELECTDEVICE_PARAMS;
typedef PSP_SELECTDEVICE_PARAMS_A PSP_SELECTDEVICE_PARAMS;
#endif


//
// Callback routine for giving progress notification during detection
//
typedef BOOL (CALLBACK* PDETECT_PROGRESS_NOTIFY)(
     IN PVOID ProgressNotifyParam,
     IN DWORD DetectComplete
     );

// where:
//     ProgressNotifyParam - value supplied by caller requesting detection.
//     DetectComplete - Percent completion, to be incremented by class
//                      installer, as it steps thru its detection.
//
// Return Value - If TRUE, then detection is cancelled.  Allows caller
//                requesting detection to stop detection asap.
//

//
// Structure corresponding to a DIF_DETECT install function.
//
typedef struct _SP_DETECTDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER  ClassInstallHeader;
    PDETECT_PROGRESS_NOTIFY DetectProgressNotify;
    PVOID                   ProgressNotifyParam;
} SP_DETECTDEVICE_PARAMS, *PSP_DETECTDEVICE_PARAMS;


//
// 'Add New Device' installation wizard structure (backward-compatibility
// only--respond to DIF_NEWDEVICEWIZARD_* requests instead).
//
// Structure corresponding to a DIF_INSTALLWIZARD install function.
// (NOTE: This structure is also applicable for DIF_DESTROYWIZARDDATA,
// but DIF_INSTALLWIZARD is the associated function code in the class
// installation parameter structure in both cases.)
//
// Define maximum number of dynamic wizard pages that can be added to
// hardware install wizard.
//
#define MAX_INSTALLWIZARD_DYNAPAGES             20

typedef struct _SP_INSTALLWIZARD_DATA {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD                  Flags;
    HPROPSHEETPAGE         DynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    DWORD                  NumDynamicPages;
    DWORD                  DynamicPageFlags;
    DWORD                  PrivateFlags;
    LPARAM                 PrivateData;
    HWND                   hwndWizardDlg;
} SP_INSTALLWIZARD_DATA, *PSP_INSTALLWIZARD_DATA;

//
// SP_INSTALLWIZARD_DATA.Flags values
//
#define NDW_INSTALLFLAG_DIDFACTDEFS         0x00000001
#define NDW_INSTALLFLAG_HARDWAREALLREADYIN  0x00000002
#define NDW_INSTALLFLAG_NEEDRESTART         DI_NEEDRESTART
#define NDW_INSTALLFLAG_NEEDREBOOT          DI_NEEDREBOOT
#define NDW_INSTALLFLAG_NEEDSHUTDOWN        0x00000200
#define NDW_INSTALLFLAG_EXPRESSINTRO        0x00000400
#define NDW_INSTALLFLAG_SKIPISDEVINSTALLED  0x00000800
#define NDW_INSTALLFLAG_NODETECTEDDEVS      0x00001000
#define NDW_INSTALLFLAG_INSTALLSPECIFIC     0x00002000
#define NDW_INSTALLFLAG_SKIPCLASSLIST       0x00004000
#define NDW_INSTALLFLAG_CI_PICKED_OEM       0x00008000
#define NDW_INSTALLFLAG_PCMCIAMODE          0x00010000
#define NDW_INSTALLFLAG_PCMCIADEVICE        0x00020000
#define NDW_INSTALLFLAG_USERCANCEL          0x00040000
#define NDW_INSTALLFLAG_KNOWNCLASS          0x00080000


//
// SP_INSTALLWIZARD_DATA.DynamicPageFlags values
//
// This flag is set if a Class installer has added pages to the install wizard.
//
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

//
// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back
// in the event of a conflict if you set this flag.
//
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

//
// The following flags are not used by the Windows NT hardware wizard.
//
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004


//
// Reserve a range of wizard page resource IDs for internal use.  Some of
// these IDs are for use by class installers that respond to the obsolete
// DIF_INSTALLWIZARD/DIF_DESTROYWIZARDDATA messages.  These IDs are listed
// below.
//
#define MIN_IDD_DYNAWIZ_RESOURCE_ID             10000
#define MAX_IDD_DYNAWIZ_RESOURCE_ID             11000

//
// Define wizard page resource IDs to be used when adding custom pages to the
// hardware install wizard via DIF_INSTALLWIZARD.  Pages marked with
// (CLASS INSTALLER PROVIDED) _must_ be supplied by the class installer if it
// responds to the DIF_INSTALLWIZARD request.
//

//
// Resource ID for the first page that the install wizard will go to after
// adding the class installer pages.  (CLASS INSTALLER PROVIDED)
//
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

//
// Resource ID for the page that the Select Device page will go back to.
// (CLASS INSTALLER PROVIDED)
//
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

//
// Resource ID for the page that the Select Device page will go forward to.
// (CLASS INSTALLER PROVIDED)
//
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002

//
// Resource ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc. (CLASS INSTALLER PROVIDED)
//
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

//
// Resource ID for the page that the Analyze dialog should go to if it
// continues from the analyze proc. (CLASS INSTALLER PROVIDED)
//
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

//
// Resource ID of the hardware install wizard's select device page.
// This ID can be used to go directly to the hardware install wizard's select
// device page.  (This is the resource ID of the Select Device wizard page
// retrieved via SetupDiGetWizardPage when SPWPT_SELECTDEVICE is the requested
// PageType.)
//
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

//
// Resource ID of the hardware install wizard's device analysis page.
// This ID can be use to go directly to the hardware install wizard's analysis
// page.
//
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

//
// Resource ID of the hardware install wizard's install detected devices page.
// This ID can be use to go directly to the hardware install wizard's install
// detected devices page.
//
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

//
// Resource ID of the hardware install wizard's select class page.
// This ID can be use to go directly to the hardware install wizard's select
// class page.
//
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

//
// The following class installer-provided wizard page resource IDs are not used
// by the Windows NT hardware wizard.
//
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008


//
// Structure corresponding to the following DIF_NEWDEVICEWIZARD_* install
// functions:
//
//     DIF_NEWDEVICEWIZARD_PRESELECT
//     DIF_NEWDEVICEWIZARD_SELECT
//     DIF_NEWDEVICEWIZARD_PREANALYZE
//     DIF_NEWDEVICEWIZARD_POSTANALYZE
//     DIF_NEWDEVICEWIZARD_FINISHINSTALL
//
typedef struct _SP_NEWDEVICEWIZARD_DATA {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD                  Flags;   // presently unused--must be zero.
    HPROPSHEETPAGE         DynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    DWORD                  NumDynamicPages;
    HWND                   hwndWizardDlg;
} SP_NEWDEVICEWIZARD_DATA, *PSP_NEWDEVICEWIZARD_DATA;


typedef SP_NEWDEVICEWIZARD_DATA SP_ADDPROPERTYPAGE_DATA;
typedef PSP_NEWDEVICEWIZARD_DATA PSP_ADDPROPERTYPAGE_DATA;


//
// Structure corresponding to the DIF_TROUBLESHOOTER install function
//
typedef struct _SP_TROUBLESHOOTER_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   ChmFile[MAX_PATH];
    CHAR                   HtmlTroubleShooter[MAX_PATH];
} SP_TROUBLESHOOTER_PARAMS_A, *PSP_TROUBLESHOOTER_PARAMS_A;

typedef struct _SP_TROUBLESHOOTER_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  ChmFile[MAX_PATH];
    WCHAR                  HtmlTroubleShooter[MAX_PATH];
} SP_TROUBLESHOOTER_PARAMS_W, *PSP_TROUBLESHOOTER_PARAMS_W;

#ifdef UNICODE
typedef SP_TROUBLESHOOTER_PARAMS_W SP_TROUBLESHOOTER_PARAMS;
typedef PSP_TROUBLESHOOTER_PARAMS_W PSP_TROUBLESHOOTER_PARAMS;
#else
typedef SP_TROUBLESHOOTER_PARAMS_A SP_TROUBLESHOOTER_PARAMS;
typedef PSP_TROUBLESHOOTER_PARAMS_A PSP_TROUBLESHOOTER_PARAMS;
#endif


//
// Structure corresponding to the DIF_POWERMESSAGEWAKE install function
//
typedef struct _SP_POWERMESSAGEWAKE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   PowerMessageWake[LINE_LEN*2];
} SP_POWERMESSAGEWAKE_PARAMS_A, *PSP_POWERMESSAGEWAKE_PARAMS_A;

typedef struct _SP_POWERMESSAGEWAKE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  PowerMessageWake[LINE_LEN*2];
} SP_POWERMESSAGEWAKE_PARAMS_W, *PSP_POWERMESSAGEWAKE_PARAMS_W;

#ifdef UNICODE
typedef SP_POWERMESSAGEWAKE_PARAMS_W SP_POWERMESSAGEWAKE_PARAMS;
typedef PSP_POWERMESSAGEWAKE_PARAMS_W PSP_POWERMESSAGEWAKE_PARAMS;
#else
typedef SP_POWERMESSAGEWAKE_PARAMS_A SP_POWERMESSAGEWAKE_PARAMS;
typedef PSP_POWERMESSAGEWAKE_PARAMS_A PSP_POWERMESSAGEWAKE_PARAMS;
#endif


//
// Driver information structure (member of a driver info list that may be associated
// with a particular device instance, or (globally) with a device information set)
//
typedef struct _SP_DRVINFO_DATA_V2_A {
    DWORD     cbSize;
    DWORD     DriverType;
    ULONG_PTR Reserved;
    CHAR      Description[LINE_LEN];
    CHAR      MfgName[LINE_LEN];
    CHAR      ProviderName[LINE_LEN];
    FILETIME  DriverDate;
    DWORDLONG DriverVersion;
} SP_DRVINFO_DATA_V2_A, *PSP_DRVINFO_DATA_V2_A;

typedef struct _SP_DRVINFO_DATA_V2_W {
    DWORD     cbSize;
    DWORD     DriverType;
    ULONG_PTR Reserved;
    WCHAR     Description[LINE_LEN];
    WCHAR     MfgName[LINE_LEN];
    WCHAR     ProviderName[LINE_LEN];
    FILETIME  DriverDate;
    DWORDLONG DriverVersion;
} SP_DRVINFO_DATA_V2_W, *PSP_DRVINFO_DATA_V2_W;

//
// Version 1 of the SP_DRVINFO_DATA structures, used only for compatibility
// with Windows NT 4.0/Windows 95/98 SETUPAPI.DLL
//
typedef struct _SP_DRVINFO_DATA_V1_A {
    DWORD     cbSize;
    DWORD     DriverType;
    ULONG_PTR Reserved;
    CHAR      Description[LINE_LEN];
    CHAR      MfgName[LINE_LEN];
    CHAR      ProviderName[LINE_LEN];
} SP_DRVINFO_DATA_V1_A, *PSP_DRVINFO_DATA_V1_A;

typedef struct _SP_DRVINFO_DATA_V1_W {
    DWORD     cbSize;
    DWORD     DriverType;
    ULONG_PTR Reserved;
    WCHAR     Description[LINE_LEN];
    WCHAR     MfgName[LINE_LEN];
    WCHAR     ProviderName[LINE_LEN];
} SP_DRVINFO_DATA_V1_W, *PSP_DRVINFO_DATA_V1_W;

#ifdef UNICODE
typedef SP_DRVINFO_DATA_V1_W SP_DRVINFO_DATA_V1;
typedef PSP_DRVINFO_DATA_V1_W PSP_DRVINFO_DATA_V1;
typedef SP_DRVINFO_DATA_V2_W SP_DRVINFO_DATA_V2;
typedef PSP_DRVINFO_DATA_V2_W PSP_DRVINFO_DATA_V2;
#else
typedef SP_DRVINFO_DATA_V1_A SP_DRVINFO_DATA_V1;
typedef PSP_DRVINFO_DATA_V1_A PSP_DRVINFO_DATA_V1;
typedef SP_DRVINFO_DATA_V2_A SP_DRVINFO_DATA_V2;
typedef PSP_DRVINFO_DATA_V2_A PSP_DRVINFO_DATA_V2;
#endif

#if USE_SP_DRVINFO_DATA_V1  // use version 1 driver info data structure

typedef SP_DRVINFO_DATA_V1_A SP_DRVINFO_DATA_A;
typedef PSP_DRVINFO_DATA_V1_A PSP_DRVINFO_DATA_A;
typedef SP_DRVINFO_DATA_V1_W SP_DRVINFO_DATA_W;
typedef PSP_DRVINFO_DATA_V1_W PSP_DRVINFO_DATA_W;
typedef SP_DRVINFO_DATA_V1 SP_DRVINFO_DATA;
typedef PSP_DRVINFO_DATA_V1 PSP_DRVINFO_DATA;

#else                       // use version 2 driver info data structure

typedef SP_DRVINFO_DATA_V2_A SP_DRVINFO_DATA_A;
typedef PSP_DRVINFO_DATA_V2_A PSP_DRVINFO_DATA_A;
typedef SP_DRVINFO_DATA_V2_W SP_DRVINFO_DATA_W;
typedef PSP_DRVINFO_DATA_V2_W PSP_DRVINFO_DATA_W;
typedef SP_DRVINFO_DATA_V2 SP_DRVINFO_DATA;
typedef PSP_DRVINFO_DATA_V2 PSP_DRVINFO_DATA;

#endif  // use current version of driver info data structure

//
// Driver information details structure (provides detailed information about a
// particular driver information structure)
//
typedef struct _SP_DRVINFO_DETAIL_DATA_A {
    DWORD    cbSize;
    FILETIME InfDate;
    DWORD    CompatIDsOffset;
    DWORD    CompatIDsLength;
    ULONG_PTR Reserved;
    CHAR     SectionName[LINE_LEN];
    CHAR     InfFileName[MAX_PATH];
    CHAR     DrvDescription[LINE_LEN];
    CHAR     HardwareID[ANYSIZE_ARRAY];
} SP_DRVINFO_DETAIL_DATA_A, *PSP_DRVINFO_DETAIL_DATA_A;

typedef struct _SP_DRVINFO_DETAIL_DATA_W {
    DWORD    cbSize;
    FILETIME InfDate;
    DWORD    CompatIDsOffset;
    DWORD    CompatIDsLength;
    ULONG_PTR Reserved;
    WCHAR    SectionName[LINE_LEN];
    WCHAR    InfFileName[MAX_PATH];
    WCHAR    DrvDescription[LINE_LEN];
    WCHAR    HardwareID[ANYSIZE_ARRAY];
} SP_DRVINFO_DETAIL_DATA_W, *PSP_DRVINFO_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DRVINFO_DETAIL_DATA_W SP_DRVINFO_DETAIL_DATA;
typedef PSP_DRVINFO_DETAIL_DATA_W PSP_DRVINFO_DETAIL_DATA;
#else
typedef SP_DRVINFO_DETAIL_DATA_A SP_DRVINFO_DETAIL_DATA;
typedef PSP_DRVINFO_DETAIL_DATA_A PSP_DRVINFO_DETAIL_DATA;
#endif


//
// Driver installation parameters (associated with a particular driver
// information element)
//
typedef struct _SP_DRVINSTALL_PARAMS {
    DWORD cbSize;
    DWORD Rank;
    DWORD Flags;
    DWORD_PTR PrivateData;
    DWORD Reserved;
} SP_DRVINSTALL_PARAMS, *PSP_DRVINSTALL_PARAMS;

//
// SP_DRVINSTALL_PARAMS.Flags values
//
#define DNF_DUPDESC             0x00000001  // Multiple providers have same desc
#define DNF_OLDDRIVER           0x00000002  // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST     0x00000004  // If set, this driver node will not be
                                            // displayed in any driver select dialogs.
#define DNF_NODRIVER            0x00000008  // if we want to install no driver
                                            // (e.g no mouse drv)
#define DNF_LEGACYINF           0x00000010  // this driver node comes from an old-style INF
#define DNF_CLASS_DRIVER        0x00000020  // Driver node represents a class driver
#define DNF_COMPATIBLE_DRIVER   0x00000040  // Driver node represents a compatible driver
#define DNF_INET_DRIVER         0x00000080  // Driver comes from an internet source
#define DNF_UNUSED1             0x00000100
#define DNF_INDEXED_DRIVER      0x00000200  // Driver is contained in the Windows Driver Index
#define DNF_OLD_INET_DRIVER     0x00000400  // Driver came from the Internet, but we don't currently
                                            // have access to it's source files.  Never attempt to
                                            // install a driver with this flag!
#define DNF_BAD_DRIVER          0x00000800  // Driver node should not be used at all
#define DNF_DUPPROVIDER         0x00001000  // Multiple drivers have the same provider and desc

//
// Rank values (the lower the Rank number, the better the Rank)
//
#define DRIVER_HARDWAREID_RANK  0x00000FFF  // Any rank less than or equal to this
                                            // value is a trusted HardwareID match

#define DRIVER_COMPATID_RANK    0x00003FFF  // Any rank less than or equal to this
                                            // (and greater than DRIVER_HARDWAREID_RANK)
                                            // is a trusted CompatibleID match

#define DRIVER_UNTRUSTED_RANK   0x00008000  // Any rank with this bit set is an "untrusted"
                                            // rank, meaning (a) the INF was unsigned, and
                                            // (b) there was no NT-specific decoration to
                                            // explicitly indicate that the INF supports
                                            // Windows NT/200x

#define DRIVER_UNTRUSTED_HARDWAREID_RANK  0x00008FFF  // Any rank less than or equal to
                                                      // this value (and greater than or
                                                      // equal to DRIVER_UNTRUSTED_RANK)
                                                      // is an untrusted HardwareID match

#define DRIVER_UNTRUSTED_COMPATID_RANK    0x0000BFFF  // Any rank less than or equal to
                                                      // this value (and greater than
                                                      // DRIVER_UNTRUSTED_HARDWAREID_RANK)
                                                      // is an untrusted CompatibleID match

//
// Setup callback routine for comparing detection signatures
//
typedef DWORD (CALLBACK* PSP_DETSIG_CMPPROC)(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext      OPTIONAL
    );


//
// Define context structure handed to co-installers
//
typedef struct _COINSTALLER_CONTEXT_DATA {
    BOOL  PostProcessing;
    DWORD InstallResult;
    PVOID PrivateData;
} COINSTALLER_CONTEXT_DATA, *PCOINSTALLER_CONTEXT_DATA;


//
// Structure containing class image list information.
//
typedef struct _SP_CLASSIMAGELIST_DATA {
    DWORD      cbSize;
    HIMAGELIST ImageList;
    ULONG_PTR  Reserved;
} SP_CLASSIMAGELIST_DATA, *PSP_CLASSIMAGELIST_DATA;


//
// Structure to be passed as first parameter (LPVOID lpv) to ExtensionPropSheetPageProc
// entry point in setupapi.dll or to "EnumPropPages32" or "BasicProperties32" entry
// points provided by class/device property page providers.  Used to retrieve a handle
// (or, potentially, multiple handles) to property pages for a specified property page type.
//
typedef struct _SP_PROPSHEETPAGE_REQUEST {
    DWORD            cbSize;
    DWORD            PageRequested;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
} SP_PROPSHEETPAGE_REQUEST, *PSP_PROPSHEETPAGE_REQUEST;

//
// Property sheet codes used in SP_PROPSHEETPAGE_REQUEST.PageRequested
//
#define SPPSR_SELECT_DEVICE_RESOURCES      1    // supplied by setupapi.dll
#define SPPSR_ENUM_BASIC_DEVICE_PROPERTIES 2    // supplied by device's BasicProperties32 provider
#define SPPSR_ENUM_ADV_DEVICE_PROPERTIES   3    // supplied by class and/or device's EnumPropPages32 provider


//
// Structure used with SetupGetBackupQueue
//
typedef struct _SP_BACKUP_QUEUE_PARAMS_A {
    DWORD    cbSize;
    CHAR     FullInfPath[MAX_PATH];             // buffer to hold ANSI pathname of INF file
    INT      FilenameOffset;                    // offset in CHAR's of filename part (after '\')
} SP_BACKUP_QUEUE_PARAMS_A, *PSP_BACKUP_QUEUE_PARAMS_A;

typedef struct _SP_BACKUP_QUEUE_PARAMS_W {
    DWORD    cbSize;
    WCHAR    FullInfPath[MAX_PATH];             // buffer to hold UNICODE pathname of INF file
    INT      FilenameOffset;                    // offset in WCHAR's of filename part (after '\')
} SP_BACKUP_QUEUE_PARAMS_W, *PSP_BACKUP_QUEUE_PARAMS_W;

#ifdef UNICODE
typedef SP_BACKUP_QUEUE_PARAMS_W SP_BACKUP_QUEUE_PARAMS;
typedef PSP_BACKUP_QUEUE_PARAMS_W PSP_BACKUP_QUEUE_PARAMS;
#else
typedef SP_BACKUP_QUEUE_PARAMS_A SP_BACKUP_QUEUE_PARAMS;
typedef PSP_BACKUP_QUEUE_PARAMS_A PSP_BACKUP_QUEUE_PARAMS;
#endif

//
// Setupapi-specific error codes
//
// Inf parse outcomes
//
#define ERROR_EXPECTED_SECTION_NAME  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0)
#define ERROR_BAD_SECTION_NAME_LINE  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|1)
#define ERROR_SECTION_NAME_TOO_LONG  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|2)
#define ERROR_GENERAL_SYNTAX         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|3)
//
// Inf runtime errors
//
#define ERROR_WRONG_INF_STYLE        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x100)
#define ERROR_SECTION_NOT_FOUND      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x101)
#define ERROR_LINE_NOT_FOUND         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x102)
#define ERROR_NO_BACKUP              (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x103)
//
// Device Installer/other errors
//
#define ERROR_NO_ASSOCIATED_CLASS         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x200)
#define ERROR_CLASS_MISMATCH              (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x201)
#define ERROR_DUPLICATE_FOUND             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x202)
#define ERROR_NO_DRIVER_SELECTED          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x203)
#define ERROR_KEY_DOES_NOT_EXIST          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x204)
#define ERROR_INVALID_DEVINST_NAME        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x205)
#define ERROR_INVALID_CLASS               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x206)
#define ERROR_DEVINST_ALREADY_EXISTS      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x207)
#define ERROR_DEVINFO_NOT_REGISTERED      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x208)
#define ERROR_INVALID_REG_PROPERTY        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x209)
#define ERROR_NO_INF                      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20A)
#define ERROR_NO_SUCH_DEVINST             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20B)
#define ERROR_CANT_LOAD_CLASS_ICON        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20C)
#define ERROR_INVALID_CLASS_INSTALLER     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20D)
#define ERROR_DI_DO_DEFAULT               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20E)
#define ERROR_DI_NOFILECOPY               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20F)
#define ERROR_INVALID_HWPROFILE           (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x210)
#define ERROR_NO_DEVICE_SELECTED          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x211)
#define ERROR_DEVINFO_LIST_LOCKED         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x212)
#define ERROR_DEVINFO_DATA_LOCKED         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x213)
#define ERROR_DI_BAD_PATH                 (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x214)
#define ERROR_NO_CLASSINSTALL_PARAMS      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x215)
#define ERROR_FILEQUEUE_LOCKED            (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x216)
#define ERROR_BAD_SERVICE_INSTALLSECT     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x217)
#define ERROR_NO_CLASS_DRIVER_LIST        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x218)
#define ERROR_NO_ASSOCIATED_SERVICE       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x219)
#define ERROR_NO_DEFAULT_DEVICE_INTERFACE (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21A)
#define ERROR_DEVICE_INTERFACE_ACTIVE     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21B)
#define ERROR_DEVICE_INTERFACE_REMOVED    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21C)
#define ERROR_BAD_INTERFACE_INSTALLSECT   (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21D)
#define ERROR_NO_SUCH_INTERFACE_CLASS     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21E)
#define ERROR_INVALID_REFERENCE_STRING    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21F)
#define ERROR_INVALID_MACHINENAME         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x220)
#define ERROR_REMOTE_COMM_FAILURE         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x221)
#define ERROR_MACHINE_UNAVAILABLE         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x222)
#define ERROR_NO_CONFIGMGR_SERVICES       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x223)
#define ERROR_INVALID_PROPPAGE_PROVIDER   (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x224)
#define ERROR_NO_SUCH_DEVICE_INTERFACE    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x225)
#define ERROR_DI_POSTPROCESSING_REQUIRED  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x226)
#define ERROR_INVALID_COINSTALLER         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x227)
#define ERROR_NO_COMPAT_DRIVERS           (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x228)
#define ERROR_NO_DEVICE_ICON              (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x229)
#define ERROR_INVALID_INF_LOGCONFIG       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22A)
#define ERROR_DI_DONT_INSTALL             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22B)
#define ERROR_INVALID_FILTER_DRIVER       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22C)
#define ERROR_NON_WINDOWS_NT_DRIVER       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22D)
#define ERROR_NON_WINDOWS_DRIVER          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22E)
#define ERROR_NO_CATALOG_FOR_OEM_INF      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22F)
#define ERROR_DEVINSTALL_QUEUE_NONNATIVE  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x230)
#define ERROR_NOT_DISABLEABLE             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x231)
#define ERROR_CANT_REMOVE_DEVINST         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x232)


//
// Backward compatibility--do not use.
//
#define ERROR_NO_DEFAULT_INTERFACE_DEVICE ERROR_NO_DEFAULT_DEVICE_INTERFACE
#define ERROR_INTERFACE_DEVICE_ACTIVE     ERROR_DEVICE_INTERFACE_ACTIVE
#define ERROR_INTERFACE_DEVICE_REMOVED    ERROR_DEVICE_INTERFACE_REMOVED
#define ERROR_NO_SUCH_INTERFACE_DEVICE    ERROR_NO_SUCH_DEVICE_INTERFACE


//
// Win9x migration DLL error code
//
#define ERROR_NOT_INSTALLED (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x1000)


WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationA(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

//
// SearchControl flags for SetupGetInfInformation
//
#define INFINFO_INF_SPEC_IS_HINF        1
#define INFINFO_INF_NAME_IS_ABSOLUTE    2
#define INFINFO_DEFAULT_SEARCH          3
#define INFINFO_REVERSE_DEFAULT_SEARCH  4
#define INFINFO_INF_PATH_LIST_SEARCH    5

#ifdef UNICODE
#define SetupGetInfInformation SetupGetInfInformationW
#else
#define SetupGetInfInformation SetupGetInfInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueryInfFileInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryInfFileInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryInfFileInformation SetupQueryInfFileInformationW
#else
#define SetupQueryInfFileInformation SetupQueryInfFileInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueryInfOriginalFileInformationA(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO     AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_A OriginalFileInfo
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryInfOriginalFileInformationW(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO     AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_W OriginalFileInfo
    );

#ifdef UNICODE
#define SetupQueryInfOriginalFileInformation SetupQueryInfOriginalFileInformationW
#else
#define SetupQueryInfOriginalFileInformation SetupQueryInfOriginalFileInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCSTR               Key,              OPTIONAL
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryInfVersionInformation SetupQueryInfVersionInformationW
#else
#define SetupQueryInfVersionInformation SetupQueryInfVersionInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetInfFileListA(
    IN  PCSTR  DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetInfFileListW(
    IN  PCWSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetInfFileList SetupGetInfFileListW
#else
#define SetupGetInfFileList SetupGetInfFileListA
#endif


WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    );

WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileA(
    IN  PCSTR FileName,
    IN  PCSTR InfClass,     OPTIONAL
    IN  DWORD InfStyle,
    OUT PUINT ErrorLine     OPTIONAL
    );

#ifdef UNICODE
#define SetupOpenInfFile SetupOpenInfFileW
#else
#define SetupOpenInfFile SetupOpenInfFileA
#endif


WINSETUPAPI
HINF
WINAPI
SetupOpenMasterInf(
    VOID
    );


WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileA(
    IN  PCSTR FileName,     OPTIONAL
    IN  HINF  InfHandle,
    OUT PUINT ErrorLine     OPTIONAL
    );

#ifdef UNICODE
#define SetupOpenAppendInfFile SetupOpenAppendInfFileW
#else
#define SetupOpenAppendInfFile SetupOpenAppendInfFileA
#endif


WINSETUPAPI
VOID
WINAPI
SetupCloseInfFile(
    IN HINF InfHandle
    );


WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  PCSTR       Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

#ifdef UNICODE
#define SetupFindFirstLine SetupFindFirstLineW
#else
#define SetupFindFirstLine SetupFindFirstLineA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    );


WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineA(
    IN  PINFCONTEXT ContextIn,
    IN  PCSTR       Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    );

WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    );

#ifdef UNICODE
#define SetupFindNextMatchLine SetupFindNextMatchLineW
#else
#define SetupFindNextMatchLine SetupFindNextMatchLineA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

#ifdef UNICODE
#define SetupGetLineByIndex SetupGetLineByIndexW
#else
#define SetupGetLineByIndex SetupGetLineByIndexA
#endif


WINSETUPAPI
LONG
WINAPI
SetupGetLineCountA(
    IN HINF  InfHandle,
    IN PCSTR Section
    );

WINSETUPAPI
LONG
WINAPI
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    );

#ifdef UNICODE
#define SetupGetLineCount SetupGetLineCountW
#else
#define SetupGetLineCount SetupGetLineCountA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextA(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    IN  PCSTR       Key,              OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetLineText SetupGetLineTextW
#else
#define SetupGetLineText SetupGetLineTextA
#endif


WINSETUPAPI
DWORD
WINAPI
SetupGetFieldCount(
    IN PINFCONTEXT Context
    );


WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetStringField SetupGetStringFieldW
#else
#define SetupGetStringField SetupGetStringFieldA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    );


WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetMultiSzField SetupGetMultiSzFieldW
#else
#define SetupGetMultiSzField SetupGetMultiSzFieldA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );


WINSETUPAPI
DWORD
WINAPI
SetupGetFileCompressionInfoA(
    IN  PCSTR   SourceFileName,
    OUT PSTR   *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    );

WINSETUPAPI
DWORD
WINAPI
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    );

#ifdef UNICODE
#define SetupGetFileCompressionInfo SetupGetFileCompressionInfoW
#else
#define SetupGetFileCompressionInfo SetupGetFileCompressionInfoA
#endif


//
// Compression types
//
#define FILE_COMPRESSION_NONE       0
#define FILE_COMPRESSION_WINLZA     1
#define FILE_COMPRESSION_MSZIP      2
#define FILE_COMPRESSION_NTCAB      3


WINSETUPAPI
DWORD
WINAPI
SetupDecompressOrCopyFileA(
    IN PCSTR SourceFileName,
    IN PCSTR TargetFileName,
    IN PUINT CompressionType OPTIONAL
    );

WINSETUPAPI
DWORD
WINAPI
SetupDecompressOrCopyFileW(
    IN PCWSTR SourceFileName,
    IN PCWSTR TargetFileName,
    IN PUINT  CompressionType OPTIONAL
    );

#ifdef UNICODE
#define SetupDecompressOrCopyFile SetupDecompressOrCopyFileW
#else
#define SetupDecompressOrCopyFile SetupDecompressOrCopyFileA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileLocationA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceFileLocation SetupGetSourceFileLocationW
#else
#define SetupGetSourceFileLocation SetupGetSourceFileLocationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileSizeA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCSTR       FileName,       OPTIONAL
    IN  PCSTR       Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileSizeW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCWSTR      FileName,       OPTIONAL
    IN  PCWSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceFileSize SetupGetSourceFileSizeW
#else
#define SetupGetSourceFileSize SetupGetSourceFileSizeA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetTargetPathA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetTargetPathW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetTargetPath SetupGetTargetPathW
#else
#define SetupGetTargetPath SetupGetTargetPathA
#endif


//
// Define flags for SourceList APIs.
//
#define SRCLIST_TEMPORARY       0x00000001
#define SRCLIST_NOBROWSE        0x00000002
#define SRCLIST_SYSTEM          0x00000010
#define SRCLIST_USER            0x00000020
#define SRCLIST_SYSIFADMIN      0x00000040
#define SRCLIST_SUBDIRS         0x00000100
#define SRCLIST_APPEND          0x00000200
#define SRCLIST_NOSTRIPPLATFORM 0x00000400


WINSETUPAPI
BOOL
WINAPI
SetupSetSourceListA(
    IN DWORD  Flags,
    IN PCSTR *SourceList,
    IN UINT   SourceCount
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetSourceListW(
    IN DWORD   Flags,
    IN PCWSTR *SourceList,
    IN UINT    SourceCount
    );

#ifdef UNICODE
#define SetupSetSourceList SetupSetSourceListW
#else
#define SetupSetSourceList SetupSetSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupCancelTemporarySourceList(
    VOID
    );


WINSETUPAPI
BOOL
WINAPI
SetupAddToSourceListA(
    IN DWORD Flags,
    IN PCSTR Source
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddToSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    );

#ifdef UNICODE
#define SetupAddToSourceList SetupAddToSourceListW
#else
#define SetupAddToSourceList SetupAddToSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromSourceListA(
    IN DWORD Flags,
    IN PCSTR Source
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    );

#ifdef UNICODE
#define SetupRemoveFromSourceList SetupRemoveFromSourceListW
#else
#define SetupRemoveFromSourceList SetupRemoveFromSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQuerySourceListA(
    IN  DWORD   Flags,
    OUT PCSTR **List,
    OUT PUINT   Count
    );

WINSETUPAPI
BOOL
WINAPI
SetupQuerySourceListW(
    IN  DWORD    Flags,
    OUT PCWSTR **List,
    OUT PUINT    Count
    );

#ifdef UNICODE
#define SetupQuerySourceList SetupQuerySourceListW
#else
#define SetupQuerySourceList SetupQuerySourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupFreeSourceListA(
    IN OUT PCSTR **List,
    IN     UINT    Count
    );

WINSETUPAPI
BOOL
WINAPI
SetupFreeSourceListW(
    IN OUT PCWSTR **List,
    IN     UINT     Count
    );

#ifdef UNICODE
#define SetupFreeSourceList SetupFreeSourceListW
#else
#define SetupFreeSourceList SetupFreeSourceListA
#endif


WINSETUPAPI
UINT
WINAPI
SetupPromptForDiskA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  DiskName,         OPTIONAL
    IN  PCSTR  PathToSource,     OPTIONAL
    IN  PCSTR  FileSought,
    IN  PCSTR  TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PSTR   PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize
    );

WINSETUPAPI
UINT
WINAPI
SetupPromptForDiskW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR DiskName,         OPTIONAL
    IN  PCWSTR PathToSource,     OPTIONAL
    IN  PCWSTR FileSought,
    IN  PCWSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PWSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize
    );

#ifdef UNICODE
#define SetupPromptForDisk SetupPromptForDiskW
#else
#define SetupPromptForDisk SetupPromptForDiskA
#endif


WINSETUPAPI
UINT
WINAPI
SetupCopyErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  DiskName,        OPTIONAL
    IN  PCSTR  PathToSource,
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PSTR   PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    );

WINSETUPAPI
UINT
WINAPI
SetupCopyErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR DiskName,        OPTIONAL
    IN  PCWSTR PathToSource,
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PWSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    );

#ifdef UNICODE
#define SetupCopyError SetupCopyErrorW
#else
#define SetupCopyError SetupCopyErrorA
#endif


WINSETUPAPI
UINT
WINAPI
SetupRenameErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

WINSETUPAPI
UINT
WINAPI
SetupRenameErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

#ifdef UNICODE
#define SetupRenameError SetupRenameErrorW
#else
#define SetupRenameError SetupRenameErrorA
#endif


WINSETUPAPI
UINT
WINAPI
SetupDeleteErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

WINSETUPAPI
UINT
WINAPI
SetupDeleteErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

#ifdef UNICODE
#define SetupDeleteError SetupDeleteErrorW
#else
#define SetupDeleteError SetupDeleteErrorA
#endif

WINSETUPAPI
UINT
WINAPI
SetupBackupErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  BackupFile,
    IN  PCSTR  TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

WINSETUPAPI
UINT
WINAPI
SetupBackupErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR BackupFile,
    IN  PCWSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

#ifdef UNICODE
#define SetupBackupError SetupBackupErrorW
#else
#define SetupBackupError SetupBackupErrorA
#endif


//
// Styles for SetupPromptForDisk, SetupCopyError,
// SetupRenameError, SetupDeleteError
//
#define IDF_NOBROWSE                    0x00000001
#define IDF_NOSKIP                      0x00000002
#define IDF_NODETAILS                   0x00000004
#define IDF_NOCOMPRESSED                0x00000008
#define IDF_CHECKFIRST                  0x00000100
#define IDF_NOBEEP                      0x00000200
#define IDF_NOFOREGROUND                0x00000400
#define IDF_WARNIFSKIP                  0x00000800
#define IDF_NOREMOVABLEMEDIAPROMPT      0x00001000
#define IDF_USEDISKNAMEASPROMPT         0x00002000
#define IDF_OEMDISK                     0x80000000

//
// Return values for SetupPromptForDisk, SetupCopyError,
// SetupRenameError, SetupDeleteError, SetupBackupError
//
#define DPROMPT_SUCCESS         0
#define DPROMPT_CANCEL          1
#define DPROMPT_SKIPFILE        2
#define DPROMPT_BUFFERTOOSMALL  3
#define DPROMPT_OUTOFMEMORY     4


WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdA(
    IN HINF  InfHandle,
    IN DWORD Id,            OPTIONAL
    IN PCSTR Directory      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory     OPTIONAL
    );

#ifdef UNICODE
#define SetupSetDirectoryId SetupSetDirectoryIdW
#else
#define SetupSetDirectoryId SetupSetDirectoryIdA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdExA(
    IN HINF  InfHandle,
    IN DWORD Id,            OPTIONAL
    IN PCSTR Directory,     OPTIONAL
    IN DWORD Flags,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    );

#ifdef UNICODE
#define SetupSetDirectoryIdEx SetupSetDirectoryIdExW
#else
#define SetupSetDirectoryIdEx SetupSetDirectoryIdExA
#endif

//
// Flags for SetupSetDirectoryIdEx
//
#define SETDIRID_NOT_FULL_PATH      0x00000001


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceInfoA(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceInfo SetupGetSourceInfoW
#else
#define SetupGetSourceInfo SetupGetSourceInfoA
#endif

//
// InfoDesired values for SetupGetSourceInfo
//

#define SRCINFO_PATH            1
#define SRCINFO_TAGFILE         2
#define SRCINFO_DESCRIPTION     3
#define SRCINFO_FLAGS           4


WINSETUPAPI
BOOL
WINAPI
SetupInstallFileA(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCSTR               SourceFile,        OPTIONAL
    IN PCSTR               SourcePathRoot,    OPTIONAL
    IN PCSTR               DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileW(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCWSTR              SourceFile,        OPTIONAL
    IN PCWSTR              SourcePathRoot,    OPTIONAL
    IN PCWSTR              DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    );

#ifdef UNICODE
#define SetupInstallFile SetupInstallFileW
#else
#define SetupInstallFile SetupInstallFileA
#endif

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExA(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCSTR               SourceFile,        OPTIONAL
    IN  PCSTR               SourcePathRoot,    OPTIONAL
    IN  PCSTR               DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExW(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCWSTR              SourceFile,        OPTIONAL
    IN  PCWSTR              SourcePathRoot,    OPTIONAL
    IN  PCWSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    );

#ifdef UNICODE
#define SetupInstallFileEx SetupInstallFileExW
#else
#define SetupInstallFileEx SetupInstallFileExA
#endif

//
// CopyStyle values for copy and queue-related APIs
//
#define SP_COPY_DELETESOURCE        0x0000001   // delete source file on successful copy
#define SP_COPY_REPLACEONLY         0x0000002   // copy only if target file already present
#define SP_COPY_NEWER               0x0000004   // copy only if source newer than or same as target
#define SP_COPY_NEWER_OR_SAME       SP_COPY_NEWER
#define SP_COPY_NOOVERWRITE         0x0000008   // copy only if target doesn't exist
#define SP_COPY_NODECOMP            0x0000010   // don't decompress source file while copying
#define SP_COPY_LANGUAGEAWARE       0x0000020   // don't overwrite file of different language
#define SP_COPY_SOURCE_ABSOLUTE     0x0000040   // SourceFile is a full source path
#define SP_COPY_SOURCEPATH_ABSOLUTE 0x0000080   // SourcePathRoot is the full path
#define SP_COPY_IN_USE_NEEDS_REBOOT 0x0000100   // System needs reboot if file in use
#define SP_COPY_FORCE_IN_USE        0x0000200   // Force target-in-use behavior
#define SP_COPY_NOSKIP              0x0000400   // Skip is disallowed for this file or section
#define SP_FLAG_CABINETCONTINUATION 0x0000800   // Used with need media notification
#define SP_COPY_FORCE_NOOVERWRITE   0x0001000   // like NOOVERWRITE but no callback nofitication
#define SP_COPY_FORCE_NEWER         0x0002000   // like NEWER but no callback nofitication
#define SP_COPY_WARNIFSKIP          0x0004000   // system critical file: warn if user tries to skip
#define SP_COPY_NOBROWSE            0x0008000   // Browsing is disallowed for this file or section
#define SP_COPY_NEWER_ONLY          0x0010000   // copy only if source file newer than target
#define SP_COPY_SOURCE_SIS_MASTER   0x0020000   // source is single-instance store master
#define SP_COPY_OEMINF_CATALOG_ONLY 0x0040000   // (SetupCopyOEMInf only) don't copy INF--just catalog
#define SP_COPY_REPLACE_BOOT_FILE   0x0080000   // file must be present upon reboot (i.e., it's
                                                // needed by the loader); this flag implies a reboot
#define SP_COPY_NOPRUNE             0x0100000   // never prune this file


WINSETUPAPI
HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    );

WINSETUPAPI
BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformA(
    IN HSPFILEQ             QueueHandle,
    IN PSP_ALTPLATFORM_INFO AlternatePlatformInfo,      OPTIONAL
    IN PCSTR                AlternateDefaultCatalogFile OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformW(
    IN HSPFILEQ             QueueHandle,
    IN PSP_ALTPLATFORM_INFO AlternatePlatformInfo,      OPTIONAL
    IN PCWSTR               AlternateDefaultCatalogFile OPTIONAL
    );

#ifdef UNICODE
#define SetupSetFileQueueAlternatePlatform SetupSetFileQueueAlternatePlatformW
#else
#define SetupSetFileQueueAlternatePlatform SetupSetFileQueueAlternatePlatformA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupSetPlatformPathOverrideA(
    IN PCSTR Override   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetPlatformPathOverrideW(
    IN PCWSTR Override  OPTIONAL
    );

#ifdef UNICODE
#define SetupSetPlatformPathOverride SetupSetPlatformPathOverrideW
#else
#define SetupSetPlatformPathOverride SetupSetPlatformPathOverrideA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,     OPTIONAL
    IN PCSTR    SourcePath,         OPTIONAL
    IN PCSTR    SourceFilename,
    IN PCSTR    SourceDescription,  OPTIONAL
    IN PCSTR    SourceTagfile,      OPTIONAL
    IN PCSTR    TargetDirectory,
    IN PCSTR    TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueCopy SetupQueueCopyW
#else
#define SetupQueueCopy SetupQueueCopyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyIndirectA(
    IN PSP_FILE_COPY_PARAMS_A CopyParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyIndirectW(
    IN PSP_FILE_COPY_PARAMS_W CopyParams
    );

#ifdef UNICODE
#define SetupQueueCopyIndirect SetupQueueCopyIndirectW
#else
#define SetupQueueCopyIndirect SetupQueueCopyIndirectA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDefaultCopyA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCSTR    SourceRootPath,
    IN PCSTR    SourceFilename,
    IN PCSTR    TargetFilename,
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDefaultCopyW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCWSTR   SourceRootPath,
    IN PCWSTR   SourceFilename,
    IN PCWSTR   TargetFilename,
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueDefaultCopy SetupQueueDefaultCopyW
#else
#define SetupQueueDefaultCopy SetupQueueDefaultCopyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueCopySectionA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section,
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueCopySectionW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section,
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueCopySection SetupQueueCopySectionW
#else
#define SetupQueueCopySection SetupQueueCopySectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    PathPart1,
    IN PCSTR    PathPart2       OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   PathPart1,
    IN PCWSTR   PathPart2       OPTIONAL
    );

#ifdef UNICODE
#define SetupQueueDelete SetupQueueDeleteW
#else
#define SetupQueueDelete SetupQueueDeleteA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section
    );

#ifdef UNICODE
#define SetupQueueDeleteSection SetupQueueDeleteSectionW
#else
#define SetupQueueDeleteSection SetupQueueDeleteSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourcePath,
    IN PCSTR    SourceFilename, OPTIONAL
    IN PCSTR    TargetPath,     OPTIONAL
    IN PCSTR    TargetFilename
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourcePath,
    IN PCWSTR   SourceFilename, OPTIONAL
    IN PCWSTR   TargetPath,     OPTIONAL
    IN PCWSTR   TargetFilename
    );

#ifdef UNICODE
#define SetupQueueRename SetupQueueRenameW
#else
#define SetupQueueRename SetupQueueRenameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section
    );

#ifdef UNICODE
#define SetupQueueRenameSection SetupQueueRenameSectionW
#else
#define SetupQueueRenameSection SetupQueueRenameSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueA(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueW(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

#ifdef UNICODE
#define SetupCommitFileQueue SetupCommitFileQueueW
#else
#define SetupCommitFileQueue SetupCommitFileQueueA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueA(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_A CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    );

WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    );

#ifdef UNICODE
#define SetupScanFileQueue SetupScanFileQueueW
#else
#define SetupScanFileQueue SetupScanFileQueueA
#endif

//
// Define flags for SetupScanFileQueue.
//
#define SPQ_SCAN_FILE_PRESENCE    0x00000001
#define SPQ_SCAN_FILE_VALIDITY    0x00000002
#define SPQ_SCAN_USE_CALLBACK     0x00000004
#define SPQ_SCAN_USE_CALLBACKEX   0x00000008
#define SPQ_SCAN_INFORM_USER      0x00000010
#define SPQ_SCAN_PRUNE_COPY_QUEUE 0x00000020

//
// Define flags used with Param2 for SPFILENOTIFY_QUEUESCAN
//
#define SPQ_DELAYED_COPY        0x00000001  // file was in use; registered for delayed copy

WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueCount(
    IN  HSPFILEQ            FileQueue,
    IN  UINT                SubQueueFileOp,
    OUT PUINT               NumOperations
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    OUT PDWORD              Flags
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               FlagMask,
    IN  DWORD               Flags
    );

//
// Flags/FlagMask for use with SetupSetFileQueueFlags and returned by SetupGetFileQueueFlags
//
#define SPQ_FLAG_BACKUP_AWARE     0x00000001  // if set, SetupCommitFileQueue will issue backup notifications

//
// Define OEM Source Type values for use in SetupCopyOEMInf.
//
#define SPOST_NONE  0
#define SPOST_PATH  1
#define SPOST_URL   2
#define SPOST_MAX   3

WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfA(
    IN  PCSTR   SourceInfFileName,
    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PSTR    DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfW(
    IN  PCWSTR  SourceInfFileName,
    IN  PCWSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PWSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PWSTR  *DestinationInfFileNameComponent OPTIONAL
    );

#ifdef UNICODE
#define SetupCopyOEMInf SetupCopyOEMInfW
#else
#define SetupCopyOEMInf SetupCopyOEMInfA
#endif


//
// Disk space list APIs
//
WINSETUPAPI
HDSKSPC
WINAPI
SetupCreateDiskSpaceListA(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    );

WINSETUPAPI
HDSKSPC
WINAPI
SetupCreateDiskSpaceListW(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    );

#ifdef UNICODE
#define SetupCreateDiskSpaceList SetupCreateDiskSpaceListW
#else
#define SetupCreateDiskSpaceList SetupCreateDiskSpaceListA
#endif

//
// Flags for SetupCreateDiskSpaceList
//
#define SPDSL_IGNORE_DISK              0x00000001  // ignore deletes and on-disk files in copies
#define SPDSL_DISALLOW_NEGATIVE_ADJUST 0x00000002


WINSETUPAPI
HDSKSPC
WINAPI
SetupDuplicateDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    );

WINSETUPAPI
HDSKSPC
WINAPI
SetupDuplicateDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    );

#ifdef UNICODE
#define SetupDuplicateDiskSpaceList SetupDuplicateDiskSpaceListW
#else
#define SetupDuplicateDiskSpaceList SetupDuplicateDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDestroyDiskSpaceList(
    IN OUT HDSKSPC DiskSpace
    );


WINSETUPAPI
BOOL
WINAPI
SetupQueryDrivesInDiskSpaceListA(
    IN  HDSKSPC DiskSpace,
    OUT PSTR    ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryDrivesInDiskSpaceListW(
    IN  HDSKSPC DiskSpace,
    OUT PWSTR   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryDrivesInDiskSpaceList SetupQueryDrivesInDiskSpaceListW
#else
#define SetupQueryDrivesInDiskSpaceList SetupQueryDrivesInDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQuerySpaceRequiredOnDriveA(
    IN  HDSKSPC   DiskSpace,
    IN  PCSTR     DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupQuerySpaceRequiredOnDriveW(
    IN  HDSKSPC   DiskSpace,
    IN  PCWSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    );

#ifdef UNICODE
#define SetupQuerySpaceRequiredOnDrive SetupQuerySpaceRequiredOnDriveW
#else
#define SetupQuerySpaceRequiredOnDrive SetupQuerySpaceRequiredOnDriveA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAdjustDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN LPCSTR   DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAdjustDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN LPCWSTR  DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

#ifdef UNICODE
#define SetupAdjustDiskSpaceList SetupAdjustDiskSpaceListW
#else
#define SetupAdjustDiskSpaceList SetupAdjustDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddToDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN PCSTR    TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddToDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN PCWSTR   TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

#ifdef UNICODE
#define SetupAddToDiskSpaceList SetupAddToDiskSpaceListW
#else
#define SetupAddToDiskSpaceList SetupAddToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupAddSectionToDiskSpaceList SetupAddSectionToDiskSpaceListW
#else
#define SetupAddSectionToDiskSpaceList SetupAddSectionToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddInstallSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddInstallSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupAddInstallSectionToDiskSpaceList SetupAddInstallSectionToDiskSpaceListW
#else
#define SetupAddInstallSectionToDiskSpaceList SetupAddInstallSectionToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PCSTR   TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PCWSTR  TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveFromDiskSpaceList SetupRemoveFromDiskSpaceListW
#else
#define SetupRemoveFromDiskSpaceList SetupRemoveFromDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveSectionFromDiskSpaceList SetupRemoveSectionFromDiskSpaceListW
#else
#define SetupRemoveSectionFromDiskSpaceList SetupRemoveSectionFromDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveInstallSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveInstallSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveInstallSectionFromDiskSpaceList SetupRemoveInstallSectionFromDiskSpaceListW
#else
#define SetupRemoveInstallSectionFromDiskSpaceList SetupRemoveInstallSectionFromDiskSpaceListA
#endif


//
// Cabinet APIs
//

WINSETUPAPI
BOOL
WINAPI
SetupIterateCabinetA(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupIterateCabinetW(
    IN  PCWSTR              CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_W MsgHandler,
    IN  PVOID               Context
    );

#ifdef UNICODE
#define SetupIterateCabinet SetupIterateCabinetW
#else
#define SetupIterateCabinet SetupIterateCabinetA
#endif


WINSETUPAPI
INT
WINAPI
SetupPromptReboot(
    IN HSPFILEQ FileQueue,  OPTIONAL
    IN HWND     Owner,
    IN BOOL     ScanOnly
    );

//
// Define flags that are returned by SetupPromptReboot
//
#define SPFILEQ_FILE_IN_USE         0x00000001
#define SPFILEQ_REBOOT_RECOMMENDED  0x00000002
#define SPFILEQ_REBOOT_IN_PROGRESS  0x00000004


WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallback(
    IN HWND OwnerWindow
    );

WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

WINSETUPAPI
VOID
WINAPI
SetupTermDefaultQueueCallback(
    IN PVOID Context
    );

WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackA(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

#ifdef UNICODE
#define SetupDefaultQueueCallback SetupDefaultQueueCallbackW
#else
#define SetupDefaultQueueCallback SetupDefaultQueueCallbackA
#endif


//
// Flags for AddReg section lines in INF.  The corresponding value
// is <ValueType> in the AddReg line format given below:
//
// <RegRootString>,<SubKey>,<ValueName>,<ValueType>,<Value>...
//
// The low word contains basic flags concerning the general data type
// and AddReg action. The high word contains values that more specifically
// identify the data type of the registry value.  The high word is ignored
// by the 16-bit Windows 95 SETUPX APIs.
//
// If <ValueType> has FLG_ADDREG_DELREG_BIT set, it will be ignored by AddReg
// (not supported by SetupX).
//
#define FLG_ADDREG_DELREG_BIT       ( 0x00008000 ) // if set, interpret as DELREG, see below

#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 )
#define FLG_ADDREG_DELVAL           ( 0x00000004 )
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only
                                                   // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists
#define FLG_ADDREG_KEYONLY_COMMON   ( 0x00002000 ) // same as FLG_ADDREG_KEYONLY but also works for DELREG
#define FLG_ADDREG_32BITKEY         ( 0x00004000 ) // make this change in the 32 bit registry.

//
// The INF may supply any arbitrary data type ordinal in the highword except
// for the following: REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ.  If this
// technique is used, then the data is given in binary format, one byte per
// field.
//
#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000                           )
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000                           )
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

//
// Flags for DelReg section lines in INF.  The corresponding value
// is <Operation> in the extended DelReg line format given below:
//
// <RegRootString>,<SubKey>,<ValueName>,<Operation>[,...]
//
// In SetupX and some versions of SetupAPI, <Operation> will be ignored and <ValueName> will
// be deleted. Use with care.
//
// The bits determined by mask FLG_DELREG_TYPE_MASK indicates type of data expected.
// <Operation> must have FLG_ADDREG_DELREG_BIT set, otherwise it is ignored and specified
// value will be deleted (allowing an AddReg section to also be used as a DelReg section)
// if <Operation> is not specified, <ValueName> will be deleted (if specified) otherwise
// <SubKey> will be deleted.
//
#define FLG_DELREG_TYPE_MASK        FLG_ADDREG_TYPE_MASK        // 0xFFFF0001
#define FLG_DELREG_TYPE_SZ          FLG_ADDREG_TYPE_SZ          // 0x00000000
#define FLG_DELREG_TYPE_MULTI_SZ    FLG_ADDREG_TYPE_MULTI_SZ    // 0x00010000
#define FLG_DELREG_TYPE_EXPAND_SZ   FLG_ADDREG_TYPE_EXPAND_SZ   // 0x00020000
#define FLG_DELREG_TYPE_BINARY      FLG_ADDREG_TYPE_BINARY      // 0x00000001
#define FLG_DELREG_TYPE_DWORD       FLG_ADDREG_TYPE_DWORD       // 0x00010001
#define FLG_DELREG_TYPE_NONE        FLG_ADDREG_TYPE_NONE        // 0x00020001
#define FLG_DELREG_KEYONLY_COMMON   FLG_ADDREG_KEYONLY_COMMON   // 0x00002000
#define FLG_DELREG_32BITKEY         FLG_ADDREG_32BITKEY         // 0x00004000
//
// <Operation> = FLG_DELREG_MULTI_SZ_DELSTRING
//               <RegRootString>,<SubKey>,<ValueName>,0x00018002,<String>
//               removes all entries matching <String> (case ignored) from multi-sz registry value
//
#define FLG_DELREG_OPERATION_MASK   (0x000000FE)
#define FLG_DELREG_MULTI_SZ_DELSTRING ( FLG_DELREG_TYPE_MULTI_SZ | FLG_ADDREG_DELREG_BIT | 0x00000002 ) // 0x00018002

//
// Flags for BitReg section lines in INF.
//
#define FLG_BITREG_CLEARBITS        ( 0x00000000 )
#define FLG_BITREG_SETBITS          ( 0x00000001 )
#define FLG_BITREG_32BITKEY         ( 0x00004000 )

//
// Flags for Ini2Reg section lines in INF.
//

#define FLG_INI2REG_32BITKEY        ( 0x00004000 )

//
// Flags for RegSvr section lines in INF
//
#define FLG_REGSVR_DLLREGISTER      ( 0x00000001 )
#define FLG_REGSVR_DLLINSTALL       ( 0x00000002 )

// Flags for RegSvr section lines in INF
//

#define FLG_PROFITEM_CURRENTUSER    ( 0x00000001 )
#define FLG_PROFITEM_DELETE         ( 0x00000002 )
#define FLG_PROFITEM_GROUP          ( 0x00000004 )
#define FLG_PROFITEM_CSIDL          ( 0x00000008 )

WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionA(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCSTR               SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCSTR               SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,         OPTIONAL
    IN PSP_FILE_CALLBACK_A MsgHandler,        OPTIONAL
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionW(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,         OPTIONAL
    IN PSP_FILE_CALLBACK_W MsgHandler,        OPTIONAL
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

#ifdef UNICODE
#define SetupInstallFromInfSection SetupInstallFromInfSectionW
#else
#define SetupInstallFromInfSection SetupInstallFromInfSectionA
#endif

//
// Flags for SetupInstallFromInfSection
//
#define SPINST_LOGCONFIG                0x00000001
#define SPINST_INIFILES                 0x00000002
#define SPINST_REGISTRY                 0x00000004
#define SPINST_INI2REG                  0x00000008
#define SPINST_FILES                    0x00000010
#define SPINST_BITREG                   0x00000020
#define SPINST_REGSVR                   0x00000040
#define SPINST_UNREGSVR                 0x00000080
#define SPINST_PROFILEITEMS             0x00000100
#define SPINST_COPYINF                  0x00000200
#define SPINST_ALL                      0x000003ff
#define SPINST_SINGLESECTION            0x00010000
#define SPINST_LOGCONFIG_IS_FORCED      0x00020000
#define SPINST_LOGCONFIGS_ARE_OVERRIDES 0x00040000
#define SPINST_REGISTERCALLBACKAWARE    0x00080000


WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionA(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCSTR    SectionName,
    IN PCSTR    SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionW(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SectionName,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    );

#ifdef UNICODE
#define SetupInstallFilesFromInfSection SetupInstallFilesFromInfSectionW
#else
#define SetupInstallFilesFromInfSection SetupInstallFilesFromInfSectionA
#endif


//
// Flags for SetupInstallServicesFromInfSection(Ex).  These flags are also used
// in the flags field of AddService or DelService lines in a device INF.  Some
// of these flags are not permitted in the non-Ex API.  These flags are marked
// as such below.
//

//
// (AddService) move service's tag to front of its group order list
//
#define SPSVCINST_TAGTOFRONT               (0x00000001)

//
// (AddService) **Ex API only** mark this service as the function driver for the
// device being installed
//
#define SPSVCINST_ASSOCSERVICE             (0x00000002)

//
// (DelService) delete the associated event log entry for a service specified in
// a DelService entry
//
#define SPSVCINST_DELETEEVENTLOGENTRY      (0x00000004)

//
// (AddService) don't overwrite display name if it already exists
//
#define SPSVCINST_NOCLOBBER_DISPLAYNAME    (0x00000008)

//
// (AddService) don't overwrite start type value if service already exists
//
#define SPSVCINST_NOCLOBBER_STARTTYPE      (0x00000010)

//
// (AddService) don't overwrite error control value if service already exists
//
#define SPSVCINST_NOCLOBBER_ERRORCONTROL   (0x00000020)

//
// (AddService) don't overwrite load order group if it already exists
//
#define SPSVCINST_NOCLOBBER_LOADORDERGROUP (0x00000040)

//
// (AddService) don't overwrite dependencies list if it already exists
//
#define SPSVCINST_NOCLOBBER_DEPENDENCIES   (0x00000080)

//
// (AddService) don't overwrite description if it already exists
//
#define SPSVCINST_NOCLOBBER_DESCRIPTION    (0x00000100)
//
// (DelService) stop the associated service specified in
// a DelService entry before deleting the service
//
#define SPSVCINST_STOPSERVICE              (0x00000200)




WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionA(
    IN HINF   InfHandle,
    IN PCSTR  SectionName,
    IN DWORD  Flags
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    );

#ifdef UNICODE
#define SetupInstallServicesFromInfSection SetupInstallServicesFromInfSectionW
#else
#define SetupInstallServicesFromInfSection SetupInstallServicesFromInfSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionExA(
    IN HINF             InfHandle,
    IN PCSTR            SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionExW(
    IN HINF             InfHandle,
    IN PCWSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    );

#ifdef UNICODE
#define SetupInstallServicesFromInfSectionEx SetupInstallServicesFromInfSectionExW
#else
#define SetupInstallServicesFromInfSectionEx SetupInstallServicesFromInfSectionExA
#endif


//
// Define handle type for Setup file log.
//
typedef PVOID HSPFILELOG;

WINSETUPAPI
HSPFILELOG
WINAPI
SetupInitializeFileLogA(
    IN PCSTR LogFileName,   OPTIONAL
    IN DWORD Flags
    );

WINSETUPAPI
HSPFILELOG
WINAPI
SetupInitializeFileLogW(
    IN PCWSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    );

#ifdef UNICODE
#define SetupInitializeFileLog SetupInitializeFileLogW
#else
#define SetupInitializeFileLog SetupInitializeFileLogA
#endif

//
// Flags for SetupInitializeFileLog
//
#define SPFILELOG_SYSTEMLOG     0x00000001  // use system log -- must be Administrator
#define SPFILELOG_FORCENEW      0x00000002  // not valid with SPFILELOG_SYSTEMLOG
#define SPFILELOG_QUERYONLY     0x00000004  // allows non-administrators to read system log


WINSETUPAPI
BOOL
WINAPI
SetupTerminateFileLog(
    IN HSPFILELOG FileLogHandle
    );


WINSETUPAPI
BOOL
WINAPI
SetupLogFileA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      SourceFilename,
    IN PCSTR      TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCSTR      DiskTagfile,      OPTIONAL
    IN PCSTR      DiskDescription,  OPTIONAL
    IN PCSTR      OtherInfo,        OPTIONAL
    IN DWORD      Flags
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogFileW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     SourceFilename,
    IN PCWSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCWSTR     DiskTagfile,      OPTIONAL
    IN PCWSTR     DiskDescription,  OPTIONAL
    IN PCWSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    );

#ifdef UNICODE
#define SetupLogFile SetupLogFileW
#else
#define SetupLogFile SetupLogFileA
#endif

//
// Flags for SetupLogFile
//
#define SPFILELOG_OEMFILE   0x00000001


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFileLogEntryA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      TargetFilename    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFileLogEntryW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     TargetFilename    OPTIONAL
    );

#ifdef UNICODE
#define SetupRemoveFileLogEntry SetupRemoveFileLogEntryW
#else
#define SetupRemoveFileLogEntry SetupRemoveFileLogEntryA
#endif


//
// Items retrievable from SetupQueryFileLog()
//
typedef enum {
    SetupFileLogSourceFilename,
    SetupFileLogChecksum,
    SetupFileLogDiskTagfile,
    SetupFileLogDiskDescription,
    SetupFileLogOtherInfo,
    SetupFileLogMax
} SetupFileLogInfo;

WINSETUPAPI
BOOL
WINAPI
SetupQueryFileLogA(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCSTR            LogSectionName,   OPTIONAL
    IN  PCSTR            TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PSTR             DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryFileLogW(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCWSTR           LogSectionName,   OPTIONAL
    IN  PCWSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PWSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryFileLog SetupQueryFileLogW
#else
#define SetupQueryFileLog SetupQueryFileLogA
#endif

//
// Text logging APIs
//
#define LogSeverity                 DWORD
#define LogSevInformation           0x00000000
#define LogSevWarning               0x00000001
#define LogSevError                 0x00000002
#define LogSevFatalError            0x00000003
#define LogSevMaximum               0x00000004

WINSETUPAPI
BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogErrorA (
    IN  LPCSTR              MessageString,
    IN  LogSeverity         Severity
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogErrorW (
    IN  LPCWSTR             MessageString,
    IN  LogSeverity         Severity
    );

#ifdef UNICODE
#define SetupLogError SetupLogErrorW
#else
#define SetupLogError SetupLogErrorA
#endif

WINSETUPAPI
VOID
WINAPI
SetupCloseLog (
    VOID
    );


//
// Backup Information API
//

WINSETUPAPI
BOOL
WINAPI
SetupGetBackupInformationA(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_A    BackupParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetBackupInformationW(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_W    BackupParams
    );

#ifdef UNICODE
#define SetupGetBackupInformation SetupGetBackupInformationW
#else
#define SetupGetBackupInformation SetupGetBackupInformationA
#endif

BOOL
SetupSetNonInteractiveMode(
    IN BOOL NonInteractiveFlag
    );

BOOL
SetupGetNonInteractiveMode(
    VOID
    );

//
// Device Installer APIs
//

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN HWND        hwndParent OPTIONAL
    );


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExW(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCWSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInfoListEx SetupDiCreateDeviceInfoListExW
#else
#define SetupDiCreateDeviceInfoListEx SetupDiCreateDeviceInfoListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailA(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A DeviceInfoSetDetailData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailW(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_W DeviceInfoSetDetailData
    );

#ifdef UNICODE
#define SetupDiGetDeviceInfoListDetail SetupDiGetDeviceInfoListDetailW
#else
#define SetupDiGetDeviceInfoListDetail SetupDiGetDeviceInfoListDetailA
#endif


//
// Flags for SetupDiCreateDeviceInfo
//
#define DICD_GENERATE_ID        0x00000001
#define DICD_INHERIT_CLASSDRVS  0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoA(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCSTR             DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCSTR             DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoW(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCWSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCWSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInfo SetupDiCreateDeviceInfoW
#else
#define SetupDiCreateDeviceInfo SetupDiCreateDeviceInfoA
#endif


//
// Flags for SetupDiOpenDeviceInfo
//
#define DIOD_INHERIT_CLASSDRVS  0x00000002
#define DIOD_CANCEL_REMOVE      0x00000004

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCSTR            DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

#ifdef UNICODE
#define SetupDiOpenDeviceInfo SetupDiOpenDeviceInfoW
#else
#define SetupDiOpenDeviceInfo SetupDiOpenDeviceInfoA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceInstanceId SetupDiGetDeviceInstanceIdW
#else
#define SetupDiGetDeviceInstanceId SetupDiGetDeviceInstanceIdA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN HDEVINFO DeviceInfoSet
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    );

//
// Backward compatibility--do not use
//
#define SetupDiEnumInterfaceDevice SetupDiEnumDeviceInterfaces


WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInterfaceA(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCSTR                      ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInterfaceW(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCWSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInterface SetupDiCreateDeviceInterfaceW
#else
#define SetupDiCreateDeviceInterface SetupDiCreateDeviceInterfaceA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiCreateInterfaceDeviceW SetupDiCreateDeviceInterfaceW
#define SetupDiCreateInterfaceDeviceA SetupDiCreateDeviceInterfaceA
#ifdef UNICODE
#define SetupDiCreateInterfaceDevice SetupDiCreateDeviceInterfaceW
#else
#define SetupDiCreateInterfaceDevice SetupDiCreateDeviceInterfaceA
#endif


//
// Flags for SetupDiOpenDeviceInterface
//
#define DIODI_NO_ADD    0x00000001

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCWSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

#ifdef UNICODE
#define SetupDiOpenDeviceInterface SetupDiOpenDeviceInterfaceW
#else
#define SetupDiOpenDeviceInterface SetupDiOpenDeviceInterfaceA
#endif

//
// Backward compatibility--do not use
//
#define SetupDiOpenInterfaceDeviceW SetupDiOpenDeviceInterfaceW
#define SetupDiOpenInterfaceDeviceA SetupDiOpenDeviceInterfaceA
#ifdef UNICODE
#define SetupDiOpenInterfaceDevice SetupDiOpenDeviceInterfaceW
#else
#define SetupDiOpenInterfaceDevice SetupDiOpenDeviceInterfaceA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceAlias(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData,
    IN  CONST GUID                *AliasInterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  AliasDeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiGetInterfaceDeviceAlias SetupDiGetDeviceInterfaceAlias


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInterfaceData(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiDeleteInterfaceDeviceData SetupDiDeleteDeviceInterfaceData


WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDeviceInterface(
    IN     HDEVINFO                  DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiRemoveInterfaceDevice SetupDiRemoveDeviceInterface


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailW(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceInterfaceDetail SetupDiGetDeviceInterfaceDetailW
#else
#define SetupDiGetDeviceInterfaceDetail SetupDiGetDeviceInterfaceDetailA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiGetInterfaceDeviceDetailW SetupDiGetDeviceInterfaceDetailW
#define SetupDiGetInterfaceDeviceDetailA SetupDiGetDeviceInterfaceDetailA
#ifdef UNICODE
#define SetupDiGetInterfaceDeviceDetail SetupDiGetDeviceInterfaceDetailW
#else
#define SetupDiGetInterfaceDeviceDetail SetupDiGetDeviceInterfaceDetailA
#endif


//
// Default install handler for DIF_INSTALLINTERFACES.
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiInstallInterfaceDevices SetupDiInstallDeviceInterfaces


//
// Default install handler for DIF_REGISTERDEVICE
//

//
// Flags for SetupDiRegisterDeviceInfo
//
#define SPRDI_FIND_DUPS        0x00000001

WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    );


//
// Ordinal values distinguishing between class drivers and
// device drivers.
// (Passed in 'DriverType' parameter of driver information list APIs)
//
#define SPDIT_NODRIVER           0x00000000
#define SPDIT_CLASSDRIVER        0x00000001
#define SPDIT_COMPATDRIVER       0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiCancelDriverInfoSearch(
    IN HDEVINFO DeviceInfoSet
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    );

#ifdef UNICODE
#define SetupDiEnumDriverInfo SetupDiEnumDriverInfoW
#else
#define SetupDiEnumDriverInfo SetupDiEnumDriverInfoA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    );

#ifdef UNICODE
#define SetupDiGetSelectedDriver SetupDiGetSelectedDriverW
#else
#define SetupDiGetSelectedDriver SetupDiGetSelectedDriverA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverA(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_A DriverInfoData  OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverW(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_W DriverInfoData  OPTIONAL
    );

#ifdef UNICODE
#define SetupDiSetSelectedDriver SetupDiSetSelectedDriverW
#else
#define SetupDiSetSelectedDriver SetupDiSetSelectedDriverA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_A        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_A DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_W        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDriverInfoDetail SetupDiGetDriverInfoDetailW
#else
#define SetupDiGetDriverInfoDetail SetupDiGetDriverInfoDetailA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDriverInfoList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    );


//
// Flags controlling what is included in the device information set built
// by SetupDiGetClassDevs
//
#define DIGCF_DEFAULT           0x00000001  // only valid with DIGCF_DEVICEINTERFACE
#define DIGCF_PRESENT           0x00000002
#define DIGCF_ALLCLASSES        0x00000004
#define DIGCF_PROFILE           0x00000008
#define DIGCF_DEVICEINTERFACE   0x00000010

//
// Backward compatibility--do not use.
//
#define DIGCF_INTERFACEDEVICE DIGCF_DEVICEINTERFACE


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCSTR       Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsW(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    );

#ifdef UNICODE
#define SetupDiGetClassDevs SetupDiGetClassDevsW
#else
#define SetupDiGetClassDevs SetupDiGetClassDevsA
#endif


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsExA(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCSTR       Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCSTR       MachineName,   OPTIONAL
    IN PVOID       Reserved
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsExW(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCWSTR      Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCWSTR      MachineName,   OPTIONAL
    IN PVOID       Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassDevsEx SetupDiGetClassDevsExW
#else
#define SetupDiGetClassDevsEx SetupDiGetClassDevsExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetINFClassA(
    IN  PCSTR  InfName,
    OUT LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetINFClassW(
    IN  PCWSTR InfName,
    OUT LPGUID ClassGuid,
    OUT PWSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetINFClass SetupDiGetINFClassW
#else
#define SetupDiGetINFClass SetupDiGetINFClassA
#endif


//
// Flags controlling exclusion from the class information list built
// by SetupDiBuildClassInfoList(Ex)
//
#define DIBCI_NOINSTALLCLASS   0x00000001
#define DIBCI_NODISPLAYCLASS   0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoList(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoListExA(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoListExW(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiBuildClassInfoListEx SetupDiBuildClassInfoListExW
#else
#define SetupDiBuildClassInfoListEx SetupDiBuildClassInfoListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetClassDescription SetupDiGetClassDescriptionW
#else
#define SetupDiGetClassDescription SetupDiGetClassDescriptionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCSTR       MachineName,          OPTIONAL
    IN  PVOID       Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionExW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCWSTR      MachineName,          OPTIONAL
    IN  PVOID       Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassDescriptionEx SetupDiGetClassDescriptionExW
#else
#define SetupDiGetClassDescriptionEx SetupDiGetClassDescriptionExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_SELECTDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSelectDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_SELECTBESTCOMPATDRV
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_INSTALLDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_INSTALLDEVICEFILES
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDriverFiles(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_REGISTER_COINSTALLERS
//
WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_REMOVE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_UNREMOVE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiUnremoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_MOVEDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiMoveDuplicateDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DestinationDeviceInfoData
    );


//
// Default install handler for DIF_PROPERTYCHANGE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiChangeState(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassA(
    IN HWND     hwndParent,  OPTIONAL
    IN PCSTR    InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassW(
    IN HWND     hwndParent,  OPTIONAL
    IN PCWSTR   InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    );

#ifdef UNICODE
#define SetupDiInstallClass SetupDiInstallClassW
#else
#define SetupDiInstallClass SetupDiInstallClassA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassExA(
    IN HWND        hwndParent,         OPTIONAL
    IN PCSTR       InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassExW(
    IN HWND        hwndParent,         OPTIONAL
    IN PCWSTR      InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    );

#ifdef UNICODE
#define SetupDiInstallClassEx SetupDiInstallClassExW
#else
#define SetupDiInstallClassEx SetupDiInstallClassExA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKey(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN REGSAM      samDesired
    );


//
// Flags for SetupDiOpenClassRegKeyEx
//
#define DIOCR_INSTALLER   0x00000001    // class installer registry branch
#define DIOCR_INTERFACE   0x00000002    // interface class registry branch

WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKeyExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKeyExW(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCWSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    );

#ifdef UNICODE
#define SetupDiOpenClassRegKeyEx SetupDiOpenClassRegKeyExW
#else
#define SetupDiOpenClassRegKeyEx SetupDiOpenClassRegKeyExA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyA(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCSTR                     InfSectionName       OPTIONAL
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyW(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCWSTR                    InfSectionName       OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInterfaceRegKey SetupDiCreateDeviceInterfaceRegKeyW
#else
#define SetupDiCreateDeviceInterfaceRegKey SetupDiCreateDeviceInterfaceRegKeyA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiCreateInterfaceDeviceRegKeyW SetupDiCreateDeviceInterfaceRegKeyW
#define SetupDiCreateInterfaceDeviceRegKeyA SetupDiCreateDeviceInterfaceRegKeyA
#ifdef UNICODE
#define SetupDiCreateInterfaceDeviceRegKey SetupDiCreateDeviceInterfaceRegKeyW
#else
#define SetupDiCreateInterfaceDeviceRegKey SetupDiCreateDeviceInterfaceRegKeyA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired
    );

//
// Backward compatibility--do not use.
//
#define SetupDiOpenInterfaceDeviceRegKey SetupDiOpenDeviceInterfaceRegKey


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved
    );

//
// Backward compatibility--do not use.
//
#define SetupDiDeleteInterfaceDeviceRegKey SetupDiDeleteDeviceInterfaceRegKey


//
// KeyType values for SetupDiCreateDevRegKey, SetupDiOpenDevRegKey, and
// SetupDiDeleteDevRegKey.
//
#define DIREG_DEV       0x00000001          // Open/Create/Delete device key
#define DIREG_DRV       0x00000002          // Open/Create/Delete driver key
#define DIREG_BOTH      0x00000004          // Delete both driver and Device key

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyA(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCSTR            InfSectionName  OPTIONAL
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyW(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCWSTR           InfSectionName  OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDevRegKey SetupDiCreateDevRegKeyW
#else
#define SetupDiCreateDevRegKey SetupDiCreateDevRegKeyA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileList(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileListExA(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCSTR  MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileListExW(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCWSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetHwProfileListEx SetupDiGetHwProfileListExW
#else
#define SetupDiGetHwProfileListEx SetupDiGetHwProfileListExA
#endif


//
// Device registry property codes
// (Codes marked as read-only (R) may only be used for
// SetupDiGetDeviceRegistryProperty)
//
// These values should cover the same set of registry properties
// as defined by the CM_DRP codes in cfgmgr32.h.
//
#define SPDRP_DEVICEDESC                  (0x00000000)  // DeviceDesc (R/W)
#define SPDRP_HARDWAREID                  (0x00000001)  // HardwareID (R/W)
#define SPDRP_COMPATIBLEIDS               (0x00000002)  // CompatibleIDs (R/W)
#define SPDRP_UNUSED0                     (0x00000003)  // unused
#define SPDRP_SERVICE                     (0x00000004)  // Service (R/W)
#define SPDRP_UNUSED1                     (0x00000005)  // unused
#define SPDRP_UNUSED2                     (0x00000006)  // unused
#define SPDRP_CLASS                       (0x00000007)  // Class (R--tied to ClassGUID)
#define SPDRP_CLASSGUID                   (0x00000008)  // ClassGUID (R/W)
#define SPDRP_DRIVER                      (0x00000009)  // Driver (R/W)
#define SPDRP_CONFIGFLAGS                 (0x0000000A)  // ConfigFlags (R/W)
#define SPDRP_MFG                         (0x0000000B)  // Mfg (R/W)
#define SPDRP_FRIENDLYNAME                (0x0000000C)  // FriendlyName (R/W)
#define SPDRP_LOCATION_INFORMATION        (0x0000000D)  // LocationInformation (R/W)
#define SPDRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000E)  // PhysicalDeviceObjectName (R)
#define SPDRP_CAPABILITIES                (0x0000000F)  // Capabilities (R)
#define SPDRP_UI_NUMBER                   (0x00000010)  // UiNumber (R)
#define SPDRP_UPPERFILTERS                (0x00000011)  // UpperFilters (R/W)
#define SPDRP_LOWERFILTERS                (0x00000012)  // LowerFilters (R/W)
#define SPDRP_BUSTYPEGUID                 (0x00000013)  // BusTypeGUID (R)
#define SPDRP_LEGACYBUSTYPE               (0x00000014)  // LegacyBusType (R)
#define SPDRP_BUSNUMBER                   (0x00000015)  // BusNumber (R)
#define SPDRP_ENUMERATOR_NAME             (0x00000016)  // Enumerator Name (R)
#define SPDRP_SECURITY                    (0x00000017)  // Security (R/W, binary form)
#define SPDRP_SECURITY_SDS                (0x00000018)  // Security (W, SDS form)
#define SPDRP_DEVTYPE                     (0x00000019)  // Device Type (R/W)
#define SPDRP_EXCLUSIVE                   (0x0000001A)  // Device is exclusive-access (R/W)
#define SPDRP_CHARACTERISTICS             (0x0000001B)  // Device Characteristics (R/W)
#define SPDRP_ADDRESS                     (0x0000001C)  // Device Address (R)
#define SPDRP_UI_NUMBER_DESC_FORMAT       (0X0000001E)  // UiNumberDescFormat (R/W)
#define SPDRP_MAXIMUM_PROPERTY            (0x0000001F)  // Upper bound on ordinals
//
// Class registry property codes
// (Codes marked as read-only (R) may only be used for
// SetupDiGetClassRegistryProperty)
//
// These values should cover the same set of registry properties
// as defined by the CM_CRP codes in cfgmgr32.h.
// they should also have a 1:1 correspondence with Device registers, where applicable
// but no overlap otherwise
//
#define SPCRP_SECURITY                    (0x00000017)  // Security (R/W, binary form)
#define SPCRP_SECURITY_SDS                (0x00000018)  // Security (W, SDS form)
#define SPCRP_DEVTYPE                     (0x00000019)  // Device Type (R/W)
#define SPCRP_EXCLUSIVE                   (0x0000001A)  // Device is exclusive-access (R/W)
#define SPCRP_CHARACTERISTICS             (0x0000001B)  // Device Characteristics (R/W)
#define SPCRP_MAXIMUM_PROPERTY            (0x0000001C)  // Upper bound on ordinals


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceRegistryProperty SetupDiGetDeviceRegistryPropertyW
#else
#define SetupDiGetDeviceRegistryProperty SetupDiGetDeviceRegistryPropertyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryPropertyA(
    IN  LPGUID           ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCSTR            MachineName,         OPTIONAL
    IN  PVOID            Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryPropertyW(
    IN  LPGUID           ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCWSTR           MachineName,         OPTIONAL
    IN  PVOID            Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassRegistryProperty SetupDiGetClassRegistryPropertyW
#else
#define SetupDiGetClassRegistryProperty SetupDiGetClassRegistryPropertyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyA(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyW(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    );

#ifdef UNICODE
#define SetupDiSetDeviceRegistryProperty SetupDiSetDeviceRegistryPropertyW
#else
#define SetupDiSetDeviceRegistryProperty SetupDiSetDeviceRegistryPropertyA
#endif

WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryPropertyA(
    IN     LPGUID           ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCSTR            MachineName,       OPTIONAL
    IN     PVOID            Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryPropertyW(
    IN     LPGUID           ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCWSTR           MachineName,       OPTIONAL
    IN     PVOID            Reserved
    );

#ifdef UNICODE
#define SetupDiSetClassRegistryProperty SetupDiSetClassRegistryPropertyW
#else
#define SetupDiSetClassRegistryProperty SetupDiSetClassRegistryPropertyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    );

#ifdef UNICODE
#define SetupDiGetDeviceInstallParams SetupDiGetDeviceInstallParamsW
#else
#define SetupDiGetDeviceInstallParams SetupDiGetDeviceInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetClassInstallParams SetupDiGetClassInstallParamsW
#else
#define SetupDiGetClassInstallParams SetupDiGetClassInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    );

#ifdef UNICODE
#define SetupDiSetDeviceInstallParams SetupDiSetDeviceInstallParamsW
#else
#define SetupDiSetDeviceInstallParams SetupDiSetDeviceInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    );

#ifdef UNICODE
#define SetupDiSetClassInstallParams SetupDiSetClassInstallParamsW
#else
#define SetupDiSetClassInstallParams SetupDiSetClassInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

#ifdef UNICODE
#define SetupDiGetDriverInstallParams SetupDiGetDriverInstallParamsW
#else
#define SetupDiGetDriverInstallParams SetupDiGetDriverInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsA(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_A    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsW(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_W    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

#ifdef UNICODE
#define SetupDiSetDriverInstallParams SetupDiSetDriverInstallParamsW
#else
#define SetupDiSetDriverInstallParams SetupDiSetDriverInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiLoadClassIcon(
    IN  CONST GUID *ClassGuid,
    OUT HICON      *LargeIcon,    OPTIONAL
    OUT PINT        MiniIconIndex OPTIONAL
    );


//
// Flags controlling the drawing of mini-icons
//
#define DMI_MASK      0x00000001
#define DMI_BKCOLOR   0x00000002
#define DMI_USERECT   0x00000004

WINSETUPAPI
INT
WINAPI
SetupDiDrawMiniIcon(
    IN HDC   hdc,
    IN RECT  rc,
    IN INT   MiniIconIndex,
    IN DWORD Flags
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassBitmapIndex(
    IN  CONST GUID *ClassGuid,    OPTIONAL
    OUT PINT        MiniIconIndex
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageListExA(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCSTR                   MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageListExW(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCWSTR                  MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassImageListEx SetupDiGetClassImageListExW
#else
#define SetupDiGetClassImageListEx SetupDiGetClassImageListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA  ClassImageListData,
    IN  CONST GUID              *ClassGuid,
    OUT PINT                     ImageIndex
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    );


//
// PropertySheetType values for the SetupDiGetClassDevPropertySheets API
//
#define DIGCDP_FLAG_BASIC           0x00000001
#define DIGCDP_FLAG_ADVANCED        0x00000002
#define DIGCDP_FLAG_REMOTE_BASIC    0x00000003
#define DIGCDP_FLAG_REMOTE_ADVANCED 0x00000004

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERA PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERW PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    );

#ifdef UNICODE
#define SetupDiGetClassDevPropertySheets SetupDiGetClassDevPropertySheetsW
#else
#define SetupDiGetClassDevPropertySheets SetupDiGetClassDevPropertySheetsA
#endif


//
// Define ICON IDs publicly exposed from setupapi.
//
#define IDI_RESOURCEFIRST           159
#define IDI_RESOURCE                159
#define IDI_RESOURCELAST            161
#define IDI_RESOURCEOVERLAYFIRST    161
#define IDI_RESOURCEOVERLAYLAST     161
#define IDI_CONFLICT                161

#define IDI_CLASSICON_OVERLAYFIRST  500
#define IDI_CLASSICON_OVERLAYLAST   502
#define IDI_PROBLEM_OVL             500
#define IDI_DISABLED_OVL            501
#define IDI_FORCED_OVL              502


WINSETUPAPI
BOOL
WINAPI
SetupDiAskForOEMDisk(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiSelectOEMDrv(
    IN     HWND             hwndParent,    OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    );

#ifdef UNICODE
#define SetupDiClassNameFromGuid SetupDiClassNameFromGuidW
#else
#define SetupDiClassNameFromGuid SetupDiClassNameFromGuidA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCSTR       MachineName,   OPTIONAL
    IN  PVOID       Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidExW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCWSTR      MachineName,   OPTIONAL
    IN  PVOID       Reserved
    );

#ifdef UNICODE
#define SetupDiClassNameFromGuidEx SetupDiClassNameFromGuidExW
#else
#define SetupDiClassNameFromGuidEx SetupDiClassNameFromGuidExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );

#ifdef UNICODE
#define SetupDiClassGuidsFromName SetupDiClassGuidsFromNameW
#else
#define SetupDiClassGuidsFromName SetupDiClassGuidsFromNameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameExA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameExW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiClassGuidsFromNameEx SetupDiClassGuidsFromNameExW
#else
#define SetupDiClassGuidsFromNameEx SetupDiClassGuidsFromNameExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetHwProfileFriendlyName SetupDiGetHwProfileFriendlyNameW
#else
#define SetupDiGetHwProfileFriendlyName SetupDiGetHwProfileFriendlyNameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCSTR  MachineName,      OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCWSTR MachineName,      OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetHwProfileFriendlyNameEx SetupDiGetHwProfileFriendlyNameExW
#else
#define SetupDiGetHwProfileFriendlyNameEx SetupDiGetHwProfileFriendlyNameExA
#endif


//
// PageType values for SetupDiGetWizardPage API
//
#define SPWPT_SELECTDEVICE      0x00000001

//
// Flags for SetupDiGetWizardPage API
//
#define SPWP_USE_DEVINFO_DATA   0x00000001

WINSETUPAPI
HPROPSHEETPAGE
WINAPI
SetupDiGetWizardPage(
    IN HDEVINFO               DeviceInfoSet,
    IN PSP_DEVINFO_DATA       DeviceInfoData,    OPTIONAL
    IN PSP_INSTALLWIZARD_DATA InstallWizardData,
    IN DWORD                  PageType,
    IN DWORD                  Flags
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO         DeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallA(
    IN  HINF    InfHandle,
    IN  PCSTR   InfSectionName,
    OUT PSTR    InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PSTR   *Extension              OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallW(
    IN  HINF    InfHandle,
    IN  PCWSTR  InfSectionName,
    OUT PWSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PWSTR  *Extension              OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetActualSectionToInstall SetupDiGetActualSectionToInstallW
#else
#define SetupDiGetActualSectionToInstall SetupDiGetActualSectionToInstallA
#endif


#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _INC_SETUPAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\SetupStr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Apr 22 20:05:36 1998
 */
/* Compiler settings for setupstr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __setupstr_h__
#define __setupstr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISetupStore_FWD_DEFINED__
#define __ISetupStore_FWD_DEFINED__
typedef interface ISetupStore ISetupStore;
#endif 	/* __ISetupStore_FWD_DEFINED__ */


#ifndef __SetupStore_FWD_DEFINED__
#define __SetupStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class SetupStore SetupStore;
#else
typedef struct SetupStore SetupStore;
#endif /* __cplusplus */

#endif 	/* __SetupStore_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_setupstr_0000
 * at Wed Apr 22 20:05:36 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


DEFINE_GUID(IID_ISetupStore, 0x9CB46565, 0xDDFA, 0x11D0, 0x9B, 0xD7, 0x00, 0xC0, 0x4F, 0xC2, 0xE0, 0xD3);
DEFINE_GUID(CLSID_SetupStore, 0x9CB46566, 0xDDFA, 0x11D0, 0x9B, 0xD7, 0x00, 0xC0, 0x4F, 0xC2, 0xE0, 0xD3);
DEFINE_GUID(LIBID_SETUPSTRLib, 0x9CB46558, 0xDDFA, 0x11D0, 0x9B, 0xD7, 0x00, 0xC0, 0x4F, 0xC2, 0xE0, 0xD3);


extern RPC_IF_HANDLE __MIDL_itf_setupstr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_setupstr_0000_v0_0_s_ifspec;

#ifndef __ISetupStore_INTERFACE_DEFINED__
#define __ISetupStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISetupStore
 * at Wed Apr 22 20:05:36 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ISetupStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CB46565-DDFA-11D0-9BD7-00C04FC2E0D3")
    ISetupStore : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSQLDB( 
            /* [in] */ BSTR bstrServerName,
            /* [in] */ BSTR bstrDatabaseName,
            /* [in] */ BSTR bstrDirectoryName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword,
            /* [in] */ BSTR bstrSuperDSPassword,
            /* [in] */ BOOLEAN fUseU2Security) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateJetDB( 
            /* [in] */ BSTR bstrFileName,
            /* [in] */ BSTR bstrDirectoryName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword,
            /* [in] */ BSTR bstrSuperDSPassword,
            /* [in] */ BOOLEAN fUseU2Security) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePartition( 
            /* [in] */ BSTR bstrServerName,
            /* [in] */ BSTR bstrDatabaseName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDirectoryPropertiesPage( 
            /* [in] */ long lInstanceId,
            /* [in] */ BSTR szRealm,
            /* [in] */ BSTR szDnPrefix) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidateJetFileName( 
            /* [in] */ BSTR bstrFileName,
            /* [in] */ BOOL fWantNew,
            /* [retval][out] */ BOOL __RPC_FAR *pfValid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateJetFileName( 
            /* [in] */ DWORD dwID,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LocalPathToFullPath( 
            /* [in] */ BSTR bstrLocal,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFull) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDriveInformation( 
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ DWORD __RPC_FAR *pdwdt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISetupStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISetupStore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISetupStore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISetupStore __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSQLDB )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrServerName,
            /* [in] */ BSTR bstrDatabaseName,
            /* [in] */ BSTR bstrDirectoryName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword,
            /* [in] */ BSTR bstrSuperDSPassword,
            /* [in] */ BOOLEAN fUseU2Security);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateJetDB )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName,
            /* [in] */ BSTR bstrDirectoryName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword,
            /* [in] */ BSTR bstrSuperDSPassword,
            /* [in] */ BOOLEAN fUseU2Security);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePartition )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrServerName,
            /* [in] */ BSTR bstrDatabaseName,
            /* [in] */ BSTR bstrDBUserName,
            /* [in] */ BSTR bstrDBPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDirectoryPropertiesPage )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ long lInstanceId,
            /* [in] */ BSTR szRealm,
            /* [in] */ BSTR szDnPrefix);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateJetFileName )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName,
            /* [in] */ BOOL fWantNew,
            /* [retval][out] */ BOOL __RPC_FAR *pfValid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateJetFileName )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LocalPathToFullPath )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrLocal,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFull);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDriveInformation )( 
            ISetupStore __RPC_FAR * This,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ DWORD __RPC_FAR *pdwdt);
        
        END_INTERFACE
    } ISetupStoreVtbl;

    interface ISetupStore
    {
        CONST_VTBL struct ISetupStoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISetupStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISetupStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISetupStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISetupStore_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISetupStore_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISetupStore_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISetupStore_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISetupStore_CreateSQLDB(This,bstrServerName,bstrDatabaseName,bstrDirectoryName,bstrDBUserName,bstrDBPassword,bstrSuperDSPassword,fUseU2Security)	\
    (This)->lpVtbl -> CreateSQLDB(This,bstrServerName,bstrDatabaseName,bstrDirectoryName,bstrDBUserName,bstrDBPassword,bstrSuperDSPassword,fUseU2Security)

#define ISetupStore_CreateJetDB(This,bstrFileName,bstrDirectoryName,bstrDBUserName,bstrDBPassword,bstrSuperDSPassword,fUseU2Security)	\
    (This)->lpVtbl -> CreateJetDB(This,bstrFileName,bstrDirectoryName,bstrDBUserName,bstrDBPassword,bstrSuperDSPassword,fUseU2Security)

#define ISetupStore_CreatePartition(This,bstrServerName,bstrDatabaseName,bstrDBUserName,bstrDBPassword)	\
    (This)->lpVtbl -> CreatePartition(This,bstrServerName,bstrDatabaseName,bstrDBUserName,bstrDBPassword)

#define ISetupStore_SetDirectoryPropertiesPage(This,lInstanceId,szRealm,szDnPrefix)	\
    (This)->lpVtbl -> SetDirectoryPropertiesPage(This,lInstanceId,szRealm,szDnPrefix)

#define ISetupStore_ValidateJetFileName(This,bstrFileName,fWantNew,pfValid)	\
    (This)->lpVtbl -> ValidateJetFileName(This,bstrFileName,fWantNew,pfValid)

#define ISetupStore_GenerateJetFileName(This,dwID,pbstrFileName)	\
    (This)->lpVtbl -> GenerateJetFileName(This,dwID,pbstrFileName)

#define ISetupStore_LocalPathToFullPath(This,bstrLocal,pbstrFull)	\
    (This)->lpVtbl -> LocalPathToFullPath(This,bstrLocal,pbstrFull)

#define ISetupStore_GetDriveInformation(This,bstrPath,pdwdt)	\
    (This)->lpVtbl -> GetDriveInformation(This,bstrPath,pdwdt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_CreateSQLDB_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrServerName,
    /* [in] */ BSTR bstrDatabaseName,
    /* [in] */ BSTR bstrDirectoryName,
    /* [in] */ BSTR bstrDBUserName,
    /* [in] */ BSTR bstrDBPassword,
    /* [in] */ BSTR bstrSuperDSPassword,
    /* [in] */ BOOLEAN fUseU2Security);


void __RPC_STUB ISetupStore_CreateSQLDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_CreateJetDB_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName,
    /* [in] */ BSTR bstrDirectoryName,
    /* [in] */ BSTR bstrDBUserName,
    /* [in] */ BSTR bstrDBPassword,
    /* [in] */ BSTR bstrSuperDSPassword,
    /* [in] */ BOOLEAN fUseU2Security);


void __RPC_STUB ISetupStore_CreateJetDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_CreatePartition_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrServerName,
    /* [in] */ BSTR bstrDatabaseName,
    /* [in] */ BSTR bstrDBUserName,
    /* [in] */ BSTR bstrDBPassword);


void __RPC_STUB ISetupStore_CreatePartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_SetDirectoryPropertiesPage_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ long lInstanceId,
    /* [in] */ BSTR szRealm,
    /* [in] */ BSTR szDnPrefix);


void __RPC_STUB ISetupStore_SetDirectoryPropertiesPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_ValidateJetFileName_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName,
    /* [in] */ BOOL fWantNew,
    /* [retval][out] */ BOOL __RPC_FAR *pfValid);


void __RPC_STUB ISetupStore_ValidateJetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_GenerateJetFileName_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB ISetupStore_GenerateJetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_LocalPathToFullPath_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrLocal,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFull);


void __RPC_STUB ISetupStore_LocalPathToFullPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISetupStore_GetDriveInformation_Proxy( 
    ISetupStore __RPC_FAR * This,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ DWORD __RPC_FAR *pdwdt);


void __RPC_STUB ISetupStore_GetDriveInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISetupStore_INTERFACE_DEFINED__ */



#ifndef __SETUPSTRLib_LIBRARY_DEFINED__
#define __SETUPSTRLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SETUPSTRLib
 * at Wed Apr 22 20:05:36 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SETUPSTRLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SetupStore;

class DECLSPEC_UUID("9CB46566-DDFA-11D0-9BD7-00C04FC2E0D3")
SetupStore;
#endif
#endif /* __SETUPSTRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;



#elif   defined(_M_MRX000)

#ifndef _INC_SETJMPEX
#if     _MSC_VER >= 1100
#define _setjmp  _setjmpVfp
#endif
#define setjmp  _setjmp
#endif

/*
 * All MIPS implementations need _JBLEN of 16
 */

#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif   defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef  _MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp  _setjmpex /* Alpha should always use setjmp as _setjmpex */
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/*
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
#ifdef _M_ALPHA64
#define _JBFILL 3
    unsigned __int64 Fp;
    unsigned __int64 Pc;
    unsigned __int64 Seb;
    unsigned long Type;
    unsigned long Type_Fill;
#else
#define _JBFILL 5
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
#endif
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[_JBFILL];
} _JUMP_BUFFER;
#undef _JBFILL

#elif   defined(_M_PPC)
/*
 * The Microsoft VC++ V4.0 compiler uses an intrinsic _setjmp.
 * The Motorola C8.5 compiler implements setjmp as a function.
 */

#if     _MSC_VER > 850
#ifndef _INC_SETJMPEX
#undef _setjmp
#define setjmp  _setjmp
#endif
#endif

/*
 * Min length is 240 bytes; round to 256 bytes.
 * Since this is allocated as an array of "double", the
 * number of entries required is 32.
 *
 * All PPC implementations need _JBLEN of 32
 */

#define _JBLEN  32
#define _JBTYPE double

/*
 * Define jump buffer layout for PowerPC setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    unsigned long Gpr1;
    unsigned long Gpr2;
    unsigned long Gpr13;
    unsigned long Gpr14;
    unsigned long Gpr15;
    unsigned long Gpr16;
    unsigned long Gpr17;
    unsigned long Gpr18;
    unsigned long Gpr19;
    unsigned long Gpr20;
    unsigned long Gpr21;
    unsigned long Gpr22;
    unsigned long Gpr23;
    unsigned long Gpr24;
    unsigned long Gpr25;
    unsigned long Gpr26;
    unsigned long Gpr27;
    unsigned long Gpr28;
    unsigned long Gpr29;
    unsigned long Gpr30;
    unsigned long Gpr31;
    unsigned long Cr;
    unsigned long Iar;
    unsigned long Type;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

// Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name.
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;

#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    unsigned long iAReserved[6];

    //
    // x86 C9.0 compatibility
    //

    unsigned long Registration;  // point to the UnwindData field.
    unsigned long TryLevel;      // ignored by setjmp
    unsigned long Cookie;        // set to "VC20" by setjmp
    unsigned long UnwindFunc;    // set to EM longjmp() by setjmp

    //
    // First dword is zero to indicate it's an exception registration
    // record prepared by EM setjmp function.
    // Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
    // EM setjmp.
    // Third dword is set to the setjmp site memory stack frame pointer.
    // Fourth dword is set to the setjmp site backing store frame pointer.
    //

    unsigned long UnwindData[6];

    //
    // floating point status register,
    // and preserved floating point registers fs0 - fs19
    //

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    //
    // return link and preserved branch registers bs0 - bs4
    //

    __int64 StIIP;     // continuation address
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    //
    // preserved general registers s0 - s3, sp, nats
    //

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    //
    // bsp, pfs, unat, lc
    //

    __int64 RsBSP;
    __int64 RsPFS;     // previous frame marker (cfm of setjmp's caller)
    __int64 ApUNAT;    // User Nat collection register (preserved)
    __int64 ApLC;      // loop counter

    __int64 IntSp;     // memory stack pointer
    __int64 IntNats;   // Nat bits of preserved integer regs s0 - s3
    __int64 Preds;     // predicates

} _JUMP_BUFFER;

#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\sgwdata.h ===
// -sgwdata.h-------------------------------------------------------------------
// Defines the configuration extension data for the Sample Gateway.
//
// Copyright 1986 - 1999 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _SGWDATA_H_
#define _SGWDATA_H_

// Name of cfg extension data blob.
#define SGWBLOBNAME     "SGWData"
#define SGWBLOBNAMEW    L"SGWData"

// -----------------------------------------------------------------------------
// Index of properties within the extension data blob.
//
// NOTE: If you add a property, add it to the end of the array.  The SGWAdmin 
//       code is designed to handle a growing property array with ease.  If you 
//       remove one it would be easier to just make it an unused place holder.
// -----------------------------------------------------------------------------

typedef enum {          
    // PT_BOOLEAN
    IDX_CHECK_IN_BOUND = 0,
    IDX_CHECK_OUT_BOUND, 

    // PT_LONG
    IDX_EDIT_THREADS_IN, 
    IDX_EDIT_THREADS_OUT,
    IDX_EDIT_MSGS_IN,    
    IDX_EDIT_MSGS_OUT,   
    IDX_EDIT_SLEEP_IN,   
    IDX_EDIT_SLEEP_OUT,  
    IDX_EDIT_POLLING_IN, 
    IDX_EDIT_POLLING_OUT,

    // PT_STRING8
    IDX_ADDR_TYPE,       
    IDX_DISP_NAME,       
    IDX_EMAIL_ADDR,      
    IDX_DIR_IN,          
    IDX_DIR_OUT,
    IDX_CONVERTER_IN,
    IDX_CONVERTER_OUT,

    // Total number of properties in Extension Data Blob.
    // Keep this one at the very end of list.
    SGWDATA_PROP_COUNT
} PropIndex;

// -----------------------------------------------------------------------------

#endif // _SGWDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Sfc.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sfc.h

Abstract:

    Header file for public SFC interfaces.

Author:

    Wesley Witt (wesw) 2-Feb-1999

Revision History:

--*/



#ifndef _SFC_
#define _SFC_


#ifdef __cplusplus
extern "C" {

#endif

#define SFC_DISABLE_NORMAL          0
#define SFC_DISABLE_ASK             1
#define SFC_DISABLE_ONCE            2
#define SFC_DISABLE_SETUP           3
#define SFC_DISABLE_NOPOPUPS        4

#define SFC_SCAN_NORMAL             0
#define SFC_SCAN_ALWAYS             1
#define SFC_SCAN_ONCE               2
#define SFC_SCAN_IMMEDIATE          3

#define SFC_QUOTA_DEFAULT           50
#define SFC_QUOTA_ALL_FILES         ((ULONG)-1)

#define SFC_IDLE_TRIGGER       L"WFP_IDLE_TRIGGER"

typedef struct _PROTECTED_FILE_DATA {
    WCHAR   FileName[MAX_PATH];
    DWORD   FileNumber;
} PROTECTED_FILE_DATA, *PPROTECTED_FILE_DATA;


BOOL
WINAPI
SfcGetNextProtectedFile(
    IN HANDLE RpcHandle, // must be NULL
    IN PPROTECTED_FILE_DATA ProtFileData
    );

BOOL
WINAPI
SfcIsFileProtected(
    IN HANDLE RpcHandle, // must be NULL
    IN LPCWSTR ProtFileName
    );

//
// new APIs which are not currently supported, but are stubbed out
//
BOOL
WINAPI
SfpVerifyFile(
    IN LPCTSTR pszFileName,
    IN LPTSTR  pszError,
    IN DWORD   dwErrSize
    );    




#ifdef __cplusplus
}
#endif

#endif // _SFC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ShTypes.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for shtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __shtypes_h__
#define __shtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shtypes_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//--------------------------------------------------------------------------
//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================
//
// SHITEMID -- Item ID  (mkid)
//     USHORT      cb;             // Size of the ID (including cb itself)
//     BYTE        abID[];         // The item ID (variable length)
//
#include <pshpack1.h>
typedef struct _SHITEMID
    {
    USHORT cb;
    BYTE abID[ 1 ];
    } 	SHITEMID;

#include <poppack.h>
#if defined(_M_IX86)
#define __unaligned
#endif // __unaligned
typedef SHITEMID __unaligned *LPSHITEMID;

typedef const SHITEMID __unaligned *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
#include <pshpack1.h>
typedef struct _ITEMIDLIST
    {
    SHITEMID mkid;
    } 	ITEMIDLIST;

#include <poppack.h>
typedef /* [unique] */ BYTE_BLOB *wirePIDL;

typedef /* [wire_marshal] */ ITEMIDLIST __unaligned *LPITEMIDLIST;

typedef /* [wire_marshal] */ const ITEMIDLIST __unaligned *LPCITEMIDLIST;

typedef struct _WINBASE_DEFINED_STRUCT
    {
    int dummy;
    } 	WINBASE_DEFINED_STRUCT;

#ifdef WINBASE_DEFINED_MIDL
typedef WINBASE_DEFINED_STRUCT WIN32_FIND_DATAA;

typedef WINBASE_DEFINED_STRUCT WIN32_FIND_DATAW;

#endif // WINBASE_DEFINED_MIDL
//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
//
//  uType indicate which union member to use 
//    STRRET_WSTR    Use STRRET.pOleStr     must be freed by caller of GetDisplayNameOf
//    STRRET_OFFSET  Use STRRET.uOffset     Offset into SHITEMID for ANSI string 
//    STRRET_CSTR    Use STRRET.cStr        ANSI Buffer
//
typedef /* [v1_enum] */ 
enum tagSTRRET_TYPE
    {	STRRET_WSTR	= 0,
	STRRET_OFFSET	= 0x1,
	STRRET_CSTR	= 0x2
    } 	STRRET_TYPE;

#include <pshpack1.h>
typedef struct _STRRET
    {
    UINT uType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()][string] */ LPWSTR pOleStr;
        /* [case()] */ UINT uOffset;
        /* [case()] */ char cStr[ 260 ];
        } 	DUMMYUNIONNAME;
    } 	STRRET;

#include <poppack.h>
typedef STRRET *LPSTRRET;

//-------------------------------------------------------------------------
//
// struct SHELLDETAILS
//
// structure for returning strings from IShellDetails
//
//-------------------------------------------------------------------------
//
//  fmt;            // LVCFMT_* value (header only)
//  cxChar;         // Number of 'average' characters (header only)
//  str;            // String information
//
#include <pshpack1.h>
typedef struct _SHELLDETAILS
    {
    int fmt;
    int cxChar;
    STRRET str;
    } 	SHELLDETAILS;

typedef struct _SHELLDETAILS *LPSHELLDETAILS;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ShFolder.h ===
// functions to get shell special folders/
// shfolder.dll supports these on all platforms including Win95, Win98, NT4 and IE4 shell

// all CSIDL values referred to here are supported natively by shfolder.dll, that is they
// will work on all platforms.

#ifndef _SHFOLDER_H_
#define _SHFOLDER_H_

#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif

#ifndef CSIDL_PERSONAL
#define CSIDL_PERSONAL                  0x0005      // My Documents
#endif

#ifndef CSIDL_MYMUSIC
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#endif

#ifndef CSIDL_APPDATA
#define CSIDL_APPDATA                   0x001A      // Application Data, new for NT4
#endif

#ifndef CSIDL_LOCAL_APPDATA

#define CSIDL_LOCAL_APPDATA             0x001C      // non roaming, user\Local Settings\Application Data
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023      // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024      // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025      // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026      // C:\Program Files
#define CSIDL_MYPICTURES                0x0027      // My Pictures, new for Win2K
#define CSIDL_PROGRAM_FILES_COMMON      0x002b      // C:\Program Files\Common 
#define CSIDL_COMMON_DOCUMENTS          0x002e      // All Users\Documents


#define CSIDL_FLAG_CREATE               0x8000      // new for Win2K, or this in to force creation of folder

#define CSIDL_COMMON_ADMINTOOLS         0x002f      // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030      // <user name>\Start Menu\Programs\Administrative Tools

#endif // CSIDL_LOCAL_APPDATA


SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

// protos so callers can GetProcAddress() from shfolder.dll

typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHA)(HWND, int, HANDLE, DWORD, LPSTR);  // "SHGetFolderPathA"
typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHW)(HWND, int, HANDLE, DWORD, LPWSTR); // "SHGetFolderPathW"

#ifdef UNICODE
#define SHGetFolderPath     SHGetFolderPathW
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHW
#else
#define SHGetFolderPath     SHGetFolderPathA
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHA
#endif

#endif //  _SHFOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
* Copyright (c) 1992-1998, Microsoft Corp.  All rights reserved               *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI       DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if !defined(_SHELL32_)
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if !defined(_SHDOCVW_)
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#endif
#endif // SHDOCAPI


#if !defined(_WIN64)
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */



DECLARE_HANDLE(HDROP);

SHSTDAPI_(UINT) DragQueryFileA(HDROP,UINT,LPSTR,UINT);
SHSTDAPI_(UINT) DragQueryFileW(HDROP,UINT,LPWSTR,UINT);
#ifdef UNICODE
#define DragQueryFile  DragQueryFileW
#else
#define DragQueryFile  DragQueryFileA
#endif // !UNICODE
SHSTDAPI_(BOOL) DragQueryPoint(HDROP,LPPOINT);
SHSTDAPI_(void) DragFinish(HDROP);
SHSTDAPI_(void) DragAcceptFiles(HWND,BOOL);

SHSTDAPI_(HINSTANCE) ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
SHSTDAPI_(HINSTANCE) ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
#ifdef UNICODE
#define ShellExecute  ShellExecuteW
#else
#define ShellExecute  ShellExecuteA
#endif // !UNICODE
SHSTDAPI_(HINSTANCE) FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
SHSTDAPI_(HINSTANCE) FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);
#ifdef UNICODE
#define FindExecutable  FindExecutableW
#else
#define FindExecutable  FindExecutableA
#endif // !UNICODE
SHSTDAPI_(LPWSTR *)  CommandLineToArgvW(LPCWSTR lpCmdLine, int*pNumArgs);

SHSTDAPI_(INT) ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
SHSTDAPI_(INT) ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);
#ifdef UNICODE
#define ShellAbout  ShellAboutW
#else
#define ShellAbout  ShellAboutA
#endif // !UNICODE
SHSTDAPI_(HICON) DuplicateIcon(HINSTANCE hInst, HICON hIcon);
SHSTDAPI_(HICON) ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
SHSTDAPI_(HICON) ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);
#ifdef UNICODE
#define ExtractAssociatedIcon  ExtractAssociatedIconW
#else
#define ExtractAssociatedIcon  ExtractAssociatedIconA
#endif // !UNICODE
SHSTDAPI_(HICON) ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);
SHSTDAPI_(HICON) ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
#ifdef UNICODE
#define ExtractIcon  ExtractIconW
#else
#define ExtractIcon  ExtractIconA
#endif // !UNICODE

#if(WINVER >= 0x0400)
typedef struct _DRAGINFOA {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */
    POINT pt;
    BOOL fNC;
    LPSTR   lpFileList;
    DWORD grfKeyState;
} DRAGINFOA, *LPDRAGINFOA;
typedef struct _DRAGINFOW {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */
    POINT pt;
    BOOL fNC;
    LPWSTR  lpFileList;
    DWORD grfKeyState;
} DRAGINFOW, *LPDRAGINFOW;
#ifdef UNICODE
typedef DRAGINFOW DRAGINFO;
typedef LPDRAGINFOW LPDRAGINFO;
#else
typedef DRAGINFOA DRAGINFO;
typedef LPDRAGINFOA LPDRAGINFO;
#endif // UNICODE


////
//// AppBar stuff
////
#define ABM_NEW           0x00000000
#define ABM_REMOVE        0x00000001
#define ABM_QUERYPOS      0x00000002
#define ABM_SETPOS        0x00000003
#define ABM_GETSTATE      0x00000004
#define ABM_GETTASKBARPOS 0x00000005
#define ABM_ACTIVATE      0x00000006  // lParam == TRUE/FALSE means activate/deactivate
#define ABM_GETAUTOHIDEBAR 0x00000007
#define ABM_SETAUTOHIDEBAR 0x00000008  // this can fail at any time.  MUST check the result
                                        // lParam = TRUE/FALSE  Set/Unset
                                        // uEdge = what edge
#define ABM_WINDOWPOSCHANGED 0x0000009

// these are put in the wparam of callback messages
#define ABN_STATECHANGE    0x0000000
#define ABN_POSCHANGED     0x0000001
#define ABN_FULLSCREENAPP  0x0000002
#define ABN_WINDOWARRANGE  0x0000003 // lParam == TRUE means hide

// flags for get state
#define ABS_AUTOHIDE    0x0000001
#define ABS_ALWAYSONTOP 0x0000002

#define ABE_LEFT        0
#define ABE_TOP         1
#define ABE_RIGHT       2
#define ABE_BOTTOM      3

typedef struct _AppBarData
{
    DWORD cbSize;
    HWND hWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
    LPARAM lParam; // message specific
} APPBARDATA, *PAPPBARDATA;

SHSTDAPI_(UINT_PTR) SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);

////
////  EndAppBar
////

SHSTDAPI_(DWORD)   DoEnvironmentSubstA(LPSTR szString, UINT cchString);
SHSTDAPI_(DWORD)   DoEnvironmentSubstW(LPWSTR szString, UINT cchString);
#ifdef UNICODE
#define DoEnvironmentSubst  DoEnvironmentSubstW
#else
#define DoEnvironmentSubst  DoEnvironmentSubstA
#endif // !UNICODE

#define EIRESID(x) (-1 * (int)(x))
SHSTDAPI_(UINT) ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
SHSTDAPI_(UINT) ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
#ifdef UNICODE
#define ExtractIconEx  ExtractIconExW
#else
#define ExtractIconEx  ExtractIconExA
#endif // !UNICODE


////
//// Shell File Operations
////
#ifndef FO_MOVE //these need to be kept in sync with the ones in shlobj.h

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes
#define FOF_NORECURSION            0x1000  // don't recurse into directories.
#if (_WIN32_IE >= 0x0500)
#define FOF_NO_CONNECTED_ELEMENTS  0x2000  // don't operate on connected elements.
#define FOF_WANTNUKEWARNING        0x4000  // during delete operation, warn if nuking instead of recycling (partially overrides FOF_NOCONFIRMATION)
#endif // (_WIN32_IE >= 0x500)

typedef WORD FILEOP_FLAGS;

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef WORD PRINTEROP_FLAGS;

#endif // FO_MOVE

// implicit parameters are:
//      if pFrom or pTo are unqualified names the current directories are
//      taken from the global current drive/directory settings managed
//      by Get/SetCurrentDrive/Directory
//
//      the global confirmation settings

typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTA, *LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTW, *LPSHFILEOPSTRUCTW;
#ifdef UNICODE
typedef SHFILEOPSTRUCTW SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTW LPSHFILEOPSTRUCT;
#else
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
#endif // UNICODE

SHSTDAPI_(int) SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
SHSTDAPI_(int) SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);
#ifdef UNICODE
#define SHFileOperation  SHFileOperationW
#else
#define SHFileOperation  SHFileOperationA
#endif // !UNICODE
SHSTDAPI_(void) SHFreeNameMappings(HANDLE hNameMappings);

typedef struct _SHNAMEMAPPINGA
{
    LPSTR   pszOldPath;
    LPSTR   pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGA, *LPSHNAMEMAPPINGA;
typedef struct _SHNAMEMAPPINGW
{
    LPWSTR  pszOldPath;
    LPWSTR  pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGW, *LPSHNAMEMAPPINGW;
#ifdef UNICODE
typedef SHNAMEMAPPINGW SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGW LPSHNAMEMAPPING;
#else
typedef SHNAMEMAPPINGA SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;
#endif // UNICODE


////
//// End Shell File Operations
////

////
////  Begin ShellExecuteEx and family
////

/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
#define SE_ERR_FNF              2       // file not found
#define SE_ERR_PNF              3       // path not found
#define SE_ERR_ACCESSDENIED     5       // access denied
#define SE_ERR_OOM              8       // out of memory
#define SE_ERR_DLLNOTFOUND              32

#endif /* WINVER >= 0x0400 */

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE                    26
#define SE_ERR_ASSOCINCOMPLETE          27
#define SE_ERR_DDETIMEOUT               28
#define SE_ERR_DDEFAIL                  29
#define SE_ERR_DDEBUSY                  30
#define SE_ERR_NOASSOC                  31

#if(WINVER >= 0x0400)

// Note CLASSKEY overrides CLASSNAME
#define SEE_MASK_CLASSNAME        0x00000001
#define SEE_MASK_CLASSKEY         0x00000003
// Note INVOKEIDLIST overrides IDLIST
#define SEE_MASK_IDLIST           0x00000004
#define SEE_MASK_INVOKEIDLIST     0x0000000c
#define SEE_MASK_ICON             0x00000010
#define SEE_MASK_HOTKEY           0x00000020
#define SEE_MASK_NOCLOSEPROCESS   0x00000040
#define SEE_MASK_CONNECTNETDRV    0x00000080
#define SEE_MASK_FLAG_DDEWAIT     0x00000100
#define SEE_MASK_DOENVSUBST       0x00000200
#define SEE_MASK_FLAG_NO_UI       0x00000400
#define SEE_MASK_UNICODE          0x00004000
#define SEE_MASK_NO_CONSOLE       0x00008000
#define SEE_MASK_ASYNCOK          0x00100000
#define SEE_MASK_HMONITOR         0x00200000
#if (_WIN32_IE >= 0x0500)
#define SEE_MASK_NOQUERYCLASSSTORE 0x01000000
#define SEE_MASK_WAITFORINPUTIDLE  0x02000000
#endif // (_WIN32_IE >= 0x500)

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        } DUMMYUNIONNAME;
        HANDLE hProcess;
} SHELLEXECUTEINFOA, *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        } DUMMYUNIONNAME;
        HANDLE hProcess;
} SHELLEXECUTEINFOW, *LPSHELLEXECUTEINFOW;
#ifdef UNICODE
typedef SHELLEXECUTEINFOW SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOW LPSHELLEXECUTEINFO;
#else
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#endif // UNICODE

SHSTDAPI_(BOOL) ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
SHSTDAPI_(BOOL) ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);
#ifdef UNICODE
#define ShellExecuteEx  ShellExecuteExW
#else
#define ShellExecuteEx  ShellExecuteExA
#endif // !UNICODE
SHSTDAPI_(void) WinExecErrorA(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);
SHSTDAPI_(void) WinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);
#ifdef UNICODE
#define WinExecError  WinExecErrorW
#else
#define WinExecError  WinExecErrorA
#endif // !UNICODE

//
//  SHCreateProcessAsUser()
typedef struct _SHCREATEPROCESSINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  pszFile;
        LPCWSTR  pszParameters;
        LPCWSTR  pszCurrentDirectory;
        IN HANDLE hUserToken;
        IN LPSECURITY_ATTRIBUTES lpProcessAttributes;
        IN LPSECURITY_ATTRIBUTES lpThreadAttributes;
        IN BOOL bInheritHandles;
        IN DWORD dwCreationFlags;
        IN LPSTARTUPINFOW lpStartupInfo;
        OUT LPPROCESS_INFORMATION lpProcessInformation;
} SHCREATEPROCESSINFOW, *PSHCREATEPROCESSINFOW;

SHSTDAPI_(BOOL) SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi);

////
////  End ShellExecuteEx and family
////

//
// RecycleBin
//

// struct for query recycle bin info
typedef struct _SHQUERYRBINFO {
    DWORD   cbSize;
#if !defined(_MAC) || defined(_MAC_INT_64)
    __int64 i64Size;
    __int64 i64NumItems;
#else
    DWORDLONG i64Size;
    DWORDLONG i64NumItems;
#endif
} SHQUERYRBINFO, *LPSHQUERYRBINFO;


// flags for SHEmptyRecycleBin
//
#define SHERB_NOCONFIRMATION    0x00000001
#define SHERB_NOPROGRESSUI      0x00000002
#define SHERB_NOSOUND           0x00000004


SHSTDAPI SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
SHSTDAPI SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
#ifdef UNICODE
#define SHQueryRecycleBin  SHQueryRecycleBinW
#else
#define SHQueryRecycleBin  SHQueryRecycleBinA
#endif // !UNICODE
SHSTDAPI SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
SHSTDAPI SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
#ifdef UNICODE
#define SHEmptyRecycleBin  SHEmptyRecycleBinW
#else
#define SHEmptyRecycleBin  SHEmptyRecycleBinA
#endif // !UNICODE

////
//// end of RecycleBin


////
//// Tray notification definitions
////

typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
#if (_WIN32_IE < 0x0500)
        CHAR   szTip[64];
#else
        CHAR   szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        CHAR   szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        CHAR   szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
#if (_WIN32_IE < 0x0500)
        WCHAR  szTip[64];
#else
        WCHAR  szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        WCHAR  szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        WCHAR  szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif // UNICODE


#define NOTIFYICONDATAA_V1_SIZE     FIELD_OFFSET(NOTIFYICONDATAA, szTip[64])
#define NOTIFYICONDATAW_V1_SIZE     FIELD_OFFSET(NOTIFYICONDATAW, szTip[64])
#ifdef UNICODE
#define NOTIFYICONDATA_V1_SIZE      NOTIFYICONDATAW_V1_SIZE
#else
#define NOTIFYICONDATA_V1_SIZE      NOTIFYICONDATAA_V1_SIZE
#endif


#if (_WIN32_IE >= 0x0500)
#define NIN_SELECT          (WM_USER + 0)
#define NINF_KEY            0x1
#define NIN_KEYSELECT       (NIN_SELECT | NINF_KEY)
#endif

#if (_WIN32_IE >= 0x0501)
#define NIN_BALLOONSHOW     (WM_USER + 2)
#define NIN_BALLOONHIDE     (WM_USER + 3)
#define NIN_BALLOONTIMEOUT  (WM_USER + 4)
#define NIN_BALLOONUSERCLICK (WM_USER + 5)
#endif


#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002
#if (_WIN32_IE >= 0x0500)
#define NIM_SETFOCUS    0x00000003
#define NIM_SETVERSION  0x00000004
#define     NOTIFYICON_VERSION 3
#endif

#define NIF_MESSAGE     0x00000001
#define NIF_ICON        0x00000002
#define NIF_TIP         0x00000004
#if (_WIN32_IE >= 0x0500)
#define NIF_STATE       0x00000008
#define NIF_INFO        0x00000010
#endif

#if (_WIN32_IE >= 0x0500)
#define NIS_HIDDEN      0x00000001
#define NIS_SHAREDICON  0x00000002

// Notify Icon Infotip flags
#define NIIF_NONE       0x00000000
// icon flags are mutualy exclusive
// and take only the lowest 2 bits
#define NIIF_INFO       0x00000001
#define NIIF_WARNING    0x00000002
#define NIIF_ERROR      0x00000003
#define NIIF_ICON_MASK  0x0000000F
#if (_WIN32_IE >= 0x0501)
#define NIIF_NOSOUND    0x00000010
#endif
#endif

SHSTDAPI_(BOOL) Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
SHSTDAPI_(BOOL) Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
#ifdef UNICODE
#define Shell_NotifyIcon  Shell_NotifyIconW
#else
#define Shell_NotifyIcon  Shell_NotifyIconA
#endif // !UNICODE

////
//// End Tray Notification Icons
////


#ifndef SHFILEINFO_DEFINED
#define SHFILEINFO_DEFINED
////
//// Begin SHGetFileInfo
////

/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        WCHAR       szDisplayName[MAX_PATH];    // out: display name (or path)
        WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif // UNICODE


// NOTE: This is also in shlwapi.h.  Please keep in synch.
#endif // !SHFILEINFO_DEFINED

#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_ICONLOCATION      0x000001000     // get icon location
#define SHGFI_EXETYPE           0x000002000     // return exe type
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_LINKOVERLAY       0x000008000     // put a link overlay on icon
#define SHGFI_SELECTED          0x000010000     // show icon in selected state
#define SHGFI_ATTR_SPECIFIED    0x000020000     // get only specified attributes
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_OPENICON          0x000000002     // get open icon
#define SHGFI_SHELLICONSIZE     0x000000004     // get shell size icon
#define SHGFI_PIDL              0x000000008     // pszPath is a pidl
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute

#if (_WIN32_IE >= 0x0500)
#define SHGFI_ADDOVERLAYS       0x000000020     // apply the appropriate overlays
#define SHGFI_OVERLAYINDEX      0x000000040     // Get the index of the overlay
                                                // in the upper 8 bits of the iIcon 
#endif

SHSTDAPI_(DWORD_PTR) SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
SHSTDAPI_(DWORD_PTR) SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
#ifdef UNICODE
#define SHGetFileInfo  SHGetFileInfoW
#else
#define SHGetFileInfo  SHGetFileInfoA
#endif // !UNICODE


#define SHGetDiskFreeSpace SHGetDiskFreeSpaceEx

SHSTDAPI_(BOOL) SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
SHSTDAPI_(BOOL) SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
#ifdef UNICODE
#define SHGetDiskFreeSpaceEx  SHGetDiskFreeSpaceExW
#else
#define SHGetDiskFreeSpaceEx  SHGetDiskFreeSpaceExA
#endif // !UNICODE
SHSTDAPI_(BOOL) SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags);
SHSTDAPI_(BOOL) SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);
#ifdef UNICODE
#define SHGetNewLinkInfo  SHGetNewLinkInfoW
#else
#define SHGetNewLinkInfo  SHGetNewLinkInfoA
#endif // !UNICODE

#define SHGNLI_PIDL             0x000000001     // pszLinkTo is a pidl
#define SHGNLI_PREFIXNAME       0x000000002     // Make name "Shortcut to xxx"
#define SHGNLI_NOUNIQUE         0x000000004     // don't do the unique name generation


////
//// End SHGetFileInfo
////

// Printer stuff
#define PRINTACTION_OPEN           0
#define PRINTACTION_PROPERTIES     1
#define PRINTACTION_NETINSTALL     2
#define PRINTACTION_NETINSTALLLINK 3
#define PRINTACTION_TESTPAGE       4
#define PRINTACTION_OPENNETPRN     5
#ifdef WINNT
#define PRINTACTION_DOCUMENTDEFAULTS 6
#define PRINTACTION_SERVERPROPERTIES 7
#endif

SHSTDAPI_(BOOL) SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal);
SHSTDAPI_(BOOL) SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal);
#ifdef UNICODE
#define SHInvokePrinterCommand  SHInvokePrinterCommandW
#else
#define SHInvokePrinterCommand  SHInvokePrinterCommandA
#endif // !UNICODE


#endif /* WINVER >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500) || (_WIN32_WINDOWS >= 0x0500)  

//
// The SHLoadNonloadedIconOverlayIdentifiers API causes the shell's
// icon overlay manager to load any registered icon overlay
// identifers that are not currently loaded.  This is useful if an
// overlay identifier did not load at shell startup but is needed
// and can be loaded at a later time.  Identifiers already loaded
// are not affected.  Overlay identifiers implement the 
// IShellIconOverlayIdentifier interface.
//
// Returns:
//      S_OK
// 
SHSTDAPI SHLoadNonloadedIconOverlayIdentifiers(void);

//
// The SHIsFileAvailableOffline API determines whether a file
// or folder is available for offline use.
//
// Parameters:
//     pwszPath             file name to get info about
//     pdwStatus            (optional) OFFLINE_STATUS_* flags returned here
//
// Returns:
//     S_OK                 File/directory is available offline, unless
//                            OFFLINE_STATUS_INCOMPLETE is returned.
//     E_INVALIDARG         Path is invalid, or not a net path
//     E_FAIL               File/directory is not available offline
// 
// Notes:
//     OFFLINE_STATUS_INCOMPLETE is never returned for directories.
//     Both OFFLINE_STATUS_LOCAL and OFFLINE_STATUS_REMOTE may be returned,
//     indicating "open in both places." This is common when the server is online.
//
SHSTDAPI SHIsFileAvailableOffline(LPCWSTR pwszPath, LPDWORD pdwStatus);

#define OFFLINE_STATUS_LOCAL        0x0001  // If open, it's open locally
#define OFFLINE_STATUS_REMOTE       0x0002  // If open, it's open remotely
#define OFFLINE_STATUS_INCOMPLETE   0x0004  // The local copy is currently imcomplete.
                                            // The file will not be available offline
                                            // until it has been synchronized.

#endif

//  sets the specified path to use the string resource
//  as the UI instead of the file system name
SHSTDAPI SHSetLocalizedName(LPWSTR pszPath, LPCWSTR pszResModule, int idsRes);



#if         _WIN32_IE >= 0x0560

STDAPI          SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress);
STDAPI          SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress);
#ifdef UNICODE
#define SHEnumerateUnreadMailAccounts  SHEnumerateUnreadMailAccountsW
#else
#define SHEnumerateUnreadMailAccounts  SHEnumerateUnreadMailAccountsA
#endif // !UNICODE
STDAPI          SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand);
STDAPI          SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand);
#ifdef UNICODE
#define SHGetUnreadMailCount  SHGetUnreadMailCountW
#else
#define SHGetUnreadMailCount  SHGetUnreadMailCountA
#endif // !UNICODE
STDAPI          SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand);
STDAPI          SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand);
#ifdef UNICODE
#define SHSetUnreadMailCount  SHSetUnreadMailCountW
#else
#define SHSetUnreadMailCount  SHSetUnreadMailCountA
#endif // !UNICODE

#endif  /*  _WIN32_IE >= 0x0560     */


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(_WIN64)
#include <poppack.h>
#endif

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\shlguid.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1995-1999
//
//===========================================================================

#ifndef _SHLGUID_H_
#define _SHLGUID_H_


#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif


#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_SHLGUID(CLSID_ShellDesktop,      0x00021400L, 0, 0);
DEFINE_SHLGUID(CLSID_ShellLink,         0x00021401L, 0, 0);

DEFINE_GUID(CLSID_NetworkPlaces,        0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D);//208D2C60-3AEA-1069-A2D7-08002B30309D
DEFINE_GUID(CLSID_NetworkDomain,        0x46e06680, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//46e06680-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkServer,        0xc0542a90, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//c0542a90-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkShare,         0x54a754c0, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//54a754c0-4bf1-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_MyComputer,           0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D
DEFINE_GUID(CLSID_Internet,             0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D
DEFINE_GUID(CLSID_ShellFSFolder,        0xF3364BA0, 0x65B9, 0x11CE, 0xA9,0xBA,0x00,0xAA,0x00,0x4A,0xE8,0x37);//F3364BA0-65B9-11CE-A9BA-00AA004AE837
DEFINE_GUID(CLSID_RecycleBin,           0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_ControlPanel,         0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);//21EC2020-3AEA-1069-A2DD-08002B30309D
DEFINE_GUID(CLSID_Printers,             0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_MyDocuments,          0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03);//450D8FBA-AD25-11D0-98A8-0800361B1103

// string version of above CLSIDs
// useful for doing psfDesktop->ParseDisplayName( L"::" L STR_MYDOCS_CLSID, ...);

#define STR_MYDOCS_CLSID   "{450D8FBA-AD25-11D0-98A8-0800361B1103}"

#if (_WIN32_IE >= 0x0400)
DEFINE_SHLGUID(CATID_BrowsableShellExt, 0x00021490L, 0, 0);
DEFINE_SHLGUID(CATID_BrowseInPlace,     0x00021491L, 0, 0);
DEFINE_SHLGUID(CATID_DeskBand,          0x00021492L, 0, 0);
DEFINE_SHLGUID(CATID_InfoBand,          0x00021493L, 0, 0);
DEFINE_SHLGUID(CATID_CommBand,          0x00021494L, 0, 0);
#endif

#define PSGUID_INTERNETSHORTCUT {0x000214A0, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_SHLGUID(FMTID_Intshcut,          0x000214A0L, 0, 0);

#define PSGUID_INTERNETSITE {0x000214A1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_SHLGUID(FMTID_InternetSite,      0x000214A1L, 0, 0);

DEFINE_SHLGUID(CGID_Explorer,           0x000214D0L, 0, 0);
DEFINE_SHLGUID(CGID_ShellDocView,       0x000214D1L, 0, 0);

#if (_WIN32_IE >= 0x0400)
DEFINE_SHLGUID(CGID_ShellServiceObject, 0x000214D2L, 0, 0);
DEFINE_SHLGUID(CGID_ExplorerBarDoc,     0x000214D3L, 0, 0);
#endif


DEFINE_SHLGUID(IID_INewShortcutHookA,   0x000214E1L, 0, 0);
DEFINE_SHLGUID(IID_IShellBrowser,       0x000214E2L, 0, 0);
DEFINE_SHLGUID(IID_IShellView,          0x000214E3L, 0, 0);
DEFINE_SHLGUID(IID_IContextMenu,        0x000214E4L, 0, 0);
DEFINE_SHLGUID(IID_IShellIcon,          0x000214E5L, 0, 0);
DEFINE_SHLGUID(IID_IShellFolder,        0x000214E6L, 0, 0);
DEFINE_SHLGUID(IID_IShellExtInit,       0x000214E8L, 0, 0);
DEFINE_SHLGUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0);
DEFINE_SHLGUID(IID_IPersistFolder,      0x000214EAL, 0, 0);
DEFINE_SHLGUID(IID_IExtractIconA,       0x000214EBL, 0, 0);
DEFINE_SHLGUID(IID_IShellDetails,       0x000214ECL, 0, 0);
DEFINE_SHLGUID(IID_IDelayedRelease,     0x000214EDL, 0, 0);
DEFINE_SHLGUID(IID_IShellLinkA,         0x000214EEL, 0, 0);
DEFINE_SHLGUID(IID_IShellCopyHookA,     0x000214EFL, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerA,        0x000214F0L, 0, 0);
DEFINE_SHLGUID(IID_ICommDlgBrowser,     0x000214F1L, 0, 0);
DEFINE_SHLGUID(IID_IEnumIDList,         0x000214F2L, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerSite,     0x000214F3L, 0, 0);
DEFINE_SHLGUID(IID_IContextMenu2,       0x000214F4L, 0, 0);
DEFINE_SHLGUID(IID_IShellExecuteHookA,  0x000214F5L, 0, 0);
DEFINE_SHLGUID(IID_IPropSheetPage,      0x000214F6L, 0, 0);
DEFINE_SHLGUID(IID_INewShortcutHookW,   0x000214F7L, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerW,        0x000214F8L, 0, 0);
DEFINE_SHLGUID(IID_IShellLinkW,         0x000214F9L, 0, 0);
DEFINE_SHLGUID(IID_IExtractIconW,       0x000214FAL, 0, 0);
DEFINE_SHLGUID(IID_IShellExecuteHookW,  0x000214FBL, 0, 0);
DEFINE_SHLGUID(IID_IShellCopyHookW,     0x000214FCL, 0, 0);

DEFINE_SHLGUID(IID_IRemoteComputer,     0x000214FEL, 0, 0);

#define IID_ICopyHookA                  IID_IShellCopyHookA
#define IID_ICopyHookW                  IID_IShellCopyHookW

#define SID_LinkSite    IID_IShellLinkW     // IServiceProvider::QueryService() access the link object that is defering to you 

#if (_WIN32_IE >= 0x0400)
DEFINE_SHLGUID(IID_IQueryInfo,          0x00021500L, 0, 0);
#endif

DEFINE_GUID(IID_IBriefcaseStg,          0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
DEFINE_GUID(IID_IShellView2,            0x88E39E80L, 0x3578, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
DEFINE_GUID(IID_IShellLinkDataList,     0x45e2b4ae, 0xb1c3, 0x11d0, 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
#if (_WIN32_IE >= 0x0500)
DEFINE_GUID(IID_IResolveShellLink,      0x5cd52983, 0x9449, 0x11d2, 0x96, 0x3a, 0x00, 0xc0, 0x4f, 0x79, 0xad, 0xf0);
#endif // _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IFolderView,            0xC75466C8L, 0xA051, 0x4049, 0xA2, 0x7F, 0xCA, 0x1E, 0x2E, 0x3B, 0x7B, 0x39);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IURLSearchHook,         0xAC60F6A0L, 0x0FD9, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
DEFINE_GUID(IID_ISearchContext,         0x09F656A2L, 0x41AF, 0x480C, 0x88, 0xF7, 0x16, 0xCC, 0x0D, 0x16, 0x46, 0x15);
DEFINE_GUID(IID_IURLSearchHook2,        0x5ee44da4L, 0x6d32, 0x46e3, 0x86, 0xbc, 0x07, 0x54, 0x0d, 0xed, 0xd0, 0xe0);
DEFINE_GUID(IID_IDelegateFolder,        0xADD8BA80L, 0x002B, 0x11D0, 0x8F, 0x0F, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);

#if (_WIN32_IE >= 0x0500)
// CLSID_FolderShortcut {0AFACED1-E828-11D1-9187-B532F1E9575D}
DEFINE_GUID(CLSID_FolderShortcut,       0x0AFACED1L, 0xE828, 0x11D1, 0x91, 0x87, 0xB5, 0x32, 0xF1, 0xE9, 0x57, 0x5D);

// CLSID_StorageFolder {E773F1AF-3A65-4866-857D-846FC9C4598A}
DEFINE_GUID(CLSID_StgFolder,            0xE773F1AFL, 0x3A65, 0x4866, 0x85, 0x7D, 0x84, 0x6F, 0xC9, 0xC4, 0x59, 0x8A);

// CLSID_CDBurn {fbeb8a05-beee-4442-804e-409d6c4515e9}
DEFINE_GUID(CLSID_CDBurn,               0xfbeb8a05L, 0xbeee, 0x4442, 0x80, 0x4e, 0x40, 0x9d, 0x6c, 0x45, 0x15, 0xe9);
#endif


DEFINE_GUID(IID_IInputObject,           0x68284faa, 0x6a48, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);
DEFINE_GUID(IID_IInputObjectSite,       0xf1db8392, 0x7331, 0x11d0, 0x8c, 0x99, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IDockingWindowSite,     0x2a342fc2, 0x7b26, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IDockingWindowFrame,    0x47d2657a, 0x7b27, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IShellIconOverlay,      0x7D688A70L, 0xC613, 0x11D0, 0x99, 0x9B, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
DEFINE_GUID(IID_IShellIconOverlayIdentifier,  0x0C6C4200L, 0xC589, 0x11D0, 0x99, 0x9A, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);


// {10339516-2894-11d2-9039-00C04F8EEB3E}
DEFINE_GUID(IID_ICommDlgBrowser2,       0x10339516, 0x2894, 0x11d2, 0x90, 0x39, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);


// 2047E320-F2A9-11CE-AE65-08002B2E1262
DEFINE_GUID(IID_IShellFolderViewCB, 0x2047E320L, 0xF2A9, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
#define SID_ShellFolderViewCB IID_IShellFolderViewCB

// {1AC3D9F0-175C-11d1-95BE-00609797EA4F}
DEFINE_GUID(IID_IPersistFolder2,        0x1ac3d9f0, 0x175c, 0x11d1, 0x95, 0xbe, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);
// {CEF04FDF-FE72-11d2-87A5-00C04F6837CF}
DEFINE_GUID(IID_IPersistFolder3,        0xcef04fdf, 0xfe72, 0x11d2, 0x87, 0xa5, 0x0, 0xc0, 0x4f, 0x68, 0x37, 0xcf);

// {63B51F81-C868-11D0-999C-00C04FD655E1}
DEFINE_GUID(CLSID_CFSIconOverlayManager, 0x63B51F81L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);


// {BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractImage,               0xbb2e617c, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {85788D00-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IRunnableTask,               0x85788d00, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);


#if (_WIN32_IE >= 0x0500)
// {953BB1EE-93B4-11d1-98A3-00C04FB687DA}
DEFINE_GUID(IID_IExtractImage2,              0x953bb1ee, 0x93b4, 0x11d1, 0x98, 0xa3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);
#endif

// {4ea39266-7211-409f-b622-f63dbd16c533}
DEFINE_GUID(IID_IThumbnailCapture,           0x4ea39266, 0x7211, 0x409f, 0xb6, 0x22, 0xf6, 0x3d, 0xbd, 0x16, 0xc5, 0x33);


// {BCFCE0A0-EC17-11d0-8D10-00A0C90F2719}
DEFINE_GUID(IID_IContextMenu3,          0xbcfce0a0, 0xec17, 0x11d0, 0x8d, 0x10, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


#endif // _WIN32_IE >= 0x0400


#define SID_SShellBrowser IID_IShellBrowser
#if (_WIN32_IE >= 0x0400)
#define SID_SShellDesktop CLSID_ShellDesktop
#endif

#if (_WIN32_IE >= 0x0400)
//
//  IShellDiscardable is an IID-only interface. If the object supports this
// interface it can be discarded anytime. IWebBrowser::PutProperty QI's for
// this interface to detect discardable properties. 
//
DEFINE_GUID(IID_IDiscardableBrowserProperty, 0x49c3de7c, 0xd329, 0x11d0, 0xab, 0x73, 0x00, 0xc0, 0x4f, 0xc3, 0x3e, 0x80);

// IShellChangeNotify is a sink of LPCITEMIDLIST notification events
//
// D82BE2B1-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(IID_IShellChangeNotify, 0xD82BE2B1L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

#endif // _WIN32_IE >= 0x0400

#ifdef UNICODE
#define IID_IFileViewer         IID_IFileViewerW
#define IID_IShellLink          IID_IShellLinkW
#define IID_IExtractIcon        IID_IExtractIconW
#define IID_IShellCopyHook      IID_IShellCopyHookW
#define IID_IShellExecuteHook   IID_IShellExecuteHookW
#define IID_INewShortcutHook    IID_INewShortcutHookW
#else
#define IID_IFileViewer         IID_IFileViewerA
#define IID_IShellLink          IID_IShellLinkA
#define IID_IExtractIcon        IID_IExtractIconA
#define IID_IShellCopyHook      IID_IShellCopyHookA
#define IID_IShellExecuteHook   IID_IShellExecuteHookA
#define IID_INewShortcutHook    IID_INewShortcutHookA
#endif


#ifndef NO_INTSHCUT_GUIDS
#include <isguids.h>            // internet shortcut GUIDs
#endif

#ifndef NO_SHDOCVW_GUIDS

#ifndef GUID_DEFS_ONLY
#include <exdisp.h>
#include <shldisp.h>
#endif


#if (_WIN32_IE >= 0x0400)
// UrlHistory Guids
DEFINE_GUID(CLSID_CUrlHistory,          0x3C374A40L, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE);
#define SID_SUrlHistory         CLSID_CUrlHistory

//UrlSearchHook Guids
DEFINE_GUID(CLSID_CURLSearchHook,       0xCFBFAE00L, 0x17A6, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


#define SID_SInternetExplorer IID_IWebBrowserApp
#define SID_SWebBrowserApp    IID_IWebBrowserApp

// AutoComplete Guids
DEFINE_GUID(IID_IAutoCompList,          0x00BB2760L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(IID_IObjMgr,                0x00BB2761L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(IID_IACList,                0x77A130B0L, 0x94FD, 0x11D0, 0xA5, 0x44, 0x00, 0xC0, 0x4F, 0xD7, 0xd0, 0x62);
DEFINE_GUID(IID_IACList2,               0x470141a0L, 0x5186, 0x11d2, 0xbb, 0xb6, 0x00, 0x60, 0x97, 0x7b, 0x46, 0x4c);
DEFINE_GUID(IID_ICurrentWorkingDirectory, 0x91956d21L, 0x9276, 0x11d1, 0x92, 0x1a, 0x00, 0x60, 0x97, 0xdf, 0x5b, 0xd4);     // {91956D21-9276-11d1-921A-006097DF5BD4}
DEFINE_GUID(CLSID_AutoComplete,         0x00BB2763L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACLHistory,           0x00BB2764L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACListISF,            0x03C036F1L, 0xA186, 0x11D0, 0x82, 0x4A, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83);
DEFINE_GUID(CLSID_ACLMRU,               0x6756a641L, 0xde71, 0x11d0, 0x83, 0x1b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);          // {6756A641-DE71-11d0-831B-00AA005B4383}
DEFINE_GUID(CLSID_ACLMulti,             0x00BB2765L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
#if (_WIN32_IE >= 0x0560)
DEFINE_GUID(CLSID_ACLCustomMRU,      0x6935db93, 0x21e8, 0x4ccc, 0xbe, 0xb9, 0x9f, 0xe3, 0xc7, 0x7a, 0x29, 0x7a);
#endif


#if (_WIN32_IE >= 0x0500)
/// IProgressDialog
// {F8383852-FCD3-11d1-A6B9-006097DF5BD4}
DEFINE_GUID(CLSID_ProgressDialog,       0xf8383852, 0xfcd3, 0x11d1, 0xa6, 0xb9, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
// {EBBC7C04-315E-11d2-B62F-006097DF5BD4}
DEFINE_GUID(IID_IProgressDialog,        0xebbc7c04, 0x315e, 0x11d2, 0xb6, 0x2f, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
#endif // _WIN32_IE >= 0x0500

// 
// Progress objects exposed via QueryService
//
#define SID_SProgressUI CLSID_ProgressDialog


//
// Top-most browser implementation in the heirarchy. use IServiceProvider::QueryService()
// to get to interfaces (IID_IShellBrowser, IID_IBrowserService, etc.)
//
DEFINE_GUID(SID_STopLevelBrowser,       0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif // _WIN32_IE >= 0x0400

#endif // !NO_SHDOCVW_GUIDS


#if (_WIN32_IE >= 0x0400)

// {75048700-EF1F-11D0-9888-006097DEACF9}
DEFINE_GUID( CLSID_ActiveDesktop, 0x75048700L, 0xEF1F, 0x11D0, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {F490EB00-1240-11D1-9888-006097DEACF9}
DEFINE_GUID(IID_IActiveDesktop, 0xF490EB00L, 0x1240, 0x11D1, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);


// {56FDF344-FD6D-11d0-958A-006097C9A090}
DEFINE_GUID(CLSID_TaskbarList, 0x56fdf344, 0xfd6d, 0x11d0, 0x95, 0x8a, 0x0, 0x60, 0x97, 0xc9, 0xa0, 0x90);

// {56FDF342-FD6D-11d0-958A-006097C9A090}
DEFINE_GUID(IID_ITaskbarList, 0x56fdf342, 0xfd6d, 0x11d0, 0x95, 0x8a, 0x0, 0x60, 0x97, 0xc9, 0xa0, 0x90);

// {74C26041-70D1-11d1-B75A-00A0C90564FE}
DEFINE_GUID(IID_ISynchronizedCallBack, 0x74c26041, 0x70d1, 0x11d1, 0xb7, 0x5a, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// Extended column handler interfaces
// {D2A105C0-87D5-11d1-8391-0000F80461CF}
DEFINE_GUID(IID_IShellDetails3,        0xd2a105c0, 0x87d5, 0x11d1, 0x83, 0x91, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

//  {c46ca590-3c3f-11d2-bee6-0000f805ca57}
DEFINE_GUID(IID_IQueryAssociations,          0xc46ca590, 0x3c3f, 0x11d2, 0xbe, 0xe6, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57);

// {a07034fd-6caa-4954-ac3f-97a27216f98a}
DEFINE_GUID(CLSID_QueryAssociations, 0xa07034fd, 0x6caa, 0x4954, 0xac, 0x3f, 0x97, 0xa2, 0x72, 0x16, 0xf9, 0x8a);

// {E8025004-1C42-11d2-BE2C-00A0C9A83DA1}
DEFINE_GUID(IID_IColumnProvider,        0xe8025004, 0x1c42, 0x11d2, 0xbe, 0x2c, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1);

// {24F14F01-7B1C-11d1-838f-0000F80461CF}
DEFINE_GUID(CLSID_DocFileColumnProvider, 0x24f14f01, 0x7b1c, 0x11d1, 0x83, 0x8f, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// {24F14F02-7B1C-11d1-838f-0000F80461CF}
DEFINE_GUID(CLSID_LinkColumnProvider,    0x24f14f02, 0x7b1c, 0x11d1, 0x83, 0x8f, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// {0D2E74C4-3C34-11d2-A27E-00C04FC30871}
DEFINE_GUID(CLSID_FileSysColumnProvider, 0xd2e74c4, 0x3c34, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);

// {875CB1A1-0F29-45de-A1AE-CFB4950D0B78}
DEFINE_GUID(CLSID_MusicPropSetStg,
0x875cb1a1, 0xf29, 0x45de, 0xa1, 0xae, 0xcf, 0xb4, 0x95, 0xd, 0xb, 0x78);

// For Internet Shortcut Creation Command
// The shell uses this command to allow trident to save off it's per frame data in the shortcut
// and to allow it to fire the OnPersist() event on every frame
// {93A68750-951A-11d1-946F-000000000000}
DEFINE_GUID(CGID_ShortCut, 0x93a68750, 0x951a, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


// {FB700430-952C-11d1-946F-000000000000}
DEFINE_GUID(IID_INamedPropertyBag, 0xfb700430, 0x952c, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {1E796980-9CC5-11D1-A83F-00C04FC99D61}
DEFINE_GUID(CLSID_InternetButtons, 0x1E796980L, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

#if (_WIN32_IE >= 0x0500)
// {178F34B8-A282-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_MSOButtons, 0x178f34b8, 0xa282, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

// {2CE4B5D8-A28F-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_ToolbarExtButtons, 0x2ce4b5d8, 0xa28f, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);
#endif // _WIN32_IE >= 0x0500

// {CFCCC7A0-A282-11D1-9082-006008059382}
DEFINE_GUID(CLSID_DarwinAppPublisher, 0xCFCCC7A0L, 0xA282, 0x11D1, 0x90, 0x82, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {7057E952-BD1B-11d1-8919-00C04FC2C836}
DEFINE_GUID(CLSID_DocHostUIHandler, 0x7057e952, 0xbd1b, 0x11d1, 0x89, 0x19, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);
#endif  // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0500)

// {93F2F68C-1D1B-11d3-A30E-00C04F79ABD1}
DEFINE_GUID(IID_IShellFolder2,  0x93f2f68c, 0x1d1b, 0x11d3, 0xa3, 0xe, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xd1);

#define PSGUID_SHELLDETAILS     {0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0}
DEFINE_GUID(FMTID_ShellDetails,  0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define PID_FINDDATA        0
#define PID_NETRESOURCE     1
#define PID_DESCRIPTIONID   2
#define PID_WHICHFOLDER     3

// PSGUID_STORAGE comes from ntquery.h
//#define PSGUID_STORAGE    {0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac}
DEFINE_GUID(FMTID_Storage,   0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac);

// Image properties 
#define PSGUID_IMAGEPROPERTIES {0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99}
DEFINE_GUID(FMTID_ImageProperties, 0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99);

// The GUIDs used to identify shell item attributes (columns). See IShellFolder2::GetDetailsEx implementations...

// {9B174B33-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_DISPLACED    {0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Displaced, 0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_DISPLACED_FROM  2
#define PID_DISPLACED_DATE  3

// {9B174B34-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_MISC    {0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Misc, 0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_MISC_STATUS         2
#define PID_MISC_ACCESSCOUNT    3
#define PID_MISC_OWNER          4
#define PID_HTMLINFOTIPFILE     5
#define PID_MISC_PICS           6

// {F2275480-F782-4291-BD94-F13693513AEC}
#define PSGUID_WEBVIEW  {0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec}
DEFINE_GUID(FMTID_WebView, 0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec);
#define PID_DISPLAY_PROPERTIES  0

// {56A3372E-CE9C-11d2-9F0E-006097C686F6}
#define PSGUID_MUSIC    {0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6}
DEFINE_GUID(FMTID_MUSIC, 0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);
#define PIDSI_ARTIST    2
#define PIDSI_SONGTITLE 3
#define PIDSI_ALBUM     4
#define PIDSI_YEAR      5
#define PIDSI_COMMENT   6
#define PIDSI_TRACK     7
#define PIDSI_DURATION  8
#define PIDSI_BITRATE   9

// {305CA226-D286-468e-B848-2B2E8E697B74}
#define PSGUID_CONTROLPANEL {0x305ca226, 0xd286, 0x468e, 0xb8, 0x48, 0x2b, 0x2e, 0x8e, 0x69, 0x7b, 0x74}
#define PID_CONTROLPANEL_CATEGORY 2

// {9B174B35-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_VOLUME    {0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Volume, 0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_VOLUME_FREE      2

#define PSGUID_QUERY_D {0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9}
DEFINE_GUID(FMTID_Query, 0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9);
#define PID_QUERY_RANK	2

// FMTID_SummaryInformation, see OLE docs for PID_ values for these
#define PSGUID_SUMMARYINFORMATION	{0xf29f85e0L, 0x4ff9, 0x1068, 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9}
// FMTID_DocumentSummaryInformation, see OLE docs on the PID_ values for this
#define PSGUID_DOCUMENTSUMMARYINFORMATION {0xd5cdd502L, 0x2e9c, 0x101b, 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae}

// FMTID_MediaFileSummaryInformation, see propidl.h PID_ values for this
#define PSGUID_MEDIAFILESUMMARYINFORMATION {0x64440492L, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x08, 0x00, 0x36, 0xb1, 0x1a, 0x03}

// {0E700BE1-9DB6-11d1-A1CE-00C04FD75D13}
DEFINE_GUID(IID_IEnumExtraSearch,  0xe700be1, 0x9db6, 0x11d1, 0xa1, 0xce, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {12518493-00B2-11d2-9FA5-9E3420524153}
DEFINE_GUID(CLSID_MountedVolume, 0x12518493, 0x00B2, 0x11d2, 0x9F, 0xA5, 0x9E, 0x34, 0x20, 0x52, 0x41, 0x53);

// {FFB8655F-81B9-4fce-B89C-9A6BA76D13E7}
DEFINE_GUID(CLSID_HWShellExecute, 0xffb8655f, 0x81b9, 0x4fce, 0xb8, 0x9c, 0x9a, 0x6b, 0xa7, 0x6d, 0x13, 0xe7);

// {12518492-00B2-11d2-9FA5-9E3420524153}
DEFINE_GUID(IID_IMountedVolume, 0x12518492, 0x00B2, 0x11d2, 0x9F, 0xA5, 0x9E, 0x34, 0x20, 0x52, 0x41, 0x53);

// {4657278A-411B-11d2-839A-00C04FD918D0}
DEFINE_GUID(CLSID_DragDropHelper,   0x4657278a, 0x411b, 0x11d2, 0x83, 0x9a, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {4657278B-411B-11d2-839A-00C04FD918D0}
DEFINE_GUID(IID_IDropTargetHelper,  0x4657278b, 0x411b, 0x11d2, 0x83, 0x9a, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {DE5BF786-477A-11d2-839D-00C04FD918D0}
DEFINE_GUID(IID_IDragSourceHelper,  0xde5bf786, 0x477a, 0x11d2, 0x83, 0x9d, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {3050f3BB-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CAnchorBrowsePropertyPage, 0x3050f3BB, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B3-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CImageBrowsePropertyPage, 0x3050f3B3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B4-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CDocBrowsePropertyPage, 0x3050f3B4, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {01E18D10-4D8B-11d2-855D-006008059367}
DEFINE_GUID(IID_IFileSystemBindData, 0x1e18d10, 0x4d8b, 0x11d2, 0x85, 0x5d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67);

// {49E1B500-4636-11d3-97F7-00C04F45D0B3}
DEFINE_GUID(SID_STopWindow, 0x49e1b500, 0x4636, 0x11d3, 0x97, 0xf7, 0x0, 0xc0, 0x4f, 0x45, 0xd0, 0xb3);

// {889A935D-971E-4B12-B90C-24DFC9E1E5E8}
DEFINE_GUID(SID_SGetViewFromViewDual, 0x889A935D, 0x971E, 0x4B12, 0xB9, 0x0C, 0x24, 0xDF, 0xC9, 0xE1, 0xE5, 0xE8);


//  BHIDs for IShellItem::BindToHandler()
#define BHID_LocalCopyHelper     CLSID_LocalCopyHelper
//  {3981e224-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFObject, 0x3981e224, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);
//  {3981e225-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFUIObject, 0x3981e225, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);
//  {3981e226-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFViewObject, 0x3981e226, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);
//  {3981e227-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_Storage, 0x3981e227, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);
//  {3981e228-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_LinkTargetItem, 0x3981e228, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

#endif // _WIN32_IE >= 0x0500


#if _WIN32_IE >= 0x0560


// {6b33163c-76a5-4b6c-bf21-45de9cd503a1
DEFINE_GUID(CLSID_PublishingWizard, 0x6b33163c, 0x76a5, 0x4b6c, 0xbf, 0x21, 0x45, 0xde, 0x9c, 0xd5, 0x03, 0xa1);
#define SID_PublishingWizard CLSID_PublishingWizard
// {CC6EEFFB-43F6-46c5-9619-51D571967F7D}
DEFINE_GUID(CLSID_PublishDropTarget, 0xcc6eeffb, 0x43f6, 0x46c5, 0x96, 0x19, 0x51, 0xd5, 0x71, 0x96, 0x7f, 0x7d);


#endif // _WIN32_IE >= 0x0560



#endif // _SHLGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\shlobj.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1998
//
// File: shlobj.h
//
//===========================================================================

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if defined(_SHELL32_)
#define WINSHELLAPI
#else
#define WINSHELLAPI       DECLSPEC_IMPORT
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if defined(_SHELL32_)
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#else
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if defined(_SHDOCVW_)
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#else
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHDOCAPI

// shell32 APIs that are also exported from shdocvw
#ifndef SHSTDDOCAPI
#if defined(_SHDOCVW_) || defined(_SHELL32_)
#define SHSTDDOCAPI          STDAPI
#define SHSTDDOCAPI_(type)   STDAPI_(type)
#else
#define SHSTDDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDDOCAPI

#ifndef BROWSEUIAPI
#if defined(_BROWSEUI_)
#define BROWSEUIAPI           STDAPI
#define BROWSEUIAPI_(type)    STDAPI_(type)
#else
#define BROWSEUIAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define BROWSEUIAPI_(type)    EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif // defined(_BROWSEUI_)
#endif // BROWSEUIAPI

// shell32 APIs that are also exported from shfolder
#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_) || defined(_SHELL32_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif



#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>   // for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */


#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#include <shtypes.h>


#include <shobjidl.h>


//===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// #define SHGetMalloc(ppmem)   CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================

SHSTDAPI SHGetMalloc(LPMALLOC * ppMalloc);


//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//    hMonitor -- Specifies the default monitor (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

// QueryContextMenu uFlags
#define CMF_NORMAL              0x00000000
#define CMF_DEFAULTONLY         0x00000001
#define CMF_VERBSONLY           0x00000002
#define CMF_EXPLORE             0x00000004
#define CMF_NOVERBS             0x00000008
#define CMF_CANRENAME           0x00000010
#define CMF_NODEFAULT           0x00000020
#define CMF_INCLUDESTATIC       0x00000040
#define CMF_FINDHACK            0x00000080
#define CMF_EXTENDEDVERBS       0x00000100      // rarely used verbs
#define CMF_RESERVED            0xffff0000      // View specific


// GetCommandString uFlags
#define GCS_VERBA        0x00000000     // canonical verb
#define GCS_HELPTEXTA    0x00000001     // help text (for status bar)
#define GCS_VALIDATEA    0x00000002     // validate command exists
#define GCS_VERBW        0x00000004     // canonical verb (unicode)
#define GCS_HELPTEXTW    0x00000005     // help text (unicode version)
#define GCS_VALIDATEW    0x00000006     // validate command exists (unicode)
#define GCS_UNICODE      0x00000004     // for bit testing - Unicode string

#ifdef UNICODE
#define GCS_VERB        GCS_VERBW
#define GCS_HELPTEXT    GCS_HELPTEXTW
#define GCS_VALIDATE    GCS_VALIDATEW
#else
#define GCS_VERB        GCS_VERBA
#define GCS_HELPTEXT    GCS_HELPTEXTA
#define GCS_VALIDATE    GCS_VALIDATEA
#endif

#define CMDSTR_NEWFOLDERA   "NewFolder"
#define CMDSTR_VIEWLISTA    "ViewList"
#define CMDSTR_VIEWDETAILSA "ViewDetails"
#define CMDSTR_NEWFOLDERW   L"NewFolder"
#define CMDSTR_VIEWLISTW    L"ViewList"
#define CMDSTR_VIEWDETAILSW L"ViewDetails"

#ifdef UNICODE
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW
#else
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA
#endif

#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY
#define CMIC_MASK_ICON          SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE
#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE
#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME
#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM
#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE
#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK
#if (_WIN32_IE >= 0x0501)
#define CMIC_MASK_SHIFT_DOWN    0x10000000
#define CMIC_MASK_CONTROL_DOWN  0x20000000
#endif // (_WIN32_IE >= 0x501)


#if (_WIN32_IE >= 0x0400)
#define CMIC_MASK_PTINVOKE      0x20000000
#endif


#include <pshpack8.h>  

//NOTE: When SEE_MASK_HMONITOR is set, hIcon is treated as hMonitor
typedef struct _CMINVOKECOMMANDINFO {
    DWORD cbSize;        // sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    HANDLE hIcon;
} CMINVOKECOMMANDINFO,  *LPCMINVOKECOMMANDINFO;

typedef struct _CMInvokeCommandInfoEx {
    DWORD cbSize;        // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;

    HANDLE hIcon;
    LPCSTR lpTitle;      // For CreateProcess-StartupInfo.lpTitle
    LPCWSTR lpVerbW;        // Unicode verb (for those who can use it)
    LPCWSTR lpParametersW;  // Unicode parameters (for those who can use it)
    LPCWSTR lpDirectoryW;   // Unicode directory (for those who can use it)
    LPCWSTR lpTitleW;       // Unicode title (for those who can use it)
#if (_WIN32_IE >= 0x0400)
    POINT   ptInvoke;       // Point where it's invoked
#endif
} CMINVOKECOMMANDINFOEX,  *LPCMINVOKECOMMANDINFOEX;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IContextMenu

DECLARE_INTERFACE_(IContextMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;
};

typedef IContextMenu *  LPCONTEXTMENU;

//
// IContextMenu2 (IContextMenu with one new member)
//
// IContextMenu2::HandleMenuMsg
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu2 interface and receives one of following messages while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//      WM_INITPOPUP, WM_DRAWITEM and WM_MEASUREITEM
//  The callee may handle these messages to draw owner draw menuitems.
//

#undef  INTERFACE
#define INTERFACE   IContextMenu2

DECLARE_INTERFACE_(IContextMenu2, IContextMenu)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***

    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;
};

typedef IContextMenu2 * LPCONTEXTMENU2;

//
// IContextMenu3 (IContextMenu with one new member)
//
// IContextMenu3::HandleMenuMsg2
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu3 interface and receives a menu message while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//

#undef  INTERFACE
#define INTERFACE   IContextMenu3

DECLARE_INTERFACE_(IContextMenu3, IContextMenu2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***

    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;

    // *** IContextMenu3 methods ***

    STDMETHOD(HandleMenuMsg2)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             LRESULT* plResult) PURE;
};

typedef IContextMenu3 * LPCONTEXTMENU3;


#if (_WIN32_IE >= 0x0500)
#undef  INTERFACE
#define INTERFACE   IPersistFolder3

#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY

// DESCRIPTION: PERSIST_FOLDER_TARGET_INFO
//    This stucture is used for Folder Shortcuts which allow the shell to
// have a file system folder act like another area in the name space.
// One of pidlTargetFolder, szTargetParsingName, or csidl needs to
// specify the destination name space.
//
// pidlTargetFolder: This is a full pidl to the target folder.  Can be NULL in the IPersistFolder3::InitializeEx()
//                   call but not in the GetFolderTargetInfo() return structure.
// szTargetParsingName: Empty string if not specified. Ortherwise, it is the parsible name
//                       to the target.  This name can be parsed by IShellFolder::
//                       ParseDisplayName() from the desktop.
// szNetworkProvider: Can be an empty string.  If not empty, it specifies the type of network
//                    provider that will be used when binding to the target.  This is used
//                    for performance optimizations for the WNet APIs.
// dwAttributes: -1 if not known.  These are the SFGAO_ flags for IShellFolder::GetAttributesOf()
// csidl: This is -1 if it's not used.  This can be used instead of pidlTargetFolder or
//        szTargetParsingName to indicate the TargetFolder.  See the list of CSIDL_ folders
//        below.  CSIDL_FLAG_PFTI_TRACKTARGET means that the IShellFolder's target folder
//        should change if the user changes the target of the underlying CSIDL value.
//        You can also pass CSIDL_FLAG_CREATE to indicate that the target folder
//        should be created if it does not exist.  No other CSIDL_FLAG_* values are supported.

#include <pshpack8.h>  

typedef struct
{
    LPITEMIDLIST  pidlTargetFolder;               // pidl for the folder we want to intiailize
    WCHAR         szTargetParsingName[MAX_PATH];  // optional parsing name for the target
    WCHAR         szNetworkProvider[MAX_PATH];    // optional network provider
    DWORD         dwAttributes;                   // optional FILE_ATTRIBUTES_ flags (-1 if not used)
    int           csidl;                          // optional folder index (SHGetFolderPath()) -1 if not used
} PERSIST_FOLDER_TARGET_INFO;

#include <poppack.h>        /* Return to byte packing */


// DESCRIPTION: IPersistFolder3
//    This interface is implemented by an IShellFolder object that wants non-default
// handling of Folder Shortcuts.  In general, shell name space extensions should use
// pidlRoot (the alias pidl) as their location in the name space and pass it to public
// APIs, such as ShellExecute().  The one exception is that pidlTarget should be used
// when sending ChangeNotifies or registering to listen for change notifies
// (see SFVM_GETNOTIFY).
//
// InitializeEx: This method initializes an IShellFolder and specifies where
//               it is rooted in the name space.
//      pbc: May be NULL.
//      pidlRoot: This is the same parameter as IPersistFolder::Initialize(). Caller allocates
//                and frees this parameter.
//      ppfti: May be NULL, in which case this is the same as a call to IPersistFolder::Initialize().
//             Otherwise this is a Folder Shortcut and this structure specifies the target
//             folder and it's attributes.
// GetFolderTargetInfo: This is used by the caller to find information about
//             the folder shortcut.  This structure may not be initialized by the caller,
//             so the callee needs to initialize every member.  The callee allocates
//             pidlTargetFolder and the caller will free it.  Filling in pidlTargetFolder is
//             ALWAYS required.
DECLARE_INTERFACE_(IPersistFolder3, IPersistFolder2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidl) PURE;

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder)(THIS_ LPITEMIDLIST *ppidl) PURE;

    // *** IPersistFolder3 methods ***
    STDMETHOD(InitializeEx)(THIS_ IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti) PURE;
    STDMETHOD(GetFolderTargetInfo)(THIS_ PERSIST_FOLDER_TARGET_INFO *ppfti) PURE;
};


#endif

//

//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder
#define GIL_ASYNC        0x0020      // this is an async extract, return E_PENDING
#define GIL_DEFAULTICON  0x0040      // get the default icon location if the final one takes too long to get

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_(IExtractIconA, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_(IExtractIconW, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPWSTR szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCWSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif

//===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIcon

DECLARE_INTERFACE_(IShellIcon, IUnknown)      // shi
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIcon methods ***
    STDMETHOD(GetIconOf)(THIS_ LPCITEMIDLIST pidl, UINT flags,
                    LPINT lpIconIndex) PURE;
};

typedef IShellIcon *LPSHELLICON;

//===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex 
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayIdentifier

DECLARE_INTERFACE_(IShellIconOverlayIdentifier, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayIdentifier methods ***
    STDMETHOD (IsMemberOf)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib) PURE;
    STDMETHOD (GetOverlayInfo)(THIS_ LPWSTR pwszIconFile, int cchMax, int * pIndex, DWORD * pdwFlags) PURE;
    STDMETHOD (GetPriority)(THIS_ int * pIPriority) PURE;
};

#define ISIOI_ICONFILE            0x00000001          // path is returned through pwszIconFile
#define ISIOI_ICONINDEX           0x00000002          // icon index in pwszIconFile is returned through pIndex


//===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object,
// this is always implemented with IShellFolder
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list
// This method is only used for those who are interested in seeing the real bits
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlay

DECLARE_INTERFACE_(IShellIconOverlay, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlay methods ***
    STDMETHOD(GetOverlayIndex)(THIS_ LPCITEMIDLIST pidl, int * pIndex) PURE;
    STDMETHOD(GetOverlayIconIndex)(THIS_ LPCITEMIDLIST pidl, int * pIconIndex) PURE;
};

#define OI_ASYNC 0xFFFFEEEE

//-------------------------------------------------------------------------
//
// SHGetIconOverlayIndex
//
// This function takes the path and icon/res id to the icon and convert it into 
// an overlay index in the system image list. 
// Note: there are totally only 15 slots for system image overlays, some of which 
// was reserved by the system, or taken by the overlayidentifiers, so it's possible
// that this function would fail and return -1;  
//
// To get the default overlays in the system, such as the share hand, link shortcut
// and slow files, pass NULL as the file name, then the IDO_SHGIOI_* flags as the icon index
//-------------------------------------------------------------------------

#define IDO_SHGIOI_SHARE  0x0FFFFFFF
#define IDO_SHGIOI_LINK   0x0FFFFFFE
#define IDO_SHGIOI_SLOWFILE 0x0FFFFFFFD
SHSTDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex);
SHSTDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pszIconPath, int iIconIndex);
#ifdef UNICODE
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexW
#else
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0400)

// IShellLinkDataList::GetFlags()/SetFlags()
typedef enum {
   SLDF_HAS_ID_LIST         = 0x00000001,   // Shell link saved with ID list
   SLDF_HAS_LINK_INFO       = 0x00000002,   // Shell link saved with LinkInfo
   SLDF_HAS_NAME            = 0x00000004,
   SLDF_HAS_RELPATH         = 0x00000008,
   SLDF_HAS_WORKINGDIR      = 0x00000010,
   SLDF_HAS_ARGS            = 0x00000020,
   SLDF_HAS_ICONLOCATION    = 0x00000040,
   SLDF_UNICODE             = 0x00000080,   // the strings are unicode
   SLDF_FORCE_NO_LINKINFO   = 0x00000100,   // don't create a LINKINFO (make a dumb link)
   SLDF_HAS_EXP_SZ          = 0x00000200,   // the link contains expandable env strings
   SLDF_RUN_IN_SEPARATE     = 0x00000400,   // Run the 16-bit target exe in a separate VDM/WOW
   SLDF_HAS_LOGO3ID         = 0x00000800,   // this link is a special Logo3/MSICD link
   SLDF_HAS_DARWINID        = 0x00001000,   // this link is a special Darwin link
   SLDF_RUNAS_USER          = 0x00002000,   // Run this link as a different user       
   SLDF_HAS_EXP_ICON_SZ     = 0x00004000,   // contains expandable env string for icon path
   SLDF_NO_PIDL_ALIAS       = 0x00008000,   // don't ever resolve to a logical location
   SLDF_FORCE_UNCNAME       = 0x00010000,   // make GetPath() prefer the UNC name to the local name
} SHELL_LINK_DATA_FLAGS;

typedef struct tagDATABLOCKHEADER
{
    DWORD   cbSize;             // Size of this extra data block
    DWORD   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER, *LPDATABLOCK_HEADER, *LPDBLIST;

typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    WORD     wFillAttribute;         // fill attribute for console
    WORD     wPopupFillAttribute;    // fill attribute for console popups
    COORD    dwScreenBufferSize;     // screen buffer size for console
    COORD    dwWindowSize;           // window size for console
    COORD    dwWindowOrigin;         // window origin for console
    DWORD    nFont;
    DWORD    nInputBufferSize;
    COORD    dwFontSize;
    UINT     uFontFamily;
    UINT     uFontWeight;
    WCHAR    FaceName[LF_FACESIZE];
    UINT     uCursorSize;
    BOOL     bFullScreen;
    BOOL     bQuickEdit;
    BOOL     bInsertMode;
    BOOL     bAutoPosition;
    UINT     uHistoryBufferSize;
    UINT     uNumberOfHistoryBuffers;
    BOOL     bHistoryNoDup;
    COLORREF ColorTable[ 16 ];
} NT_CONSOLE_PROPS, *LPNT_CONSOLE_PROPS;
#define NT_CONSOLE_PROPS_SIG 0xA0000002

// This is a FE Console property
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    UINT     uCodePage;
} NT_FE_CONSOLE_PROPS, *LPNT_FE_CONSOLE_PROPS;
#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004

#if (_WIN32_IE >= 0x0500)
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    CHAR        szDarwinID[MAX_PATH];  // ANSI darwin ID associated with link
    WCHAR       szwDarwinID[MAX_PATH]; // UNICODE darwin ID associated with link
} EXP_DARWIN_LINK, *LPEXP_DARWIN_LINK;
#define EXP_DARWIN_ID_SIG       0xA0000006
#define EXP_LOGO3_ID_SIG        0xA0000007
#endif

#define EXP_SPECIAL_FOLDER_SIG         0xA0000005   // LPEXP_SPECIAL_FOLDER


typedef struct 
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    DWORD       idSpecialFolder;    // special folder id this link points into
    DWORD       cbOffset;           // ofset into pidl from SLDF_HAS_ID_LIST for child
} EXP_SPECIAL_FOLDER, *LPEXP_SPECIAL_FOLDER;



typedef struct 
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    CHAR        szTarget[ MAX_PATH ];   // ANSI target name w/EXP_SZ in it
    WCHAR       swzTarget[ MAX_PATH ];  // UNICODE target name w/EXP_SZ in it
} EXP_SZ_LINK, *LPEXP_SZ_LINK;
#define EXP_SZ_LINK_SIG                0xA0000001   // LPEXP_SZ_LINK (target)
#define EXP_SZ_ICON_SIG                0xA0000007   // LPEXP_SZ_LINK (icon)

#undef  INTERFACE
#define INTERFACE IShellLinkDataList

DECLARE_INTERFACE_(IShellLinkDataList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellLinkDataList methods ***
    STDMETHOD(AddDataBlock)(THIS_ void * pDataBlock) PURE;
    STDMETHOD(CopyDataBlock)(THIS_ DWORD dwSig, void **ppDataBlock) PURE;
    STDMETHOD(RemoveDataBlock)(THIS_ DWORD dwSig) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags) PURE;
};

#endif // (_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
#undef  INTERFACE
#define INTERFACE IResolveShellLink

DECLARE_INTERFACE_(IResolveShellLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IResolveShellLink methods ***
    STDMETHOD(ResolveShellLink)(THIS_ IUnknown* punk, HWND hwnd, DWORD fFlags) PURE;
};
#endif // (_WIN32_IE >= 0x0500)


#ifdef _INC_SHELLAPI    /* for LPSHELLEXECUTEINFO */
//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookA

DECLARE_INTERFACE_(IShellExecuteHookA, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookA methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOA pei) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookW

DECLARE_INTERFACE_(IShellExecuteHookW, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookW methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOW pei) PURE;
};

#ifdef UNICODE
#define IShellExecuteHook       IShellExecuteHookW
#define IShellExecuteHookVtbl   IShellExecuteHookWVtbl
#else
#define IShellExecuteHook       IShellExecuteHookA
#define IShellExecuteHookVtbl   IShellExecuteHookAVtbl
#endif
#endif

//===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IURLSearchHook

DECLARE_INTERFACE_(IURLSearchHook, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IURLSearchHook methods ***
    STDMETHOD(Translate)(THIS_ LPWSTR lpwszSearchURL, DWORD cchBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchContext

DECLARE_INTERFACE_(ISearchContext, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ISearchContext methods ***
    STDMETHOD(GetSearchUrl)(THIS_ BSTR * pbstrSearchUrl) PURE;
    STDMETHOD(GetSearchText)(THIS_ BSTR * pbstrSearchText) PURE;
    STDMETHOD(GetSearchStyle)(THIS_ DWORD * pdwSearchStyle) PURE;
};

#undef  INTERFACE
#define INTERFACE   IURLSearchHook2

DECLARE_INTERFACE_(IURLSearchHook2, IURLSearchHook)
{
    // *** IURLSearchHook2 methods ***
    STDMETHOD(TranslateWithSearchContext)(THIS_ LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSearchContext) PURE;
};

//===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   INewShortcutHookA

DECLARE_INTERFACE_(INewShortcutHookA, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPSTR pszExtension, int cchExtension) PURE;
};

#undef  INTERFACE
#define INTERFACE   INewShortcutHookW

DECLARE_INTERFACE_(INewShortcutHookW, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCWSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPWSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCWSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPWSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPWSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPWSTR pszExtension, int cchExtension) PURE;
};

#ifdef UNICODE
#define INewShortcutHook        INewShortcutHookW
#define INewShortcutHookVtbl    INewShortcutHookWVtbl
#else
#define INewShortcutHook        INewShortcutHookA
#define INewShortcutHookVtbl    INewShortcutHookAVtbl
#endif

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#ifndef FO_MOVE //these need to be kept in sync with the ones in shellapi.h

// file operations

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes
#define FOF_NORECURSION            0x1000  // don't recurse into directories.
#if (_WIN32_IE >= 0x500)
#define FOF_NO_CONNECTED_ELEMENTS  0x2000  // don't operate on connected file elements.
#define FOF_WANTNUKEWARNING        0x4000  // during delete operation, warn if nuking instead of recycling (partially overrides FOF_NOCONFIRMATION)
#endif // _WIN32_IE >= 0x500

typedef WORD FILEOP_FLAGS;

// printer operations

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef UINT PRINTEROP_FLAGS;

#endif // FO_MOVE

#undef  INTERFACE
#define INTERFACE   ICopyHookA

DECLARE_INTERFACE_(ICopyHookA, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookA *    LPCOPYHOOKA;

#undef  INTERFACE
#define INTERFACE   ICopyHookW

DECLARE_INTERFACE_(ICopyHookW, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCWSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCWSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookW *    LPCOPYHOOKW;

#ifdef UNICODE
#define ICopyHook       ICopyHookW
#define ICopyHookVtbl   ICopyHookWVtbl
#define LPCOPYHOOK      LPCOPYHOOKW
#else
#define ICopyHook       ICopyHookA
#define ICopyHookVtbl   ICopyHookAVtbl
#define LPCOPYHOOK      LPCOPYHOOKA
#endif

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE_(IFileViewerSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewerSite methods ***
    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;


//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

#include <pshpack8.h>  

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    IUnknown *punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

#include <poppack.h>        /* Return to byte packing */

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

#undef  INTERFACE
#define INTERFACE   IFileViewerA

DECLARE_INTERFACE(IFileViewerA)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerA * LPFILEVIEWERA;

#undef  INTERFACE
#define INTERFACE   IFileViewerW

DECLARE_INTERFACE(IFileViewerW)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPWSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerW * LPFILEVIEWERW;

#ifdef UNICODE
#define IFileViewer IFileViewerW
#define LPFILEVIEWER LPFILEVIEWERW
#else
#define IFileViewer IFileViewerA
#define LPFILEVIEWER LPFILEVIEWERA
#endif



//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0) // for Win9x compat
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1) // for Win9x compat
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)

#if (_WIN32_IE >= 0x0400)
//--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll
#define IDC_OFFLINE_HAND        103
//
//--------------------------------------------------------------------------
#endif


//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003

#undef  INTERFACE
#define INTERFACE   ICommDlgBrowser

DECLARE_INTERFACE_(ICommDlgBrowser, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,
                ULONG uChange) PURE;
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,
                LPCITEMIDLIST pidl) PURE;
};

typedef ICommDlgBrowser * LPCOMMDLGBROWSER;

//-------------------------------------------------------------------------
// ICommDlgBrowser2 interface
//
// Member functions:
//
//  ICommDlgBrowser2::Notify(IShellView *pshv, DWORD dwNotfyType)
//   Called when the view is wants to notify common dialog when an event
//  occurrs.
//
//  CDB2N_CONTEXTMENU_START indicates the context menu has started.
//  CDB2N_CONTEXTMENU_DONE  indicates the context menu has completed.
//
//  ICommDlgBrowser2::GetDefaultMenuText(IShellView *pshv,
//                                      WCHAR *pszText, INT cchMax)
//   Called when the view wants to get the default context menu text.
//  pszText points to buffer and cchMax specifies the size of the
//  buffer in characters.  The browser on return has filled the buffer
//  with the default context menu text.  The Shell will call this method
//  with at least a buffer size of MAX_PATH.  The browser should return
//  S_OK if it returned a new default menu text, S_FALSE to let the view
//  to use the normal default menu text.
//
//  ICommDlgBrowser2::GetViewFlags(DWORD *pdwFlags)
//     Called when the view wants to determine  if special customization needs to
//    be done for the common dialog browser. For example View calls this function to 
//    determin if all files(hidden and system)needs to be shown. If the GetViewFlags returns a DWORD with 
//    CDB2GVF_SHOWALLFILES  flag set then it will show all the files.
//-------------------------------------------------------------------------

#define CDB2N_CONTEXTMENU_DONE  0x00000001
#define CDB2N_CONTEXTMENU_START 0x00000002

//GetViewFlags
#define CDB2GVF_SHOWALLFILES        0x00000001

#undef  INTERFACE
#define INTERFACE   ICommDlgBrowser2

DECLARE_INTERFACE_(ICommDlgBrowser2, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,
                ULONG uChange) PURE;
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,
                LPCITEMIDLIST pidl) PURE;

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(Notify) (THIS_ struct IShellView * ppshv,
                DWORD dwNotifyType) PURE;
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView * ppshv,
                WCHAR *pszText, INT cchMax) PURE;
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags) PURE;

};

typedef ICommDlgBrowser2 * LPCOMMDLGBROWSER2;



//
// function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.

SHSTDAPI_(BOOL) SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);
SHSTDAPI_(BOOL) SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
#ifdef UNICODE
#define SHGetPathFromIDList  SHGetPathFromIDListW
#else
#define SHGetPathFromIDList  SHGetPathFromIDListA
#endif // !UNICODE

SHSTDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, SECURITY_ATTRIBUTES *psa);
#ifdef UNICODE
#define SHCreateDirectoryEx  SHCreateDirectoryExW
#else
#define SHCreateDirectoryEx  SHCreateDirectoryExA
#endif // !UNICODE

SHSTDAPI SHOpenFolderAndSelectItems(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, DWORD dwFlags);
SHSTDAPI SHCreateShellItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidl, IShellItem **ppsi);

//-------------------------------------------------------------------------
//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//
//
//-------------------------------------------------------------------------
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS    REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_INTERNET                  0x0001        // Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_CONTROLS                  0x0003        // My Computer\Control Panel
#define CSIDL_PRINTERS                  0x0004        // My Computer\Printers
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_BITBUCKET                 0x000a        // <desktop>\Recycle Bin
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_MYDOCUMENTS               0x000c        // logical "My Documents" desktop icon
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#define CSIDL_MYVIDEO                   0x000e        // "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common 
#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections
#define CSIDL_COMMON_MUSIC              0x0035        // All Users\My Music
#define CSIDL_COMMON_PICTURES           0x0036        // All Users\My Pictures
#define CSIDL_COMMON_VIDEO              0x0037        // All Users\My Video

#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force folder creation in SHGetFolderPath()
#define CSIDL_FLAG_DONT_VERIFY          0x4000        // combine with CSIDL_ value to return an unverified folder path
#define CSIDL_FLAG_NO_ALIAS             0x1000        // combine with CSIDL_ value to insure non-alias versions of the pidl
#define CSIDL_FLAG_MASK                 0xFF00        // mask for all possible flag values


SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);

#if (_WIN32_IE >= 0x0400)

SHSTDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
SHSTDAPI_(BOOL) SHGetSpecialFolderPathW(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
#ifdef UNICODE
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0500)

typedef enum {
    SHGFP_TYPE_CURRENT  = 0,   // current value for user, verify it exists
    SHGFP_TYPE_DEFAULT  = 1,   // default value, may not exist
} SHGFP_TYPE;

SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPath  SHGetFolderPathW
#else
#define SHGetFolderPath  SHGetFolderPathA
#endif // !UNICODE
SHSTDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPITEMIDLIST *ppidl);


#endif      // _WIN32_IE >= 0x0500

#endif      // _WIN32_IE >= 0x0400



//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
// 
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

#include <pshpack8.h>  

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;        // Return display name of item selected.
    LPCSTR       lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPWSTR       pszDisplayName;        // Return display name of item selected.
    LPCWSTR      lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;

#include <poppack.h>        /* Return to byte packing */

#ifdef UNICODE
#define BROWSEINFO      BROWSEINFOW
#define PBROWSEINFO     PBROWSEINFOW
#define LPBROWSEINFO    LPBROWSEINFOW
#else
#define BROWSEINFO      BROWSEINFOA
#define PBROWSEINFO     PBROWSEINFOA
#define LPBROWSEINFO    LPBROWSEINFOA
#endif

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004   // Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                        // this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                        // rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
                                        // all three lines of text.
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010   // Add an editbox to the dialog
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_NEWDIALOGSTYLE     0x0040   // Use the new dialog layout with the ability to resize
                                        // Caller needs to call OleInitialize() before using this API

#define BIF_USENEWUI           (BIF_NEWDIALOGSTYLE | BIF_EDITBOX)

#define BIF_BROWSEINCLUDEURLS  0x0080   // Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
#define BIF_UAHINT             0x0100   // Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything
#define BIF_SHAREABLE          0x8000  // sharable resources displayed (remote shares, requires BIF_USENEWUI)

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2
#define BFFM_VALIDATEFAILEDA    3   // lParam:szPath ret:1(cont),0(EndDialog)
#define BFFM_VALIDATEFAILEDW    4   // lParam:wzPath ret:1(cont),0(EndDialog)
#define BFFM_IUNKNOWN           5   // provides IUnknown to client. lParam: IUnknown*

// messages to browser
#define BFFM_SETSTATUSTEXTA     (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)
#define BFFM_SETSELECTIONW      (WM_USER + 103)
#define BFFM_SETSTATUSTEXTW     (WM_USER + 104)
#define BFFM_SETOKTEXT          (WM_USER + 105) // Unicode only
#define BFFM_SETEXPANDED        (WM_USER + 106) // Unicode only

SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderA(LPBROWSEINFOA lpbi);
SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderW(LPBROWSEINFOW lpbi);

#ifdef UNICODE
#define SHBrowseForFolder   SHBrowseForFolderW
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTW
#define BFFM_SETSELECTION   BFFM_SETSELECTIONW

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   When this function is called, the shell calls CoCreateInstance
//  (or equivalent) with CLSCTX_INPROC_SERVER and the specified CLSID
//  from within the shell's process and release it immediately.
//
//-------------------------------------------------------------------------

SHSTDAPI SHLoadInProc(REFCLSID rclsid);


#if _WIN32_IE >= 0x0560

//-------------------------------------------------------------------------
//
// SHEnableServiceObject
//
//   Like SHLoadInProc, but gives control over the object's lifetime
//  via fEnable parameter.  TRUE tells the shell to create the object
//  and hold onto it, FALSE tells the shell to look for the previously
//  created instance of the object and release it.
//
//-------------------------------------------------------------------------

SHSTDAPI SHEnableServiceObject(REFCLSID rclsid, BOOL fEnable);

#endif


//
//  Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL,
//                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
//
SHSTDAPI SHGetDesktopFolder(IShellFolder **ppshf);


// IShellFolder IBindCtx* parameters. the IUnknown for these are
// accessed through IBindCtx::RegisterObjectParam/GetObjectParam
// use this to provide the data needed create IDLists through 
// IShellFolder::ParseDisplayName(). this data applies to the last element
// of the name that is parsed (c:\foo\bar.txt, data applies to bar.txt)
// this makes creating these IDLists much faster that suppling the name only

#define STR_FILE_SYS_BIND_DATA      L"File System Bind Data"

#undef  INTERFACE
#define INTERFACE   IFileSystemBindData

DECLARE_INTERFACE_(IFileSystemBindData, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileSystemBindData methods ***
    STDMETHOD(SetFindData)(THIS_ const WIN32_FIND_DATAW *pfd) PURE;
    STDMETHOD(GetFindData)(THIS_ WIN32_FIND_DATAW *pfd) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_(IShellDetails, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};



//-------------------------------------------------------------------------
//
// ITaskbarList interface
//
//
// [Member functions]
//
// ITaskbarList::HrInit()
//   This function must be called first to validate use of other members.
//
// ITaskbarList::AddTab(hwnd)
//   This function adds a tab for hwnd to the taskbar.
//
// ITaskbarList::DeleteTab(hwnd)
//   This function deletes a tab for hwnd from the taskbar.
//
// ITaskbarList::ActivateTab(hwnd)
//   This function activates the tab associated with hwnd on the taskbar.
//
// ITaskbarList::SetActivateAlt(hwnd)
//   This function marks hwnd in the taskbar as the active tab
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ITaskbarList

DECLARE_INTERFACE_(ITaskbarList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ITaskbarList specific methods ***
    STDMETHOD(HrInit) (THIS) PURE;
    STDMETHOD(AddTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(DeleteTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(ActivateTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(SetActiveAlt) (THIS_ HWND hwnd) PURE;
};

//-------------------------------------------------------------------------
//
// IObjMgr interface
//
//
// [Member functions]
//
// IObjMgr::Append(punk)
//   This function adds an object to the end of a list of objects.
//
// IObjMgr::Remove(punk)
//   This function removes an object from a list of objects.
//
// This is implemented by CLSID_ACLMulti so each AutoComplete List
// (CLSID_ACLHistory, CLSID_ACListISF, CLSID_ACLMRU) can be added.
// CLSID_ACLMulti's IEnumString will then be the union of the results
// from the COM Objects added.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IObjMgr

DECLARE_INTERFACE_(IObjMgr, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IObjMgr specific methods ***
    STDMETHOD(Append) (THIS_ IUnknown *punk) PURE;
    STDMETHOD(Remove) (THIS_ IUnknown *punk) PURE;
};


//-------------------------------------------------------------------------
//
// ICurrentWorkingDirectory interface
//
//
// [Member functions]
//
// ICurrentWorkingDirectory::GetDirectory(LPWSTR pwzPath, DWORD cchSize)
//   This function gets the Current Working Directory from a COM object that
//   stores such state.
//
// ICurrentWorkingDirectory::SetDirectory(LPCWSTR pwzPath)
//   This function sets the Current Working Directory of a COM object that
//   stores such state.
//
// This function can be used generically.  One COM object that implements it
// is CLSID_ACListISF so that the AutoComplete engine can complete relative
// paths.  SetDirectory() will set the "Current Working Directory" and
// AutoComplete with then complete both absolute and relative paths.
// For Example, if ::SetDirectory(L"C:\Program Files") is called, then
// the user can AutoComplete "..\winnt".  In order to set the current
// working directory for non-file system paths, "ftp://ftp.microsoft.com/" or
// "Control Panel" for example, use IPersistFolder.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ICurrentWorkingDirectory

DECLARE_INTERFACE_(ICurrentWorkingDirectory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ICurrentWorkingDirectory specific methods ***
    STDMETHOD(GetDirectory) (THIS_ LPWSTR pwzPath, DWORD cchSize) PURE;
    STDMETHOD(SetDirectory) (THIS_ LPCWSTR pwzPath) PURE;
};


//-------------------------------------------------------------------------
//
// IACList interface
//
//
// [Member functions]
//
// IObjMgr::Expand(LPCOLESTR)
//   This function tells an autocomplete list to expand a specific string.
//
// If the user enters a multi-level path, AutoComplete (CLSID_AutoComplete)
// will use this interface to tell the "AutoComplete Lists" where to expand
// the results.
//
// For Example, if the user enters "C:\Program Files\Micros", AutoComplete
// first completely enumerate the "AutoComplete Lists" via IEnumString.  Then it
// will call the "AutoComplete Lists" with IACList::Expand(L"C:\Program Files").
// It will then enumerate the IEnumString interface again to get results in
// that directory.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IACList

DECLARE_INTERFACE_(IACList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IACList specific methods ***
    STDMETHOD(Expand) (THIS_ LPCOLESTR pszExpand) PURE;
};

//-------------------------------------------------------------------------
//
// IACList2 interface
//
// [Description]
//              This interface exists to allow the caller to set filter criteria
// for an AutoComplete List.  AutoComplete Lists generates the list of
// possible AutoComplete completions.  CLSID_ACListISF is one AutoComplete
// List COM object that implements this interface.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IACList2

typedef enum _tagAUTOCOMPLETELISTOPTIONS 
{
    ACLO_NONE            = 0,    // don't enumerate anything
    ACLO_CURRENTDIR      = 1,    // enumerate current directory
    ACLO_MYCOMPUTER      = 2,    // enumerate MyComputer
    ACLO_DESKTOP         = 4,    // enumerate Desktop Folder
    ACLO_FAVORITES       = 8,    // enumerate Favorites Folder
    ACLO_FILESYSONLY     = 16,   // enumerate only the file system
} AUTOCOMPLETELISTOPTIONS;

DECLARE_INTERFACE_(IACList2, IACList)
{
    // *** IACList2 specific methods ***
    STDMETHOD(SetOptions)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(GetOptions)(THIS_ DWORD* pdwFlag) PURE;
};


/*-------------------------------------------------------------------------*\
    INTERFACE: IProgressDialog

    DESCRIPTION:
        CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
    a progress dialog, set it's title, animation, text lines, progress, and
    it will do all the work of updating on a background thread, being modless,
    handling the user cancelling the operation, and estimating the time remaining
    until the operation completes.

    USAGE:
        This is how the dialog is used during operations that require progress
    and the ability to cancel:
    {
        DWORD dwComplete, dwTotal;
        IProgressDialog * ppd;
        CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd);
        ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
        ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
        ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
        ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.

        dwComplete = 0;
        dwTotal = CalcTotalUnitsToDo();

        // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        ppd->Timer(PDTIMER_RESET, NULL);

        for (nIndex = 0; nIndex < nTotal; nIndex++)
        {
            if (TRUE == ppd->HasUserCancelled())
                break;

            ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
            dwComplete += DoSlowOperation();

            ppd->SetProgress(dwCompleted, dwTotal);
        }

        ppd->StopProgressDialog();
        ppd->Release();
    }
\*-------------------------------------------------------------------------*/

// Flags for IProgressDialog::StartProgressDialog() (dwFlags)
#define PROGDLG_NORMAL          0x00000000      // default normal progress dlg behavior
#define PROGDLG_MODAL           0x00000001      // the dialog is modal to its hwndParent (default is modeless)
#define PROGDLG_AUTOTIME        0x00000002      // automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
#define PROGDLG_NOTIME          0x00000004      // we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files
#define PROGDLG_NOMINIMIZE      0x00000008      // Do not have a minimize button in the caption bar.
#define PROGDLG_NOPROGRESSBAR   0x00000010      // Don't display the progress bar

// Time Actions (dwTimerAction)
#define PDTIMER_RESET       0x00000001       // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so
                                             // those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.


#undef  INTERFACE
#define INTERFACE   IProgressDialog

DECLARE_INTERFACE_(IProgressDialog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IProgressDialog specific methods
    STDMETHOD(StartProgressDialog)(THIS_ HWND hwndParent, IUnknown * punkEnableModless, DWORD dwFlags, LPCVOID pvResevered) PURE;
    STDMETHOD(StopProgressDialog)(THIS) PURE;
    STDMETHOD(SetTitle)(THIS_ LPCWSTR pwzTitle) PURE;
    STDMETHOD(SetAnimation)(THIS_ HINSTANCE hInstAnimation, UINT idAnimation) PURE;
    STDMETHOD_(BOOL,HasUserCancelled) (THIS) PURE;
    STDMETHOD(SetProgress)(THIS_ DWORD dwCompleted, DWORD dwTotal) PURE;
    STDMETHOD(SetProgress64)(THIS_ ULONGLONG ullCompleted, ULONGLONG ullTotal) PURE;
    STDMETHOD(SetLine)(THIS_ DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered) PURE;
    STDMETHOD(SetCancelMsg)(THIS_ LPCWSTR pwzCancelMsg, LPCVOID pvResevered) PURE;
    STDMETHOD(Timer)(THIS_ DWORD dwTimerAction, LPCVOID pvResevered) PURE;
};


//==========================================================================
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================

//-------------------------------------------------------------------------
//
// IInputObjectSite interface
//
//   A site implements this interface so the object can communicate
// focus change to it.
//
// [Member functions]
//
// IInputObjectSite::OnFocusChangeIS(punkObj, fSetFocus)
//   Object (punkObj) is getting or losing the focus.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObjectSite

DECLARE_INTERFACE_(IInputObjectSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObjectSite specific methods ***
    STDMETHOD(OnFocusChangeIS)(THIS_ IUnknown* punkObj, BOOL fSetFocus) PURE;
};


//-------------------------------------------------------------------------
//
// IInputObject interface
//
//   An object implements this interface so the site can communicate
// activation and accelerator events to it.
//
// [Member functions]
//
// IInputObject::UIActivateIO(fActivate, lpMsg)
//   Activates or deactivates the object.  lpMsg may be NULL.  Returns
//   S_OK if the activation succeeded.
//
// IInputObject::HasFocusIO()
//   Returns S_OK if the object has the focus, S_FALSE if not.
//
// IInputObject::TranslateAcceleratorIO(lpMsg)
//   Allow the object to process the message.  Returns S_OK if the
//   message was processed (eaten).
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObject

DECLARE_INTERFACE_(IInputObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObject specific methods ***
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg) PURE;
    STDMETHOD(HasFocusIO)(THIS) PURE;
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg) PURE;
};


//==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================


//-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size
//   specified in *pbw.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindowSite

DECLARE_INTERFACE_(IDockingWindowSite, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowSite methods ***
    STDMETHOD(GetBorderDW) (THIS_ IUnknown* punkObj, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppv)
//
//-------------------------------------------------------------------------


// flags for RemoveToolbar
#define DWFRF_NORMAL            0x0000
#define DWFRF_DELETECONFIGDATA  0x0001


// flags for AddToolbar
#define DWFAF_HIDDEN  0x0001   // add hidden

#undef  INTERFACE
#define INTERFACE   IDockingWindowFrame

DECLARE_INTERFACE_(IDockingWindowFrame, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwAddFlags) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, void **ppv) PURE;
};



#if (_WIN32_IE >= 0x0400)

//-------------------------------------------------------------------------
//
// IRunnableTask interface
//
//   This is a free threaded interface used for putting items on a background
// scheduler for execution within the view.  It allows a scheduler to start and
// stop tasks on as many worker threads as it deems necessary.
//
// Run(), Kill() and Suspend() may be called from different threads.
//
// [Member functions]
//
// IRunnableTask::Run(void)
//   Initiate the task to run.  This should return E_PENDING if the task
//   has been suspended.
//
// IRunnableTask::Kill(void)
//
// IRunnableTask::Suspend(void)
//
// IRunnableTask::Resume(void)
//
// IRunnableTask::IsRunning(void)
//
//-------------------------------------------------------------------------

// Convenient state values
#define IRTIR_TASK_NOT_RUNNING  0
#define IRTIR_TASK_RUNNING      1
#define IRTIR_TASK_SUSPENDED    2
#define IRTIR_TASK_PENDING      3
#define IRTIR_TASK_FINISHED     4

#undef  INTERFACE
#define INTERFACE   IRunnableTask

DECLARE_INTERFACE_( IRunnableTask, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRunnableTask methods ***
    STDMETHOD (Run)(THIS) PURE;
    STDMETHOD (Kill)(THIS_ BOOL fWait ) PURE;
    STDMETHOD (Suspend)(THIS) PURE;
    STDMETHOD (Resume)(THIS) PURE;
    STDMETHOD_(ULONG, IsRunning)(THIS) PURE;
};

typedef IRunnableTask * LPRUNNABLETASK;
#endif


#if (_WIN32_IE >= 0x0400)

// --- IExtractImage
// this interface is provided for objects to provide a thumbnail image.
// IExtractImage::GetLocation()
//      Gets a path description of the image that is to be extracted. This is used to
//      identify the image in the view so that multiple instances of the same image can reuse the
//      original image. If *pdwFlags == IEIFLAG_ASYNC and the result is E_PENDING, then *pdwPriority
//      is used to return the priority of the item, this is usually a measure of how long it will take
//      to perform the extraction. *pdwFlags can return IEIFLAG_CACHE if the view should cache a copy
//      of the image for future reference and faster access. This flag is use dto tell the difference
//      between file formats that cache a thumbnail image  such as Flashpix or Office documents, and those
//      that don't cache one.
// IExtractImage::Extract()
//      Extract the thumbnail of the specified size. If GetLocation() returned the values indicating
//      it is free-threaded and can be placed on a background thread. If the object
//      supports IRunnableTask as well, then long extractions can be started and paused as appropriate.
//      At this point it is asssumed the object is free-threaded.
//      If dwRecClrDepth contains a recommended Colour depth
//      If *phBmpthumbnail is non NULL, then it contains the destination bitmap that should be used.

#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY
#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY
#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define IEIFLAG_ASYNC       0x0001      // ask the extractor if it supports ASYNC extract (free threaded)
#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail
#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect
#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering
#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does
#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )
#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary
#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail
#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail

#undef  INTERFACE
#define INTERFACE   IExtractImage

DECLARE_INTERFACE_ ( IExtractImage, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IExtractImage methods ***
    STDMETHOD (GetLocation) ( THIS_ LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags ) PURE;

    STDMETHOD (Extract)( THIS_ HBITMAP * phBmpThumbnail) PURE;
};
typedef IExtractImage * LPEXTRACTIMAGE;


/* ***************** IExtractImage2
 * GetDateStamp : returns the date stamp associated with the image. If this image is already cached,
 *                then it is easy to find out if the image is out of date.
 */

#undef  INTERFACE
#define INTERFACE   IExtractImage

DECLARE_INTERFACE_ ( IExtractImage2, IExtractImage )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IExtractImage methods ***
    STDMETHOD (GetLocation) ( THIS_ LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags ) PURE;

    STDMETHOD (Extract)( THIS_ HBITMAP * phBmpThumbnail) PURE;

    // *** IExtractImage2 methods ***
    STDMETHOD (GetDateStamp)( THIS_ FILETIME * pDateStamp ) PURE;
};
typedef IExtractImage2 * LPEXTRACTIMAGE2;

/* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 */

#undef  INTERFACE
#define INTERFACE   IThumbnailCapture

DECLARE_INTERFACE_ ( IThumbnailCapture, IUnknown )
{
    // *** IThumbnailCapture methods ***
    STDMETHOD (CaptureThumbnail)    ( THIS_ const SIZE * pMaxSize,
                                      IUnknown * pHTMLDoc2,
                                      HBITMAP * phbmThumbnail ) PURE;
};
typedef IThumbnailCapture * LPTHUMBNAILCAPTURE;

#endif


#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct  _tagCOMPSTATEINFO
{
    DWORD   dwSize;             // Size of this structure.
    int     iLeft;              // Left of the top-left corner in screen co-ordinates.
    int     iTop;               // Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    DWORD   dwItemState;        // State of the component (full-screen mode or split-screen or normal state.
}
COMPSTATEINFO;

typedef COMPSTATEINFO   *LPCOMPSTATEINFO;
typedef const COMPSTATEINFO *LPCCOMPSTATEINFO;



#define COMPONENT_TOP (0x3fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

// The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility
// reasons.
typedef struct _tagIE4COMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MA