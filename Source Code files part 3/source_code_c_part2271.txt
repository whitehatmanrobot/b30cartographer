gClient_LoadHistoryPosition_Proxy( 
    ITravelLogClient __RPC_FAR * This,
    /* [in] */ LPWSTR pszUrlLocation,
    /* [in] */ DWORD dwPosition);


void __RPC_STUB ITravelLogClient_LoadHistoryPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogClient_INTERFACE_DEFINED__ */


#ifndef __IEnumTravelLogEntry_INTERFACE_DEFINED__
#define __IEnumTravelLogEntry_INTERFACE_DEFINED__

/* interface IEnumTravelLogEntry */
/* [helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumTravelLogEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD85-AD18-11d3-A4C5-00C04F72D6B8")
    IEnumTravelLogEntry : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *rgElt,
            /* [out] */ ULONG __RPC_FAR *pcEltFetched) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTravelLogEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumTravelLogEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumTravelLogEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumTravelLogEntry __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumTravelLogEntry __RPC_FAR * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *rgElt,
            /* [out] */ ULONG __RPC_FAR *pcEltFetched);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumTravelLogEntry __RPC_FAR * This,
            /* [in] */ ULONG cElt);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumTravelLogEntry __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumTravelLogEntry __RPC_FAR * This,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumTravelLogEntryVtbl;

    interface IEnumTravelLogEntry
    {
        CONST_VTBL struct IEnumTravelLogEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTravelLogEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTravelLogEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTravelLogEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTravelLogEntry_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumTravelLogEntry_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumTravelLogEntry_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTravelLogEntry_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Next_Proxy( 
    IEnumTravelLogEntry __RPC_FAR * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *rgElt,
    /* [out] */ ULONG __RPC_FAR *pcEltFetched);


void __RPC_STUB IEnumTravelLogEntry_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Skip_Proxy( 
    IEnumTravelLogEntry __RPC_FAR * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumTravelLogEntry_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Reset_Proxy( 
    IEnumTravelLogEntry __RPC_FAR * This);


void __RPC_STUB IEnumTravelLogEntry_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Clone_Proxy( 
    IEnumTravelLogEntry __RPC_FAR * This,
    /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumTravelLogEntry_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTravelLogEntry_INTERFACE_DEFINED__ */


#ifndef __ITravelLogStg_INTERFACE_DEFINED__
#define __ITravelLogStg_INTERFACE_DEFINED__

/* interface ITravelLogStg */
/* [unique][object][uuid] */ 


enum tagTLENUMF
    {	TLEF_RELATIVE_INCLUDE_CURRENT	= 0x1,
	TLEF_RELATIVE_BACK	= 0x10,
	TLEF_RELATIVE_FORE	= 0x20,
	TLEF_INCLUDE_UNINVOKEABLE	= 0x40,
	TLEF_ABSOLUTE	= 0x31
    };
typedef DWORD TLENUMF;


EXTERN_C const IID IID_ITravelLogStg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD80-AD18-11d3-A4C5-00C04F72D6B8")
    ITravelLogStg : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ ITravelLogEntry __RPC_FAR *ptleRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *pptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelTo( 
            /* [in] */ ITravelLogEntry __RPC_FAR *ptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE EnumEntries( 
            /* [in] */ TLENUMF flags,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindEntries( 
            /* [in] */ TLENUMF flags,
            /* [in] */ LPCWSTR pszUrl,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ TLENUMF flags,
            /* [out] */ DWORD __RPC_FAR *pcEntries) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ ITravelLogEntry __RPC_FAR *ptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRelativeEntry( 
            /* [in] */ int iOffset,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ptle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogStgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITravelLogStg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITravelLogStg __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ ITravelLogEntry __RPC_FAR *ptleRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *pptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TravelTo )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ ITravelLogEntry __RPC_FAR *ptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumEntries )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ TLENUMF flags,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindEntries )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ TLENUMF flags,
            /* [in] */ LPCWSTR pszUrl,
            /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ TLENUMF flags,
            /* [out] */ DWORD __RPC_FAR *pcEntries);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveEntry )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ ITravelLogEntry __RPC_FAR *ptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRelativeEntry )( 
            ITravelLogStg __RPC_FAR * This,
            /* [in] */ int iOffset,
            /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ptle);
        
        END_INTERFACE
    } ITravelLogStgVtbl;

    interface ITravelLogStg
    {
        CONST_VTBL struct ITravelLogStgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogStg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogStg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogStg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogStg_CreateEntry(This,pszUrl,pszTitle,ptleRelativeTo,fPrepend,pptle)	\
    (This)->lpVtbl -> CreateEntry(This,pszUrl,pszTitle,ptleRelativeTo,fPrepend,pptle)

#define ITravelLogStg_TravelTo(This,ptle)	\
    (This)->lpVtbl -> TravelTo(This,ptle)

#define ITravelLogStg_EnumEntries(This,flags,ppenum)	\
    (This)->lpVtbl -> EnumEntries(This,flags,ppenum)

#define ITravelLogStg_FindEntries(This,flags,pszUrl,ppenum)	\
    (This)->lpVtbl -> FindEntries(This,flags,pszUrl,ppenum)

#define ITravelLogStg_GetCount(This,flags,pcEntries)	\
    (This)->lpVtbl -> GetCount(This,flags,pcEntries)

#define ITravelLogStg_RemoveEntry(This,ptle)	\
    (This)->lpVtbl -> RemoveEntry(This,ptle)

#define ITravelLogStg_GetRelativeEntry(This,iOffset,ptle)	\
    (This)->lpVtbl -> GetRelativeEntry(This,iOffset,ptle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_CreateEntry_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ LPCWSTR pszUrl,
    /* [in] */ LPCWSTR pszTitle,
    /* [in] */ ITravelLogEntry __RPC_FAR *ptleRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *pptle);


void __RPC_STUB ITravelLogStg_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_TravelTo_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ ITravelLogEntry __RPC_FAR *ptle);


void __RPC_STUB ITravelLogStg_TravelTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_EnumEntries_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ TLENUMF flags,
    /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB ITravelLogStg_EnumEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_FindEntries_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ TLENUMF flags,
    /* [in] */ LPCWSTR pszUrl,
    /* [out] */ IEnumTravelLogEntry __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB ITravelLogStg_FindEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_GetCount_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ TLENUMF flags,
    /* [out] */ DWORD __RPC_FAR *pcEntries);


void __RPC_STUB ITravelLogStg_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_RemoveEntry_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ ITravelLogEntry __RPC_FAR *ptle);


void __RPC_STUB ITravelLogStg_RemoveEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_GetRelativeEntry_Proxy( 
    ITravelLogStg __RPC_FAR * This,
    /* [in] */ int iOffset,
    /* [out] */ ITravelLogEntry __RPC_FAR *__RPC_FAR *ptle);


void __RPC_STUB ITravelLogStg_GetRelativeEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogStg_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  PIDLIST_ABSOLUTE_UserSize(     unsigned long __RPC_FAR *, unsigned long            , PIDLIST_ABSOLUTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  PIDLIST_ABSOLUTE_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  PIDLIST_ABSOLUTE_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 
void                      __RPC_USER  PIDLIST_ABSOLUTE_UserFree(     unsigned long __RPC_FAR *, PIDLIST_ABSOLUTE __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tpcshell.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _TPCSHELL_H_
#define _TPCSHELL_H_
// Copyright (c) Microsoft Corporation. All rights reserved.	
//***   tpcshell.h -- TPC *shell.h-like things
// DESCRIPTION
//  'extensions' to *shell.h. e.g. TPC-specific APIs


#ifdef __cplusplus
extern "C" {
#endif

// IME Escape functions
#define IME_ESC_SET_MODE                   (IME_ESC_PRIVATE_FIRST)
#define IME_ESC_GET_MODE                   (IME_ESC_PRIVATE_FIRST + 1)
#define IME_ESC_SEND_BACK_TO_FOCUS_WINDOW  (IME_ESC_PRIVATE_FIRST + 2)
#define IME_ESC_SET_CUSTOM_SYMBOLS         (IME_ESC_PRIVATE_FIRST + 3)
#define IME_ESC_RETAIN_MODE_ICON           (IME_ESC_PRIVATE_FIRST + 4)
#define IME_ESC_SAVE_USER_WORDS            (IME_ESC_PRIVATE_FIRST + 5)
#define IME_ESC_CLEAR_ON_BACK_PRESS_HOLD   (IME_ESC_PRIVATE_FIRST + 6)
#define IME_ESC_SKIP_AMBIG_MODE            (IME_ESC_PRIVATE_FIRST + 7)

void SHSendBackToFocusWindow(UINT uMsg, WPARAM wp, LPARAM lp);

// WM_IME_NOTIFY/IMN_PRIVATE constants
#define IMNP_CLEAR_ALL                      (1)     // Clear window contents

#ifdef __cplusplus
}
#endif

#endif // _TPCSHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\time.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*time.h - definitions/declarations for time routines
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structures returned by the localtime and gmtime routines and
*       used by asctime.
*
*       Note that Windows CE does not support many time routines.
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#include <crtdefs.h>


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tlhelp32.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: tlhelp32.h

Purpose: Toolhelp include file for Windows

--*/

#ifndef __TOOLHELP32_H__
#define __TOOLHELP32_H__

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPNOHEAPS  0x40000000  // optimization to not snapshot heaps
#define TH32CS_SNAPALL      (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_GETALLMODS       0x80000000

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
BOOL WINAPI CloseToolhelp32Snapshot(HANDLE hSnapshot);

typedef struct tagHEAPLIST32 {
    DWORD  dwSize;
    DWORD  th32ProcessID;
    DWORD  th32HeapID;
    DWORD  dwFlags;
} HEAPLIST32, *PHEAPLIST32, *LPHEAPLIST32;

#define HF32_DEFAULT            1  // process's default heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32 {
    DWORD  dwSize;
    HANDLE hHandle;
    DWORD  dwAddress;
    DWORD  dwBlockSize;
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;
    DWORD  th32HeapID;
} HEAPENTRY32, *PHEAPENTRY32, *LPHEAPENTRY32;

#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004
#define LF32_DECOMMIT 0x00000008
#define LF32_BIGBLOCK 0x00000010

BOOL WINAPI Heap32First(HANDLE hSnapshot, LPHEAPENTRY32 lphe, DWORD th32ProcessID, DWORD th32HeapID);
BOOL WINAPI Heap32Next(HANDLE hSnapshot, LPHEAPENTRY32 lphe);

BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer,
        DWORD cbRead, LPDWORD lpNumberOfBytesRead);

typedef struct tagPROCESSENTRY32 {
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;
    LONG    pcPriClassBase;
    DWORD   dwFlags;
    TCHAR   szExeFile[MAX_PATH];
    DWORD   th32MemoryBase;
    DWORD   th32AccessKey; // overloaded with process account id (>= 7.0 OS)
} PROCESSENTRY32, *PPROCESSENTRY32, *LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

typedef struct tagTHREADENTRY32 {
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;
    DWORD   th32OwnerProcessID;
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
    DWORD   th32AccessKey;
    DWORD   th32CurrentProcessID;
} THREADENTRY32, *PTHREADENTRY32, *LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

typedef struct tagMODULEENTRY32 {
    DWORD   dwSize;
    DWORD   th32ModuleID;
    DWORD   th32ProcessID;
    DWORD   GlblcntUsage;
    DWORD   ProccntUsage;
    BYTE   *modBaseAddr;
    DWORD   modBaseSize;
    HMODULE hModule;
    TCHAR   szModule[MAX_PATH];
    TCHAR   szExePath[MAX_PATH];
    DWORD   dwFlags;
} MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32;

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // __TOOLHELP32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tpcuser.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// this file is OBSOLETE (use windowsm.h or winuserm.h)

#pragma warning(push)
#pragma warning( 4: 4995)
inline void TPCUser_Is_Deprecated_Include_WinUserm_Instead() {}
#pragma deprecated (TPCUser_Is_Deprecated_Include_WinUserm_Instead)
inline void TPCUser_Is_Deprecated_Include_WinUserm_Instead2() {TPCUser_Is_Deprecated_Include_WinUserm_Instead();}
#pragma warning(pop)

#include "winuserm.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\transact.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Feb 09 18:03:56 1998
 */
/* Compiler settings for .\transact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_transact_0000
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: BasicTransactionTypes
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][local] */ 


typedef struct  BOID
    {
    byte rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))
#ifndef MAX_TRAN_DESC_DEFINED
#define MAX_TRAN_DESC_DEFINED
typedef 
enum TX_MISC_CONSTANTS
    {	MAX_TRAN_DESC	= 40
    }	TX_MISC_CONSTANTS;

#endif
typedef BOID XACTUOW;

typedef LONG ISOLEVEL;

typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16,
	ISOFLAG_READONLY	= 32
    }	ISOFLAG;

typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4,
	XACTTC_ASYNC	= 4
    }	XACTTC;

typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    unsigned char szDescription[ 40 ];
    }	XACTOPT;

// Some of these values conflict with values defined in winerror.h
// the other values are also defined in winerror.h. 
// We get rid of this definition to avoid conflict in building.
#if 0
typedef 
enum XACT_E
    {	XACT_E_FIRST	= 0x8004d000,
	XACT_E_LAST	= 0x8004d01e,
	XACT_S_FIRST	= 0x4d000,
	XACT_S_LAST	= 0x4d009,
	XACT_E_ALREADYOTHERSINGLEPHASE	= 0x8004d000,
	XACT_E_CANTRETAIN	= 0x8004d001,
	XACT_E_COMMITFAILED	= 0x8004d002,
	XACT_E_COMMITPREVENTED	= 0x8004d003,
	XACT_E_HEURISTICABORT	= 0x8004d004,
	XACT_E_HEURISTICCOMMIT	= 0x8004d005,
	XACT_E_HEURISTICDAMAGE	= 0x8004d006,
	XACT_E_HEURISTICDANGER	= 0x8004d007,
	XACT_E_ISOLATIONLEVEL	= 0x8004d008,
	XACT_E_NOASYNC	= 0x8004d009,
	XACT_E_NOENLIST	= 0x8004d00a,
	XACT_E_NOISORETAIN	= 0x8004d00b,
	XACT_E_NORESOURCE	= 0x8004d00c,
	XACT_E_NOTCURRENT	= 0x8004d00d,
	XACT_E_NOTRANSACTION	= 0x8004d00e,
	XACT_E_NOTSUPPORTED	= 0x8004d00f,
	XACT_E_UNKNOWNRMGRID	= 0x8004d010,
	XACT_E_WRONGSTATE	= 0x8004d011,
	XACT_E_WRONGUOW	= 0x8004d012,
	XACT_E_XTIONEXISTS	= 0x8004d013,
	XACT_E_NOIMPORTOBJECT	= 0x8004d014,
	XACT_E_INVALIDCOOKIE	= 0x8004d015,
	XACT_E_INDOUBT	= 0x8004d016,
	XACT_E_NOTIMEOUT	= 0x8004d017,
	XACT_E_ALREADYINPROGRESS	= 0x8004d018,
	XACT_E_ABORTED	= 0x8004d019,
	XACT_E_LOGFULL	= 0x8004d01a,
	XACT_E_TMNOTAVAILABLE	= 0x8004d01b,
	XACT_E_CONNECTION_DOWN	= 0x8004d01c,
	XACT_E_CONNECTION_DENIED	= 0x8004d01d,
	XACT_E_REENLISTTIMEOUT	= 0x8004d01e,
	XACT_S_ASYNC	= 0x4d000,
	XACT_S_DEFECT	= 0x4d001,
	XACT_S_READONLY	= 0x4d002,
	XACT_S_SOMENORETAIN	= 0x4d003,
	XACT_S_OKINFORM	= 0x4d004,
	XACT_S_MADECHANGESCONTENT	= 0x4d005,
	XACT_S_MADECHANGESINFORM	= 0x4d006,
	XACT_S_ALLNORETAIN	= 0x4d007,
	XACT_S_ABORTING	= 0x4d008,
	XACT_S_SINGLEPHASE	= 0x4d009
    }	XACT_E;
#endif


extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransaction
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0fb15084-af41-11ce-bd2b-204c4f4f5020")
    ITransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
        END_INTERFACE
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionDispenser
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E1-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
        END_INTERFACE
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOptions
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E0-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
        END_INTERFACE
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOutcomeEvents
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Committed( 
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Aborted( 
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        END_INTERFACE
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_transact_0010
 * at Mon Feb 09 18:03:56 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 




#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_ITransaction,				0x0fb15084, 0xaf41, 0x11ce, 0xbd, 0x2b, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionDispenser,		0x3A6AD9E1, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOptions,			0x3A6AD9E0, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOutcomeEvents,	0x3A6AD9E2, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);

#else

#define  IID_ITransaction                    __uuidof(ITransaction)
#define  IID_ITransactionDispenser           __uuidof(ITransactionDispenser)
#define  IID_ITransactionOptions             __uuidof(ITransactionOptions)
#define  IID_ITransactionOutcomeEvents       __uuidof(ITransactionOutcomeEvents)

#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\transfrm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

//
// base class from which you can derive a simple transform codec.
//
// It assumes the codec has one input and one output stream, and has no
// interest in memory management, interface negotiation or anything else.
//
// derive your class from this, and supply Transform and the media type/format
// negotiation functions. Implement that class, compile and link and
// you're done.


#ifndef __TRANSFRM__
#define __TRANSFRM__

// ======================================================================
// This is the com object that represents a simple transform filter. It
// supports IBaseFilter, IMediaFilter and two pins through nested interfaces
// ======================================================================

class CTransformFilter;

// ==================================================
// Implements the input pin
// ==================================================

class CTransformInputPin : public CBaseInputPin
{
    friend class CTransformFilter;

protected:
    CTransformFilter *m_pTransformFilter;


public:

    CTransformInputPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

    STDMETHODIMP QueryId(LPWSTR * Id)
    {
        return AMGetWideString(L"In", Id);
    }

    // Grab and release extra interfaces if required

    HRESULT CheckConnect(IPin *pPin);
    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtIn);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType* mt);

    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    // AddRef it yourself if you need to hold it beyond the end
    // of this call.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream that passes straight downstream
    // (there is no queued data)
    STDMETHODIMP EndOfStream(void);

    // passes it to CTransformFilter::BeginFlush
    STDMETHODIMP BeginFlush(void);

    // passes it to CTransformFilter::EndFlush
    STDMETHODIMP EndFlush(void);

    STDMETHODIMP NewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    // Check if it's OK to process samples
    virtual HRESULT CheckStreaming();

    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };

};

// ==================================================
// Implements the output pin
// ==================================================

class CTransformOutputPin : public CBaseOutputPin
{
    friend class CTransformFilter;

protected:
    CTransformFilter *m_pTransformFilter;

public:

    // implement IMediaPosition by passing upstream
    IUnknown * m_pPosition;

    CTransformOutputPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

    ~CTransformOutputPin();

    // override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // --- CBaseOutputPin ------------

    STDMETHODIMP QueryId(LPWSTR * Id)
    {
        return AMGetWideString(L"Out", Id);
    }

    // Grab and release extra interfaces if required

    HRESULT CheckConnect(IPin *pPin);
    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // called from CBaseOutputPin during connection to ask for
    // the count and size of buffers we need.
    HRESULT DecideBufferSize(
                IMemAllocator * pAlloc,
                ALLOCATOR_PROPERTIES *pProp);

    // returns the preferred formats for a pin
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // inherited from IQualityControl via CBasePin
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };
};


class AM_NOVTABLE CTransformFilter : public CBaseFilter
{

public:

    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects

    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin);

    // override state changes to allow derived transform filter
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

public:

    CTransformFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid);
    ~CTransformFilter();

    // =================================================================
    // ----- override these bits ---------------------------------------
    // =================================================================

    // These must be supplied in a derived class

    virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);

    // check if you can support mtIn
    virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE;

    // check if you can support the transform from this input to this output
    virtual HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut) PURE;

    // this goes in the factory template table to create new instances
    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *);

    // call the SetProperties function with appropriate arguments
    virtual HRESULT DecideBufferSize(
                        IMemAllocator * pAllocator,
                        ALLOCATOR_PROPERTIES *pprop) PURE;

    // override to suggest OUTPUT pin media types
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) PURE;



    // =================================================================
    // ----- Optional Override Methods           -----------------------
    // =================================================================

    // you can also override these if you want to know about streaming
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();

    // override if you can do anything constructive with quality notifications
    virtual HRESULT AlterQuality(Quality q);

    // override this to know when the media type is actually set
    virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // chance to grab extra interfaces on connection
    virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
    virtual HRESULT BreakConnect(PIN_DIRECTION dir);
    virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin);

    // chance to customize the transform process
    virtual HRESULT Receive(IMediaSample *pSample);

    // Standard setup for output sample
    HRESULT InitializeOutputSample(IMediaSample *pSample, IMediaSample **ppOutSample);

    // if you override Receive, you may need to override these three too
    virtual HRESULT EndOfStream(void);
    virtual HRESULT BeginFlush(void);
    virtual HRESULT EndFlush(void);
    virtual HRESULT NewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

#ifdef PERF
    // Override to register performance measurement with a less generic string
    // You should do this to avoid confusion with other filters
    virtual void RegisterPerfId()
         {m_idTransform = MSR_REGISTER(TEXT("Transform"));}
#endif // PERF


// implementation details

protected:

#ifdef PERF
    int m_idTransform;                 // performance measuring id
#endif
    BOOL m_bEOSDelivered;              // have we sent EndOfStream
    BOOL m_bSampleSkipped;             // Did we just skip a frame
    BOOL m_bQualityChanged;            // Have we degraded?

    // critical section protecting filter state.

    CCritSec m_csFilter;

    // critical section stopping state changes (ie Stop) while we're
    // processing a sample.
    //
    // This critical section is held when processing
    // events that occur on the receive thread - Receive() and EndOfStream().
    //
    // If you want to hold both m_csReceive and m_csFilter then grab
    // m_csFilter FIRST - like CTransformFilter::Stop() does.

    CCritSec m_csReceive;

    // these hold our input and output pins

    friend class CTransformInputPin;
    friend class CTransformOutputPin;
    CTransformInputPin *m_pInput;
    CTransformOutputPin *m_pOutput;
};

#endif /* __TRANSFRM__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\udfutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#pragma once

#include <windows.h>

//
// Definition of callback indicating progress of format
//
typedef VOID (*PFN_PROGRESS)( DWORD dwPercent );

//
// This is used for formats that have different phases.
// Physical Format
// Logical Format
//
typedef VOID (*PFN_UDFPROGRESS)( DWORD dwPercent, const WCHAR* strPhase );

//
// Definition of callback to display a message or to prompt user
//
typedef BOOL (*PFN_MESSAGE)( LPTSTR szMessage, LPTSTR szCaption, BOOL fYesNo );

typedef struct
{
    BOOL fAllowFullFormat;
    BOOL fForceFullFormat;
    BOOL fMirrorMetadataFile;
    USHORT MajorRevision;
    USHORT MinorRevision;
    ULONG MetadataFileSize;
    ULONG SparingTableSize;
} UDF_FORMAT_OPTIONS, *PUDF_FORMAT_OPTIONS;

typedef struct
{
    UDF_FORMAT_OPTIONS FormatOptions;
    HANDLE hStore;
    HANDLE hPartition;
    PFN_UDFPROGRESS pfnProgress;
    PFN_MESSAGE pfnMessage;
} UDF_FORMATEX_PARAMS, *PUDF_FORMATEX_PARAMS;

//
// hPartition is not used on optical media.  In that case, it should be NULL.
//
typedef DWORD (*PFN_UDFFORMATVOLUME)( HANDLE hStore,
                                      HANDLE hPartition,
                                      PUDF_FORMAT_OPTIONS pFormatOptions,
                                      PFN_UDFPROGRESS pfnProgress,
                                      PFN_MESSAGE pfnMessage );

//
// This is required if a UDF volume calls FSDMGR_FormatVolume.
//
typedef DWORD (*PFN_UDFFORMATVOLUMEEX)( HANDLE hVolume,
                                        UDF_FORMATEX_PARAMS* pFormatParameters );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tspi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

tspi.h

Abstract:

Windows CE version of TSPI.h

Notes: 


--*/
// The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
// granted  a royalty free worldwide, unlimited license to make copies, and use
// the   API/SPI  for  making  applications/drivers  that  interface  with  the
// specification provided that this paragraph and the Intel/Microsoft copyright
// statement is maintained as is in the text and source code files.
//
// Copyright 1992, 1993 Intel/Microsoft, all rights reserved.

#ifndef TSPI_H
#define TSPI_H

#define TAPI_CE_4X_VERSION 0x00020010   // supports TSPI_lineTranslateAddress

#include <windows.h>

#include "tapi.h"

// tspi.h  is  only  of  use  in  conjunction  with tapi.h.  Very few types are
// defined  in  tspi.h.   Most  types of procedure formal parameters are simply
// passed through from corresponding procedures in tapi.h.  A working knowledge
// of the TAPI interface is required for an understanding of this interface.

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef DECLARE_OPAQUE32
#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#endif  // DECLARE_OPAQUE32

#ifndef TSPIAPI
# ifdef UNDER_CE
# define TSPIAPI
# else
#  define TSPIAPI __export __pascal
# endif                                    
#endif
 
DECLARE_OPAQUE32(HDRVCALL);
DECLARE_OPAQUE32(HDRVLINE);
DECLARE_OPAQUE32(HDRVPHONE);

typedef HDRVCALL * LPHDRVCALL;
typedef HDRVLINE * LPHDRVLINE;
typedef HDRVPHONE FAR * LPHDRVPHONE;

DECLARE_OPAQUE32(HTAPICALL);
DECLARE_OPAQUE32(HTAPILINE);
DECLARE_OPAQUE32(HTAPIPHONE);

typedef HTAPICALL * LPHTAPICALL;
typedef HTAPILINE * LPHTAPILINE;
typedef HTAPIPHONE FAR * LPHTAPIPHONE;

DECLARE_OPAQUE32(HPROVIDER);
typedef HPROVIDER * LPHPROVIDER;



typedef void (CALLBACK * LINEEVENT) (
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3);

typedef void (CALLBACK * PHONEEVENT)(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3
    );


#define TSPI_MESSAGE_BASE 500
    // The lowest-numbered TSPI-specific message ID number

#define LINE_NEWCALL                ((long) TSPI_MESSAGE_BASE + 0)
#define LINE_CALLDEVSPECIFIC        ((long) TSPI_MESSAGE_BASE + 1)
#define LINE_CALLDEVSPECIFICFEATURE ((long) TSPI_MESSAGE_BASE + 2)

typedef DWORD DRV_REQUESTID;

typedef void (CALLBACK * ASYNC_COMPLETION) (
    DRV_REQUESTID  dwRequestID,
    LONG           lResult);


// ----------------------------------------------------------------------------
// TSPIAPI TSPI_line functions
// ----------------------------------------------------------------------------
    
LONG TSPIAPI TSPI_lineAccept(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineAddToConference(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdConfCall,
    HDRVCALL       hdConsultCall);

LONG TSPIAPI TSPI_lineAnswer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineBlindTransfer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineClose(
    HDRVLINE  hdLine);

LONG TSPIAPI TSPI_lineCloseCall(
    HDRVCALL  hdCall);

LONG TSPIAPI TSPI_lineCompleteTransfer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    HDRVCALL       hdConsultCall,
    HTAPICALL      htConfCall,
    LPHDRVCALL     lphdConfCall,
    DWORD          dwTransferMode);

LONG TSPIAPI TSPI_lineConditionalMediaDetection(
    HDRVLINE          hdLine,
    DWORD             dwMediaModes,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineConfigDialogEdit(
    DWORD dwDeviceID,
    HWND hwndOwner, 
    LPCWSTR lpszDeviceClass,
    LPVOID const lpDeviceConfigIn, 
    DWORD dwSize,
    LPVARSTRING lpDeviceConfigOut
    );

LONG TSPIAPI TSPI_lineDevSpecific(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    LPVOID         lpParams,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineDial(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineDrop(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineForward(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    DWORD             bAllAddresses,
    DWORD             dwAddressID,
    LPLINEFORWARDLIST const lpForwardList,
    DWORD             dwNumRingsNoAnswer,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineGenerateDigits(
    HDRVCALL       hdCall,
    DWORD          dwEndToEndID,
    DWORD          dwDigitMode,
    LPCWSTR         lpszDigits,
    DWORD          dwDuration);

LONG TSPIAPI TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones);

LONG TSPIAPI TSPI_lineStartDTMF(
    HDRVCALL            hdCall,
    CHAR                   cDTMFDigit);

LONG TSPIAPI TSPI_lineStopDTMF(
    HDRVCALL            hdCall);

LONG TSPIAPI TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps);

LONG TSPIAPI TSPI_lineGetAddressID(
    HDRVLINE       hdLine,
    LPDWORD        lpdwAddressID,
    DWORD          dwAddressMode,
    LPCWSTR         lpsAddress,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineGetAddressStatus(
    HDRVLINE             hdLine,
    DWORD                dwAddressID,
    LPLINEADDRESSSTATUS  lpAddressStatus);

LONG TSPIAPI TSPI_lineGetCallAddressID(
    HDRVCALL  hdCall,
    LPDWORD   lpdwAddressID);

LONG TSPIAPI TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo);

LONG TSPIAPI TSPI_lineGetCallStatus(
    HDRVCALL          hdCall,
    LPLINECALLSTATUS  lpCallStatus);

LONG TSPIAPI TSPI_lineGetDevCaps(
    DWORD          dwDeviceID,
    DWORD          dwTSPIVersion,
    DWORD          dwExtVersion,
    LPLINEDEVCAPS  lpLineDevCaps);

LONG TSPIAPI TSPI_lineGetDevConfig(
    DWORD dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR lpszDeviceClass);

LONG TSPIAPI TSPI_lineGetExtensionID(
    DWORD              dwDeviceID,
    DWORD              dwTSPIVersion,
    LPLINEEXTENSIONID  lpExtensionID);

LONG TSPIAPI TSPI_lineGetIcon(
    DWORD    dwDeviceID,
    LPCWSTR   lpszDeviceClass,
    LPHICON  lphIcon);

LONG TSPIAPI TSPI_lineGetID(
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    DWORD          dwSelect,
    LPVARSTRING    lpDeviceID,
    LPCWSTR        lpszDeviceClass);

LONG TSPIAPI TSPI_lineGetLineDevStatus(
    HDRVLINE         hdLine,
    LPLINEDEVSTATUS  lpLineDevStatus);

LONG TSPIAPI TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs);

LONG TSPIAPI TSPI_lineHold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineMakeCall(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    HTAPICALL         htCall,
    LPHDRVCALL        lphdCall,
    LPCWSTR            lpszDestAddress,
    DWORD             dwCountryCode,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineMonitorDigits(
    HDRVCALL       hdCall,
    DWORD          dwDigitModes);

LONG TSPIAPI TSPI_lineMonitorMedia(
    HDRVCALL       hdCall,
    DWORD          dwMediaModes);

LONG TSPIAPI TSPI_lineNegotiateExtVersion(
    DWORD    dwDeviceID,
    DWORD    dwTSPIVersion,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwExtVersion);

LONG TSPIAPI TSPI_lineNegotiateTSPIVersion(
    DWORD    dwDeviceID,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwTSPIVersion);

LONG TSPIAPI TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc);

LONG TSPIAPI TSPI_linePickup(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HTAPICALL      htCall,
    LPHDRVCALL     lphdCall,
    LPCWSTR         lpszDestAddress,
    LPCWSTR         lpszGroupID);

LONG TSPIAPI TSPI_linePrepareAddToConference(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdConfCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineRedirect(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineRemoveFromConference(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineSecureCall(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineSelectExtVersion(
    HDRVLINE  hdLine,
    DWORD     dwExtVersion);

LONG TSPIAPI TSPI_lineSendUserUserInfo(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineSetCallParams(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    DWORD             dwBearerMode,
    DWORD             dwMinRate,
    DWORD             dwMaxRate,
    LPLINEDIALPARAMS  const lpDialParams);

LONG TSPIAPI TSPI_lineSetDefaultMediaDetection(
    HDRVLINE       hdLine,
    DWORD          dwMediaModes);

LONG TSPIAPI TSPI_lineSetDevConfig(
    DWORD         dwDeviceID,
    LPVOID        const lpDeviceConfig,
    DWORD         dwSize,
    LPCWSTR       lpszDeviceClass);

LONG TSPIAPI TSPI_lineSetMediaMode(
    HDRVCALL       hdCall,
    DWORD          dwMediaMode);

LONG TSPIAPI TSPI_lineSetStatusMessages(
    HDRVLINE       hdLine,
    DWORD          dwLineStates,
    DWORD          dwAddressStates);

LONG TSPIAPI TSPI_lineSetTerminal(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    DWORD          dwSelect,
    DWORD          dwTerminalModes,
    DWORD          dwTerminalID,
    DWORD           bEnable);

LONG TSPIAPI TSPI_lineSetupConference(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    HDRVLINE          hdLine,
    HTAPICALL         htConfCall,
    LPHDRVCALL        lphdConfCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    DWORD             dwNumParties,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineSetupTransfer(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineSwapHold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdActiveCall,
    HDRVCALL       hdHeldCall);

LONG TSPIAPI TSPI_lineTranslateAddress(
    DWORD                   dwDeviceID,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput);

LONG TSPIAPI TSPI_lineUnhold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);



// ----------------------------------------------------------------------------
// TSPIAPI TSPI_phone functions
// ----------------------------------------------------------------------------

LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE           hdPhone
    );

LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneGetData(
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDisplay
    );

LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
TSPIAPI
TSPI_phoneGetGain(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
TSPIAPI
TSPI_phoneGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE           hdPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

LONG
TSPIAPI
TSPI_phoneGetVolume(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD               dwDeviceID,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwTSPIVersion
    );

LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD               dwDeviceID,
    HTAPIPHONE          htPhone,
    LPHDRVPHONE         lphdPhone,
    DWORD               dwTSPIVersion,
    PHONEEVENT          lpfnEventProc
    );

LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE           hdPhone,
    DWORD               dwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneSetData(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCWSTR             lpsDisplay,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetGain(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE           hdPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
TSPIAPI
TSPI_phoneSetVolume(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );



// ----------------------------------------------------------------------------
// TSPIAPI TSPI_provider functions
// ----------------------------------------------------------------------------

// Returns a Vtbl of all the other TSPI functions
LONG TSPIAPI TSPI_lineGetProcTable(
    void *lplpTspiProcs
    );

LONG TSPIAPI TSPI_providerInstall(
    HWND   hwndOwner,
    DWORD  dwPermanentProviderID
    );

LONG TSPIAPI TSPI_providerInit(
    DWORD             dwTSPIVersion,
    DWORD             dwPermanentProviderID,
    DWORD             dwLineDeviceIDBase,
    DWORD             dwPhoneDeviceIDBase,
    DWORD             dwNumLines,
    DWORD             dwNumPhones,
    ASYNC_COMPLETION  lpfnCompletionProc,
    LPDWORD           lpdwTSPIOptions);

LONG TSPIAPI TSPI_providerShutdown(
    DWORD    dwTSPIVersion);

LONG TSPIAPI TSPI_providerCreateLineDevice(
    HKEY    hActiveKey,
    LPCWSTR lpszDevPath,
    LPCWSTR lpszDeviceName);

LONG TSPIAPI TSPI_providerDeleteLineDevice(
    DWORD   Identifier );

LONG TSPIAPI TSPI_providerCreatePhoneDevice(
    HKEY    hActiveKey,
    LPCWSTR lpszDevPath,
    LPCWSTR lpszDeviceName);

LONG TSPIAPI TSPI_providerDeletePhoneDevice(
    DWORD   Identifier );

LONG TSPIAPI TSPI_providerRemoveDevice(
    LPCWSTR lpszDeviceName);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  // TSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tuple.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

    tuple.h

Abstract:  

    This file implements the Windows CE PCMCIA metaformat card information
    tuple structure definitions.  This is provided as a sample to platform
    writers and is expected to be able to be used without modification on most
    (if not all) hardware platforms.

Functions:


Notes:

    Since the tuples are compressed and must be processed sequentially,
    the definitions provided here are in the form of a union of all
    the elements in the tuple.  This allows a byte pointer to the union
    to be incremented as it references each of the elements of the tuple.

    Also described are the parsed structures returned by the function
    CardGetParsedTuple().

--*/

// @doc DRIVERS

#ifndef TUPLE_INC
#define TUPLE_INC

#pragma pack(1)

// Tuple Codes

#define CISTPL_NULL         0x00
#define CISTPL_DEVICE       0x01
#define CISTPL_LONGLINK_CB  0x02        // CardBus
#define CISTPL_CONFIG_CB    0x04        // CardBus
#define CISTPL_CFTABLE_ENTRY_CB 0x05    // CardBus
#define CISTPL_LONGLINK_MFC 0x06        // Multiple Function
#define CISTPL_LONG_LINK_MFC 0x06       // Multiple Function
#define CISTPL_CHECKSUM     0x10
#define CISTPL_LONGLINK_A   0x11
#define CISTPL_LONGLINK_C   0x12
#define CISTPL_LINKTARGET   0x13
#define CISTPL_NO_LINK      0x14
#define CISTPL_VERS_1       0x15
#define CISTPL_ALTSTR       0x16
#define CISTPL_DEVICE_A     0x17
#define CISTPL_JEDEC_C      0x18
#define CISTPL_JEDEC_A      0x19
#define CISTPL_CONFIG       0x1A
#define CISTPL_CFTABLE_ENTRY 0x1B
#define CISTPL_DEVICE_OC    0x1C
#define CISTPL_DEVICE_OA    0x1D
#define CISTPL_GEODEVICE    0x1E
#define CISTPL_GEODEVICE_A  0x1F
#define CISTPL_MANFID       0x20
#define CISTPL_FUNCID       0x21
#define CISTPL_FUNCE        0x22
#define CISTPL_VERS_2       0x40
#define CISTPL_FORMAT       0x41
#define CISTPL_GEOMETRY     0x42
#define CISTPL_BYTEORDER    0x43
#define CISTPL_DATE         0x44
#define CISTPL_BATTERY      0x45
#define CISTPL_ORG          0x46
#define CISTPL_END          0xFF


// Device Information Tuple Definitions

typedef union {
    BYTE dt_DevID;
    BYTE dt_ExtDevSpeed;
    BYTE dt_DevSize;
} DEVICE_TPL;

// Device ID Definitions

#define DEVID_DSPEED 0x07    // Device speed mask
#define DEVID_WPS    0x08    // Device write protect switch bit
#define DEVID_DTYPE  0xF0    // Device type code mask

// Device Speed Code Definitions

#define DSPEED_NULL  0x00
#define DSPEED_250NS 0x01
#define DSPEED_200NS 0x02
#define DSPEED_150NS 0x03
#define DSPEED_100NS 0x04
#define DSPEED_EXT   0x07

// Device Type Code Definitions

#define DTYPE_NULL     0x00
#define DTYPE_ROM      0x01
#define DTYPE_OTPROM   0x02
#define DTYPE_EPROM    0x03
#define DTYPE_EEPROM   0x04
#define DTYPE_FLASH    0x05
#define DTYPE_SRAM     0x06
#define DTYPE_DRAM     0x07
#define DTYPE_FUNCSPEC 0x0D
#define DTYPE_EXTEND   0x0E

// Extended Device Speed Definitions

#define ESPEED_EXP  0x07    // Extended device speed exponent mask
#define ESPEED_MANT 0x71    // Extended device speed mantissa mask
#define ESPEED_EXT  0x80    // Additional ext speed byte follows

// Extended Device Speed Code Exponent Definitions

#define SPDEXP_1NS   0x00
#define SPDEXP_10NS  0x01
#define SPDEXP_100NS 0x02
#define SPDEXP_1US   0x03
#define SPDEXP_10US  0x04
#define SPDEXP_100US 0x05
#define SPDEXP_1MS   0x06
#define SPDEXP_10MS  0x07

// Extended Device Speed Code Mantissa Definitions

#define SPDMANT_1_0 0x01
#define SPDMANT_1_2 0x02
#define SPDMANT_1_3 0x03
#define SPDMANT_1_5 0x04
#define SPDMANT_2_0 0x05
#define SPDMANT_2_5 0x06
#define SPDMANT_3_0 0x07
#define SPDMANT_3_5 0x08
#define SPDMANT_4_0 0x09
#define SPDMANT_4_5 0x0A
#define SPDMANT_5_0 0x0B
#define SPDMANT_5_5 0x0C
#define SPDMANT_6_0 0x0D
#define SPDMANT_7_0 0x0E
#define SPDMANT_8_0 0x0F

// Device Size Byte Definitions

#define DSIZE_CODE  0x07
#define DSIZE_UNITS 0xF1

// Device Size Code Definitions

#define SCODE_512  0x00
#define SCODE_2K   0x01
#define SCODE_8K   0x02
#define SCODE_32K  0x03
#define SCODE_128K 0x04
#define SCODE_512K 0x05
#define SCODE_2M   0x06


// Level 1 Version/Product Information Tuple Definitions

typedef struct {
    BYTE v1_Major;
    BYTE v1_Minor;
    BYTE v1_Info;
} L1VERS_TPL;

// Device Information String Terminator Definition

#define TPLL1V_END 0xFF


// Configuration Tuple Definitions

typedef union {
    struct {
    BYTE cc_Sz;
    BYTE cc_Last;
    };
    BYTE cc_RAdr;
    BYTE cc_RMsk;
} CONFIG_TPL;

// Configuration Size Field Byte Definitions

#define TPCC_RASZ 0x03
#define TPCC_RMSZ 0x3C
#define TPCC_RFSZ_MASK  0xC0
#define TPCCRFSZ(X)     ((X & TPCC_RFSZ_MASK) >> 6)
#define TPCC_RMSZ_MASK  0x3C
#define TPCCRMSZ(X)     ((X & TPCC_RMSZ_MASK) >> 2)
#define TPCC_RASZ_MASK  0x03
#define TPCCRASZ(X)     (X & TPCC_RASZ_MASK)

// Configuration Last Entry Index Byte Definitions

#define TPCC_LASTINDX 0x3F


// Configuration Table Entry Tuple Definitions

typedef union {
    BYTE ce_Indx;
    BYTE ce_IF;
    BYTE ce_FS;
    union {
    BYTE ce_PD_Selection;
    BYTE ce_PD_NomV;
    BYTE ce_PD_MinV;
    BYTE ce_PD_MaxV;
    BYTE ce_PD_StaticI;
    BYTE ce_PD_AvgI;
    BYTE ce_PD_PeakI;
    BYTE ce_PD_PDwnI;
    };
    BYTE ce_TD;
    union {
    BYTE ce_IO_Parm;
    BYTE ce_IO_RangeDesc;
    BYTE ce_IO_Address;
    BYTE ce_IO_Length;
    };
    union {
    BYTE ce_IR_Parm;
    WORD ce_IR_MASK;
    };
    BYTE ce_MS;
    BYTE ce_MI;
} CFENTRY_TPL;

// Configuration Table Index Byte Definitions

#define TPCE_ENTRYNUM 0x3F
#define TPCE_DEFAULT  0x40
#define TPCE_INTFACE  0x80

// Configuration Table Entry Interface Description Field Definitions

#define TPCE_IFTYPE       0x0F
#define TPCE_BVDSACTIVE   0x10
#define TPCE_WPACTIVE     0x20
#define TPCE_RDYBSYACTIVE 0x40
#define TPCE_MWAITREQD    0x80

// Configuration Table Entry Feature Selection Byte Definitions

#define TPCE_POWER    0x03
#define TPCE_TIMING   0x04
#define TPCE_IOSPACE  0x08
#define TPCE_IRQ      0x10
#define TPCE_MEMSPACE 0x60
#define TPCE_MISC     0x80

// Configuration Table Entry Power Desc Parameter Selection Byte Definitions

#define TPCE_PD_NOMV    0x01
#define TPCE_PD_MINV    0x02
#define TPCE_PD_MAXV    0x04
#define TPCE_PD_STATICI 0x08
#define TPCE_PD_AVGI    0x10
#define TPCE_PD_PEAKI   0x20
#define TPCE_PD_PDWNI   0x40

// Configuration Table Entry Power Description Structure Parameter Definitions

#define TPCE_PD_EXP   0x07
#define TPCE_PD_MANT  0x71
#define TPCE_PD_EXT   0x80

#define TPCE_PD_EXTEN 0x7F

// Configuration Table Entry Power Description Voltage Exponent Definitions

#define PDEXP_10UV    0x00
#define PDEXP_100UV   0x01
#define PDEXP_1MV     0x02
#define PDEXP_10MV    0x03
#define PDEXP_100MV   0x04
#define PDEXP_1V      0x05
#define PDEXP_10V     0x06
#define PDEXP_100V    0x07

// Configuration Table Entry Power Description Current Exponent Definitions

#define PDEXP_100NA   0x00
#define PDEXP_1UA     0x01
#define PDEXP_10UA    0x02
#define PDEXP_100UA   0x03
#define PDEXP_1MA     0x04
#define PDEXP_10MA    0x05
#define PDEXP_100MA   0x06
#define PDEXP_1A      0x07

// Configuration Table Entry Power Description Mantissa Definitions

#define PDMANT_1_0    0x00
#define PDMANT_1_2    0x01
#define PDMANT_1_3    0x02
#define PDMANT_1_5    0x03
#define PDMANT_2_0    0x04
#define PDMANT_2_5    0x05
#define PDMANT_3_0    0x06
#define PDMANT_3_5    0x07
#define PDMANT_4_0    0x08
#define PDMANT_4_5    0x09
#define PDMANT_5_0    0x0A
#define PDMANT_5_5    0x0B
#define PDMANT_6_0    0x0C
#define PDMANT_7_0    0x0D
#define PDMANT_8_0    0x0E
#define PDMANT_9_0    0x0F

// Configuration Table Entry Timing Information Definitions

#define TPCE_TD_WAIT   0x03
#define TPCE_TD_RDYBSY 0x1C

// Configuration Table Entry I/O Space Address Parameter Definitions

#define TPCE_IO_ADDRLINES 0x1F
#define TPCE_IO_BUS8      0x20
#define TPCE_IO_BUS16     0x40
#define TPCE_IO_RANGE     0x80

// Configuration Table Entry I/O Space Range Descriptor Definitions

#define TPCE_IO_NUMRANGES  0x0F
#define TPCE_IO_ADDRSIZE   0x30
#define TPCE_IO_LENGTHSIZE 0xC0

// Configuration Table Entry IRQ Interrupt Request Descriptor Definitions

#define TPCE_IR_IRQN  0x0F
#define TPCE_IR_NMI   0x01
#define TPCE_IR_LOCK  0x02
#define TPCE_IR_BERR  0x04
#define TPCE_IR_VEND  0x08
#define TPCE_IR_MASK  0x10
#define TPCE_IR_LEVEL 0x20
#define TPCE_IR_PULSE 0x40
#define TPCE_IR_SHARE 0x80



//******************************************************

typedef struct tTPCE_IF
{
    BYTE InterfaceType;
    BYTE BVDsActive;
    BYTE WPActive;
    BYTE RdyBsyActive;
    BYTE MWaitActive;
} tTPCE_IF;

typedef struct tTPCE_FS
{
    BYTE Power;
    BYTE Timing;
    BYTE IOSpace;
    BYTE IRQ;
    BYTE MemSpace;
    BYTE Misc;
} tTPCE_FS;

typedef struct tTPCE_PD
{
    BYTE   NomVPresent;
    BYTE   MinVPresent;
    BYTE   MaxVPresent;
    BYTE   StaticIPresent;
    BYTE   AvgIPresent;
    BYTE   PeakIPresent;
    BYTE   PDwnIPresent;
    BYTE   RFUPresent;
    double NomV;
    double MinV;
    double MaxV;
    double StaticI;
    double AvgI;
    double PeakI;
    double PDwnI;
    double RFU;
} tTPCE_PD;

typedef struct tTPCE_TD
{
    BYTE   WaitScalePresent;
    BYTE   ReadyBusyScalePresent;
    BYTE   ReservedScale7Present;
    double WaitScale;
    double ReadyBusyScale;
    double ReservedScale7;
} tTPCE_TD;

typedef struct tTPCE_IO
{
    BYTE IOAddrLines;
    BYTE Bus8;
    BYTE Bus16;
    BYTE Range;
    BYTE NumberIOAddrRanges;
    BYTE AddressSize;
    BYTE LengthSize;
} tTPCE_IO;

typedef struct tTPCE_IR
{
    BYTE Irqn;
    BYTE Vend;
    BYTE Berr;
    BYTE Iock;
    BYTE Nmi;
    BYTE Mask0;
    BYTE Level;
    BYTE Pulse;
    BYTE Share;
    BYTE Irq0;
    BYTE Irq1;
    BYTE Irq2;
    BYTE Irq3;
    BYTE Irq4;
    BYTE Irq5;
    BYTE Irq6;
    BYTE Irq7;
    BYTE Irq8;
    BYTE Irq9;
    BYTE Irq10;
    BYTE Irq11;
    BYTE Irq12;
    BYTE Irq13;
    BYTE Irq14;
    BYTE Irq15;
} tTPCE_IR;

typedef struct tTPCE_MS
{
    BYTE NumWindows;
    BYTE LengthSize;
    BYTE CardAddrSze;
    BYTE HostAddr;
} tTPCE_MS;

typedef struct tTPCE_MI
{
    BYTE MaxTwinCards;
    BYTE Audio;
    BYTE ReadOnly;
    BYTE PwrDown;
    BYTE Reserved;
    BYTE Ext;
} tTPCE_MI;

typedef struct tCardEntryTuple
{
    BYTE     ConfigEntryNumber;
    BYTE     DefaultBit;
    BYTE     InterfaceBytePresent;
    tTPCE_IF IF;
    tTPCE_FS FS;
    tTPCE_PD PDVcc;
    tTPCE_PD PDVpp1;
    tTPCE_PD PDVpp2;
    tTPCE_TD TD;
    tTPCE_IO IO;
    tTPCE_IR IR;
    tTPCE_MS MS;
    tTPCE_MI MI;
} tCardEntryTuple;

typedef struct tDGTPL
{
    BYTE DGTPL_BUS;
    BYTE DGTPL_EBS;
    BYTE DGTPL_RBS;
    BYTE DGTPL_WBS;
    BYTE DGTPL_PART;
    BYTE DGTPL_HWIL;
} tDGTPL;

//
// CISTPL_FUNCID function codes
//
#define PCCARD_TYPE_VENDOR_SPECIFIC 0
#define PCCARD_TYPE_MEMORY        1
#define PCCARD_TYPE_SERIAL        2
#define PCCARD_TYPE_PARALLEL      3
#define PCCARD_TYPE_FIXED_DISK    4
#define PCCARD_TYPE_VIDEO         5
#define PCCARD_TYPE_NETWORK       6
#define PCCARD_TYPE_AIMS          7
#define PCCARD_TYPE_UNKNOWN       0xff


//
// Parsed structures returned by CardGetParsedTuple
//

//
// @struct PARSED_CONFIG | Structure returned by CardGetParsedTuple for a parsed
//                         CISTPL_CONFIG tuple
//
// Note:
//  1) only one byte of the register presence mask is used,
//  2) custom interface subtuples are not parsed
//
typedef struct _PARSED_CONFIG {
    UINT32  ConfigBase;         // @field Base address of the card configuration registers.
    UINT8   RegMask;            // @field Config register presence mask.
    UINT8   LastConfigIndex;    // @field Index of last entry in the card configuration table.
} PARSED_CONFIG, * PPARSED_CONFIG;


//
// Parsed CISTPL_CFTABLE_ENTRY tuples.
//
// All CISTPL_CFTABLE_ENTRY tuples for a given socket/function are parsed
// and the results are returned using the following three structures.
//
// Note: the custom interface subtuples are not parsed
//

//
//  If the POWER_DESCR structure is changed, then PARSED_CFTABLE must be realigned
//
// @struct POWER_DESCR | Structure used for the power description fields
// VccDescr, Vpp1Descr and Vpp2Descr in a PARSED_CFTABLE structure.
//
// Note:
//  1) The voltages are in 0.1 volt units,
//  2) The currents are in milliAmps,
//
typedef struct _POWER_DESCR {
    UINT16   ValidMask;      // @field Describes which of the following fields are valid
                            // (bit 0 set implies NominalV is valid,
                            // bit 1 set implies MinV is valid)
                            // etc
    UINT16   NominalV;       // @field Nominal operating supply voltage
    UINT16   MinV;           // @field Minimum operating supply voltage
    UINT16   MaxV;           // @field Maximum operating supply voltage
    UINT16   StaticI;        // @field Continuous supply current required
    UINT16   AvgI;           // @field Max current required averaged over 1 second
    UINT16   PeakI;          // @field Max current required averaged over 10 milliseconds
    UINT16   PowerDownI;     // @field Power-down supply current required
} POWER_DESCR, * PPOWER_DESCR;

//
// POWER_DESCR.ValidMask
// 
#define PWR_DESCR_NOMINALV  0x01
#define PWR_DESCR_MINV      0x02
#define PWR_DESCR_MAXV      0x04
#define PWR_DESCR_STATICI   0x08
#define PWR_DESCR_AVGI      0x10
#define PWR_DESCR_PEAKI     0x20
#define PWR_DESCR_POWERDWNI 0x40

#define PWR_AVAIL_NOMINALV  0x0100
#define PWR_AVAIL_MINV      0x0200
#define PWR_AVAIL_MAXV      0x0400

#define MAX_IO_RANGES   4   // limit this to 4, it can be as high as 16

//
// @struct PARSED_CFTABLE | Structure used by CardGetParsedTuple for parsed
// CISTPL_CFTABLE_ENTRY tuples.
//
typedef struct _PARSED_CFTABLE {
    POWER_DESCR VccDescr;   // @field Power description of Vcc
    POWER_DESCR Vpp1Descr;  // @field Power description of Vpp1
    POWER_DESCR Vpp2Descr;  // @field Power description of Vpp2

    UINT32  IOLength[MAX_IO_RANGES];    // @field IOLength[i] is the number of bytes in 
    UINT32  IOBase[MAX_IO_RANGES];      // @field the I/O address range starting at IOBase[i]
                                        // There are NumIOEntries in each array.
    UINT8   NumIOEntries;   // @field Number of I/O address range entries in the two arrays:
                            // IOLength[] and IOBase[]

    UINT8   ConfigIndex;    // @field Value to be written to the configuration option
                            // register to enable this CFTABLE_ENTRY.
    UINT8   ContainsDefaults;   // @field True if this entry contains defaults to be used by subsequent entries.

    UINT8   IFacePresent;   // @field True if the following 5 fields are valid:
    UINT8   IFaceType;      // @field 0 = memory, 1 = I/O, 2,3,8-15 = rsvd, 4-7 = custom
    UINT8   BVDActive;      // @field True if BVD1 and BVD2 are active in the Pin Replacement Register (PRR)
    UINT8   WPActive;       // @field True if the card write protect is active in the PRR
    UINT8   ReadyActive;    // @field True if READY is active in the PRR
    UINT8   WaitRequired;   // @field True if the WAIT signal is required for memory cycles

    UINT8   IOAccess;       // @field 1 = 8 bit only, 2 = 8 bit access to 16 bit registers is not supported,
                            // 3 = 8 bit access to 16 bit registers is supported

    UINT8   NumIOAddrLines; // @field 0 = socket controller provides address decode
                            // 1-26 = number of address lines decoded
    UINT8   Pad0;
} PARSED_CFTABLE, * PPARSED_CFTABLE;

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\types.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: types.h

Purpose: Type definitions.

--*/

/* Useful typedefs */

#pragma once

#ifndef _TYPES_H_
#define _TYPES_H_

/* The left side of these typedefs are machine and compiler dependent */
typedef signed      char        INT8;
typedef unsigned    char        UINT8;
typedef signed      short       INT16;
typedef unsigned    short       UINT16;
typedef signed      int         INT32;
typedef unsigned    int         UINT32;
typedef signed      __int64     INT64;
typedef unsigned    __int64     UINT64;
typedef unsigned    __int64     ULONG64;
typedef struct _INT128  { UINT32 u0,u1,u2; INT32 u3; } INT128;
typedef struct _UINT128 { UINT32 u0,u1,u2,u3; } UINT128;

typedef INT8    *PINT8;
typedef UINT8   *PUINT8;
typedef INT16   *PINT16;
typedef UINT16  *PUINT16;
typedef INT32   *PINT32;
typedef UINT32  *PUINT32;
typedef INT64   *PINT64;
typedef UINT64  *PUINT64;
typedef ULONG64 *PULONG64;
typedef INT128  *PINT128;
typedef UINT128 *PUINT128;

typedef const void * PCVOID;
typedef void ** PPVOID;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef void (*PFNVOID)();
typedef CHAR * LPCHAR;

typedef HANDLE HPROCESS;
typedef HANDLE HTHREAD;

typedef LPCRECT PCRECT;

typedef DWORD WIN32_ERROR_CODE;
#endif // _TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tvout.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: tvout.h

--*/

#ifndef __TVOUT_H_
#define __TVOUT_H_


typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    ULONG dwOffset;                     // leave it 0 for now.
    ULONG dwCommand;                    // VP_COMMAND_*            SET or GET
    ULONG dwFlags;                      // bitfield, defined below SET or GET
    ULONG dwMode;                       // bitfield, defined below SET or GET
    ULONG dwTVStandard;                 // bitfield, defined below SET or GET
    ULONG dwAvailableModes;             // bitfield, defined below GET
    ULONG dwAvailableTVStandard;        // bitfield, defined below GET
    ULONG dwFlickerFilter;              // value                   SET or GET
    ULONG dwOverScanX;                  // value                   SET or GET
    ULONG dwOverScanY;                  //                         SET or GET
    ULONG dwMaxUnscaledX;               // value                   SET or GET
    ULONG dwMaxUnscaledY;               //                         SET or GET
    ULONG dwPositionX;                  // value                   SET or GET
    ULONG dwPositionY;                  //                         SET or GET
    ULONG dwBrightness;                 // value                   SET or GET
    ULONG dwContrast;                   // value                   SET or GET
    ULONG dwCPType;                     // copy protection type    SET or GET
    ULONG dwCPCommand;                  // VP_CP_CMD_
    ULONG dwCPStandard;                 // what TV standards CP is available on. GET
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    UCHAR bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET          0x0001  // size set, return caps.
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET          0x0002  // size and params set.

#define VP_FLAGS_TV_MODE        0x0001
#define VP_FLAGS_TV_STANDARD    0x0002
#define VP_FLAGS_FLICKER        0x0004
#define VP_FLAGS_OVERSCAN       0x0008
#define VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define VP_FLAGS_POSITION       0x0020
#define VP_FLAGS_BRIGHTNESS     0x0040
#define VP_FLAGS_CONTRAST       0x0080
#define VP_FLAGS_COPYPROTECT    0x0100

#define VP_MODE_WIN_GRAPHICS    0x0001
#define VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback

#define VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define VP_TV_STANDARD_PAL_B    0x0004
#define VP_TV_STANDARD_PAL_D    0x0008
#define VP_TV_STANDARD_PAL_H    0x0010
#define VP_TV_STANDARD_PAL_I    0x0020
#define VP_TV_STANDARD_PAL_M    0x0040
#define VP_TV_STANDARD_PAL_N    0x0080
#define VP_TV_STANDARD_SECAM_B  0x0100
#define VP_TV_STANDARD_SECAM_D  0x0200
#define VP_TV_STANDARD_SECAM_G  0x0400
#define VP_TV_STANDARD_SECAM_H  0x0800
#define VP_TV_STANDARD_SECAM_K  0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L  0x4000
#define VP_TV_STANDARD_WIN_VGA  0x8000
// and the rest
#define VP_TV_STANDARD_NTSC_433 0x00010000
#define VP_TV_STANDARD_PAL_G    0x00020000
#define VP_TV_STANDARD_PAL_60   0x00040000
#define VP_TV_STANDARD_SECAM_L1 0x00080000

#define VP_CP_TYPE_APS_TRIGGER  0x0001  // DVD trigger bits only
#define VP_CP_TYPE_MACROVISION  0x0002  // full macrovision data available

#define VP_CP_CMD_ACTIVATE      0x0001  // CP command type
#define VP_CP_CMD_DEACTIVATE    0x0002
#define VP_CP_CMD_CHANGE        0x0004

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\tsp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//


#ifndef _TSP_H_
#define _TSP_H_


#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif


/* String constants used to identify the CellTSP */
#define CELLTSP_PROVIDERINFO_STRING (L"Cellular TAPI Service Provider")
#define CELLTSP_LINENAME_STRING (L"Cellular Line")
#define CELLTSP_PHONENAME_STRING (L"Cellular Phone")
#define CELLTSP_NDISNAME_STRING (L"Cellular NDIS")


/* Maximum length constants */
#define CELLDEVCONFIG_MAXLENGTH_GPRSACCESSPOINTNAME (64)
#define CELLDEVCONFIG_MAXLENGTH_GPRSADDRESS         (64)
#define CELLDEVCONFIG_MAXLENGTH_GPRSPARAMETERS      (32)


/* LINEBEARERMODE_ constant to identify GPRS calls */
#define LINEBEARERMODE_GPRS (LINEBEARERMODE_DATA << 16)
// When using RAS, the following string MUST be used as the destination address for all GPRS calls
#define GPRS_DEST_ADDRESS (L"~GPRS!")

/* LINEDISCONNECTMODE_ constants to provide more detailed error reporting */
#define LINEDISCONNECTMODE_PHONECONNECTIONFAILURE      (LINEDISCONNECTMODE_NORMAL | (0xd0<<16))
#define LINEDISCONNECTMODE_INVALIDSIMCARD              (LINEDISCONNECTMODE_NORMAL | (0xd1<<16))
#define LINEDISCONNECTMODE_SIMCARDBUSY                 (LINEDISCONNECTMODE_NORMAL | (0xd2<<16))
#define LINEDISCONNECTMODE_NETWORKSERVICENOTAVAILABLE  (LINEDISCONNECTMODE_NORMAL | (0xd3<<16))
#define LINEDISCONNECTMODE_EMERGENCYONLY               (LINEDISCONNECTMODE_NORMAL | (0xd4<<16))


/* Caller ID options for LINECALLPARAMSDEVSPECIFIC structure */
enum CALLER_ID_OPTIONS {
    CALLER_ID_DEFAULT,  /* Accept the default behavior */
    CALLER_ID_BLOCK,    /* Block sending of caller-ID information, overriding the current default if necessary */
    CALLER_ID_PRESENT,  /* Send caller-ID information, overriding the current default if necessary */
};

/* Structure that can be passed as data for LINECALLPARAMS.dwDevSpecific[Size, Offset] */
typedef struct linecallparamsdevspecific_tag {
    CALLER_ID_OPTIONS cidoOptions;
} LINECALLPARAMSDEVSPECIFIC, *LPLINECALLPARAMSDEVSPECIFIC;


/* Bearer Service CE constants define bearer service connection elements for CELLBEARERINFO structure */
#define CELLDEVCONFIG_CONNELEM_UNKNOWN              (0x00000000)  // Bearer service unknown
#define CELLDEVCONFIG_CONNELEM_TRANSPARENT          (0x00000001)  // Link layer correction enabled
#define CELLDEVCONFIG_CONNELEM_NONTRANSPARENT       (0x00000002)  // No link layer correction present
#define CELLDEVCONFIG_CONNELEM_BOTH_TRANSPARENT     (0x00000003)  // Both available, transparent preferred
#define CELLDEVCONFIG_CONNELEM_BOTH_NONTRANSPARENT  (0x00000004)  // Both available, non-transparent preferred

/* Telephony service type constants for CELLBEARERINFO structure
   These flags only apply for data access.  When a voice call is being
   placed, this flag is ignored. */
#define CELLDEVCONFIG_SERVICE_UNKNOWN               (0x00000000)  // Unknown service
#define CELLDEVCONFIG_SERVICE_MODEM_ASYNC           (0x00000001)  // Asynchronous modem
#define CELLDEVCONFIG_SERVICE_MODEM_SYNC            (0x00000002)  // Synchronous modem
#define CELLDEVCONFIG_SERVICE_PADACCESS_ASYNC       (0x00000003)  // PAD Access (asynchronous)
#define CELLDEVCONFIG_SERVICE_PACKETACCESS_SYNC     (0x00000004)  // Packet Access (synchronous)

/* Data rate constants define protocol dependent data rates for CELLBEARERINFO structure */
#define CELLDEVCONFIG_SPEED_UNKNOWN                 (0x00000000)  // Unknown speed
#define CELLDEVCONFIG_SPEED_AUTO                    (0x00000001)  // Automatic selection of speed
#define CELLDEVCONFIG_SPEED_300_V21                 (0x00000002)  // 300 bps      (V.21)
#define CELLDEVCONFIG_SPEED_300_V110                (0x00000003)  // 300 bps      (V.100)
#define CELLDEVCONFIG_SPEED_1200_V22                (0x00000004)  // 1200 bps     (V.22)
#define CELLDEVCONFIG_SPEED_1200_75_V23             (0x00000005)  // 1200/75 bps  (V.23)
#define CELLDEVCONFIG_SPEED_1200_V110               (0x00000006)  // 1200 bps     (V.100)
#define CELLDEVCONFIG_SPEED_1200_V120               (0x00000007)  // 1200 bps     (V.120)
#define CELLDEVCONFIG_SPEED_2400_V22BIS             (0x00000008)  // 2400 bps     (V.22bis)
#define CELLDEVCONFIG_SPEED_2400_V26TER             (0x00000009)  // 2400 bps     (V.26ter)
#define CELLDEVCONFIG_SPEED_2400_V110               (0x0000000a)  // 2400 bps     (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_2400_V120               (0x0000000b)  // 2400 bps     (V.120)
#define CELLDEVCONFIG_SPEED_4800_V32                (0x0000000c)  // 4800 bps     (V.32)
#define CELLDEVCONFIG_SPEED_4800_V110               (0x0000000d)  // 4800 bps     (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_4800_V120               (0x0000000e)  // 4800 bps     (V.120)
#define CELLDEVCONFIG_SPEED_9600_V32                (0x0000000f)  // 9600 bps     (V.32)
#define CELLDEVCONFIG_SPEED_9600_V34                (0x00000010)  // 9600 bps     (V.34)
#define CELLDEVCONFIG_SPEED_9600_V110               (0x00000011)  // 9600 bps     (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_9600_V120               (0x00000012)  // 9600 bps     (V.120)
#define CELLDEVCONFIG_SPEED_14400_V34               (0x00000013)  // 14400 bps    (V.34)
#define CELLDEVCONFIG_SPEED_14400_V110              (0x00000014)  // 14400 bps    (V.100 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_14400_V120              (0x00000015)  // 14400 bps    (V.120)
#define CELLDEVCONFIG_SPEED_19200_V34               (0x00000016)  // 19200 bps    (V.34)
#define CELLDEVCONFIG_SPEED_19200_V110              (0x00000017)  // 19200 bps    (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_19200_V120              (0x00000018)  // 19200 bps    (V.120)
#define CELLDEVCONFIG_SPEED_28800_V34               (0x00000019)  // 28800 bps    (V.34)
#define CELLDEVCONFIG_SPEED_28800_V110              (0x0000001a)  // 28800 bps    (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_28800_V120              (0x0000001b)  // 28800 bps    (V.120)
#define CELLDEVCONFIG_SPEED_38400_V110              (0x0000001c)  // 38400 bps    (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_38400_V120              (0x0000001d)  // 38400 bps    (V.120)
#define CELLDEVCONFIG_SPEED_48000_V110              (0x0000001e)  // 48000 bps    (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_48000_V120              (0x0000001f)  // 48000 bps    (V.120)
#define CELLDEVCONFIG_SPEED_56000_V110              (0x00000020)  // 56000 bps    (V.110 or X.31 flag stuffing)
#define CELLDEVCONFIG_SPEED_56000_V120              (0x00000021)  // 56000 bps    (V.120)
#define CELLDEVCONFIG_SPEED_56000_TRANSP            (0x00000022)  // 56000 bps    (bit transparent)
#define CELLDEVCONFIG_SPEED_64000_TRANSP            (0x00000023)  // 64000 bps    (bit transparent)
#define CELLDEVCONFIG_SPEED_32000_PIAFS32K          (0x00000024)      // 32000 bps (PIAFS32k)
#define CELLDEVCONFIG_SPEED_64000_PIAFS64K          (0x00000025)      //  64000 bps (PIAFS64k)
#define CELLDEVCONFIG_SPEED_28800_MULTIMEDIA        (0x00000026)      //  28800 bps (MultiMedia)
#define CELLDEVCONFIG_SPEED_32000_MULTIMEDIA        (0x00000027)      //  32000 bps (MultiMedia)
#define CELLDEVCONFIG_SPEED_33600_MULTIMEDIA        (0x00000028)      //  33600 bps (MultiMedia)
#define CELLDEVCONFIG_SPEED_56000_MULTIMEDIA        (0x00000029)      //  56000 bps (MultiMedia)
#define CELLDEVCONFIG_SPEED_64000_MULTIMEDIA        (0x0000002a)      //  64000 bps (MultiMedia)

/* Data compression directions constants for CELLDATACOMPINFO structure */
#define CELLDEVCONFIG_DATACOMPDIR_UNKNOWN           (0x00000000)  // Unknown direction
#define CELLDEVCONFIG_DATACOMPDIR_NONE              (0x00000001)  // No compression
#define CELLDEVCONFIG_DATACOMPDIR_TRANSMIT          (0x00000002)  // Transmit only
#define CELLDEVCONFIG_DATACOMPDIR_RECEIVE           (0x00000003)  // Receive only
#define CELLDEVCONFIG_DATACOMPDIR_BOTH              (0x00000004)  // Both directions, accept any direction

/* GPRS data compression settings constants for CELLGPRSCONNECTIONINFO structure */
#define CELLDEVCONFIG_GPRSCOMPRESSION_UNKNOWN       (0x00000000)  // Compression unknown
#define CELLDEVCONFIG_GPRSCOMPRESSION_OFF           (0x00000001)  // Compression off
#define CELLDEVCONFIG_GPRSCOMPRESSION_ON            (0x00000002)  // Compression on

/* GPRS protocol identifier constants for CELLGPRSCONNECTIONINFO structure */
#define CELLDEVCONFIG_GPRSPROTOCOL_UNKNOWN       (0x00000000)  // Unknown
#define CELLDEVCONFIG_GPRSPROTOCOL_X25           (0x00000001)  // Unsupported
#define CELLDEVCONFIG_GPRSPROTOCOL_IP            (0x00000002)  // IP (Radio acts as PPP server)
#define CELLDEVCONFIG_GPRSPROTOCOL_IHOSP         (0x00000003)  // Unsupported
#define CELLDEVCONFIG_GPRSPROTOCOL_PPP           (0x00000004)  // Point to Point protocol (PPP frames forwarded to end server)

/* GPRS L2 protocol identifier constants for CELLGPRSCONNECTIONINFO structure */
#define CELLDEVCONFIG_GPRSL2PROTOCOL_UNKNOWN     (0x00000000)  // Unknown
#define CELLDEVCONFIG_GPRSL2PROTOCOL_NULL        (0x00000001)  // Unsupported
#define CELLDEVCONFIG_GPRSL2PROTOCOL_PPP         (0x00000002)  // WinCE uses PPP
#define CELLDEVCONFIG_GPRSL2PROTOCOL_PAD         (0x00000003)  // Unsupported
#define CELLDEVCONFIG_GPRSL2PROTOCOL_X25         (0x00000004)  // Unsupported

/* GPRS precedence classes for CELLGPRSQOSSETTINGS structure */
#define CELLDEVCONFIG_GPRSPRECEDENCECLASS_UNKNOWN             (0x00000000)  // Unknown
#define CELLDEVCONFIG_GPRSPRECEDENCECLASS_SUBSCRIBED          (0x00000001)  // Subscribed value stored in network
#define CELLDEVCONFIG_GPRSPRECEDENCECLASS_HIGH                (0x00000002)  // High priority
#define CELLDEVCONFIG_GPRSPRECEDENCECLASS_NORMAL              (0x00000003)  // Normal priority
#define CELLDEVCONFIG_GPRSPRECEDENCECLASS_LOW                 (0x00000004)  // Low priority

/* GPRS delay classes for CELLGPRSQOSSETTINGS structure */
#define CELLDEVCONFIG_GPRSDELAYCLASS_UNKNOWN                 (0x00000000)  // Unknown
#define CELLDEVCONFIG_GPRSDELAYCLASS_SUBSCRIBED              (0x00000001)
#define CELLDEVCONFIG_GPRSDELAYCLASS_PREDICTIVE1             (0x00000002)
#define CELLDEVCONFIG_GPRSDELAYCLASS_PREDICTIVE2             (0x00000003)
#define CELLDEVCONFIG_GPRSDELAYCLASS_PREDICTIVE3             (0x00000004)
#define CELLDEVCONFIG_GPRSDELAYCLASS_BESTEFFORT              (0x00000005)

/* GPRS reliability classes for CELLGPRSQOSSETTINGS structure */
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_UNKNOWN           (0x00000000)  // Unknown
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_SUBSCRIBED        (0x00000001)
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_1                 (0x00000002)
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_2                 (0x00000003)
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_3                 (0x00000004)
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_4                 (0x00000005)
#define CELLDEVCONFIG_GPRSRELIABILITYCLASS_5                 (0x00000006)

/* GPRS peak throughput classes for CELLGPRSQOSSETTINGS structure */
#define CELLDEVCONFIG_PEAKTHRUCLASS_UNKNOWN                  (0x00000000)  // Unknown
#define CELLDEVCONFIG_PEAKTHRUCLASS_SUBSCRIBED               (0x00000001)
#define CELLDEVCONFIG_PEAKTHRUCLASS_8000                     (0x00000002)  // kbit/second
#define CELLDEVCONFIG_PEAKTHRUCLASS_16000                    (0x00000003)
#define CELLDEVCONFIG_PEAKTHRUCLASS_32000                    (0x00000004)
#define CELLDEVCONFIG_PEAKTHRUCLASS_64000                    (0x00000005)
#define CELLDEVCONFIG_PEAKTHRUCLASS_128000                   (0x00000006)
#define CELLDEVCONFIG_PEAKTHRUCLASS_256000                   (0x00000007)
#define CELLDEVCONFIG_PEAKTHRUCLASS_512000                   (0x00000008)
#define CELLDEVCONFIG_PEAKTHRUCLASS_1024000                  (0x00000009)
#define CELLDEVCONFIG_PEAKTHRUCLASS_2048000                  (0x0000000a)

/* GPRS mean throughput classes for CELLGPRSQOSSETTINGS structure */
#define CELLDEVCONFIG_MEANTHRUCLASS_UNKNOWN                  (0x00000000)  // Unknown
#define CELLDEVCONFIG_MEANTHRUCLASS_SUBSCRIBED               (0x00000001)
#define CELLDEVCONFIG_MEANTHRUCLASS_100                      (0x00000002)  // octets/hour
#define CELLDEVCONFIG_MEANTHRUCLASS_200                      (0x00000003)
#define CELLDEVCONFIG_MEANTHRUCLASS_500                      (0x00000004)
#define CELLDEVCONFIG_MEANTHRUCLASS_1000                     (0x00000005)
#define CELLDEVCONFIG_MEANTHRUCLASS_2000                     (0x00000006)
#define CELLDEVCONFIG_MEANTHRUCLASS_5000                     (0x00000007)
#define CELLDEVCONFIG_MEANTHRUCLASS_10000                    (0x00000008)
#define CELLDEVCONFIG_MEANTHRUCLASS_20000                    (0x00000009)
#define CELLDEVCONFIG_MEANTHRUCLASS_50000                    (0x0000000a)
#define CELLDEVCONFIG_MEANTHRUCLASS_100000                   (0x0000000b)
#define CELLDEVCONFIG_MEANTHRUCLASS_200000                   (0x0000000c)
#define CELLDEVCONFIG_MEANTHRUCLASS_500000                   (0x0000000d)
#define CELLDEVCONFIG_MEANTHRUCLASS_1000000                  (0x0000000e)
#define CELLDEVCONFIG_MEANTHRUCLASS_2000000                  (0x0000000f)
#define CELLDEVCONFIG_MEANTHRUCLASS_5000000                  (0x00000010)
#define CELLDEVCONFIG_MEANTHRUCLASS_10000000                 (0x00000011)
#define CELLDEVCONFIG_MEANTHRUCLASS_20000000                 (0x00000012)
#define CELLDEVCONFIG_MEANTHRUCLASS_50000000                 (0x00000013)
#define CELLDEVCONFIG_MEANTHRUCLASS_DONTCARE                 (0x00000014)  // Best effort

/* Flags for the CELLDEVCONFIG structure */
#define CELLDEVCONFIG_FLAG_TERMINALAFTERDIALING              (0x00000001)  // (Only valid when used with lineSetDevConfig)


/* Structure containing bearer information
   Used to set different bearers, specifically to enable quick connect. */
typedef struct CELLBEARERINFO_tag {
    DWORD dwSpeed;              /* One of the CELLDEVCONFIG_SPEED_* constants */
    DWORD dwService;            /* One of the CELLDEVCONFIG_SERVICE_* constants */
    DWORD dwConnectionElement;  /* One of the CELLDEVCONFIG_CONNELEM_* constants */
} CELLBEARERINFO, *LPCELLBEARERINFO;

/* Structure containing data compression information
   Used for v.42bis compression settings. */
typedef struct CELLDATACOMPINFO_tag {
    DWORD dwDirection;        /* One of the CELLDEVCONFIG_DATACOMPDIR_* constants */
    BOOL  dwRequired;         /* Data compression required */
    DWORD dwMaxDictEntries;   /* Maximum number of dictionary entries */
    DWORD dwMaxStringLength;  /* Maximum string length */
} CELLDATACOMPINFO, *LPCELLDATACOMPINFO;

/* Structure containing radio link protocol settings
   Radio link protocol is a link layer correction protocol that increases
   the perceived reliability of the air link. */
typedef struct CELLRADIOLINKINFO_tag {
    DWORD dwVersion;             /* Version number */
    DWORD dwIws;                 /* IWF to MS window size  */
    DWORD dwMws;                 /* MS to IWF window size  */
    DWORD dwAckTimer;            /* Acknowledgement timer [T1] (milliseconds) */
    DWORD dwRetransmitAttempts;  /* Retransmit attempts [N2] */
    DWORD dwResequenceTimer;     /* Resequence timer [T4] (milliseconds) */
} CELLRADIOLINKINFO, *LPCELLRADIOLINKINFO;

/* Structure containing GPRS Quality Of Service (QOS) settings
   Used to specify minimum and requested QOS settings */
typedef struct CELLGPRSQOSSETTINGS_tag {
    DWORD dwPrecedenceClass;                               /* One of the CELLDEVCONFIG_GPRSPRECEDENCECLASS_* constants */
    DWORD dwDelayClass;                                    /* One of the CELLDEVCONFIG_GPRSDELAYCLASS_* constants */
    DWORD dwReliabilityClass;                              /* One of the CELLDEVCONFIG_GPRSRELIABILITYCLASS_* constants */
    DWORD dwPeakThruClass;                                 /* One of the CELLDEVCONFIG_GPRSPEAKTHRUCLASS_* constants */
    DWORD dwMeanThruClass;                                 /* One of the CELLDEVCONFIG_GPRSMEANTHRUCLASS_* constants */
} CELLGPRSQOSSETTINGS, *LPCELLGPRSQOSSETTINGS;

/* Structure containing GPRS connection information
   Used in the initiation of GPRS calls. */
typedef struct CELLGPRSCONNECTIONINFO_tag {
    DWORD                dwProtocolType;                                                    /* One of the CELLDEVCONFIG_GPRSPROTOCOL_* constants */
    DWORD                dwL2ProtocolType;                                                  /* One of the CELLDEVCONFIG_GPRSL2PROTOCOL_* constants */
    WCHAR                wszAccessPointName[CELLDEVCONFIG_MAXLENGTH_GPRSACCESSPOINTNAME];   /* Logical name to select the GPRS gateway  */
    WCHAR                wszAddress[CELLDEVCONFIG_MAXLENGTH_GPRSADDRESS];                   /* The packet address to use (if empty, then a dynamic address will be requested) */
    DWORD                dwDataCompression;                                                 /* One of the CELLDEVCONFIG_GPRSCOMPRESSION_* constants */
    DWORD                dwHeaderCompression;                                               /* One of the CELLDEVCONFIG_GPRSCOMPRESSION_* constants */
    char                 szParameters[CELLDEVCONFIG_MAXLENGTH_GPRSPARAMETERS];              /* Prococol-specific parameters (NULL terminated) */
    BOOL                 bRequestedQOSSettingsValid;                                        /* TRUE iff sgqsRequestedQOSSettings is valid */
    CELLGPRSQOSSETTINGS  cgqsRequestedQOSSettings;                                          /* GPRS QOS settings structure */
    BOOL                 bMinimumQOSSettingsValid;                                          /* TRUE iff sgqsMinimumQOSSettings is valid */
    CELLGPRSQOSSETTINGS  cgqsMinimumQOSSettings;                                            /* GPRS QOS settings structure */
} CELLGPRSCONNECTIONINFO, *LPCELLGPRSCONNECTIONINFO;

/* A service-provider-specific configuration structure
   This structure is specific to this version of this TSP.  Future versions
   may append additional data elements to the end of this structure. */
typedef struct CELLDEVCONFIG_tag {
    DWORD                   dwTotalSize;               /* Standard TAPI structure variable */
    DWORD                   dwNeededSize;              /* Standard TAPI structure variable */
    DWORD                   dwUsedSize;                /* Standard TAPI structure variable */
    BOOL                    bBearerInfoValid;          /* TRUE iff sbiBearerInfo is valid */
    CELLBEARERINFO          cbiBearerInfo;             /* Bearer structure */
    BOOL                    bDataCompInfoValid;        /* TRUE iff sdciDataCompInfo is valid */
    CELLDATACOMPINFO        cdciDataCompInfo;          /* Data compression structure */
    BOOL                    bRadioLinkInfoValid;       /* TRUE iff srliRadioLinkInfo is valid */
    CELLRADIOLINKINFO       crliRadioLinkInfo;         /* RLP structure */
    BOOL                    bGPRSConnectionInfoValid;  /* TRUE iff sgciGPRSConnectionInfo is valid */
    CELLGPRSCONNECTIONINFO  cgciGPRSConnectionInfo;    /* GPRS connection structure */
    DWORD                   dwFlags;                   /* Bit-mask of CELLDEVCONFIG_FLAG_* constants */
} CELLDEVCONFIG, *LPCELLDEVCONFIG;


#ifdef __cplusplus
}
#endif


#endif  // _TSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\transip.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

//
// base class from which you can derive a simple Transform-In-Place filter.
// The difference between this and Transfrm.h is that Transfrm copies the data.
//
// It assumes the filter has one input and one output stream, and has no
// interest in memory management, interface negotiation or anything else.
//
// Derive your class from this, and supply Transform and the media type/format
// negotiation functions. Implement that class, compile and link and
// you're done.


#ifndef __TRANSIP__
#define __TRANSIP__

// ======================================================================
// This is the com object that represents a simple transform filter. It
// supports IBaseFilter, IMediaFilter and two pins through nested interfaces
// ======================================================================

class CTransInPlaceFilter;

// Several of the pin functions call filter functions to do the work,
// so you can often use the pin classes unaltered, just overriding the
// functions in CTransInPlaceFilter.  If that's not enough and you want
// to derive your own pin class, override GetPin in the filter to supply
// your own pin classes to the filter.

// ==================================================
// Implements the input pin
// ==================================================

class CTransInPlaceInputPin : public CTransformInputPin
{

protected:
    CTransInPlaceFilter *m_pTIPFilter;    // our filter
    BOOL                 m_bReadOnly;     // incoming stream is read only

public:

    CTransInPlaceInputPin(
        TCHAR               *pObjectName,
        CTransInPlaceFilter *pFilter,
        HRESULT             *phr,
        LPCWSTR              pName);

    // --- IMemInputPin -----

    // Provide an enumerator for media types by getting one from downstream
    STDMETHODIMP EnumMediaTypes( IEnumMediaTypes **ppEnum );

    // Say whether media type is acceptable.
    HRESULT CheckMediaType(const CMediaType* pmt);

    // Return our upstream allocator
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // get told which allocator the upstream output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator,
                                 BOOL bReadOnly);

    // Allow the filter to see what allocator we have
    // N.B. This does NOT AddRef
    IMemAllocator * PeekAllocator()
        {  return m_pAllocator; }

    // Pass this on downstream if it ever gets called.
    STDMETHODIMP
    CTransInPlaceInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    inline const BOOL ReadOnly() { return m_bReadOnly; }


};  // CTransInPlaceInputPin

// ==================================================
// Implements the output pin
// ==================================================

class CTransInPlaceOutputPin : public CTransformOutputPin
{

protected:
    // m_pFilter points to our CBaseFilter
    CTransInPlaceFilter *m_pTIPFilter;

public:

    CTransInPlaceOutputPin(
        TCHAR               *pObjectName,
        CTransInPlaceFilter *pFilter,
        HRESULT             *phr,
        LPCWSTR              pName);


    // --- CBaseOutputPin ------------

    // negotiate the allocator and its buffer size/count
    // Insists on using our own allocator.  (Actually the one upstream of us).
    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

    // Provide a media type enumerator.  Get it from upstream.
    STDMETHODIMP EnumMediaTypes( IEnumMediaTypes **ppEnum );

    // Say whether media type is acceptable.
    HRESULT CheckMediaType(const CMediaType* pmt);

    // This is like NotifyAllocator - only output pins do not normally have those
    // This is only called internally by our own input pin to propagate
    // allocator decisions downstream.  ReadOnly allocators are not propagated
    // but we check the properties and propagate those.
    HRESULT ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadONly);

    IMemInputPin * ConnectedIMemInputPin()
        { return m_pInputPin; }

    // Allow the filter to see what allocator we have
    // N.B. This does NOT AddRef
    IMemAllocator * PeekAllocator()
        {  return m_pAllocator; }
};  // CTransInPlaceOutputPin


class AM_NOVTABLE CTransInPlaceFilter : public CTransformFilter
{

public:

    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects

    virtual CBasePin *GetPin(int n);

public:

    CTransInPlaceFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid, HRESULT *);

    // The following are defined to avoid undefined pure virtuals.
    // Even if they are never called, they will give linkage warnings/errors

    // We override EnumMediaTypes to bypass the transform class enumerator
    // which would otherwise call this.
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType)
        {   DbgBreak("CTransInPlaceFilter::GetMediaType should never be called");
            return E_UNEXPECTED;
        }

    // This is called when we actually have to provide out own allocator.
    HRESULT DecideBufferSize(IMemAllocator*, ALLOCATOR_PROPERTIES *);

    // The functions which call this in CTransform are overridden in this
    // class to call CheckInputType with the assumption that the type
    // does not change.  In Debug builds some calls will be made and
    // we just ensure that they do not assert.
    HRESULT CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut)
    {
        return S_OK;
    };


    // =================================================================
    // ----- You may want to override this -----------------------------
    // =================================================================

    HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pReceivePin);

    // chance to customize the transform process
    virtual HRESULT Receive(IMediaSample *pSample);

    // =================================================================
    // ----- You MUST override these -----------------------------------
    // =================================================================

    virtual HRESULT Transform(IMediaSample *pSample) PURE;

    // this goes in the factory template table to create new instances
    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *);


#ifdef PERF
    // Override to register performance measurement with a less generic string
    // You should do this to avoid confusion with other filters
    virtual void RegisterPerfId()
         {m_idTransInPlace = MSR_REGISTER(TEXT("TransInPlace"));}
#endif // PERF


// implementation details

protected:

    IMediaSample * CTransInPlaceFilter::Copy(IMediaSample *pSource);

    int m_idTransInPlace;                 // performance measuring id

    // these hold our input and output pins

    friend class CTransInPlaceInputPin;
    friend class CTransInPlaceOutputPin;

    CTransInPlaceInputPin  *InputPin()
    {
        return (CTransInPlaceInputPin *)m_pInput;
    };
    CTransInPlaceOutputPin *OutputPin()
    {
        return (CTransInPlaceOutputPin *)m_pOutput;
    };
}; // CTransInPlaceFilter

#endif /* __TRANSIP__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\udpmib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    udpmib.h

Abstract:

    This module contains the public definitions and structures for the
    UDP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

Environment:

    user mode or kernel mode

--*/

#ifndef _UDPMIB_
#define _UDPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#define TCPIP_OWNING_MODULE_SIZE 16

typedef struct _MIB_UDPROW {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
} MIB_UDPROW, *PMIB_UDPROW;

typedef struct _MIB_UDPTABLE {
    DWORD dwNumEntries;
    MIB_UDPROW table[ANY_SIZE];
} MIB_UDPTABLE, *PMIB_UDPTABLE;

#define SIZEOF_UDPTABLE(X) (FIELD_OFFSET(MIB_UDPTABLE, table[0]) + \
						    ((X) * sizeof(MIB_UDPROW)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_PID {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwOwningPid;
} MIB_UDPROW_OWNER_PID, *PMIB_UDPROW_OWNER_PID;

typedef struct _MIB_UDPTABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_PID    table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_PID, *PMIB_UDPTABLE_OWNER_PID;

#define SIZEOF_UDPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_PID, table[0]) + \
									  ((X) * sizeof(MIB_UDPROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_MODULE {
    DWORD           dwLocalAddr;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDPROW_OWNER_MODULE, *PMIB_UDPROW_OWNER_MODULE;

typedef struct _MIB_UDPTABLE_OWNER_MODULE
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_MODULE, *PMIB_UDPTABLE_OWNER_MODULE;

#define SIZEOF_UDPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_MODULE, table[0]) + \
										 ((X) * sizeof(MIB_UDPROW_OWNER_MODULE)) + ALIGN_SIZE)

#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

typedef struct _MIB_UDP6ROW {
    IN6_ADDR dwLocalAddr;
    DWORD dwLocalScopeId;
    DWORD dwLocalPort;
} MIB_UDP6ROW, *PMIB_UDP6ROW;

typedef struct _MIB_UDP6TABLE {
    DWORD dwNumEntries;
    MIB_UDP6ROW table[ANY_SIZE];
} MIB_UDP6TABLE, *PMIB_UDP6TABLE;

#define SIZEOF_UDP6TABLE(X) (FIELD_OFFSET(MIB_UDP6TABLE, table[0]) + \
							 ((X) * sizeof(MIB_UDP6ROW)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_PID {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
} MIB_UDP6ROW_OWNER_PID, *PMIB_UDP6ROW_OWNER_PID;

typedef struct _MIB_UDP6TABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDP6ROW_OWNER_PID   table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_PID, *PMIB_UDP6TABLE_OWNER_PID;

#define SIZEOF_UDP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_PID, table[0]) + \
									   ((X) * sizeof(MIB_UDP6ROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_MODULE {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDP6ROW_OWNER_MODULE, *PMIB_UDP6ROW_OWNER_MODULE;

typedef struct _MIB_UDP6TABLE_OWNER_MODULE
{
    DWORD                    dwNumEntries;
    MIB_UDP6ROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_MODULE, *PMIB_UDP6TABLE_OWNER_MODULE;

#define SIZEOF_UDP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_MODULE, table[0]) + \
										  ((X) * sizeof(MIB_UDP6ROW_OWNER_MODULE)) + ALIGN_SIZE)

#endif // _WS2IPDEF_

typedef struct _MIB_UDPSTATS {
    DWORD dwInDatagrams;
    DWORD dwNoPorts;
    DWORD dwInErrors;
    DWORD dwOutDatagrams;
    DWORD dwNumAddrs;
} MIB_UDPSTATS,*PMIB_UDPSTATS;

#endif // _UDPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\unaligned.hpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       unaligned.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of UNALIGNED data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an UNALIGNED type, use the MAKE_UNALIGNED_TYPE macro.  For example, if
// you need an int_UNALIGNED, say
//
//        MAKE_UNALIGNED_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type UNALIGNED" in your code
// with "type_UNALIGNED".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// UNALIGNED64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __unaligned_h__
#define __unaligned_h__

#if defined (_MSC_VER) || defined(__APOGEE__)

#define MAKE_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_UNALIGNED

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//

#ifdef SPARC
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base base##_UNALIGNED64
#else
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base UNALIGNED base##_UNALIGNED64
#endif // SPARC

#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef base UNALIGNED *base##_UNALIGNEDPTR

#else // defined (_MSC_VER) || defined(__APOGEE__)


#ifdef BIG_ENDIAN

#define SET2(val,data)                          \
    data[0] = (val) >> 8,                       \
    data[1] = (val)

#define GET2(data)                              \
    ( ( data[0] << 8 ) |                        \
      ( data[1] ) )

#define SET4(val,data)                          \
    data[0] = (val) >> 24,                      \
    data[1] = (val) >> 16,                      \
    data[2] = (val) >> 8,                       \
    data[3] = (val)

#define GET4(data)                              \
    ( ( data[0] << 24 ) |                       \
      ( data[1] << 16 ) |                       \
      ( data[2] << 8 ) |                        \
      ( data[3] ) )

#define SET8(val,data)                          \
    data[0] = (val) >> 56,                      \
    data[1] = (val) >> 48,                      \
    data[2] = (val) >> 40,                      \
    data[3] = (val) >> 32                       \
    data[4] = (val) >> 24,                      \
    data[5] = (val) >> 16,                      \
    data[6] = (val) >> 8,                       \
    data[7] = (val)

#define GET8(data)                              \
    ( ( data[0] << 56 ) |                       \
      ( data[1] << 48 ) |                       \
      ( data[2] << 40 ) |                       \
      ( data[3] << 32 ) |                       \
      ( data[4] << 24 ) |                       \
      ( data[5] << 16 ) |                       \
      ( data[6] << 8 ) |                        \
      ( data[7] ) )

#define SET648(val,data)                        \
    data[0] = (val) >> 32,                      \
    data[1] = (val)

#define GET648(data)                            \
    ( ( data[0] << 32 ) |                       \
      ( data[1] ) )

#else

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                              \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#endif

#define GROUP(type,size,get,set,sfx)                                    \
    Unaligned##sfx##size( type v ) { set##size( v, data ); }            \
    type operator = ( type v )     { set##size( v, data ); return v; }  \
    operator type()           { return get##size( data ); }             \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; } \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; } \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; } \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; } \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; } \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; } \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; } \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; } \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; } \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; } \


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class Unaligned##sfx##size<BASE>                                \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}

MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
MAKE_TEMPLATE( 8, unsigned int, 64 );

template<class BASE>
class UnalignedPtr<BASE> : Unaligned4<BASE> {
public:
	UnalignedPtr<BASE>(const void * v) : Unaligned4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#define MAKE_UNALIGNED_TYPE(base,size)    typedef Unaligned##size<base>   base##_UNALIGNED
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef Unaligned64##size<base> base##_UNALIGNED64
#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef UnalignedPtr<base> *    base##_UNALIGNEDPTR

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_UNALIGNED_TYPE( short, 2 );
MAKE_UNALIGNED_TYPE( int, 4 );
MAKE_UNALIGNED_TYPE( long, 4 );
MAKE_UNALIGNED_TYPE( WORD, 2 );
MAKE_UNALIGNED_TYPE( DWORD, 4 );
MAKE_UNALIGNED_TYPE( USHORT, 4 );
MAKE_UNALIGNED_TYPE( SHORT, 4 );
MAKE_UNALIGNED_TYPE( __int64, 8 );
MAKE_UNALIGNED64_TYPE( __int64, 8 );

#endif __unaligned_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\urltrack.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:16:06 2007
 */
/* Compiler settings for ..\urltrack.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urltrack_h__
#define __urltrack_h__

/* Forward Declarations */ 

#ifndef __IUrlTrackingStg_FWD_DEFINED__
#define __IUrlTrackingStg_FWD_DEFINED__
typedef interface IUrlTrackingStg IUrlTrackingStg;
#endif 	/* __IUrlTrackingStg_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_urltrack_0000 */
/* [local] */ 



////////////////////////////////////////////////////////////////////////////
//  User click stream tracking object

EXTERN_C const GUID CLSID_CUrlTrackingStg          ;

//  IUrlTrackingStg Interface Definitions
#ifndef _LPURLTRACKSTG
#define _LPURLTRACKSTG
typedef 
enum tagBRMODE
    {	BM_NORMAL	= 0,
	BM_SCREENSAVER	= 1,
	BM_DESKTOP	= 2,
	BM_THEATER	= 3,
	BM_UNKNOWN	= 4
    }	BRMODE;



extern RPC_IF_HANDLE __MIDL_itf_urltrack_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urltrack_0000_v0_0_s_ifspec;

#ifndef __IUrlTrackingStg_INTERFACE_DEFINED__
#define __IUrlTrackingStg_INTERFACE_DEFINED__

/* interface IUrlTrackingStg */
/* [object][uuid][local] */ 


EXTERN_C const IID IID_IUrlTrackingStg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f2f8cbb3-b040-11d0-bb16-00c04fb66f63")
    IUrlTrackingStg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLoad( 
            /* [in] */ LPCTSTR lpszUrl,
            /* [in] */ BRMODE ContextMode,
            /* [in] */ BOOL fUseCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUnload( 
            /* [in] */ LPCTSTR lpszUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUrlTrackingStgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUrlTrackingStg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUrlTrackingStg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUrlTrackingStg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLoad )( 
            IUrlTrackingStg __RPC_FAR * This,
            /* [in] */ LPCTSTR lpszUrl,
            /* [in] */ BRMODE ContextMode,
            /* [in] */ BOOL fUseCache);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUnload )( 
            IUrlTrackingStg __RPC_FAR * This,
            /* [in] */ LPCTSTR lpszUrl);
        
        END_INTERFACE
    } IUrlTrackingStgVtbl;

    interface IUrlTrackingStg
    {
        CONST_VTBL struct IUrlTrackingStgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlTrackingStg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUrlTrackingStg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUrlTrackingStg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUrlTrackingStg_OnLoad(This,lpszUrl,ContextMode,fUseCache)	\
    (This)->lpVtbl -> OnLoad(This,lpszUrl,ContextMode,fUseCache)

#define IUrlTrackingStg_OnUnload(This,lpszUrl)	\
    (This)->lpVtbl -> OnUnload(This,lpszUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUrlTrackingStg_OnLoad_Proxy( 
    IUrlTrackingStg __RPC_FAR * This,
    /* [in] */ LPCTSTR lpszUrl,
    /* [in] */ BRMODE ContextMode,
    /* [in] */ BOOL fUseCache);


void __RPC_STUB IUrlTrackingStg_OnLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUrlTrackingStg_OnUnload_Proxy( 
    IUrlTrackingStg __RPC_FAR * This,
    /* [in] */ LPCTSTR lpszUrl);


void __RPC_STUB IUrlTrackingStg_OnUnload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUrlTrackingStg_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urltrack_0081 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urltrack_0081_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urltrack_0081_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\urlmonui.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#if !defined(_DEF_URLMONUI_H_)

#define _DEF_URLMONUI_H_ 

// Return values from DialogProc's
enum  {  ZALERT_NO = 0 /* should be 0*/ , ZALERT_YES, ZALERT_YESPERSIST };

#if defined(__cplusplus)
extern "C"{
#endif 

int IsDialogBoxHandled
(
    IN HWND     hWnd,
    IN DWORD    dwAction,
    IN DWORD    dwPermissions,
    IN LPCTSTR  lpszText
);


#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\uniqueid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    uniqueid.h

Abstract:

    Definitions for the unique identifier returned by
    IOCTL_HAL_GET_DEVICEID

Revision History:

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winioctl.h>

typedef struct _DEVICE_ID {
	DWORD	dwSize;
	DWORD	dwPresetIDOffset;
	DWORD	dwPresetIDBytes;
	DWORD	dwPlatformIDOffset;
	DWORD	dwPlatformIDBytes;
} DEVICE_ID, *PDEVICE_ID;


#ifndef IOCTL_HAL_GET_DEVICEID
#define IOCTL_HAL_GET_DEVICEID CTL_CODE(FILE_DEVICE_HAL, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
BOOL KernelIoControl(DWORD dwIoControlCode, LPVOID lpInBuf, DWORD nInBufSize, LPVOID lpOutBuf, DWORD nOutBufSize, LPDWORD lpBytesReturned);
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\unknwn.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/* Lack of pragma once is deliberate */

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Sat Feb 28 06:58:11 2004
 */
/* Compiler settings for .\unknwn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

/* Forward Declarations */ 

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_unknwn_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_s_ifspec;

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

/* interface IUnknown */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IUnknown __RPC_FAR *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IUnknown;
    extern "C++"
    {
        MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
        IUnknown
        {
        public:
            BEGIN_INTERFACE
            virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
                /* [in] */ REFIID riid,
                /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
            
            virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
            
            virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
    	
            template<class Q>
    	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
    	{
    	    return QueryInterface(__uuidof(Q), (void **)pp);
    	}
            
            END_INTERFACE
        };
    } // extern C++
    HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy(
        IUnknown __RPC_FAR * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    void __RPC_STUB IUnknown_QueryInterface_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_AddRef_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_Release_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
#else

EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
    IUnknown
    {
    public:
        BEGIN_INTERFACE
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
        
        END_INTERFACE
    };
    
#else 	/* C style interface */

    typedef struct IUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnknown __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnknown __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnknown __RPC_FAR * This);
        
        END_INTERFACE
    } IUnknownVtbl;

    interface IUnknown
    {
        CONST_VTBL struct IUnknownVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy( 
    IUnknown __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_unknwn_0003 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0003_v0_0_s_ifspec;

#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

/* interface IClassFactory */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IClassFactory __RPC_FAR *LPCLASSFACTORY;


EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000001-0000-0000-C000-000000000046")
    IClassFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClassFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClassFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            IClassFactory __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockServer )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ BOOL fLock);
        
        END_INTERFACE
    } IClassFactoryVtbl;

    interface IClassFactory
    {
        CONST_VTBL struct IClassFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject)

#define IClassFactory_LockServer(This,fLock)	\
    (This)->lpVtbl -> LockServer(This,fLock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IClassFactory_RemoteLockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);


/* [call_as] */ HRESULT __stdcall IClassFactory_LockServer_Stub( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\usb100.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  
    usb100.h

Abstract:  
    Constant definitions from Universal Serial Bus specification version 1.0.

Notes: 

--*/
#ifndef   __USB100_H__
#define   __USB100_H__


#include <windows.h>
#include <PSHPACK1.H>

#define MAXIMUM_USB_STRING_LENGTH 255

// values for the bits returned by the USB GET_STATUS command
#define USB_GETSTATUS_SELF_POWERED                0x01
#define USB_GETSTATUS_REMOTE_WAKEUP_ENABLED       0x02


#define USB_DEVICE_DESCRIPTOR_TYPE                0x01
#define USB_CONFIGURATION_DESCRIPTOR_TYPE         0x02
#define USB_STRING_DESCRIPTOR_TYPE                0x03
#define USB_INTERFACE_DESCRIPTOR_TYPE             0x04
#define USB_ENDPOINT_DESCRIPTOR_TYPE              0x05
#define USB_POWER_DESCRIPTOR_TYPE                 0x08
#define USB_DEVICE_INTERFACE_ASSOCIATION_DESCRIPTOR 0x0b

#define USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(d, i) ((USHORT)((USHORT)d<<8 | i))

//
// Values for bmAttributes field of an
// endpoint descriptor
//

#define USB_ENDPOINT_TYPE_MASK                    0x03

#define USB_ENDPOINT_TYPE_CONTROL                 0x00
#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
#define USB_ENDPOINT_TYPE_BULK                    0x02
#define USB_ENDPOINT_TYPE_INTERRUPT               0x03


//
// definitions for bits in the bmAttributes field of a
// configuration descriptor.
//
#define USB_CONFIG_POWERED_MASK                   0x40

// This bit must be set for USB specification compliance
#define USB_CONFIG_RESERVED_ATTRIBUTE             0x80

#define USB_CONFIG_SELF_POWERED                   0x40
#define USB_CONFIG_REMOTE_WAKEUP                  0x20

//
// Endpoint direction bit, stored in address
//

#define USB_ENDPOINT_DIRECTION_MASK               0x80

// test direction bit in the bEndpointAddress field of
// an endpoint descriptor.
#define USB_ENDPOINT_DIRECTION_OUT(addr)          (!((addr) & USB_ENDPOINT_DIRECTION_MASK))
#define USB_ENDPOINT_DIRECTION_IN(addr)           ((addr) & USB_ENDPOINT_DIRECTION_MASK)

//
// USB defined request codes
// see chapter 9 of the USB 1.0 specifcation for
// more information.
//

// These are the correct values based on the USB 1.0
// specification

#define USB_REQUEST_GET_STATUS                    0x00
#define USB_REQUEST_CLEAR_FEATURE                 0x01

#define USB_REQUEST_SET_FEATURE                   0x03

#define USB_REQUEST_SET_ADDRESS                   0x05
#define USB_REQUEST_GET_DESCRIPTOR                0x06
#define USB_REQUEST_SET_DESCRIPTOR                0x07
#define USB_REQUEST_GET_CONFIGURATION             0x08
#define USB_REQUEST_SET_CONFIGURATION             0x09
#define USB_REQUEST_GET_INTERFACE                 0x0A
#define USB_REQUEST_SET_INTERFACE                 0x0B
#define USB_REQUEST_SYNC_FRAME                    0x0C


//
// defined USB device classes
//


#define USB_DEVICE_CLASS_RESERVED           0x00
#define USB_DEVICE_CLASS_AUDIO              0x01
#define USB_DEVICE_CLASS_COMMUNICATIONS     0x02
#define USB_DEVICE_CLASS_HUMAN_INTERFACE    0x03
#define USB_DEVICE_CLASS_MONITOR            0x04
#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE 0x05
#define USB_DEVICE_CLASS_POWER              0x06
#define USB_DEVICE_CLASS_PRINTER            0x07
#define USB_DEVICE_CLASS_STORAGE            0x08
#define USB_DEVICE_CLASS_HUB                0x09
#define USB_DEVICE_CLASS_VENDOR_SPECIFIC    0xFF

//
// USB defined Feature selectors
//

#define USB_FEATURE_ENDPOINT_STALL          0x0000
#define USB_FEATURE_REMOTE_WAKEUP           0x0001
#define USB_FEATURE_POWER_D0                0x0002
#define USB_FEATURE_POWER_D1                0x0003
#define USB_FEATURE_POWER_D2                0x0004
#define USB_FEATURE_POWER_D3                0x0005

typedef struct _USB_DEVICE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;

    USHORT idVendor;
    USHORT idProduct;
    USHORT bcdDevice;
    UCHAR iManufacturer;
    UCHAR iProduct;
    UCHAR iSerialNumber;
    UCHAR bNumConfigurations;
} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;

//
// values for bmAttributes Field in
// USB_CONFIGURATION_DESCRIPTOR
//

#define BUS_POWERED                           0x80
#define SELF_POWERED                          0x40
#define REMOTE_WAKEUP                         0x20

typedef struct _USB_CONFIGURATION_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT wTotalLength;
    UCHAR bNumInterfaces;
    UCHAR bConfigurationValue;
    UCHAR iConfiguration;
    UCHAR bmAttributes;
    UCHAR MaxPower;
} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;

typedef struct _USB_INTERFACE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bInterfaceNumber;
    UCHAR bAlternateSetting;
    UCHAR bNumEndpoints;
    UCHAR bInterfaceClass;
    UCHAR bInterfaceSubClass;
    UCHAR bInterfaceProtocol;
    UCHAR iInterface;
} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;

typedef struct _USB_STRING_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    WCHAR bString[1];
} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;

typedef struct _USB_INTERFACE_ASSOCIATION_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bFirstInterface;
    UCHAR bInterfaceCount;
    UCHAR bFunctionClass;
    UCHAR bFunctionSubClass;
    UCHAR bFunctionProtocol;
    UCHAR iFunction;    
}USB_INTERFACE_ASSOCIATION_DESCRIPTOR,*PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR;
//
// USB power descriptor added to core specification
//

#define USB_SUPPORT_D0_COMMAND      0x01
#define USB_SUPPORT_D1_COMMAND      0x02
#define USB_SUPPORT_D2_COMMAND      0x04
#define USB_SUPPORT_D3_COMMAND      0x08

#define USB_SUPPORT_D1_WAKEUP       0x10
#define USB_SUPPORT_D2_WAKEUP       0x20


typedef struct _USB_POWER_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bCapabilitiesFlags;
    USHORT EventNotification;
    USHORT D1LatencyTime;
    USHORT D2LatencyTime;
    USHORT D3LatencyTime;
    UCHAR PowerUnit;
    USHORT D0PowerConsumption;
    USHORT D1PowerConsumption;
    USHORT D2PowerConsumption;
} USB_POWER_DESCRIPTOR, *PUSB_POWER_DESCRIPTOR;


typedef struct _USB_COMMON_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
} USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;


//
// Standard USB HUB definitions
//
// See Chapter 11
//

typedef struct _USB_HUB_DESCRIPTOR {
    UCHAR        bDescriptorLength;      // Length of this descriptor
    UCHAR        bDescriptorType;        // Hub configuration type
    UCHAR        bNumberOfPorts;         // number of ports on this hub
    USHORT       wHubCharacteristics;    // Hub Charateristics
    UCHAR        bPowerOnToPowerGood;    // port power on till power good in 2ms
    UCHAR        bHubControlCurrent;     // max current in mA
    //
    // room for 255 ports power control and removable bitmask
    UCHAR        bRemoveAndPowerMask[64];
} USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;


#include <POPPACK.H>


#endif   /* __USB100_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\urlmon.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* at Tue Sep 16 22:27:55 2008
 */
/* Compiler settings for ..\urlmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlmon_h__
#define __urlmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistMoniker_FWD_DEFINED__
#define __IPersistMoniker_FWD_DEFINED__
typedef interface IPersistMoniker IPersistMoniker;
#endif 	/* __IPersistMoniker_FWD_DEFINED__ */


#ifndef __IMonikerProp_FWD_DEFINED__
#define __IMonikerProp_FWD_DEFINED__
typedef interface IMonikerProp IMonikerProp;
#endif 	/* __IMonikerProp_FWD_DEFINED__ */


#ifndef __IBindProtocol_FWD_DEFINED__
#define __IBindProtocol_FWD_DEFINED__
typedef interface IBindProtocol IBindProtocol;
#endif 	/* __IBindProtocol_FWD_DEFINED__ */


#ifndef __IBinding_FWD_DEFINED__
#define __IBinding_FWD_DEFINED__
typedef interface IBinding IBinding;
#endif 	/* __IBinding_FWD_DEFINED__ */


#ifndef __IBindStatusCallback_FWD_DEFINED__
#define __IBindStatusCallback_FWD_DEFINED__
typedef interface IBindStatusCallback IBindStatusCallback;
#endif 	/* __IBindStatusCallback_FWD_DEFINED__ */


#ifndef __IAuthenticate_FWD_DEFINED__
#define __IAuthenticate_FWD_DEFINED__
typedef interface IAuthenticate IAuthenticate;
#endif 	/* __IAuthenticate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate_FWD_DEFINED__
#define __IHttpNegotiate_FWD_DEFINED__
typedef interface IHttpNegotiate IHttpNegotiate;
#endif 	/* __IHttpNegotiate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate2_FWD_DEFINED__
#define __IHttpNegotiate2_FWD_DEFINED__
typedef interface IHttpNegotiate2 IHttpNegotiate2;
#endif 	/* __IHttpNegotiate2_FWD_DEFINED__ */


#ifndef __IWinInetFileStream_FWD_DEFINED__
#define __IWinInetFileStream_FWD_DEFINED__
typedef interface IWinInetFileStream IWinInetFileStream;
#endif 	/* __IWinInetFileStream_FWD_DEFINED__ */


#ifndef __IWindowForBindingUI_FWD_DEFINED__
#define __IWindowForBindingUI_FWD_DEFINED__
typedef interface IWindowForBindingUI IWindowForBindingUI;
#endif 	/* __IWindowForBindingUI_FWD_DEFINED__ */


#ifndef __ICodeInstall_FWD_DEFINED__
#define __ICodeInstall_FWD_DEFINED__
typedef interface ICodeInstall ICodeInstall;
#endif 	/* __ICodeInstall_FWD_DEFINED__ */


#ifndef __IUri_FWD_DEFINED__
#define __IUri_FWD_DEFINED__
typedef interface IUri IUri;
#endif 	/* __IUri_FWD_DEFINED__ */


#ifndef __IUriContainer_FWD_DEFINED__
#define __IUriContainer_FWD_DEFINED__
typedef interface IUriContainer IUriContainer;
#endif 	/* __IUriContainer_FWD_DEFINED__ */


#ifndef __IUriBuilder_FWD_DEFINED__
#define __IUriBuilder_FWD_DEFINED__
typedef interface IUriBuilder IUriBuilder;
#endif 	/* __IUriBuilder_FWD_DEFINED__ */


#ifndef __IUriBuilderFactory_FWD_DEFINED__
#define __IUriBuilderFactory_FWD_DEFINED__
typedef interface IUriBuilderFactory IUriBuilderFactory;
#endif 	/* __IUriBuilderFactory_FWD_DEFINED__ */


#ifndef __IWinInetInfo_FWD_DEFINED__
#define __IWinInetInfo_FWD_DEFINED__
typedef interface IWinInetInfo IWinInetInfo;
#endif 	/* __IWinInetInfo_FWD_DEFINED__ */


#ifndef __IHttpSecurity_FWD_DEFINED__
#define __IHttpSecurity_FWD_DEFINED__
typedef interface IHttpSecurity IHttpSecurity;
#endif 	/* __IHttpSecurity_FWD_DEFINED__ */


#ifndef __IWinInetHttpInfo_FWD_DEFINED__
#define __IWinInetHttpInfo_FWD_DEFINED__
typedef interface IWinInetHttpInfo IWinInetHttpInfo;
#endif 	/* __IWinInetHttpInfo_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints_FWD_DEFINED__
#define __IWinInetCacheHints_FWD_DEFINED__
typedef interface IWinInetCacheHints IWinInetCacheHints;
#endif 	/* __IWinInetCacheHints_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints2_FWD_DEFINED__
#define __IWinInetCacheHints2_FWD_DEFINED__
typedef interface IWinInetCacheHints2 IWinInetCacheHints2;
#endif 	/* __IWinInetCacheHints2_FWD_DEFINED__ */


#ifndef __IProxyInfo_FWD_DEFINED__
#define __IProxyInfo_FWD_DEFINED__
typedef interface IProxyInfo IProxyInfo;
#endif 	/* __IProxyInfo_FWD_DEFINED__ */


#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IInternet_FWD_DEFINED__
#define __IInternet_FWD_DEFINED__
typedef interface IInternet IInternet;
#endif 	/* __IInternet_FWD_DEFINED__ */


#ifndef __IInternetBindInfo_FWD_DEFINED__
#define __IInternetBindInfo_FWD_DEFINED__
typedef interface IInternetBindInfo IInternetBindInfo;
#endif 	/* __IInternetBindInfo_FWD_DEFINED__ */


#ifndef __IInternetProtocolRoot_FWD_DEFINED__
#define __IInternetProtocolRoot_FWD_DEFINED__
typedef interface IInternetProtocolRoot IInternetProtocolRoot;
#endif 	/* __IInternetProtocolRoot_FWD_DEFINED__ */


#ifndef __IInternetProtocol_FWD_DEFINED__
#define __IInternetProtocol_FWD_DEFINED__
typedef interface IInternetProtocol IInternetProtocol;
#endif 	/* __IInternetProtocol_FWD_DEFINED__ */


#ifndef __IInternetProtocolEx_FWD_DEFINED__
#define __IInternetProtocolEx_FWD_DEFINED__
typedef interface IInternetProtocolEx IInternetProtocolEx;
#endif 	/* __IInternetProtocolEx_FWD_DEFINED__ */


#ifndef __IInternetProtocolSink_FWD_DEFINED__
#define __IInternetProtocolSink_FWD_DEFINED__
typedef interface IInternetProtocolSink IInternetProtocolSink;
#endif 	/* __IInternetProtocolSink_FWD_DEFINED__ */


#ifndef __IInternetProtocolSinkStackable_FWD_DEFINED__
#define __IInternetProtocolSinkStackable_FWD_DEFINED__
typedef interface IInternetProtocolSinkStackable IInternetProtocolSinkStackable;
#endif 	/* __IInternetProtocolSinkStackable_FWD_DEFINED__ */


#ifndef __IInternetSession_FWD_DEFINED__
#define __IInternetSession_FWD_DEFINED__
typedef interface IInternetSession IInternetSession;
#endif 	/* __IInternetSession_FWD_DEFINED__ */


#ifndef __IInternetThreadSwitch_FWD_DEFINED__
#define __IInternetThreadSwitch_FWD_DEFINED__
typedef interface IInternetThreadSwitch IInternetThreadSwitch;
#endif 	/* __IInternetThreadSwitch_FWD_DEFINED__ */


#ifndef __IInternetPriority_FWD_DEFINED__
#define __IInternetPriority_FWD_DEFINED__
typedef interface IInternetPriority IInternetPriority;
#endif 	/* __IInternetPriority_FWD_DEFINED__ */


#ifndef __IInternetProtocolInfo_FWD_DEFINED__
#define __IInternetProtocolInfo_FWD_DEFINED__
typedef interface IInternetProtocolInfo IInternetProtocolInfo;
#endif 	/* __IInternetProtocolInfo_FWD_DEFINED__ */


#ifndef __IInternetSecurityMgrSite_FWD_DEFINED__
#define __IInternetSecurityMgrSite_FWD_DEFINED__
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
#endif 	/* __IInternetSecurityMgrSite_FWD_DEFINED__ */


#ifndef __IInternetSecurityManager_FWD_DEFINED__
#define __IInternetSecurityManager_FWD_DEFINED__
typedef interface IInternetSecurityManager IInternetSecurityManager;
#endif 	/* __IInternetSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx_FWD_DEFINED__
#define __IInternetSecurityManagerEx_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx IInternetSecurityManagerEx;
#endif 	/* __IInternetSecurityManagerEx_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx2_FWD_DEFINED__
#define __IInternetSecurityManagerEx2_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx2 IInternetSecurityManagerEx2;
#endif 	/* __IInternetSecurityManagerEx2_FWD_DEFINED__ */


#ifndef __IZoneIdentifier_FWD_DEFINED__
#define __IZoneIdentifier_FWD_DEFINED__
typedef interface IZoneIdentifier IZoneIdentifier;
#endif 	/* __IZoneIdentifier_FWD_DEFINED__ */


#ifndef __IInternetHostSecurityManager_FWD_DEFINED__
#define __IInternetHostSecurityManager_FWD_DEFINED__
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif 	/* __IInternetHostSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManager_FWD_DEFINED__
#define __IInternetZoneManager_FWD_DEFINED__
typedef interface IInternetZoneManager IInternetZoneManager;
#endif 	/* __IInternetZoneManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx_FWD_DEFINED__
#define __IInternetZoneManagerEx_FWD_DEFINED__
typedef interface IInternetZoneManagerEx IInternetZoneManagerEx;
#endif 	/* __IInternetZoneManagerEx_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx2_FWD_DEFINED__
#define __IInternetZoneManagerEx2_FWD_DEFINED__
typedef interface IInternetZoneManagerEx2 IInternetZoneManagerEx2;
#endif 	/* __IInternetZoneManagerEx2_FWD_DEFINED__ */


#ifndef __ISoftDistExt_FWD_DEFINED__
#define __ISoftDistExt_FWD_DEFINED__
typedef interface ISoftDistExt ISoftDistExt;
#endif 	/* __ISoftDistExt_FWD_DEFINED__ */


#ifndef __ICatalogFileInfo_FWD_DEFINED__
#define __ICatalogFileInfo_FWD_DEFINED__
typedef interface ICatalogFileInfo ICatalogFileInfo;
#endif 	/* __ICatalogFileInfo_FWD_DEFINED__ */


#ifndef __IDataFilter_FWD_DEFINED__
#define __IDataFilter_FWD_DEFINED__
typedef interface IDataFilter IDataFilter;
#endif 	/* __IDataFilter_FWD_DEFINED__ */


#ifndef __IEncodingFilterFactory_FWD_DEFINED__
#define __IEncodingFilterFactory_FWD_DEFINED__
typedef interface IEncodingFilterFactory IEncodingFilterFactory;
#endif 	/* __IEncodingFilterFactory_FWD_DEFINED__ */


#ifndef __IWrappedProtocol_FWD_DEFINED__
#define __IWrappedProtocol_FWD_DEFINED__
typedef interface IWrappedProtocol IWrappedProtocol;
#endif 	/* __IWrappedProtocol_FWD_DEFINED__ */


#ifndef __IWinInetCacheAccess_FWD_DEFINED__
#define __IWinInetCacheAccess_FWD_DEFINED__
typedef interface IWinInetCacheAccess IWinInetCacheAccess;
#endif 	/* __IWinInetCacheAccess_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "servprov.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_urlmon_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlMon.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// URL Moniker Interfaces.












// Side-by-Side clsid
EXTERN_C const IID CLSID_SBS_StdURLMoniker;  
EXTERN_C const IID CLSID_SBS_HttpProtocol;   
EXTERN_C const IID CLSID_SBS_FtpProtocol;    
EXTERN_C const IID CLSID_SBS_GopherProtocol; 
EXTERN_C const IID CLSID_SBS_HttpSProtocol;  
EXTERN_C const IID CLSID_SBS_FileProtocol;   
EXTERN_C const IID CLSID_SBS_MkProtocol;     
EXTERN_C const IID CLSID_SBS_UrlMkBindCtx;   
EXTERN_C const IID CLSID_SBS_SoftDistExt;  
EXTERN_C const IID CLSID_SBS_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_SBS_DeCompMimeFilter;     
EXTERN_C const IID CLSID_SBS_CdlProtocol;          
EXTERN_C const IID CLSID_SBS_ClassInstallFilter;   
EXTERN_C const IID CLSID_SBS_InternetSecurityManager;  
EXTERN_C const IID CLSID_SBS_InternetZoneManager;  
// END Side-by-Side clsid
// These are for backwards compatibility with previous URLMON versions
#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION
#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE
#define BINDF_NOCOPYDATA BINDF_PULLDATA
#define INVALID_P_ROOT_SECURITY_ID ((BYTE*)-1)
#define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP
EXTERN_C const IID IID_IAsyncMoniker;    
EXTERN_C const IID CLSID_StdURLMoniker;  
EXTERN_C const IID CLSID_HttpProtocol;   
EXTERN_C const IID CLSID_FtpProtocol;    
EXTERN_C const IID CLSID_GopherProtocol; 
EXTERN_C const IID CLSID_HttpSProtocol;  
EXTERN_C const IID CLSID_FileProtocol;   
EXTERN_C const IID CLSID_MkProtocol;     
EXTERN_C const IID CLSID_StdURLProtocol; 
EXTERN_C const IID CLSID_UrlMkBindCtx;   
EXTERN_C const IID CLSID_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_DeCompMimeFilter;     
EXTERN_C const IID CLSID_CdlProtocol;          
EXTERN_C const IID CLSID_ClassInstallFilter;   
EXTERN_C const IID IID_IAsyncBindCtx;    
 
#define SZ_URLCONTEXT           OLESTR("URL Context")
#define SZ_ASYNC_CALLEE         OLESTR("AsyncCallee")
#define MKSYS_URLMONIKER         6            
#define URL_MK_LEGACY            0            
#define URL_MK_UNIFORM           1            
#define URL_MK_NO_CANONICALIZE   2            
 
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags);             
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID);                                           
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CreateURLMonikerEx2(LPMONIKER pMkCtx, IUri* pUri, LPMONIKER FAR * ppmk, DWORD dwFlags);             
#endif
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved);                                                     
STDAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk);                                           
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);                      
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid); 
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);                               
STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv);
STDAPI FaultInIEFeature( HWND hWnd,
            __in uCLSSPEC *pClassSpec,
            __inout_opt QUERYCONTEXT *pQuery, DWORD dwFlags);                                           
STDAPI GetComponentIDFromCLSSPEC(__in uCLSSPEC *pClassspec,
            __deref_out LPSTR * ppszComponentID);                                                      
// flags for FaultInIEFeature
#define FIEF_FLAG_FORCE_JITUI               0x1     // force JIT ui even if
                                                 // previoulsy rejected by 
                                                 // user in this session or
                                                 // marked as Never Ask Again
#define FIEF_FLAG_PEEK                      0x2     // just peek, don't faultin
#define FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK        0x4     // force JIT without checking local version
 
//helper apis                                                                               
STDAPI IsAsyncMoniker(IMoniker* pmk);                                                       
STDAPI CreateURLBinding(LPCWSTR lpszUrl, __in IBindCtx *pbc, __deref_inout IBinding **ppBdg);
 
STDAPI RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);            
STDAPI FindMediaType(LPCSTR rgszTypes, __out CLIPFORMAT* rgcfTypes);                                       
STDAPI CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc); 
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc);                            
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved);    
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID *pclsID, DWORD reserved);                          
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);       
STDAPI UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD *pdwBufferLength, DWORD dwReserved);       
STDAPI FindMimeFromData(                                                                                                                  
    __in_opt                LPBC    pBC,                   // bind context - can be NULL                                                 
    __in_opt                LPCWSTR pwzUrl,                // url - can be null                                                          
    __in_bcount_opt(cbSize) LPVOID  pBuffer,               // buffer with data to sniff - can be null (pwzUrl must be valid)             
                            DWORD   cbSize,                // size of buffer                                                             
    __in_opt                LPCWSTR pwzMimeProposed,       // proposed mime if - can be null                                             
                            DWORD   dwMimeFlags,           // will be defined                                                            
    __deref_out             LPWSTR  *ppwzMimeOut,          // the suggested mime                                                         
    __reserved              DWORD   dwReserved);           // must be 0                                                                  
#define     FMFD_DEFAULT             0x00000000 
#define     FMFD_URLASFILENAME       0x00000001 
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define     FMFD_ENABLEMIMESNIFFING  0x00000002 
#define     FMFD_IGNOREMIMETEXTPLAIN  0x00000004 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define     FMFD_SERVERMIME   0x00000008 
STDAPI ObtainUserAgentString(                           
                                        DWORD dwOption, 
    __out_ecount_part(*cbSize, *cbSize) LPSTR pszUAOut, 
    __inout                             DWORD *cbSize); 
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);    
STDAPI CompatFlagsFromClsid(CLSID *pclsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);             
 
// URLMON-specific defines for UrlMkSetSessionOption() above
#define URLMON_OPTION_USERAGENT           0x10000001
#define URLMON_OPTION_USERAGENT_REFRESH   0x10000002
#define URLMON_OPTION_URL_ENCODING        0x10000004
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLMON_OPTION_USE_BINDSTRINGCREDS 0x10000008
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS 0x10000010
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
 
#define CF_NULL                 0                                  
#define CFSTR_MIME_NULL         NULL                               
#define CFSTR_MIME_TEXT         (TEXT("text/plain"))             
#define CFSTR_MIME_RICHTEXT     (TEXT("text/richtext"))          
#define CFSTR_MIME_X_BITMAP     (TEXT("image/x-xbitmap"))        
#define CFSTR_MIME_POSTSCRIPT   (TEXT("application/postscript")) 
#define CFSTR_MIME_AIFF         (TEXT("audio/aiff"))             
#define CFSTR_MIME_BASICAUDIO   (TEXT("audio/basic"))            
#define CFSTR_MIME_WAV          (TEXT("audio/wav"))              
#define CFSTR_MIME_X_WAV        (TEXT("audio/x-wav"))            
#define CFSTR_MIME_GIF          (TEXT("image/gif"))              
#define CFSTR_MIME_PJPEG        (TEXT("image/pjpeg"))            
#define CFSTR_MIME_JPEG         (TEXT("image/jpeg"))             
#define CFSTR_MIME_TIFF         (TEXT("image/tiff"))             
#define CFSTR_MIME_X_PNG        (TEXT("image/x-png"))            
#define CFSTR_MIME_BMP          (TEXT("image/bmp"))              
#define CFSTR_MIME_X_ART        (TEXT("image/x-jg"))             
#define CFSTR_MIME_X_EMF        (TEXT("image/x-emf"))            
#define CFSTR_MIME_X_WMF        (TEXT("image/x-wmf"))            
#define CFSTR_MIME_AVI          (TEXT("video/avi"))              
#define CFSTR_MIME_MPEG         (TEXT("video/mpeg"))             
#define CFSTR_MIME_FRACTALS     (TEXT("application/fractals"))   
#define CFSTR_MIME_RAWDATA      (TEXT("application/octet-stream"))
#define CFSTR_MIME_RAWDATASTRM  (TEXT("application/octet-stream"))
#define CFSTR_MIME_PDF          (TEXT("application/pdf"))        
#define CFSTR_MIME_HTA          (TEXT("application/hta"))        
#define CFSTR_MIME_X_AIFF       (TEXT("audio/x-aiff"))           
#define CFSTR_MIME_X_REALAUDIO  (TEXT("audio/x-pn-realaudio"))   
#define CFSTR_MIME_XBM          (TEXT("image/xbm"))              
#define CFSTR_MIME_QUICKTIME    (TEXT("video/quicktime"))        
#define CFSTR_MIME_X_MSVIDEO    (TEXT("video/x-msvideo"))        
#define CFSTR_MIME_X_SGI_MOVIE  (TEXT("video/x-sgi-movie"))      
#define CFSTR_MIME_HTML         (TEXT("text/html"))              
#define CFSTR_MIME_XML          (TEXT("text/xml"))               
 
// MessageId: MK_S_ASYNCHRONOUS                                              
// MessageText: Operation is successful, but will complete asynchronously.   
//                                                                           
#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  
#ifndef S_ASYNCHRONOUS                                                       
#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               
#endif                                                                       
                                                                             
#ifndef E_PENDING                                                            
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             
#endif                                                                       
                                                                             
//                                                                           
//                                                                           
// WinINet and protocol specific errors are mapped to one of the following   
// error which are returned in IBSC::OnStopBinding                           
//                                                                           
//                                                                           
// Note: FACILITY C is split into ranges of 1k                               
// C0000 - C03FF  INET_E_ (URLMON's original hresult)                        
// C0400 - C07FF  INET_E_CLIENT_xxx                                          
// C0800 - C0BFF  INET_E_SERVER_xxx                                          
// C0C00 - C0FFF  INET_E_????                                                
// C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                    
#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      
#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      
#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      
#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      
#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      
#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      
#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      
#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      
#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      
#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      
#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      
#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      
#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      
#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      
#define INET_E_INVALID_CERTIFICATE       _HRESULT_TYPEDEF_(0x800C0019L)      
#define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)      
#define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)      
#define INET_E_CANNOT_LOCK_REQUEST       _HRESULT_TYPEDEF_(0x800C0016L)      
#define INET_E_USE_EXTEND_BINDING        _HRESULT_TYPEDEF_(0x800C0017L)      
#define INET_E_TERMINATED_BIND           _HRESULT_TYPEDEF_(0x800C0018L)      
#define INET_E_ERROR_FIRST               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_CODE_DOWNLOAD_DECLINED    _HRESULT_TYPEDEF_(0x800C0100L)      
#define INET_E_RESULT_DISPATCHED         _HRESULT_TYPEDEF_(0x800C0200L)      
#define INET_E_CANNOT_REPLACE_SFP_FILE   _HRESULT_TYPEDEF_(0x800C0300L)      
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_SUPPRESSED   _HRESULT_TYPEDEF_(0x800C0400L)      
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY   _HRESULT_TYPEDEF_(0x800C0500L)      
#define INET_E_ERROR_LAST                INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY
#ifndef _LPPERSISTMONIKER_DEFINED
#define _LPPERSISTMONIKER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec;

#ifndef __IPersistMoniker_INTERFACE_DEFINED__
#define __IPersistMoniker_INTERFACE_DEFINED__

/* interface IPersistMoniker */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPersistMoniker *LPPERSISTMONIKER;


EXTERN_C const IID IID_IPersistMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c9-baf9-11ce-8c82-00aa004ba90b")
    IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCompleted( 
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurMoniker( 
            /* [out] */ IMoniker **ppimkName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistMoniker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistMoniker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistMoniker * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistMoniker * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistMoniker * This,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( STDMETHODCALLTYPE *SaveCompleted )( 
            IPersistMoniker * This,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurMoniker )( 
            IPersistMoniker * This,
            /* [out] */ IMoniker **ppimkName);
        
        END_INTERFACE
    } IPersistMonikerVtbl;

    interface IPersistMoniker
    {
        CONST_VTBL struct IPersistMonikerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMoniker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistMoniker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistMoniker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistMoniker_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 

#define IPersistMoniker_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define IPersistMoniker_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    ( (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode) ) 

#define IPersistMoniker_Save(This,pimkName,pbc,fRemember)	\
    ( (This)->lpVtbl -> Save(This,pimkName,pbc,fRemember) ) 

#define IPersistMoniker_SaveCompleted(This,pimkName,pibc)	\
    ( (This)->lpVtbl -> SaveCompleted(This,pimkName,pibc) ) 

#define IPersistMoniker_GetCurMoniker(This,ppimkName)	\
    ( (This)->lpVtbl -> GetCurMoniker(This,ppimkName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistMoniker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPMONIKERPROP_DEFINED
#define _LPMONIKERPROP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec;

#ifndef __IMonikerProp_INTERFACE_DEFINED__
#define __IMonikerProp_INTERFACE_DEFINED__

/* interface IMonikerProp */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IMonikerProp *LPMONIKERPROP;

typedef /* [public][public] */ 
enum __MIDL_IMonikerProp_0001
    {	MIMETYPEPROP	= 0,
	USE_SRC_URL	= 0x1,
	CLASSIDPROP	= 0x2,
	TRUSTEDDOWNLOADPROP	= 0x3,
	POPUPLEVELPROP	= 0x4
    } 	MONIKERPROPERTY;


EXTERN_C const IID IID_IMonikerProp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5ca5f7f-1847-4d87-9c5b-918509f7511d")
    IMonikerProp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ LPCWSTR val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonikerPropVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMonikerProp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMonikerProp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMonikerProp * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutProperty )( 
            IMonikerProp * This,
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ LPCWSTR val);
        
        END_INTERFACE
    } IMonikerPropVtbl;

    interface IMonikerProp
    {
        CONST_VTBL struct IMonikerPropVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonikerProp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMonikerProp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMonikerProp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMonikerProp_PutProperty(This,mkp,val)	\
    ( (This)->lpVtbl -> PutProperty(This,mkp,val) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMonikerProp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPBINDPROTOCOL_DEFINED
#define _LPBINDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec;

#ifndef __IBindProtocol_INTERFACE_DEFINED__
#define __IBindProtocol_INTERFACE_DEFINED__

/* interface IBindProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IBindProtocol *LPBINDPROTOCOL;


EXTERN_C const IID IID_IBindProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9cd-baf9-11ce-8c82-00aa004ba90b")
    IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IBindProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb);
        
        END_INTERFACE
    } IBindProtocolVtbl;

    interface IBindProtocol
    {
        CONST_VTBL struct IBindProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindProtocol_CreateBinding(This,szUrl,pbc,ppb)	\
    ( (This)->lpVtbl -> CreateBinding(This,szUrl,pbc,ppb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBindProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPBINDING_DEFINED
#define _LPBINDING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec;

#ifndef __IBinding_INTERFACE_DEFINED__
#define __IBinding_INTERFACE_DEFINED__

/* interface IBinding */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBinding *LPBINDING;


EXTERN_C const IID IID_IBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c0-baf9-11ce-8c82-00aa004ba90b")
    IBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IBinding * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBinding * This,
            /* [out] */ LONG *pnPriority);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindResult )( 
            IBinding * This,
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IBindingVtbl;

    interface IBinding
    {
        CONST_VTBL struct IBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBinding_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IBinding_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IBinding_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IBinding_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IBinding_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)	\
    ( (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_RemoteGetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBinding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPBINDSTATUSCALLBACK_DEFINED
#define _LPBINDSTATUSCALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec;

#ifndef __IBindStatusCallback_INTERFACE_DEFINED__
#define __IBindStatusCallback_INTERFACE_DEFINED__

/* interface IBindStatusCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBindStatusCallback *LPBINDSTATUSCALLBACK;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0001
    {	BINDVERB_GET	= 0,
	BINDVERB_POST	= 0x1,
	BINDVERB_PUT	= 0x2,
	BINDVERB_CUSTOM	= 0x3
    } 	BINDVERB;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0002
    {	BINDINFOF_URLENCODESTGMEDDATA	= 0x1,
	BINDINFOF_URLENCODEDEXTRAINFO	= 0x2
    } 	BINDINFOF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0003
    {	BINDF_ASYNCHRONOUS	= 0x1,
	BINDF_ASYNCSTORAGE	= 0x2,
	BINDF_NOPROGRESSIVERENDERING	= 0x4,
	BINDF_OFFLINEOPERATION	= 0x8,
	BINDF_GETNEWESTVERSION	= 0x10,
	BINDF_NOWRITECACHE	= 0x20,
	BINDF_NEEDFILE	= 0x40,
	BINDF_PULLDATA	= 0x80,
	BINDF_IGNORESECURITYPROBLEM	= 0x100,
	BINDF_RESYNCHRONIZE	= 0x200,
	BINDF_HYPERLINK	= 0x400,
	BINDF_NO_UI	= 0x800,
	BINDF_SILENTOPERATION	= 0x1000,
	BINDF_PRAGMA_NO_CACHE	= 0x2000,
	BINDF_GETCLASSOBJECT	= 0x4000,
	BINDF_RESERVED_1	= 0x8000,
	BINDF_FREE_THREADED	= 0x10000,
	BINDF_DIRECT_READ	= 0x20000,
	BINDF_FORMS_SUBMIT	= 0x40000,
	BINDF_GETFROMCACHE_IF_NET_FAIL	= 0x80000,
	BINDF_FROMURLMON	= 0x100000,
	BINDF_FWD_BACK	= 0x200000,
	BINDF_PREFERDEFAULTHANDLER	= 0x400000,
	BINDF_ENFORCERESTRICTED	= 0x800000
    } 	BINDF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0004
    {	URL_ENCODING_NONE	= 0,
	URL_ENCODING_ENABLE_UTF8	= 0x10000000,
	URL_ENCODING_DISABLE_UTF8	= 0x20000000
    } 	URL_ENCODING;

typedef struct _tagBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	BINDINFO;

typedef struct _REMSECURITY_ATTRIBUTES
    {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
    } 	REMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *PREMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *LPREMSECURITY_ATTRIBUTES;

typedef struct _tagRemBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	RemBINDINFO;

typedef struct tagRemFORMATETC
    {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    } 	RemFORMATETC;

typedef struct tagRemFORMATETC *LPREMFORMATETC;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0005
    {	BINDINFO_OPTIONS_WININETFLAG	= 0x10000,
	BINDINFO_OPTIONS_ENABLE_UTF8	= 0x20000,
	BINDINFO_OPTIONS_DISABLE_UTF8	= 0x40000,
	BINDINFO_OPTIONS_USE_IE_ENCODING	= 0x80000,
	BINDINFO_OPTIONS_BINDTOOBJECT	= 0x100000,
	BINDINFO_OPTIONS_SECURITYOPTOUT	= 0x200000,
	BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN	= 0x400000,
	BINDINFO_OPTIONS_USEBINDSTRINGCREDS	= 0x800000,
	BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS	= 0x1000000,
	BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE	= 0x2000000,
	BINDINFO_WPC_DOWNLOADBLOCKED	= 0x8000000,
	BINDINFO_WPC_LOGGING_ENABLED	= 0x10000000,
	BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS	= 0x40000000,
	BINDINFO_OPTIONS_SHDOCVW_NAVIGATE	= 0x80000000
    } 	BINDINFO_OPTIONS;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0006
    {	BSCF_FIRSTDATANOTIFICATION	= 0x1,
	BSCF_INTERMEDIATEDATANOTIFICATION	= 0x2,
	BSCF_LASTDATANOTIFICATION	= 0x4,
	BSCF_DATAFULLYAVAILABLE	= 0x8,
	BSCF_AVAILABLEDATASIZEUNKNOWN	= 0x10
    } 	BSCF;

typedef 
enum tagBINDSTATUS
    {	BINDSTATUS_FINDINGRESOURCE	= 1,
	BINDSTATUS_CONNECTING	= ( BINDSTATUS_FINDINGRESOURCE + 1 ) ,
	BINDSTATUS_REDIRECTING	= ( BINDSTATUS_CONNECTING + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADDATA	= ( BINDSTATUS_REDIRECTING + 1 ) ,
	BINDSTATUS_DOWNLOADINGDATA	= ( BINDSTATUS_BEGINDOWNLOADDATA + 1 ) ,
	BINDSTATUS_ENDDOWNLOADDATA	= ( BINDSTATUS_DOWNLOADINGDATA + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADCOMPONENTS	= ( BINDSTATUS_ENDDOWNLOADDATA + 1 ) ,
	BINDSTATUS_INSTALLINGCOMPONENTS	= ( BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_ENDDOWNLOADCOMPONENTS	= ( BINDSTATUS_INSTALLINGCOMPONENTS + 1 ) ,
	BINDSTATUS_USINGCACHEDCOPY	= ( BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_SENDINGREQUEST	= ( BINDSTATUS_USINGCACHEDCOPY + 1 ) ,
	BINDSTATUS_CLASSIDAVAILABLE	= ( BINDSTATUS_SENDINGREQUEST + 1 ) ,
	BINDSTATUS_MIMETYPEAVAILABLE	= ( BINDSTATUS_CLASSIDAVAILABLE + 1 ) ,
	BINDSTATUS_CACHEFILENAMEAVAILABLE	= ( BINDSTATUS_MIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_BEGINSYNCOPERATION	= ( BINDSTATUS_CACHEFILENAMEAVAILABLE + 1 ) ,
	BINDSTATUS_ENDSYNCOPERATION	= ( BINDSTATUS_BEGINSYNCOPERATION + 1 ) ,
	BINDSTATUS_BEGINUPLOADDATA	= ( BINDSTATUS_ENDSYNCOPERATION + 1 ) ,
	BINDSTATUS_UPLOADINGDATA	= ( BINDSTATUS_BEGINUPLOADDATA + 1 ) ,
	BINDSTATUS_ENDUPLOADDATA	= ( BINDSTATUS_UPLOADINGDATA + 1 ) ,
	BINDSTATUS_PROTOCOLCLASSID	= ( BINDSTATUS_ENDUPLOADDATA + 1 ) ,
	BINDSTATUS_ENCODING	= ( BINDSTATUS_PROTOCOLCLASSID + 1 ) ,
	BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE	= ( BINDSTATUS_ENCODING + 1 ) ,
	BINDSTATUS_CLASSINSTALLLOCATION	= ( BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_DECODING	= ( BINDSTATUS_CLASSINSTALLLOCATION + 1 ) ,
	BINDSTATUS_LOADINGMIMEHANDLER	= ( BINDSTATUS_DECODING + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONATTACH	= ( BINDSTATUS_LOADINGMIMEHANDLER + 1 ) ,
	BINDSTATUS_FILTERREPORTMIMETYPE	= ( BINDSTATUS_CONTENTDISPOSITIONATTACH + 1 ) ,
	BINDSTATUS_CLSIDCANINSTANTIATE	= ( BINDSTATUS_FILTERREPORTMIMETYPE + 1 ) ,
	BINDSTATUS_IUNKNOWNAVAILABLE	= ( BINDSTATUS_CLSIDCANINSTANTIATE + 1 ) ,
	BINDSTATUS_DIRECTBIND	= ( BINDSTATUS_IUNKNOWNAVAILABLE + 1 ) ,
	BINDSTATUS_RAWMIMETYPE	= ( BINDSTATUS_DIRECTBIND + 1 ) ,
	BINDSTATUS_PROXYDETECTING	= ( BINDSTATUS_RAWMIMETYPE + 1 ) ,
	BINDSTATUS_ACCEPTRANGES	= ( BINDSTATUS_PROXYDETECTING + 1 ) ,
	BINDSTATUS_COOKIE_SENT	= ( BINDSTATUS_ACCEPTRANGES + 1 ) ,
	BINDSTATUS_COMPACT_POLICY_RECEIVED	= ( BINDSTATUS_COOKIE_SENT + 1 ) ,
	BINDSTATUS_COOKIE_SUPPRESSED	= ( BINDSTATUS_COMPACT_POLICY_RECEIVED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_UNKNOWN	= ( BINDSTATUS_COOKIE_SUPPRESSED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_ACCEPT	= ( BINDSTATUS_COOKIE_STATE_UNKNOWN + 1 ) ,
	BINDSTATUS_COOKIE_STATE_REJECT	= ( BINDSTATUS_COOKIE_STATE_ACCEPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_PROMPT	= ( BINDSTATUS_COOKIE_STATE_REJECT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_LEASH	= ( BINDSTATUS_COOKIE_STATE_PROMPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_DOWNGRADE	= ( BINDSTATUS_COOKIE_STATE_LEASH + 1 ) ,
	BINDSTATUS_POLICY_HREF	= ( BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1 ) ,
	BINDSTATUS_P3P_HEADER	= ( BINDSTATUS_POLICY_HREF + 1 ) ,
	BINDSTATUS_SESSION_COOKIE_RECEIVED	= ( BINDSTATUS_P3P_HEADER + 1 ) ,
	BINDSTATUS_PERSISTENT_COOKIE_RECEIVED	= ( BINDSTATUS_SESSION_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_SESSION_COOKIES_ALLOWED	= ( BINDSTATUS_PERSISTENT_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_CACHECONTROL	= ( BINDSTATUS_SESSION_COOKIES_ALLOWED + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONFILENAME	= ( BINDSTATUS_CACHECONTROL + 1 ) ,
	BINDSTATUS_MIMETEXTPLAINMISMATCH	= ( BINDSTATUS_CONTENTDISPOSITIONFILENAME + 1 ) ,
	BINDSTATUS_PUBLISHERAVAILABLE	= ( BINDSTATUS_MIMETEXTPLAINMISMATCH + 1 ) ,
	BINDSTATUS_DISPLAYNAMEAVAILABLE	= ( BINDSTATUS_PUBLISHERAVAILABLE + 1 ) ,
	BINDSTATUS_SSLUX_NAVBLOCKED	= ( BINDSTATUS_DISPLAYNAMEAVAILABLE + 1 ) ,
	BINDSTATUS_SERVER_MIMETYPEAVAILABLE	= ( BINDSTATUS_SSLUX_NAVBLOCKED + 1 ) ,
	BINDSTATUS_SNIFFED_CLASSIDAVAILABLE	= ( BINDSTATUS_SERVER_MIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_SIZEAVAILABLE	= ( BINDSTATUS_SNIFFED_CLASSIDAVAILABLE + 1 ) 
    } 	BINDSTATUS;


EXTERN_C const IID IID_IBindStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c1-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartBinding( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding *pib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DWORD reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStopBinding( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartBinding )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding *pib);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBindStatusCallback * This,
            /* [out] */ LONG *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE *OnLowResource )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IBindStatusCallback * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *OnStopBinding )( 
            IBindStatusCallback * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IBindStatusCallback * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OnDataAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);
        
        END_INTERFACE
    } IBindStatusCallbackVtbl;

    interface IBindStatusCallback
    {
        CONST_VTBL struct IBindStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindStatusCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindStatusCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindStatusCallback_OnStartBinding(This,dwReserved,pib)	\
    ( (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib) ) 

#define IBindStatusCallback_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBindStatusCallback_OnLowResource(This,reserved)	\
    ( (This)->lpVtbl -> OnLowResource(This,reserved) ) 

#define IBindStatusCallback_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText) ) 

#define IBindStatusCallback_OnStopBinding(This,hresult,szError)	\
    ( (This)->lpVtbl -> OnStopBinding(This,hresult,szError) ) 

#define IBindStatusCallback_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IBindStatusCallback_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    ( (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed) ) 

#define IBindStatusCallback_OnObjectAvailable(This,riid,punk)	\
    ( (This)->lpVtbl -> OnObjectAvailable(This,riid,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteGetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteOnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPAUTHENTICATION_DEFINED
#define _LPAUTHENTICATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec;

#ifndef __IAuthenticate_INTERFACE_DEFINED__
#define __IAuthenticate_INTERFACE_DEFINED__

/* interface IAuthenticate */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IAuthenticate *LPAUTHENTICATION;


EXTERN_C const IID IID_IAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d0-baf9-11ce-8c82-00aa004ba90b")
    IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [out] */ HWND *phwnd,
            /* [out] */ LPWSTR *pszUsername,
            /* [out] */ LPWSTR *pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuthenticate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuthenticate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuthenticate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IAuthenticate * This,
            /* [out] */ HWND *phwnd,
            /* [out] */ LPWSTR *pszUsername,
            /* [out] */ LPWSTR *pszPassword);
        
        END_INTERFACE
    } IAuthenticateVtbl;

    interface IAuthenticate
    {
        CONST_VTBL struct IAuthenticateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAuthenticate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAuthenticate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAuthenticate_Authenticate(This,phwnd,pszUsername,pszPassword)	\
    ( (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAuthenticate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE_DEFINED
#define _LPHTTPNEGOTIATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec;

#ifndef __IHttpNegotiate_INTERFACE_DEFINED__
#define __IHttpNegotiate_INTERFACE_DEFINED__

/* interface IHttpNegotiate */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IHttpNegotiate *LPHTTPNEGOTIATE;


EXTERN_C const IID IID_IHttpNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d2-baf9-11ce-8c82-00aa004ba90b")
    IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginningTransaction( 
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate * This,
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders);
        
        END_INTERFACE
    } IHttpNegotiateVtbl;

    interface IHttpNegotiate
    {
        CONST_VTBL struct IHttpNegotiateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0007 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE2_DEFINED
#define _LPHTTPNEGOTIATE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec;

#ifndef __IHttpNegotiate2_INTERFACE_DEFINED__
#define __IHttpNegotiate2_INTERFACE_DEFINED__

/* interface IHttpNegotiate2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IHttpNegotiate2 *LPHTTPNEGOTIATE2;


EXTERN_C const IID IID_IHttpNegotiate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")
    IHttpNegotiate2 : public IHttpNegotiate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRootSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate2 * This,
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate2 * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootSecurityId )( 
            IHttpNegotiate2 * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IHttpNegotiate2Vtbl;

    interface IHttpNegotiate2
    {
        CONST_VTBL struct IHttpNegotiate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate2_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate2_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 


#define IHttpNegotiate2_GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0008 */
/* [local] */ 

#endif
#ifndef _LPWININETFILESTREAM_DEFINED
#define _LPWININETFILESTREAM_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec;

#ifndef __IWinInetFileStream_INTERFACE_DEFINED__
#define __IWinInetFileStream_INTERFACE_DEFINED__

/* interface IWinInetFileStream */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IWinInetFileStream *LPWININETFILESTREAM;


EXTERN_C const IID IID_IWinInetFileStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F134C4B7-B1F8-4e75-B886-74B90943BECB")
    IWinInetFileStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHandleForUnlock( 
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeleteFile( 
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetFileStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetFileStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetFileStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetFileStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHandleForUnlock )( 
            IWinInetFileStream * This,
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeleteFile )( 
            IWinInetFileStream * This,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWinInetFileStreamVtbl;

    interface IWinInetFileStream
    {
        CONST_VTBL struct IWinInetFileStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetFileStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetFileStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetFileStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetFileStream_SetHandleForUnlock(This,hWinInetLockHandle,dwReserved)	\
    ( (This)->lpVtbl -> SetHandleForUnlock(This,hWinInetLockHandle,dwReserved) ) 

#define IWinInetFileStream_SetDeleteFile(This,dwReserved)	\
    ( (This)->lpVtbl -> SetDeleteFile(This,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetFileStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0009 */
/* [local] */ 

#endif
#ifndef _LPWINDOWFORBINDINGUI_DEFINED
#define _LPWINDOWFORBINDINGUI_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec;

#ifndef __IWindowForBindingUI_INTERFACE_DEFINED__
#define __IWindowForBindingUI_INTERFACE_DEFINED__

/* interface IWindowForBindingUI */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWindowForBindingUI *LPWINDOWFORBINDINGUI;


EXTERN_C const IID IID_IWindowForBindingUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d5-bafa-11ce-8c82-00aa004ba90b")
    IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowForBindingUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowForBindingUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowForBindingUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowForBindingUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IWindowForBindingUI * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } IWindowForBindingUIVtbl;

    interface IWindowForBindingUI
    {
        CONST_VTBL struct IWindowForBindingUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowForBindingUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowForBindingUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowForBindingUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowForBindingUI_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowForBindingUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0010 */
/* [local] */ 

#endif
#ifndef _LPCODEINSTALL_DEFINED
#define _LPCODEINSTALL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec;

#ifndef __ICodeInstall_INTERFACE_DEFINED__
#define __ICodeInstall_INTERFACE_DEFINED__

/* interface ICodeInstall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICodeInstall *LPCODEINSTALL;

typedef /* [public] */ 
enum __MIDL_ICodeInstall_0001
    {	CIP_DISK_FULL	= 0,
	CIP_ACCESS_DENIED	= ( CIP_DISK_FULL + 1 ) ,
	CIP_NEWER_VERSION_EXISTS	= ( CIP_ACCESS_DENIED + 1 ) ,
	CIP_OLDER_VERSION_EXISTS	= ( CIP_NEWER_VERSION_EXISTS + 1 ) ,
	CIP_NAME_CONFLICT	= ( CIP_OLDER_VERSION_EXISTS + 1 ) ,
	CIP_TRUST_VERIFICATION_COMPONENT_MISSING	= ( CIP_NAME_CONFLICT + 1 ) ,
	CIP_EXE_SELF_REGISTERATION_TIMEOUT	= ( CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1 ) ,
	CIP_UNSAFE_TO_ABORT	= ( CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1 ) ,
	CIP_NEED_REBOOT	= ( CIP_UNSAFE_TO_ABORT + 1 ) ,
	CIP_NEED_REBOOT_UI_PERMISSION	= ( CIP_NEED_REBOOT + 1 ) 
    } 	CIP_STATUS;


EXTERN_C const IID IID_ICodeInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d1-baf9-11ce-8c82-00aa004ba90b")
    ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCodeInstallProblem( 
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeInstall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeInstall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeInstall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            ICodeInstall * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnCodeInstallProblem )( 
            ICodeInstall * This,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ICodeInstallVtbl;

    interface ICodeInstall
    {
        CONST_VTBL struct ICodeInstallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeInstall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodeInstall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodeInstall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodeInstall_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define ICodeInstall_OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)	\
    ( (This)->lpVtbl -> OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodeInstall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0011 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPUri_DEFINED
#define _LPUri_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec;

#ifndef __IUri_INTERFACE_DEFINED__
#define __IUri_INTERFACE_DEFINED__

/* interface IUri */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL_IUri_0001
    {	Uri_PROPERTY_ABSOLUTE_URI	= 0,
	Uri_PROPERTY_STRING_START	= Uri_PROPERTY_ABSOLUTE_URI,
	Uri_PROPERTY_AUTHORITY	= 1,
	Uri_PROPERTY_DISPLAY_URI	= 2,
	Uri_PROPERTY_DOMAIN	= 3,
	Uri_PROPERTY_EXTENSION	= 4,
	Uri_PROPERTY_FRAGMENT	= 5,
	Uri_PROPERTY_HOST	= 6,
	Uri_PROPERTY_PASSWORD	= 7,
	Uri_PROPERTY_PATH	= 8,
	Uri_PROPERTY_PATH_AND_QUERY	= 9,
	Uri_PROPERTY_QUERY	= 10,
	Uri_PROPERTY_RAW_URI	= 11,
	Uri_PROPERTY_SCHEME_NAME	= 12,
	Uri_PROPERTY_USER_INFO	= 13,
	Uri_PROPERTY_USER_NAME	= 14,
	Uri_PROPERTY_STRING_LAST	= Uri_PROPERTY_USER_NAME,
	Uri_PROPERTY_HOST_TYPE	= 15,
	Uri_PROPERTY_DWORD_START	= Uri_PROPERTY_HOST_TYPE,
	Uri_PROPERTY_PORT	= 16,
	Uri_PROPERTY_SCHEME	= 17,
	Uri_PROPERTY_ZONE	= 18,
	Uri_PROPERTY_DWORD_LAST	= Uri_PROPERTY_ZONE
    } 	Uri_PROPERTY;

typedef /* [public] */ 
enum __MIDL_IUri_0002
    {	Uri_HOST_UNKNOWN	= 0,
	Uri_HOST_DNS	= ( Uri_HOST_UNKNOWN + 1 ) ,
	Uri_HOST_IPV4	= ( Uri_HOST_DNS + 1 ) ,
	Uri_HOST_IPV6	= ( Uri_HOST_IPV4 + 1 ) ,
	Uri_HOST_IDN	= ( Uri_HOST_IPV6 + 1 ) 
    } 	Uri_HOST_TYPE;


EXTERN_C const IID IID_IUri;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39EE748-6A27-4817-A6F2-13914BEF5890")
    IUri : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyBSTR( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyLength( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDWORD( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasProperty( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ BOOL *pfHasProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAbsoluteUri( 
            /* [out] */ BSTR *pbstrAbsoluteUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthority( 
            /* [out] */ BSTR *pbstrAuthority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayUri( 
            /* [out] */ BSTR *pbstrDisplayString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [out] */ BSTR *pbstrDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [out] */ BSTR *pbstrExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [out] */ BSTR *pbstrFragment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHost( 
            /* [out] */ BSTR *pbstrHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [out] */ BSTR *pbstrPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ BSTR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathAndQuery( 
            /* [out] */ BSTR *pbstrPathAndQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ BSTR *pbstrQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRawUri( 
            /* [out] */ BSTR *pbstrRawUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [out] */ BSTR *pbstrSchemeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserInfo( 
            /* [out] */ BSTR *pbstrUserInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [out] */ BSTR *pbstrUserName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostType( 
            /* [out] */ DWORD *pdwHostType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ DWORD *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScheme( 
            /* [out] */ DWORD *pdwScheme) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZone( 
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ LPDWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IUri *pUri,
            /* [out] */ BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUri * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUri * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUri * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyBSTR )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyLength )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDWORD )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *HasProperty )( 
            IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ BOOL *pfHasProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetAbsoluteUri )( 
            IUri * This,
            /* [out] */ BSTR *pbstrAbsoluteUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthority )( 
            IUri * This,
            /* [out] */ BSTR *pbstrAuthority);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayUri )( 
            IUri * This,
            /* [out] */ BSTR *pbstrDisplayString);
        
        HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IUri * This,
            /* [out] */ BSTR *pbstrDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtension )( 
            IUri * This,
            /* [out] */ BSTR *pbstrExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            IUri * This,
            /* [out] */ BSTR *pbstrFragment);
        
        HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            IUri * This,
            /* [out] */ BSTR *pbstrHost);
        
        HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            IUri * This,
            /* [out] */ BSTR *pbstrPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IUri * This,
            /* [out] */ BSTR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetPathAndQuery )( 
            IUri * This,
            /* [out] */ BSTR *pbstrPathAndQuery);
        
        HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IUri * This,
            /* [out] */ BSTR *pbstrQuery);
        
        HRESULT ( STDMETHODCALLTYPE *GetRawUri )( 
            IUri * This,
            /* [out] */ BSTR *pbstrRawUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            IUri * This,
            /* [out] */ BSTR *pbstrSchemeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserInfo )( 
            IUri * This,
            /* [out] */ BSTR *pbstrUserInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IUri * This,
            /* [out] */ BSTR *pbstrUserName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostType )( 
            IUri * This,
            /* [out] */ DWORD *pdwHostType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IUri * This,
            /* [out] */ DWORD *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetScheme )( 
            IUri * This,
            /* [out] */ DWORD *pdwScheme);
        
        HRESULT ( STDMETHODCALLTYPE *GetZone )( 
            IUri * This,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IUri * This,
            /* [out] */ LPDWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IUri * This,
            /* [in] */ IUri *pUri,
            /* [out] */ BOOL *pfEqual);
        
        END_INTERFACE
    } IUriVtbl;

    interface IUri
    {
        CONST_VTBL struct IUriVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUri_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUri_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUri_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUri_GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags) ) 

#define IUri_GetPropertyLength(This,uriProp,pcchProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyLength(This,uriProp,pcchProperty,dwFlags) ) 

#define IUri_GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags) ) 

#define IUri_HasProperty(This,uriProp,pfHasProperty)	\
    ( (This)->lpVtbl -> HasProperty(This,uriProp,pfHasProperty) ) 

#define IUri_GetAbsoluteUri(This,pbstrAbsoluteUri)	\
    ( (This)->lpVtbl -> GetAbsoluteUri(This,pbstrAbsoluteUri) ) 

#define IUri_GetAuthority(This,pbstrAuthority)	\
    ( (This)->lpVtbl -> GetAuthority(This,pbstrAuthority) ) 

#define IUri_GetDisplayUri(This,pbstrDisplayString)	\
    ( (This)->lpVtbl -> GetDisplayUri(This,pbstrDisplayString) ) 

#define IUri_GetDomain(This,pbstrDomain)	\
    ( (This)->lpVtbl -> GetDomain(This,pbstrDomain) ) 

#define IUri_GetExtension(This,pbstrExtension)	\
    ( (This)->lpVtbl -> GetExtension(This,pbstrExtension) ) 

#define IUri_GetFragment(This,pbstrFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pbstrFragment) ) 

#define IUri_GetHost(This,pbstrHost)	\
    ( (This)->lpVtbl -> GetHost(This,pbstrHost) ) 

#define IUri_GetPassword(This,pbstrPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pbstrPassword) ) 

#define IUri_GetPath(This,pbstrPath)	\
    ( (This)->lpVtbl -> GetPath(This,pbstrPath) ) 

#define IUri_GetPathAndQuery(This,pbstrPathAndQuery)	\
    ( (This)->lpVtbl -> GetPathAndQuery(This,pbstrPathAndQuery) ) 

#define IUri_GetQuery(This,pbstrQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pbstrQuery) ) 

#define IUri_GetRawUri(This,pbstrRawUri)	\
    ( (This)->lpVtbl -> GetRawUri(This,pbstrRawUri) ) 

#define IUri_GetSchemeName(This,pbstrSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pbstrSchemeName) ) 

#define IUri_GetUserInfo(This,pbstrUserInfo)	\
    ( (This)->lpVtbl -> GetUserInfo(This,pbstrUserInfo) ) 

#define IUri_GetUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pbstrUserName) ) 

#define IUri_GetHostType(This,pdwHostType)	\
    ( (This)->lpVtbl -> GetHostType(This,pdwHostType) ) 

#define IUri_GetPort(This,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pdwPort) ) 

#define IUri_GetScheme(This,pdwScheme)	\
    ( (This)->lpVtbl -> GetScheme(This,pdwScheme) ) 

#define IUri_GetZone(This,pdwZone)	\
    ( (This)->lpVtbl -> GetZone(This,pdwZone) ) 

#define IUri_GetProperties(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetProperties(This,pdwFlags) ) 

#define IUri_IsEqual(This,pUri,pfEqual)	\
    ( (This)->lpVtbl -> IsEqual(This,pUri,pfEqual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUri_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0012 */
/* [local] */ 

STDAPI CreateUri(__in LPCWSTR pwzURI,
                 __in DWORD dwFlags,
                 __in __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriWithFragment(
                 __in LPCWSTR pwzURI,
                 __in_opt LPCWSTR pwzFragment,        // can be NULL
                 __in DWORD dwFlags,
                 __in __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriFromMultiByteString(
    __in       LPCSTR    pszANSIInputUri,
               DWORD     dwEncodingFlags, // ORed set of Uri_ENCODING_ flags
               DWORD     dwCodePage,
               DWORD     dwCreateFlags,
    __reserved DWORD_PTR dwReserved,   // must be 0
    __out      IUri**    ppUri);

//The following flags are used with IUri::GetProperties.
#define Uri_HAS_ABSOLUTE_URI    (1 << Uri_PROPERTY_ABSOLUTE_URI)
#define Uri_HAS_AUTHORITY       (1 << Uri_PROPERTY_AUTHORITY)
#define Uri_HAS_DISPLAY_URI     (1 << Uri_PROPERTY_DISPLAY_URI)
#define Uri_HAS_DOMAIN          (1 << Uri_PROPERTY_DOMAIN)
#define Uri_HAS_EXTENSION       (1 << Uri_PROPERTY_EXTENSION)
#define Uri_HAS_FRAGMENT        (1 << Uri_PROPERTY_FRAGMENT)
#define Uri_HAS_HOST            (1 << Uri_PROPERTY_HOST)
#define Uri_HAS_PASSWORD        (1 << Uri_PROPERTY_PASSWORD)
#define Uri_HAS_PATH            (1 << Uri_PROPERTY_PATH)
#define Uri_HAS_QUERY           (1 << Uri_PROPERTY_QUERY)
#define Uri_HAS_RAW_URI         (1 << Uri_PROPERTY_RAW_URI)
#define Uri_HAS_SCHEME_NAME     (1 << Uri_PROPERTY_SCHEME_NAME)
#define Uri_HAS_USER_NAME       (1 << Uri_PROPERTY_USER_NAME)
#define Uri_HAS_PATH_AND_QUERY  (1 << Uri_PROPERTY_PATH_AND_QUERY)
#define Uri_HAS_USER_INFO       (1 << Uri_PROPERTY_USER_INFO)
#define Uri_HAS_HOST_TYPE       (1 << Uri_PROPERTY_HOST_TYPE)
#define Uri_HAS_PORT            (1 << Uri_PROPERTY_PORT)
#define Uri_HAS_SCHEME          (1 << Uri_PROPERTY_SCHEME)
#define Uri_HAS_ZONE            (1 << Uri_PROPERTY_ZONE)

//The following public Uri_CREATE flags may be passed in 
//through the dwFlags parameter of the CreateUri functions.
//Note that ALLOW_RELATIVE and ALLOW_IMPLICIT_WILDCARD_SCHEME are mutually exclusive and may not be passed together.
#define Uri_CREATE_ALLOW_RELATIVE                 0x00000001    // When the scheme is unspecified and not implicit file, assume relative.
#define Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME 0x00000002    // When the scheme is unspecified and not implicit file, assume wildcard.
#define Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME     0x00000004    // When the scheme is unspecified and it starts with X: or \\ assume its a file scheme.
#define Uri_CREATE_NOFRAG                         0x00000008    // If there's a query string don't look for a fragment
#define Uri_CREATE_NO_CANONICALIZE                0x00000010    // Do not canonicalize the scheme, host, authority, or path
#define Uri_CREATE_CANONICALIZE                   0x00000100    // DEFAULT: Canonicalize the scheme, host, authority, and path
#define Uri_CREATE_FILE_USE_DOS_PATH              0x00000020    // Use DOS path compat mode for file URI creation
#define Uri_CREATE_DECODE_EXTRA_INFO              0x00000040    // Beta2 DEFAULT: Decode the contents of query and fragment, then re-encode reserved characters
#define Uri_CREATE_NO_DECODE_EXTRA_INFO           0x00000080    // Beta1 DEFAULT: Neither decode nor re-encode any part of the query or fragment
#define Uri_CREATE_CRACK_UNKNOWN_SCHEMES          0x00000200    // Beta2 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like heirarchical URIs
#define Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES       0x00000400    // Beta1 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like opaque URIs
#define Uri_CREATE_PRE_PROCESS_HTML_URI           0x00000800    // DEFAULT:  Perform pre-processing on the URI to remove control characters and whitespace as if the URI comes from the raw href value of an HTML page.
#define Uri_CREATE_NO_PRE_PROCESS_HTML_URI        0x00001000    // Don't perform pre-processing to remove control characters and whitespace as appropriate.
#define Uri_CREATE_IE_SETTINGS                    0x00002000    // Use IE registry settings for such things as whether or not to use IDN.
#define Uri_CREATE_NO_IE_SETTINGS                 0x00004000    // DEFAULT: Don't use IE registry settings.
#define Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS 0x00008000    // Don't percent-encode characters that are forbidden by the RFC.
//The following flags may be passed in through the dwFlags 
//parameter of the IUri::GetPropertyBSTR or IUri::GetPropertyLength functions.
//The following flags apply only to the property Uri_PROPERTY_DISPLAY_URI:
#define Uri_DISPLAY_NO_FRAGMENT               0x00000001    // Exclude fragment from the DisplayUri, if one exists
#define Uri_PUNYCODE_IDN_HOST                 0x00000002    // Show the hostname encoded as punycode inside the Host, Domain, or AbsoluteUri properties, if the Uri is IDN
#define Uri_DISPLAY_IDN_HOST                  0x00000004    // Show the hostname encoded as punycode or Unicode as it would appear in the DisplayUri property. This applies to the Host, Domain, and AbsoluteUri properties.
// The following are Uri_ENCODING_ flags for use with the function CreateUriFromMultiByteString
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8  0x00000001
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_CP                    0x00000002
#define Uri_ENCODING_HOST_IS_IDN                                 0x00000004
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8                0x00000008
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP                  0x00000010
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8  0x00000020
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP                    0x00000040
#define Uri_ENCODING_RFC (Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8)

//The following flags may be passed in through the dwUriBuilderFlags 
//parameter of the IUriBuilder::CreateUri
#define UriBuilder_USE_ORIGINAL_FLAGS             0x00000001    // Use the create flags from the underlying IUri if they are available.

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec;

#ifndef __IUriContainer_INTERFACE_DEFINED__
#define __IUriContainer_INTERFACE_DEFINED__

/* interface IUriContainer */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IUriContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a158a630-ed6f-45fb-b987-f68676f57752")
    IUriContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [out] */ IUri **ppIUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriContainer * This,
            /* [out] */ IUri **ppIUri);
        
        END_INTERFACE
    } IUriContainerVtbl;

    interface IUriContainer
    {
        CONST_VTBL struct IUriContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriContainer_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0013 */
/* [local] */ 

#if !defined(SORTPP_PASS)
//                       Temporary workaround for sortpp.exe problem in base\wow64\cgen
//                       Windows OS Bug 2242537 tracks this build break for 64-bit platforms


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec;

#ifndef __IUriBuilder_INTERFACE_DEFINED__
#define __IUriBuilder_INTERFACE_DEFINED__

/* interface IUriBuilder */
/* [unique][uuid][object][local][helpstring] */ 


EXTERN_C const IID IID_IUriBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4221B2E1-8955-46c0-BD5B-DE9897565DE7")
    IUriBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateUriSimple( 
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateUri( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateUriWithFlags( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [out] */ IUri **ppIUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIUri( 
            /* [unique][in] */ IUri *pIUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [out] */ DWORD *pcchFragment,
            /* [out] */ LPCWSTR *ppwzFragment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHost( 
            /* [out] */ DWORD *pcchHost,
            /* [out] */ LPCWSTR *ppwzHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [out] */ DWORD *pcchPassword,
            /* [out] */ LPCWSTR *ppwzPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ DWORD *pcchPath,
            /* [out] */ LPCWSTR *ppwzPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ BOOL *pfHasPort,
            /* [out] */ DWORD *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ DWORD *pcchQuery,
            /* [out] */ LPCWSTR *ppwzQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [out] */ DWORD *pcchSchemeName,
            /* [out] */ LPCWSTR *ppwzSchemeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [out] */ DWORD *pcchUserName,
            /* [out] */ LPCWSTR *ppwzUserName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFragment( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHost( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuery( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSchemeName( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserName( 
            /* [in] */ LPCWSTR pwzNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperties( 
            /* [in] */ DWORD dwPropertyMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasBeenModified( 
            /* [out] */ BOOL *pfModified) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateUriSimple )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri);
        
        HRESULT ( STDMETHODCALLTYPE *CreateUri )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri);
        
        HRESULT ( STDMETHODCALLTYPE *CreateUriWithFlags )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUri **ppIUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriBuilder * This,
            /* [out] */ IUri **ppIUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetIUri )( 
            IUriBuilder * This,
            /* [unique][in] */ IUri *pIUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchFragment,
            /* [out] */ LPCWSTR *ppwzFragment);
        
        HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchHost,
            /* [out] */ LPCWSTR *ppwzHost);
        
        HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchPassword,
            /* [out] */ LPCWSTR *ppwzPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchPath,
            /* [out] */ LPCWSTR *ppwzPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IUriBuilder * This,
            /* [out] */ BOOL *pfHasPort,
            /* [out] */ DWORD *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchQuery,
            /* [out] */ LPCWSTR *ppwzQuery);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchSchemeName,
            /* [out] */ LPCWSTR *ppwzSchemeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IUriBuilder * This,
            /* [out] */ DWORD *pcchUserName,
            /* [out] */ LPCWSTR *ppwzUserName);
        
        HRESULT ( STDMETHODCALLTYPE *SetFragment )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetHost )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IUriBuilder * This,
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetQuery )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSchemeName )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserName )( 
            IUriBuilder * This,
            /* [in] */ LPCWSTR pwzNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperties )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwPropertyMask);
        
        HRESULT ( STDMETHODCALLTYPE *HasBeenModified )( 
            IUriBuilder * This,
            /* [out] */ BOOL *pfModified);
        
        END_INTERFACE
    } IUriBuilderVtbl;

    interface IUriBuilder
    {
        CONST_VTBL struct IUriBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilder_CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#define IUriBuilder_SetIUri(This,pIUri)	\
    ( (This)->lpVtbl -> SetIUri(This,pIUri) ) 

#define IUriBuilder_GetFragment(This,pcchFragment,ppwzFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pcchFragment,ppwzFragment) ) 

#define IUriBuilder_GetHost(This,pcchHost,ppwzHost)	\
    ( (This)->lpVtbl -> GetHost(This,pcchHost,ppwzHost) ) 

#define IUriBuilder_GetPassword(This,pcchPassword,ppwzPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pcchPassword,ppwzPassword) ) 

#define IUriBuilder_GetPath(This,pcchPath,ppwzPath)	\
    ( (This)->lpVtbl -> GetPath(This,pcchPath,ppwzPath) ) 

#define IUriBuilder_GetPort(This,pfHasPort,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pfHasPort,pdwPort) ) 

#define IUriBuilder_GetQuery(This,pcchQuery,ppwzQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pcchQuery,ppwzQuery) ) 

#define IUriBuilder_GetSchemeName(This,pcchSchemeName,ppwzSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pcchSchemeName,ppwzSchemeName) ) 

#define IUriBuilder_GetUserName(This,pcchUserName,ppwzUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pcchUserName,ppwzUserName) ) 

#define IUriBuilder_SetFragment(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetFragment(This,pwzNewValue) ) 

#define IUriBuilder_SetHost(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetHost(This,pwzNewValue) ) 

#define IUriBuilder_SetPassword(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPassword(This,pwzNewValue) ) 

#define IUriBuilder_SetPath(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPath(This,pwzNewValue) ) 

#define IUriBuilder_SetPort(This,fHasPort,dwNewValue)	\
    ( (This)->lpVtbl -> SetPort(This,fHasPort,dwNewValue) ) 

#define IUriBuilder_SetQuery(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetQuery(This,pwzNewValue) ) 

#define IUriBuilder_SetSchemeName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetSchemeName(This,pwzNewValue) ) 

#define IUriBuilder_SetUserName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetUserName(This,pwzNewValue) ) 

#define IUriBuilder_RemoveProperties(This,dwPropertyMask)	\
    ( (This)->lpVtbl -> RemoveProperties(This,dwPropertyMask) ) 

#define IUriBuilder_HasBeenModified(This,pfModified)	\
    ( (This)->lpVtbl -> HasBeenModified(This,pfModified) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilder_INTERFACE_DEFINED__ */


#ifndef __IUriBuilderFactory_INTERFACE_DEFINED__
#define __IUriBuilderFactory_INTERFACE_DEFINED__

/* interface IUriBuilderFactory */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IUriBuilderFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E982CE48-0B96-440c-BC37-0C869B27A29E")
    IUriBuilderFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIUriBuilder( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUriBuilder **ppIUriBuilder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInitializedIUriBuilder( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUriBuilder **ppIUriBuilder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilderFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilderFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilderFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUriBuilder **ppIUriBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInitializedIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ IUriBuilder **ppIUriBuilder);
        
        END_INTERFACE
    } IUriBuilderFactoryVtbl;

    interface IUriBuilderFactory
    {
        CONST_VTBL struct IUriBuilderFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilderFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilderFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilderFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilderFactory_CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#define IUriBuilderFactory_CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilderFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0015 */
/* [local] */ 

STDAPI CreateIUriBuilder(
    __in_opt    IUri         *pIUri,
    __in        DWORD         dwFlags,
    __in        DWORD_PTR     dwReserved,
    __deref_out IUriBuilder **ppIUriBuilder
    );
#endif // (!defined(SORTPP_PASS)
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETINFO_DEFINED
#define _LPWININETINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec;

#ifndef __IWinInetInfo_INTERFACE_DEFINED__
#define __IWinInetInfo_INTERFACE_DEFINED__

/* interface IWinInetInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IWinInetInfo *LPWININETINFO;


EXTERN_C const IID IID_IWinInetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d6-bafa-11ce-8c82-00aa004ba90b")
    IWinInetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryOption( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        END_INTERFACE
    } IWinInetInfoVtbl;

    interface IWinInetInfo
    {
        CONST_VTBL struct IWinInetInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_RemoteQueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


void __RPC_STUB IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0016 */
/* [local] */ 

#endif
#define WININETINFO_OPTION_LOCK_HANDLE 65534
#ifndef _LPHTTPSECURITY_DEFINED
#define _LPHTTPSECURITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0016_v0_0_s_ifspec;

#ifndef __IHttpSecurity_INTERFACE_DEFINED__
#define __IHttpSecurity_INTERFACE_DEFINED__

/* interface IHttpSecurity */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IHttpSecurity *LPHTTPSECURITY;


EXTERN_C const IID IID_IHttpSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d7-bafa-11ce-8c82-00aa004ba90b")
    IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSecurityProblem( 
            /* [in] */ DWORD dwProblem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpSecurity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IHttpSecurity * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSecurityProblem )( 
            IHttpSecurity * This,
            /* [in] */ DWORD dwProblem);
        
        END_INTERFACE
    } IHttpSecurityVtbl;

    interface IHttpSecurity
    {
        CONST_VTBL struct IHttpSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpSecurity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpSecurity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpSecurity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpSecurity_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define IHttpSecurity_OnSecurityProblem(This,dwProblem)	\
    ( (This)->lpVtbl -> OnSecurityProblem(This,dwProblem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpSecurity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0017 */
/* [local] */ 

#endif
#ifndef _LPWININETHTTPINFO_DEFINED
#define _LPWININETHTTPINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0017_v0_0_s_ifspec;

#ifndef __IWinInetHttpInfo_INTERFACE_DEFINED__
#define __IWinInetHttpInfo_INTERFACE_DEFINED__

/* interface IWinInetHttpInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IWinInetHttpInfo *LPWININETHTTPINFO;


EXTERN_C const IID IID_IWinInetHttpInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d8-bafa-11ce-8c82-00aa004ba90b")
    IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetHttpInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetHttpInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetHttpInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetHttpInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetHttpInfoVtbl;

    interface IWinInetHttpInfo
    {
        CONST_VTBL struct IWinInetHttpInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetHttpInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetHttpInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetHttpInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetHttpInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 


#define IWinInetHttpInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_RemoteQueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


void __RPC_STUB IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetHttpInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0018 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPWININETCACHEHINTS_DEFINED
#define _LPWININETCACHEHINTS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints_INTERFACE_DEFINED__
#define __IWinInetCacheHints_INTERFACE_DEFINED__

/* interface IWinInetCacheHints */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints *LPWININETCACHEHINTS;


EXTERN_C const IID IID_IWinInetCacheHints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD")
    IWinInetCacheHints : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension( 
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHintsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHintsVtbl;

    interface IWinInetCacheHints
    {
        CONST_VTBL struct IWinInetCacheHintsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0019 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETCACHEHINTS2_DEFINED
#define _LPWININETCACHEHINTS2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints2_INTERFACE_DEFINED__
#define __IWinInetCacheHints2_INTERFACE_DEFINED__

/* interface IWinInetCacheHints2 */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints2 *LPWININETCACHEHINTS2;


EXTERN_C const IID IID_IWinInetCacheHints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7857AEAC-D31F-49bf-884E-DD46DF36780A")
    IWinInetCacheHints2 : public IWinInetCacheHints
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension2( 
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out] */ WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension2 )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out] */ WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHints2Vtbl;

    interface IWinInetCacheHints2
    {
        CONST_VTBL struct IWinInetCacheHints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints2_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 


#define IWinInetCacheHints2_SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0020 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifdef UNDER_CE
#ifndef _LPPROXYINFO_DEFINED
#define _LPPROXYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec;

#ifndef __IProxyInfo_INTERFACE_DEFINED__
#define __IProxyInfo_INTERFACE_DEFINED__

/* interface IProxyInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IProxyInfo *LPPROXYINFO;

typedef /* [public] */ 
enum __MIDL_IProxyInfo_0001
    {	pioHTTPPROXY	= 0,
	pioWAPGATEWAY	= ( pioHTTPPROXY + 1 ) 
    } 	PROXYINFOOPTION;

typedef struct _tagHTTPPROXYINFO
    {
    LPOLESTR pszProxy;
    LPOLESTR pszProxyBypass;
    DWORD dwReserved;
    } 	HTTPPROXYINFO;

typedef struct _tagWAPGATEWAYINFO
    {
    LPOLESTR pszGateway;
    DWORD dwServicePortA;
    LPOLESTR szServiceTypeA;
    DWORD dwServicePortB;
    LPOLESTR szServiceTypeB;
    BOOL bMaster;
    DWORD dwReserved;
    } 	WAPGATEWAYINFO;


EXTERN_C const IID IID_IProxyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d8-bafa-11ce-8c82-00aa004ba90c")
    IProxyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProxyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProxyInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProxyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProxyInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IProxyInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IProxyInfoVtbl;

    interface IProxyInfo
    {
        CONST_VTBL struct IProxyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProxyInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProxyInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProxyInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProxyInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IProxyInfo_RemoteQueryInfo_Proxy( 
    IProxyInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


void __RPC_STUB IProxyInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProxyInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0021 */
/* [local] */ 

#endif
#endif // UNDER_CE
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/* interface IBindHost */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBindHost *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc4801a1-2ba9-11cf-a229-00aa003d7352")
    IBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMoniker( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx *pBC,
            /* [out] */ IMoniker **ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToStorage( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToObject( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMoniker )( 
            IBindHost * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx *pBC,
            /* [out] */ IMoniker **ppmk,
            /* [in] */ DWORD dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToStorage )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToObject )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        END_INTERFACE
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    ( (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved) ) 

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0022 */
/* [local] */ 

#endif
                                                                                                           
// These are for backwards compatibility with previous URLMON versions
// Flags for the UrlDownloadToCacheFile                                                                    
#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            
#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      
#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  
                                                                                                           
                                                                                                           
struct IBindStatusCallback;                                                                                
STDAPI HlinkSimpleNavigateToString(                                                                        
    /* [in] */ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI HlinkSimpleNavigateToMoniker(                                                                       
    /* [in] */ IMoniker *pmkTarget,      // required - target document - (may be null                      
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                        
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                       
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                    
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                   
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                             
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                           
STDAPI URLDownloadToCacheFileA(__in LPUNKNOWN, __in LPCSTR,  __out_ecount(cchFileName) LPSTR,  DWORD cchFileName, DWORD, __in LPBINDSTATUSCALLBACK);                   
STDAPI URLDownloadToCacheFileW(__in LPUNKNOWN, __in LPCWSTR, __out_ecount(cchFileName) LPWSTR, DWORD cchFileName, DWORD, __in LPBINDSTATUSCALLBACK);                 
STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                      
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                     
                                                                                                           
#ifdef UNICODE                                                                                             
#define URLOpenStream            URLOpenStreamW                                                            
#define URLOpenPullStream        URLOpenPullStreamW                                                        
#define URLDownloadToFile        URLDownloadToFileW                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    
#else                                                                                                      
#define URLOpenStream            URLOpenStreamA                                                            
#define URLOpenPullStream        URLOpenPullStreamA                                                        
#define URLDownloadToFile        URLDownloadToFileA                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    
#endif // !UNICODE                                                                                         
                                                                                                           
                                                                                                           
STDAPI HlinkGoBack(IUnknown *pUnk);                                                                        
STDAPI HlinkGoForward(IUnknown *pUnk);                                                                     
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);                                              
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);                                          
                                                                                                           
#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   









#ifndef _LPIINTERNET
#define _LPIINTERNET


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec;

#ifndef __IInternet_INTERFACE_DEFINED__
#define __IInternet_INTERFACE_DEFINED__

/* interface IInternet */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternet *LPIINTERNET;


EXTERN_C const IID IID_IInternet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e0-baf9-11ce-8c82-00aa004ba90b")
    IInternet : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInternetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternet * This);
        
        END_INTERFACE
    } IInternetVtbl;

    interface IInternet
    {
        CONST_VTBL struct IInternetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0023 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETBINDINFO
#define _LPIINTERNETBINDINFO


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec;

#ifndef __IInternetBindInfo_INTERFACE_DEFINED__
#define __IInternetBindInfo_INTERFACE_DEFINED__

/* interface IInternetBindInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetBindInfo *LPIINTERNETBINDINFO;

typedef 
enum tagBINDSTRING
    {	BINDSTRING_HEADERS	= 1,
	BINDSTRING_ACCEPT_MIMES	= ( BINDSTRING_HEADERS + 1 ) ,
	BINDSTRING_EXTRA_URL	= ( BINDSTRING_ACCEPT_MIMES + 1 ) ,
	BINDSTRING_LANGUAGE	= ( BINDSTRING_EXTRA_URL + 1 ) ,
	BINDSTRING_USERNAME	= ( BINDSTRING_LANGUAGE + 1 ) ,
	BINDSTRING_PASSWORD	= ( BINDSTRING_USERNAME + 1 ) ,
	BINDSTRING_UA_PIXELS	= ( BINDSTRING_PASSWORD + 1 ) ,
	BINDSTRING_UA_COLOR	= ( BINDSTRING_UA_PIXELS + 1 ) ,
	BINDSTRING_OS	= ( BINDSTRING_UA_COLOR + 1 ) ,
	BINDSTRING_USER_AGENT	= ( BINDSTRING_OS + 1 ) ,
	BINDSTRING_ACCEPT_ENCODINGS	= ( BINDSTRING_USER_AGENT + 1 ) ,
	BINDSTRING_POST_COOKIE	= ( BINDSTRING_ACCEPT_ENCODINGS + 1 ) ,
	BINDSTRING_POST_DATA_MIME	= ( BINDSTRING_POST_COOKIE + 1 ) ,
	BINDSTRING_URL	= ( BINDSTRING_POST_DATA_MIME + 1 ) ,
	BINDSTRING_IID	= ( BINDSTRING_URL + 1 ) ,
	BINDSTRING_FLAG_BIND_TO_OBJECT	= ( BINDSTRING_IID + 1 ) ,
	BINDSTRING_PTR_BIND_CONTEXT	= ( BINDSTRING_FLAG_BIND_TO_OBJECT + 1 ) 
    } 	BINDSTRING;


EXTERN_C const IID IID_IInternetBindInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e1-baf9-11ce-8c82-00aa004ba90b")
    IInternetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindString( 
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetBindInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetBindInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetBindInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetBindInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IInternetBindInfo * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindString )( 
            IInternetBindInfo * This,
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched);
        
        END_INTERFACE
    } IInternetBindInfoVtbl;

    interface IInternetBindInfo
    {
        CONST_VTBL struct IInternetBindInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetBindInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetBindInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetBindInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetBindInfo_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IInternetBindInfo_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    ( (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetBindInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0024 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLROOT_DEFINED
#define _LPIINTERNETPROTOCOLROOT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec;

#ifndef __IInternetProtocolRoot_INTERFACE_DEFINED__
#define __IInternetProtocolRoot_INTERFACE_DEFINED__

/* interface IInternetProtocolRoot */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolRoot *LPIINTERNETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {	PI_PARSE_URL	= 0x1,
	PI_FILTER_MODE	= 0x2,
	PI_FORCE_ASYNC	= 0x4,
	PI_USE_WORKERTHREAD	= 0x8,
	PI_MIMEVERIFICATION	= 0x10,
	PI_CLSIDLOOKUP	= 0x20,
	PI_DATAPROGRESS	= 0x40,
	PI_SYNCHRONOUS	= 0x80,
	PI_APARTMENTTHREADED	= 0x100,
	PI_CLASSINSTALL	= 0x200,
	PI_PASSONBINDCTX	= 0x2000,
	PI_NOMIMEHANDLER	= 0x8000,
	PI_LOADAPPDIRECT	= 0x4000,
	PD_FORCE_SWITCH	= 0x10000,
	PI_PREFERDEFAULTHANDLER	= 0x20000
    } 	PI_FLAGS;

typedef struct _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    } 	PROTOCOLDATA;

typedef struct _tagStartParam
    {
    IID iid;
    IBindCtx *pIBindCtx;
    IUnknown *pItf;
    } 	StartParam;


EXTERN_C const IID IID_IInternetProtocolRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolRoot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolRoot * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolRoot * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolRoot * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolRoot * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolRoot * This);
        
        END_INTERFACE
    } IInternetProtocolRootVtbl;

    interface IInternetProtocolRoot
    {
        CONST_VTBL struct IInternetProtocolRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolRoot_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolRoot_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolRoot_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolRoot_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolRoot_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolRoot_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolRoot_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0025 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOL_DEFINED
#define _LPIINTERNETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec;

#ifndef __IInternetProtocol_INTERFACE_DEFINED__
#define __IInternetProtocol_INTERFACE_DEFINED__

/* interface IInternetProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocol *LPIINTERNETPROTOCOL;


EXTERN_C const IID IID_IInternetProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocol : public IInternetProtocolRoot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockRequest( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocol * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocol * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocol * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocol * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocol * This);
        
        END_INTERFACE
    } IInternetProtocolVtbl;

    interface IInternetProtocol
    {
        CONST_VTBL struct IInternetProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocol_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocol_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocol_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocol_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocol_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocol_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocol_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocol_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocol_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocol_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0026 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLEX_DEFINED
#define _LPIINTERNETPROTOCOLEX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec;

#ifndef __IInternetProtocolEx_INTERFACE_DEFINED__
#define __IInternetProtocolEx_INTERFACE_DEFINED__

/* interface IInternetProtocolEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetProtocolEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7A98E66-1010-492c-A1C8-C809E1F75905")
    IInternetProtocolEx : public IInternetProtocol
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartEx( 
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolEx * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolEx * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolEx * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocolEx * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocolEx * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartEx )( 
            IInternetProtocolEx * This,
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        END_INTERFACE
    } IInternetProtocolExVtbl;

    interface IInternetProtocolEx
    {
        CONST_VTBL struct IInternetProtocolExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolEx_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolEx_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolEx_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolEx_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolEx_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolEx_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocolEx_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocolEx_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocolEx_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocolEx_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 


#define IInternetProtocolEx_StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0027 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLSINK_DEFINED
#define _LPIINTERNETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec;

#ifndef __IInternetProtocolSink_INTERFACE_DEFINED__
#define __IInternetProtocolSink_INTERFACE_DEFINED__

/* interface IInternetProtocolSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSink *LPIINTERNETPROTOCOLSINK;


EXTERN_C const IID IID_IInternetProtocolSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Switch( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportData( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Switch )( 
            IInternetProtocolSink * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            IInternetProtocolSink * This,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportData )( 
            IInternetProtocolSink * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax);
        
        HRESULT ( STDMETHODCALLTYPE *ReportResult )( 
            IInternetProtocolSink * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult);
        
        END_INTERFACE
    } IInternetProtocolSinkVtbl;

    interface IInternetProtocolSink
    {
        CONST_VTBL struct IInternetProtocolSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSink_Switch(This,pProtocolData)	\
    ( (This)->lpVtbl -> Switch(This,pProtocolData) ) 

#define IInternetProtocolSink_ReportProgress(This,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> ReportProgress(This,ulStatusCode,szStatusText) ) 

#define IInternetProtocolSink_ReportData(This,grfBSCF,ulProgress,ulProgressMax)	\
    ( (This)->lpVtbl -> ReportData(This,grfBSCF,ulProgress,ulProgressMax) ) 

#define IInternetProtocolSink_ReportResult(This,hrResult,dwError,szResult)	\
    ( (This)->lpVtbl -> ReportResult(This,hrResult,dwError,szResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0028 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED
#define _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec;

#ifndef __IInternetProtocolSinkStackable_INTERFACE_DEFINED__
#define __IInternetProtocolSinkStackable_INTERFACE_DEFINED__

/* interface IInternetProtocolSinkStackable */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSinkStackable *LPIINTERNETPROTOCOLSINKStackable;


EXTERN_C const IID IID_IInternetProtocolSinkStackable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9f0-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSinkStackable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SwitchSink( 
            /* [in] */ IInternetProtocolSink *pOIProtSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitSwitch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RollbackSwitch( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkStackableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSinkStackable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchSink )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ IInternetProtocolSink *pOIProtSink);
        
        HRESULT ( STDMETHODCALLTYPE *CommitSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *RollbackSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        END_INTERFACE
    } IInternetProtocolSinkStackableVtbl;

    interface IInternetProtocolSinkStackable
    {
        CONST_VTBL struct IInternetProtocolSinkStackableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSinkStackable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSinkStackable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSinkStackable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSinkStackable_SwitchSink(This,pOIProtSink)	\
    ( (This)->lpVtbl -> SwitchSink(This,pOIProtSink) ) 

#define IInternetProtocolSinkStackable_CommitSwitch(This)	\
    ( (This)->lpVtbl -> CommitSwitch(This) ) 

#define IInternetProtocolSinkStackable_RollbackSwitch(This)	\
    ( (This)->lpVtbl -> RollbackSwitch(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSinkStackable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0029 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETSESSION_DEFINED
#define _LPIINTERNETSESSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec;

#ifndef __IInternetSession_INTERFACE_DEFINED__
#define __IInternetSession_INTERFACE_DEFINED__

/* interface IInternetSession */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetSession *LPIINTERNETSESSION;

typedef 
enum _tagOIBDG_FLAGS
    {	OIBDG_APARTMENTTHREADED	= 0x100,
	OIBDG_DATAONLY	= 0x1000
    } 	OIBDG_FLAGS;


EXTERN_C const IID IID_IInternetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e7-baf9-11ce-8c82-00aa004ba90b")
    IInternetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IInternetSession * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetSessionVtbl;

    interface IInternetSession
    {
        CONST_VTBL struct IInternetSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSession_RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)	\
    ( (This)->lpVtbl -> RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved) ) 

#define IInternetSession_UnregisterNameSpace(This,pCF,pszProtocol)	\
    ( (This)->lpVtbl -> UnregisterNameSpace(This,pCF,pszProtocol) ) 

#define IInternetSession_RegisterMimeFilter(This,pCF,rclsid,pwzType)	\
    ( (This)->lpVtbl -> RegisterMimeFilter(This,pCF,rclsid,pwzType) ) 

#define IInternetSession_UnregisterMimeFilter(This,pCF,pwzType)	\
    ( (This)->lpVtbl -> UnregisterMimeFilter(This,pCF,pwzType) ) 

#define IInternetSession_CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption)	\
    ( (This)->lpVtbl -> CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption) ) 

#define IInternetSession_SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved) ) 

#define IInternetSession_GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0030 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETTHREADSWITCH_DEFINED
#define _LPIINTERNETTHREADSWITCH_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec;

#ifndef __IInternetThreadSwitch_INTERFACE_DEFINED__
#define __IInternetThreadSwitch_INTERFACE_DEFINED__

/* interface IInternetThreadSwitch */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetThreadSwitch *LPIINTERNETTHREADSWITCH;


EXTERN_C const IID IID_IInternetThreadSwitch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e8-baf9-11ce-8c82-00aa004ba90b")
    IInternetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetThreadSwitchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetThreadSwitch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetThreadSwitch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetThreadSwitch * This);
        
        END_INTERFACE
    } IInternetThreadSwitchVtbl;

    interface IInternetThreadSwitch
    {
        CONST_VTBL struct IInternetThreadSwitchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetThreadSwitch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetThreadSwitch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetThreadSwitch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetThreadSwitch_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IInternetThreadSwitch_Continue(This)	\
    ( (This)->lpVtbl -> Continue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetThreadSwitch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0031 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPRIORITY_DEFINED
#define _LPIINTERNETPRIORITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec;

#ifndef __IInternetPriority_INTERFACE_DEFINED__
#define __IInternetPriority_INTERFACE_DEFINED__

/* interface IInternetPriority */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetPriority *LPIINTERNETPRIORITY;


EXTERN_C const IID IID_IInternetPriority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9eb-baf9-11ce-8c82-00aa004ba90b")
    IInternetPriority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetPriorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetPriority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetPriority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetPriority * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IInternetPriority * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IInternetPriority * This,
            /* [out] */ LONG *pnPriority);
        
        END_INTERFACE
    } IInternetPriorityVtbl;

    interface IInternetPriority
    {
        CONST_VTBL struct IInternetPriorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetPriority_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetPriority_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetPriority_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetPriority_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IInternetPriority_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetPriority_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0032 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLINFO_DEFINED
#define _LPIINTERNETPROTOCOLINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec;

#ifndef __IInternetProtocolInfo_INTERFACE_DEFINED__
#define __IInternetProtocolInfo_INTERFACE_DEFINED__

/* interface IInternetProtocolInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolInfo *LPIINTERNETPROTOCOLINFO;

typedef 
enum _tagPARSEACTION
    {	PARSE_CANONICALIZE	= 1,
	PARSE_FRIENDLY	= ( PARSE_CANONICALIZE + 1 ) ,
	PARSE_SECURITY_URL	= ( PARSE_FRIENDLY + 1 ) ,
	PARSE_ROOTDOCUMENT	= ( PARSE_SECURITY_URL + 1 ) ,
	PARSE_DOCUMENT	= ( PARSE_ROOTDOCUMENT + 1 ) ,
	PARSE_ANCHOR	= ( PARSE_DOCUMENT + 1 ) ,
	PARSE_ENCODE	= ( PARSE_ANCHOR + 1 ) ,
	PARSE_DECODE	= ( PARSE_ENCODE + 1 ) ,
	PARSE_PATH_FROM_URL	= ( PARSE_DECODE + 1 ) ,
	PARSE_URL_FROM_PATH	= ( PARSE_PATH_FROM_URL + 1 ) ,
	PARSE_MIME	= ( PARSE_URL_FROM_PATH + 1 ) ,
	PARSE_SERVER	= ( PARSE_MIME + 1 ) ,
	PARSE_SCHEMA	= ( PARSE_SERVER + 1 ) ,
	PARSE_SITE	= ( PARSE_SCHEMA + 1 ) ,
	PARSE_DOMAIN	= ( PARSE_SITE + 1 ) ,
	PARSE_LOCATION	= ( PARSE_DOMAIN + 1 ) ,
	PARSE_SECURITY_DOMAIN	= ( PARSE_LOCATION + 1 ) ,
	PARSE_ESCAPE	= ( PARSE_SECURITY_DOMAIN + 1 ) ,
	PARSE_UNESCAPE	= ( PARSE_ESCAPE + 1 ) 
    } 	PARSEACTION;

typedef 
enum _tagPSUACTION
    {	PSU_DEFAULT	= 1,
	PSU_SECURITY_URL_ONLY	= ( PSU_DEFAULT + 1 ) 
    } 	PSUACTION;

typedef 
enum _tagQUERYOPTION
    {	QUERY_EXPIRATION_DATE	= 1,
	QUERY_TIME_OF_LAST_CHANGE	= ( QUERY_EXPIRATION_DATE + 1 ) ,
	QUERY_CONTENT_ENCODING	= ( QUERY_TIME_OF_LAST_CHANGE + 1 ) ,
	QUERY_CONTENT_TYPE	= ( QUERY_CONTENT_ENCODING + 1 ) ,
	QUERY_REFRESH	= ( QUERY_CONTENT_TYPE + 1 ) ,
	QUERY_RECOMBINE	= ( QUERY_REFRESH + 1 ) ,
	QUERY_CAN_NAVIGATE	= ( QUERY_RECOMBINE + 1 ) ,
	QUERY_USES_NETWORK	= ( QUERY_CAN_NAVIGATE + 1 ) ,
	QUERY_IS_CACHED	= ( QUERY_USES_NETWORK + 1 ) ,
	QUERY_IS_INSTALLEDENTRY	= ( QUERY_IS_CACHED + 1 ) ,
	QUERY_IS_CACHED_OR_MAPPED	= ( QUERY_IS_INSTALLEDENTRY + 1 ) ,
	QUERY_USES_CACHE	= ( QUERY_IS_CACHED_OR_MAPPED + 1 ) ,
	QUERY_IS_SECURE	= ( QUERY_USES_CACHE + 1 ) ,
	QUERY_IS_SAFE	= ( QUERY_IS_SECURE + 1 ) ,
	QUERY_USES_HISTORYFOLDER	= ( QUERY_IS_SAFE + 1 ) 
    } 	QUERYOPTION;


EXTERN_C const IID IID_IInternetProtocolInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CombineUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CompareUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetProtocolInfoVtbl;

    interface IInternetProtocolInfo
    {
        CONST_VTBL struct IInternetProtocolInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolInfo_ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags)	\
    ( (This)->lpVtbl -> CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags) ) 

#define IInternetProtocolInfo_QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0033 */
/* [local] */ 

#endif
#define IOInet               IInternet            
#define IOInetBindInfo       IInternetBindInfo    
#define IOInetProtocolRoot   IInternetProtocolRoot
#define IOInetProtocol       IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolEx     IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolSink   IInternetProtocolSink
#define IOInetProtocolInfo   IInternetProtocolInfo
#define IOInetSession        IInternetSession     
#define IOInetPriority       IInternetPriority    
#define IOInetThreadSwitch   IInternetThreadSwitch
#define IOInetProtocolSinkStackable   IInternetProtocolSinkStackable
#define LPOINET              LPIINTERNET             
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETBINDINFO      LPIINTERNETBINDINFO     
#define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT 
#define LPOINETPROTOCOL      LPIINTERNETPROTOCOL     
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLEX    LPIINTERNETPROTOCOLEX   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK 
#define LPOINETSESSION       LPIINTERNETSESSION      
#define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH 
#define LPOINETPRIORITY      LPIINTERNETPRIORITY     
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETPROTOCOLSINKSTACKABLE  LPIINTERNETPROTOCOLSINKSTACKABLE 
#define IID_IOInet               IID_IInternet            
#define IID_IOInetBindInfo       IID_IInternetBindInfo    
#define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot
#define IID_IOInetProtocol       IID_IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolEx     IID_IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolSink   IID_IInternetProtocolSink
#define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo
#define IID_IOInetSession        IID_IInternetSession     
#define IID_IOInetPriority       IID_IInternetPriority    
#define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch
#define IID_IOInetProtocolSinkStackable   IID_IInternetProtocolSinkStackable
STDAPI CoInternetParseUrl(                              
                            LPCWSTR      pwzUrl,        
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pszResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD        dwReserved     
    );                                                  
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetParseIUri(                             
                       __in IUri        *pIUri,         
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pwzResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD_PTR    dwReserved     
    );                                                  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrl(                                             
                                               LPCWSTR   pwzBaseUrl,     
                                               LPCWSTR   pwzRelativeUrl, 
                                               DWORD     dwCombineFlags, 
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR    pszResult,      
                                               DWORD     cchResult,      
    __out_opt                                  DWORD     *pcchResult,    
    __reserved                                 DWORD     dwReserved      
    );                                                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrlEx(              
    __in_opt    IUri       *pBaseUri,       
    __in_opt    LPCWSTR     pwzRelativeUrl, 
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
STDAPI CoInternetCombineIUri (              
    __in        IUri       *pBaseUri,       
    __in        IUri       *pRelativeUri,   
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCompareUrl(             
    LPCWSTR pwzUrl1,                     
    LPCWSTR pwzUrl2,                     
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetGetProtocolFlags(       
    LPCWSTR     pwzUrl,                  
    DWORD      *pdwFlags,                
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    LPVOID      pvBuffer,                
    DWORD       cbBuffer,                
    DWORD      *pcbBuffer,               
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSession(             
    DWORD       dwSessionMode,           
    __deref_out IInternetSession **ppIInternetSession,
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSecurityUrl(         
    LPCWSTR pwszUrl,                     
    __deref_out LPWSTR *ppwszSecUrl,     
    __in PSUACTION   psuAction,          
    __reserved DWORD dwReserved          
    );                                   
STDAPI AsyncInstallDistributionUnit(     
    LPCWSTR szDistUnit,                  
    LPCWSTR szTYPE,                      
    LPCWSTR szExt,                       
    DWORD dwFileVersionMS,               
    DWORD dwFileVersionLS,               
    LPCWSTR szURL,                       
    IBindCtx *pbc,                       
    LPVOID   pvReserved,                 
    DWORD   flags                        
    );                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetGetSecurityUrlEx(       
    __in IUri         *pUri,             
    __deref_out IUri **ppSecUri,         
    PSUACTION          psuAction,        
    __reserved  DWORD_PTR dwReserved 

    
    );                                   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _INTERNETFEATURELIST_DEFINED
#define _INTERNETFEATURELIST_DEFINED
typedef 
enum _tagINTERNETFEATURELIST
    {	FEATURE_OBJECT_CACHING	= 0,
	FEATURE_ZONE_ELEVATION	= ( FEATURE_OBJECT_CACHING + 1 ) ,
	FEATURE_MIME_HANDLING	= ( FEATURE_ZONE_ELEVATION + 1 ) ,
	FEATURE_MIME_SNIFFING	= ( FEATURE_MIME_HANDLING + 1 ) ,
	FEATURE_WINDOW_RESTRICTIONS	= ( FEATURE_MIME_SNIFFING + 1 ) ,
	FEATURE_WEBOC_POPUPMANAGEMENT	= ( FEATURE_WINDOW_RESTRICTIONS + 1 ) ,
	FEATURE_BEHAVIORS	= ( FEATURE_WEBOC_POPUPMANAGEMENT + 1 ) ,
	FEATURE_DISABLE_MK_PROTOCOL	= ( FEATURE_BEHAVIORS + 1 ) ,
	FEATURE_LOCALMACHINE_LOCKDOWN	= ( FEATURE_DISABLE_MK_PROTOCOL + 1 ) ,
	FEATURE_SECURITYBAND	= ( FEATURE_LOCALMACHINE_LOCKDOWN + 1 ) ,
	FEATURE_RESTRICT_ACTIVEXINSTALL	= ( FEATURE_SECURITYBAND + 1 ) ,
	FEATURE_VALIDATE_NAVIGATE_URL	= ( FEATURE_RESTRICT_ACTIVEXINSTALL + 1 ) ,
	FEATURE_RESTRICT_FILEDOWNLOAD	= ( FEATURE_VALIDATE_NAVIGATE_URL + 1 ) ,
	FEATURE_ADDON_MANAGEMENT	= ( FEATURE_RESTRICT_FILEDOWNLOAD + 1 ) ,
	FEATURE_PROTOCOL_LOCKDOWN	= ( FEATURE_ADDON_MANAGEMENT + 1 ) ,
	FEATURE_HTTP_USERNAME_PASSWORD_DISABLE	= ( FEATURE_PROTOCOL_LOCKDOWN + 1 ) ,
	FEATURE_SAFE_BINDTOOBJECT	= ( FEATURE_HTTP_USERNAME_PASSWORD_DISABLE + 1 ) ,
	FEATURE_UNC_SAVEDFILECHECK	= ( FEATURE_SAFE_BINDTOOBJECT + 1 ) ,
	FEATURE_GET_URL_DOM_FILEPATH_UNENCODED	= ( FEATURE_UNC_SAVEDFILECHECK + 1 ) ,
	FEATURE_TABBED_BROWSING	= ( FEATURE_GET_URL_DOM_FILEPATH_UNENCODED + 1 ) ,
	FEATURE_SSLUX	= ( FEATURE_TABBED_BROWSING + 1 ) ,
	FEATURE_DISABLE_NAVIGATION_SOUNDS	= ( FEATURE_SSLUX + 1 ) ,
	FEATURE_DISABLE_LEGACY_COMPRESSION	= ( FEATURE_DISABLE_NAVIGATION_SOUNDS + 1 ) ,
	FEATURE_FORCE_ADDR_AND_STATUS	= ( FEATURE_DISABLE_LEGACY_COMPRESSION + 1 ) ,
	FEATURE_XMLHTTP	= ( FEATURE_FORCE_ADDR_AND_STATUS + 1 ) ,
	FEATURE_DISABLE_TELNET_PROTOCOL	= ( FEATURE_XMLHTTP + 1 ) ,
	FEATURE_FEEDS	= ( FEATURE_DISABLE_TELNET_PROTOCOL + 1 ) ,
	FEATURE_BLOCK_INPUT_PROMPTS	= ( FEATURE_FEEDS + 1 ) ,
	FEATURE_ENTRY_COUNT	= ( FEATURE_BLOCK_INPUT_PROMPTS + 1 ) 
    } 	INTERNETFEATURELIST;


// CoInternetSetFeatureEnabled can be used to set/reset features. 
// The following flags control where the feature is set

#define SET_FEATURE_ON_THREAD                       0x00000001
#define SET_FEATURE_ON_PROCESS                      0x00000002
#define SET_FEATURE_IN_REGISTRY                     0x00000004
#define SET_FEATURE_ON_THREAD_LOCALMACHINE          0x00000008
#define SET_FEATURE_ON_THREAD_INTRANET              0x00000010
#define SET_FEATURE_ON_THREAD_TRUSTED               0x00000020
#define SET_FEATURE_ON_THREAD_INTERNET              0x00000040
#define SET_FEATURE_ON_THREAD_RESTRICTED            0x00000080

// CoInternetIsFeatureEnabled can be used to get features. 
// The following flags control where the feature is obtained from
// default is from process

#define GET_FEATURE_FROM_THREAD                      0x00000001
#define GET_FEATURE_FROM_PROCESS                     0x00000002
#define GET_FEATURE_FROM_REGISTRY                    0x00000004
#define GET_FEATURE_FROM_THREAD_LOCALMACHINE         0x00000008
#define GET_FEATURE_FROM_THREAD_INTRANET             0x00000010
#define GET_FEATURE_FROM_THREAD_TRUSTED              0x00000020
#define GET_FEATURE_FROM_THREAD_INTERNET             0x00000040
#define GET_FEATURE_FROM_THREAD_RESTRICTED           0x00000080
#endif
STDAPI CoInternetSetFeatureEnabled(      
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    BOOL fEnable                         
    );                                   
STDAPI CoInternetIsFeatureEnabled(       
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetIsFeatureEnabledForUrl( 
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    LPCWSTR szURL,                       
    IInternetSecurityManager *pSecMgr    
    );                                   
STDAPI CoInternetIsFeatureEnabledForIUri( 
    INTERNETFEATURELIST FeatureEntry,     
    DWORD dwFlags,                        
    IUri * pIUri,                         
    IInternetSecurityManagerEx2 *pSecMgr  
    );                                    
STDAPI CoInternetIsFeatureZoneElevationEnabled( 
    LPCWSTR szFromURL,                          
    LPCWSTR szToURL,                            
    IInternetSecurityManager *pSecMgr,          
    DWORD dwFlags                               
    );                                          
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
 
STDAPI CopyStgMedium(const STGMEDIUM * pcstgmedSrc,  
                           STGMEDIUM * pstgmedDest); 
STDAPI CopyBindInfo( const BINDINFO * pcbiSrc,   
                           BINDINFO * pbiDest ); 
STDAPI_(void) ReleaseBindInfo( BINDINFO * pbindinfo );  
 
#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      
#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      
#define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER  
#define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)      
#define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)      
#define OInetParseUrl               CoInternetParseUrl               
#define OInetCombineUrl             CoInternetCombineUrl             
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCombineUrlEx           CoInternetCombineUrlEx           
#define OInetCombineIUri            CoInternetCombineIUri            
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCompareUrl             CoInternetCompareUrl             
#define OInetQueryInfo              CoInternetQueryInfo              
#define OInetGetSession             CoInternetGetSession             
#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ 
//
// Static Protocol flags
//
#define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001

// Creates the security manager object. The first argument is the Service provider
// to allow for delegation
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved);


// Security manager CLSID's
EXTERN_C const IID CLSID_InternetSecurityManager;  
EXTERN_C const IID CLSID_InternetZoneManager;  
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
EXTERN_C const IID CLSID_PersistentZoneIdentifier;  
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
// This service is used for delegation support on the Security Manager interface
#define SID_SInternetSecurityManager         IID_IInternetSecurityManager

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SID_SInternetSecurityManagerEx         IID_IInternetSecurityManagerEx
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)

#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SID_SInternetSecurityManagerEx2         IID_IInternetSecurityManagerEx2
#endif //(_WIN32_IE >= _WIN32_IE_IE70)

#define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager

#ifndef _LPINTERNETSECURITYMGRSITE_DEFINED
#define _LPINTERNETSECURITYMGRSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec;

#ifndef __IInternetSecurityMgrSite_INTERFACE_DEFINED__
#define __IInternetSecurityMgrSite_INTERFACE_DEFINED__

/* interface IInternetSecurityMgrSite */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetSecurityMgrSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ed-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityMgrSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityMgrSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityMgrSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityMgrSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IInternetSecurityMgrSite * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IInternetSecurityMgrSiteVtbl;

    interface IInternetSecurityMgrSite
    {
        CONST_VTBL struct IInternetSecurityMgrSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityMgrSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityMgrSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityMgrSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityMgrSite_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IInternetSecurityMgrSite_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityMgrSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0034 */
/* [local] */ 

#endif
#ifndef _LPINTERNETSECURITYMANANGER_DEFINED
#define _LPINTERNETSECURITYMANANGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec;

#ifndef __IInternetSecurityManager_INTERFACE_DEFINED__
#define __IInternetSecurityManager_INTERFACE_DEFINED__

/* interface IInternetSecurityManager */
/* [object][unique][uuid] */ 

#define MUTZ_NOSAVEDFILECHECK        0x00000001 // don't check file: for saved file comment
#define MUTZ_ISFILE                  0x00000002 // Assume URL if File, url does not need file://
#define MUTZ_ACCEPT_WILDCARD_SCHEME  0x00000080 // Accept a wildcard scheme
#define MUTZ_ENFORCERESTRICTED       0x00000100 // enforce restricted zone independent of URL
#define MUTZ_RESERVED                0x00000200 // This is same as PUAF_NOSAVEDFILECHECK. However we already have MUTZ_NOSAVEDFILECHECK for this.
#define MUTZ_REQUIRESAVEDFILECHECK   0x00000400 // always check the file for MOTW (overriding FEATURE_UNC_SAVEDFILECHECK)
#define MUTZ_DONT_UNESCAPE           0x00000800 // Do not unescape the url
#define MUTZ_DONT_USE_CACHE          0x00001000 // Do not check the cache
#define MUTZ_FORCE_INTRANET_FLAGS    0x00002000 // Force the intranet flags to be active
#define MUTZ_IGNORE_ZONE_MAPPINGS    0x00004000 // Don't look up the Zone Mappings
// MapUrlToZone returns the zone index given a URL
#define MAX_SIZE_SECURITY_ID 512 // bytes
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0001
    {	PUAF_DEFAULT	= 0,
	PUAF_NOUI	= 0x1,
	PUAF_ISFILE	= 0x2,
	PUAF_WARN_IF_DENIED	= 0x4,
	PUAF_FORCEUI_FOREGROUND	= 0x8,
	PUAF_CHECK_TIFS	= 0x10,
	PUAF_DONTCHECKBOXINDIALOG	= 0x20,
	PUAF_TRUSTED	= 0x40,
	PUAF_ACCEPT_WILDCARD_SCHEME	= 0x80,
	PUAF_ENFORCERESTRICTED	= 0x100,
	PUAF_NOSAVEDFILECHECK	= 0x200,
	PUAF_REQUIRESAVEDFILECHECK	= 0x400,
	PUAF_DONT_USE_CACHE	= 0x1000,
	PUAF_RESERVED1	= 0x2000,
	PUAF_RESERVED2	= 0x4000,
	PUAF_LMZ_UNLOCKED	= 0x10000,
	PUAF_LMZ_LOCKED	= 0x20000,
	PUAF_DEFAULTZONEPOL	= 0x40000,
	PUAF_NPL_USE_LOCKED_IF_RESTRICTED	= 0x80000,
	PUAF_NOUIIFLOCKED	= 0x100000,
	PUAF_DRAGPROTOCOLCHECK	= 0x200000
    } 	PUAF;

typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0002
    {	PUAFOUT_DEFAULT	= 0,
	PUAFOUT_ISLOCKZONEPOLICY	= 0x1
    } 	PUAFOUT;

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed
// This is the wrapper function to conveniently read a custom policy.
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0003
    {	SZM_CREATE	= 0,
	SZM_DELETE	= 0x1
    } 	SZM_FLAGS;

// SetZoneMapping
//    lpszPattern: string denoting a URL pattern
//        Examples of valid patterns:   
//            *://*.msn.com             
//            http://*.sony.co.jp       
//            *://et.msn.com            
//            ftp://157.54.23.41/       
//            https://localsvr          
//            file:\localsvr\share     
//            *://157.54.100-200.*      
//        Examples of invalid patterns: 
//            http://*.lcs.mit.edu      
//            ftp://*                   
//    dwFlags: SZM_FLAGS values         

EXTERN_C const IID IID_IInternetSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ee-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSecuritySite( 
            /* [unique][in] */ IInternetSecurityMgrSite *pSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecuritySite( 
            /* [out] */ IInternetSecurityMgrSite **ppSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZone( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneMapping( 
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneMappings( 
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [unique][in] */ IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [out] */ IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerVtbl;

    interface IInternetSecurityManager
    {
        CONST_VTBL struct IInternetSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManager_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManager_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManager_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManager_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManager_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManager_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManager_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManager_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0035 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETSECURITYMANANGEREX_DEFINED
#define _LPINTERNETSECURITYMANANGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx */
/* [object][unique][uuid] */ 

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed

EXTERN_C const IID IID_IInternetSecurityManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F164EDF1-CC7C-4f0d-9A94-34222625C393")
    IInternetSecurityManagerEx : public IInternetSecurityManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ DWORD *pdwOutFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManagerEx * This,
            /* [unique][in] */ IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManagerEx * This,
            /* [out] */ IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            IInternetSecurityManagerEx * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ DWORD *pdwOutFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerExVtbl;

    interface IInternetSecurityManagerEx
    {
        CONST_VTBL struct IInternetSecurityManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0036 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETSECURITYMANANGEREx2_DEFINED
#define _LPINTERNETSECURITYMANANGEREx2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx2_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx2_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx2 */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IInternetSecurityManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1E50292-A795-4117-8E09-2B560A72AC60")
    IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2( 
            /* [in] */ IUri *pUri,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPWSTR *ppwszMappedUrl,
            /* [out] */ DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2( 
            /* [in] */ IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityIdEx2( 
            /* [in] */ IUri *pUri,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2( 
            /* [in] */ IUri *pUri,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManagerEx2 * This,
            /* [unique][in] */ IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManagerEx2 * This,
            /* [out] */ IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZoneEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ IUri *pUri,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPWSTR *ppwszMappedUrl,
            /* [out] */ DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityIdEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ IUri *pUri,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicyEx2 )( 
            IInternetSecurityManagerEx2 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IInternetSecurityManagerEx2Vtbl;

    interface IInternetSecurityManagerEx2
    {
        CONST_VTBL struct IInternetSecurityManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx2_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx2_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx2_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx2_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx2_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 


#define IInternetSecurityManagerEx2_MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags)	\
    ( (This)->lpVtbl -> MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0037 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec;

#ifndef __IZoneIdentifier_INTERFACE_DEFINED__
#define __IZoneIdentifier_INTERFACE_DEFINED__

/* interface IZoneIdentifier */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IZoneIdentifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cd45f185-1b21-48e2-967b-ead743a8914e")
    IZoneIdentifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [in] */ DWORD dwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoneIdentifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IZoneIdentifier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IZoneIdentifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IZoneIdentifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IZoneIdentifier * This,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            IZoneIdentifier * This,
            /* [in] */ DWORD dwZone);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IZoneIdentifier * This);
        
        END_INTERFACE
    } IZoneIdentifierVtbl;

    interface IZoneIdentifier
    {
        CONST_VTBL struct IZoneIdentifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoneIdentifier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IZoneIdentifier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IZoneIdentifier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IZoneIdentifier_GetId(This,pdwZone)	\
    ( (This)->lpVtbl -> GetId(This,pdwZone) ) 

#define IZoneIdentifier_SetId(This,dwZone)	\
    ( (This)->lpVtbl -> SetId(This,dwZone) ) 

#define IZoneIdentifier_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IZoneIdentifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0038 */
/* [local] */ 

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED
#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED
//This is the interface MSHTML exposes to its clients
//The clients need not pass in a URL to these functions
//since MSHTML maintains the notion of the current URL


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec;

#ifndef __IInternetHostSecurityManager_INTERFACE_DEFINED__
#define __IInternetHostSecurityManager_INTERFACE_DEFINED__

/* interface IInternetHostSecurityManager */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetHostSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")
    IInternetHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetHostSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetHostSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetHostSecurityManager * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetHostSecurityManager * This,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetHostSecurityManagerVtbl;

    interface IInternetHostSecurityManager
    {
        CONST_VTBL struct IInternetHostSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetHostSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetHostSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetHostSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetHostSecurityManager_GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetHostSecurityManager_ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetHostSecurityManager_QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetHostSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0039 */
/* [local] */ 

#endif

// The zone manager maintains policies for a set of standard actions. 
// These actions are identified by integral values (called action indexes)
// specified below.

// Minimum legal value for an action    
#define URLACTION_MIN                                          0x00001000

#define URLACTION_DOWNLOAD_MIN                                 0x00001000
#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001
#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004
#define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004
#define URLACTION_DOWNLOAD_MAX                                 0x000011FF

#define URLACTION_ACTIVEX_MIN                                  0x00001200
#define URLACTION_ACTIVEX_RUN                                  0x00001200
#define URLPOLICY_ACTIVEX_CHECK_LIST                           0x00010000
#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four
#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 //
#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 //
#define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 //
#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 //
#define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205
#define URLACTION_ACTIVEX_NO_WEBOC_SCRIPT                      0x00001206
#define URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION          0x00001207
#define URLACTION_ACTIVEX_OVERRIDE_OPTIN                       0x00001208
#define URLACTION_ACTIVEX_SCRIPTLET_RUN                        0x00001209
#define URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION           0x0000120A //
#define URLACTION_ACTIVEX_CURR_MAX                             0x0000120A
#define URLACTION_ACTIVEX_MAX                                  0x000013ff

#define URLACTION_SCRIPT_MIN                                   0x00001400
#define URLACTION_SCRIPT_RUN                                   0x00001400
#define URLACTION_SCRIPT_JAVA_USE                              0x00001402
#define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405
#define URLACTION_CROSS_DOMAIN_DATA                            0x00001406
#define URLACTION_SCRIPT_PASTE                                 0x00001407
#define URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE                0x00001408
#define URLACTION_SCRIPT_CURR_MAX                              0x00001408
#define URLACTION_SCRIPT_MAX                                   0x000015ff

#define URLACTION_HTML_MIN                                     0x00001600
#define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two
#define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 //
#define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 //
#define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604
#define URLACTION_HTML_JAVA_RUN                                0x00001605 // derive from Java custom policy
#define URLACTION_HTML_USERDATA_SAVE                           0x00001606
#define URLACTION_HTML_SUBFRAME_NAVIGATE                       0x00001607
#define URLACTION_HTML_META_REFRESH                            0x00001608
#define URLACTION_HTML_MIXED_CONTENT                           0x00001609
#define URLACTION_HTML_INCLUDE_FILE_PATH                       0x0000160A
#define URLACTION_HTML_MAX                                     0x000017ff

#define URLACTION_SHELL_MIN                                    0x00001800
#define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800
#define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802
#define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803
#define URLACTION_SHELL_VERB                                   0x00001804
#define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805
#define URLACTION_SHELL_SHELLEXECUTE                           0x00001806
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_EXECUTE_HIGHRISK                       0x00001806
#define URLACTION_SHELL_EXECUTE_MODRISK                        0x00001807
#define URLACTION_SHELL_EXECUTE_LOWRISK                        0x00001808
#define URLACTION_SHELL_POPUPMGR                               0x00001809
#define URLACTION_SHELL_RTF_OBJECTS_LOAD                       0x0000180A
#define URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY             0x0000180B
#define URLACTION_SHELL_EXTENSIONSECURITY                      0x0000180C
#define URLACTION_SHELL_SECURE_DRAGSOURCE                      0x0000180D
#define URLACTION_SHELL_CURR_MAX                               0x0000180D
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_MAX                                    0x000019ff

#define URLACTION_NETWORK_MIN                                  0x00001A00

#define URLACTION_CREDENTIALS_USE                              0x00001A00
#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000
#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000
#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000
#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000

#define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01
#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000
#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000
#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000


#define URLACTION_COOKIES                                      0x00001A02
#define URLACTION_COOKIES_SESSION                              0x00001A03

#define URLACTION_CLIENT_CERT_PROMPT                           0x00001A04

#define URLACTION_COOKIES_THIRD_PARTY                          0x00001A05
#define URLACTION_COOKIES_SESSION_THIRD_PARTY                  0x00001A06

#define URLACTION_COOKIES_ENABLED                              0x00001A10

#define URLACTION_NETWORK_CURR_MAX                             0x00001A10
#define URLACTION_NETWORK_MAX                                  0x00001Bff


#define URLACTION_JAVA_MIN                                     0x00001C00
#define URLACTION_JAVA_PERMISSIONS                             0x00001C00
#define URLPOLICY_JAVA_PROHIBIT                      0x00000000
#define URLPOLICY_JAVA_HIGH                          0x00010000
#define URLPOLICY_JAVA_MEDIUM                        0x00020000
#define URLPOLICY_JAVA_LOW                           0x00030000
#define URLPOLICY_JAVA_CUSTOM                        0x00800000
#define URLACTION_JAVA_CURR_MAX                                0x00001C00
#define URLACTION_JAVA_MAX                                     0x00001Cff


// The following Infodelivery actions should have no default policies
// in the registry.  They assume that no default policy means fall
// back to the global restriction.  If an admin sets a policy per
// zone, then it overrides the global restriction.

#define URLACTION_INFODELIVERY_MIN                           0x00001D00
#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00
#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01
#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02
#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03
#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04
#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05
#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06
#define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06
#define URLACTION_INFODELIVERY_MAX                           0x00001Dff
#define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00
#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05
#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000
#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000
#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000
#define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_BEHAVIOR_MIN                               0x00002000
#define URLACTION_BEHAVIOR_RUN                               0x00002000
#define URLPOLICY_BEHAVIOR_CHECK_LIST                        0x00010000

// The following actions correspond to the Feature options above.
// However, they are NOT in the same order.
#define URLACTION_FEATURE_MIN                                0x00002100
#define URLACTION_FEATURE_MIME_SNIFFING                      0x00002100
#define URLACTION_FEATURE_ZONE_ELEVATION                     0x00002101
#define URLACTION_FEATURE_WINDOW_RESTRICTIONS                0x00002102
#define URLACTION_FEATURE_SCRIPT_STATUS_BAR                  0x00002103
#define URLACTION_FEATURE_FORCE_ADDR_AND_STATUS              0x00002104
#define URLACTION_FEATURE_BLOCK_INPUT_PROMPTS                0x00002105

#define URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN                  0x00002200
#define URLACTION_AUTOMATIC_DOWNLOAD_UI                      0x00002200
#define URLACTION_AUTOMATIC_ACTIVEX_UI                       0x00002201

#define URLACTION_ALLOW_RESTRICTEDPROTOCOLS                0x00002300

// Whether to do the Anti-Phishing check.
#define URLACTION_ALLOW_APEVALUATION                       0x00002301

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
// The following ExpressAPP and XPS actions are trumped by registry in
// case of Internet Explorer upgrade from IE 6.0 which honors registry.
#define URLACTION_WINDOWS_BROWSER_APPLICATIONS             0x00002400
#define URLACTION_XPS_DOCUMENTS                            0x00002401
#define URLACTION_LOOSE_XAML                               0x00002402
#define URLACTION_LOWRIGHTS                                0x00002500
// The following action belong to WinFX Bootstrapper
#define URLACTION_WINFX_SETUP                              0x00002600

#endif //(_WIN32_IE >= _WIN32_IE_IE70)
// For each action specified above the system maintains
// a set of policies for the action. 
// The only policies supported currently are permissions (i.e. is something allowed)
// and logging status. 
// IMPORTANT: If you are defining your own policies don't overload the meaning of the
// loword of the policy. You can use the hiword to store any policy bits which are only
// meaningful to your action.
// For an example of how to do this look at the URLPOLICY_JAVA above

// Permissions 
#define URLPOLICY_ALLOW                0x00
#define URLPOLICY_QUERY                0x01
#define URLPOLICY_DISALLOW             0x03

// Notifications are not done when user already queried.
#define URLPOLICY_NOTIFY_ON_ALLOW      0x10
#define URLPOLICY_NOTIFY_ON_DISALLOW   0x20

// Logging is done regardless of whether user was queried.
#define URLPOLICY_LOG_ON_ALLOW         0x40
#define URLPOLICY_LOG_ON_DISALLOW      0x80

#define URLPOLICY_MASK_PERMISSIONS     0x0f
#define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS)
#define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))


#define URLPOLICY_DONTCHECKDLGBOX     0x100
// The ordinal #'s that define the predefined zones internet explorer knows about. 
// When we support user-defined zones their zone numbers should be between 
// URLZONE_USER_MIN and URLZONE_USER_MAX
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
// Custom policy to query whether the local machine zone
// has been unlocked for current document.
EXTERN_C const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED; 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGER_DEFINED
#define _LPINTERNETZONEMANAGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec;

#ifndef __IInternetZoneManager_INTERFACE_DEFINED__
#define __IInternetZoneManager_INTERFACE_DEFINED__

/* interface IInternetZoneManager */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetZoneManager *LPURLZONEMANAGER;

typedef 
enum tagURLZONE
    {	URLZONE_INVALID	= -1,
	URLZONE_PREDEFINED_MIN	= 0,
	URLZONE_LOCAL_MACHINE	= 0,
	URLZONE_INTRANET	= ( URLZONE_LOCAL_MACHINE + 1 ) ,
	URLZONE_TRUSTED	= ( URLZONE_INTRANET + 1 ) ,
	URLZONE_INTERNET	= ( URLZONE_TRUSTED + 1 ) ,
	URLZONE_UNTRUSTED	= ( URLZONE_INTERNET + 1 ) ,
	URLZONE_PREDEFINED_MAX	= 999,
	URLZONE_USER_MIN	= 1000,
	URLZONE_USER_MAX	= 10000
    } 	URLZONE;

// Enhanced Security Configuration zone mapping flag for IInternetSecurityManager::SetZoneMapping
#define URLZONE_ESC_FLAG     0x100
typedef 
enum tagURLTEMPLATE
    {	URLTEMPLATE_CUSTOM	= 0,
	URLTEMPLATE_PREDEFINED_MIN	= 0x10000,
	URLTEMPLATE_LOW	= 0x10000,
	URLTEMPLATE_MEDLOW	= 0x10500,
	URLTEMPLATE_MEDIUM	= 0x11000,
	URLTEMPLATE_MEDHIGH	= 0x11500,
	URLTEMPLATE_HIGH	= 0x12000,
	URLTEMPLATE_PREDEFINED_MAX	= 0x20000
    } 	URLTEMPLATE;


enum __MIDL_IInternetZoneManager_0001
    {	MAX_ZONE_PATH	= 260,
	MAX_ZONE_DESCRIPTION	= 200
    } ;
typedef /* [public] */ 
enum __MIDL_IInternetZoneManager_0002
    {	ZAFLAGS_CUSTOM_EDIT	= 0x1,
	ZAFLAGS_ADD_SITES	= 0x2,
	ZAFLAGS_REQUIRE_VERIFICATION	= 0x4,
	ZAFLAGS_INCLUDE_PROXY_OVERRIDE	= 0x8,
	ZAFLAGS_INCLUDE_INTRANET_SITES	= 0x10,
	ZAFLAGS_NO_UI	= 0x20,
	ZAFLAGS_SUPPORTS_VERIFICATION	= 0x40,
	ZAFLAGS_UNC_AS_INTRANET	= 0x80,
	ZAFLAGS_DETECT_INTRANET	= 0x100,
	ZAFLAGS_USE_LOCKED_ZONES	= 0x10000,
	ZAFLAGS_VERIFY_TEMPLATE_SETTINGS	= 0x20000,
	ZAFLAGS_NO_CACHE	= 0x40000
    } 	ZAFLAGS;

typedef struct _ZONEATTRIBUTES
    {
    ULONG cbSize;
    WCHAR szDisplayName[ 260 ];
    WCHAR szDescription[ 200 ];
    WCHAR szIconPath[ 260 ];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
    } 	ZONEATTRIBUTES;

typedef struct _ZONEATTRIBUTES *LPZONEATTRIBUTES;

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Sets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes as above.
// Returns S_OK or ??? if failed to write the zone attributes.
/* Registry Flags

    When reading, default behavior is:
        If HKLM allows override and HKCU value exists
            Then use HKCU value
            Else use HKLM value
    When writing, default behavior is same as HKCU
        If HKLM allows override
           Then Write to HKCU
           Else Fail
*/
typedef 
enum _URLZONEREG
    {	URLZONEREG_DEFAULT	= 0,
	URLZONEREG_HKLM	= ( URLZONEREG_DEFAULT + 1 ) ,
	URLZONEREG_HKCU	= ( URLZONEREG_HKLM + 1 ) 
    } 	URLZONEREG;

// Gets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the callee allocated buffer for the policy byte blob; caller is
//   responsible for freeing this buffer eventually.
// pcbPolicy is the size of the byte blob returned.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced).
// Sets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.  
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the caller allocated buffer for the policy byte blob.
// pcbPolicy is the size of the byte blob to be set.
// dwRegFlags determines if HTCU or HKLM is set.
// Returns S_OK or ??? if failed to write the zone custom policy.
// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ef-baf9-11ce-8c82-00aa004ba90b")
    IInternetZoneManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateZoneEnumerator( 
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneAt( 
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyZoneEnumerator( 
            /* [in] */ DWORD dwEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTemplatePoliciesToZone( 
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetZoneManagerVtbl;

    interface IInternetZoneManager
    {
        CONST_VTBL struct IInternetZoneManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManager_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManager_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManager_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManager_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManager_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManager_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0040 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGEREX_DEFINED
#define _LPINTERNETZONEMANAGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx */
/* [unique][uuid][object][local] */ 

// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// dwFlags determine which registry policies are accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C23339-8E06-431e-9BF4-7E711C085648")
    IInternetZoneManagerEx : public IInternetZoneManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetZoneManagerExVtbl;

    interface IInternetZoneManagerEx
    {
        CONST_VTBL struct IInternetZoneManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0041 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED
#define _LPINTERNETZONEMANAGEREX2_DEFINED
#define SECURITY_IE_STATE_GREEN 0x00000000
#define SECURITY_IE_STATE_RED   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx2_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx2_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx2 */
/* [unique][uuid][object][local] */ 

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Can also verify template settings by matching current settings with security template

EXTERN_C const IID IID_IInternetZoneManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")
    IInternetZoneManagerEx2 : public IInternetZoneManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributesEx( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneSecurityState( 
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIESecurityState( 
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FixUnsecureSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributesEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneSecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered);
        
        HRESULT ( STDMETHODCALLTYPE *GetIESecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache);
        
        HRESULT ( STDMETHODCALLTYPE *FixUnsecureSettings )( 
            IInternetZoneManagerEx2 * This);
        
        END_INTERFACE
    } IInternetZoneManagerEx2Vtbl;

    interface IInternetZoneManagerEx2
    {
        CONST_VTBL struct IInternetZoneManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx2_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx2_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx2_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx2_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx2_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 


#define IInternetZoneManagerEx2_GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered)	\
    ( (This)->lpVtbl -> GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered) ) 

#define IInternetZoneManagerEx2_GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache)	\
    ( (This)->lpVtbl -> GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache) ) 

#define IInternetZoneManagerEx2_FixUnsecureSettings(This)	\
    ( (This)->lpVtbl -> FixUnsecureSettings(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0042 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
EXTERN_C const IID CLSID_SoftDistExt;  
#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001
#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008


#define SOFTDIST_ADSTATE_NONE                0x00000000
#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001
#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002
#define SOFTDIST_ADSTATE_INSTALLED           0x00000003

typedef struct _tagCODEBASEHOLD
    {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
    } 	CODEBASEHOLD;

typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
    } 	SOFTDISTINFO;

typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec;

#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

/* interface ISoftDistExt */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISoftDistExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")
    ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist( 
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftDistExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftDistExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftDistExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftDistExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoftDist )( 
            ISoftDistExt * This,
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncInstallDistributionUnit )( 
            ISoftDistExt * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh);
        
        END_INTERFACE
    } ISoftDistExtVtbl;

    interface ISoftDistExt
    {
        CONST_VTBL struct ISoftDistExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftDistExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftDistExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftDistExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)	\
    ( (This)->lpVtbl -> ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi) ) 

#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetFirstCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetNextCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)	\
    ( (This)->lpVtbl -> AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftDistExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0043 */
/* [local] */ 

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi );
STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );
#endif
#ifndef _LPCATALOGFILEINFO_DEFINED
#define _LPCATALOGFILEINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec;

#ifndef __ICatalogFileInfo_INTERFACE_DEFINED__
#define __ICatalogFileInfo_INTERFACE_DEFINED__

/* interface ICatalogFileInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICatalogFileInfo *LPCATALOGFILEINFO;


EXTERN_C const IID IID_ICatalogFileInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("711C7600-6B48-11d1-B403-00AA00B92AF1")
    ICatalogFileInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogFile( 
            /* [out] */ LPSTR *ppszCatalogFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJavaTrust( 
            /* [out] */ void **ppJavaTrust) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogFileInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogFileInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogFileInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogFileInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogFile )( 
            ICatalogFileInfo * This,
            /* [out] */ LPSTR *ppszCatalogFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetJavaTrust )( 
            ICatalogFileInfo * This,
            /* [out] */ void **ppJavaTrust);
        
        END_INTERFACE
    } ICatalogFileInfoVtbl;

    interface ICatalogFileInfo
    {
        CONST_VTBL struct ICatalogFileInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogFileInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogFileInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogFileInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogFileInfo_GetCatalogFile(This,ppszCatalogFile)	\
    ( (This)->lpVtbl -> GetCatalogFile(This,ppszCatalogFile) ) 

#define ICatalogFileInfo_GetJavaTrust(This,ppJavaTrust)	\
    ( (This)->lpVtbl -> GetJavaTrust(This,ppJavaTrust) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogFileInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0044 */
/* [local] */ 

#endif
#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;

#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

/* interface IDataFilter */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IDataFilter *LPDATAFILTER;


EXTERN_C const IID IID_IDataFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
    IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoEncode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDecode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel( 
            /* [in] */ DWORD dwEncLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoEncode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DoDecode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncodingLevel )( 
            IDataFilter * This,
            /* [in] */ DWORD dwEncLevel);
        
        END_INTERFACE
    } IDataFilterVtbl;

    interface IDataFilter
    {
        CONST_VTBL struct IDataFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_SetEncodingLevel(This,dwEncLevel)	\
    ( (This)->lpVtbl -> SetEncodingLevel(This,dwEncLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0045 */
/* [local] */ 

#endif
#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED
typedef struct _tagPROTOCOLFILTERDATA
    {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
    } 	PROTOCOLFILTERDATA;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;

#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

/* interface IEncodingFilterFactory */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO
    {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
    } 	DATAINFO;


EXTERN_C const IID IID_IEncodingFilterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
    IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindBestFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncodingFilterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncodingFilterFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncodingFilterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncodingFilterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindBestFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF);
        
        END_INTERFACE
    } IEncodingFilterFactoryVtbl;

    interface IEncodingFilterFactory
    {
        CONST_VTBL struct IEncodingFilterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEncodingFilterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEncodingFilterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)	\
    ( (This)->lpVtbl -> FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF) ) 

#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)	\
    ( (This)->lpVtbl -> GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEncodingFilterFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0046 */
/* [local] */ 

#endif
#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED
// Logging-specific apis
BOOL WINAPI IsLoggingEnabledA(IN LPCSTR  pszUrl);                    
BOOL WINAPI IsLoggingEnabledW(IN LPCWSTR  pwszUrl);                  
#ifdef UNICODE                                                       
#define IsLoggingEnabled         IsLoggingEnabledW                   
#else                                                                
#define IsLoggingEnabled         IsLoggingEnabledA                   
#endif // !UNICODE                                                   
typedef struct _tagHIT_LOGGING_INFO
    {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
    } 	HIT_LOGGING_INFO;

typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

BOOL WINAPI WriteHitLogging(IN LPHIT_LOGGING_INFO lpLogginginfo);    
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
    {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
    } ;
EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; 
#endif
#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;

#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

/* interface IWrappedProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWrappedProtocol *LPIWRAPPEDPROTOCOL;


EXTERN_C const IID IID_IWrappedProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
    IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWrapperCode( 
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrappedProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrappedProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrappedProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrappedProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWrapperCode )( 
            IWrappedProtocol * This,
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWrappedProtocolVtbl;

    interface IWrappedProtocol
    {
        CONST_VTBL struct IWrappedProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrappedProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWrappedProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWrappedProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved)	\
    ( (This)->lpVtbl -> GetWrapperCode(This,pnCode,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWrappedProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0047 */
/* [local] */ 

#endif
#ifndef _LPWININETCACHEACCESS_DEFINED
#define _LPWININETCACHEACCESS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec;

#ifndef __IWinInetCacheAccess_INTERFACE_DEFINED__
#define __IWinInetCacheAccess_INTERFACE_DEFINED__

/* interface IWinInetCacheAccess */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheAccess *LPWININETCACHEACCESS;


EXTERN_C const IID IID_IWinInetCacheAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26387D06-2768-4d06-8918-2D45807A9902")
    IWinInetCacheAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheFilename( 
            /* [in] */ LPCWSTR pwzNewCacheFilePath,
            /* [out] */ DWORD *pdwWinInetError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreventCacheEntryWrite( 
            /* [out] */ DWORD *pdwWinInetError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheFilename )( 
            IWinInetCacheAccess * This,
            /* [in] */ LPCWSTR pwzNewCacheFilePath,
            /* [out] */ DWORD *pdwWinInetError);
        
        HRESULT ( STDMETHODCALLTYPE *PreventCacheEntryWrite )( 
            IWinInetCacheAccess * This,
            /* [out] */ DWORD *pdwWinInetError);
        
        END_INTERFACE
    } IWinInetCacheAccessVtbl;

    interface IWinInetCacheAccess
    {
        CONST_VTBL struct IWinInetCacheAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheAccess_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheAccess_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheAccess_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheAccess_SetCacheFilename(This,pwzNewCacheFilePath,pdwWinInetError)	\
    ( (This)->lpVtbl -> SetCacheFilename(This,pwzNewCacheFilePath,pdwWinInetError) ) 

#define IWinInetCacheAccess_PreventCacheEntryWrite(This,pdwWinInetError)	\
    ( (This)->lpVtbl -> PreventCacheEntryWrite(This,pdwWinInetError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheAccess_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0048 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ STGMEDIUM *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IProxyInfo_QueryInfo_Proxy( 
    IProxyInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IProxyInfo_QueryInfo_Stub( 
    IProxyInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\userdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for userdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __userdata_h__
#define __userdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMVAUserData_FWD_DEFINED__
#define __IWMVAUserData_FWD_DEFINED__
typedef interface IWMVAUserData IWMVAUserData;
#endif 	/* __IWMVAUserData_FWD_DEFINED__ */


#ifndef __IWMVBIDataConfig_FWD_DEFINED__
#define __IWMVBIDataConfig_FWD_DEFINED__
typedef interface IWMVBIDataConfig IWMVBIDataConfig;
#endif 	/* __IWMVBIDataConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_userdata_0000_0000 */
/* [local] */ 

typedef 
enum WMVAUserDataLevel
    {	levelSequence	= 1,
	levelEntryPoint	= 2,
	levelFrame	= 4,
	levelField	= 8,
	levelSlice	= 16
    } 	UserDataLevel;

typedef void ( *PFNCB )( 
    BYTE *pbData,
    DWORD dwLength,
    UserDataLevel udLevel,
    DWORD dwContext);



extern RPC_IF_HANDLE __MIDL_itf_userdata_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_userdata_0000_0000_v0_0_s_ifspec;

#ifndef __IWMVAUserData_INTERFACE_DEFINED__
#define __IWMVAUserData_INTERFACE_DEFINED__

/* interface IWMVAUserData */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IWMVAUserData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1793D585-35BF-49F9-8F84-39BD249A5B5A")
    IWMVAUserData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [in] */ PFNCB pfnCallback,
            /* [in] */ DWORD dwContext,
            /* [in] */ DWORD dwLevelMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVAUserDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVAUserData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVAUserData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVAUserData * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterCallback )( 
            IWMVAUserData * This,
            /* [in] */ PFNCB pfnCallback,
            /* [in] */ DWORD dwContext,
            /* [in] */ DWORD dwLevelMask);
        
        END_INTERFACE
    } IWMVAUserDataVtbl;

    interface IWMVAUserData
    {
        CONST_VTBL struct IWMVAUserDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVAUserData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVAUserData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVAUserData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVAUserData_RegisterCallback(This,pfnCallback,dwContext,dwLevelMask)	\
    ( (This)->lpVtbl -> RegisterCallback(This,pfnCallback,dwContext,dwLevelMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVAUserData_INTERFACE_DEFINED__ */


#ifndef __IWMVBIDataConfig_INTERFACE_DEFINED__
#define __IWMVBIDataConfig_INTERFACE_DEFINED__

/* interface IWMVBIDataConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVBIDataConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CFF19C8-334D-4469-B5DD-042E89A09172")
    IWMVBIDataConfig : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLevelMask( 
            /* [in] */ DWORD dwLevelMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevelMask( 
            /* [in] */ DWORD *pdwLevelMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVBIDataConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVBIDataConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVBIDataConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVBIDataConfig * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLevelMask )( 
            IWMVBIDataConfig * This,
            /* [in] */ DWORD dwLevelMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevelMask )( 
            IWMVBIDataConfig * This,
            /* [in] */ DWORD *pdwLevelMask);
        
        END_INTERFACE
    } IWMVBIDataConfigVtbl;

    interface IWMVBIDataConfig
    {
        CONST_VTBL struct IWMVBIDataConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVBIDataConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVBIDataConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVBIDataConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVBIDataConfig_SetLevelMask(This,dwLevelMask)	\
    ( (This)->lpVtbl -> SetLevelMask(This,dwLevelMask) ) 

#define IWMVBIDataConfig_GetLevelMask(This,pdwLevelMask)	\
    ( (This)->lpVtbl -> GetLevelMask(This,pdwLevelMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVBIDataConfig_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\uuids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types
// for standard media types, and also class ids for well-known components.
#ifndef __UUIDS__
#define __UUIDS__


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 28e3a27d-5f48-4700-913b-4986608c8a8b
OUR_GUID_ENTRY(MEDIATYPE_VideoBuffered,
0x28e3a27d, 0x5f48, 0x4700, 0x91, 0x3b, 0x49, 0x86, 0x60, 0x8c, 0x8a, 0x8b)

// 451efe59-3bbd-43c7-9e67-511a835fa7f1
OUR_GUID_ENTRY(MEDIATYPE_AudioBuffered,
0x451efe59, 0x3bbd, 0x43c7, 0x9e, 0x67, 0x51, 0x1a, 0x83, 0x5f, 0xa7, 0xf1)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36313259-0000-0010-8000-00AA00389B71  'YV16' ==  MEDIASUBTYPE_YV16
OUR_GUID_ENTRY(MEDIASUBTYPE_YV16,
0x36315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595549-0000-0010-8000-00AA00389B71 'IUYV' == MEDIASUBTYPE_IUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_IUYV,
0x56595549, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV12' ==  MEDIASUBTYPE_NV12
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,
0x3231564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30323449-0000-0010-8000-00AA00389B71  'I420' ==  MEDIASUBTYPE_I420
OUR_GUID_ENTRY(MEDIASUBTYPE_I420,
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' ==  MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )

// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555) )


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71     MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// CAC15F74-A3F8-4eb6-9317-A5709618E415
OUR_GUID_ENTRY(MEDIASUBTYPE_Midi,
0xcac15f74, 0xa3f8, 0x4eb6, 0x93, 0x17, 0xa5, 0x70, 0x96, 0x18, 0xe4, 0x15)

// --- class IDs ---


#ifndef IID_ICutListElement_Defined
OUR_GUID_ENTRY(IID_IAMCutListElement,
0xCDE29520,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)
#define IID_ICutListElement_Defined

OUR_GUID_ENTRY(IID_IAMFileCutListElement,
0xF0947070,0x276C,0x11d0,0x83,0x16,0x00,0x20,0xAF,0x11,0xC0,0x10)

OUR_GUID_ENTRY(IID_IAMVideoCutListElement,
0xCDE29522,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

OUR_GUID_ENTRY(IID_IAMAudioCutListElement,
0xCDE29524,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)
#endif

// the cutlist source filter
OUR_GUID_ENTRY(CLSID_CutListSource,
0xa5ea8d20, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IStandardCutList,
0xa5ea8d29, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IFileClip,
0xa5ea8d2a, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_ICutListGraphBuilder,
0xa5ea8d2c, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListGraphBuilder,
0xa5ea8d2f, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_SimpleCutList,
0xa5ea8d30, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_VideoFileClip,
0xa5ea8d31, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_AudioFileClip,
0xa5ea8d32, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListCacheMemory,
0xa5ea8d33, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

// end cut list stuff


// {F80B6E95-B55A-4619-AEC4-A10EAEDE980C}   Base Video Capture Filter
OUR_GUID_ENTRY(CLSID_VideoCapture,
0xf80b6e95, 0xb55a, 0x4619, 0xae, 0xc4, 0xa1, 0xe, 0xae, 0xde, 0x98, 0xc)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

#ifdef UNDER_CE

// f4ac1a50-b69e-11d0-88b8-08002be53f4a           Video CD Source filter
OUR_GUID_ENTRY(CLSID_VideoCDSource,
0xf4ac1a50, 0xb69e, 0x11d0, 0x88, 0xb8, 0x08, 0x00, 0x2b, 0xe5, 0x3f, 0x4a)

// d41fa1a0-fc5b-11cf-a66b-00aa00bf96aa           Video CD Proxy filter
OUR_GUID_ENTRY(CLSID_VideoCDProxy,
0xd41fa1a0, 0xfc5b, 0x11cf, 0xa6, 0x6b, 0x00, 0xaa, 0x00, 0xbf, 0x96, 0xaa)

// 48319150-a6fa-11d0-88b8-08002be53f4a           Video CD Manager
OUR_GUID_ENTRY(CLSID_VideoCDManager,
0x48319150, 0xa6fa, 0x11d0, 0x88, 0xb8, 0x08, 0x00, 0x2b, 0xe5, 0x3f, 0x4a)

// {6949148B-D79D-4f29-A1CF-2B8E9B675F32}         Generic Streamer
OUR_GUID_ENTRY(CLSID_GenericStreamer,
0x6949148b, 0xd79d, 0x4f29, 0xa1, 0xcf, 0x2b, 0x8e, 0x9b, 0x67, 0x5f, 0x32)

#endif // UNDER_CE

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG-1 splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 3AE86B20-7BE8-11D1-ABE6-00A0C905F375           MPEG-2 splitter
OUR_GUID_ENTRY(CLSID_MPEG2Splitter,
0x3AE86B20, 0x7BE8, 0x11D1, 0xAB, 0xE6, 0x00, 0xA0, 0xC9, 0x05, 0xF3, 0x75)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// {38BE3000-DBF4-11d0-860E-00A024CFEF6D}         MP3 decoder
OUR_GUID_ENTRY(CLSID_Mp3Dec,
0x38be3000, 0xdbf4, 0x11d0, 0x86, 0xe, 0x0, 0xa0, 0x24, 0xcf, 0xef, 0x6d)

// 301056D0-6DFF-11D2-9EEB-006008039E37           MJPEG decoder
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056D0, 0x6DFF, 0x11D2, 0x9E, 0xEB, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 )

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)


// {D51BD5A1-7548-11cf-A520-0080C77EF58A}
OUR_GUID_ENTRY(CLSID_WAVEParser,
0xd51bd5a1, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// {D51BD5A2-7548-11cf-A520-0080C77EF58A}
OUR_GUID_ENTRY(CLSID_MIDIParser,
0xd51bd5a2, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// {487B7222-6A78-4ebd-840D-31413BCACDC8}
OUR_GUID_ENTRY(CLSID_MIDISynth,
0x487b7222, 0x6a78, 0x4ebd, 0x84, 0xd, 0x31, 0x41, 0x3b, 0xca, 0xcd, 0xc8)

// {4B0E5CCC-625A-11d3-84AD-00C04F68EB0F}
OUR_GUID_ENTRY(CLSID_DMFilter,
0x4b0e5ccc, 0x625a, 0x11d3, 0x84, 0xad, 0x0, 0xc0, 0x4f, 0x68, 0xeb, 0xf)

// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// D3588AB1-0781-11ce-B03A-0020AF0BA770           AVIFile-based writer
OUR_GUID_ENTRY(CLSID_AVIDocWriter,
0xd3588ab1, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio capture
OUR_GUID_ENTRY(CLSID_AudioCapture,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {5f2759c0-7685-11cf-8b23-00805f6cef60}    IAMovie plug-in distributor
OUR_GUID_ENTRY(CLSID_AMovie,
0x5f2759c0, 0x7685, 0x11cf, 0x8b, 0x23, 0x00, 0x80, 0x5f, 0x6c, 0xef, 0x60)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {F560AE42-6CDD-11d1-ADE2-0000F8754B99}     ASF mux filter
OUR_GUID_ENTRY(CLSID_AsfMux,
0xf560ae42, 0x6cdd, 0x11d1, 0xad, 0xe2, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)


// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {64CCCAD6-BA96-4d94-94C1-B6EF9D50E02D}
OUR_GUID_ENTRY(CLSID_VBIDataRenderer,
0x64cccad6, 0xba96, 0x4d94, 0x94, 0xc1, 0xb6, 0xef, 0x9d, 0x50, 0xe0, 0x2d)

// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B         Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {8FA61F8C-86E5-4885-8123-A7DB54A4A185}
OUR_GUID_ENTRY(CLSID_FilterGraphCache, 
0x8fa61f8c, 0x86e5, 0x4885, 0x81, 0x23, 0xa7, 0xdb, 0x54, 0xa4, 0xa1, 0x85)

// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// BADC3D7C-97C9-424a-907B-00982350B3C1
OUR_GUID_ENTRY(CLSID_PropertyBag,
0xbadc3d7c, 0x97c9, 0x424a, 0x90, 0x7b, 0x0, 0x98, 0x23, 0x50, 0xb3, 0xc1)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// 94297043-BD82-4DFD-B0DE-8177739C6D20        DMO Wrapper Filter
OUR_GUID_ENTRY(CLSID_DMOWrapperFilter,
0x94297043, 0xbd82, 0x4dfd, 0xb0, 0xde, 0x81, 0x77, 0x73, 0x9c, 0x6d, 0x20)

// 4FACBBA1-FFD8-4cd7-8228-61E2F65CB1AE        WMV/MPG4 Decoder Filter
OUR_GUID_ENTRY(CLSID_WMVDec,
0x4facbba1, 0xffd8, 0x4cd7, 0x82, 0x28, 0x61, 0xe2, 0xf6, 0x5c, 0xb1, 0xae)

// 32003718-b4f9-4bd5-ac2f-7e11b079079d
OUR_GUID_ENTRY(CLSID_BufferingFilter,
0x32003718, 0xb4f9, 0x4bd5, 0xac, 0x2f, 0x7e, 0x11, 0xb0, 0x79, 0x07, 0x9d)

//==========================================================================;
// Class definitions of all WMT filters.
//==========================================================================;

// B9D1F321-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFACMHandler,
0xb9d1f321, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B9D1F322-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFICMHandler,
0xb9d1f322, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B9D1F323-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFURLHandler,
0xb9d1f323, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// 6B6D0800-9ADA-11d0-A520-00A0D10129C0
OUR_GUID_ENTRY(CLSID_NetShowSource,
0x6b6d0800, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0)

// 640999A2-A946-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_NSCFile,
0x640999a2, 0xa946, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// D51BD5AE-7548-11cf-A520-0080C77EF58A
OUR_GUID_ENTRY(CLSID_XMLPlaylist,
0xd51bd5ae, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// 4B428940-263C-11d1-A520-000000000000
OUR_GUID_ENTRY(CLSID_URLGrabber,
0x4b428940, 0x263c, 0x11d1, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B61BE100-5B4E-11CF-A8FD-00805F5C442B
OUR_GUID_ENTRY(CLSID_AsfXStreamTypeJpegJfifVideo,
0xb61be100,0x5b4e,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b)

// 3b907DE0-E415-11CF-A917-00805F5C442B
OUR_GUID_ENTRY(CLSID_AsfXStreamTypeDegradableJpeg,
0x35907de0,0xe415,0x11cf,0xa9,0x17,0x00,0x80,0x5f,0x5c,0x44,0x2b)

// B9D1F325-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFDJPEGHandler,
0xb9d1f325, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B9D1F324-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFJPEGHandler,
0xb9d1f324, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// A98C8400-4181-11d1-A520-00A0D10129C0
OUR_GUID_ENTRY(CLSID_M3UParser,
0xa98c8400, 0x4181, 0x11d1, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0)

// 640999A1-A946-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASXFile2,
0x640999a1, 0xa946, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B9D1F32E-C401-11D0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFEmbeddedFileHandler,
0xb9d1f32e, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// B9D1F320-C401-11d0-A520-000000000000
OUR_GUID_ENTRY(CLSID_ASFDibHandler,
0xb9d1f320, 0xc401, 0x11d0, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)

// 63F8AA94-E2B9-11d0-ADF6-00C04FB66DAD
OUR_GUID_ENTRY(CLSID_NSMultiplexer,
0x63f8aa94, 0xe2b9, 0x11d0, 0xad, 0xf6, 0x0, 0xc0, 0x4f, 0xb6, 0x6d, 0xad)


// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

#include <ddrawguids.h>

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

///////////////////////////////////////////////////////////////////////////

// {B8E8BD60-0BFE-11d0-AF91-00AA00B67A42}
OUR_GUID_ENTRY(IID_IIPDVDec,
0xb8e8bd60, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {A0025E90-E45B-11D1-ABE9-00A0C905F375}
OUR_GUID_ENTRY(CLSID_OverlayMixer2,
0xa0025e90, 0xe45b, 0x11d1, 0xab, 0xe9, 0x00, 0xa0, 0xc9,0x05, 0xf3, 0x75)

// 48025243-2d39-11ce-875d-00608cb78066
OUR_GUID_ENTRY(CLSID_ScriptCommandRenderer,
0x48025243, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 48025244-2d39-11ce-875d-00608cb78066
OUR_GUID_ENTRY(IID_IScriptCommandRenderer,
0x48025244, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {D51BD5A5-7548-11cf-A520-0080C77EF58A}
OUR_GUID_ENTRY(CLSID_FileRend,
0xd51bd5A5, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// {D51BD5A3-7548-11cf-A520-0080C77EF58A}
OUR_GUID_ENTRY(CLSID_MultFile,
0xd51bd5a3, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// ------------------------------------------------------------------
// ASF Writer
// ------------------------------------------------------------------

// 4f4ba16c-ccb0-4d23-b1e8-672c7dfe4a02
OUR_GUID_ENTRY(CLSID_ASFWriter,
0x4f4ba16c, 0xccb0, 0x4d23, 0xb1, 0xe8, 0x67, 0x2c, 0x7d, 0xfe, 0x4a, 0x02)


// ------------------------------------------------------------------
// Image Sink Filter
// ------------------------------------------------------------------

// 1d4d3676-96ef-4cd7-a3d7-07fac0d0c585
OUR_GUID_ENTRY(CLSID_IMGSinkFilter,
0x1d4d3676, 0x96ef, 0x4cd7, 0xa3, 0xd7, 0x07, 0xfa, 0xc0, 0xd0, 0xc5, 0x85)

//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//


// c830acbd-ab07-492f-8852-45b6987c2979
OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
0xc830acbd, 0xab07, 0x492f, 0x88, 0x52, 0x45, 0xb6, 0x98, 0x7c, 0x29, 0x79)
/*
// e46a9787-2b71-444d-a4b5-1fab7b708d6a
OUR_GUID_ENTRY(IID_IVideoFrameStep,
0xe46a9787, 0x2b71, 0x444d, 0xa4, 0xb5, 0x1f, 0xab, 0x7b, 0x70, 0x8d, 0x6a)
*/

// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {06b32aee-77da-484b-973b-5d64f47201b0}
OUR_GUID_ENTRY(CLSID_VideoMixer,
0x06b32aee, 0x77da, 0x484b, 0x97, 0x3b, 0x5d, 0x64, 0xf4, 0x72, 0x01, 0xb0)

// {7D8AA343-6E63-4663-BE90-6B80F66540A3}
OUR_GUID_ENTRY(CLSID_ImageSynchronization,
0x7D8AA343, 0x6E63, 0x4663, 0xBE, 0x90, 0x6B, 0x80, 0xF6, 0x65, 0x40, 0xA3)

// -------------------------------------------------------------------------
// Restricted FilterGraph CLSID
// -------------------------------------------------------------------------
//{5BC2683F-DED9-46e5-96AE-F4046CA518C9}
OUR_GUID_ENTRY(CLSID_RestrictedFilterGraph,
0x5BC2683F, 0xDED9, 0x46e5, 0x96, 0xAE, 0xF4, 0x04, 0x6C, 0xA5, 0x18, 0xC9)

#undef OUR_GUID_ENTRY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\use_ansi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*
*Purpose:
*       Does nothing. Placeholder for compatibility with VC++.
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP
#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\usbclient.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name: 

    usbclient.c

Abstract:

    Common USB Client Driver Interface

--*/

#ifndef _USBCLIENT_
#define _USBCLIENT_

#include <windows.h>
#include <usbdi.h>

#define USB_ERROR  DWORD
#define PUSB_ERROR LPDWORD

#define ONE_FRAME_PERIOD 1L // msec

// steal a debug zone for the client
#define ZONE_USBCLIENT DEBUGZONE(15)

#ifdef __cplusplus
extern "C" {
#endif

BOOL
AbortTransfer(
    LPCUSB_FUNCS   pUsbFuncs,
    USB_TRANSFER   hTransfer,
    DWORD          dwFlags
    );

BOOL
CloseTransferHandle(
    LPCUSB_FUNCS   UsbFuncs,
    USB_TRANSFER   hTransfer
    );

DWORD
ClearOrSetFeature(
    LPCUSB_FUNCS              UsbFuncs,
    HANDLE                    hUsbDevice,
    LPTRANSFER_NOTIFY_ROUTINE NotifyRoutine,
    PVOID                     NotifyContext,
    DWORD                     dwFlags, 
    WORD                      wFeature,
    UCHAR                     bIndex,
    DWORD                     dwTimeout,
    BOOL                      bSet
    );

DWORD
DefaultTransferComplete(
   PVOID    Context
   );

DWORD
GetStatus(
    LPCUSB_FUNCS              pUsbFuncs,
    HANDLE                    hUsbDevice,
    LPTRANSFER_NOTIFY_ROUTINE NotifyRoutine,
    PVOID                     NotifyContext,
    DWORD                     dwFlags,
    UCHAR                     bIndex,
    LPWORD                    lpwStatus,
    DWORD                     dwTimeout
    );

BOOL
GetTransferStatus(
    LPCUSB_FUNCS   UsbFuncs,
    USB_TRANSFER   hTransfer,
    LPDWORD        pBytesTransferred,   
    PUSB_ERROR     pUsbError
    );

DWORD
IssueBulkTransfer( 
   LPCUSB_FUNCS               UsbFuncs,
   USB_PIPE                   hPipe,
   LPTRANSFER_NOTIFY_ROUTINE  NotifyRoutine,
   PVOID                      NotifyContext,
   DWORD                      Flags,
   LPVOID                     pBuffer,
   ULONG                      PhysAddr,
   DWORD                      BufferLength,
   LPDWORD                    pBytesTransferred,
   DWORD                      dwTimeout,
   PUSB_ERROR                 pUsbRc
   );

DWORD
IssueInterruptTransfer( 
   LPCUSB_FUNCS               UsbFuncs,
   USB_PIPE                   hPipe,
   LPTRANSFER_NOTIFY_ROUTINE  NotifyRoutine,
   PVOID                      NotifyContext,
   DWORD                      Flags,
   LPVOID                     pBuffer,
   ULONG                      PhysAddr,
   DWORD                      BufferLength,
   LPDWORD                    pBytesTransferred,
   DWORD                      dwTimeout,
   PUSB_ERROR                 pUsbRc
   );

DWORD
IssueVendorTransfer(
   LPCUSB_FUNCS               UsbFuncs,
   HANDLE                     hUsbDevice,
   LPTRANSFER_NOTIFY_ROUTINE  NotifyRoutine,
   PVOID                      NotifyContext,
   DWORD                      Flags,
   PUSB_DEVICE_REQUEST        pControlHeader,
   LPVOID                     pBuf,
   ULONG                      PhysAddr,
   LPDWORD                    pBytesTransferred,
   DWORD                      dwTimeout,
   PUSB_ERROR                 pUsbRc
   );

DWORD
ResetDefaultEndpoint(
    LPCUSB_FUNCS   UsbFuncs,
    HANDLE         hUsbDevice
    );

DWORD
ResetBulkEndpoint(
    LPCUSB_FUNCS              pUsbFuncs,
    HANDLE                    hUsbDevice,
    USB_PIPE                  hPipe,
    LPTRANSFER_NOTIFY_ROUTINE NotifyRoutine,
    PVOID                     NotifyContext,
    UCHAR                     bIndex,
    DWORD                     dwTimeout
    );

BOOL
ResetPipe(
    LPCUSB_FUNCS    pUsbFuncs,
    USB_PIPE        hPipe,
    DWORD           dwFlags
    );
// Util function

//
// Registry Value Descriptor
//
typedef struct _REG_VALUE_DESCR {
    LPWSTR Name; // Value Name
    DWORD  Type; // Value Type
    DWORD  Size; // Value Data Size
    PBYTE  Data; // Value Data
} REG_VALUE_DESCR, *PREG_VALUE_DESCR;

#define SET     TRUE
#define GET     FALSE

//
// GetSetKeyValues
// Get or Set the specified KeyName and its Values to the registry under HKLM
//
// KeyName: HKLM\KeyName
// ValDesc: pointer to a Reg Value Descriptor array. Note the last array entry must be NULL.
// bSet: TRUE to Set, else Get
// bOverwrite: TRUE to overwrite it the key already exists
//
BOOL
GetSetKeyValues(
   LPCTSTR          KeyName,
   PREG_VALUE_DESCR ValDesc,
   BOOL             bSet,
   BOOL             bOverwrite
   );

#if !defined(STATUS_DELETE_PENDING)
//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
//  A non close operation has been requested of a file object with a
//  delete pending.
//
#define STATUS_DELETE_PENDING            ((LONG)0xC0000056L)
#endif


typedef struct _REMOVE_LOCK 
{   
    BOOL Removed;
    LONG    IoCount;
    HANDLE  RemoveEvent;

} REMOVE_LOCK, *PREMOVE_LOCK;

BOOL
InitializeRemoveLock(
    IN PREMOVE_LOCK Lock
    );

DWORD
AcquireRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

VOID
ReleaseRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );
  
VOID
ReleaseRemoveLockAndWait(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

#ifdef __cplusplus
}
#endif

#endif // _USBCLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\usbdi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

usbdi.h

Abstract:  

    Definitions for the Universal Serial Bus client driver interface.

Notes: 


--*/

#pragma once

#ifndef   __USBDI_H__
#define   __USBDI_H__

#ifndef   __USBTYPES_H__
#include  "usbtypes.h"
#endif


#ifdef __cplusplus
extern "C" {
#endif

// USB Notification Messages
// These messages are passed to the client drivers's LPDEVICE_NOTIFY_ROUTINE
// function.  The client driver registers it's notification routine with
// the LPREGISTER_NOTIFICATION_ROUTINE function
#define     USB_CLOSE_DEVICE    1
#define     USB_SUSPENDED_DEVICE 0x10
#define     USB_RESUMED_DEVICE  0x11



// Pass this constant to RegisterClientSettings to load the client driver by
// default for any of the parameters in the USB_DRIVER_SETTINGS structure.

#define     USB_NO_INFO             0xFFFFFFFF

// @doc  DRIVERS
// @struct USB_DRIVER_SETTINGS | Passed to RegisterClientSettings
// to allow USBD to recognize client driver and when to load it.  Fields are
// broken into 3 groups: vendor specific, device specific, and interface
// specific.  Load order is determined by searching first for the most general
// vendor specific client, next the most general device specific client, and 
// finally (for each interface) the most general interface specific client.
// Any of the fields may be set to USB_NO_INFO, which indicates that the client
// should be loaded by default if all other fields match, and no other client
// driver is ahead in the load order.
typedef struct _USB_DRIVER_SETTINGS
{
    DWORD dwCount;           // @field Set to the size of this structure, in bytes

    //Vendor specific (also Device Specific)
    DWORD dwVendorId;        // @field (Vendor) Matches vendor id in device descriptor
    DWORD dwProductId;       // @field (Vendor) Matches procuct id in device descriptor
    DWORD dwReleaseNumber;   // @field (Vendor) Matches release number in device descriptor

    //Device specific
    DWORD dwDeviceClass;     // @field (Device) Matches device class in device descriptor
    DWORD dwDeviceSubClass;  // @field (Device) Matches device subclass in device descriptor
    DWORD dwDeviceProtocol;  // @field (Device) Matches protocol in device descriptor

    //Interface specific
    DWORD dwInterfaceClass;    // @field (Interface) Matches class in interface descriptor
    DWORD dwInterfaceSubClass; // @field (Interface) Matches subclass in interface descriptor
    DWORD dwInterfaceProtocol; // @field (Interface) Matches protocol in interface descriptor

} USB_DRIVER_SETTINGS, * PUSB_DRIVER_SETTINGS, * LPUSB_DRIVER_SETTINGS;
typedef USB_DRIVER_SETTINGS const * PCUSB_DRIVER_SETTINGS;
typedef USB_DRIVER_SETTINGS const * LPCUSB_DRIVER_SETTINGS;

struct  _USB_FUNCS;
typedef struct _USB_FUNCS USB_FUNCS, * PUSB_FUNCS, * LPUSB_FUNCS;
typedef struct _USB_FUNCS const * PCUSB_FUNCS;
typedef struct _USB_FUNCS const * LPCUSB_FUNCS;

/******************************************************************************/
//These are entry points which all Client Drivers MUST have
BOOL USBDeviceAttach(USB_HANDLE hDevice, LPCUSB_FUNCS lpUsbFuncs,
                     LPCUSB_INTERFACE lpInterface, LPCWSTR szUniqueDriverId,
                     LPBOOL fAcceptControl,
                     LPCUSB_DRIVER_SETTINGS lpDriverSettings, DWORD dwUnused);
BOOL USBInstallDriver(LPCWSTR szDriverLibFile);
BOOL USBUnInstallDriver();

// format for the USB notification procedure (Client drivers register this
// function with the USBD to receive device notifications.
// IMPORTANT:
// If a client driver processes a message it should return TRUE.
// If a client driver does not process a message it should return FALSE.
// All client drivers are required to process the   USB_CLOSE_DEVICE   message


typedef BOOL (WINAPI *LPDEVICE_NOTIFY_ROUTINE)(LPVOID lpvNotifyParameter,
                                               DWORD dwCode,
                                               LPDWORD * dwInfo1,
                                               LPDWORD * dwInfo2,
                                               LPDWORD * dwInfo3,
                                               LPDWORD * dwInfo4);

/******************************************************************************/
//These are entry points to the USBD (USB Driver)


// Manipulates information in the registry which identifies this device
// these functions are called from anytime from any process
// to set up the device in the registry
// To get access to them call LoadLibrary on USBD.DLL and GetProcAddress on the
// function name

//USBD version information
typedef VOID (* LPGET_USBD_VERSION)(LPDWORD lpdwMajorVersion,
                                    LPDWORD lpdwMinorVersion);
VOID GetUSBDVersion(LPDWORD lpdwMajorVersion, LPDWORD lpdwMinorVersion);

// Registers & uneregisters a client driver's Unique Driver ID.
typedef BOOL (* LPREGISTER_CLIENT_DRIVER_ID)(LPCWSTR);
BOOL RegisterClientDriverID(LPCWSTR szUniqueDriverId);
typedef BOOL (* LPUN_REGISTER_CLIENT_DRIVER_ID)(LPCWSTR);
BOOL UnRegisterClientDriverID(LPCWSTR szUniqueDriverId);

// registers & unregisters the conditions under which a driver will be loaded.
typedef BOOL (* LPREGISTER_CLIENT_SETTINGS)(LPCWSTR, LPCWSTR, LPCWSTR,
                                            LPCUSB_DRIVER_SETTINGS);
BOOL RegisterClientSettings(LPCWSTR lpszDriverLibFile,
                            LPCWSTR lpszUniqueDriverId, LPCWSTR szReserved,
                            LPCUSB_DRIVER_SETTINGS lpDriverSettings);
typedef BOOL (* LPUN_REGISTER_CLIENT_SETTINGS)(LPCWSTR, LPCWSTR,
                                               LPCUSB_DRIVER_SETTINGS);
BOOL UnRegisterClientSettings(LPCWSTR lpszUniqueDriverId, LPCWSTR szReserved,
                              LPCUSB_DRIVER_SETTINGS lpDriverSettings);

// open a client drivers's USB registry key
typedef HKEY (* LPOPEN_CLIENT_REGISTRY_KEY)(LPCWSTR);
HKEY OpenClientRegistryKey(LPCWSTR szUniqueDriverId);

BOOL GetClientRegistryPath(LPWSTR szRegistryPath, DWORD dwRegPathUnit, LPCWSTR szUniqueDriverId);



// These functions are only available to Drivers
// They are not exported functions.  Drivers obtain access to them through
// the USBDeviceAttach function which passes a table of functions to the client.

//Notification routine functions (
typedef BOOL (* LPREGISTER_NOTIFICATION_ROUTINE)(USB_HANDLE,
                                                 LPDEVICE_NOTIFY_ROUTINE,
                                                 LPVOID);
typedef BOOL (* LPUN_REGISTER_NOTIFICATION_ROUTINE)(USB_HANDLE,
                                                    LPDEVICE_NOTIFY_ROUTINE,
                                                    LPVOID);


// function to load drivers for separate interfaces
typedef BOOL (* LPLOAD_GENERIC_INTERFACE_DRIVER)(USB_HANDLE, LPCUSB_INTERFACE);

typedef BOOL (* LPLOAD_GENERIC_IAD_DRIVER)(USB_HANDLE, PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR);

//Helper commands
typedef BOOL (* LPTRANSLATE_STRING_DESCR)(LPCUSB_STRING_DESCRIPTOR, LPWSTR,
                                          DWORD);
typedef LPCUSB_INTERFACE (* LPFIND_INTERFACE)(LPCUSB_DEVICE, UCHAR, UCHAR);


//USB Subsystem Commands
typedef BOOL (* LPGET_FRAME_NUMBER)(USB_HANDLE, LPDWORD);
typedef BOOL (* LPGET_FRAME_LENGTH)(USB_HANDLE, LPUSHORT);


//Enables Device to Adjust the USB SOF period on OHCI or UHCI cards
typedef BOOL (* LPTAKE_FRAME_LENGTH_CONTROL)(USB_HANDLE);
typedef BOOL (* LPSET_FRAME_LENGTH)(USB_HANDLE, HANDLE, USHORT);
typedef BOOL (* LPRELEASE_FRAME_LENGTH_CONTROL)(USB_HANDLE);


// Gets info on a device
typedef LPCUSB_DEVICE (* LPGET_DEVICE_INFO)(USB_HANDLE);

//Device commands
typedef USB_TRANSFER (* LPISSUE_VENDOR_TRANSFER)(USB_HANDLE,
                                                 LPTRANSFER_NOTIFY_ROUTINE,
                                                 LPVOID, DWORD,
                                                 LPCUSB_DEVICE_REQUEST, LPVOID,
                                                 ULONG);
typedef USB_TRANSFER (* LPGET_INTERFACE)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                         LPVOID, DWORD, UCHAR, PUCHAR);
typedef USB_TRANSFER (* LPSET_INTERFACE)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                         LPVOID, DWORD, UCHAR, UCHAR);
typedef USB_TRANSFER (* LPGET_DESCRIPTOR)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                          LPVOID, DWORD, UCHAR, UCHAR, WORD,
                                          WORD, LPVOID);
typedef USB_TRANSFER (* LPSET_DESCRIPTOR)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                          LPVOID, DWORD, UCHAR, UCHAR, WORD,
                                          WORD, PVOID);
typedef USB_TRANSFER (* LPSET_FEATURE)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                       LPVOID, DWORD, WORD, UCHAR);
typedef USB_TRANSFER (* LPCLEAR_FEATURE)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                         LPVOID, DWORD, WORD, UCHAR);
typedef USB_TRANSFER (* LPGET_STATUS)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                      LPVOID, DWORD, UCHAR, LPWORD);
typedef USB_TRANSFER (* LPSYNC_FRAME)(USB_HANDLE, LPTRANSFER_NOTIFY_ROUTINE,
                                      LPVOID, DWORD, UCHAR, LPWORD);


//pipe handling
typedef USB_PIPE (* LPOPEN_PIPE)(USB_HANDLE, LPCUSB_ENDPOINT_DESCRIPTOR);
typedef BOOL (* LPABORT_PIPE_TRANSFERS)(USB_PIPE, DWORD);
typedef BOOL (* LPRESET_PIPE)(USB_PIPE);
typedef BOOL (* LPCLOSE_PIPE)(USB_PIPE);
typedef BOOL (* LPIS_PIPE_HALTED)(USB_PIPE, LPBOOL);

typedef BOOL (* LPRESET_DEFAULT_PIPE)(USB_HANDLE);
typedef BOOL (* LPIS_DEFAULT_PIPE_HALTED)(USB_HANDLE, LPBOOL);

//Transfer commands
typedef USB_TRANSFER (* LPISSUE_CONTROL_TRANSFER)(USB_PIPE,
                                                  LPTRANSFER_NOTIFY_ROUTINE,
                                                  LPVOID, DWORD, LPCVOID, DWORD,
                                                  LPVOID, ULONG);
typedef USB_TRANSFER (* LPISSUE_BULK_TRANSFER)(USB_PIPE,
                                               LPTRANSFER_NOTIFY_ROUTINE,
                                               LPVOID, DWORD, DWORD, LPVOID,
                                               ULONG);
typedef USB_TRANSFER (* LPISSUE_INTERRUPT_TRANSFER)(USB_PIPE,
                                                    LPTRANSFER_NOTIFY_ROUTINE,
                                                    LPVOID, DWORD, DWORD,
                                                    LPVOID, ULONG);
typedef USB_TRANSFER (* LPISSUE_ISOCH_TRANSFER)(USB_PIPE,
                                                LPTRANSFER_NOTIFY_ROUTINE,
                                                LPVOID, DWORD, DWORD, DWORD,
                                                LPCDWORD, LPVOID, ULONG);

// get info on Transfers
typedef BOOL (* LPIS_TRANSFER_COMPLETE)(USB_TRANSFER);
typedef BOOL (* LPGET_TRANSFER_STATUS)(USB_TRANSFER, LPDWORD, LPDWORD);
typedef BOOL (* LPGET_ISOCH_RESULTS)(USB_TRANSFER, DWORD, LPDWORD, LPDWORD);

// transfer maniuplators
typedef BOOL (* LPABORT_TRANSFER)(USB_TRANSFER, DWORD);
typedef BOOL (* LPCLOSE_TRANSFER)(USB_TRANSFER);

// Device Control Function
typedef BOOL (* LPDISABLE_DEVICE)(USB_HANDLE,BOOL,UCHAR);
typedef BOOL (* LPSUSPEND_DEVICE)(USB_HANDLE,UCHAR);
typedef BOOL (* LPRESUME_DEVICE)(USB_HANDLE,UCHAR);

// NEW API for 1.3
typedef BOOL (* LPGET_CLIENT_REGISTRY_PATH)(LPWSTR,DWORD,LPCWSTR);

// function table
struct _USB_FUNCS {
    DWORD                               dwCount;

    LPGET_USBD_VERSION                  lpGetUSBDVersion;
    LPOPEN_CLIENT_REGISTRY_KEY          lpOpenClientRegistyKey;
    LPREGISTER_NOTIFICATION_ROUTINE     lpRegisterNotificationRoutine;
    LPUN_REGISTER_NOTIFICATION_ROUTINE  lpUnRegisterNotificationRoutine;
    LPLOAD_GENERIC_INTERFACE_DRIVER     lpLoadGenericInterfaceDriver;
    LPTRANSLATE_STRING_DESCR            lpTranslateStringDesc;
    LPFIND_INTERFACE                    lpFindInterface;
    LPGET_FRAME_NUMBER                  lpGetFrameNumber;
    LPGET_FRAME_LENGTH                  lpGetFrameLength;
    LPTAKE_FRAME_LENGTH_CONTROL         lpTakeFrameLengthControl;
    LPRELEASE_FRAME_LENGTH_CONTROL      lpReleaseFrameLengthControl;
    LPSET_FRAME_LENGTH                  lpSetFrameLength;
    LPGET_DEVICE_INFO                   lpGetDeviceInfo;
    LPISSUE_VENDOR_TRANSFER             lpIssueVendorTransfer;
    LPGET_INTERFACE                     lpGetInterface;
    LPSET_INTERFACE                     lpSetInterface;
    LPGET_DESCRIPTOR                    lpGetDescriptor;
    LPSET_DESCRIPTOR                    lpSetDescriptor;
    LPSET_FEATURE                       lpSetFeature;
    LPCLEAR_FEATURE                     lpClearFeature;
    LPGET_STATUS                        lpGetStatus;
    LPSYNC_FRAME                        lpSyncFrame;
    LPOPEN_PIPE                         lpOpenPipe;
    LPABORT_PIPE_TRANSFERS              lpAbortPipeTransfers;
    LPRESET_PIPE                        lpResetPipe;
    LPCLOSE_PIPE                        lpClosePipe;
    LPIS_PIPE_HALTED                    lpIsPipeHalted;
    LPISSUE_CONTROL_TRANSFER            lpIssueControlTransfer;
    LPISSUE_BULK_TRANSFER               lpIssueBulkTransfer;
    LPISSUE_INTERRUPT_TRANSFER          lpIssueInterruptTransfer;
    LPISSUE_ISOCH_TRANSFER              lpIssueIsochTransfer;
    LPIS_TRANSFER_COMPLETE              lpIsTransferComplete;
    LPGET_TRANSFER_STATUS               lpGetTransferStatus;
    LPGET_ISOCH_RESULTS                 lpGetIsochResults;
    LPABORT_TRANSFER                    lpAbortTransfer;
    LPCLOSE_TRANSFER                    lpCloseTransfer;
    LPRESET_DEFAULT_PIPE                lpResetDefaultPipe;
    LPIS_DEFAULT_PIPE_HALTED            lpIsDefaultPipeHalted;
    LPDISABLE_DEVICE                    lpDisableDevice;
    LPSUSPEND_DEVICE                    lpSuspendDevice;
    LPRESUME_DEVICE                     lpResumeDevice;
    LPGET_CLIENT_REGISTRY_PATH          lpGetClientRegistyPath;
    LPLOAD_GENERIC_IAD_DRIVER           lpLoadGenericIADDriver;
};

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\usbtypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  
    usbtypes.h

Abstract:  
    Definitions for Universal Serial Bus driver.
    
Notes: 

--*/
#ifndef   __USBTYPES_H__
#define   __USBTYPES_H__

#include    <windef.h>

#ifndef   __USB100_H__
#include    "usb100.h"
#endif


#ifdef __cplusplus
extern "C" {
#endif

// defines the maximum size of strings related to driver loading
#define     USB_MAX_LOAD_STRING     (MAX_PATH + 1)

// Flags for transfer functions
#define     USB_IN_TRANSFER         0x00000080
#define     USB_OUT_TRANSFER        0x00000000
#define     USB_NO_WAIT             0x00000100 //transfers without events get completed immediately
#define     USB_SHORT_TRANSFER_OK   0x00000200 //allows the transfer to be shorter than the buffer
#define     USB_START_ISOCH_ASAP    0x00000400
#define     USB_COMPRESS_ISOCH      0x00000800
#define     USB_SEND_TO_DEVICE      0x00001000
#define     USB_SEND_TO_INTERFACE   0x00002000
#define     USB_SEND_TO_ENDPOINT    0x00004000
#define     USB_DONT_BLOCK_FOR_MEM  0x00008000 // Don't block waiting for memory allocations

// USB_DEVICE_REQUEST.bmRequestType bits for control Pipes
#define     USB_REQUEST_DEVICE_TO_HOST      0x80
#define     USB_REQUEST_HOST_TO_DEVICE      0x00
#define     USB_REQUEST_STANDARD            0x00
#define     USB_REQUEST_CLASS               0x20
#define     USB_REQUEST_VENDOR              0x40
#define     USB_REQUEST_RESERVED            0x60
#define     USB_REQUEST_FOR_DEVICE          0x00
#define     USB_REQUEST_FOR_INTERFACE       0x01
#define     USB_REQUEST_FOR_ENDPOINT        0x02
#define     USB_REQUEST_FOR_OTHER           0x03

// USB Errors
#define     USB_NO_ERROR                        0x00000000
#define     USB_CRC_ERROR                       0x00000001
#define     USB_BIT_STUFFING_ERROR              0x00000002
#define     USB_DATA_TOGGLE_MISMATCH_ERROR      0x00000003
#define     USB_STALL_ERROR                     0x00000004
#define     USB_DEVICE_NOT_RESPONDING_ERROR     0x00000005
#define     USB_PID_CHECK_FAILURE_ERROR         0x00000006
#define     USB_UNEXPECTED_PID_ERROR            0x00000007
#define     USB_DATA_OVERRUN_ERROR              0x00000008
#define     USB_DATA_UNDERRUN_ERROR             0x00000009
#define     USB_BUFFER_OVERRUN_ERROR            0x0000000C
#define     USB_BUFFER_UNDERRUN_ERROR           0x0000000D
#define     USB_NOT_ACCESSED_ERROR              0x0000000E
#define     USB_NOT_ACCESSED_ALT                0x0000000F  // HCD maps this to E when encountered

#define     USB_ISOCH_ERROR                     0x00000100
#define     USB_CANCELED_ERROR                  0x00000101
#define     USB_NOT_COMPLETE_ERROR              0x00000103
#define     USB_CLIENT_BUFFER_ERROR             0x00000104

typedef USB_ENDPOINT_DESCRIPTOR * LPUSB_ENDPOINT_DESCRIPTOR;
typedef USB_INTERFACE_DESCRIPTOR * LPUSB_INTERFACE_DESCRIPTOR;
typedef USB_CONFIGURATION_DESCRIPTOR * LPUSB_CONFIGURATION_DESCRIPTOR;
typedef USB_DEVICE_DESCRIPTOR * LPUSB_DEVICE_DESCRIPTOR;
typedef USB_STRING_DESCRIPTOR * LPUSB_STRING_DESCRIPTOR;

typedef USB_ENDPOINT_DESCRIPTOR const * PCUSB_ENDPOINT_DESCRIPTOR;
typedef USB_ENDPOINT_DESCRIPTOR const * LPCUSB_ENDPOINT_DESCRIPTOR;

typedef USB_INTERFACE_DESCRIPTOR const * PCUSB_INTERFACE_DESCRIPTOR;
typedef USB_INTERFACE_DESCRIPTOR const * LPCUSB_INTERFACE_DESCRIPTOR;

typedef USB_CONFIGURATION_DESCRIPTOR const * PCUSB_CONFIGURATION_DESCRIPTOR;
typedef USB_CONFIGURATION_DESCRIPTOR const * LPCUSB_CONFIGURATION_DESCRIPTOR;

typedef USB_DEVICE_DESCRIPTOR const * PCUSB_DEVICE_DESCRIPTOR;
typedef USB_DEVICE_DESCRIPTOR const * LPCUSB_DEVICE_DESCRIPTOR;

typedef USB_STRING_DESCRIPTOR const * PCUSB_STRING_DESCRIPTOR;
typedef USB_STRING_DESCRIPTOR const * LPCUSB_STRING_DESCRIPTOR;


typedef LPVOID USB_HANDLE;
typedef LPVOID USB_PIPE;
typedef LPVOID USB_TRANSFER;

typedef UINT * LPUINT;
typedef DWORD const * LPCDWORD;
typedef USHORT * LPUSHORT;
typedef LPVOID * LPLPVOID;
typedef ULONG FAR * LPULONG;

typedef DWORD (WINAPI *LPTRANSFER_NOTIFY_ROUTINE)(LPVOID lpvNotifyParameter);

// Device info returned by GetDeviceInfo
typedef struct _USB_ENDPOINT {
    DWORD                             dwCount;

    USB_ENDPOINT_DESCRIPTOR           Descriptor;
    LPVOID                            lpvExtended;
    DWORD                             dwExtendedSize;
} USB_ENDPOINT, * PUSB_ENDPOINT, * LPUSB_ENDPOINT;
typedef USB_ENDPOINT const * PCUSB_ENDPOINT;
typedef USB_ENDPOINT const * LPCUSB_ENDPOINT;

typedef struct _USB_INTERFACE {
    DWORD                             dwCount;

    USB_INTERFACE_DESCRIPTOR          Descriptor;
    LPVOID                            lpvExtended;
    LPUSB_ENDPOINT                    lpEndpoints;
    DWORD                             dwExtendedSize;
} USB_INTERFACE, * PUSB_INTERFACE, * LPUSB_INTERFACE;
typedef USB_INTERFACE const * PCUSB_INTERFACE;
typedef USB_INTERFACE const * LPCUSB_INTERFACE;

typedef struct _USB_CONFIGURATION {
    DWORD                             dwCount;

    USB_CONFIGURATION_DESCRIPTOR      Descriptor;
    LPVOID                            lpvExtended;
    DWORD                             dwNumInterfaces;
    LPUSB_INTERFACE                   lpInterfaces;
    DWORD                             dwExtendedSize;
} USB_CONFIGURATION, * PUSB_CONFIGURATION, * LPUSB_CONFIGURATION;
typedef USB_CONFIGURATION const * PCUSB_CONFIGURATION;
typedef USB_CONFIGURATION const * LPCUSB_CONFIGURATION;

typedef struct _USB_DEVICE {
    DWORD                             dwCount;

    USB_DEVICE_DESCRIPTOR             Descriptor;
    LPUSB_CONFIGURATION               lpConfigs;
    LPUSB_CONFIGURATION               lpActiveConfig;
} USB_DEVICE, * PUSB_DEVICE, * LPUSB_DEVICE;
typedef USB_DEVICE const * PCUSB_DEVICE;
typedef USB_DEVICE const * LPCUSB_DEVICE;

typedef struct _USB_DEVICE_REQUEST
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_DEVICE_REQUEST, * PUSB_DEVICE_REQUEST, * LPUSB_DEVICE_REQUEST;
typedef USB_DEVICE_REQUEST const * PCUSB_DEVICE_REQUEST;
typedef USB_DEVICE_REQUEST const * LPCUSB_DEVICE_REQUEST;


// USB HW ID values
typedef enum {
    USB_HW_ID_GENERIC_EHCI = 0,
    USB_HW_ID_CI13611A,    
    USB_HW_ID_OEM_DEFINED = 0x8000
} USB_HW_ID;



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\usb200.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  
    usb200.h

Abstract:  
    Constant definitions from Universal Serial Bus specification version 2.0.

Notes: 

--*/
#ifndef   __USB200_H__
#define   __USB200_H__
#include <usb100.h>

#include <PSHPACK1.H>
#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE                    0x06
#define USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE           0x07

typedef struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;

    UCHAR bNumConfigurations;
    UCHAR bReserved;
} USB_DEVICE_QUALIFIER_DESCRIPTOR, *PUSB_DEVICE_QUALIFIER_DESCRIPTOR;

typedef USB_CONFIGURATION_DESCRIPTOR USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR, *PUSB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR;

#define USB_ENDPOINT_MAX_PACKET_SIZE_MASK                       0x07FF

#define USB_OTG_CONFIGURATION_DESCRIPTOR_TYPE                   0x09
typedef struct _USB_OTG_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bmAttributes;
} USB_OTG_DESCRIPTOR, *PUSB_OTG_DESCRIPTOR ;
// For OTG Feature
#define USB_FEATURE_B_HNP_ENABLE            0x0003
#define USB_FEATURE_A_HNP_SUPPORT           0x0004
#define USB_FEATURE_A_ALT_HNP_SUPPORT       0x0005

#ifdef USB_IF_ELECTRICAL_TEST_MODE

#define USB_EHCI_TEST_MODE_DISABLED      0x00
#define USB_EHCI_TEST_MODE_J_STATE       0x01
#define USB_EHCI_TEST_MODE_K_STATE       0x02
#define USB_EHCI_TEST_MODE_SE0_NAK       0x03
#define USB_EHCI_TEST_MODE_TEST_PACKET   0x04
#define USB_EHCI_TEST_MODE_FORCE_ENABLE 0x05

#define BUS_USBD_EXTENTION_FUNCTIONCODE 0x180
#define BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_USBD_BEGIN _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBD_END   _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE+BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE-1)


#define BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE 0x200
#define BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE_SIZE 0x10
#define IOCTL_USB_TEST_MODE_BEGIN _BUSACCESS_CTL_CODE(BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE )
#define IOCTL_USB_TEST_MODE_END \
    _BUSACCESS_CTL_CODE(BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE+BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE_SIZE-1)

#define IOCTL_USB_EHCI_GET_NUM_PORTS _BUSACCESS_CTL_CODE(BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE+0x02)
#define IOCTL_USB_EHCI_SET_TEST_MODE _BUSACCESS_CTL_CODE(BUS_USB_TEST_MODE_EXTENTION_FUNCTIONCODE+0x03)

typedef struct _IO_USB_EHCI_SET_TEST_MODE
{
    DWORD dwPortNum;
    DWORD dwTestMode;
} IO_USB_EHCI_SET_TEST_MODE, *PIO_USB_EHCI_SET_TEST_MODE;

#endif //#ifdef USB_IF_ELECTRICAL_TEST_MODE

#include <POPPACK.H>

#endif   /* __USB200_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\videoctl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __VIDEOCTL__
#define __VIDEOCTL__

// These help with property page implementations. The first can be used to
// load any string from a resource file. The buffer to load into is passed
// as an input parameter. The same buffer is the return value if the string
// was found otherwise it returns TEXT(""). The GetDialogSize is passed the
// resource ID of a dialog box and returns the size of it in screen pixels

#define STR_MAX_LENGTH 256
TCHAR * WINAPI StringFromResource(TCHAR *pBuffer, int iResourceID);

#ifdef UNICODE
#define WideStringFromResource StringFromResource
#else
WCHAR * WINAPI WideStringFromResource(WCHAR *pBuffer, int iResourceID);
#endif

#ifndef UNDER_CE
BOOL WINAPI GetDialogSize(int iResourceID,     // Dialog box resource identifier
                          DLGPROC pDlgProc,    // Pointer to dialog procedure
                          LPARAM lParam,       // Any user data wanted in pDlgProc
                          SIZE *pResult);      // Returns the size of dialog box
#endif

// Class that aggregates an IDirectDraw interface

class CAggDirectDraw : public IDirectDraw, public CUnknown
{
protected:

    LPDIRECTDRAW m_pDirectDraw;

public:

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Constructor and destructor

    CAggDirectDraw(const TCHAR *pName,LPUNKNOWN pUnk) :
        CUnknown(pName,pUnk),
        m_pDirectDraw(NULL) { };

    virtual CAggDirectDraw::~CAggDirectDraw() { };

    // Set the object we should be aggregating
    void SetDirectDraw(LPDIRECTDRAW pDirectDraw) {
        m_pDirectDraw = pDirectDraw;
    }

    // IDirectDraw methods

    STDMETHODIMP CreateClipper(DWORD, LPDIRECTDRAWCLIPPER *, IUnknown *);
    STDMETHODIMP CreatePalette(DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE *, IUnknown *);
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC, LPDIRECTDRAWSURFACE *, IUnknown *);
    STDMETHODIMP EnumDisplayModes(DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK);
    STDMETHODIMP EnumSurfaces(DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK);
    STDMETHODIMP FlipToGDISurface();
    STDMETHODIMP GetCaps(LPDDCAPS, LPDDCAPS);
    STDMETHODIMP GetDisplayMode(LPDDSURFACEDESC);
    STDMETHODIMP GetFourCCCodes(LPDWORD, LPDWORD);
    STDMETHODIMP GetGDISurface(LPDIRECTDRAWSURFACE *);
    STDMETHODIMP GetMonitorFrequency(LPDWORD);
    STDMETHODIMP GetScanLine(LPDWORD);
    STDMETHODIMP GetVerticalBlankStatus(LPBOOL);
    STDMETHODIMP RestoreDisplayMode();
    STDMETHODIMP SetCooperativeLevel(HWND, DWORD);
    STDMETHODIMP SetDisplayMode(DWORD, DWORD, DWORD, DWORD, DWORD);
    STDMETHODIMP WaitForVerticalBlank(DWORD, HANDLE);
    STDMETHODIMP GetAvailableVidMem(LPDDSCAPS, LPDWORD, LPDWORD);
    STDMETHODIMP GetSurfaceFromDC(HDC, LPDIRECTDRAWSURFACE *);
    STDMETHODIMP RestoreAllSurfaces();
    STDMETHODIMP TestCooperativeLevel();
    STDMETHODIMP GetDeviceIdentifier(LPDDDEVICEIDENTIFIER, DWORD);
};


// Class that aggregates an IDirectDrawSurface interface

class CAggDrawSurface : public IDirectDrawSurface, public CUnknown
{
protected:

    LPDIRECTDRAWSURFACE m_pDirectDrawSurface;

public:

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Constructor and destructor

    CAggDrawSurface(const TCHAR *pName,LPUNKNOWN pUnk) :
        CUnknown(pName,pUnk),
        m_pDirectDrawSurface(NULL) { };

    virtual ~CAggDrawSurface() { };

    // Set the object we should be aggregating
    void SetDirectDrawSurface(LPDIRECTDRAWSURFACE pDirectDrawSurface) {
        m_pDirectDrawSurface = pDirectDrawSurface;
    }

    // IDirectDrawSurface methods

    STDMETHODIMP AddOverlayDirtyRect(LPRECT);
    STDMETHODIMP Blt(LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDBLTFX);
    STDMETHODIMP EnumAttachedSurfaces(LPVOID, LPDDENUMSURFACESCALLBACK);
    STDMETHODIMP EnumOverlayZOrders(DWORD, LPVOID, LPDDENUMSURFACESCALLBACK);
    STDMETHODIMP Flip(LPDIRECTDRAWSURFACE, DWORD);
    STDMETHODIMP GetBltStatus(DWORD);
    STDMETHODIMP GetCaps(LPDDSCAPS);
    STDMETHODIMP GetClipper(LPDIRECTDRAWCLIPPER *);
    STDMETHODIMP GetColorKey(DWORD, LPDDCOLORKEY);
    STDMETHODIMP GetDC(HDC *);
    STDMETHODIMP GetFlipStatus(DWORD);
    STDMETHODIMP GetOverlayPosition(LPLONG, LPLONG);
    STDMETHODIMP GetPalette(LPDIRECTDRAWPALETTE *);
    STDMETHODIMP GetPixelFormat(LPDDPIXELFORMAT);
    STDMETHODIMP GetSurfaceDesc(LPDDSURFACEDESC);
    STDMETHODIMP IsLost();
    STDMETHODIMP Lock(LPRECT, LPDDSURFACEDESC, DWORD, HANDLE);
    STDMETHODIMP ReleaseDC(HDC);
    STDMETHODIMP Restore();
    STDMETHODIMP SetClipper(LPDIRECTDRAWCLIPPER);
    STDMETHODIMP SetColorKey(DWORD, LPDDCOLORKEY);
    STDMETHODIMP SetOverlayPosition(LONG, LONG );
    STDMETHODIMP SetPalette(LPDIRECTDRAWPALETTE);
    STDMETHODIMP Unlock(LPRECT);
    STDMETHODIMP UpdateOverlay(LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDOVERLAYFX);
    STDMETHODIMP UpdateOverlayZOrder(DWORD, LPDIRECTDRAWSURFACE);
    STDMETHODIMP GetDDInterface(LPDIRECTDRAW *);
    STDMETHODIMP AlphaBlt(LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX);
};


// ActiveMovie must work on multiple platforms, in particular it also runs on
// Windows NT 3.51 which does not have DirectDraw capabilities. The filters
// cannot therefore link statically to the DirectDraw library. To make their
// lives that little bit easier we provide this class that manages loading
// and unloading the library and creating the initial IDirectDraw interface

typedef DWORD (WINAPI *PGETFILEVERSIONINFOSIZE)(LPTSTR,LPDWORD);
typedef BOOL (WINAPI *PGETFILEVERSIONINFO)(LPTSTR,DWORD,DWORD,LPVOID);
typedef BOOL (WINAPI *PVERQUERYVALUE)(LPVOID,LPTSTR,LPVOID,PUINT);

class CLoadDirectDraw
{
    LPDIRECTDRAW m_pDirectDraw;     // The DirectDraw driver instance
    HINSTANCE m_hDirectDraw;        // Handle to the loaded library

public:

    CLoadDirectDraw();
    ~CLoadDirectDraw();

    HRESULT LoadDirectDraw();
    HRESULT LoadDirectDraw (HINSTANCE *hDirectDraw);
    void ReleaseDirectDraw();
    HRESULT IsDirectDrawLoaded();
    LPDIRECTDRAW GetDirectDraw();
};

#endif // __VIDEOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vervec.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:16:08 2007
 */
/* Compiler settings for ..\vervec.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vervec_h__
#define __vervec_h__

/* Forward Declarations */ 

#ifndef __IVersionVector_FWD_DEFINED__
#define __IVersionVector_FWD_DEFINED__
typedef interface IVersionVector IVersionVector;
#endif 	/* __IVersionVector_FWD_DEFINED__ */


#ifndef __IVersionHost_FWD_DEFINED__
#define __IVersionHost_FWD_DEFINED__
typedef interface IVersionHost IVersionHost;
#endif 	/* __IVersionHost_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_vervec_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// version.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IVersionVector Interface.


#ifndef _LPVERSION_DEFINED
#define _LPVERSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_vervec_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vervec_0000_v0_0_s_ifspec;

#ifndef __IVersionVector_INTERFACE_DEFINED__
#define __IVersionVector_INTERFACE_DEFINED__

/* interface IVersionVector */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IVersionVector __RPC_FAR *LPVERSION;


EXTERN_C const IID IID_IVersionVector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4eb01410-db1a-11d1-ba53-00c04fc2040e")
    IVersionVector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVersion( 
            /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
            /* [in] */ const OLECHAR __RPC_FAR *pchVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
            /* [out] */ OLECHAR __RPC_FAR *pchVersion,
            /* [out][in] */ ULONG __RPC_FAR *pcchVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVersionVectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVersionVector __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVersionVector __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVersionVector __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVersion )( 
            IVersionVector __RPC_FAR * This,
            /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
            /* [in] */ const OLECHAR __RPC_FAR *pchVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IVersionVector __RPC_FAR * This,
            /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
            /* [out] */ OLECHAR __RPC_FAR *pchVersion,
            /* [out][in] */ ULONG __RPC_FAR *pcchVersion);
        
        END_INTERFACE
    } IVersionVectorVtbl;

    interface IVersionVector
    {
        CONST_VTBL struct IVersionVectorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVersionVector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVersionVector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVersionVector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVersionVector_SetVersion(This,pchComponent,pchVersion)	\
    (This)->lpVtbl -> SetVersion(This,pchComponent,pchVersion)

#define IVersionVector_GetVersion(This,pchComponent,pchVersion,pcchVersion)	\
    (This)->lpVtbl -> GetVersion(This,pchComponent,pchVersion,pcchVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVersionVector_SetVersion_Proxy( 
    IVersionVector __RPC_FAR * This,
    /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
    /* [in] */ const OLECHAR __RPC_FAR *pchVersion);


void __RPC_STUB IVersionVector_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVersionVector_GetVersion_Proxy( 
    IVersionVector __RPC_FAR * This,
    /* [in] */ const OLECHAR __RPC_FAR *pchComponent,
    /* [out] */ OLECHAR __RPC_FAR *pchVersion,
    /* [out][in] */ ULONG __RPC_FAR *pcchVersion);


void __RPC_STUB IVersionVector_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVersionVector_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vervec_0082 */
/* [local] */ 

#endif
EXTERN_C const GUID SID_SVersionHost;
#ifndef _LPVERSIONHOST_DEFINED
#define _LPVERSIONHOST_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_vervec_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vervec_0082_v0_0_s_ifspec;

#ifndef __IVersionHost_INTERFACE_DEFINED__
#define __IVersionHost_INTERFACE_DEFINED__

/* interface IVersionHost */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IVersionHost __RPC_FAR *LPVERSIONHOST;


EXTERN_C const IID IID_IVersionHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("667115ac-dc02-11d1-ba57-00c04fc2040e")
    IVersionHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryUseLocalVersionVector( 
            /* [out] */ BOOL __RPC_FAR *fUseLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVersionVector( 
            /* [in] */ IVersionVector __RPC_FAR *pVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVersionHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVersionHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVersionHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVersionHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryUseLocalVersionVector )( 
            IVersionHost __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *fUseLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryVersionVector )( 
            IVersionHost __RPC_FAR * This,
            /* [in] */ IVersionVector __RPC_FAR *pVersion);
        
        END_INTERFACE
    } IVersionHostVtbl;

    interface IVersionHost
    {
        CONST_VTBL struct IVersionHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVersionHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVersionHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVersionHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVersionHost_QueryUseLocalVersionVector(This,fUseLocal)	\
    (This)->lpVtbl -> QueryUseLocalVersionVector(This,fUseLocal)

#define IVersionHost_QueryVersionVector(This,pVersion)	\
    (This)->lpVtbl -> QueryVersionVector(This,pVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVersionHost_QueryUseLocalVersionVector_Proxy( 
    IVersionHost __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *fUseLocal);


void __RPC_STUB IVersionHost_QueryUseLocalVersionVector_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVersionHost_QueryVersionVector_Proxy( 
    IVersionHost __RPC_FAR * This,
    /* [in] */ IVersionVector __RPC_FAR *pVersion);


void __RPC_STUB IVersionHost_QueryVersionVector_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVersionHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vervec_0083 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_vervec_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vervec_0083_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vfwmsgs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
 // no longer used  - but might get
 // our own facility in the future?
 // FacilityNames=(FACILITY_VFW=0x4)
 // To add a message:
 //
 // The MessageId is the number of the message.
 // Accepted severities are 'Success' and 'Warning'.
 //
 // Facility should be FACILITY_ITF (was FACILITY_VFW).
 //
 // The SymbolicName is the name used in the code to identify the message.
 // The text of a message starts the line after 'Language=' and
 // ends before a line with only a '.' in column one.
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VFW_E_INVALIDMEDIATYPE
//
// MessageText:
//
// An invalid media type was specified.%0
//
#define VFW_E_INVALIDMEDIATYPE           ((HRESULT)0x80040200L)

//
// MessageId: VFW_E_INVALIDSUBTYPE
//
// MessageText:
//
// An invalid media subtype was specified.%0
//
#define VFW_E_INVALIDSUBTYPE             ((HRESULT)0x80040201L)

//
// MessageId: VFW_E_NEED_OWNER
//
// MessageText:
//
// This object can only be created as an aggregated object.%0
//
#define VFW_E_NEED_OWNER                 ((HRESULT)0x80040202L)

//
// MessageId: VFW_E_ENUM_OUT_OF_SYNC
//
// MessageText:
//
// The enumerator has become invalid.%0
//
#define VFW_E_ENUM_OUT_OF_SYNC           ((HRESULT)0x80040203L)

//
// MessageId: VFW_E_ALREADY_CONNECTED
//
// MessageText:
//
// At least one of the pins involved in the operation is already connected.%0
//
#define VFW_E_ALREADY_CONNECTED          ((HRESULT)0x80040204L)

//
// MessageId: VFW_E_FILTER_ACTIVE
//
// MessageText:
//
// This operation cannot be performed because the filter is active.%0
//
#define VFW_E_FILTER_ACTIVE              ((HRESULT)0x80040205L)

//
// MessageId: VFW_E_NO_TYPES
//
// MessageText:
//
// One of the specified pins supports no media types.%0
//
#define VFW_E_NO_TYPES                   ((HRESULT)0x80040206L)

//
// MessageId: VFW_E_NO_ACCEPTABLE_TYPES
//
// MessageText:
//
// There is no common media type between these pins.%0
//
#define VFW_E_NO_ACCEPTABLE_TYPES        ((HRESULT)0x80040207L)

//
// MessageId: VFW_E_INVALID_DIRECTION
//
// MessageText:
//
// Two pins of the same direction cannot be connected together.%0
//
#define VFW_E_INVALID_DIRECTION          ((HRESULT)0x80040208L)

//
// MessageId: VFW_E_NOT_CONNECTED
//
// MessageText:
//
// The operation cannot be performed because the pins are not connected.%0
//
#define VFW_E_NOT_CONNECTED              ((HRESULT)0x80040209L)

//
// MessageId: VFW_E_NO_ALLOCATOR
//
// MessageText:
//
// No sample buffer allocator is available.%0
//
#define VFW_E_NO_ALLOCATOR               ((HRESULT)0x8004020AL)

//
// MessageId: VFW_E_RUNTIME_ERROR
//
// MessageText:
//
// A run-time error occurred.%0
//
#define VFW_E_RUNTIME_ERROR              ((HRESULT)0x8004020BL)

//
// MessageId: VFW_E_BUFFER_NOTSET
//
// MessageText:
//
// No buffer space has been set.%0
//
#define VFW_E_BUFFER_NOTSET              ((HRESULT)0x8004020CL)

//
// MessageId: VFW_E_BUFFER_OVERFLOW
//
// MessageText:
//
// The buffer is not big enough.%0
//
#define VFW_E_BUFFER_OVERFLOW            ((HRESULT)0x8004020DL)

//
// MessageId: VFW_E_BADALIGN
//
// MessageText:
//
// An invalid alignment was specified.%0
//
#define VFW_E_BADALIGN                   ((HRESULT)0x8004020EL)

//
// MessageId: VFW_E_ALREADY_COMMITTED
//
// MessageText:
//
// Cannot change allocated memory while the filter is active.%0
//
#define VFW_E_ALREADY_COMMITTED          ((HRESULT)0x8004020FL)

//
// MessageId: VFW_E_BUFFERS_OUTSTANDING
//
// MessageText:
//
// One or more buffers are still active.%0
//
#define VFW_E_BUFFERS_OUTSTANDING        ((HRESULT)0x80040210L)

//
// MessageId: VFW_E_NOT_COMMITTED
//
// MessageText:
//
// Cannot allocate a sample when the allocator is not active.%0
//
#define VFW_E_NOT_COMMITTED              ((HRESULT)0x80040211L)

//
// MessageId: VFW_E_SIZENOTSET
//
// MessageText:
//
// Cannot allocate memory because no size has been set.%0
//
#define VFW_E_SIZENOTSET                 ((HRESULT)0x80040212L)

//
// MessageId: VFW_E_NO_CLOCK
//
// MessageText:
//
// Cannot lock for synchronization because no clock has been defined.%0
//
#define VFW_E_NO_CLOCK                   ((HRESULT)0x80040213L)

//
// MessageId: VFW_E_NO_SINK
//
// MessageText:
//
// Quality messages could not be sent because no quality sink has been defined.%0
//
#define VFW_E_NO_SINK                    ((HRESULT)0x80040214L)

//
// MessageId: VFW_E_NO_INTERFACE
//
// MessageText:
//
// A required interface has not been implemented.%0
//
#define VFW_E_NO_INTERFACE               ((HRESULT)0x80040215L)

//
// MessageId: VFW_E_NOT_FOUND
//
// MessageText:
//
// An object or name was not found.%0
//
#define VFW_E_NOT_FOUND                  ((HRESULT)0x80040216L)

//
// MessageId: VFW_E_CANNOT_CONNECT
//
// MessageText:
//
// No combination of intermediate filters could be found to make the connection.%0
//
#define VFW_E_CANNOT_CONNECT             ((HRESULT)0x80040217L)

//
// MessageId: VFW_E_CANNOT_RENDER
//
// MessageText:
//
// No combination of filters could be found to render the stream.%0
//
#define VFW_E_CANNOT_RENDER              ((HRESULT)0x80040218L)

//
// MessageId: VFW_E_CHANGING_FORMAT
//
// MessageText:
//
// Could not change formats dynamically.%0
//
#define VFW_E_CHANGING_FORMAT            ((HRESULT)0x80040219L)

//
// MessageId: VFW_E_NO_COLOR_KEY_SET
//
// MessageText:
//
// No color key has been set.%0
//
#define VFW_E_NO_COLOR_KEY_SET           ((HRESULT)0x8004021AL)

//
// MessageId: VFW_E_NOT_OVERLAY_CONNECTION
//
// MessageText:
//
// Current pin connection is not using the IOverlay transport.%0
//
#define VFW_E_NOT_OVERLAY_CONNECTION     ((HRESULT)0x8004021BL)

//
// MessageId: VFW_E_NOT_SAMPLE_CONNECTION
//
// MessageText:
//
// Current pin connection is not using the IMemInputPin transport.%0
//
#define VFW_E_NOT_SAMPLE_CONNECTION      ((HRESULT)0x8004021CL)

//
// MessageId: VFW_E_PALETTE_SET
//
// MessageText:
//
// Setting a color key would conflict with the palette already set.%0
//
#define VFW_E_PALETTE_SET                ((HRESULT)0x8004021DL)

//
// MessageId: VFW_E_COLOR_KEY_SET
//
// MessageText:
//
// Setting a palette would conflict with the color key already set.%0
//
#define VFW_E_COLOR_KEY_SET              ((HRESULT)0x8004021EL)

//
// MessageId: VFW_E_NO_COLOR_KEY_FOUND
//
// MessageText:
//
// No matching color key is available.%0
//
#define VFW_E_NO_COLOR_KEY_FOUND         ((HRESULT)0x8004021FL)

//
// MessageId: VFW_E_NO_PALETTE_AVAILABLE
//
// MessageText:
//
// No palette is available.%0
//
#define VFW_E_NO_PALETTE_AVAILABLE       ((HRESULT)0x80040220L)

//
// MessageId: VFW_E_NO_DISPLAY_PALETTE
//
// MessageText:
//
// Display does not use a palette.%0
//
#define VFW_E_NO_DISPLAY_PALETTE         ((HRESULT)0x80040221L)

//
// MessageId: VFW_E_TOO_MANY_COLORS
//
// MessageText:
//
// Too many colors for the current display settings.%0
//
#define VFW_E_TOO_MANY_COLORS            ((HRESULT)0x80040222L)

//
// MessageId: VFW_E_STATE_CHANGED
//
// MessageText:
//
// The state changed while waiting to process the sample.%0
//
#define VFW_E_STATE_CHANGED              ((HRESULT)0x80040223L)

//
// MessageId: VFW_E_NOT_STOPPED
//
// MessageText:
//
// The operation could not be performed because the filter is not stopped.%0
//
#define VFW_E_NOT_STOPPED                ((HRESULT)0x80040224L)

//
// MessageId: VFW_E_NOT_PAUSED
//
// MessageText:
//
// The operation could not be performed because the filter is not paused.%0
//
#define VFW_E_NOT_PAUSED                 ((HRESULT)0x80040225L)

//
// MessageId: VFW_E_NOT_RUNNING
//
// MessageText:
//
// The operation could not be performed because the filter is not running.%0
//
#define VFW_E_NOT_RUNNING                ((HRESULT)0x80040226L)

//
// MessageId: VFW_E_WRONG_STATE
//
// MessageText:
//
// The operation could not be performed because the filter is in the wrong state.%0
//
#define VFW_E_WRONG_STATE                ((HRESULT)0x80040227L)

//
// MessageId: VFW_E_START_TIME_AFTER_END
//
// MessageText:
//
// The sample start time is after the sample end time.%0
//
#define VFW_E_START_TIME_AFTER_END       ((HRESULT)0x80040228L)

//
// MessageId: VFW_E_INVALID_RECT
//
// MessageText:
//
// The supplied rectangle is invalid.%0
//
#define VFW_E_INVALID_RECT               ((HRESULT)0x80040229L)

//
// MessageId: VFW_E_TYPE_NOT_ACCEPTED
//
// MessageText:
//
// This pin cannot use the supplied media type.%0
//
#define VFW_E_TYPE_NOT_ACCEPTED          ((HRESULT)0x8004022AL)

//
// MessageId: VFW_E_SAMPLE_REJECTED
//
// MessageText:
//
// This sample cannot be rendered.%0
//
#define VFW_E_SAMPLE_REJECTED            ((HRESULT)0x8004022BL)

//
// MessageId: VFW_E_SAMPLE_REJECTED_EOS
//
// MessageText:
//
// This sample cannot be rendered because the end of the stream has been reached.%0
//
#define VFW_E_SAMPLE_REJECTED_EOS        ((HRESULT)0x8004022CL)

//
// MessageId: VFW_E_DUPLICATE_NAME
//
// MessageText:
//
// An attempt to add a filter with a duplicate name failed.%0
//
#define VFW_E_DUPLICATE_NAME             ((HRESULT)0x8004022DL)

//
// MessageId: VFW_S_DUPLICATE_NAME
//
// MessageText:
//
// An attempt to add a filter with a duplicate name succeeded with a modified name.%0
//
#define VFW_S_DUPLICATE_NAME             ((HRESULT)0x0004022DL)

//
// MessageId: VFW_E_TIMEOUT
//
// MessageText:
//
// A time-out has expired.%0
//
#define VFW_E_TIMEOUT                    ((HRESULT)0x8004022EL)

//
// MessageId: VFW_E_INVALID_FILE_FORMAT
//
// MessageText:
//
// The file format is invalid.%0
//
#define VFW_E_INVALID_FILE_FORMAT        ((HRESULT)0x8004022FL)

//
// MessageId: VFW_E_ENUM_OUT_OF_RANGE
//
// MessageText:
//
// The list has already been exhausted.%0
//
#define VFW_E_ENUM_OUT_OF_RANGE          ((HRESULT)0x80040230L)

//
// MessageId: VFW_E_CIRCULAR_GRAPH
//
// MessageText:
//
// The filter graph is circular.%0
//
#define VFW_E_CIRCULAR_GRAPH             ((HRESULT)0x80040231L)

//
// MessageId: VFW_E_NOT_ALLOWED_TO_SAVE
//
// MessageText:
//
// Updates are not allowed in this state.%0
//
#define VFW_E_NOT_ALLOWED_TO_SAVE        ((HRESULT)0x80040232L)

//
// MessageId: VFW_E_TIME_ALREADY_PASSED
//
// MessageText:
//
// An attempt was made to queue a command for a time in the past.%0
//
#define VFW_E_TIME_ALREADY_PASSED        ((HRESULT)0x80040233L)

//
// MessageId: VFW_E_ALREADY_CANCELLED
//
// MessageText:
//
// The queued command has already been canceled.%0
//
#define VFW_E_ALREADY_CANCELLED          ((HRESULT)0x80040234L)

//
// MessageId: VFW_E_CORRUPT_GRAPH_FILE
//
// MessageText:
//
// Cannot render the file because it is corrupt.%0
//
#define VFW_E_CORRUPT_GRAPH_FILE         ((HRESULT)0x80040235L)

//
// MessageId: VFW_E_ADVISE_ALREADY_SET
//
// MessageText:
//
// An overlay advise link already exists.%0
//
#define VFW_E_ADVISE_ALREADY_SET         ((HRESULT)0x80040236L)

//
// MessageId: VFW_S_STATE_INTERMEDIATE
//
// MessageText:
//
// The state transition has not completed.%0
//
#define VFW_S_STATE_INTERMEDIATE         ((HRESULT)0x00040237L)

//
// MessageId: VFW_E_NO_MODEX_AVAILABLE
//
// MessageText:
//
// No full-screen modes are available.%0
//
#define VFW_E_NO_MODEX_AVAILABLE         ((HRESULT)0x80040238L)

//
// MessageId: VFW_E_NO_ADVISE_SET
//
// MessageText:
//
// This Advise cannot be canceled because it was not successfully set.%0
//
#define VFW_E_NO_ADVISE_SET              ((HRESULT)0x80040239L)

//
// MessageId: VFW_E_NO_FULLSCREEN
//
// MessageText:
//
// A full-screen mode is not available.%0
//
#define VFW_E_NO_FULLSCREEN              ((HRESULT)0x8004023AL)

//
// MessageId: VFW_E_IN_FULLSCREEN_MODE
//
// MessageText:
//
// Cannot call IVideoWindow methods while in full-screen mode.%0
//
#define VFW_E_IN_FULLSCREEN_MODE         ((HRESULT)0x8004023BL)

//
// MessageId: VFW_E_UNKNOWN_FILE_TYPE
//
// MessageText:
//
// The media type of this file is not recognized.%0
//
#define VFW_E_UNKNOWN_FILE_TYPE          ((HRESULT)0x80040240L)

//
// MessageId: VFW_E_CANNOT_LOAD_SOURCE_FILTER
//
// MessageText:
//
// The source filter for this file could not be loaded.%0
//
#define VFW_E_CANNOT_LOAD_SOURCE_FILTER  ((HRESULT)0x80040241L)

//
// MessageId: VFW_S_PARTIAL_RENDER
//
// MessageText:
//
// Some of the streams in this movie are in an unsupported format.%0
//
#define VFW_S_PARTIAL_RENDER             ((HRESULT)0x00040242L)

//
// MessageId: VFW_E_FILE_TOO_SHORT
//
// MessageText:
//
// A file appeared to be incomplete.%0
//
#define VFW_E_FILE_TOO_SHORT             ((HRESULT)0x80040243L)

//
// MessageId: VFW_E_INVALID_FILE_VERSION
//
// MessageText:
//
// The version number of the file is invalid.%0
//
#define VFW_E_INVALID_FILE_VERSION       ((HRESULT)0x80040244L)

//
// MessageId: VFW_S_SOME_DATA_IGNORED
//
// MessageText:
//
// The file contained some property settings that were not used.%0
//
#define VFW_S_SOME_DATA_IGNORED          ((HRESULT)0x00040245L)

//
// MessageId: VFW_S_CONNECTIONS_DEFERRED
//
// MessageText:
//
// Some connections have failed and have been deferred.%0
//
#define VFW_S_CONNECTIONS_DEFERRED       ((HRESULT)0x00040246L)

//
// MessageId: VFW_E_INVALID_CLSID
//
// MessageText:
//
// This file is corrupt: it contains an invalid class identifier.%0
//
#define VFW_E_INVALID_CLSID              ((HRESULT)0x80040247L)

//
// MessageId: VFW_E_INVALID_MEDIA_TYPE
//
// MessageText:
//
// This file is corrupt: it contains an invalid media type.%0
//
#define VFW_E_INVALID_MEDIA_TYPE         ((HRESULT)0x80040248L)

 // Message id from WINWarning.H
//
// MessageId: VFW_E_BAD_KEY
//
// MessageText:
//
// A registry entry is corrupt.%0
//
#define VFW_E_BAD_KEY                    ((HRESULT)0x800403F2L)

 // Message id from WINWarning.H
//
// MessageId: VFW_S_NO_MORE_ITEMS
//
// MessageText:
//
// The end of the list has been reached.%0
//
#define VFW_S_NO_MORE_ITEMS              ((HRESULT)0x00040103L)

//
// MessageId: VFW_E_SAMPLE_TIME_NOT_SET
//
// MessageText:
//
// No time stamp has been set for this sample.%0
//
#define VFW_E_SAMPLE_TIME_NOT_SET        ((HRESULT)0x80040249L)

//
// MessageId: VFW_S_RESOURCE_NOT_NEEDED
//
// MessageText:
//
// The resource specified is no longer needed.%0
//
#define VFW_S_RESOURCE_NOT_NEEDED        ((HRESULT)0x00040250L)

//
// MessageId: VFW_E_MEDIA_TIME_NOT_SET
//
// MessageText:
//
// No media time stamp has been set for this sample.%0
//
#define VFW_E_MEDIA_TIME_NOT_SET         ((HRESULT)0x80040251L)

//
// MessageId: VFW_E_NO_TIME_FORMAT_SET
//
// MessageText:
//
// No media time format has been selected.%0
//
#define VFW_E_NO_TIME_FORMAT_SET         ((HRESULT)0x80040252L)

//
// MessageId: VFW_E_MONO_AUDIO_HW
//
// MessageText:
//
// Cannot change balance because audio device is mono only.%0
//
#define VFW_E_MONO_AUDIO_HW              ((HRESULT)0x80040253L)

//
// MessageId: VFW_S_MEDIA_TYPE_IGNORED
//
// MessageText:
//
// A connection could not be made with the media type in the persistent graph,%0
// but has been made with a negotiated media type.%0
//
#define VFW_S_MEDIA_TYPE_IGNORED         ((HRESULT)0x00040254L)

//
// MessageId: VFW_E_NO_DECOMPRESSOR
//
// MessageText:
//
// Cannot play back the video stream: no suitable decompressor could be found.%0
//
#define VFW_E_NO_DECOMPRESSOR            ((HRESULT)0x80040255L)

//
// MessageId: VFW_E_NO_AUDIO_HARDWARE
//
// MessageText:
//
// Cannot play back the audio stream: no audio hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_AUDIO_HARDWARE          ((HRESULT)0x80040256L)

//
// MessageId: VFW_S_VIDEO_NOT_RENDERED
//
// MessageText:
//
// Cannot play back the video stream: no suitable decompressor could be found.%0
//
#define VFW_S_VIDEO_NOT_RENDERED         ((HRESULT)0x00040257L)

//
// MessageId: VFW_S_AUDIO_NOT_RENDERED
//
// MessageText:
//
// Cannot play back the audio stream: no audio hardware is available.%0
//
#define VFW_S_AUDIO_NOT_RENDERED         ((HRESULT)0x00040258L)

//
// MessageId: VFW_E_RPZA
//
// MessageText:
//
// Cannot play back the video stream: format 'RPZA' is not supported.%0
//
#define VFW_E_RPZA                       ((HRESULT)0x80040259L)

//
// MessageId: VFW_S_RPZA
//
// MessageText:
//
// Cannot play back the video stream: format 'RPZA' is not supported.%0
//
#define VFW_S_RPZA                       ((HRESULT)0x0004025AL)

//
// MessageId: VFW_E_PROCESSOR_NOT_SUITABLE
//
// MessageText:
//
// ActiveMovie cannot play MPEG movies on this processor.%0
//
#define VFW_E_PROCESSOR_NOT_SUITABLE     ((HRESULT)0x8004025BL)

//
// MessageId: VFW_E_UNSUPPORTED_AUDIO
//
// MessageText:
//
// Cannot play back the audio stream: the audio format is not supported.%0
//
#define VFW_E_UNSUPPORTED_AUDIO          ((HRESULT)0x8004025CL)

//
// MessageId: VFW_E_UNSUPPORTED_VIDEO
//
// MessageText:
//
// Cannot play back the video stream: the video format is not supported.%0
//
#define VFW_E_UNSUPPORTED_VIDEO          ((HRESULT)0x8004025DL)

//
// MessageId: VFW_E_MPEG_NOT_CONSTRAINED
//
// MessageText:
//
// ActiveMovie cannot play this video stream because it falls outside the constrained standard.%0
//
#define VFW_E_MPEG_NOT_CONSTRAINED       ((HRESULT)0x8004025EL)

//
// MessageId: VFW_E_NOT_IN_GRAPH
//
// MessageText:
//
// Cannot perform the requested function on an object that is not in the filter graph.%0
//
#define VFW_E_NOT_IN_GRAPH               ((HRESULT)0x8004025FL)

//
// MessageId: VFW_S_ESTIMATED
//
// MessageText:
//
// The value returned had to be estimated.  It's accuracy can not be guaranteed.%0
//
#define VFW_S_ESTIMATED                  ((HRESULT)0x00040260L)

//
// MessageId: VFW_E_NO_TIME_FORMAT
//
// MessageText:
//
// Cannot get or set time related information on an object that is using a time format of TIME_FORMAT_NONE.%0
//
#define VFW_E_NO_TIME_FORMAT             ((HRESULT)0x80040261L)

//
// MessageId: VFW_E_READ_ONLY
//
// MessageText:
//
// The connection cannot be made because the stream is read only and the filter alters the data.%0
//
#define VFW_E_READ_ONLY                  ((HRESULT)0x80040262L)

//
// MessageId: VFW_S_RESERVED
//
// MessageText:
//
// This success code is reserved for internal purposes within ActiveMovie.%0
//
#define VFW_S_RESERVED                   ((HRESULT)0x00040263L)

//
// MessageId: VFW_E_BUFFER_UNDERFLOW
//
// MessageText:
//
// The buffer is not full enough.%0
//
#define VFW_E_BUFFER_UNDERFLOW           ((HRESULT)0x80040264L)

//
// MessageId: VFW_E_UNSUPPORTED_STREAM
//
// MessageText:
//
// Cannot play back the file.  The format is not supported.%0
//
#define VFW_E_UNSUPPORTED_STREAM         ((HRESULT)0x80040265L)

//
// MessageId: VFW_E_NO_TRANSPORT
//
// MessageText:
//
// Pins cannot connect due to not supporting the same transport.%0
//
#define VFW_E_NO_TRANSPORT               ((HRESULT)0x80040266L)

//
// MessageId: VFW_S_STREAM_OFF
//
// MessageText:
//
// The stream has been turned off.%0
//
#define VFW_S_STREAM_OFF                 ((HRESULT)0x00040267L)

//
// MessageId: VFW_S_CANT_CUE
//
// MessageText:
//
// The graph can't be cued because of lack of or corrupt data.%0
//
#define VFW_S_CANT_CUE                   ((HRESULT)0x00040268L)

//
// MessageId: VFW_E_BAD_VIDEOCD
//
// MessageText:
//
// The Video CD can't be read correctly by the device or is the data is corrupt.%0
//
#define VFW_E_BAD_VIDEOCD                ((HRESULT)0x80040269L)

//
// MessageId: VFW_S_NO_STOP_TIME
//
// MessageText:
//
// The stop time for the sample was not set.%0
//
#define VFW_S_NO_STOP_TIME               ((HRESULT)0x00040270L)

//
// MessageId: VFW_E_OUT_OF_VIDEO_MEMORY
//
// MessageText:
//
// There is not enough Video Memory at this display resolution and number of colors. Reducing resolution might help.%0
//
#define VFW_E_OUT_OF_VIDEO_MEMORY        ((HRESULT)0x80040271L)

//
// MessageId: VFW_E_VP_NEGOTIATION_FAILED
//
// MessageText:
//
// The VideoPort connection negotiation process has failed.%0
//
#define VFW_E_VP_NEGOTIATION_FAILED      ((HRESULT)0x80040272L)

//
// MessageId: VFW_E_DDRAW_CAPS_NOT_SUITABLE
//
// MessageText:
//
// Either DirectDraw has not been installed or the Video Card capabilities are not suitable. Make sure the display is not in 16 color mode.%0
//
#define VFW_E_DDRAW_CAPS_NOT_SUITABLE    ((HRESULT)0x80040273L)

//
// MessageId: VFW_E_NO_VP_HARDWARE
//
// MessageText:
//
// No VideoPort hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_VP_HARDWARE             ((HRESULT)0x80040274L)

//
// MessageId: VFW_E_NO_CAPTURE_HARDWARE
//
// MessageText:
//
// No Capture hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_CAPTURE_HARDWARE        ((HRESULT)0x80040275L)

//
// MessageId: VFW_E_DVD_OPERATION_INHIBITED
//
// MessageText:
//
// This User Operation is inhibited by DVD Content at this time.%0
//
#define VFW_E_DVD_OPERATION_INHIBITED    ((HRESULT)0x80040276L)

//
// MessageId: VFW_E_DVD_INVALIDDOMAIN
//
// MessageText:
//
// This Operation is not permitted in the current domain.%0
//
#define VFW_E_DVD_INVALIDDOMAIN          ((HRESULT)0x80040277L)

//
// MessageId: VFW_E_DVD_NO_BUTTON
//
// MessageText:
//
// Requested Button is not available.%0
//
#define VFW_E_DVD_NO_BUTTON              ((HRESULT)0x80040278L)

//
// MessageId: VFW_E_DVD_GRAPHNOTREADY
//
// MessageText:
//
// DVD-Video playback graph has not been built yet.%0
//
#define VFW_E_DVD_GRAPHNOTREADY          ((HRESULT)0x80040279L)

//
// MessageId: VFW_E_DVD_RENDERFAIL
//
// MessageText:
//
// DVD-Video playback graph building failed.%0
//
#define VFW_E_DVD_RENDERFAIL             ((HRESULT)0x8004027AL)

//
// MessageId: VFW_E_DVD_DECNOTENOUGH
//
// MessageText:
//
// DVD-Video playback graph could not be built due to insufficient decoders.%0
//
#define VFW_E_DVD_DECNOTENOUGH           ((HRESULT)0x8004027BL)

//
// MessageId: VFW_E_DDRAW_VERSION_NOT_SUITABLE
//
// MessageText:
//
// Version number of direct draw not suitable. Make sure to install dx5 or higher version.%0
//
#define VFW_E_DDRAW_VERSION_NOT_SUITABLE ((HRESULT)0x8004027CL)

//
// MessageId: VFW_E_COPYPROT_FAILED
//
// MessageText:
//
// Copy protection cannot be enabled. Please make sure any other copy protected content is not being shown now.%0
//
#define VFW_E_COPYPROT_FAILED            ((HRESULT)0x8004027DL)

//
// MessageId: VFW_S_NOPREVIEWPIN
//
// MessageText:
//
// There was no preview pin available, so the capture pin output is being split to provide both capture and preview.%0
//
#define VFW_S_NOPREVIEWPIN               ((HRESULT)0x0004027EL)

//
// MessageId: VFW_E_FRAME_STEP_UNSUPPORTED
//
// MessageText:
//
// Frame step is not supported on this configuration.%0
//
#define VFW_E_FRAME_STEP_UNSUPPORTED     ((HRESULT)0x8004028EL)

//
// MessageId: VFW_E_VMR_NOT_IN_MIXER_MODE
//
// MessageText:
//
// The VMR has not yet created a mixing component.  That is, IVMRFilterConfig::SetNumberofStreams has not yet been called.%0
//
#define VFW_E_VMR_NOT_IN_MIXER_MODE      ((HRESULT)0x80040296L)

//
// MessageId: VFW_E_VMR_NO_AP_SUPPLIED
//
// MessageText:
//
// The application has not yet provided the VMR filter with a valid allocator-presenter object.%0
//
#define VFW_E_VMR_NO_AP_SUPPLIED         ((HRESULT)0x80040297L)

//
// MessageId: VFW_E_VMR_NO_DEINTERLACE_HW
//
// MessageText:
//
// The VMR could not find any de-interlacing hardware on the current display device.%0
//
#define VFW_E_VMR_NO_DEINTERLACE_HW      ((HRESULT)0x80040298L)

//
// MessageId: VFW_E_VMR_NO_PROCAMP_HW
//
// MessageText:
//
// The VMR could not find any ProcAmp hardware on the current display device.%0
//
#define VFW_E_VMR_NO_PROCAMP_HW          ((HRESULT)0x80040299L)

//
// MessageId: VFW_E_DVD_VMR9_INCOMPATIBLEDEC
//
// MessageText:
//
// VMR9 does not work with VPE-based hardware decoders.%0
//
#define VFW_E_DVD_VMR9_INCOMPATIBLEDEC   ((HRESULT)0x8004029AL)

//
// MessageId: VFW_E_NO_COPP_HW
//
// MessageText:
//
// The current display device does not support Content Output Protection Protocol (COPP) H/W.%0
//
#define VFW_E_NO_COPP_HW                 ((HRESULT)0x8004029BL)

//
//
// E_PROP_SET_UNSUPPORTED and E_PROP_ID_UNSUPPORTED are added here using
// HRESULT_FROM_WIN32() because VC5 doesn't have WinNT's new error codes
// from winerror.h, and because it is more convienent to have them already
// formed as HRESULTs.  These should correspond to:
//     HRESULT_FROM_WIN32(ERROR_NOT_FOUND)     == E_PROP_ID_UNSUPPORTED
//     HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND) == E_PROP_SET_UNSUPPORTED
#if !defined(E_PROP_SET_UNSUPPORTED)
//
// MessageId: E_PROP_SET_UNSUPPORTED
//
// MessageText:
//
// The Specified property set is not supported.%0
//
#define E_PROP_SET_UNSUPPORTED           ((HRESULT)0x80070492L)

#endif //!defined(E_PROP_SET_UNSUPPORTED)
#if !defined(E_PROP_ID_UNSUPPORTED)
//
// MessageId: E_PROP_ID_UNSUPPORTED
//
// MessageText:
//
// The specified property ID is not supported for the specified property set.%0
//
#define E_PROP_ID_UNSUPPORTED            ((HRESULT)0x80070490L)

#endif //!defined(E_PROP_ID_UNSUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\uxtheme.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//---------------------------------------------------------------------------
//
// uxtheme.h - theming API header file.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

#ifndef _UXTHEME_H_
#define _UXTHEME_H_

#include <commctrl.h>
#include <SpecStrings.h>

#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif /* _UXTHEME_ */
#endif /* THEMEAPI */

typedef HANDLE HTHEME;          // handle to a section of theme data for class

#define MAX_THEMECOLOR  64
#define MAX_THEMESIZE   64

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <vssym32.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassList
    );

#define OTD_FORCE_RECT_SIZING   0x00000001          // make all parts size to rect
#define OTD_NONCLIENT           0x00000002          // set if hTheme to be used for nonclient area
#define OTD_VALIDBITS           (OTD_FORCE_RECT_SIZING | \
                                 OTD_NONCLIENT)

//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeDataEx(
    HWND hwnd,
    LPCWSTR pszClassList,
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  CloseThemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI
CloseThemeData(
    HTHEME hTheme
    );

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt LPCRECT pClipRect
    );

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT           0x00000001  // rcClip has been specified
#define DTBG_DRAWSOLID          0x00000002  // DEPRECATED: draw transparent/alpha images as solid
#define DTBG_OMITBORDER         0x00000004  // don't draw border of part
#define DTBG_OMITCONTENT        0x00000008  // don't draw content area of part
#define DTBG_COMPUTINGREGION    0x00000010  // TRUE if calling to compute region
#define DTBG_MIRRORDC           0x00000020  // assume the hdc is mirrorred and
                                            // flip images as appropriate (currently 
                                            // only supported for bgtype=imagefile)
#define DTBG_NOMIRROR           0x00000040  // don't mirror the output, overrides everything else 
#define DTBG_VALIDBITS          (DTBG_CLIPRECT | \
                                 DTBG_DRAWSOLID | \
                                 DTBG_OMITBORDER | \
                                 DTBG_OMITCONTENT | \
                                 DTBG_COMPUTINGREGION | \
                                 DTBG_MIRRORDC | \
                                 DTBG_NOMIRROR)

typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
} DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackgroundEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt const DTBGOPTS *pOptions
    );

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----
#define DTT_GRAYED              0x00000001          // draw a grayed-out string (this is deprecated)
#define DTT_FLAGS2VALIDBITS     (DTT_GRAYED)

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    DWORD dwTextFlags2,
    LPCRECT pRect
    );


//---------------------------------------------------------------------------
//
// DrawThemeTextEx
//

// Callback function used by DrawTextWithGlow instead of DrawTextW
typedef 
int
(WINAPI *DTT_CALLBACK_PROC)
(
    __in HDC hdc,
    __inout_ecount(cchText) LPWSTR pszText,
    __in int cchText,
    __inout LPRECT prc,
    __in UINT dwFlags,
    __in LPARAM lParam);

//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR       (1UL << 0)      // crText has been specified
#define DTT_BORDERCOLOR     (1UL << 1)      // crBorder has been specified
#define DTT_SHADOWCOLOR     (1UL << 2)      // crShadow has been specified
#define DTT_SHADOWTYPE      (1UL << 3)      // iTextShadowType has been specified
#define DTT_SHADOWOFFSET    (1UL << 4)      // ptShadowOffset has been specified
#define DTT_BORDERSIZE      (1UL << 5)      // iBorderSize has been specified
#define DTT_FONTPROP        (1UL << 6)      // iFontPropId has been specified
#define DTT_COLORPROP       (1UL << 7)      // iColorPropId has been specified
#define DTT_STATEID         (1UL << 8)      // IStateId has been specified
#define DTT_CALCRECT        (1UL << 9)      // Use pRect as and in/out parameter
#define DTT_APPLYOVERLAY    (1UL << 10)     // fApplyOverlay has been specified
#define DTT_GLOWSIZE        (1UL << 11)     // iGlowSize has been specified
#define DTT_CALLBACK        (1UL << 12)     // pfnDrawTextCallback has been specified
#define DTT_COMPOSITED      (1UL << 13)     // Draws text with antialiased alpha (needs a DIB section)
#define DTT_VALIDBITS       (DTT_TEXTCOLOR | \
                             DTT_BORDERCOLOR | \
                             DTT_SHADOWCOLOR | \
                             DTT_SHADOWTYPE | \
                             DTT_SHADOWOFFSET | \
                             DTT_BORDERSIZE | \
                             DTT_FONTPROP | \
                             DTT_COLORPROP | \
                             DTT_STATEID | \
                             DTT_CALCRECT | \
                             DTT_APPLYOVERLAY | \
                             DTT_GLOWSIZE | \
                             DTT_COMPOSITED)

typedef struct _DTTOPTS
{
    DWORD             dwSize;              // size of the struct
    DWORD             dwFlags;             // which options have been specified
    COLORREF          crText;              // color to use for text fill
    COLORREF          crBorder;            // color to use for text outline
    COLORREF          crShadow;            // color to use for text shadow
    int               iTextShadowType;     // TST_SINGLE or TST_CONTINUOUS
    POINT             ptShadowOffset;      // where shadow is drawn (relative to text)
    int               iBorderSize;         // Border radius around text
    int               iFontPropId;         // Font property to use for the text instead of TMT_FONT
    int               iColorPropId;        // Color property to use for the text instead of TMT_TEXTCOLOR
    int               iStateId;            // Alternate state id
    BOOL              fApplyOverlay;       // Overlay text on top of any text effect?
    int               iGlowSize;           // Glow radious around text
    DTT_CALLBACK_PROC pfnDrawTextCallback; // Callback for DrawText
    LPARAM            lParam;              // Parameter for callback
} DTTOPTS, *PDTTOPTS; 

THEMEAPI
DrawThemeTextEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    __inout LPRECT pRect,
    __in_opt const DTTOPTS *pOptions
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pBoundingRect,
    __out LPRECT pContentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pContentRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __out HRGN *pRegion
    );

enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW             // size that theme mgr will use to draw part
};

//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI
GetThemePartSize(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    __in_opt LPCRECT prc,
    enum THEMESIZE eSize,
    __out SIZE *psz
    );

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchCharCount) LPCWSTR pszText,
    int cchCharCount,
    DWORD dwTextFlags,
    __in_opt LPCRECT pBoundingRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __out TEXTMETRICW *ptm
    );

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x00000000
//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x00000002      // Return code may be either HTCLIENT or HTBORDER. 
//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x00000004
//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x00000010      // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x00000020      // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x00000040      // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x00000080      // Hit test bottom resizing border
#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT | \
                                     HTTB_RESIZINGBORDER_TOP | \
                                     HTTB_RESIZINGBORDER_RIGHT | \
                                     HTTB_RESIZINGBORDER_BOTTOM)
// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE         0x00000100
// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS    0x00000200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI
HitTestThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    LPCRECT pRect,
    HRGN hrgn,
    POINT ptTest,
    __out WORD *pwHitTestCode
    );

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pDestRect,
    UINT uEdge,
    UINT uFlags,
    __out_opt LPRECT pContentRect
    );

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeIcon(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    HIMAGELIST himl,
    int iImageIndex
    );

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out COLORREF *pColor
    );

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMetric(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI
GetThemeString(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszBuff,
    int cchMaxBuffChars
    );

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBool(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out BOOL *pfVal
    );

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeEnumValue(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI
GetThemePosition(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out POINT *pPoint
    );

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI
GetThemeFont(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LOGFONTW *pFont
    );

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeRect(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LPRECT pRect
    );

typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMargins(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __in_opt LPCRECT prc,
    __out MARGINS *pMargins
    );

#if WINVER >= 0x0600
#define MAX_INTLIST_COUNT 402
#else
#define MAX_INTLIST_COUNT 10
#endif

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeIntList(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out INTLIST *pIntList
    );

enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI
GetThemePropertyOrigin(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out enum PROPERTYORIGIN *pOrigin
    );

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName,
    LPCWSTR pszSubIdList
    );

enum WINDOWTHEMEATTRIBUTETYPE
{
    WTA_NONCLIENT = 1
};

typedef struct _WTA_OPTIONS
{
    DWORD dwFlags;          // values for each style option specified in the bitmask
    DWORD dwMask;           // bitmask for flags that are changing
                            // valid options are: WTNCA_NODRAWCAPTION, WTNCA_NODRAWICON, WTNCA_NOSYSMENU
} WTA_OPTIONS, *PWTA_OPTIONS;

#define WTNCA_NODRAWCAPTION       0x00000001    // don't draw the window caption
#define WTNCA_NODRAWICON          0x00000002    // don't draw the system icon
#define WTNCA_NOSYSMENU           0x00000004    // don't expose the system menu icon functionality
#define WTNCA_NOMIRRORHELP        0x00000008    // don't mirror the question mark, even in RTL layout
#define WTNCA_VALIDBITS           (WTNCA_NODRAWCAPTION | \
                                   WTNCA_NODRAWICON | \
                                   WTNCA_NOSYSMENU | \
                                   WTNCA_NOMIRRORHELP)

THEMEAPI
SetWindowThemeAttribute(
    HWND hwnd,
    enum WINDOWTHEMEATTRIBUTETYPE eAttribute,
    __in_bcount(cbAttribute) PVOID pvAttribute,
    DWORD cbAttribute
    );

__inline HRESULT SetWindowThemeNonClientAttributes(HWND hwnd, DWORD dwMask, DWORD dwAttributes)    
{
    WTA_OPTIONS wta;
    wta.dwFlags = dwAttributes;
    wta.dwMask = dwMask;
    return SetWindowThemeAttribute(hwnd, WTA_NONCLIENT, (void*)&(wta), sizeof(wta));
}


//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI
GetThemeFilename(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszThemeFileName,
    int cchMaxBuffChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF)
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH)
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    );

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER       (border width)
//                          SM_CXVSCROLL      (scrollbar width)
//                          SM_CYHSCROLL      (scrollbar height)
//                          SM_CXSIZE         (caption width)
//                          SM_CYSIZE         (caption height)
//                          SM_CXSMSIZE       (small caption width)
//                          SM_CYSMSIZE       (small caption height)
//                          SM_CXMENUSIZE     (menubar width)
//                          SM_CYMENUSIZE     (menubar height)
//                          SM_CXPADDEDBORDER (padded border width)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int)
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    );

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    __out LOGFONTW *plf
    );

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    __out_ecount(cchMaxStringChars) LPWSTR pszStringBuff,
    int cchMaxStringChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    __out int *piValue
    );

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeActive(
    VOID
    );

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsAppThemed(
    VOID
    );

//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
GetWindowTheme(
    HWND hwnd
    );

#define ETDT_DISABLE                    0x00000001
#define ETDT_ENABLE                     0x00000002
#define ETDT_USETABTEXTURE              0x00000004
#define ETDT_USEAEROWIZARDTABTEXTURE    0x00000008

#define ETDT_ENABLETAB              (ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE)
        
#define ETDT_ENABLEAEROWIZARDTAB    (ETDT_ENABLE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)
                             
#define ETDT_VALIDBITS              (ETDT_DISABLE | \
                                     ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)

//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------
THEMEAPI
EnableThemeDialogTexture(
    __in HWND hwnd,
    __in DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeDialogTextureEnabled(
    __in HWND hwnd
    );

//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1UL << 0)
#define STAP_ALLOW_CONTROLS     (1UL << 1)
#define STAP_ALLOW_WEBCONTENT   (1UL << 2)
#define STAP_VALIDBITS          (STAP_ALLOW_NONCLIENT | \
                                 STAP_ALLOW_CONTROLS | \
                                 STAP_ALLOW_WEBCONTENT)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD)
GetThemeAppProperties(
    VOID
    );

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void)
SetThemeAppProperties(
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    __out_ecount(cchMaxNameChars) LPWSTR pszThemeFileName,
    int cchMaxNameChars,
    __out_ecount_opt(cchMaxColorChars) LPWSTR pszColorBuff,
    int cchMaxColorChars,
    __out_ecount_opt(cchMaxSizeChars) LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    );

#define SZ_THDOCPROP_DISPLAYNAME    L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME  L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP        L"ToolTip"
#define SZ_THDOCPROP_AUTHOR         L"author"

THEMEAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    __out_ecount(cchMaxValChars) LPWSTR pszValueBuff,
    int cchMaxValChars
    );

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackground(
    HWND hwnd,
    HDC hdc,
    __in_opt const RECT* prc
    );


#define DTPB_WINDOWDC           0x00000001
#define DTPB_USECTLCOLORSTATIC  0x00000002
#define DTPB_USEERASEBKGND      0x00000004

//---------------------------------------------------------------------------
// DrawThemeParentBackgroundEx()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//                        Sends a WM_ERASEBKGND message followed by a WM_PRINTCLIENT.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  dwFlags             - if 0, only returns S_OK if the parent handled 
//                        WM_PRINTCLIENT.
//                      - if DTPB_WINDOWDC is set, hdc is assumed to be a window DC,
//                        not a client DC.
//                      - if DTPB_USEERASEBKGND is set, the function will return S_OK 
//                        without sending a WM_CTLCOLORSTATIC message if the parent 
//                        actually painted on WM_ERASEBKGND.
//                      - if DTPB_CTLCOLORSTATIC is set, the function will send
//                        a WM_CTLCOLORSTATIC message to the parent and use the 
//                        brush if one is provided, else COLOR_BTNFACE.
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//
//  Return value        - S_OK if something was painted, S_FALSE if not.
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackgroundEx(
    HWND hwnd,
    HDC hdc,
    DWORD dwFlags,
    __in_opt const RECT* prc
    );

//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI
EnableTheming(
    BOOL fEnable
    );

#define GBF_DIRECT      0x00000001      // direct dereferencing.
#define GBF_COPY        0x00000002      // create a copy of the bitmap
#define GBF_VALIDBITS   (GBF_DIRECT | \
                         GBF_COPY)

#if (_WIN32_WINNT >= 0x0600)

THEMEAPI
GetThemeBitmap(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    ULONG dwFlags,
    __out HBITMAP* phBitmap
    );

//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeStream(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out VOID **ppvStream,
    __out_opt DWORD *pcbStream,
    __in_opt HINSTANCE hInst
    );

#endif // #if (_WIN32_WINNT >= 0x0600)


//------------------------------------------------------------------------
//  BufferedPaintInit() - Initialize the Buffered Paint API.
//                        Should be called prior to BeginBufferedPaint,
//                        and should have a matching BufferedPaintUnInit.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintInit(
    VOID
    );

//------------------------------------------------------------------------
//  BufferedPaintUnInit() - Uninitialize the Buffered Paint API.
//                          Should be called once for each call to BufferedPaintInit,
//                          when calls to BeginBufferedPaint are no longer needed.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintUnInit(
    VOID
    );

//------------------------------------------------------------------------
//  BeginBufferedPaint() - Begins a buffered paint operation.
//
//    hdcTarget          - Target DC on which the buffer will be painted
//    rcTarget           - Rectangle specifying the area of the target DC to paint to
//    dwFormat           - Format of the buffer (see BP_BUFFERFORMAT)
//    pPaintParams       - Paint operation parameters (see BP_PAINTPARAMS)
//    phBufferedPaint    - Pointer to receive handle to new buffered paint context
//------------------------------------------------------------------------

// HPAINTBUFFER
typedef HANDLE HPAINTBUFFER;  // handle to a buffered paint context


// BP_BUFFERFORMAT
typedef enum _BP_BUFFERFORMAT
{
    BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
    BPBF_DIB,                 // Device-independent bitmap
    BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
    BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} BP_BUFFERFORMAT;

#define BPBF_COMPOSITED BPBF_TOPDOWNDIB


// BP_ANIMATIONSTYLE
typedef enum _BP_ANIMATIONSTYLE
{
    BPAS_NONE,                // No animation
    BPAS_LINEAR,              // Linear fade animation
    BPAS_CUBIC,               // Cubic fade animation
    BPAS_SINE                 // Sinusoid fade animation
} BP_ANIMATIONSTYLE;


// BP_ANIMATIONPARAMS
typedef struct _BP_ANIMATIONPARAMS
{
    DWORD               cbSize;
    DWORD               dwFlags; // BPAF_ flags
    BP_ANIMATIONSTYLE   style;
    DWORD               dwDuration;
} BP_ANIMATIONPARAMS, *PBP_ANIMATIONPARAMS;

#define BPPF_ERASE               0x0001 // Empty the buffer during BeginBufferedPaint()
#define BPPF_NOCLIP              0x0002 // Don't apply the target DC's clip region to the double buffer
#define BPPF_NONCLIENT           0x0004 // Using a non-client DC

                                        
// BP_PAINTPARAMS
typedef struct _BP_PAINTPARAMS
{
    DWORD                       cbSize;
    DWORD                       dwFlags; // BPPF_ flags
    const RECT *                prcExclude;
    const BLENDFUNCTION *       pBlendFunction;
} BP_PAINTPARAMS, *PBP_PAINTPARAMS;

THEMEAPI_(HPAINTBUFFER)
BeginBufferedPaint(
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __out HDC *phdc
    );


//------------------------------------------------------------------------
//  EndBufferedPaint() - Ends a buffered paint operation.
//
//    hBufferedPaint   - handle to buffered paint context
//    fUpdateTarget    - update target DC
//------------------------------------------------------------------------
THEMEAPI
EndBufferedPaint(
    HPAINTBUFFER hBufferedPaint,
    BOOL fUpdateTarget
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetRect() - Returns the target rectangle specified during BeginBufferedPaint
//
//    hBufferedPaint             - handle to buffered paint context
//    prc                        - pointer to receive target rectangle
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintTargetRect(
    HPAINTBUFFER hBufferedPaint,
    __out RECT *prc
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetDC() - Returns the target DC specified during BeginBufferedPaint
//
//    hBufferedPaint           - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintTargetDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintDC() - Returns the same paint DC returned by BeginBufferedPaint
//
//    hBufferedPaint     - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintBits() - Obtains a pointer to the buffer bitmap, if the buffer is a DIB
//
//    hBufferedPaint       - handle to buffered paint context
//    ppbBuffer            - pointer to receive pointer to buffer bitmap pixels
//    pcxRow               - pointer to receive width of buffer bitmap, in pixels;
//                           this value may not necessarily be equal to the buffer width
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintBits(
    HPAINTBUFFER hBufferedPaint,
    __out RGBQUAD **ppbBuffer,
    __out int *pcxRow
    );

//------------------------------------------------------------------------
//  BufferedPaintClear() - Clears given rectangle to ARGB = {0, 0, 0, 0}
//
//    hBufferedPaint     - handle to buffered paint context
//    prc                - rectangle to clear; NULL specifies entire buffer
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintClear(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc
    );

//------------------------------------------------------------------------
//  BufferedPaintSetAlpha() - Set alpha to given value in given rectangle
//
//    hBufferedPaint        - handle to buffered paint context
//    prc                   - rectangle to set alpha in; NULL specifies entire buffer
//    alpha                 - alpha value to set in the given rectangle
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintSetAlpha(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc,
    BYTE alpha
    );

// Macro for setting the buffer to opaque (alpha = 255)
#define BufferedPaintMakeOpaque(hBufferedPaint, prc) BufferedPaintSetAlpha(hBufferedPaint, prc, 255)

//------------------------------------------------------------------------
//  BufferedPaintStopAllAnimations() - Stop all buffer animations for the given window
//
//    hwnd                           - window on which to stop all animations
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintStopAllAnimations(
    HWND hwnd
    );

typedef HANDLE HANIMATIONBUFFER;  // handle to a buffered paint animation

THEMEAPI_(HANIMATIONBUFFER)
BeginBufferedAnimation(
    HWND hwnd,
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __in BP_ANIMATIONPARAMS *pAnimationParams,
    __out HDC *phdcFrom,
    __out HDC *phdcTo
    );

THEMEAPI
EndBufferedAnimation(
    HANIMATIONBUFFER hbpAnimation,
    BOOL fUpdateTarget
    );

THEMEAPI_(BOOL)
BufferedPaintRenderAnimation(
    HWND hwnd,
    HDC hdcTarget
    );
    
//----------------------------------------------------------------------------
// Tells if the DWM is running, and composition effects are possible for this 
// process (themes are active). 
// Roughly equivalent to "DwmIsCompositionEnabled() && IsAppthemed()"
//----------------------------------------------------------------------------
THEMEAPI_(BOOL) IsCompositionActive();

//------------------------------------------------------------------------
//  GetThemeTransitionDuration()
//                      - Gets the duration for the specified transition
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateIdFrom        - starting state number of part
//  iStateIdTo          - ending state number of part
//  iPropId             - property id 
//  pdwDuration         - receives the transition duration
//------------------------------------------------------------------------
THEMEAPI
GetThemeTransitionDuration(
    HTHEME hTheme,
    int iPartId,
    int iStateIdFrom,
    int iStateIdTo,
    int iPropId,
    __out DWORD *pdwDuration
    );  

#endif /* _UXTHEME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vibrate.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// File: vibrate.h
//
// Purpose: API for controlling the vibrator.
//

#pragma once

//
// Overview: A vibration "song" will consist of an array of "vibration notes", each note specifying an 
// amplitude, a frequency, and a duration.
//


//
// Definition of a vibrate note.
//
// wDuration is the duration of the note in milliseconds.
// bAmplitude and bFrequency are on a scale of zero to 7, with 0xFF meaning Default.  There are no set 
//    units; the driver can interpret the numbers in whatever units it likes.
//    However, bAmplitude=0 always means "off". 
//
typedef struct
{
    WORD wDuration;
    BYTE bAmplitude;  
    BYTE bFrequency;
} VIBRATENOTE; 

//
// Starts playing the vibration song specified by rgvn.
//
// cvn == number of elements in rgvn
// rgvn == an array of VIBRATENOTEs that define the song
// fRepeat == should the song be repeated (until the timeout expires)
// dwTimeout == the maximum amount of time the song should play, in milliseconds, 
//    including any repetition.  May be INFINITE.
//
// NOTE: If rgvn == NULL, (and therefore cvn should equal 0) that means you want a default amplitude, 
//    a default frequency, and an infinite duration for that note (of course, the dwTimeout parameter 
//    will still stop your song).  So to play a simple vibrate of 2 seconds you do:
// 
//       Vibrate(0, NULL, TRUE/*don't care*/, 2000);
//
// Return values:
//    E_FAIL == failure, probably device not present (use VibrateGetDeviceCaps)
//    E_NOTIMPL == the feature you are attempting to use is not yet implemented
//    S_OK == hurray, everything's great
//
HRESULT Vibrate(DWORD cvn, const VIBRATENOTE * rgvn, BOOL fRepeat, DWORD dwTimeout);

//
// Stops all current songs in this process.
//
// Return values:
//    E_FAIL == failure, probably device not present (use VibrateGetDeviceCaps)
//    S_OK == hurray, everything's great
//
HRESULT VibrateStop (void);

//
// List of vibrator device capabilities.
//
typedef enum 
{
    VDC_AMPLITUDE,
    VDC_FREQUENCY,
    VDC_LAST
} VIBRATEDEVICECAPS;

//
// Returns the number of steps (0 to 7) that the hardware supports.  Zero means the device has no vibrator.  
// One means the vibrator only supports one level. That is, it only supports on/off. 
// An application can always construct its VIBRATENOTEs as if the device supports all 8 levels.  
// The Vibrate function will map the level specified in the note to one of the levels 
// the device actually supports.
//
int VibrateGetDeviceCaps (VIBRATEDEVICECAPS vdc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\voicectl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ 
  Copyright (c) Microsoft Corporation. All rights reserved.
  
  File: VoiceCtl.c
  
  Abstract:
  
  Contents:
	Voice Control related defines
  
--*/

#ifndef __VOICE_CTL_H__
#define __VOICE_CTL_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct tag_NM_VOICE_RECORDER 
{
	 NMHDR	    hdr;                     
	 DWORD		dwExtra;            
} NM_VOICE_RECORDER, *LPNM_VOICE_RECORDER;


typedef struct tag_CM_VOICE_RECORDER 
{
	 WORD	    cb;                     
	 DWORD		dwStyle;
	 int		xPos, yPos;
	 HWND		hwndParent;
	 int		id;
	 LPTSTR		lpszRecordFileName;
} CM_VOICE_RECORDER, *LPCM_VOICE_RECORDER;



#define VRM_FIRST               0x1900      // must be uniqe
							   
typedef enum tagVR_MSG {
	VRM_RECORD = (VRM_FIRST + 0),				
	VRM_PLAY,				
	VRM_STOP,				
	VRM_CANCEL,				
	VRM_OK,				
} VR_MSG;


#define VRN_FIRST              (0U-860U)    
#define VRN_LAST               (0U-890U)

#define VRN_RECORD_START	(VRN_FIRST-1)
#define VRN_RECORD_STOP		(VRN_FIRST-2)
#define VRN_PLAY_START		(VRN_FIRST-3)
#define VRN_PLAY_STOP		(VRN_FIRST-4)
#define VRN_CANCEL			(VRN_FIRST-5)
#define VRN_OK				(VRN_FIRST-6)
#define VRN_ERROR			(VRN_FIRST-7)


typedef enum tagVR_STYLE {
	VRS_NO_OKCANCEL  = 0x0001,		// No OK/CANCLE dispalyed
	VRS_NO_NOTIFY    = 0x0002,		// No parent Notifcation
	VRS_MODAL	     = 0x0004,		// Control is Modal     
	VRS_NO_OK	     = 0x0008,		// No OK displayed
	VRS_NO_RECORD    = 0x0010,		// No REOCRD button displayed
	VRS_PLAY_MODE    = 0x0020,		// Immediatly play supplied file when launched
	VRS_NO_MOVE		 = 0x0040,		// Grip is removed and the control cannot be moved around by the user
	VRS_RECORD_MODE  = 0x0080,      // Immediately record when launched
	VRS_STOP_DISMISS = 0x0100,      // Dismiss control when stopped
} VR_STYLE;


typedef enum tagVR_ErrorCodes {	 
	// must be the save as in VoiceDll.h
	ER_SUCCESS,         // No error 
    ER_FAIL,            // Unknown error
    ER_OUTOFMEMORY,     // Out of memory
    ER_UNUSED1,         //
    ER_INVALIDPARAM,    // Invalid param
    ER_UNUSED2,         //
    ER_WRITE_FILE_FAIL, // Write to file error
    ER_UNUSED3,         //
	ER_OOM_STORAGE,     // Out of storage
	ER_MAX_FILE_SIZE,	// Maximum file size reached during recording.
	ER_BUSY,            // Control is busy recording or playing
} VR_ECODE;


HWND	VoiceRecorder_Create(LPCM_VOICE_RECORDER lpVR);

#ifdef __cplusplus
}
#endif


#endif // __VOICE_CTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vpconfig.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//
//--------------------------------------------------------------------------;

// An interface exposed by the decoder to help the decoder and the filter configuring
// the videoport to communicate. 

#ifndef __IVPConfig__
#define __IVPConfig__

#ifdef __cplusplus
extern "C" {
#endif

// IVPBaseConfig
DECLARE_INTERFACE_(IVPBaseConfig, IUnknown)
{
public:

    // gets the various connection information structures (guid, portwidth)
    // in an array of structures. If the pointer to the array is NULL, first 
    // parameter returns the total number of formats supported.
    STDMETHOD (GetConnectInfo)(THIS_
			       IN OUT LPDWORD pdwNumConnectInfo,
			       IN OUT LPDDVIDEOPORTCONNECT pddVPConnectInfo
			      ) PURE;

    // sets the connection entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetConnectInfo)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // gets various data parameters, includes dimensionnal info
    STDMETHOD (GetVPDataInfo)(THIS_
			      IN OUT LPAMVPDATAINFO pamvpDataInfo
			     ) PURE;

    // retrives maximum pixels per second rate expected for a given 
    // format and a given scaling factor. If decoder does not support 
    // those scaling factors, then it gives the rate and the nearest 
    // scaling factors.
    STDMETHOD (GetMaxPixelRate)(THIS_
				IN OUT LPAMVPSIZE pamvpSize,
				OUT LPDWORD pdwMaxPixelsPerSecond
			       ) PURE;

    // informs the callee of the videoformats supported by the videoport
    STDMETHOD (InformVPInputFormats)(THIS_
				     IN DWORD dwNumFormats,
				     IN LPDDPIXELFORMAT pDDPixelFormats
				    ) PURE;

    // gets the various formats supported by the decoder in an array
    // of structures. If the pointer to the array is NULL, first parameter
    // returns the total number of formats supported.
    STDMETHOD (GetVideoFormats)(THIS_
				IN OUT LPDWORD pdwNumFormats,
				IN OUT LPDDPIXELFORMAT pddPixelFormats
			       ) PURE;

    // sets the format entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetVideoFormat)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // asks the decoder to treat even fields like odd fields and visa versa
    STDMETHOD (SetInvertPolarity)(THIS_
				 ) PURE;

    // the mixer uses this function to determine if the callee wants
    // the vpmixer to use its overlay surface and if so to get a pointer to it
    STDMETHOD (GetOverlaySurface)(THIS_
				  OUT LPDIRECTDRAWSURFACE* ppddOverlaySurface
				 ) PURE;

    // sets the direct draw kernel handle
    STDMETHOD (SetDirectDrawKernelHandle)(THIS_
					  IN DWORD dwDDKernelHandle
					 ) PURE;

    // sets the video port id
    STDMETHOD (SetVideoPortID)(THIS_
			       IN DWORD dwVideoPortID
			      ) PURE;

    // sets the direct draw surface kernel handle
    STDMETHOD (SetDDSurfaceKernelHandles)(THIS_
					  IN DWORD cHandles,
					  IN DWORD *rgDDKernelHandles
					 ) PURE;

    // Tells driver about surface created on its behalf by ovmixer/vbisurf and 
    // returned from videoport/ddraw. Should always return NOERROR or E_NOIMPL. 
    // dwPitch is the pitch of the surface (distance in pixels between the start 
    // pixels of two consecutive lines of the surface). (dwXOrigin, dwYOrigin) 
    // are the (X, Y) coordinates of the pixel at which valid data starts.  
    STDMETHOD (SetSurfaceParameters)(THIS_
                    IN DWORD dwPitch,
                    IN DWORD dwXOrigin,
                    IN DWORD dwYOrigin
                    ) PURE;
};

// IVPConfig
DECLARE_INTERFACE_(IVPConfig, IVPBaseConfig)
{
public:
	// the mixer uses this function to determine if the callee wants
	// the mixer to decimate VIDEO data at its own descrition
	STDMETHOD (IsVPDecimationAllowed)(THIS_
					  OUT LPBOOL pbIsDecimationAllowed
					 ) PURE;

	// sets the scaling factors. If decoder does not support these,
	// then it sets the values to the nearest factors it can support
	STDMETHOD (SetScalingFactors)(THIS_
				      IN LPAMVPSIZE pamvpSize
				     ) PURE;
};

// IVPVBIConfig
DECLARE_INTERFACE_(IVPVBIConfig, IVPBaseConfig)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\voipphone.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// voipphone.h
//
// VoIP Phone API
//
// Copyright (c) Microsoft Corporation. All rights reserved.

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

// Override Call Information flags used in 
#define OCIF_CELLULAR_NETWORK       0x00000001
#define OCIF_VOIP_NETWORK           0x00000002
#define OCIF_NETWORK_TYPE_MASK      (OCIF_CELLULAR_NETWORK |  OCIF_VOIP_NETWORK)
#define OCIF_CELLULAR_PHONE_NUMBER  0x00000004
#define OCIF_VOIP_PHONE_NUMBER      0x00000008
#define OCIF_PHONE_NUMBER_TYPE_MASK (OCIF_CELLULAR_PHONE_NUMBER |  OCIF_VOIP_PHONE_NUMBER)
#define OCIF_MASK                   (OCIF_NETWORK_TYPE_MASK | OCIF_VOIP_PHONE_NUMBER)

//  VoIPPhoneOverride API set
//  Used to override the VoIP Phone behavior. The DLL which  implements these
//  APIs should be registered under
//
//  [HKEY_LOCAL_MACHINE\Security\Phone]
//  "VoIPPhoneOverride"=hook.dll

//  VoIPPhoneOverrideInitialize:
//  Invoked whenever the VoIP Phone application is initialized. Right after
//  the DLL is loaded.
//
//  Parameters:
//  None.
//
//  Returns:
//  Must return S_OK.
HRESULT
VoIPPhoneOverrideInitialize(
    void
    );

//  VoIPPhoneOverrideUnInitialize:
//  Invoked whenever the VoIP Phone application is shutdown. Right before
//  the DLL is unloaded.
//
//  Parameters:
//  None.
//
//  Returns:
//  Must return S_OK.
HRESULT
VoIPPhoneOverrideUnInitialize(
    void
    );

//  VoIPPhoneOverrideCallNetwork: 
//  Invoked whenever the VoIP Phone is about to make a call.
//
//  Paramters:
//  [in] pszDialString - number dialed.
//  [in] cchDialStringLength - number of characters of the number dialed.
//  [in/out] pdwCallInformationFlags - call information flags that apply to this call. 
//      One or more of the OCIF_xxx values
//
//  Returns:
//  S_OK : when pCallInformationFlags are processed and the network type is overridden.
//      Only flags that match OCIF_NETWORK_TYPE_MASK are used on output.
//      Any changes to other flags are ignored.
//  E_FAIL : whenever a failure occurrs. Any out parameter will be ignored.
//  E_NOTIMPL : when the default behavior is desired.
HRESULT
VoIPPhoneOverrideCallNetwork(
    LPCTSTR pszDialString,
    DWORD cchDialStringLength,
    DWORD* pdwCallInformationFlags
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vptype.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//
//--------------------------------------------------------------------------;
// this file includes all the data structures defined for the IVPConfig
// interface.

#ifndef __IVPType__
#define __IVPType__

#ifdef __cplusplus
extern "C" {
#endif

    // enum to specify the criterion, which the vpmixer is supposed to use
    // in order to select the video format
    typedef enum _AMVP_SELECT_FORMAT_BY
    {
	AMVP_DO_NOT_CARE,
	AMVP_BEST_BANDWIDTH,
	AMVP_INPUT_SAME_AS_OUTPUT
    } AMVP_SELECT_FORMAT_BY;

    // enum to specify the various mode
    typedef enum _AMVP_MODE
    {	
	AMVP_MODE_WEAVE,
	AMVP_MODE_BOBINTERLEAVED,
	AMVP_MODE_BOBNONINTERLEAVED,
	AMVP_MODE_SKIPEVEN,
	AMVP_MODE_SKIPODD
    } AMVP_MODE;

    // struct to specify the width and height. The context could be anything
    // such as scaling cropping etc.
    typedef struct _AMVPSIZE
    {
	DWORD			dwWidth;				// the width
	DWORD			dwHeight;				// the height
    } AMVPSIZE, *LPAMVPSIZE;

    // struct to specify the dimensional characteristics of the input stream
    typedef struct _AMVPDIMINFO
    {
	DWORD			dwFieldWidth;				// Field height of the data
	DWORD			dwFieldHeight;				// Field width of the data
	DWORD			dwVBIWidth;				// Width of the VBI data
	DWORD			dwVBIHeight;				// Height of the VBI data
	RECT			rcValidRegion;				// The vaild rectangle, used for cropping
    } AMVPDIMINFO, *LPAMVPDIMINFO;

    // struct to specify the various data specific characteristics of the input stream
    typedef struct _AMVPDATAINFO
    {
	DWORD			dwSize;					// Size of the struct
	DWORD			dwMicrosecondsPerField;			// Time taken by each field
	AMVPDIMINFO		amvpDimInfo;				// Dimensional Information 
	DWORD			dwPictAspectRatioX;			// X dimension of Picture Aspect Ratio
	DWORD			dwPictAspectRatioY;			// Y dimension of Picture Aspect Ratio
	BOOL			bEnableDoubleClock;			// Videoport should enable double clocking
	BOOL			bEnableVACT;				// Videoport should use an external VACT signal
	BOOL			bDataIsInterlaced;			// Indicates that the signal is interlaced
	LONG			lHalfLinesOdd;				// number of halflines in the odd field
	BOOL			bFieldPolarityInverted;			// Device inverts the polarity by default
	DWORD			dwNumLinesInVREF;			// Number of lines of data in VREF 
	LONG			lHalfLinesEven;				// number of halflines in the even field
	DWORD			dwReserved1;				// Reserved for future use
    } AMVPDATAINFO, *LPAMVPDATAINFO; 


#ifdef __cplusplus
}
#endif

#endif // __IVPType__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vrtldata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for vrtldata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vrtldata_h__
#define __vrtldata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVerbSnapshot_FWD_DEFINED__
#define __IVerbSnapshot_FWD_DEFINED__
typedef interface IVerbSnapshot IVerbSnapshot;
#endif 	/* __IVerbSnapshot_FWD_DEFINED__ */


#ifndef __IVerbSource_FWD_DEFINED__
#define __IVerbSource_FWD_DEFINED__
typedef interface IVerbSource IVerbSource;
#endif 	/* __IVerbSource_FWD_DEFINED__ */


#ifndef __IVerbExtension_FWD_DEFINED__
#define __IVerbExtension_FWD_DEFINED__
typedef interface IVerbExtension IVerbExtension;
#endif 	/* __IVerbExtension_FWD_DEFINED__ */


#ifndef __IObjectCache_FWD_DEFINED__
#define __IObjectCache_FWD_DEFINED__
typedef interface IObjectCache IObjectCache;
#endif 	/* __IObjectCache_FWD_DEFINED__ */


#ifndef __IObjectWithCache_FWD_DEFINED__
#define __IObjectWithCache_FWD_DEFINED__
typedef interface IObjectWithCache IObjectWithCache;
#endif 	/* __IObjectWithCache_FWD_DEFINED__ */


#ifndef __IEventDelegate_FWD_DEFINED__
#define __IEventDelegate_FWD_DEFINED__
typedef interface IEventDelegate IEventDelegate;
#endif 	/* __IEventDelegate_FWD_DEFINED__ */


#ifndef __IEvent_FWD_DEFINED__
#define __IEvent_FWD_DEFINED__
typedef interface IEvent IEvent;
#endif 	/* __IEvent_FWD_DEFINED__ */


#ifndef __IObjectWithEvent_FWD_DEFINED__
#define __IObjectWithEvent_FWD_DEFINED__
typedef interface IObjectWithEvent IObjectWithEvent;
#endif 	/* __IObjectWithEvent_FWD_DEFINED__ */


#ifndef __IVirtualItem_FWD_DEFINED__
#define __IVirtualItem_FWD_DEFINED__
typedef interface IVirtualItem IVirtualItem;
#endif 	/* __IVirtualItem_FWD_DEFINED__ */


#ifndef __IVirtualList_FWD_DEFINED__
#define __IVirtualList_FWD_DEFINED__
typedef interface IVirtualList IVirtualList;
#endif 	/* __IVirtualList_FWD_DEFINED__ */


#ifndef __IGroupedVirtualList_FWD_DEFINED__
#define __IGroupedVirtualList_FWD_DEFINED__
typedef interface IGroupedVirtualList IGroupedVirtualList;
#endif 	/* __IGroupedVirtualList_FWD_DEFINED__ */


#ifndef __ICategorizedVirtualItem_FWD_DEFINED__
#define __ICategorizedVirtualItem_FWD_DEFINED__
typedef interface ICategorizedVirtualItem ICategorizedVirtualItem;
#endif 	/* __ICategorizedVirtualItem_FWD_DEFINED__ */


#ifndef __IDataItem_FWD_DEFINED__
#define __IDataItem_FWD_DEFINED__
typedef interface IDataItem IDataItem;
#endif 	/* __IDataItem_FWD_DEFINED__ */


#ifndef __ICategorizedDataItem_FWD_DEFINED__
#define __ICategorizedDataItem_FWD_DEFINED__
typedef interface ICategorizedDataItem ICategorizedDataItem;
#endif 	/* __ICategorizedDataItem_FWD_DEFINED__ */


#ifndef __IDataList_FWD_DEFINED__
#define __IDataList_FWD_DEFINED__
typedef interface IDataList IDataList;
#endif 	/* __IDataList_FWD_DEFINED__ */


#ifndef __IItemInspector_FWD_DEFINED__
#define __IItemInspector_FWD_DEFINED__
typedef interface IItemInspector IItemInspector;
#endif 	/* __IItemInspector_FWD_DEFINED__ */


#ifndef __IPersistBlob_FWD_DEFINED__
#define __IPersistBlob_FWD_DEFINED__
typedef interface IPersistBlob IPersistBlob;
#endif 	/* __IPersistBlob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vrtldata_0000_0000 */
/* [local] */ 

// Failure code meaning that an object already exists and therefore won't be
// re-added or re-created in the applicable context.
#define E_ALREADYEXISTS              HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)

// Failure code meaning that buffer passed in is not large enough
#define E_INSUFFICIENTBUFFER         HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

// Failure code meaning that some data element (e.g., property) could not be found
#define E_NOTFOUND                   HRESULT_FROM_WIN32(ERROR_NOT_FOUND)

// Failure code meaning that operation is not supported by object
#define E_NOTSUPPORTED               HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)

// Success code meaning that some processing is still being done
// but the operation was able to complete successfully, regardless.
#define S_PENDING                    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1)

// Failure code meaning that an object does not exist and therefore can't be
// retrieved or removed from applicable context.
#define E_DOESNOTEXIST               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1)

// Failure code meaning that data access was attempted outside of the
// allowed boundaries.
#define E_OUTOFBOUNDS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2)

// Failure code meaning that operation could not be completed because match reasons
// collection was already full.
#define E_MATCHREASONS_FULL          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3)

// Failure code meaning that operation could not be completed because we were unable
// to load supplier.
#define E_SUPPLIERNOTLOADED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x4)

// Verb can't be invoked on verb source that provided it
#define VERBSTATE_DISABLED       0x0000
// Verb can be invoked on verb source that provided it
#define VERBSTATE_ENABLED        0x0001
#define VERBSTATE_ENABLEDMASK    (VERBSTATE_ENABLED)
// Verb represents a group of sub verbs
#define VERBSTATE_GROUP          0x0002


// Verb doesn't have a toggle state
#define VERBSTATE_NOTOGGLE       0x0000
// Verb has a toggle state and toggle is off
#define VERBSTATE_TOGGLEOFF      0x0010
// Verb has a toggle state and toggle is on
#define VERBSTATE_TOGGLEON       0x0020
#define VERBSTATE_TOGGLEMASK     (VERBSTATE_TOGGLEOFF | VERBSTATE_TOGGLEON)




// Verb ID is specified
#define VERBDESCMASK_ID          0x0001
// Verb state is specified
#define VERBDESCMASK_STATE       0x0002
// Verb display name is specified
#define VERBDESCMASK_DISPLAYNAME 0x0004
// Verb group name is specified
#define VERBDESCMASK_GROUPNAME   0x0008




// Special verb group specification that represent a verb source's default set of verbs
#define VERBGROUP_DEFAULT                TEXT("default")
// Special verb group specification that represent all of a verb source's verbs
#define VERBGROUP_ALL                    TEXT("all")
// Special verb group specification that means a particular verb has no associated group
#define VERBGROUP_NONE                   TEXT("none")
// Used to group edit verbs such as "cut", "copy" and "paste"
#define VERBGROUP_EDIT                   TEXT("edit")
// Used to group communication initiation verbs such as "call", "send SMS" and "send email"
#define VERBGROUP_STARTCOMMUNICATION     TEXT("startcommunication")
// Used to group communication response verbs such as "reply sender", "reply all" and "forward"
#define VERBGROUP_RESPONDCOMMUNICATION   TEXT("respondcommunication")
// Used to specify softkey verbs for applications such as smartsearch
#define VERBGROUP_SOFTKEYS               TEXT("softkeys")
typedef struct _VERBDESC
    {
    DWORD dwMask;
    DWORD dwID;
    DWORD dwState;
    LPOLESTR pszDisplayName;
    UINT cchDisplayName;
    LPOLESTR pszGroupName;
    UINT cchGroupName;
    } 	VERBDESC;

typedef 
enum _VERBSNAPSHOTSORTBY
    {	VSSORTBY_DEFAULT	= 0,
	VSSORTBY_DISPLAYNAME	= ( VSSORTBY_DEFAULT + 1 ) ,
	VSSORTBY_GROUPNAME	= ( VSSORTBY_DISPLAYNAME + 1 ) 
    } 	VERBSNAPSHOTSORTBY;



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0000_v0_0_s_ifspec;

#ifndef __IVerbSnapshot_INTERFACE_DEFINED__
#define __IVerbSnapshot_INTERFACE_DEFINED__

/* interface IVerbSnapshot */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVerbSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6849f85-53f2-43f9-a6fe-2f081daeb7f2")
    IVerbSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ UINT *pcVerbCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbDescriptorRef( 
            /* [in] */ UINT uiVerb,
            /* [out] */ VERBDESC **ppVerbDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtendedVerbProperty( 
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [in] */ PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedVerbProperty( 
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [out] */ PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSort( 
            /* [in] */ VERBSNAPSHOTSORTBY sortbyNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSort( 
            /* [out] */ VERBSNAPSHOTSORTBY *psortbyCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [in] */ UINT uiVerb,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVerbSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVerbSnapshot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVerbSnapshot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVerbSnapshot * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IVerbSnapshot * This,
            /* [out] */ UINT *pcVerbCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbDescriptorRef )( 
            IVerbSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [out] */ VERBDESC **ppVerbDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtendedVerbProperty )( 
            IVerbSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [in] */ PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedVerbProperty )( 
            IVerbSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [out] */ PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSort )( 
            IVerbSnapshot * This,
            /* [in] */ VERBSNAPSHOTSORTBY sortbyNew);
        
        HRESULT ( STDMETHODCALLTYPE *GetSort )( 
            IVerbSnapshot * This,
            /* [out] */ VERBSNAPSHOTSORTBY *psortbyCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            IVerbSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam);
        
        END_INTERFACE
    } IVerbSnapshotVtbl;

    interface IVerbSnapshot
    {
        CONST_VTBL struct IVerbSnapshotVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVerbSnapshot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVerbSnapshot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVerbSnapshot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVerbSnapshot_GetCount(This,pcVerbCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcVerbCount) ) 

#define IVerbSnapshot_GetVerbDescriptorRef(This,uiVerb,ppVerbDesc)	\
    ( (This)->lpVtbl -> GetVerbDescriptorRef(This,uiVerb,ppVerbDesc) ) 

#define IVerbSnapshot_SetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue)	\
    ( (This)->lpVtbl -> SetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue) ) 

#define IVerbSnapshot_GetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue)	\
    ( (This)->lpVtbl -> GetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue) ) 

#define IVerbSnapshot_SetSort(This,sortbyNew)	\
    ( (This)->lpVtbl -> SetSort(This,sortbyNew) ) 

#define IVerbSnapshot_GetSort(This,psortbyCurrent)	\
    ( (This)->lpVtbl -> GetSort(This,psortbyCurrent) ) 

#define IVerbSnapshot_InvokeVerb(This,uiVerb,hwndOwner,pVerbParam)	\
    ( (This)->lpVtbl -> InvokeVerb(This,uiVerb,hwndOwner,pVerbParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVerbSnapshot_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0001 */
/* [local] */ 

// Minimum ID value for global properties
#define VERBPROPID_RESERVEDMIN           0xFFFFFF00
// Property that describes which softkey index, if any, is the preferred
// index for the corresponding verb. Absence of this property means that
// there is no preferred softkey for corresponding verb.
// Type is VT_UI4.
#define VERBPROPID_SOFTKEYPREFERENCE     (VERBPROPID_RESERVEDMIN + 0x01)

// Alternate text (e.g., shorter than default display text) that should
// be used if verb is displayed in a softkey. Absence of this property
// means that default display text in VERBDESC.pszDisplayName should be
// used whether this verb is displayed in a menu, in a softkey or
// elsewhere.
// Supported types for returning this property are VT_BSTR and VT_LPWSTR

#define VERBPROPID_SOFTKEYDISPLAYTEXT    (VERBPROPID_RESERVEDMIN + 0x02)
// Image used to represent a verb in a menu item (or elsewhere).
// Supported types for returning this property are VT_BSTR or VT_LPWSTR,
// which will be used to pass back as string in resource URL format
// (e.g.: res://tapres.dll/PNG/#23), and also VT_UNKNOWN and VT_STREAM,
// which will be used to pass back an IStream object that describes the
// image

#define VERBPROPID_IMAGE                 (VERBPROPID_RESERVEDMIN + 0x03)
// Reserve a range of 256 property IDs for global verb properties
// Maximum ID value used for verb properties
#define VERBPROPID_RESERVEDMAX           (VERBPROPID_IMAGE)
extern int dummary_array[(VERBPROPID_RESERVEDMAX - VERBPROPID_RESERVEDMIN) <= 0xFF];



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0001_v0_0_s_ifspec;

#ifndef __IVerbSource_INTERFACE_DEFINED__
#define __IVerbSource_INTERFACE_DEFINED__

/* interface IVerbSource */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVerbSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9aaaa7dc-ee97-4f02-beac-3970853f0d69")
    IVerbSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGroupVerbs( 
            /* [in] */ LPCOLESTR pszGroupName,
            /* [out] */ IVerbSnapshot **ppSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbsFromIDs( 
            /* [max_is][in] */ const DWORD *rgdwVerbIDs,
            /* [in] */ UINT cVerbIDs,
            /* [out] */ IVerbSnapshot **ppSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [in] */ DWORD dwVerbID,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVerbSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVerbSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVerbSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVerbSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupVerbs )( 
            IVerbSource * This,
            /* [in] */ LPCOLESTR pszGroupName,
            /* [out] */ IVerbSnapshot **ppSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbsFromIDs )( 
            IVerbSource * This,
            /* [max_is][in] */ const DWORD *rgdwVerbIDs,
            /* [in] */ UINT cVerbIDs,
            /* [out] */ IVerbSnapshot **ppSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            IVerbSource * This,
            /* [in] */ DWORD dwVerbID,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam);
        
        END_INTERFACE
    } IVerbSourceVtbl;

    interface IVerbSource
    {
        CONST_VTBL struct IVerbSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVerbSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVerbSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVerbSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVerbSource_GetGroupVerbs(This,pszGroupName,ppSnapshot)	\
    ( (This)->lpVtbl -> GetGroupVerbs(This,pszGroupName,ppSnapshot) ) 

#define IVerbSource_GetVerbsFromIDs(This,rgdwVerbIDs,cVerbIDs,ppSnapshot)	\
    ( (This)->lpVtbl -> GetVerbsFromIDs(This,rgdwVerbIDs,cVerbIDs,ppSnapshot) ) 

#define IVerbSource_InvokeVerb(This,dwVerbID,hwndOwner,pVerbParam)	\
    ( (This)->lpVtbl -> InvokeVerb(This,dwVerbID,hwndOwner,pVerbParam) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVerbSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0002 */
/* [local] */ 

// If a verb source also implements IObjectWithEvent, it may send the following event
// to notify listeners of changes in the verbs available from this source.
#define VERBSOURCE_EVENT_VERBSCHANGED 0x0001
HRESULT VerbSnapshot_CreateInstance( 
    /* [max_is][in] */ VERBDESC *rgVerbs,
    /* [in] */ UINT cVerbs,
    /* [in] */ IVerbSource *pVerbSource,
    /* [retval][out] */ IVerbSnapshot **ppSnapshot);



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0002_v0_0_s_ifspec;

#ifndef __IVerbExtension_INTERFACE_DEFINED__
#define __IVerbExtension_INTERFACE_DEFINED__

/* interface IVerbExtension */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVerbExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9861db81-f95b-40ba-8056-536e6bde051c")
    IVerbExtension : public IVerbSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVerbTarget( 
            /* [optional][in] */ IUnknown *pTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValidVerbIDRange( 
            /* [out] */ DWORD *pdwFirstValidID,
            /* [out] */ DWORD *pdwLastValidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVerbExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVerbExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVerbExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVerbExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupVerbs )( 
            IVerbExtension * This,
            /* [in] */ LPCOLESTR pszGroupName,
            /* [out] */ IVerbSnapshot **ppSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbsFromIDs )( 
            IVerbExtension * This,
            /* [max_is][in] */ const DWORD *rgdwVerbIDs,
            /* [in] */ UINT cVerbIDs,
            /* [out] */ IVerbSnapshot **ppSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            IVerbExtension * This,
            /* [in] */ DWORD dwVerbID,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetVerbTarget )( 
            IVerbExtension * This,
            /* [optional][in] */ IUnknown *pTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetValidVerbIDRange )( 
            IVerbExtension * This,
            /* [out] */ DWORD *pdwFirstValidID,
            /* [out] */ DWORD *pdwLastValidID);
        
        END_INTERFACE
    } IVerbExtensionVtbl;

    interface IVerbExtension
    {
        CONST_VTBL struct IVerbExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVerbExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVerbExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVerbExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVerbExtension_GetGroupVerbs(This,pszGroupName,ppSnapshot)	\
    ( (This)->lpVtbl -> GetGroupVerbs(This,pszGroupName,ppSnapshot) ) 

#define IVerbExtension_GetVerbsFromIDs(This,rgdwVerbIDs,cVerbIDs,ppSnapshot)	\
    ( (This)->lpVtbl -> GetVerbsFromIDs(This,rgdwVerbIDs,cVerbIDs,ppSnapshot) ) 

#define IVerbExtension_InvokeVerb(This,dwVerbID,hwndOwner,pVerbParam)	\
    ( (This)->lpVtbl -> InvokeVerb(This,dwVerbID,hwndOwner,pVerbParam) ) 


#define IVerbExtension_SetVerbTarget(This,pTarget)	\
    ( (This)->lpVtbl -> SetVerbTarget(This,pTarget) ) 

#define IVerbExtension_GetValidVerbIDRange(This,pdwFirstValidID,pdwLastValidID)	\
    ( (This)->lpVtbl -> GetValidVerbIDRange(This,pdwFirstValidID,pdwLastValidID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVerbExtension_INTERFACE_DEFINED__ */


#ifndef __IObjectCache_INTERFACE_DEFINED__
#define __IObjectCache_INTERFACE_DEFINED__

/* interface IObjectCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjectCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A0D2717-AA3E-4194-AF13-2AD02F6E8438")
    IObjectCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObject( 
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey,
            /* [in] */ REFIID riidObjType,
            /* [in] */ IUnknown *punkObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey,
            /* [in] */ REFIID riidObjType,
            /* [retval][out] */ IUnknown **ppunkObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObject( 
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObject )( 
            IObjectCache * This,
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey,
            /* [in] */ REFIID riidObjType,
            /* [in] */ IUnknown *punkObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IObjectCache * This,
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey,
            /* [in] */ REFIID riidObjType,
            /* [retval][out] */ IUnknown **ppunkObj);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObject )( 
            IObjectCache * This,
            /* [size_is][in] */ LPCOLESTR pszKey,
            /* [in] */ UINT cchKey);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IObjectCache * This);
        
        END_INTERFACE
    } IObjectCacheVtbl;

    interface IObjectCache
    {
        CONST_VTBL struct IObjectCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectCache_AddObject(This,pszKey,cchKey,riidObjType,punkObj)	\
    ( (This)->lpVtbl -> AddObject(This,pszKey,cchKey,riidObjType,punkObj) ) 

#define IObjectCache_GetObject(This,pszKey,cchKey,riidObjType,ppunkObj)	\
    ( (This)->lpVtbl -> GetObject(This,pszKey,cchKey,riidObjType,ppunkObj) ) 

#define IObjectCache_RemoveObject(This,pszKey,cchKey)	\
    ( (This)->lpVtbl -> RemoveObject(This,pszKey,cchKey) ) 

#define IObjectCache_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectCache_INTERFACE_DEFINED__ */


#ifndef __IObjectWithCache_INTERFACE_DEFINED__
#define __IObjectWithCache_INTERFACE_DEFINED__

/* interface IObjectWithCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64EC3C08-E7FC-4b56-96A8-FD744DC3EDFE")
    IObjectWithCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCache( 
            /* [retval][out] */ IObjectCache **ppCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCache( 
            /* [in] */ IObjectCache *pCache) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCache )( 
            IObjectWithCache * This,
            /* [retval][out] */ IObjectCache **ppCache);
        
        HRESULT ( STDMETHODCALLTYPE *SetCache )( 
            IObjectWithCache * This,
            /* [in] */ IObjectCache *pCache);
        
        END_INTERFACE
    } IObjectWithCacheVtbl;

    interface IObjectWithCache
    {
        CONST_VTBL struct IObjectWithCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithCache_GetCache(This,ppCache)	\
    ( (This)->lpVtbl -> GetCache(This,ppCache) ) 

#define IObjectWithCache_SetCache(This,pCache)	\
    ( (This)->lpVtbl -> SetCache(This,pCache) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0005 */
/* [local] */ 

HRESULT ObjectCache_CreateInstance( 
    /* [retval][out] */ IObjectCache **ppCacheNew);

// All event codes below 0x0400 are reserved for events
// defined by the system

// Library-specific event codes start here
#define EVENTCODE_USER              0x00000400
// Application-specific event codes start here
#define EVENTCODE_APP               0x00008000


extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0005_v0_0_s_ifspec;

#ifndef __IEventDelegate_INTERFACE_DEFINED__
#define __IEventDelegate_INTERFACE_DEFINED__

/* interface IEventDelegate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEventDelegate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8f31b2a-c6f5-4644-9327-1e2aed43a9a3")
    IEventDelegate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DelegateProc( 
            /* [in] */ LONG nEventCode,
            /* [optional][in] */ IUnknown *pSender,
            /* [optional][in] */ const BLOB *pParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventDelegateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEventDelegate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEventDelegate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEventDelegate * This);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateProc )( 
            IEventDelegate * This,
            /* [in] */ LONG nEventCode,
            /* [optional][in] */ IUnknown *pSender,
            /* [optional][in] */ const BLOB *pParams);
        
        END_INTERFACE
    } IEventDelegateVtbl;

    interface IEventDelegate
    {
        CONST_VTBL struct IEventDelegateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventDelegate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEventDelegate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEventDelegate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEventDelegate_DelegateProc(This,nEventCode,pSender,pParams)	\
    ( (This)->lpVtbl -> DelegateProc(This,nEventCode,pSender,pParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEventDelegate_INTERFACE_DEFINED__ */


#ifndef __IEvent_INTERFACE_DEFINED__
#define __IEvent_INTERFACE_DEFINED__

/* interface IEvent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1bd5fbd5-f60b-4622-8e31-4b8be6c63cbb")
    IEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddDelegate( 
            /* [in] */ IEventDelegate *pDelegate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveDelegate( 
            /* [in] */ IEventDelegate *pDelegate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasDelegates( 
            /* [out] */ BOOL *pfHasDelegates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ LONG nEventCode,
            /* [optional][in] */ IUnknown *pSender,
            /* [optional][in] */ const BLOB *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitUntilIdle( 
            /* [in] */ DWORD dwWait) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDelegate )( 
            IEvent * This,
            /* [in] */ IEventDelegate *pDelegate);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveDelegate )( 
            IEvent * This,
            /* [in] */ IEventDelegate *pDelegate);
        
        HRESULT ( STDMETHODCALLTYPE *HasDelegates )( 
            IEvent * This,
            /* [out] */ BOOL *pfHasDelegates);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvent * This,
            /* [in] */ LONG nEventCode,
            /* [optional][in] */ IUnknown *pSender,
            /* [optional][in] */ const BLOB *pParams);
        
        HRESULT ( STDMETHODCALLTYPE *WaitUntilIdle )( 
            IEvent * This,
            /* [in] */ DWORD dwWait);
        
        END_INTERFACE
    } IEventVtbl;

    interface IEvent
    {
        CONST_VTBL struct IEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEvent_AddDelegate(This,pDelegate)	\
    ( (This)->lpVtbl -> AddDelegate(This,pDelegate) ) 

#define IEvent_RemoveDelegate(This,pDelegate)	\
    ( (This)->lpVtbl -> RemoveDelegate(This,pDelegate) ) 

#define IEvent_HasDelegates(This,pfHasDelegates)	\
    ( (This)->lpVtbl -> HasDelegates(This,pfHasDelegates) ) 

#define IEvent_Invoke(This,nEventCode,pSender,pParams)	\
    ( (This)->lpVtbl -> Invoke(This,nEventCode,pSender,pParams) ) 

#define IEvent_WaitUntilIdle(This,dwWait)	\
    ( (This)->lpVtbl -> WaitUntilIdle(This,dwWait) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEvent_INTERFACE_DEFINED__ */


#ifndef __IObjectWithEvent_INTERFACE_DEFINED__
#define __IObjectWithEvent_INTERFACE_DEFINED__

/* interface IObjectWithEvent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD014131-2E86-48e5-A42E-01F3CD41C453")
    IObjectWithEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [retval][out] */ IEvent **ppEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IObjectWithEvent * This,
            /* [retval][out] */ IEvent **ppEvent);
        
        END_INTERFACE
    } IObjectWithEventVtbl;

    interface IObjectWithEvent
    {
        CONST_VTBL struct IObjectWithEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithEvent_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0008 */
/* [local] */ 

HRESULT MulticastEvent_CreateInstance( 
    /* [retval][out] */ IEvent **ppEvent);

HRESULT AsynchronousMulticastEvent_CreateInstance( 
    /* [optional][in] */ IObjectCache *pCache,
    /* [retval][out] */ IEvent **ppEvent);

typedef HRESULT ( *DELEGATEPROC )( 
    void *pContext,
    LONG nEventCode,
    IUnknown *pSender,
    const BLOB *pParams);

HRESULT CreateCallbackProcDelegate( 
    /* [in] */ DELEGATEPROC pfnDelegate,
    /* [optional][in] */ void *pContext,
    /* [retval][out] */ IEventDelegate **ppDelegate);

HRESULT CreateWindowMsgDelegate( 
    /* [in] */ HWND hwndNotify,
    /* [in] */ UINT nMsgCode,
    /* [retval][out] */ IEventDelegate **ppDelegate);

// Minimum ID value for global properties
#define PROPID_RESERVEDMIN       0xFFFFFF00
// Item category, i.e., "contact", "message", etc.
#define PROPID_CATEGORY          (PROPID_RESERVEDMIN)
// Unique ID for item. It is a variant of type VT_VECTOR | VT_UI1
// that is allocated using CoTaskMemAlloc.
#define PROPID_UNIQUEID          (PROPID_RESERVEDMIN + 0x01)
// Represents an unspecified property
#define PROPID_NULL              (PROPID_RESERVEDMIN + 0x02)

// Array of default text fields used for displaying in UI
#define PROPID_DISPLAYTEXTFIELDS (PROPID_RESERVEDMIN + 0x10)
// Shorthand for first element of display text fields array
#define PROPID_TEXT0             (PROPID_RESERVEDMIN + 0x11)
// Shorthand for second element of display text fields array
#define PROPID_TEXT1             (PROPID_RESERVEDMIN + 0x12)
// Shorthand for third element of display text fields array
#define PROPID_TEXT2             (PROPID_RESERVEDMIN + 0x13)
// Shorthand for fourth element of display text fields array
#define PROPID_TEXT3             (PROPID_RESERVEDMIN + 0x14)
// Shorthand for fifth element of display text fields array
#define PROPID_TEXT4             (PROPID_RESERVEDMIN + 0x15)
// Shorthand for sixth element of display text fields array
#define PROPID_TEXT5             (PROPID_RESERVEDMIN + 0x16)
// Shorthand for seventh element of display text fields array
#define PROPID_TEXT6             (PROPID_RESERVEDMIN + 0x17)
// Shorthand for eighth element of display text fields array
#define PROPID_TEXT7             (PROPID_RESERVEDMIN + 0x18)
// Shorthand for ninth element of display text fields array
#define PROPID_TEXT8             (PROPID_RESERVEDMIN + 0x19)
// Shorthand for tenth element of display text fields array
#define PROPID_TEXT9             (PROPID_RESERVEDMIN + 0x1a)

// Array of highlight specifications for the default text fields used for displaying in UI
#define PROPID_DISPLAYTEXTFIELD_HIGHLIGHTS (PROPID_RESERVEDMIN + 0x20)
// Highlight specification corresponding to first element of display text fields array
#define PROPID_TEXT0_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x21)
// Highlight specification corresponding to second element of display text fields array
#define PROPID_TEXT1_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x22)
// Highlight specification corresponding to third element of display text fields array
#define PROPID_TEXT2_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x23)
// Highlight specification corresponding to fourth element of display text fields array
#define PROPID_TEXT3_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x24)
// Highlight specification corresponding to fifth element of display text fields array
#define PROPID_TEXT4_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x25)
// Highlight specification corresponding to sixth element of display text fields array
#define PROPID_TEXT5_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x26)
// Highlight specification corresponding to seventh element of display text fields array
#define PROPID_TEXT6_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x27)
// Highlight specification corresponding to ighth element of display text fields array
#define PROPID_TEXT7_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x28)
// Highlight specification corresponding to ninth element of display text fields array
#define PROPID_TEXT8_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x29)
// Highlight specification corresponding to tenth element of display text fields array
#define PROPID_TEXT9_HIGHLIGHT   (PROPID_RESERVEDMIN + 0x2a)

// Array of default images used for displaying in UI
#define PROPID_DISPLAYIMAGES     (PROPID_RESERVEDMIN + 0x30)
// Shorthand for first element of display image array
#define PROPID_IMAGE0            (PROPID_RESERVEDMIN + 0x31)
// Shorthand for second element of display image array
#define PROPID_IMAGE1            (PROPID_RESERVEDMIN + 0x32)
// Shorthand for third element of display image array
#define PROPID_IMAGE2            (PROPID_RESERVEDMIN + 0x33)
// Shorthand for fourth element of display image array
#define PROPID_IMAGE3            (PROPID_RESERVEDMIN + 0x34)
// Shorthand for fifth element of display image array
#define PROPID_IMAGE4            (PROPID_RESERVEDMIN + 0x35)
// Shorthand for sixth element of display image array
#define PROPID_IMAGE5            (PROPID_RESERVEDMIN + 0x36)
// Shorthand for seventh element of display image array
#define PROPID_IMAGE6            (PROPID_RESERVEDMIN + 0x37)
// Shorthand for eighth element of display image array
#define PROPID_IMAGE7            (PROPID_RESERVEDMIN + 0x38)
// Shorthand for ninth element of display image array
#define PROPID_IMAGE8            (PROPID_RESERVEDMIN + 0x39)
// Shorthand for tenth element of display image array
#define PROPID_IMAGE9            (PROPID_RESERVEDMIN + 0x3a)

// List contained by item. May be used for tree-like behavior or
// for obtaining sub-lists concatenated into a bigger grouped list
#define PROPID_LIST              (PROPID_RESERVEDMIN + 0x40)
// Item phone number returned as an alphanumeric string which
// Should be supported by items that support dialing.
// Data is returned as a VT_LPWSTR type.
#define PROPID_DIALSTRING        (PROPID_RESERVEDMIN + 0x41)
// Reserved by system.
#define PROPID_RESERVED1         (PROPID_RESERVEDMIN + 0x42)
// Maximum ID value used for global properties
#define PROPID_RESERVEDMAX       (PROPID_RESERVED1)
// Reserve a range of 256 property IDs for global item properties
extern int dummary_array[(PROPID_RESERVEDMAX - PROPID_RESERVEDMIN) <= 0xFF];






// Retrieve properties from underlying data source even if already cached
#define CACHEPROPOPT_READTHROUGH 0x01


extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0008_v0_0_s_ifspec;

#ifndef __IVirtualItem_INTERFACE_DEFINED__
#define __IVirtualItem_INTERFACE_DEFINED__

/* interface IVirtualItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVirtualItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18fd8835-0a81-4fd4-b851-ad91eb0573be")
    IVirtualItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsValid( 
            /* [retval][out] */ BOOL *pfValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CachePropertiesHint( 
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbSource( 
            /* [retval][out] */ IVerbSource **ppVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [out] */ IEvent **ppEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVirtualItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVirtualItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVirtualItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVirtualItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            IVirtualItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            IVirtualItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IVirtualItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IVirtualItem * This,
            /* [out] */ IEvent **ppEvent);
        
        END_INTERFACE
    } IVirtualItemVtbl;

    interface IVirtualItem
    {
        CONST_VTBL struct IVirtualItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVirtualItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVirtualItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVirtualItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVirtualItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define IVirtualItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IVirtualItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define IVirtualItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IVirtualItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVirtualItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0009 */
/* [local] */ 



// Property has been added to item
#define VITEMEVENT_PROPADDED     0x00000000

// Property in item has changed
#define VITEMEVENT_PROPCHANGED   0x00000001

// Property in item has been removed
#define VITEMEVENT_PROPDELETED   0x00000002

typedef struct _VITEMEVENTPARAMS
    {
    DWORD dwPropID;
    } 	VITEMEVENTPARAMS;

typedef 
enum _LISTSORTDIRECTION
    {	LSDIR_ASCENDING	= 1,
	LSDIR_DESCENDING	= 2,
	LSDIR_BOTH	= 3
    } 	LISTSORTDIRECTION;

// Maximum length allowable for string filters
// including NULL terminating character.
#define VLFILTER_MAX             256


extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0009_v0_0_s_ifspec;

#ifndef __IVirtualList_INTERFACE_DEFINED__
#define __IVirtualList_INTERFACE_DEFINED__

/* interface IVirtualList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVirtualList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c54297ea-1df0-4296-9c1d-9078fbba8bc7")
    IVirtualList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ UINT *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ UINT iItem,
            /* [retval][out] */ IVirtualItem **ppviItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CacheItemsHint( 
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterString( 
            /* [size_is][out] */ LPOLESTR pszFilter,
            /* [out][in] */ UINT *pcchFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterString( 
            /* [in] */ LPCOLESTR pszFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortPropertyID( 
            /* [retval][out] */ DWORD *pdwPropertyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDirection( 
            /* [retval][out] */ LISTSORTDIRECTION *plsdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortCount( 
            /* [retval][out] */ UINT *pcSort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortPropertyID( 
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortDirection( 
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplySort( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbSource( 
            /* [retval][out] */ IVerbSource **ppVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [out] */ IEvent **ppEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVirtualListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVirtualList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVirtualList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IVirtualList * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IVirtualList * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ IVirtualItem **ppviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IVirtualList * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IVirtualList * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterString )( 
            IVirtualList * This,
            /* [size_is][out] */ LPOLESTR pszFilter,
            /* [out][in] */ UINT *pcchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IVirtualList * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortPropertyID )( 
            IVirtualList * This,
            /* [retval][out] */ DWORD *pdwPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDirection )( 
            IVirtualList * This,
            /* [retval][out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IVirtualList * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IVirtualList * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IVirtualList * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IVirtualList * This,
            /* [out] */ IEvent **ppEvent);
        
        END_INTERFACE
    } IVirtualListVtbl;

    interface IVirtualList
    {
        CONST_VTBL struct IVirtualListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVirtualList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVirtualList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVirtualList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVirtualList_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IVirtualList_GetItem(This,iItem,ppviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppviItem) ) 

#define IVirtualList_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IVirtualList_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IVirtualList_GetFilterString(This,pszFilter,pcchFilter)	\
    ( (This)->lpVtbl -> GetFilterString(This,pszFilter,pcchFilter) ) 

#define IVirtualList_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IVirtualList_GetSortPropertyID(This,pdwPropertyID)	\
    ( (This)->lpVtbl -> GetSortPropertyID(This,pdwPropertyID) ) 

#define IVirtualList_GetSortDirection(This,plsdir)	\
    ( (This)->lpVtbl -> GetSortDirection(This,plsdir) ) 

#define IVirtualList_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IVirtualList_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IVirtualList_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IVirtualList_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IVirtualList_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IVirtualList_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IVirtualList_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVirtualList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0010 */
/* [local] */ 



// List has changed significantly
#define VLISTEVENT_RESET         0x00000000

// Item was added to list
#define VLISTEVENT_ITEMADDED     0x00000001

// Item in list has changed
#define VLISTEVENT_ITEMCHANGED   0x00000002

// Item in list has been removed
#define VLISTEVENT_ITEMDELETED   0x00000003

// Item in list has been moved
#define VLISTEVENT_ITEMMOVED     0x00000004

typedef struct _VLISTEVENTPARAMS
    {
    UINT iNewItem;
    UINT iOldItem;
    } 	VLISTEVENTPARAMS;

typedef struct _RESETEVENTPARAMS
    {
    UINT cItemsNew;
    UINT cItemsOld;
    UINT iFirstItemAffected;
    UINT cItemsAffected;
    } 	RESETEVENTPARAMS;

// Minimum ID value for global properties
#define LISTPROPID_RESERVEDMIN       0xFFFFFE00
// Specifies whether the list supports unique IDs for its items.
#define LISTPROPID_SUPPORTSUNIQUEID     (LISTPROPID_RESERVEDMIN + 0x01)
// A property of type VT_UNKNOWN that supports IMatchReasonsCollection
// interface. This object contains a summary of the strings actually
// matched within the list's items after a call to
// IVirtualList.SetFilterString.
#define LISTPROPID_STRINGMATCHREASONS    (LISTPROPID_RESERVEDMIN + 0x02)
// Description of List Contents
#define LISTPROPID_TITLE                 (LISTPROPID_RESERVEDMIN + 0x03)
// Category to which all items in a list belong. This is an optional property
// that should only be expected in scenarios that explicitly specify it.
#define LISTPROPID_ITEMCATEGORY          (LISTPROPID_RESERVEDMIN + 0x04)
// Reserve a range of 256 property IDs for global list properties
// Maximum ID value used for list properties
#define LISTPROPID_RESERVEDMAX           (LISTPROPID_ITEMCATEGORY)
extern int dummary_array[(LISTPROPID_RESERVEDMAX - LISTPROPID_RESERVEDMIN) <= 0xFF];



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0010_v0_0_s_ifspec;

#ifndef __IGroupedVirtualList_INTERFACE_DEFINED__
#define __IGroupedVirtualList_INTERFACE_DEFINED__

/* interface IGroupedVirtualList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGroupedVirtualList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fd47c3e-853c-4a6e-957e-0c4a5f6d3cb8")
    IGroupedVirtualList : public IVirtualList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGroupCount( 
            /* [out] */ UINT *pcGroups) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupInfo( 
            /* [in] */ UINT uGroupIdx,
            /* [out] */ UINT *puMinRange,
            /* [out] */ IVirtualItem **ppviGroupDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGroupedVirtualListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGroupedVirtualList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGroupedVirtualList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGroupedVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IGroupedVirtualList * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IGroupedVirtualList * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ IVirtualItem **ppviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IGroupedVirtualList * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IGroupedVirtualList * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterString )( 
            IGroupedVirtualList * This,
            /* [size_is][out] */ LPOLESTR pszFilter,
            /* [out][in] */ UINT *pcchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IGroupedVirtualList * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortPropertyID )( 
            IGroupedVirtualList * This,
            /* [retval][out] */ DWORD *pdwPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDirection )( 
            IGroupedVirtualList * This,
            /* [retval][out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IGroupedVirtualList * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IGroupedVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IGroupedVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IGroupedVirtualList * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IGroupedVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IGroupedVirtualList * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IGroupedVirtualList * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCount )( 
            IGroupedVirtualList * This,
            /* [out] */ UINT *pcGroups);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupInfo )( 
            IGroupedVirtualList * This,
            /* [in] */ UINT uGroupIdx,
            /* [out] */ UINT *puMinRange,
            /* [out] */ IVirtualItem **ppviGroupDescription);
        
        END_INTERFACE
    } IGroupedVirtualListVtbl;

    interface IGroupedVirtualList
    {
        CONST_VTBL struct IGroupedVirtualListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGroupedVirtualList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGroupedVirtualList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGroupedVirtualList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGroupedVirtualList_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IGroupedVirtualList_GetItem(This,iItem,ppviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppviItem) ) 

#define IGroupedVirtualList_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IGroupedVirtualList_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IGroupedVirtualList_GetFilterString(This,pszFilter,pcchFilter)	\
    ( (This)->lpVtbl -> GetFilterString(This,pszFilter,pcchFilter) ) 

#define IGroupedVirtualList_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IGroupedVirtualList_GetSortPropertyID(This,pdwPropertyID)	\
    ( (This)->lpVtbl -> GetSortPropertyID(This,pdwPropertyID) ) 

#define IGroupedVirtualList_GetSortDirection(This,plsdir)	\
    ( (This)->lpVtbl -> GetSortDirection(This,plsdir) ) 

#define IGroupedVirtualList_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IGroupedVirtualList_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IGroupedVirtualList_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IGroupedVirtualList_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IGroupedVirtualList_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IGroupedVirtualList_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IGroupedVirtualList_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IGroupedVirtualList_GetGroupCount(This,pcGroups)	\
    ( (This)->lpVtbl -> GetGroupCount(This,pcGroups) ) 

#define IGroupedVirtualList_GetGroupInfo(This,uGroupIdx,puMinRange,ppviGroupDescription)	\
    ( (This)->lpVtbl -> GetGroupInfo(This,uGroupIdx,puMinRange,ppviGroupDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGroupedVirtualList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0011 */
/* [local] */ 

typedef 
enum _VIPRSTATUS
    {	VIPRS_AVAILABLE	= 1,
	VIPRS_UNAVAILABLE	= 2
    } 	VIPRSTATUS;

typedef struct _VIPRINFO
    {
    DWORD dwPropID;
    VARTYPE vt;
    VIPRSTATUS viprs;
    } 	VIPRINFO;

typedef struct _ITEMPROPERTY
    {
    DWORD dwID;
    PROPVARIANT varValue;
    } 	ITEMPROPERTY;



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0011_v0_0_s_ifspec;

#ifndef __ICategorizedVirtualItem_INTERFACE_DEFINED__
#define __ICategorizedVirtualItem_INTERFACE_DEFINED__

/* interface ICategorizedVirtualItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICategorizedVirtualItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9a0c8cbd-24b6-45f4-a6a5-e6f75711ec2c")
    ICategorizedVirtualItem : public IVirtualItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyRef( 
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [size_is][out] */ LPOLESTR pszDataCategory,
            /* [out][in] */ UINT *pcchDataCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryRef( 
            /* [out] */ LPOLESTR *ppszDataCategory,
            /* [out] */ UINT *pcchDataCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueID( 
            /* [size_is][out] */ BYTE *rgbUniqueID,
            /* [out][in] */ UINT *pcbUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueIDRef( 
            /* [out] */ BYTE **prgbUniqueID,
            /* [out] */ UINT *pcbUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayTextFieldCount( 
            /* [out] */ UINT *pcDisplayFieldCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayTextField( 
            /* [in] */ UINT iDisplayField,
            /* [size_is][out] */ LPOLESTR pszDisplayField,
            /* [out][in] */ UINT *pcchDisplayField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayImageCount( 
            /* [out] */ UINT *pcDisplayImageCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayImage( 
            /* [in] */ UINT iDisplayImage,
            /* [size_is][out] */ LPOLESTR pszDisplayImage,
            /* [out][in] */ UINT *pcchDisplayImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllProperties( 
            /* [out] */ ITEMPROPERTY **prgProperties,
            /* [out] */ UINT *pcProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeProperties( 
            /* [size_is][in] */ ITEMPROPERTY *rgProperties,
            /* [in] */ UINT cProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInformation( 
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ VIPRINFO *pvipriInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizedVirtualItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategorizedVirtualItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategorizedVirtualItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategorizedVirtualItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICategorizedVirtualItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ICategorizedVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            ICategorizedVirtualItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            ICategorizedVirtualItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            ICategorizedVirtualItem * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRef )( 
            ICategorizedVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ICategorizedVirtualItem * This,
            /* [size_is][out] */ LPOLESTR pszDataCategory,
            /* [out][in] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryRef )( 
            ICategorizedVirtualItem * This,
            /* [out] */ LPOLESTR *ppszDataCategory,
            /* [out] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueID )( 
            ICategorizedVirtualItem * This,
            /* [size_is][out] */ BYTE *rgbUniqueID,
            /* [out][in] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueIDRef )( 
            ICategorizedVirtualItem * This,
            /* [out] */ BYTE **prgbUniqueID,
            /* [out] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextFieldCount )( 
            ICategorizedVirtualItem * This,
            /* [out] */ UINT *pcDisplayFieldCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextField )( 
            ICategorizedVirtualItem * This,
            /* [in] */ UINT iDisplayField,
            /* [size_is][out] */ LPOLESTR pszDisplayField,
            /* [out][in] */ UINT *pcchDisplayField);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImageCount )( 
            ICategorizedVirtualItem * This,
            /* [out] */ UINT *pcDisplayImageCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImage )( 
            ICategorizedVirtualItem * This,
            /* [in] */ UINT iDisplayImage,
            /* [size_is][out] */ LPOLESTR pszDisplayImage,
            /* [out][in] */ UINT *pcchDisplayImage);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllProperties )( 
            ICategorizedVirtualItem * This,
            /* [out] */ ITEMPROPERTY **prgProperties,
            /* [out] */ UINT *pcProperties);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProperties )( 
            ICategorizedVirtualItem * This,
            /* [size_is][in] */ ITEMPROPERTY *rgProperties,
            /* [in] */ UINT cProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInformation )( 
            ICategorizedVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ VIPRINFO *pvipriInfo);
        
        END_INTERFACE
    } ICategorizedVirtualItemVtbl;

    interface ICategorizedVirtualItem
    {
        CONST_VTBL struct ICategorizedVirtualItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizedVirtualItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategorizedVirtualItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategorizedVirtualItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategorizedVirtualItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define ICategorizedVirtualItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define ICategorizedVirtualItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define ICategorizedVirtualItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define ICategorizedVirtualItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define ICategorizedVirtualItem_GetPropertyRef(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRef(This,dwPropertyID,pPropertyValue) ) 

#define ICategorizedVirtualItem_GetCategory(This,pszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pszDataCategory,pcchDataCategory) ) 

#define ICategorizedVirtualItem_GetCategoryRef(This,ppszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategoryRef(This,ppszDataCategory,pcchDataCategory) ) 

#define ICategorizedVirtualItem_GetUniqueID(This,rgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueID(This,rgbUniqueID,pcbUniqueID) ) 

#define ICategorizedVirtualItem_GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID) ) 

#define ICategorizedVirtualItem_GetDisplayTextFieldCount(This,pcDisplayFieldCount)	\
    ( (This)->lpVtbl -> GetDisplayTextFieldCount(This,pcDisplayFieldCount) ) 

#define ICategorizedVirtualItem_GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField)	\
    ( (This)->lpVtbl -> GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField) ) 

#define ICategorizedVirtualItem_GetDisplayImageCount(This,pcDisplayImageCount)	\
    ( (This)->lpVtbl -> GetDisplayImageCount(This,pcDisplayImageCount) ) 

#define ICategorizedVirtualItem_GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage)	\
    ( (This)->lpVtbl -> GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage) ) 

#define ICategorizedVirtualItem_GetAllProperties(This,prgProperties,pcProperties)	\
    ( (This)->lpVtbl -> GetAllProperties(This,prgProperties,pcProperties) ) 

#define ICategorizedVirtualItem_FreeProperties(This,rgProperties,cProperties)	\
    ( (This)->lpVtbl -> FreeProperties(This,rgProperties,cProperties) ) 

#define ICategorizedVirtualItem_GetPropertyInformation(This,dwPropertyID,pvipriInfo)	\
    ( (This)->lpVtbl -> GetPropertyInformation(This,dwPropertyID,pvipriInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategorizedVirtualItem_INTERFACE_DEFINED__ */


#ifndef __IDataItem_INTERFACE_DEFINED__
#define __IDataItem_INTERFACE_DEFINED__

/* interface IDataItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDataItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1cf7754-cb12-4de0-8508-ed6f81fb1261")
    IDataItem : public IVirtualItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVerbSource( 
            /* [in] */ IVerbExtension *pVerbSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            IDataItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            IDataItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IDataItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IDataItem * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetVerbSource )( 
            IDataItem * This,
            /* [in] */ IVerbExtension *pVerbSource);
        
        END_INTERFACE
    } IDataItemVtbl;

    interface IDataItem
    {
        CONST_VTBL struct IDataItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define IDataItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IDataItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define IDataItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IDataItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IDataItem_SetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> SetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IDataItem_SetVerbSource(This,pVerbSource)	\
    ( (This)->lpVtbl -> SetVerbSource(This,pVerbSource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataItem_INTERFACE_DEFINED__ */


#ifndef __ICategorizedDataItem_INTERFACE_DEFINED__
#define __ICategorizedDataItem_INTERFACE_DEFINED__

/* interface ICategorizedDataItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICategorizedDataItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d114133-baba-4110-bd77-dd59c6a6a82d")
    ICategorizedDataItem : public ICategorizedVirtualItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [in] */ LPCOLESTR pszDataCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUniqueID( 
            /* [size_is][in] */ const BYTE *rgbUniqueID,
            /* [in] */ UINT cbUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayTextFields( 
            /* [size_is][in] */ LPCOLESTR *rgpszDisplayFields,
            /* [in] */ UINT cDisplayFields) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayTextFieldsEx( 
            /* [size_is][in] */ const PROPVARIANT *rgvarDisplayFields,
            /* [in] */ UINT cDisplayFields) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayImages( 
            /* [size_is][in] */ LPCOLESTR *rgpszDisplayImages,
            /* [in] */ UINT cDisplayImages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayImagesEx( 
            /* [size_is][in] */ const PROPVARIANT *rgvarDisplayImages,
            /* [in] */ UINT cDisplayImages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyInformation( 
            /* [in] */ const VIPRINFO *pvipriInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVerbSource( 
            /* [in] */ IVerbExtension *pVerbSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizedDataItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategorizedDataItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategorizedDataItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategorizedDataItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICategorizedDataItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ICategorizedDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            ICategorizedDataItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            ICategorizedDataItem * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRef )( 
            ICategorizedDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ICategorizedDataItem * This,
            /* [size_is][out] */ LPOLESTR pszDataCategory,
            /* [out][in] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryRef )( 
            ICategorizedDataItem * This,
            /* [out] */ LPOLESTR *ppszDataCategory,
            /* [out] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueID )( 
            ICategorizedDataItem * This,
            /* [size_is][out] */ BYTE *rgbUniqueID,
            /* [out][in] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueIDRef )( 
            ICategorizedDataItem * This,
            /* [out] */ BYTE **prgbUniqueID,
            /* [out] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextFieldCount )( 
            ICategorizedDataItem * This,
            /* [out] */ UINT *pcDisplayFieldCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextField )( 
            ICategorizedDataItem * This,
            /* [in] */ UINT iDisplayField,
            /* [size_is][out] */ LPOLESTR pszDisplayField,
            /* [out][in] */ UINT *pcchDisplayField);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImageCount )( 
            ICategorizedDataItem * This,
            /* [out] */ UINT *pcDisplayImageCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImage )( 
            ICategorizedDataItem * This,
            /* [in] */ UINT iDisplayImage,
            /* [size_is][out] */ LPOLESTR pszDisplayImage,
            /* [out][in] */ UINT *pcchDisplayImage);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllProperties )( 
            ICategorizedDataItem * This,
            /* [out] */ ITEMPROPERTY **prgProperties,
            /* [out] */ UINT *pcProperties);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProperties )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ ITEMPROPERTY *rgProperties,
            /* [in] */ UINT cProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInformation )( 
            ICategorizedDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ VIPRINFO *pvipriInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            ICategorizedDataItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetCategory )( 
            ICategorizedDataItem * This,
            /* [in] */ LPCOLESTR pszDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *SetUniqueID )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ const BYTE *rgbUniqueID,
            /* [in] */ UINT cbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayTextFields )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ LPCOLESTR *rgpszDisplayFields,
            /* [in] */ UINT cDisplayFields);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayTextFieldsEx )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ const PROPVARIANT *rgvarDisplayFields,
            /* [in] */ UINT cDisplayFields);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayImages )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ LPCOLESTR *rgpszDisplayImages,
            /* [in] */ UINT cDisplayImages);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayImagesEx )( 
            ICategorizedDataItem * This,
            /* [size_is][in] */ const PROPVARIANT *rgvarDisplayImages,
            /* [in] */ UINT cDisplayImages);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyInformation )( 
            ICategorizedDataItem * This,
            /* [in] */ const VIPRINFO *pvipriInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetVerbSource )( 
            ICategorizedDataItem * This,
            /* [in] */ IVerbExtension *pVerbSource);
        
        END_INTERFACE
    } ICategorizedDataItemVtbl;

    interface ICategorizedDataItem
    {
        CONST_VTBL struct ICategorizedDataItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizedDataItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategorizedDataItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategorizedDataItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategorizedDataItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define ICategorizedDataItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define ICategorizedDataItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define ICategorizedDataItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define ICategorizedDataItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define ICategorizedDataItem_GetPropertyRef(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRef(This,dwPropertyID,pPropertyValue) ) 

#define ICategorizedDataItem_GetCategory(This,pszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pszDataCategory,pcchDataCategory) ) 

#define ICategorizedDataItem_GetCategoryRef(This,ppszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategoryRef(This,ppszDataCategory,pcchDataCategory) ) 

#define ICategorizedDataItem_GetUniqueID(This,rgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueID(This,rgbUniqueID,pcbUniqueID) ) 

#define ICategorizedDataItem_GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID) ) 

#define ICategorizedDataItem_GetDisplayTextFieldCount(This,pcDisplayFieldCount)	\
    ( (This)->lpVtbl -> GetDisplayTextFieldCount(This,pcDisplayFieldCount) ) 

#define ICategorizedDataItem_GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField)	\
    ( (This)->lpVtbl -> GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField) ) 

#define ICategorizedDataItem_GetDisplayImageCount(This,pcDisplayImageCount)	\
    ( (This)->lpVtbl -> GetDisplayImageCount(This,pcDisplayImageCount) ) 

#define ICategorizedDataItem_GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage)	\
    ( (This)->lpVtbl -> GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage) ) 

#define ICategorizedDataItem_GetAllProperties(This,prgProperties,pcProperties)	\
    ( (This)->lpVtbl -> GetAllProperties(This,prgProperties,pcProperties) ) 

#define ICategorizedDataItem_FreeProperties(This,rgProperties,cProperties)	\
    ( (This)->lpVtbl -> FreeProperties(This,rgProperties,cProperties) ) 

#define ICategorizedDataItem_GetPropertyInformation(This,dwPropertyID,pvipriInfo)	\
    ( (This)->lpVtbl -> GetPropertyInformation(This,dwPropertyID,pvipriInfo) ) 


#define ICategorizedDataItem_SetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> SetProperty(This,dwPropertyID,pPropertyValue) ) 

#define ICategorizedDataItem_SetCategory(This,pszDataCategory)	\
    ( (This)->lpVtbl -> SetCategory(This,pszDataCategory) ) 

#define ICategorizedDataItem_SetUniqueID(This,rgbUniqueID,cbUniqueID)	\
    ( (This)->lpVtbl -> SetUniqueID(This,rgbUniqueID,cbUniqueID) ) 

#define ICategorizedDataItem_SetDisplayTextFields(This,rgpszDisplayFields,cDisplayFields)	\
    ( (This)->lpVtbl -> SetDisplayTextFields(This,rgpszDisplayFields,cDisplayFields) ) 

#define ICategorizedDataItem_SetDisplayTextFieldsEx(This,rgvarDisplayFields,cDisplayFields)	\
    ( (This)->lpVtbl -> SetDisplayTextFieldsEx(This,rgvarDisplayFields,cDisplayFields) ) 

#define ICategorizedDataItem_SetDisplayImages(This,rgpszDisplayImages,cDisplayImages)	\
    ( (This)->lpVtbl -> SetDisplayImages(This,rgpszDisplayImages,cDisplayImages) ) 

#define ICategorizedDataItem_SetDisplayImagesEx(This,rgvarDisplayImages,cDisplayImages)	\
    ( (This)->lpVtbl -> SetDisplayImagesEx(This,rgvarDisplayImages,cDisplayImages) ) 

#define ICategorizedDataItem_SetPropertyInformation(This,pvipriInfo)	\
    ( (This)->lpVtbl -> SetPropertyInformation(This,pvipriInfo) ) 

#define ICategorizedDataItem_SetVerbSource(This,pVerbSource)	\
    ( (This)->lpVtbl -> SetVerbSource(This,pVerbSource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategorizedDataItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0014 */
/* [local] */ 

HRESULT DataItem_CreateInstance( 
    /* [out] */ ICategorizedDataItem **ppcdiNew);

#define DIPM_CACHE      0x01
#define DIPM_UNIQUEID   0x02
#define DIPM_CATEGORY   0x04
typedef struct _DATAITEMPARAMS
    {
    DWORD dwMask;
    IObjectCache *pCache;
    BYTE *rgbUniqueID;
    UINT cbUniqueID;
    LPOLESTR pszCategory;
    } 	DATAITEMPARAMS;

HRESULT DataItem_CreateInstanceWithParams( 
    /* [in] */ DATAITEMPARAMS *pdip,
    /* [out] */ ICategorizedDataItem **ppcdiNew);



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0014_v0_0_s_ifspec;

#ifndef __IDataList_INTERFACE_DEFINED__
#define __IDataList_INTERFACE_DEFINED__

/* interface IDataList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDataList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4767FB09-2906-4b72-885D-EB5228DD0F5A")
    IDataList : public IVirtualList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ IVirtualItem *pviItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [in] */ UINT iItem,
            /* [in] */ IVirtualItem *pviItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllItems( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVerbSource( 
            /* [in] */ IVerbSource *pVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ PROPVARIANT *pListPropertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IDataList * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IDataList * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ IVirtualItem **ppviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IDataList * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IDataList * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterString )( 
            IDataList * This,
            /* [size_is][out] */ LPOLESTR pszFilter,
            /* [out][in] */ UINT *pcchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IDataList * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortPropertyID )( 
            IDataList * This,
            /* [retval][out] */ DWORD *pdwPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDirection )( 
            IDataList * This,
            /* [retval][out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IDataList * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IDataList * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IDataList * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IDataList * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IDataList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IDataList * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IDataList * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            IDataList * This,
            /* [in] */ IVirtualItem *pviItem);
        
        HRESULT ( STDMETHODCALLTYPE *InsertItem )( 
            IDataList * This,
            /* [in] */ UINT iItem,
            /* [in] */ IVirtualItem *pviItem);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            IDataList * This,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllItems )( 
            IDataList * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVerbSource )( 
            IDataList * This,
            /* [in] */ IVerbSource *pVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IDataList * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ PROPVARIANT *pListPropertyValue);
        
        END_INTERFACE
    } IDataListVtbl;

    interface IDataList
    {
        CONST_VTBL struct IDataListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataList_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IDataList_GetItem(This,iItem,ppviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppviItem) ) 

#define IDataList_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IDataList_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IDataList_GetFilterString(This,pszFilter,pcchFilter)	\
    ( (This)->lpVtbl -> GetFilterString(This,pszFilter,pcchFilter) ) 

#define IDataList_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IDataList_GetSortPropertyID(This,pdwPropertyID)	\
    ( (This)->lpVtbl -> GetSortPropertyID(This,pdwPropertyID) ) 

#define IDataList_GetSortDirection(This,plsdir)	\
    ( (This)->lpVtbl -> GetSortDirection(This,plsdir) ) 

#define IDataList_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IDataList_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IDataList_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IDataList_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IDataList_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IDataList_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IDataList_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IDataList_AddItem(This,pviItem)	\
    ( (This)->lpVtbl -> AddItem(This,pviItem) ) 

#define IDataList_InsertItem(This,iItem,pviItem)	\
    ( (This)->lpVtbl -> InsertItem(This,iItem,pviItem) ) 

#define IDataList_RemoveItem(This,iItem)	\
    ( (This)->lpVtbl -> RemoveItem(This,iItem) ) 

#define IDataList_RemoveAllItems(This)	\
    ( (This)->lpVtbl -> RemoveAllItems(This) ) 

#define IDataList_SetVerbSource(This,pVerbSource)	\
    ( (This)->lpVtbl -> SetVerbSource(This,pVerbSource) ) 

#define IDataList_SetProperty(This,dwPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> SetProperty(This,dwPropertyID,pListPropertyValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vrtldata_0000_0015 */
/* [local] */ 

HRESULT DataList_CreateInstance( 
    /* [out] */ IDataList **ppNewList);



extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrtldata_0000_0015_v0_0_s_ifspec;

#ifndef __IItemInspector_INTERFACE_DEFINED__
#define __IItemInspector_INTERFACE_DEFINED__

/* interface IItemInspector */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IItemInspector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e16cabc2-e109-49f4-ae7b-0797db7abece")
    IItemInspector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsItemValid( 
            /* [in] */ ICategorizedVirtualItem *pcviItem,
            /* [retval][out] */ BOOL *pfValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CachePropertiesInItem( 
            /* [in] */ ICategorizedDataItem *pItem,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbExtension( 
            /* [retval][out] */ IVerbExtension **ppVerbExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemInspectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemInspector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemInspector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemInspector * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsItemValid )( 
            IItemInspector * This,
            /* [in] */ ICategorizedVirtualItem *pcviItem,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesInItem )( 
            IItemInspector * This,
            /* [in] */ ICategorizedDataItem *pItem,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbExtension )( 
            IItemInspector * This,
            /* [retval][out] */ IVerbExtension **ppVerbExtension);
        
        END_INTERFACE
    } IItemInspectorVtbl;

    interface IItemInspector
    {
        CONST_VTBL struct IItemInspectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemInspector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemInspector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemInspector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemInspector_IsItemValid(This,pcviItem,pfValid)	\
    ( (This)->lpVtbl -> IsItemValid(This,pcviItem,pfValid) ) 

#define IItemInspector_CachePropertiesInItem(This,pItem,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CachePropertiesInItem(This,pItem,rgdwPropertyIDs,cPropertyIDs) ) 

#define IItemInspector_GetVerbExtension(This,ppVerbExtension)	\
    ( (This)->lpVtbl -> GetVerbExtension(This,ppVerbExtension) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemInspector_INTERFACE_DEFINED__ */


#ifndef __IPersistBlob_INTERFACE_DEFINED__
#define __IPersistBlob_INTERFACE_DEFINED__

/* interface IPersistBlob */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPersistBlob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f74defe1-344c-4d8e-b358-b4d2b6511f9e")
    IPersistBlob : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ const BLOB *pBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [out] */ BLOB *pBlob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistBlobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistBlob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistBlob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistBlob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistBlob * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistBlob * This,
            /* [in] */ const BLOB *pBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistBlob * This,
            /* [out] */ BLOB *pBlob);
        
        END_INTERFACE
    } IPersistBlobVtbl;

    interface IPersistBlob
    {
        CONST_VTBL struct IPersistBlobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistBlob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistBlob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistBlob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistBlob_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistBlob_Load(This,pBlob)	\
    ( (This)->lpVtbl -> Load(This,pBlob) ) 

#define IPersistBlob_Save(This,pBlob)	\
    ( (This)->lpVtbl -> Save(This,pBlob) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistBlob_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vssym32.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

//-------------------------------------------------------------------------//
//  VisualStyle Core Win32/ComCtl32 symbols
//-------------------------------------------------------------------------//

#ifndef __VSSYM32_H__
#define __VSSYM32_H__

#include "VSStyle.h"

//
//  enumerated property values
//

enum BGTYPE {
	BT_IMAGEFILE = 0,
	BT_BORDERFILL = 1,
	BT_NONE = 2,
};


//
//  enumerated property values
//

enum IMAGELAYOUT {
	IL_VERTICAL = 0,
	IL_HORIZONTAL = 1,
};


//
//  enumerated property values
//

enum BORDERTYPE {
	BT_RECT = 0,
	BT_ROUNDRECT = 1,
	BT_ELLIPSE = 2,
};


//
//  enumerated property values
//

enum FILLTYPE {
	FT_SOLID = 0,
	FT_VERTGRADIENT = 1,
	FT_HORZGRADIENT = 2,
	FT_RADIALGRADIENT = 3,
	FT_TILEIMAGE = 4,
};


//
//  enumerated property values
//

enum SIZINGTYPE {
	ST_TRUESIZE = 0,
	ST_STRETCH = 1,
	ST_TILE = 2,
};


//
//  enumerated property values
//

enum HALIGN {
	HA_LEFT = 0,
	HA_CENTER = 1,
	HA_RIGHT = 2,
};


//
//  enumerated property values
//

enum CONTENTALIGNMENT {
	CA_LEFT = 0,
	CA_CENTER = 1,
	CA_RIGHT = 2,
};


//
//  enumerated property values
//

enum VALIGN {
	VA_TOP = 0,
	VA_CENTER = 1,
	VA_BOTTOM = 2,
};


//
//  enumerated property values
//

enum OFFSETTYPE {
	OT_TOPLEFT = 0,
	OT_TOPRIGHT = 1,
	OT_TOPMIDDLE = 2,
	OT_BOTTOMLEFT = 3,
	OT_BOTTOMRIGHT = 4,
	OT_BOTTOMMIDDLE = 5,
	OT_MIDDLELEFT = 6,
	OT_MIDDLERIGHT = 7,
	OT_LEFTOFCAPTION = 8,
	OT_RIGHTOFCAPTION = 9,
	OT_LEFTOFLASTBUTTON = 10,
	OT_RIGHTOFLASTBUTTON = 11,
	OT_ABOVELASTBUTTON = 12,
	OT_BELOWLASTBUTTON = 13,
};


//
//  enumerated property values
//

enum ICONEFFECT {
	ICE_NONE = 0,
	ICE_GLOW = 1,
	ICE_SHADOW = 2,
	ICE_PULSE = 3,
	ICE_ALPHA = 4,
};


//
//  enumerated property values
//

enum TEXTSHADOWTYPE {
	TST_NONE = 0,
	TST_SINGLE = 1,
	TST_CONTINUOUS = 2,
};


//
//  enumerated property values
//

enum GLYPHTYPE {
	GT_NONE = 0,
	GT_IMAGEGLYPH = 1,
	GT_FONTGLYPH = 2,
};


//
//  enumerated property values
//

enum IMAGESELECTTYPE {
	IST_NONE = 0,
	IST_SIZE = 1,
	IST_DPI = 2,
};


//
//  enumerated property values
//

enum TRUESIZESCALINGTYPE {
	TSST_NONE = 0,
	TSST_SIZE = 1,
	TSST_DPI = 2,
};


//
//  enumerated property values
//

enum GLYPHFONTSIZINGTYPE {
	GFST_NONE = 0,
	GFST_SIZE = 1,
	GFST_DPI = 2,
};

//
//  property symbol definitions
//

#define TMT_RESERVEDLOW	0
#define TMT_RESERVEDHIGH	7999

#define TMT_DIBDATA	2
#define TMT_GLYPHDIBDATA	8
#define TMT_ENUM	200
#define TMT_STRING	201
#define TMT_INT	202
#define TMT_BOOL	203
#define TMT_COLOR	204
#define TMT_MARGINS	205
#define TMT_FILENAME	206
#define TMT_SIZE	207
#define TMT_POSITION	208
#define TMT_RECT	209
#define TMT_FONT	210
#define TMT_INTLIST	211
#define TMT_HBITMAP	212
#define TMT_DISKSTREAM	213
#define TMT_STREAM	214
#define TMT_BITMAPREF	215
#define TMT_COLORSCHEMES	401
#define TMT_SIZES	402
#define TMT_CHARSET	403
#define TMT_NAME	600
#define TMT_DISPLAYNAME	601
#define TMT_TOOLTIP	602
#define TMT_COMPANY	603
#define TMT_AUTHOR	604
#define TMT_COPYRIGHT	605
#define TMT_URL	606
#define TMT_VERSION	607
#define TMT_DESCRIPTION	608
#define TMT_FIRST_RCSTRING_NAME	TMT_DISPLAYNAME
#define TMT_LAST_RCSTRING_NAME	TMT_DESCRIPTION
#define TMT_CAPTIONFONT	801
#define TMT_SMALLCAPTIONFONT	802
#define TMT_MENUFONT	803
#define TMT_STATUSFONT	804
#define TMT_MSGBOXFONT	805
#define TMT_ICONTITLEFONT	806
#define TMT_HEADING1FONT	807
#define TMT_HEADING2FONT	808
#define TMT_BODYFONT	809
#define TMT_FIRSTFONT	TMT_CAPTIONFONT
#define TMT_LASTFONT	TMT_BODYFONT
#define TMT_FLATMENUS	1001
#define TMT_FIRSTBOOL	TMT_FLATMENUS
#define TMT_LASTBOOL	TMT_FLATMENUS
#define TMT_SIZINGBORDERWIDTH	1201
#define TMT_SCROLLBARWIDTH	1202
#define TMT_SCROLLBARHEIGHT	1203
#define TMT_CAPTIONBARWIDTH	1204
#define TMT_CAPTIONBARHEIGHT	1205
#define TMT_SMCAPTIONBARWIDTH	1206
#define TMT_SMCAPTIONBARHEIGHT	1207
#define TMT_MENUBARWIDTH	1208
#define TMT_MENUBARHEIGHT	1209
#define TMT_PADDEDBORDERWIDTH	1210
#define TMT_FIRSTSIZE	TMT_SIZINGBORDERWIDTH
#define TMT_LASTSIZE	TMT_PADDEDBORDERWIDTH
#define TMT_MINCOLORDEPTH	1301
#define TMT_FIRSTINT	TMT_MINCOLORDEPTH
#define TMT_LASTINT	TMT_MINCOLORDEPTH
#define TMT_CSSNAME	1401
#define TMT_XMLNAME	1402
#define TMT_LASTUPDATED	1403
#define TMT_ALIAS	1404
#define TMT_FIRSTSTRING	TMT_CSSNAME
#define TMT_LASTSTRING	TMT_ALIAS
#define TMT_SCROLLBAR	1601
#define TMT_BACKGROUND	1602
#define TMT_ACTIVECAPTION	1603
#define TMT_INACTIVECAPTION	1604
#define TMT_MENU	1605
#define TMT_WINDOW	1606
#define TMT_WINDOWFRAME	1607
#define TMT_MENUTEXT	1608
#define TMT_WINDOWTEXT	1609
#define TMT_CAPTIONTEXT	1610
#define TMT_ACTIVEBORDER	1611
#define TMT_INACTIVEBORDER	1612
#define TMT_APPWORKSPACE	1613
#define TMT_HIGHLIGHT	1614
#define TMT_HIGHLIGHTTEXT	1615
#define TMT_BTNFACE	1616
#define TMT_BTNSHADOW	1617
#define TMT_GRAYTEXT	1618
#define TMT_BTNTEXT	1619
#define TMT_INACTIVECAPTIONTEXT	1620
#define TMT_BTNHIGHLIGHT	1621
#define TMT_DKSHADOW3D	1622
#define TMT_LIGHT3D	1623
#define TMT_INFOTEXT	1624
#define TMT_INFOBK	1625
#define TMT_BUTTONALTERNATEFACE	1626
#define TMT_HOTTRACKING	1627
#define TMT_GRADIENTACTIVECAPTION	1628
#define TMT_GRADIENTINACTIVECAPTION	1629
#define TMT_MENUHILIGHT	1630
#define TMT_MENUBAR	1631
#define TMT_FIRSTCOLOR	TMT_SCROLLBAR
#define TMT_LASTCOLOR	TMT_MENUBAR
#define TMT_FROMHUE1	1801
#define TMT_FROMHUE2	1802
#define TMT_FROMHUE3	1803
#define TMT_FROMHUE4	1804
#define TMT_FROMHUE5	1805
#define TMT_TOHUE1	1806
#define TMT_TOHUE2	1807
#define TMT_TOHUE3	1808
#define TMT_TOHUE4	1809
#define TMT_TOHUE5	1810
#define TMT_FROMCOLOR1	2001
#define TMT_FROMCOLOR2	2002
#define TMT_FROMCOLOR3	2003
#define TMT_FROMCOLOR4	2004
#define TMT_FROMCOLOR5	2005
#define TMT_TOCOLOR1	2006
#define TMT_TOCOLOR2	2007
#define TMT_TOCOLOR3	2008
#define TMT_TOCOLOR4	2009
#define TMT_TOCOLOR5	2010
#define TMT_TRANSPARENT	2201
#define TMT_AUTOSIZE	2202
#define TMT_BORDERONLY	2203
#define TMT_COMPOSITED	2204
#define TMT_BGFILL	2205
#define TMT_GLYPHTRANSPARENT	2206
#define TMT_GLYPHONLY	2207
#define TMT_ALWAYSSHOWSIZINGBAR	2208
#define TMT_MIRRORIMAGE	2209
#define TMT_UNIFORMSIZING	2210
#define TMT_INTEGRALSIZING	2211
#define TMT_SOURCEGROW	2212
#define TMT_SOURCESHRINK	2213
#define TMT_DRAWBORDERS	2214
#define TMT_NOETCHEDEFFECT	2215
#define TMT_TEXTAPPLYOVERLAY	2216
#define TMT_TEXTGLOW	2217
#define TMT_TEXTITALIC	2218
#define TMT_COMPOSITEDOPAQUE	2219
#define TMT_LOCALIZEDMIRRORIMAGE	2220
#define TMT_IMAGECOUNT	2401
#define TMT_ALPHALEVEL	2402
#define TMT_BORDERSIZE	2403
#define TMT_ROUNDCORNERWIDTH	2404
#define TMT_ROUNDCORNERHEIGHT	2405
#define TMT_GRADIENTRATIO1	2406
#define TMT_GRADIENTRATIO2	2407
#define TMT_GRADIENTRATIO3	2408
#define TMT_GRADIENTRATIO4	2409
#define TMT_GRADIENTRATIO5	2410
#define TMT_PROGRESSCHUNKSIZE	2411
#define TMT_PROGRESSSPACESIZE	2412
#define TMT_SATURATION	2413
#define TMT_TEXTBORDERSIZE	2414
#define TMT_ALPHATHRESHOLD	2415
#define TMT_WIDTH	2416
#define TMT_HEIGHT	2417
#define TMT_GLYPHINDEX	2418
#define TMT_TRUESIZESTRETCHMARK	2419
#define TMT_MINDPI1	2420
#define TMT_MINDPI2	2421
#define TMT_MINDPI3	2422
#define TMT_MINDPI4	2423
#define TMT_MINDPI5	2424
#define TMT_TEXTGLOWSIZE	2425
#define TMT_FRAMESPERSECOND	2426
#define TMT_PIXELSPERFRAME	2427
#define TMT_ANIMATIONDELAY	2428
#define TMT_GLOWINTENSITY	2429
#define TMT_OPACITY	2430
#define TMT_COLORIZATIONCOLOR	2431
#define TMT_COLORIZATIONOPACITY	2432
#define TMT_GLYPHFONT	2601
#define TMT_IMAGEFILE	3001
#define TMT_IMAGEFILE1	3002
#define TMT_IMAGEFILE2	3003
#define TMT_IMAGEFILE3	3004
#define TMT_IMAGEFILE4	3005
#define TMT_IMAGEFILE5	3006
#define TMT_GLYPHIMAGEFILE	3008
#define TMT_TEXT	3201
#define TMT_CLASSICVALUE	3202
#define TMT_OFFSET	3401
#define TMT_TEXTSHADOWOFFSET	3402
#define TMT_MINSIZE	3403
#define TMT_MINSIZE1	3404
#define TMT_MINSIZE2	3405
#define TMT_MINSIZE3	3406
#define TMT_MINSIZE4	3407
#define TMT_MINSIZE5	3408
#define TMT_NORMALSIZE	3409
#define TMT_SIZINGMARGINS	3601
#define TMT_CONTENTMARGINS	3602
#define TMT_CAPTIONMARGINS	3603
#define TMT_BORDERCOLOR	3801
#define TMT_FILLCOLOR	3802
#define TMT_TEXTCOLOR	3803
#define TMT_EDGELIGHTCOLOR	3804
#define TMT_EDGEHIGHLIGHTCOLOR	3805
#define TMT_EDGESHADOWCOLOR	3806
#define TMT_EDGEDKSHADOWCOLOR	3807
#define TMT_EDGEFILLCOLOR	3808
#define TMT_TRANSPARENTCOLOR	3809
#define TMT_GRADIENTCOLOR1	3810
#define TMT_GRADIENTCOLOR2	3811
#define TMT_GRADIENTCOLOR3	3812
#define TMT_GRADIENTCOLOR4	3813
#define TMT_GRADIENTCOLOR5	3814
#define TMT_SHADOWCOLOR	3815
#define TMT_GLOWCOLOR	3816
#define TMT_TEXTBORDERCOLOR	3817
#define TMT_TEXTSHADOWCOLOR	3818
#define TMT_GLYPHTEXTCOLOR	3819
#define TMT_GLYPHTRANSPARENTCOLOR	3820
#define TMT_FILLCOLORHINT	3821
#define TMT_BORDERCOLORHINT	3822
#define TMT_ACCENTCOLORHINT	3823
#define TMT_TEXTCOLORHINT	3824
#define TMT_HEADING1TEXTCOLOR	3825
#define TMT_HEADING2TEXTCOLOR	3826
#define TMT_BODYTEXTCOLOR	3827
#define TMT_BGTYPE	4001
#define TMT_BORDERTYPE	4002
#define TMT_FILLTYPE	4003
#define TMT_SIZINGTYPE	4004
#define TMT_HALIGN	4005
#define TMT_CONTENTALIGNMENT	4006
#define TMT_VALIGN	4007
#define TMT_OFFSETTYPE	4008
#define TMT_ICONEFFECT	4009
#define TMT_TEXTSHADOWTYPE	4010
#define TMT_IMAGELAYOUT	4011
#define TMT_GLYPHTYPE	4012
#define TMT_IMAGESELECTTYPE	4013
#define TMT_GLYPHFONTSIZINGTYPE	4014
#define TMT_TRUESIZESCALINGTYPE	4015
#define TMT_USERPICTURE	5001
#define TMT_DEFAULTPANESIZE	5002
#define TMT_BLENDCOLOR	5003
#define TMT_CUSTOMSPLITRECT	5004
#define TMT_ANIMATIONBUTTONRECT	5005
#define TMT_ANIMATIONDURATION	5006
#define TMT_TRANSITIONDURATIONS	6000
#define TMT_SCALEDBACKGROUND	7001
#define TMT_ATLASIMAGE	8000
#define TMT_ATLASINPUTIMAGE	8001
#define TMT_ATLASRECT	8002


//
//  LINK class parts and states 
//
#define VSCLASS_LINK	L"LINK"

enum LINKPARTS {
	LP_HYPERLINK = 1,
};

enum HYPERLINKSTATES {
	HLS_NORMALTEXT = 1,
	HLS_LINKTEXT = 2,
};


//
//  EMPTYMARKUP class parts and states 
//
#define VSCLASS_EMPTYMARKUP	L"EMPTYMARKUP"

enum EMPTYMARKUPPARTS {
	EMP_MARKUPTEXT = 1,
};

enum MARKUPTEXTSTATES {
	EMT_NORMALTEXT = 1,
	EMT_LINKTEXT = 2,
};


//
//  STATIC class parts and states 
//
#define VSCLASS_STATIC	L"STATIC"

enum STATICPARTS {
	STAT_TEXT = 1,
};


//
//  PAGE class parts and states 
//
#define VSCLASS_PAGE	L"PAGE"

enum PAGEPARTS {
	PGRP_UP = 1,
	PGRP_DOWN = 2,
	PGRP_UPHORZ = 3,
	PGRP_DOWNHORZ = 4,
};


//
//  MONTHCAL class parts and states 
//
#define VSCLASS_MONTHCAL	L"MONTHCAL"

enum MONTHCALPARTS {
	MC_BACKGROUND = 1,
	MC_BORDERS = 2,
	MC_GRIDBACKGROUND = 3,
	MC_COLHEADERSPLITTER = 4,
	MC_GRIDCELLBACKGROUND = 5,
	MC_GRIDCELL = 6,
	MC_GRIDCELLUPPER = 7,
	MC_TRAILINGGRIDCELL = 8,
	MC_TRAILINGGRIDCELLUPPER = 9,
	MC_NAVNEXT = 10,
	MC_NAVPREV = 11,
};

enum GRIDCELLBACKGROUNDSTATES {
	MCGCB_SELECTED = 1,
	MCGCB_HOT = 2,
	MCGCB_SELECTEDHOT = 3,
	MCGCB_SELECTEDNOTFOCUSED = 4,
	MCGCB_TODAY = 5,
};

enum GRIDCELLSTATES {
	MCGC_HOT = 1,
	MCGC_HASSTATE = 2,
	MCGC_HASSTATEHOT = 3,
	MCGC_TODAY = 4,
};

enum GRIDCELLUPPERSTATES {
	MCGCU_HOT = 1,
	MCGCU_HASSTATE = 2,
	MCGCU_HASSTATEHOT = 3,
};

enum TRAILINGGRIDCELLSTATES {
	MCTGC_HOT = 1,
	MCTGC_HASSTATE = 2,
	MCTGC_HASSTATEHOT = 3,
	MCTGC_TODAY = 4,
};

enum TRAILINGGRIDCELLUPPERSTATES {
	MCTGCU_HOT = 1,
	MCTGCU_HASSTATE = 2,
	MCTGCU_HASSTATEHOT = 3,
};

enum NAVNEXTSTATES {
	MCNN_NORMAL = 1,
	MCNN_HOT = 2,
	MCNN_PRESSED = 3,
	MCNN_DISABLED = 4,
};

enum NAVPREVSTATES {
	MCNP_NORMAL = 1,
	MCNP_HOT = 2,
	MCNP_PRESSED = 3,
	MCNP_DISABLED = 4,
};


//
//  CLOCK class parts and states 
//
#define VSCLASS_CLOCK	L"CLOCK"

enum CLOCKPARTS {
	CLP_TIME = 1,
};

enum CLOCKSTATES {
	CLS_NORMAL = 1,
};


//
//  TRAYNOTIFY class parts and states 
//
#define VSCLASS_TRAYNOTIFY	L"TRAYNOTIFY"

enum TRAYNOTIFYPARTS {
	TNP_BACKGROUND = 1,
	TNP_ANIMBACKGROUND = 2,
};


//
//  TASKBAR class parts and states 
//
#define VSCLASS_TASKBAR	L"TASKBAR"

enum TASKBARPARTS {
	TBP_BACKGROUNDBOTTOM = 1,
	TBP_BACKGROUNDRIGHT = 2,
	TBP_BACKGROUNDTOP = 3,
	TBP_BACKGROUNDLEFT = 4,
	TBP_SIZINGBARBOTTOM = 5,
	TBP_SIZINGBARRIGHT = 6,
	TBP_SIZINGBARTOP = 7,
	TBP_SIZINGBARLEFT = 8,
};


//
//  TASKBAND class parts and states 
//
#define VSCLASS_TASKBAND	L"TASKBAND"

enum TASKBANDPARTS {
	TDP_GROUPCOUNT = 1,
	TDP_FLASHBUTTON = 2,
	TDP_FLASHBUTTONGROUPMENU = 3,
};


//
//  STARTPANEL class parts and states 
//
#define VSCLASS_STARTPANEL	L"STARTPANEL"

enum STARTPANELPARTS {
	SPP_USERPANE = 1,
	SPP_MOREPROGRAMS = 2,
	SPP_MOREPROGRAMSARROW = 3,
	SPP_PROGLIST = 4,
	SPP_PROGLISTSEPARATOR = 5,
	SPP_PLACESLIST = 6,
	SPP_PLACESLISTSEPARATOR = 7,
	SPP_LOGOFF = 8,
	SPP_LOGOFFBUTTONS = 9,
	SPP_USERPICTURE = 10,
	SPP_PREVIEW = 11,
	SPP_MOREPROGRAMSTAB = 12,
	SPP_NSCHOST = 13,
	SPP_SOFTWAREEXPLORER = 14,
	SPP_OPENBOX = 15,
	SPP_SEARCHVIEW = 16,
	SPP_MOREPROGRAMSARROWBACK = 17,
	SPP_TOPMATCH = 18,
	SPP_LOGOFFSPLITBUTTONDROPDOWN = 19,
};

enum MOREPROGRAMSTABSTATES {
	SPMPT_NORMAL = 1,
	SPMPT_HOT = 2,
	SPMPT_SELECTED = 3,
	SPMPT_DISABLED = 4,
	SPMPT_FOCUSED = 5,
};

enum SOFTWAREEXPLORERSTATES {
	SPSE_NORMAL = 1,
	SPSE_HOT = 2,
	SPSE_SELECTED = 3,
	SPSE_DISABLED = 4,
	SPSE_FOCUSED = 5,
};

enum OPENBOXSTATES {
	SPOB_NORMAL = 1,
	SPOB_HOT = 2,
	SPOB_SELECTED = 3,
	SPOB_DISABLED = 4,
	SPOB_FOCUSED = 5,
};

enum MOREPROGRAMSARROWSTATES {
	SPS_NORMAL = 1,
	SPS_HOT = 2,
	SPS_PRESSED = 3,
};

enum MOREPROGRAMSARROWBACKSTATES {
	SPSB_NORMAL = 1,
	SPSB_HOT = 2,
	SPSB_PRESSED = 3,
};

enum LOGOFFBUTTONSSTATES {
	SPLS_NORMAL = 1,
	SPLS_HOT = 2,
	SPLS_PRESSED = 3,
};


//
//  MENUBAND class parts and states 
//
#define VSCLASS_MENUBAND	L"MENUBAND"

enum MENUBANDPARTS {
	MDP_NEWAPPBUTTON = 1,
	MDP_SEPERATOR = 2,
};

enum MENUBANDSTATES {
	MDS_NORMAL = 1,
	MDS_HOT = 2,
	MDS_PRESSED = 3,
	MDS_DISABLED = 4,
	MDS_CHECKED = 5,
	MDS_HOTCHECKED = 6,
};


#endif //__VSSYM32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vpnotify.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//
//--------------------------------------------------------------------------;

#ifndef __IVPNotify__
#define __IVPNotify__

#ifdef __cplusplus
extern "C" {
#endif

// interface IVPBaseNotify
DECLARE_INTERFACE_(IVPBaseNotify, IUnknown)
{
public:
	// this function initializes the reconnection to the decoder. 
	STDMETHOD (RenegotiateVPParameters)(THIS_
					   ) PURE;

};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify, IVPBaseNotify)
{
public:
    // function to set the mode (bob, weave etc)
    STDMETHOD (SetDeinterlaceMode)(THIS_ 
				   IN AMVP_MODE mode
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetDeinterlaceMode)(THIS_ 
				   OUT AMVP_MODE *pMode
				  ) PURE;
};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify2, IVPNotify)
{
public:
// function to set the mode (bob, weave etc)
    STDMETHOD (SetVPSyncMaster)(THIS_ 
				   IN BOOL bVPSyncMaster
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetVPSyncMaster)(THIS_ 
				   OUT BOOL *pbVPSyncMaster
				  ) PURE;

    /*
    // this function sets the directdraw surface that the mixer is supposed to use.
    STDMETHOD (SetDirectDrawSurface)(THIS_ 
				  IN LPDIRECTDRAWSURFACE pDirectDrawSurface
				 ) PURE;

    // this function gets the directdraw surface that the mixer is using
    STDMETHOD (GetDirectDrawSurface)(THIS_ 
				  OUT LPDIRECTDRAWSURFACE *ppDirectDrawSurface
				 ) PURE;

    // this functions sets the color-controls, if the chip supports it.
    STDMETHOD (SetVPColorControls)(THIS_ 
				 IN LPDDCOLORCONTROL pColorControl
				) PURE;

    // this functions also returns the capability of the hardware in the dwFlags
    // value of the struct.
    STDMETHOD (GetVPColorControls)(THIS_ 
				 OUT LPDDCOLORCONTROL *ppColorControl
				) PURE;
    */
};


// interface IVPVBINotify
DECLARE_INTERFACE_(IVPVBINotify, IVPBaseNotify)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPNotify__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vsstyle.h ===
//-------------------------------------------------------------------------//
//  VisualStyle Style Guide symbols
//-------------------------------------------------------------------------//

#ifndef __VSSTYLE_H__
#define __VSSTYLE_H__

//
//  property symbol definitions
//

#define TMTVS_RESERVEDLOW	100000
#define TMTVS_RESERVEDHIGH	19999



//
//  AEROWIZARDSTYLE class parts and states 
//
#define VSCLASS_AEROWIZARDSTYLE	L"AEROWIZARDSTYLE"
#define VSCLASS_AEROWIZARD	L"AEROWIZARD"

enum AEROWIZARDPARTS {
	AW_TITLEBAR = 1,
	AW_HEADERAREA = 2,
	AW_CONTENTAREA = 3,
	AW_COMMANDAREA = 4,
	AW_BUTTON = 5,
};

#define AEROWIZARDSTYLEPARTS AEROWIZARDPARTS;

enum TITLEBARSTATES {
	AW_S_TITLEBAR_ACTIVE = 1,
	AW_S_TITLEBAR_INACTIVE = 2,
};

enum HEADERAREASTATES {
	AW_S_HEADERAREA_NOMARGIN = 1,
};

enum CONTENTAREASTATES {
	AW_S_CONTENTAREA_NOMARGIN = 1,
};


//
//  BUTTONSTYLE class parts and states 
//
#define VSCLASS_BUTTONSTYLE	L"BUTTONSTYLE"
#define VSCLASS_BUTTON	L"BUTTON"

enum BUTTONPARTS {
	BP_PUSHBUTTON = 1,
	BP_RADIOBUTTON = 2,
	BP_CHECKBOX = 3,
	BP_GROUPBOX = 4,
	BP_USERBUTTON = 5,
	BP_COMMANDLINK = 6,
	BP_COMMANDLINKGLYPH = 7,
};

#define BUTTONSTYLEPARTS BUTTONPARTS;

enum PUSHBUTTONSTATES {
	PBS_NORMAL = 1,
	PBS_HOT = 2,
	PBS_PRESSED = 3,
	PBS_DISABLED = 4,
	PBS_DEFAULTED = 5,
	PBS_DEFAULTED_ANIMATING = 6,
};

enum RADIOBUTTONSTATES {
	RBS_UNCHECKEDNORMAL = 1,
	RBS_UNCHECKEDHOT = 2,
	RBS_UNCHECKEDPRESSED = 3,
	RBS_UNCHECKEDDISABLED = 4,
	RBS_CHECKEDNORMAL = 5,
	RBS_CHECKEDHOT = 6,
	RBS_CHECKEDPRESSED = 7,
	RBS_CHECKEDDISABLED = 8,
};

enum CHECKBOXSTATES {
	CBS_UNCHECKEDNORMAL = 1,
	CBS_UNCHECKEDHOT = 2,
	CBS_UNCHECKEDPRESSED = 3,
	CBS_UNCHECKEDDISABLED = 4,
	CBS_CHECKEDNORMAL = 5,
	CBS_CHECKEDHOT = 6,
	CBS_CHECKEDPRESSED = 7,
	CBS_CHECKEDDISABLED = 8,
	CBS_MIXEDNORMAL = 9,
	CBS_MIXEDHOT = 10,
	CBS_MIXEDPRESSED = 11,
	CBS_MIXEDDISABLED = 12,
	CBS_IMPLICITNORMAL = 13,
	CBS_IMPLICITHOT = 14,
	CBS_IMPLICITPRESSED = 15,
	CBS_IMPLICITDISABLED = 16,
	CBS_EXCLUDEDNORMAL = 17,
	CBS_EXCLUDEDHOT = 18,
	CBS_EXCLUDEDPRESSED = 19,
	CBS_EXCLUDEDDISABLED = 20,
};

enum GROUPBOXSTATES {
	GBS_NORMAL = 1,
	GBS_DISABLED = 2,
};

enum COMMANDLINKSTATES {
	CMDLS_NORMAL = 1,
	CMDLS_HOT = 2,
	CMDLS_PRESSED = 3,
	CMDLS_DISABLED = 4,
	CMDLS_DEFAULTED = 5,
	CMDLS_DEFAULTED_ANIMATING = 6,
};

enum COMMANDLINKGLYPHSTATES {
	CMDLGS_NORMAL = 1,
	CMDLGS_HOT = 2,
	CMDLGS_PRESSED = 3,
	CMDLGS_DISABLED = 4,
	CMDLGS_DEFAULTED = 5,
};


//
//  COMBOBOXSTYLE class parts and states 
//
#define VSCLASS_COMBOBOXSTYLE	L"COMBOBOXSTYLE"
#define VSCLASS_COMBOBOX	L"COMBOBOX"

enum COMBOBOXPARTS {
	CP_DROPDOWNBUTTON = 1,
	CP_BACKGROUND = 2,
	CP_TRANSPARENTBACKGROUND = 3,
	CP_BORDER = 4,
	CP_READONLY = 5,
	CP_DROPDOWNBUTTONRIGHT = 6,
	CP_DROPDOWNBUTTONLEFT = 7,
	CP_CUEBANNER = 8,
};

#define COMBOBOXSTYLEPARTS COMBOBOXPARTS;

enum COMBOBOXSTYLESTATES {
	CBXS_NORMAL = 1,
	CBXS_HOT = 2,
	CBXS_PRESSED = 3,
	CBXS_DISABLED = 4,
};

enum DROPDOWNBUTTONRIGHTSTATES {
	CBXSR_NORMAL = 1,
	CBXSR_HOT = 2,
	CBXSR_PRESSED = 3,
	CBXSR_DISABLED = 4,
};

enum DROPDOWNBUTTONLEFTSTATES {
	CBXSL_NORMAL = 1,
	CBXSL_HOT = 2,
	CBXSL_PRESSED = 3,
	CBXSL_DISABLED = 4,
};

enum TRANSPARENTBACKGROUNDSTATES {
	CBTBS_NORMAL = 1,
	CBTBS_HOT = 2,
	CBTBS_DISABLED = 3,
	CBTBS_FOCUSED = 4,
};

enum BORDERSTATES {
	CBB_NORMAL = 1,
	CBB_HOT = 2,
	CBB_FOCUSED = 3,
	CBB_DISABLED = 4,
};

enum READONLYSTATES {
	CBRO_NORMAL = 1,
	CBRO_HOT = 2,
	CBRO_PRESSED = 3,
	CBRO_DISABLED = 4,
};

enum CUEBANNERSTATES {
	CBCB_NORMAL = 1,
	CBCB_HOT = 2,
	CBCB_PRESSED = 3,
	CBCB_DISABLED = 4,
};


//
//  COMMUNICATIONSSTYLE class parts and states 
//
#define VSCLASS_COMMUNICATIONSSTYLE	L"COMMUNICATIONSSTYLE"
#define VSCLASS_COMMUNICATIONS	L"COMMUNICATIONS"

enum COMMUNICATIONSPARTS {
	CSST_TAB = 1,
};

#define COMMUNICATIONSSTYLEPARTS COMMUNICATIONSPARTS;

enum TABSTATES {
	CSTB_NORMAL = 1,
	CSTB_HOT = 2,
	CSTB_SELECTED = 3,
};


//
//  CONTROLPANELSTYLE class parts and states 
//
#define VSCLASS_CONTROLPANELSTYLE	L"CONTROLPANELSTYLE"
#define VSCLASS_CONTROLPANEL	L"CONTROLPANEL"

enum CONTROLPANELPARTS {
	CPANEL_NAVIGATIONPANE = 1,
	CPANEL_CONTENTPANE = 2,
	CPANEL_NAVIGATIONPANELABEL = 3,
	CPANEL_CONTENTPANELABEL = 4,
	CPANEL_TITLE = 5,
	CPANEL_BODYTEXT = 6,
	CPANEL_HELPLINK = 7,
	CPANEL_TASKLINK = 8,
	CPANEL_GROUPTEXT = 9,
	CPANEL_CONTENTLINK = 10,
	CPANEL_SECTIONTITLELINK = 11,
	CPANEL_LARGECOMMANDAREA = 12,
	CPANEL_SMALLCOMMANDAREA = 13,
	CPANEL_BUTTON = 14,
	CPANEL_MESSAGETEXT = 15,
	CPANEL_NAVIGATIONPANELINE = 16,
	CPANEL_CONTENTPANELINE = 17,
	CPANEL_BANNERAREA = 18,
	CPANEL_BODYTITLE = 19,
};

#define CONTROLPANELSTYLEPARTS CONTROLPANELPARTS;

enum HELPLINKSTATES {
	CPHL_NORMAL = 1,
	CPHL_HOT = 2,
	CPHL_PRESSED = 3,
	CPHL_DISABLED = 4,
};

enum TASKLINKSTATES {
	CPTL_NORMAL = 1,
	CPTL_HOT = 2,
	CPTL_PRESSED = 3,
	CPTL_DISABLED = 4,
	CPTL_PAGE = 5,
};

enum CONTENTLINKSTATES {
	CPCL_NORMAL = 1,
	CPCL_HOT = 2,
	CPCL_PRESSED = 3,
	CPCL_DISABLED = 4,
};

enum SECTIONTITLELINKSTATES {
	CPSTL_NORMAL = 1,
	CPSTL_HOT = 2,
};


//
//  DATEPICKERSTYLE class parts and states 
//
#define VSCLASS_DATEPICKERSTYLE	L"DATEPICKERSTYLE"
#define VSCLASS_DATEPICKER	L"DATEPICKER"

enum DATEPICKERPARTS {
	DP_DATETEXT = 1,
	DP_DATEBORDER = 2,
	DP_SHOWCALENDARBUTTONRIGHT = 3,
};

#define DATEPICKERSTYLEPARTS DATEPICKERPARTS;

enum DATETEXTSTATES {
	DPDT_NORMAL = 1,
	DPDT_DISABLED = 2,
	DPDT_SELECTED = 3,
};

enum DATEBORDERSTATES {
	DPDB_NORMAL = 1,
	DPDB_HOT = 2,
	DPDB_FOCUSED = 3,
	DPDB_DISABLED = 4,
};

enum SHOWCALENDARBUTTONRIGHTSTATES {
	DPSCBR_NORMAL = 1,
	DPSCBR_HOT = 2,
	DPSCBR_PRESSED = 3,
	DPSCBR_DISABLED = 4,
};


//
//  DRAGDROPSTYLE class parts and states 
//
#define VSCLASS_DRAGDROPSTYLE	L"DRAGDROPSTYLE"
#define VSCLASS_DRAGDROP	L"DRAGDROP"

enum DRAGDROPPARTS {
	DD_COPY = 1,
	DD_MOVE = 2,
	DD_UPDATEMETADATA = 3,
	DD_CREATELINK = 4,
	DD_WARNING = 5,
	DD_NONE = 6,
	DD_IMAGEBG = 7,
	DD_TEXTBG = 8,
};

#define DRAGDROPSTYLEPARTS DRAGDROPPARTS;

enum COPYSTATES {
	DDCOPY_HIGHLIGHT = 1,
	DDCOPY_NOHIGHLIGHT = 2,
};

enum MOVESTATES {
	DDMOVE_HIGHLIGHT = 1,
	DDMOVE_NOHIGHLIGHT = 2,
};

enum UPDATEMETADATASTATES {
	DDUPDATEMETADATA_HIGHLIGHT = 1,
	DDUPDATEMETADATA_NOHIGHLIGHT = 2,
};

enum CREATELINKSTATES {
	DDCREATELINK_HIGHLIGHT = 1,
	DDCREATELINK_NOHIGHLIGHT = 2,
};

enum WARNINGSTATES {
	DDWARNING_HIGHLIGHT = 1,
	DDWARNING_NOHIGHLIGHT = 2,
};

enum NONESTATES {
	DDNONE_HIGHLIGHT = 1,
	DDNONE_NOHIGHLIGHT = 2,
};


//
//  EDITSTYLE class parts and states 
//
#define VSCLASS_EDITSTYLE	L"EDITSTYLE"
#define VSCLASS_EDIT	L"EDIT"

enum EDITPARTS {
	EP_EDITTEXT = 1,
	EP_CARET = 2,
	EP_BACKGROUND = 3,
	EP_PASSWORD = 4,
	EP_BACKGROUNDWITHBORDER = 5,
	EP_EDITBORDER_NOSCROLL = 6,
	EP_EDITBORDER_HSCROLL = 7,
	EP_EDITBORDER_VSCROLL = 8,
	EP_EDITBORDER_HVSCROLL = 9,
};

#define EDITSTYLEPARTS EDITPARTS;

enum EDITTEXTSTATES {
	ETS_NORMAL = 1,
	ETS_HOT = 2,
	ETS_SELECTED = 3,
	ETS_DISABLED = 4,
	ETS_FOCUSED = 5,
	ETS_READONLY = 6,
	ETS_ASSIST = 7,
	ETS_CUEBANNER = 8,
};

enum BACKGROUNDSTATES {
	EBS_NORMAL = 1,
	EBS_HOT = 2,
	EBS_DISABLED = 3,
	EBS_FOCUSED = 4,
	EBS_READONLY = 5,
	EBS_ASSIST = 6,
};

enum BACKGROUNDWITHBORDERSTATES {
	EBWBS_NORMAL = 1,
	EBWBS_HOT = 2,
	EBWBS_DISABLED = 3,
	EBWBS_FOCUSED = 4,
};

enum EDITBORDER_NOSCROLLSTATES {
	EPSN_NORMAL = 1,
	EPSN_HOT = 2,
	EPSN_FOCUSED = 3,
	EPSN_DISABLED = 4,
};

enum EDITBORDER_HSCROLLSTATES {
	EPSH_NORMAL = 1,
	EPSH_HOT = 2,
	EPSH_FOCUSED = 3,
	EPSH_DISABLED = 4,
};

enum EDITBORDER_VSCROLLSTATES {
	EPSV_NORMAL = 1,
	EPSV_HOT = 2,
	EPSV_FOCUSED = 3,
	EPSV_DISABLED = 4,
};

enum EDITBORDER_HVSCROLLSTATES {
	EPSHV_NORMAL = 1,
	EPSHV_HOT = 2,
	EPSHV_FOCUSED = 3,
	EPSHV_DISABLED = 4,
};


//
//  EXPLORERBARSTYLE class parts and states 
//
#define VSCLASS_EXPLORERBARSTYLE	L"EXPLORERBARSTYLE"
#define VSCLASS_EXPLORERBAR	L"EXPLORERBAR"

enum EXPLORERBARPARTS {
	EBP_HEADERBACKGROUND = 1,
	EBP_HEADERCLOSE = 2,
	EBP_HEADERPIN = 3,
	EBP_IEBARMENU = 4,
	EBP_NORMALGROUPBACKGROUND = 5,
	EBP_NORMALGROUPCOLLAPSE = 6,
	EBP_NORMALGROUPEXPAND = 7,
	EBP_NORMALGROUPHEAD = 8,
	EBP_SPECIALGROUPBACKGROUND = 9,
	EBP_SPECIALGROUPCOLLAPSE = 10,
	EBP_SPECIALGROUPEXPAND = 11,
	EBP_SPECIALGROUPHEAD = 12,
};

#define EXPLORERBARSTYLEPARTS EXPLORERBARPARTS;

enum HEADERCLOSESTATES {
	EBHC_NORMAL = 1,
	EBHC_HOT = 2,
	EBHC_PRESSED = 3,
};

enum HEADERPINSTATES {
	EBHP_NORMAL = 1,
	EBHP_HOT = 2,
	EBHP_PRESSED = 3,
	EBHP_SELECTEDNORMAL = 4,
	EBHP_SELECTEDHOT = 5,
	EBHP_SELECTEDPRESSED = 6,
};

enum IEBARMENUSTATES {
	EBM_NORMAL = 1,
	EBM_HOT = 2,
	EBM_PRESSED = 3,
};

enum NORMALGROUPCOLLAPSESTATES {
	EBNGC_NORMAL = 1,
	EBNGC_HOT = 2,
	EBNGC_PRESSED = 3,
};

enum NORMALGROUPEXPANDSTATES {
	EBNGE_NORMAL = 1,
	EBNGE_HOT = 2,
	EBNGE_PRESSED = 3,
};

enum SPECIALGROUPCOLLAPSESTATES {
	EBSGC_NORMAL = 1,
	EBSGC_HOT = 2,
	EBSGC_PRESSED = 3,
};

enum SPECIALGROUPEXPANDSTATES {
	EBSGE_NORMAL = 1,
	EBSGE_HOT = 2,
	EBSGE_PRESSED = 3,
};


//
//  FLYOUTSTYLE class parts and states 
//
#define VSCLASS_FLYOUTSTYLE	L"FLYOUTSTYLE"
#define VSCLASS_FLYOUT	L"FLYOUT"

enum FLYOUTPARTS {
	FLYOUT_HEADER = 1,
	FLYOUT_BODY = 2,
	FLYOUT_LABEL = 3,
	FLYOUT_LINK = 4,
	FLYOUT_DIVIDER = 5,
	FLYOUT_WINDOW = 6,
	FLYOUT_LINKAREA = 7,
	FLYOUT_LINKHEADER = 8,
};

#define FLYOUTSTYLEPARTS FLYOUTPARTS;

enum LABELSTATES {
	FLS_NORMAL = 1,
	FLS_SELECTED = 2,
	FLS_EMPHASIZED = 3,
	FLS_DISABLED = 4,
};

enum LINKSTATES {
	FLYOUTLINK_NORMAL = 1,
	FLYOUTLINK_HOVER = 2,
};

enum BODYSTATES {
	FBS_NORMAL = 1,
	FBS_EMPHASIZED = 2,
};

enum LINKHEADERSTATES {
	FLH_NORMAL = 1,
	FLH_HOVER = 2,
};


//
//  HEADERSTYLE class parts and states 
//
#define VSCLASS_HEADERSTYLE	L"HEADERSTYLE"
#define VSCLASS_HEADER	L"HEADER"

enum HEADERPARTS {
	HP_HEADERITEM = 1,
	HP_HEADERITEMLEFT = 2,
	HP_HEADERITEMRIGHT = 3,
	HP_HEADERSORTARROW = 4,
	HP_HEADERDROPDOWN = 5,
	HP_HEADERDROPDOWNFILTER = 6,
	HP_HEADEROVERFLOW = 7,
};

#define HEADERSTYLEPARTS HEADERPARTS;

enum HEADERSTYLESTATES {
	HBG_DETAILS = 1,
	HBG_ICON = 2,
};

enum HEADERITEMSTATES {
	HIS_NORMAL = 1,
	HIS_HOT = 2,
	HIS_PRESSED = 3,
	HIS_SORTEDNORMAL = 4,
	HIS_SORTEDHOT = 5,
	HIS_SORTEDPRESSED = 6,
	HIS_ICONNORMAL = 7,
	HIS_ICONHOT = 8,
	HIS_ICONPRESSED = 9,
	HIS_ICONSORTEDNORMAL = 10,
	HIS_ICONSORTEDHOT = 11,
	HIS_ICONSORTEDPRESSED = 12,
};

enum HEADERITEMLEFTSTATES {
	HILS_NORMAL = 1,
	HILS_HOT = 2,
	HILS_PRESSED = 3,
};

enum HEADERITEMRIGHTSTATES {
	HIRS_NORMAL = 1,
	HIRS_HOT = 2,
	HIRS_PRESSED = 3,
};

enum HEADERSORTARROWSTATES {
	HSAS_SORTEDUP = 1,
	HSAS_SORTEDDOWN = 2,
};

enum HEADERDROPDOWNSTATES {
	HDDS_NORMAL = 1,
	HDDS_SOFTHOT = 2,
	HDDS_HOT = 3,
};

enum HEADERDROPDOWNFILTERSTATES {
	HDDFS_NORMAL = 1,
	HDDFS_SOFTHOT = 2,
	HDDFS_HOT = 3,
};

enum HEADEROVERFLOWSTATES {
	HOFS_NORMAL = 1,
	HOFS_HOT = 2,
};


//
//  LISTBOXSTYLE class parts and states 
//
#define VSCLASS_LISTBOXSTYLE	L"LISTBOXSTYLE"
#define VSCLASS_LISTBOX	L"LISTBOX"

enum LISTBOXPARTS {
	LBCP_BORDER_HSCROLL = 1,
	LBCP_BORDER_HVSCROLL = 2,
	LBCP_BORDER_NOSCROLL = 3,
	LBCP_BORDER_VSCROLL = 4,
	LBCP_ITEM = 5,
};

#define LISTBOXSTYLEPARTS LISTBOXPARTS;

enum BORDER_HSCROLLSTATES {
	LBPSH_NORMAL = 1,
	LBPSH_FOCUSED = 2,
	LBPSH_HOT = 3,
	LBPSH_DISABLED = 4,
};

enum BORDER_HVSCROLLSTATES {
	LBPSHV_NORMAL = 1,
	LBPSHV_FOCUSED = 2,
	LBPSHV_HOT = 3,
	LBPSHV_DISABLED = 4,
};

enum BORDER_NOSCROLLSTATES {
	LBPSN_NORMAL = 1,
	LBPSN_FOCUSED = 2,
	LBPSN_HOT = 3,
	LBPSN_DISABLED = 4,
};

enum BORDER_VSCROLLSTATES {
	LBPSV_NORMAL = 1,
	LBPSV_FOCUSED = 2,
	LBPSV_HOT = 3,
	LBPSV_DISABLED = 4,
};

enum ITEMSTATES {
	LBPSI_HOT = 1,
	LBPSI_HOTSELECTED = 2,
	LBPSI_SELECTED = 3,
	LBPSI_SELECTEDNOTFOCUS = 4,
};


//
//  LISTVIEWSTYLE class parts and states 
//
#define VSCLASS_LISTVIEWSTYLE	L"LISTVIEWSTYLE"
#define VSCLASS_LISTVIEW	L"LISTVIEW"

enum LISTVIEWPARTS {
	LVP_LISTITEM = 1,
	LVP_LISTGROUP = 2,
	LVP_LISTDETAIL = 3,
	LVP_LISTSORTEDDETAIL = 4,
	LVP_EMPTYTEXT = 5,
	LVP_GROUPHEADER = 6,
	LVP_GROUPHEADERLINE = 7,
	LVP_EXPANDBUTTON = 8,
	LVP_COLLAPSEBUTTON = 9,
	LVP_COLUMNDETAIL = 10,
};

#define LISTVIEWSTYLEPARTS LISTVIEWPARTS;

enum LISTITEMSTATES {
	LISS_NORMAL = 1,
	LISS_HOT = 2,
	LISS_SELECTED = 3,
	LISS_DISABLED = 4,
	LISS_SELECTEDNOTFOCUS = 5,
	LISS_HOTSELECTED = 6,
};

enum GROUPHEADERSTATES {
	LVGH_OPEN = 1,
	LVGH_OPENHOT = 2,
	LVGH_OPENSELECTED = 3,
	LVGH_OPENSELECTEDHOT = 4,
	LVGH_OPENSELECTEDNOTFOCUSED = 5,
	LVGH_OPENSELECTEDNOTFOCUSEDHOT = 6,
	LVGH_OPENMIXEDSELECTION = 7,
	LVGH_OPENMIXEDSELECTIONHOT = 8,
	LVGH_CLOSE = 9,
	LVGH_CLOSEHOT = 10,
	LVGH_CLOSESELECTED = 11,
	LVGH_CLOSESELECTEDHOT = 12,
	LVGH_CLOSESELECTEDNOTFOCUSED = 13,
	LVGH_CLOSESELECTEDNOTFOCUSEDHOT = 14,
	LVGH_CLOSEMIXEDSELECTION = 15,
	LVGH_CLOSEMIXEDSELECTIONHOT = 16,
};

enum GROUPHEADERLINESTATES {
	LVGHL_OPEN = 1,
	LVGHL_OPENHOT = 2,
	LVGHL_OPENSELECTED = 3,
	LVGHL_OPENSELECTEDHOT = 4,
	LVGHL_OPENSELECTEDNOTFOCUSED = 5,
	LVGHL_OPENSELECTEDNOTFOCUSEDHOT = 6,
	LVGHL_OPENMIXEDSELECTION = 7,
	LVGHL_OPENMIXEDSELECTIONHOT = 8,
	LVGHL_CLOSE = 9,
	LVGHL_CLOSEHOT = 10,
	LVGHL_CLOSESELECTED = 11,
	LVGHL_CLOSESELECTEDHOT = 12,
	LVGHL_CLOSESELECTEDNOTFOCUSED = 13,
	LVGHL_CLOSESELECTEDNOTFOCUSEDHOT = 14,
	LVGHL_CLOSEMIXEDSELECTION = 15,
	LVGHL_CLOSEMIXEDSELECTIONHOT = 16,
};

enum EXPANDBUTTONSTATES {
	LVEB_NORMAL = 1,
	LVEB_HOVER = 2,
	LVEB_PUSHED = 3,
};

enum COLLAPSEBUTTONSTATES {
	LVCB_NORMAL = 1,
	LVCB_HOVER = 2,
	LVCB_PUSHED = 3,
};


//
//  MENUSTYLE class parts and states 
//
#define VSCLASS_MENUSTYLE	L"MENUSTYLE"
#define VSCLASS_MENU	L"MENU"

enum MENUPARTS {
	MENU_MENUITEM_TMSCHEMA = 1,
	MENU_MENUDROPDOWN_TMSCHEMA = 2,
	MENU_MENUBARITEM_TMSCHEMA = 3,
	MENU_MENUBARDROPDOWN_TMSCHEMA = 4,
	MENU_CHEVRON_TMSCHEMA = 5,
	MENU_SEPARATOR_TMSCHEMA = 6,
	MENU_BARBACKGROUND = 7,
	MENU_BARITEM = 8,
	MENU_POPUPBACKGROUND = 9,
	MENU_POPUPBORDERS = 10,
	MENU_POPUPCHECK = 11,
	MENU_POPUPCHECKBACKGROUND = 12,
	MENU_POPUPGUTTER = 13,
	MENU_POPUPITEM = 14,
	MENU_POPUPSEPARATOR = 15,
	MENU_POPUPSUBMENU = 16,
	MENU_SYSTEMCLOSE = 17,
	MENU_SYSTEMMAXIMIZE = 18,
	MENU_SYSTEMMINIMIZE = 19,
	MENU_SYSTEMRESTORE = 20,
};

#define MENUSTYLEPARTS MENUPARTS;

enum BARBACKGROUNDSTATES {
	MB_ACTIVE = 1,
	MB_INACTIVE = 2,
};

enum BARITEMSTATES {
	MBI_NORMAL = 1,
	MBI_HOT = 2,
	MBI_PUSHED = 3,
	MBI_DISABLED = 4,
	MBI_DISABLEDHOT = 5,
	MBI_DISABLEDPUSHED = 6,
};

enum POPUPCHECKSTATES {
	MC_CHECKMARKNORMAL = 1,
	MC_CHECKMARKDISABLED = 2,
	MC_BULLETNORMAL = 3,
	MC_BULLETDISABLED = 4,
};

enum POPUPCHECKBACKGROUNDSTATES {
	MCB_DISABLED = 1,
	MCB_NORMAL = 2,
	MCB_BITMAP = 3,
};

enum POPUPITEMSTATES {
	MPI_NORMAL = 1,
	MPI_HOT = 2,
	MPI_DISABLED = 3,
	MPI_DISABLEDHOT = 4,
};

enum POPUPSUBMENUSTATES {
	MSM_NORMAL = 1,
	MSM_DISABLED = 2,
};

enum SYSTEMCLOSESTATES {
	MSYSC_NORMAL = 1,
	MSYSC_DISABLED = 2,
};

enum SYSTEMMAXIMIZESTATES {
	MSYSMX_NORMAL = 1,
	MSYSMX_DISABLED = 2,
};

enum SYSTEMMINIMIZESTATES {
	MSYSMN_NORMAL = 1,
	MSYSMN_DISABLED = 2,
};

enum SYSTEMRESTORESTATES {
	MSYSR_NORMAL = 1,
	MSYSR_DISABLED = 2,
};


//
//  NAVIGATION class parts and states 
//
#define VSCLASS_NAVIGATION	L"NAVIGATION"

enum NAVIGATIONPARTS {
	NAV_BACKBUTTON = 1,
	NAV_FORWARDBUTTON = 2,
	NAV_MENUBUTTON = 3,
};

enum NAV_BACKBUTTONSTATES {
	NAV_BB_NORMAL = 1,
	NAV_BB_HOT = 2,
	NAV_BB_PRESSED = 3,
	NAV_BB_DISABLED = 4,
};

enum NAV_FORWARDBUTTONSTATES {
	NAV_FB_NORMAL = 1,
	NAV_FB_HOT = 2,
	NAV_FB_PRESSED = 3,
	NAV_FB_DISABLED = 4,
};

enum NAV_MENUBUTTONSTATES {
	NAV_MB_NORMAL = 1,
	NAV_MB_HOT = 2,
	NAV_MB_PRESSED = 3,
	NAV_MB_DISABLED = 4,
};


//
//  PROGRESSSTYLE class parts and states 
//
#define VSCLASS_PROGRESSSTYLE	L"PROGRESSSTYLE"
#define VSCLASS_PROGRESS	L"PROGRESS"

enum PROGRESSPARTS {
	PP_BAR = 1,
	PP_BARVERT = 2,
	PP_CHUNK = 3,
	PP_CHUNKVERT = 4,
	PP_FILL = 5,
	PP_FILLVERT = 6,
	PP_PULSEOVERLAY = 7,
	PP_MOVEOVERLAY = 8,
	PP_PULSEOVERLAYVERT = 9,
	PP_MOVEOVERLAYVERT = 10,
	PP_TRANSPARENTBAR = 11,
	PP_TRANSPARENTBARVERT = 12,
};

#define PROGRESSSTYLEPARTS PROGRESSPARTS;

enum TRANSPARENTBARSTATES {
	PBBS_NORMAL = 1,
	PBBS_PARTIAL = 2,
};

enum TRANSPARENTBARVERTSTATES {
	PBBVS_NORMAL = 1,
	PBBVS_PARTIAL = 2,
};

enum FILLSTATES {
	PBFS_NORMAL = 1,
	PBFS_ERROR = 2,
	PBFS_PAUSED = 3,
	PBFS_PARTIAL = 4,
};

enum FILLVERTSTATES {
	PBFVS_NORMAL = 1,
	PBFVS_ERROR = 2,
	PBFVS_PAUSED = 3,
	PBFVS_PARTIAL = 4,
};


//
//  REBARSTYLE class parts and states 
//
#define VSCLASS_REBARSTYLE	L"REBARSTYLE"
#define VSCLASS_REBAR	L"REBAR"

enum REBARPARTS {
	RP_GRIPPER = 1,
	RP_GRIPPERVERT = 2,
	RP_BAND = 3,
	RP_CHEVRON = 4,
	RP_CHEVRONVERT = 5,
	RP_BACKGROUND = 6,
	RP_SPLITTER = 7,
	RP_SPLITTERVERT = 8,
};

#define REBARSTYLEPARTS REBARPARTS;

enum CHEVRONSTATES {
	CHEVS_NORMAL = 1,
	CHEVS_HOT = 2,
	CHEVS_PRESSED = 3,
};

enum CHEVRONVERTSTATES {
	CHEVSV_NORMAL = 1,
	CHEVSV_HOT = 2,
	CHEVSV_PRESSED = 3,
};

enum SPLITTERSTATES {
	SPLITS_NORMAL = 1,
	SPLITS_HOT = 2,
	SPLITS_PRESSED = 3,
};

enum SPLITTERVERTSTATES {
	SPLITSV_NORMAL = 1,
	SPLITSV_HOT = 2,
	SPLITSV_PRESSED = 3,
};


//
//  SCROLLBARSTYLE class parts and states 
//
#define VSCLASS_SCROLLBARSTYLE	L"SCROLLBARSTYLE"
#define VSCLASS_SCROLLBAR	L"SCROLLBAR"

enum SCROLLBARPARTS {
	SBP_ARROWBTN = 1,
	SBP_THUMBBTNHORZ = 2,
	SBP_THUMBBTNVERT = 3,
	SBP_LOWERTRACKHORZ = 4,
	SBP_UPPERTRACKHORZ = 5,
	SBP_LOWERTRACKVERT = 6,
	SBP_UPPERTRACKVERT = 7,
	SBP_GRIPPERHORZ = 8,
	SBP_GRIPPERVERT = 9,
	SBP_SIZEBOX = 10,
};

#define SCROLLBARSTYLEPARTS SCROLLBARPARTS;

enum ARROWBTNSTATES {
	ABS_UPNORMAL = 1,
	ABS_UPHOT = 2,
	ABS_UPPRESSED = 3,
	ABS_UPDISABLED = 4,
	ABS_DOWNNORMAL = 5,
	ABS_DOWNHOT = 6,
	ABS_DOWNPRESSED = 7,
	ABS_DOWNDISABLED = 8,
	ABS_LEFTNORMAL = 9,
	ABS_LEFTHOT = 10,
	ABS_LEFTPRESSED = 11,
	ABS_LEFTDISABLED = 12,
	ABS_RIGHTNORMAL = 13,
	ABS_RIGHTHOT = 14,
	ABS_RIGHTPRESSED = 15,
	ABS_RIGHTDISABLED = 16,
	ABS_UPHOVER = 17,
	ABS_DOWNHOVER = 18,
	ABS_LEFTHOVER = 19,
	ABS_RIGHTHOVER = 20,
};

enum SCROLLBARSTYLESTATES {
	SCRBS_NORMAL = 1,
	SCRBS_HOT = 2,
	SCRBS_PRESSED = 3,
	SCRBS_DISABLED = 4,
	SCRBS_HOVER = 5,
};

enum SIZEBOXSTATES {
	SZB_RIGHTALIGN = 1,
	SZB_LEFTALIGN = 2,
	SZB_TOPRIGHTALIGN = 3,
	SZB_TOPLEFTALIGN = 4,
	SZB_HALFBOTTOMRIGHTALIGN = 5,
	SZB_HALFBOTTOMLEFTALIGN = 6,
	SZB_HALFTOPRIGHTALIGN = 7,
	SZB_HALFTOPLEFTALIGN = 8,
};


//
//  SPINSTYLE class parts and states 
//
#define VSCLASS_SPINSTYLE	L"SPINSTYLE"
#define VSCLASS_SPIN	L"SPIN"

enum SPINPARTS {
	SPNP_UP = 1,
	SPNP_DOWN = 2,
	SPNP_UPHORZ = 3,
	SPNP_DOWNHORZ = 4,
};

#define SPINSTYLEPARTS SPINPARTS;

enum UPSTATES {
	UPS_NORMAL = 1,
	UPS_HOT = 2,
	UPS_PRESSED = 3,
	UPS_DISABLED = 4,
};

enum DOWNSTATES {
	DNS_NORMAL = 1,
	DNS_HOT = 2,
	DNS_PRESSED = 3,
	DNS_DISABLED = 4,
};

enum UPHORZSTATES {
	UPHZS_NORMAL = 1,
	UPHZS_HOT = 2,
	UPHZS_PRESSED = 3,
	UPHZS_DISABLED = 4,
};

enum DOWNHORZSTATES {
	DNHZS_NORMAL = 1,
	DNHZS_HOT = 2,
	DNHZS_PRESSED = 3,
	DNHZS_DISABLED = 4,
};


//
//  STATUSSTYLE class parts and states 
//
#define VSCLASS_STATUSSTYLE	L"STATUSSTYLE"
#define VSCLASS_STATUS	L"STATUS"

enum STATUSPARTS {
	SP_PANE = 1,
	SP_GRIPPERPANE = 2,
	SP_GRIPPER = 3,
};

#define STATUSSTYLEPARTS STATUSPARTS;


//
//  TABSTYLE class parts and states 
//
#define VSCLASS_TABSTYLE	L"TABSTYLE"
#define VSCLASS_TAB	L"TAB"

enum TABPARTS {
	TABP_TABITEM = 1,
	TABP_TABITEMLEFTEDGE = 2,
	TABP_TABITEMRIGHTEDGE = 3,
	TABP_TABITEMBOTHEDGE = 4,
	TABP_TOPTABITEM = 5,
	TABP_TOPTABITEMLEFTEDGE = 6,
	TABP_TOPTABITEMRIGHTEDGE = 7,
	TABP_TOPTABITEMBOTHEDGE = 8,
	TABP_PANE = 9,
	TABP_BODY = 10,
	TABP_AEROWIZARDBODY = 11,
};

#define TABSTYLEPARTS TABPARTS;

enum TABITEMSTATES {
	TIS_NORMAL = 1,
	TIS_HOT = 2,
	TIS_SELECTED = 3,
	TIS_DISABLED = 4,
	TIS_FOCUSED = 5,
};

enum TABITEMLEFTEDGESTATES {
	TILES_NORMAL = 1,
	TILES_HOT = 2,
	TILES_SELECTED = 3,
	TILES_DISABLED = 4,
	TILES_FOCUSED = 5,
};

enum TABITEMRIGHTEDGESTATES {
	TIRES_NORMAL = 1,
	TIRES_HOT = 2,
	TIRES_SELECTED = 3,
	TIRES_DISABLED = 4,
	TIRES_FOCUSED = 5,
};

enum TABITEMBOTHEDGESTATES {
	TIBES_NORMAL = 1,
	TIBES_HOT = 2,
	TIBES_SELECTED = 3,
	TIBES_DISABLED = 4,
	TIBES_FOCUSED = 5,
};

enum TOPTABITEMSTATES {
	TTIS_NORMAL = 1,
	TTIS_HOT = 2,
	TTIS_SELECTED = 3,
	TTIS_DISABLED = 4,
	TTIS_FOCUSED = 5,
};

enum TOPTABITEMLEFTEDGESTATES {
	TTILES_NORMAL = 1,
	TTILES_HOT = 2,
	TTILES_SELECTED = 3,
	TTILES_DISABLED = 4,
	TTILES_FOCUSED = 5,
};

enum TOPTABITEMRIGHTEDGESTATES {
	TTIRES_NORMAL = 1,
	TTIRES_HOT = 2,
	TTIRES_SELECTED = 3,
	TTIRES_DISABLED = 4,
	TTIRES_FOCUSED = 5,
};

enum TOPTABITEMBOTHEDGESTATES {
	TTIBES_NORMAL = 1,
	TTIBES_HOT = 2,
	TTIBES_SELECTED = 3,
	TTIBES_DISABLED = 4,
	TTIBES_FOCUSED = 5,
};


//
//  TASKDIALOGSTYLE class parts and states 
//
#define VSCLASS_TASKDIALOGSTYLE	L"TASKDIALOGSTYLE"
#define VSCLASS_TASKDIALOG	L"TASKDIALOG"

enum TASKDIALOGPARTS {
	TDLG_PRIMARYPANEL = 1,
	TDLG_MAININSTRUCTIONPANE = 2,
	TDLG_MAINICON = 3,
	TDLG_CONTENTPANE = 4,
	TDLG_CONTENTICON = 5,
	TDLG_EXPANDEDCONTENT = 6,
	TDLG_COMMANDLINKPANE = 7,
	TDLG_SECONDARYPANEL = 8,
	TDLG_CONTROLPANE = 9,
	TDLG_BUTTONSECTION = 10,
	TDLG_BUTTONWRAPPER = 11,
	TDLG_EXPANDOTEXT = 12,
	TDLG_EXPANDOBUTTON = 13,
	TDLG_VERIFICATIONTEXT = 14,
	TDLG_FOOTNOTEPANE = 15,
	TDLG_FOOTNOTEAREA = 16,
	TDLG_FOOTNOTESEPARATOR = 17,
	TDLG_EXPANDEDFOOTERAREA = 18,
	TDLG_PROGRESSBAR = 19,
	TDLG_IMAGEALIGNMENT = 20,
	TDLG_RADIOBUTTONPANE = 21,
};

#define TASKDIALOGSTYLEPARTS TASKDIALOGPARTS;

enum CONTENTPANESTATES {
	TDLGCPS_STANDALONE = 1,
};

enum EXPANDOBUTTONSTATES {
	TDLGEBS_NORMAL = 1,
	TDLGEBS_HOVER = 2,
	TDLGEBS_PRESSED = 3,
	TDLGEBS_EXPANDEDNORMAL = 4,
	TDLGEBS_EXPANDEDHOVER = 5,
	TDLGEBS_EXPANDEDPRESSED = 6,
};


//
//  TEXTSTYLE class parts and states 
//
#define VSCLASS_TEXTSTYLE	L"TEXTSTYLE"

enum TEXTSTYLEPARTS {
	TEXT_MAININSTRUCTION = 1,
	TEXT_INSTRUCTION = 2,
	TEXT_BODYTITLE = 3,
	TEXT_BODYTEXT = 4,
	TEXT_SECONDARYTEXT = 5,
	TEXT_HYPERLINKTEXT = 6,
	TEXT_EXPANDED = 7,
	TEXT_LABEL = 8,
	TEXT_CONTROLLABEL = 9,
};

enum HYPERLINKTEXTSTATES {
	TS_HYPERLINK_NORMAL = 1,
	TS_HYPERLINK_HOT = 2,
	TS_HYPERLINK_PRESSED = 3,
	TS_HYPERLINK_DISABLED = 4,
};

enum CONTROLLABELSTATES {
	TS_CONTROLLABEL_NORMAL = 1,
	TS_CONTROLLABEL_DISABLED = 2,
};


//
//  TOOLBARSTYLE class parts and states 
//
#define VSCLASS_TOOLBARSTYLE	L"TOOLBARSTYLE"
#define VSCLASS_TOOLBAR	L"TOOLBAR"

enum TOOLBARPARTS {
	TP_BUTTON = 1,
	TP_DROPDOWNBUTTON = 2,
	TP_SPLITBUTTON = 3,
	TP_SPLITBUTTONDROPDOWN = 4,
	TP_SEPARATOR = 5,
	TP_SEPARATORVERT = 6,
};

#define TOOLBARSTYLEPARTS TOOLBARPARTS;

enum TOOLBARSTYLESTATES {
	TS_NORMAL = 1,
	TS_HOT = 2,
	TS_PRESSED = 3,
	TS_DISABLED = 4,
	TS_CHECKED = 5,
	TS_HOTCHECKED = 6,
	TS_NEARHOT = 7,
	TS_OTHERSIDEHOT = 8,
};


//
//  TOOLTIPSTYLE class parts and states 
//
#define VSCLASS_TOOLTIPSTYLE	L"TOOLTIPSTYLE"
#define VSCLASS_TOOLTIP	L"TOOLTIP"

enum TOOLTIPPARTS {
	TTP_STANDARD = 1,
	TTP_STANDARDTITLE = 2,
	TTP_BALLOON = 3,
	TTP_BALLOONTITLE = 4,
	TTP_CLOSE = 5,
	TTP_BALLOONSTEM = 6,
};

#define TOOLTIPSTYLEPARTS TOOLTIPPARTS;

enum CLOSESTATES {
	TTCS_NORMAL = 1,
	TTCS_HOT = 2,
	TTCS_PRESSED = 3,
};

enum STANDARDSTATES {
	TTSS_NORMAL = 1,
	TTSS_LINK = 2,
};

enum BALLOONSTATES {
	TTBS_NORMAL = 1,
	TTBS_LINK = 2,
};

enum BALLOONSTEMSTATES {
	TTBSS_POINTINGUPLEFTWALL = 1,
	TTBSS_POINTINGUPCENTERED = 2,
	TTBSS_POINTINGUPRIGHTWALL = 3,
	TTBSS_POINTINGDOWNRIGHTWALL = 4,
	TTBSS_POINTINGDOWNCENTERED = 5,
	TTBSS_POINTINGDOWNLEFTWALL = 6,
};


//
//  TRACKBARSTYLE class parts and states 
//
#define VSCLASS_TRACKBARSTYLE	L"TRACKBARSTYLE"
#define VSCLASS_TRACKBAR	L"TRACKBAR"

enum TRACKBARPARTS {
	TKP_TRACK = 1,
	TKP_TRACKVERT = 2,
	TKP_THUMB = 3,
	TKP_THUMBBOTTOM = 4,
	TKP_THUMBTOP = 5,
	TKP_THUMBVERT = 6,
	TKP_THUMBLEFT = 7,
	TKP_THUMBRIGHT = 8,
	TKP_TICS = 9,
	TKP_TICSVERT = 10,
};

#define TRACKBARSTYLEPARTS TRACKBARPARTS;

enum TRACKBARSTYLESTATES {
	TKS_NORMAL = 1,
};

enum TRACKSTATES {
	TRS_NORMAL = 1,
};

enum TRACKVERTSTATES {
	TRVS_NORMAL = 1,
};

enum THUMBSTATES {
	TUS_NORMAL = 1,
	TUS_HOT = 2,
	TUS_PRESSED = 3,
	TUS_FOCUSED = 4,
	TUS_DISABLED = 5,
};

enum THUMBBOTTOMSTATES {
	TUBS_NORMAL = 1,
	TUBS_HOT = 2,
	TUBS_PRESSED = 3,
	TUBS_FOCUSED = 4,
	TUBS_DISABLED = 5,
};

enum THUMBTOPSTATES {
	TUTS_NORMAL = 1,
	TUTS_HOT = 2,
	TUTS_PRESSED = 3,
	TUTS_FOCUSED = 4,
	TUTS_DISABLED = 5,
};

enum THUMBVERTSTATES {
	TUVS_NORMAL = 1,
	TUVS_HOT = 2,
	TUVS_PRESSED = 3,
	TUVS_FOCUSED = 4,
	TUVS_DISABLED = 5,
};

enum THUMBLEFTSTATES {
	TUVLS_NORMAL = 1,
	TUVLS_HOT = 2,
	TUVLS_PRESSED = 3,
	TUVLS_FOCUSED = 4,
	TUVLS_DISABLED = 5,
};

enum THUMBRIGHTSTATES {
	TUVRS_NORMAL = 1,
	TUVRS_HOT = 2,
	TUVRS_PRESSED = 3,
	TUVRS_FOCUSED = 4,
	TUVRS_DISABLED = 5,
};

enum TICSSTATES {
	TSS_NORMAL = 1,
};

enum TICSVERTSTATES {
	TSVS_NORMAL = 1,
};


//
//  TREEVIEWSTYLE class parts and states 
//
#define VSCLASS_TREEVIEWSTYLE	L"TREEVIEWSTYLE"
#define VSCLASS_TREEVIEW	L"TREEVIEW"

enum TREEVIEWPARTS {
	TVP_TREEITEM = 1,
	TVP_GLYPH = 2,
	TVP_BRANCH = 3,
	TVP_HOTGLYPH = 4,
};

#define TREEVIEWSTYLEPARTS TREEVIEWPARTS;

enum TREEITEMSTATES {
	TREIS_NORMAL = 1,
	TREIS_HOT = 2,
	TREIS_SELECTED = 3,
	TREIS_DISABLED = 4,
	TREIS_SELECTEDNOTFOCUS = 5,
	TREIS_HOTSELECTED = 6,
};

enum GLYPHSTATES {
	GLPS_CLOSED = 1,
	GLPS_OPENED = 2,
};

enum HOTGLYPHSTATES {
	HGLPS_CLOSED = 1,
	HGLPS_OPENED = 2,
};


//
//  WINDOWSTYLE class parts and states 
//
#define VSCLASS_WINDOWSTYLE	L"WINDOWSTYLE"
#define VSCLASS_WINDOW	L"WINDOW"

enum WINDOWPARTS {
	WP_CAPTION = 1,
	WP_SMALLCAPTION = 2,
	WP_MINCAPTION = 3,
	WP_SMALLMINCAPTION = 4,
	WP_MAXCAPTION = 5,
	WP_SMALLMAXCAPTION = 6,
	WP_FRAMELEFT = 7,
	WP_FRAMERIGHT = 8,
	WP_FRAMEBOTTOM = 9,
	WP_SMALLFRAMELEFT = 10,
	WP_SMALLFRAMERIGHT = 11,
	WP_SMALLFRAMEBOTTOM = 12,
	WP_SYSBUTTON = 13,
	WP_MDISYSBUTTON = 14,
	WP_MINBUTTON = 15,
	WP_MDIMINBUTTON = 16,
	WP_MAXBUTTON = 17,
	WP_CLOSEBUTTON = 18,
	WP_SMALLCLOSEBUTTON = 19,
	WP_MDICLOSEBUTTON = 20,
	WP_RESTOREBUTTON = 21,
	WP_MDIRESTOREBUTTON = 22,
	WP_HELPBUTTON = 23,
	WP_MDIHELPBUTTON = 24,
	WP_HORZSCROLL = 25,
	WP_HORZTHUMB = 26,
	WP_VERTSCROLL = 27,
	WP_VERTTHUMB = 28,
	WP_DIALOG = 29,
	WP_CAPTIONSIZINGTEMPLATE = 30,
	WP_SMALLCAPTIONSIZINGTEMPLATE = 31,
	WP_FRAMELEFTSIZINGTEMPLATE = 32,
	WP_SMALLFRAMELEFTSIZINGTEMPLATE = 33,
	WP_FRAMERIGHTSIZINGTEMPLATE = 34,
	WP_SMALLFRAMERIGHTSIZINGTEMPLATE = 35,
	WP_FRAMEBOTTOMSIZINGTEMPLATE = 36,
	WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE = 37,
	WP_FRAME = 38,
};

#define WINDOWSTYLEPARTS WINDOWPARTS;

enum FRAMESTATES {
	FS_ACTIVE = 1,
	FS_INACTIVE = 2,
};

enum CAPTIONSTATES {
	CS_ACTIVE = 1,
	CS_INACTIVE = 2,
	CS_DISABLED = 3,
};

enum MAXCAPTIONSTATES {
	MXCS_ACTIVE = 1,
	MXCS_INACTIVE = 2,
	MXCS_DISABLED = 3,
};

enum MINCAPTIONSTATES {
	MNCS_ACTIVE = 1,
	MNCS_INACTIVE = 2,
	MNCS_DISABLED = 3,
};

enum HORZSCROLLSTATES {
	HSS_NORMAL = 1,
	HSS_HOT = 2,
	HSS_PUSHED = 3,
	HSS_DISABLED = 4,
};

enum HORZTHUMBSTATES {
	HTS_NORMAL = 1,
	HTS_HOT = 2,
	HTS_PUSHED = 3,
	HTS_DISABLED = 4,
};

enum VERTSCROLLSTATES {
	VSS_NORMAL = 1,
	VSS_HOT = 2,
	VSS_PUSHED = 3,
	VSS_DISABLED = 4,
};

enum VERTTHUMBSTATES {
	VTS_NORMAL = 1,
	VTS_HOT = 2,
	VTS_PUSHED = 3,
	VTS_DISABLED = 4,
};

enum SYSBUTTONSTATES {
	SBS_NORMAL = 1,
	SBS_HOT = 2,
	SBS_PUSHED = 3,
	SBS_DISABLED = 4,
};

enum MINBUTTONSTATES {
	MINBS_NORMAL = 1,
	MINBS_HOT = 2,
	MINBS_PUSHED = 3,
	MINBS_DISABLED = 4,
};

enum MAXBUTTONSTATES {
	MAXBS_NORMAL = 1,
	MAXBS_HOT = 2,
	MAXBS_PUSHED = 3,
	MAXBS_DISABLED = 4,
};

enum RESTOREBUTTONSTATES {
	RBS_NORMAL = 1,
	RBS_HOT = 2,
	RBS_PUSHED = 3,
	RBS_DISABLED = 4,
};

enum HELPBUTTONSTATES {
	HBS_NORMAL = 1,
	HBS_HOT = 2,
	HBS_PUSHED = 3,
	HBS_DISABLED = 4,
};

enum CLOSEBUTTONSTATES {
	CBS_NORMAL = 1,
	CBS_HOT = 2,
	CBS_PUSHED = 3,
	CBS_DISABLED = 4,
};


#endif //__VSSTYLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\vtrans.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Video transform base class.
// This class is derived from CTransformFilter, but is specialised to handle
// the requirements of video quality control by frame dropping.
// This is a non-in-place transform, (i.e. it copies the data) such as a decoder.

class CVideoTransformFilter : public CTransformFilter
{
  public:

    CVideoTransformFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid);
    ~CVideoTransformFilter();
    HRESULT EndFlush();

    // =================================================================
    // ----- override these bits ---------------------------------------
    // =================================================================
    // The following methods are in CTransformFilter which is inherited.
    // They are mentioned here for completeness
    //
    // These MUST be supplied in a derived class
    //
    // NOTE:
    // virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);
    // virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE;
    // virtual HRESULT CheckTransform
    //     (const CMediaType* mtIn, const CMediaType* mtOut) PURE;
    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *);
    // virtual HRESULT DecideBufferSize
    //     (IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pprop) PURE;
    // virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) PURE;
    //
    // These MAY also be overridden
    //
    // virtual HRESULT StopStreaming();
    // virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    // virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
    // virtual HRESULT BreakConnect(PIN_DIRECTION dir);
    // virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin);
    // virtual HRESULT EndOfStream(void);
    // virtual HRESULT BeginFlush(void);
    // virtual HRESULT EndFlush(void);
    // virtual HRESULT NewSegment
    //     (REFERENCE_TIME tStart,REFERENCE_TIME tStop,double dRate);
    // override the AlterQuality if you wish to avoid the video frame dropping mechanism in CVideoTransformFilter
    // virtual HRESULT AlterQuality(Quality q);  

#ifdef PERF

    // If you override this - ensure that you register all these ids
    // as well as any of your own,
    virtual void RegisterPerfId() {
        m_idSkip        = MSR_REGISTER("Video Transform Skip frame");
        m_idFrameType   = MSR_REGISTER("Video transform frame type");
        m_idLate        = MSR_REGISTER("Video Transform Lateness");
        m_idTimeTillKey = MSR_REGISTER("Video Transform Estd. time to next key");
        CTransformFilter::RegisterPerfId();
    }
#endif

  protected:

    // =========== QUALITY MANAGEMENT IMPLEMENTATION ========================
    // Frames are assumed to come in three types:
    // Type 1: an AVI key frame or an MPEG I frame.
    //        This frame can be decoded with no history.
    //        Dropping this frame means that no further frame can be decoded
    //        until the next type 1 frame.
    //        Type 1 frames are sync points.
    // Type 2: an AVI non-key frame or an MPEG P frame.
    //        This frame cannot be decoded unless the previous type 1 frame was
    //        decoded and all type 2 frames since have been decoded.
    //        Dropping this frame means that no further frame can be decoded
    //        until the next type 1 frame.
    // Type 3: An MPEG B frame.
    //        This frame cannot be decoded unless the previous type 1 or 2 frame
    //        has been decoded AND the subsequent type 1 or 2 frame has also
    //        been decoded.  (This requires decoding the frames out of sequence).
    //        Dropping this frame affects no other frames.  This implementation
    //        does not allow for these.  All non-sync-point frames are treated
    //        as being type 2.
    //
    // The spacing of frames of type 1 in a file is not guaranteed.  There MUST
    // be a type 1 frame at (well, near) the start of the file in order to start
    // decoding at all.  After that there could be one every half second or so,
    // there could be one at the start of each scene (aka "cut", "shot") or
    // there could be no more at all.
    // If there is only a single type 1 frame then NO FRAMES CAN BE DROPPED
    // without losing all the rest of the movie.  There is no way to tell whether
    // this is the case, so we find that we are in the gambling business.
    // To try to improve the odds, we record the greatest interval between type 1s
    // that we have seen and we bet on things being no worse than this in the
    // future.  This is of course a poor show, but it's "the only show in town".

    // You can tell if it's a type 1 frame by calling IsSyncPoint().
    // there is no architected way to test for a type 3, so you should override
    // the quality management here if you have B-frames.

    int m_nKeyFramePeriod; // the largest observed interval between type 1 frames
                           // 1 means every frame is type 1, 2 means every other.

    int m_nFramesSinceKeyFrame; // Used to count frames since the last type 1.
                                // becomes the new m_nKeyFramePeriod if greater.
#ifdef UNDER_CE
    int m_nKeyFrameSum;
    int m_nSkipChecks;
#endif
    BOOL m_bSkipping;           // we are skipping to the next type 1 frame

#ifdef PERF
    int m_idFrameType;          // MSR id Frame type.  1=Key, 2="non-key"
    int m_idSkip;               // MSR id skipping
    int m_idLate;               // MSR id lateness
    int m_idTimeTillKey;        // MSR id for guessed time till next key frame.
#endif

    virtual HRESULT StartStreaming();

    HRESULT AbortPlayback(HRESULT hr);	// if something bad happens

    HRESULT Receive(IMediaSample *pSample);

    virtual HRESULT AlterQuality(Quality q);

    BOOL ShouldSkipFrame(IMediaSample * pIn);

    int m_itrLate;              // lateness from last Quality message
                                // (this overflows at 214 secs late).
    int m_tDecodeStart;         // timeGetTime when decode started.
    int m_itrAvgDecode;         // Average decode time in reference units.

    BOOL m_bNoSkip;             // debug - no skipping.

    // We send an EC_QUALITY_CHANGE notification to the app if we have to degrade.
    // We send one when we start degrading, not one for every frame, this means
    // we track whether we've sent one yet.
    BOOL m_bQualityChanged;

    // When non-zero, don't pass anything to renderer until next keyframe
    // If there are few keys, give up and eventually draw something
    int m_nWaitForKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wchar.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*wchar.h - declarations for wide character functions
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WCHAR
#define _INC_WCHAR

/*
 * STDLIB is included for legacy reasons.
 */
#include "stdlib.h"

#include <crtdefs.h>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/*
 *  According to the standard, WCHAR_MIN and WCHAR_MAX need to be
 *  "constant expressions suitable for use in #if preprocessing directives,
 *  and this expression shall have the same type as would an expression that
 *  is an object of the corresponding type converted according to the integer
 *  promotions".
 */
#define WCHAR_MIN       0
#define WCHAR_MAX       0xffff

typedef int mbstate_t;
typedef wchar_t _Wint_t;

#ifdef  __cplusplus
inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *)
        {return (1); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        for (; 0 < _N; ++_Su1, ++_S2, --_N)
                *_Su1 = *_S2;
        return (_S1); }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        if (_S2 < _Su1 && _Su1 < _S2 + _N)
                for (_Su1 += _N, _S2 += _N; 0 < _N; --_N)
                        *--_Su1 = *--_S2;
        else
                for (; 0 < _N; --_N)
                        *_Su1++ = *_S2++;
        return (_S1); }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }

#endif /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wctype.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*wctype.h - declarations for wide character functions
*
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#include <crtdefs.h>

#ifdef  __cplusplus
extern "C" {
#endif

/* set bit masks for the possible character types */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */

typedef wchar_t wctrans_t;

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wdogapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _WATCHDOG_API_H_
#define _WATCHDOG_API_H_


#ifdef __cplusplus
extern "C" {
#endif

//
// Watchdog timer support
//

//
// default actions
//
#define WDOG_NO_DFLT_ACTION         0
#define WDOG_KILL_PROCESS           1
#define WDOG_RESET_DEVICE           2

#define WD_TOTAL_DFLT_ACTION        3

//
// watchdog APIs
//
HANDLE CreateWatchDogTimer (
    LPCWSTR pszWatchDogName,
    DWORD dwPeriod,
    DWORD dwWait,
    DWORD dwDfltAction,
    DWORD dwParam,
    DWORD dwFlags);

HANDLE OpenWatchDogTimer (
    LPCWSTR pszWatchDogName,
    DWORD dwFlags);

BOOL StartWatchDogTimer (
    HANDLE hWatchDog,
    DWORD dwFlags);

BOOL StopWatchDogTimer (
    HANDLE hWatchDog,
    DWORD dwFlags);

BOOL RefreshWatchDogTimer (
    HANDLE hWatchDog,
    DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif  // _WATCHDOG_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wdm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    wdm.h

Abstract:

    This module defines the WDM types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#pragma once

#ifndef _WDMDDK_
#define _WDMDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#ifdef __cplusplus
extern "C" {
#endif

#include <ntstatus.h>
#include <memory.h>
#include <ceddk.h>


typedef UCHAR KIRQL;
typedef CONST char *PCSZ;

typedef char CCHAR, *PCCHAR;
typedef short CSHORT, *PCSHORT;
typedef ULONG CLONG, *PCLONG;
typedef KIRQL *PKIRQL;

#ifndef FASTCALL
#define FASTCALL
#endif
#ifndef PAGED_CODE
#define PAGED_CODE()
#endif

#ifndef MAXULONG
#define MAXULONG 0xffffffff  // From ntdef.h
#endif

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//
#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif

//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;

#ifdef UNDER_CE
#define  DEVICE_OBJECT CEDEVICE_OBJECT
#define  PDEVICE_OBJECT PCEDEVICE_OBJECT 
#define _DEVICE_OBJECT _CEDEVICE_OBJECT
#endif

typedef struct _DEVICE_DESCRIPTION  DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;
typedef struct _DEVICE_OBJECT       DEVICE_OBJECT,      *PDEVICE_OBJECT; 
typedef struct _DMA_ADAPTER         DMA_ADAPTER,        *PDMA_ADAPTER;
typedef struct _IO_TIMER                                *PIO_TIMER;
typedef struct _IRP                 IRP,                *PIRP;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    LPWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

// define NO_UNICODE_STRING so taht lpc.h doesn't re-define it
#define NO_UNICODE_STRING

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.  In a future compiler this will
// be placed at:
//
//      ULONG Pages[];
//
// Until this declaration is permitted, however, one simply calculates the
// base of the array by adding one to the base MDL pointer:
//
//      Pages = (PULONG) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//
// NOTE: If MDL_64_BIT_VA flag is set, the StartVa field contains
//       the Virtual Page Number (VirtualAddress / PAGE_SIZE).
//       HENCE, the reference to the base virtual address becomes:
//
//        (PVOID64)(((LONG LONG)Mdl->StartVa << PAGE_SHIFT) | Mdl->ByteOffset)
//

typedef struct _MDL {
    struct _MDL *Next;
    PVOID StartVa;
    ULONG ByteCount;
//    CSHORT Size;
    SHORT MdlFlags;
//    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031

#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000100

//
// define IO_NO_INCREMENT
//

#define IO_NO_INCREMENT                 0

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
//#define FO_ALERTABLE_IO                 0x00000004
//#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
//#define FO_WRITE_THROUGH                0x00000010
//#define FO_SEQUENTIAL_ONLY              0x00000020
//#define FO_CACHE_SUPPORTED              0x00000040
//#define FO_NAMED_PIPE                   0x00000080
//#define FO_STREAM_FILE                  0x00000100
//#define FO_MAILSLOT                     0x00000200
//#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
//#define FO_DIRECT_DEVICE_OPEN           0x00000800
//#define FO_FILE_MODIFIED                0x00001000
//#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
//#define FO_TEMPORARY_FILE               0x00008000
//#define FO_DELETE_ON_CLOSE              0x00010000
//#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000

typedef struct _FILE_OBJECT {
//    CSHORT Type;
//    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
//    PVOID DoNotUse1;
    PVOID FsContext;
    PVOID FsContext2;
//    PSECTION_OBJECT_POINTERS SectionObjectPointer;
//    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
//    BOOLEAN LockOperation;
//    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
//    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
//    BOOLEAN SharedDelete;
    ULONG Flags;
    HANDLE hCloseEvent;
//    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
//    ULONG Waiters;
    ULONG Busy;
//    PVOID LastLock;
    ULONG Lock;
    HANDLE Event;
    HANDLE hevtSynchronous;
//    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT, *PFILE_OBJECT;

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(*PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define driver initialization routine type.
//

typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//

typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );

//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
(*PFAST_IO_MDL_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_PREPARE_MDL_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
VOID
(*PPNP_CALLBACK) (
    IN PVOID Context
    );


//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
//    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
//    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
//    PFAST_IO_LOCK FastIoLock;
//    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
//    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
//    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
//    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
//    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
//    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
//    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
//    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
//    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
//    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
//    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
//    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
//    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
//    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
//    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at front of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue and interrupt
//     the target processor if the DPC is targeted and the system is an MP
//     system.
//
// N.B. If the target processor is the same as the processor on which the DPC
//      is queued on, then the processor is always interrupted if the DPC queue
//      was previously empty.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    USHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PULONG Lock;
} KDPC, *PKDPC;


//
// string definition
//

typedef struct _STRING {
          USHORT        Length;
          USHORT        MaximumLength;
          PCHAR         Buffer;
        } STRING, *PSTRING;

typedef STRING ANSI_STRING, *PANSI_STRING;


//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
//    CSHORT Type;
//    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    CRITICAL_SECTION Lock;
    BOOLEAN Busy;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY;


//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifndef _PO_DDK_
#define _PO_DDK_

typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown,
    PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef union _POWER_STATE {
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
    SystemPowerState,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;
#endif

//
// Define I/O Request Packet (IRP) stack locations
//

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            ULONG Options;
            USHORT FileAttributes;
            USHORT ShareAccess;
        } Create;


        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG Key;
            LARGE_INTEGER ByteOffset;
        } Write;


        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG InputBufferLength;
            ULONG IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

#if 0
        //
        // Non-system service parameters.
        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
        } QueryInterface;

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_QUERY_RESOURCE_REQUIREMENTS
        //

        struct {
            ULONG NoArguments;
        } QueryResourceRequirements;

        //
        // Parameters for IRP_MN_SET_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } SetResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_EJECT
        //

        struct {
            ULONG NoArguments;
        } Eject;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_PNP_DEVICE_STATE
        //

        struct {
            BOOLEAN Query;
            UCHAR Reserved[3];
            PNP_DEVICE_STATE PnpDeviceState;
        } PnpDeviceState;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;
#endif

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE Type;
            POWER_STATE State;
        } Power;

#if 0

        //
        // Parameters for device removal irp
        //

        struct {
            PDEVICE_OBJECT DeviceToRemove;
        } RemoveDevice;

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
        } StartDevice;
#endif

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

//
// Define dynamic processor add types.
//

typedef enum {
    KeProcessorAddStartNotify = 0,
    KeProcessorAddCompleteNotify,
    KeProcessorAddFailureNotify
} KE_PROCESSOR_CHANGE_NOTIFY_STATE;


//
// Define the major function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//
// WinCE Note: IRPs have been renumbered to save space
//
#define IRP_MJ_CREATE                   0x00
//#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x01
#define IRP_MJ_READ                     0x02
#define IRP_MJ_WRITE                    0x03
//#define IRP_MJ_QUERY_INFORMATION        0x05
//#define IRP_MJ_SET_INFORMATION          0x06
//#define IRP_MJ_QUERY_EA                 0x07
//#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x04
//#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
//#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
//#define IRP_MJ_DIRECTORY_CONTROL        0x0c
//#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x05
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x06
#define IRP_MJ_SHUTDOWN                 0x07
//#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x08
//#define IRP_MJ_CREATE_MAILSLOT          0x13
//#define IRP_MJ_QUERY_SECURITY           0x14
//#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x09
//#define IRP_MJ_NOT_DEFINED              0x17    // available
#define IRP_MJ_DEVICE_CHANGE            0x0a
//#define IRP_MJ_QUERY_QUOTA              0x19
//#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x0b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete
#define IRP_MJ_MAXIMUM_FUNCTION         0x0c

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// PNP/Power minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_SET_RESOURCE_REQUIREMENTS    0x0C
#define IRP_MN_ADJUST_RESOURCES             0x0D
#define IRP_MN_SET_DEVICE_RESOURCES         0x0E

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_PNP_DEVICE_STATE             0x14

#define IRP_MN_WAIT_WAKE                    0x15
#define IRP_MN_POWER_SEQUENCE               0x16
#define IRP_MN_SET_POWER                    0x17
#define IRP_MN_QUERY_POWER                  0x18

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04

//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
//    CSHORT Type;
//    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

//    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

//    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

//    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    HANDLE UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

//            PETHREAD Thread;
            HANDLE CallerProcess;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // List entry - used to queue the packet to completion queue, among
            // others.
            //

            LIST_ENTRY ListEntry;

            //
            // Current stack location - contains a pointer to the current
            // IO_STACK_LOCATION structure in the IRP stack.  This field
            // should never be directly accessed by drivers.  They should
            // use the standard functions.
            //

            struct _IO_STACK_LOCATION *CurrentStackLocation;

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

//        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        ULONG CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010

typedef struct _DEVOBJ_EXTENSION {

//    CSHORT          Type;
//    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    //
    // Shared Power Management fields
    //

    ULONG           IdleCount;                  // SHARED field via PoSetDeviceBusy()
//    POWER_STATE     CurrentPowerState;
    ULONG           CurrentDevicePowerState;
    BOOLEAN         StartIoQueueHolding;        // PO & IO
    BOOLEAN         UseAsyncPowerUp;
    BOOLEAN         PowerControlNeeded;
    BOOLEAN         PowerControlPagable;


    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // Note: any new shared fields get added here.
    //



} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //


} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

typedef struct _DRIVER_OBJECT {
//    CSHORT Type;
//    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

//    PVOID DriverStart;
//    ULONG DriverSize;
//    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

//    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  This is a pointer
    // to the path to the hardware information in the registry
    //

//    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis



//
// Define Device Status for IoReportDeviceStatus
// 0 - 0x7fffffff are for private use and 0x80000000 -
// 0xffffffff are reserved for system.
//

#define DEVICE_STATUS_OK            0x80000000
#define DEVICE_STATUS_MALFUNCTIONED 0x80000001
#define DEVICE_STATUS_REMOVED       0x80000002
#define DEVICE_STATUS_DISABLED      0x80000003

//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;


//
// Define Device Object (DO) flags
//

#define DO_VERIFY_VOLUME                0x00000002
#define DO_BUFFERED_IO                  0x00000004
#define DO_EXCLUSIVE                    0x00000008
#define DO_DIRECT_IO                    0x00000010
#define DO_MAP_IO_BUFFER                0x00000020
#define DO_DEVICE_HAS_NAME              0x00000040
#define DO_DEVICE_INITIALIZING          0x00000080
#define DO_SYSTEM_BOOT_PARTITION        0x00000100
#define DO_LONG_TERM_REQUESTS           0x00000200
#define DO_NEVER_LAST_DEVICE            0x00000400
#define DO_SHUTDOWN_REGISTERED          0x00000800
#define DO_BUS_ENUMERATED_DEVICE        0x00001000

//
// Device Object structure definition
//
#ifndef UNDER_CE
typedef struct _DEVICE_OBJECT {
//    CSHORT Type;
//    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
//    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
//    PVOID DoNotUse1;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
//        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
//    PSECURITY_DESCRIPTOR SecurityDescriptor;
//    KEVENT DeviceLock;

//    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
//    PVOID  Reserved;
} DEVICE_OBJECT, *PDEVICE_OBJECT;
#endif

//
// DMA related
//
typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG Reserved;
    // Elements is not only 1 element long.  It can be of any size.
    SCATTER_GATHER_ELEMENT Elements[1];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;


//
// Define the DMA transfer widths.
//
typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;


//
// Define DMA transfer speeds.
//
typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;


//
// Define the device description structure.
//
typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG DoNotUse2;
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//
#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1


typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
//    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
} DMA_OPERATIONS;


#if 0
__inline
PVOID
HalAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}


__inline
VOID
HalFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}
#endif	// 0.

__inline
NTSTATUS
IoAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    PREFAST_ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}


__inline
BOOLEAN
IoFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    PREFAST_ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}


__inline
VOID
IoFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    PREFAST_ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}


__inline
VOID
IoFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    IN PVOID MapRegisterBase,
    IN ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    PREFAST_ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


__inline
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    PREFAST_ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}


__inline
ULONG
HalGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    PREFAST_ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}


__inline
ULONG
HalReadDmaCounter(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    PREFAST_ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

typedef struct _DMA_ADAPTER *(*PGET_DMA_ADAPTER)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );


LPVOID
HalAllocatePhysicalMemory(
    IN LPVOID StartAddress,
    IN ULONG Size,
    OUT PPHYSICAL_ADDRESS PhysicalBuffer,
    IN BOOLEAN CacheEnabled
    );

ULONG
HalFreePhysicalMemory(
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

BOOL
HalMapInterrupt(
    IN ULONG InterruptNumber,
    IN ULONG InterruptVector,
    OUT DWORD *InterruptId
    );

PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );

/*
NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );
*/

NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );


PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN HANDLE Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN HANDLE Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IoCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
IoCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );

VOID
IoFreeIrp(
    IN PIRP Irp
    );

VOID
IoFreeMdl(
    IN PMDL Mdl
    );

NTSTATUS
IoSendWinCePnPMessage(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
IoSendWinCePnPCallback(
    IN PPNP_CALLBACK pCallback,
    IN PVOID pContext
    );

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )


//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );


NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN struct _DEVICE_DESCRIPTION *DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

PDEVICE_OBJECT
IoGetRelatedDeviceObject (
    IN PFILE_OBJECT FileObject
    );

VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) || (Error) || (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor do they wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;

//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

#if defined(DBG) || defined(DEBUG)

#define KdPrint(_x_)   DbgPrint _x_
#define KdBreakPoint() DebugBreak()

#else

#define KdPrint(_x_)
#define KdBreakPoint()

#endif

ULONG
DbgPrint(
  IN PCHAR DebugMessage,
  ...
);


VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );


typedef CRITICAL_SECTION KSPIN_LOCK, *PKSPIN_LOCK;

#define KeAcquireSpinLockAtDpcLevel(lock)   EnterCriticalSection(lock)
// Add IRQL to avoid unreferenced param errors

__inline VOID KeAcquireSpinLock(IN PKSPIN_LOCK  SpinLock,    OUT PKIRQL  OldIrql    ) {
    EnterCriticalSection(SpinLock); 
    *OldIrql=2; // BUGBUG--what is the correct value to set this to
}

#define KeInitializeSpinLock(lock)          InitializeCriticalSection(lock)
#define KeUninitializeSpinLock(lock)        DeleteCriticalSection(lock)
#define KeReleaseSpinLock(lock,newirql)     LeaveCriticalSection(lock); newirql
#define KeReleaseSpinLockFromDpcLevel(lock) LeaveCriticalSection(lock)
#define KeFreeSpinLock(lock)                DeleteCriticalSection(lock)

#define KeRaiseIrql(newirql,oldirql)        newirql; oldirql
#define KeLowerIrql(newirql)                newirql

__inline VOID KeQueryTickCount(LARGE_INTEGER UNALIGNED * val) {
    val->QuadPart = GetTickCount();
}

// Returns # of 100ns units that elapse with each tick.  CE tick count is in ms
__inline ULONG KeQueryTimeIncrement(VOID) {
    return (10000);
}


// NT's new InterlockedExchangePointer() takes care of 32 bit/64 bit pointers.
// whereas the old InterlockedExchange() only work on 32 bit pointers.
//
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
    ((PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value)))
#endif


VOID
MmBuildMdlForNonPagedPool (
    IN OUT PMDL MemoryDescriptorList
    );

PMDL
MmCreateMdl(
    IN PMDL MemoryDescriptorList OPTIONAL,
    IN PVOID Base,
    IN ULONG Length
    );

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) (((Mdl)->MdlFlags & MDL_64_BIT_VA) ?              \
    (PVOID) ((ULONG) (Mdl)->StartVa << PAGE_SHIFT) : (Mdl)->StartVa) +  \
    (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  (((Mdl)->MdlFlags & MDL_64_BIT_VA) ?       \
    (PVOID) (((ULONG) (Mdl)->StartVa) << PAGE_SHIFT) : (Mdl)->StartVa)

//++
//
// VOID
// MmInitializeMdl (
//     IN PMDL MemoryDescriptorList,
//     IN PVOID BaseVa,
//     IN ULONG Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (Length); \
    }

//#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
//    (MemoryDescriptorList)->Next = (PMDL) NULL; \
//    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
//            (sizeof(ULONG) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
//    (MemoryDescriptorList)->MdlFlags = 0; \
//    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
//    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
//    (MemoryDescriptorList)->ByteCount = (Length); \
//    }


//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

PVOID
MmMapLockedPages (
    IN PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode
    );

//++
//
// VOID
// MmPrepareMdlForReuse (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }

VOID
MmProbeAndLockPages (
    IN OUT PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );

VOID
MmUnlockPages (
    IN PMDL MemoryDescriptorList
    );

VOID
MmUnmapLockedPages (
    IN PVOID BaseAddress,
    IN PMDL MemoryDescriptorList
    );

NTSTATUS
ObDereferenceObject(
    IN PVOID Object
    );

#include <linklist.h>

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


PVOID
PnPLoadWDMDriver(
    IN LPCWSTR pDriverName,
    IN PDEVICE_OBJECT pPDO,
    IN LPWSTR pszRegPath,
    OUT PDRIVER_OBJECT *ppDriverObject);

NTSTATUS
PnPUnLoadWDMDriver(
    IN PVOID pContext);


VOID
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
RtlAppendUnicodeToString(
    IN PUNICODE_STRING Destination,
    IN PWSTR Source OPTIONAL
);

NTSTATUS
RtlIntegerToUnicodeString(
    IN ULONG  Value,
    IN ULONG  Base OPTIONAL,
    IN OUT PUNICODE_STRING  String
    );

NTSTATUS
RtlAppendUnicodeStringToString(
    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    );

VOID
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    );

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#ifndef RtlZeroMemory
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))
#endif

#if !defined(MIDL_PASS)

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef __RtlSecureZeroMemory_defined
#define __RtlSecureZeroMemory_defined

FORCEINLINE
PVOID
RtlSecureZeroMemory(
    IN PVOID ptr,
    IN SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}

#endif  // __RtlSecureZeroMemory_defined
#endif  // MIDL_PASS

//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;


//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.
//

VOID
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

BOOLEAN
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

VOID
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

VOID
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

ULONG
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

ULONG
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

VOID
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

VOID
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

ULONG
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

ULONG
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

ULONG
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

ULONG
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

BOOLEAN
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

BOOLEAN
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

//
//  The following two procedures return to the caller a value indicating
//  the position within a ULONGLONG of the most or least significant non-zero
//  bit.  A value of zero results in a return value of -1.
//

CCHAR
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

CCHAR
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );

//  Define the splay links and the associated manipuliation macros and
//  routines.  Note that the splay_links should be an opaque type.
//  Routine are provided to traverse and manipulate the structure.
//
typedef struct _RTL_SPLAY_LINKS {
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;


//
//  The macro procedure InitializeSplayLinks takes as input a pointer to
//  splay link and initializes its substructure.  All splay link nodes must
//  be initialized before they are used in the different splay routines and
//  macros.
//
//  VOID
//  RtlInitializeSplayLinks (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlInitializeSplayLinks(Links) {    \
    PRTL_SPLAY_LINKS _SplayLinks;            \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks;   \
    _SplayLinks->LeftChild = NULL;       \
    _SplayLinks->RightChild = NULL;      \
    }

//
//  The macro function Parent takes as input a pointer to a splay link in a
//  tree and returns a pointer to the splay link of the parent of the input
//  node.  If the input node is the root of the tree the return value is
//  equal to the input value.
//
//  PRTL_SPLAY_LINKS
//  RtlParent (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlParent(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->Parent \
    )

//
//  The macro function LeftChild takes as input a pointer to a splay link in
//  a tree and returns a pointer to the splay link of the left child of the
//  input node.  If the left child does not exist, the return value is NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->LeftChild \
    )

//
//  The macro function RightChild takes as input a pointer to a splay link
//  in a tree and returns a pointer to the splay link of the right child of
//  the input node.  If the right child does not exist, the return value is
//  NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->RightChild \
    )

//
//  The macro function IsRoot takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the root of the tree,
//  otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRoot (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRoot(Links) (                          \
    (RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsLeftChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the left child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsLeftChild(Links) (                                   \
    (RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsRightChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the right child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRightChild(Links) (                                   \
    (RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro procedure InsertAsLeftChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the left child of the first node.  The first node must not
//  already have a left child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsLeftChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                      \
    PRTL_SPLAY_LINKS _SplayChild;                       \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);     \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);       \
    _SplayParent->LeftChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;             \
    }

//
//  The macro procedure InsertAsRightChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the right child of the first node.  The first node must not
//  already have a right child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsRightChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsRightChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                       \
    PRTL_SPLAY_LINKS _SplayChild;                        \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);      \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);        \
    _SplayParent->RightChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;              \
    }

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

PRTL_SPLAY_LINKS
RtlSplay (
    PRTL_SPLAY_LINKS Links
    );

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//

PRTL_SPLAY_LINKS
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );

//
//  The DeleteNoSplay function takes as input a pointer to a splay link in a tree,
//  the caller's pointer to the root of the tree and deletes that node from the
//  tree.  Upon return the caller's pointer to the root node will correctly point
//  at the root of the tree.
//
//  It operationally differs from RtlDelete only in that it will not splay the tree.
//

VOID
RtlDeleteNoSplay (
    PRTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS *Root
    );

//
//  The SubtreeSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node of
//  the substree rooted at the input node.  If there is not a successor, the
//  return value is NULL.
//

PRTL_SPLAY_LINKS
RtlSubtreeSuccessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The SubtreePredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node of
//  the substree rooted at the input node.  If there is not a predecessor,
//  the return value is NULL.
//

PRTL_SPLAY_LINKS
RtlSubtreePredecessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The RealSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node within
//  the entire tree.  If there is not a successor, the return value is NULL.
//

PRTL_SPLAY_LINKS
RtlRealSuccessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The RealPredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node
//  within the entire tree.  If there is not a predecessor, the return value
//  is NULL.
//

PRTL_SPLAY_LINKS
RtlRealPredecessor (
    PRTL_SPLAY_LINKS Links
    );

//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );

ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );

ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );




#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _WDMDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wap.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//


#ifndef _WAP_H_
#define _WAP_H_


//
// Errors
//

#define FACILITY_WAP                            0x500

// WTLS errors
#define WAP_E_WTLS                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x0001)
#define WAP_E_WTLS_CERTIFICATE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x0002)
#define WAP_E_WTLS_HANDSHAKE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x0003)
#define WAP_E_WTLS_CRYPTERROR                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x0004)
#define WAP_E_WTLS_BADMAC                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x0005)

#define WAP_E_NO_UDP_ACCESS                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WAP, 0x00100)


//
// Constants
//

// Maximum sizes
#define MAX_WAP_ADDRESS_LENGTH                  (64)

// WDP field identifiers
#define WDP_FIELD_NONE                          (0x00000000)
#define WDP_FIELD_SOURCEADDRESS                 (0x00000001)
#define WDP_FIELD_SOURCEPORT                    (0x00000002)
#define WDP_FIELD_DESTINATIONADDRESS            (0x00000004)
#define WDP_FIELD_DESTINATIONPORT               (0x00000008)
#define WDP_FIELD_USERDATA                      (0x00000010)
/*
#define WDP_FIELD_ERRORCODE                     (0x00000020)
*/

// WTP field identifiers
#define WTP_FIELD_NONE                          (0x00000000)
#define WTP_FIELD_SOURCEADDRESS                 (0x00000001)
#define WTP_FIELD_SOURCEPORT                    (0x00000002)
#define WTP_FIELD_DESTINATIONADDRESS            (0x00000004)
#define WTP_FIELD_DESTINATIONPORT               (0x00000008)
#define WTP_FIELD_USERACKNOWLEDGEMENT           (0x00000010)
#define WTP_FIELD_WANTSECURETRANSACTION         (0x00000020)
#define WTP_FIELD_USERDATA                      (0x00000040)
#define WTP_FIELD_CLASSTYPE                     (0x00000080)
#define WTP_FIELD_EXITINFO                      (0x00000100)
#define WTP_FIELD_HANDLE                        (0x00000200)
#define WTP_FIELD_ABORTCODE                     (0x00000400)
#define WTP_FIELD_TRANSACTIONSECURITYLEVEL      (0x00000800)

// WAP layers
enum WAP_LAYER
    {
    WAP_LAYER_WDP = 1,
    WAP_LAYER_WTLS,
    WAP_LAYER_WTP,
    WAP_LAYER_WSP,
    WAP_LAYER_WAE,
    };

// WAP primitives
enum WAP_PRIMITIVE_ID
    {
    WAP_PRIMITIVE_ID_T_DUNITDATA = 1,
/*
    WAP_PRIMITIVE_ID_T_DERROR,
*/
    WAP_PRIMITIVE_ID_TR_INVOKE,
    WAP_PRIMITIVE_ID_TR_RESULT,
    WAP_PRIMITIVE_ID_TR_ABORT,
    };

// WAP primitive type
enum WAP_PRIMITIVE_TYPE
    {
    WAP_PRIMITIVE_TYPE_REQUEST = 1,
    WAP_PRIMITIVE_TYPE_INDICATION,
    WAP_PRIMITIVE_TYPE_RESPONSE,
    WAP_PRIMITIVE_TYPE_CONFIRM,
    };

// WAP address types
enum WAP_ADDRESS_TYPE
    {
    WAP_ADDRESS_TYPE_UDP = 1,
    WAP_ADDRESS_TYPE_GSM_SMS,
    };

// WAP address structure
typedef struct WAP_ADDRESS_tag
    {
    WAP_ADDRESS_TYPE watAddressType;
    TCHAR ptsAddress[MAX_WAP_ADDRESS_LENGTH];
    } WAP_ADDRESS;

typedef DWORD WAP_HANDLE;

// WTP transaction class types
enum WTP_TRANSACTION_CLASS_TYPE
    {
    WTP_TRANSACTION_CLASS_TYPE_0 = 1,
    WTP_TRANSACTION_CLASS_TYPE_1,
    WTP_TRANSACTION_CLASS_TYPE_2,
    };

// WTP secure transaction (WTLS) security levels
enum WTP_TRANSACTION_SECURITY_LEVEL
    {
    WTP_TRANSACTION_SECURITY_LEVEL_NOTSECURE = 1,  // Not a secure connection
    WTP_TRANSACTION_SECURITY_LEVEL_SECURENOAUTH,   // Secure with no authentication
    WTP_TRANSACTION_SECURITY_LEVEL_GATEWAYAUTH,    // Secure with gateway authentication
    };

typedef LONG WTP_TRANSACTION_HANDLE;
#define INVALID_WTP_TRANSACTION_HANDLE (0)

//
// WAP primitives
//

// Base primitive type - all other primitive types derive from this one
typedef struct wap_primitive_base_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;     // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType; // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                 // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    } WAP_PRIMITIVE_BASE;

// T-DUnitdata primitive (WDP)
typedef struct wdp_unitdata_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;     // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType; // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                 // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    WAP_ADDRESS waSourceAddress;
    DWORD dwSourcePort;
    WAP_ADDRESS waDestinationAddress;
    DWORD dwDestinationPort;
    const BYTE* pbUserData;
    DWORD dwUserDataSize;
    } WDP_UNITDATA;

/*
// T-DError primitive (WDP)
typedef struct wap_primitive_t_derror_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;     // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType; // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                 // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    WAP_ADDRESS waSourceAddress;
    DWORD dwSourcePort;
    WAP_ADDRESS waDestinationAddress;
    DWORD dwDestinationPort;
    HRESULT hrErrorCode;
    } WAP_PRIMITIVE_T_DERROR;
*/

// TR-Invoke primitive (WTP)
typedef struct wtp_invoke_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;      // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType;  // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                  // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    WAP_ADDRESS waSourceAddress;
    DWORD dwSourcePort;
    WAP_ADDRESS waDestinationAddress;
    DWORD dwDestinationPort;
    BOOL bUserAcknowledgement;
    BOOL bWantSecureTransaction;
    const BYTE* pbUserData;
    DWORD dwUserDataSize;
    WTP_TRANSACTION_CLASS_TYPE wtctClassType;
    const BYTE* pbExitInfo;
    DWORD dwExitInfoSize;
    WTP_TRANSACTION_HANDLE wthTransactionHandle;
    } WTP_INVOKE;

// TR-Result primitive (WTP)
typedef struct wtp_result_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;      // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType;  // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                  // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    const BYTE* pbUserData;
    DWORD dwUserDataSize;
    const BYTE* pbExitInfo;
    DWORD dwExitInfoSize;
    WTP_TRANSACTION_HANDLE wthTransactionHandle;
    WTP_TRANSACTION_SECURITY_LEVEL wtslTransactionSecurityLevel;
    } WTP_RESULT;

// TR-Abort primitive (WTP)
typedef struct wtp_abort_tag
    {
    WAP_PRIMITIVE_ID wpiPrimitiveID;      // One of WAP_PRIMITIVE_ID_* - Always present and valid
    WAP_PRIMITIVE_TYPE wptPrimitiveType;  // One of WAP_PRIMITIVE_TYPE_* -- always present and valid
    DWORD dwValidFields;                  // One of *_FIELD_*, depending on wpiPrimitiveID - Always present and valid
    BYTE bAbortCode;
    WTP_TRANSACTION_HANDLE wthTransactionHandle;
    } WTP_ABORT;


// APIs

HRESULT WapOpen
    (
    const WAP_LAYER wlLayer,
    const DWORD dwLocalPort,
    WAP_HANDLE* const pwhHandle,
    HANDLE* const phMessageAvailableEvent
    );

HRESULT WapClose
    (
    const WAP_HANDLE whHandle
    );

HRESULT WapSend
    (
    const WAP_HANDLE whHandle,
    WAP_PRIMITIVE_BASE* const pwpbPrimitive
    );

HRESULT WapGetNextPrimitiveSize
    (
    const WAP_HANDLE whHandle,
    DWORD* const pdwNextPrimitiveSize
    );

HRESULT WapRead
    (
    const WAP_HANDLE whHandle,
    __out_bcount(dwPrimitiveBufferSize) WAP_PRIMITIVE_BASE* const pwpbPrimitiveBuffer,
    const DWORD dwPrimitiveBufferSize
    );

HRESULT WapPing
    (
    const WAP_ADDRESS* const pwaAddress,
    const WORD wIdentifier,
    const DWORD dwSendDataSize,
    DWORD* const pdwReceiveDataSize,
    const DWORD dwTimeout
    );


#endif // _WAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wfpalign.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Defines Alignment for MIPSIV - CE only file
*/
#ifndef _WFPALIGNH
#define _WFPALIGNH
#include "crtdefs.h"

typedef UINT64 UNALIGNED UNALIGNEDUINT64;

#endif // _WFPALIGNH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\webevnts.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:16:12 2007
 */
/* Compiler settings for ..\webevnts.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __webevnts_h__
#define __webevnts_h__

/* Forward Declarations */ 

#ifndef __IWebBrowserEventsService_FWD_DEFINED__
#define __IWebBrowserEventsService_FWD_DEFINED__
typedef interface IWebBrowserEventsService IWebBrowserEventsService;
#endif 	/* __IWebBrowserEventsService_FWD_DEFINED__ */


#ifndef __IWebBrowserEventsUrlService_FWD_DEFINED__
#define __IWebBrowserEventsUrlService_FWD_DEFINED__
typedef interface IWebBrowserEventsUrlService IWebBrowserEventsUrlService;
#endif 	/* __IWebBrowserEventsUrlService_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_webevnts_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// webevnts.h
//=--------------------------------------------------------------------------=
// (C) Copyright 2005-2008 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IWebBrowserEventsService and IWebBrowserUrlForEvents Interfaces.



#ifndef _LPWEBEVNTS_DEFINED
#define _LPWEBEVNTS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_v0_0_s_ifspec;

#ifndef __IWebBrowserEventsService_INTERFACE_DEFINED__
#define __IWebBrowserEventsService_INTERFACE_DEFINED__

/* interface IWebBrowserEventsService */
/* [object][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserEventsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54A8F188-9EBD-4795-AD16-9B4945119636")
    IWebBrowserEventsService : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireBeforeNavigate2Event( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfCancel) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireNavigateComplete2Event( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDownloadBeginEvent( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDownloadCompleteEvent( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDocumentCompleteEvent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserEventsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowserEventsService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireBeforeNavigate2Event )( 
            IWebBrowserEventsService __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfCancel);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireNavigateComplete2Event )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireDownloadBeginEvent )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireDownloadCompleteEvent )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireDocumentCompleteEvent )( 
            IWebBrowserEventsService __RPC_FAR * This);
        
        END_INTERFACE
    } IWebBrowserEventsServiceVtbl;

    interface IWebBrowserEventsService
    {
        CONST_VTBL struct IWebBrowserEventsServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserEventsService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowserEventsService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowserEventsService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowserEventsService_FireBeforeNavigate2Event(This,pfCancel)	\
    (This)->lpVtbl -> FireBeforeNavigate2Event(This,pfCancel)

#define IWebBrowserEventsService_FireNavigateComplete2Event(This)	\
    (This)->lpVtbl -> FireNavigateComplete2Event(This)

#define IWebBrowserEventsService_FireDownloadBeginEvent(This)	\
    (This)->lpVtbl -> FireDownloadBeginEvent(This)

#define IWebBrowserEventsService_FireDownloadCompleteEvent(This)	\
    (This)->lpVtbl -> FireDownloadCompleteEvent(This)

#define IWebBrowserEventsService_FireDocumentCompleteEvent(This)	\
    (This)->lpVtbl -> FireDocumentCompleteEvent(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsService_FireBeforeNavigate2Event_Proxy( 
    IWebBrowserEventsService __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfCancel);


void __RPC_STUB IWebBrowserEventsService_FireBeforeNavigate2Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsService_FireNavigateComplete2Event_Proxy( 
    IWebBrowserEventsService __RPC_FAR * This);


void __RPC_STUB IWebBrowserEventsService_FireNavigateComplete2Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsService_FireDownloadBeginEvent_Proxy( 
    IWebBrowserEventsService __RPC_FAR * This);


void __RPC_STUB IWebBrowserEventsService_FireDownloadBeginEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsService_FireDownloadCompleteEvent_Proxy( 
    IWebBrowserEventsService __RPC_FAR * This);


void __RPC_STUB IWebBrowserEventsService_FireDownloadCompleteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsService_FireDocumentCompleteEvent_Proxy( 
    IWebBrowserEventsService __RPC_FAR * This);


void __RPC_STUB IWebBrowserEventsService_FireDocumentCompleteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowserEventsService_INTERFACE_DEFINED__ */


#ifndef __IWebBrowserEventsUrlService_INTERFACE_DEFINED__
#define __IWebBrowserEventsUrlService_INTERFACE_DEFINED__

/* interface IWebBrowserEventsUrlService */
/* [object][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserEventsUrlService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("87CC5D04-EAFA-4833-9820-8F986530CC00")
    IWebBrowserEventsUrlService : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetUrlForEvents( 
            /* [retval][out] */ BSTR __RPC_FAR *pUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserEventsUrlServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowserEventsUrlService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowserEventsUrlService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowserEventsUrlService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUrlForEvents )( 
            IWebBrowserEventsUrlService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pUrl);
        
        END_INTERFACE
    } IWebBrowserEventsUrlServiceVtbl;

    interface IWebBrowserEventsUrlService
    {
        CONST_VTBL struct IWebBrowserEventsUrlServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserEventsUrlService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowserEventsUrlService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowserEventsUrlService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowserEventsUrlService_GetUrlForEvents(This,pUrl)	\
    (This)->lpVtbl -> GetUrlForEvents(This,pUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IWebBrowserEventsUrlService_GetUrlForEvents_Proxy( 
    IWebBrowserEventsUrlService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pUrl);


void __RPC_STUB IWebBrowserEventsUrlService_GetUrlForEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowserEventsUrlService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_webevnts_0083 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_webevnts_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webevnts_0083_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\winceerr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/************************************************************************
*                                                                       *
*   winceerr.h --  error code ranges used with FACILITY_WINDOWS_CE      *
*                                                                       *
*                                                                       *
************************************************************************/

#ifndef _WINCEERR_
#define _WINCEERR_

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif

// Unless otherwise specified, ranges should be considered to cover 0x40 codes

#define UPDERROR_BASE       0x0000  // See public\common\oak\inc\upderrors.h

#define MA_ML_BASE          0x0200  // MediaApps Media Library (see public\mediaapps\MLErrorCodes.h)

#define MA_CAMCAP_BASE      0x0300  // MediaApps SHCameraCaptureEx (see public\mediaapps\sdk\inc\CAMErrorCodes.h

#define UPDSUCCESS_BASE     0x1000  // See public\common\oak\inc\upderrors.h

#define WINCEPRIV_BASE      0x8000  // Codes from 0x8000-0xFFFF are used by private Windows CE code

#endif//_WINCEERR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\winber.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    winber.h   Basic Encoding Rules (BER) API header file

Abstract:

   This module is the header file for the 32 bit BER library on
   Windows NT, Windows 95 and Windows CE.

Updates :

Environments :

    Win32 user mode

--*/

//
// Only pull in this header file once.
//

#ifndef _WINBER_DEFINED_
#define _WINBER_DEFINED_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WINBER_)
#define WINBERAPI DECLSPEC_IMPORT
#else
//#define WINBERAPI __declspec(dllexport)
#define WINBERAPI
#endif

#ifndef BERAPI
#define BERAPI __cdecl
#endif

#define LBER_ERROR   0xffffffffL
#define LBER_DEFAULT 0xffffffffL

typedef unsigned int ber_tag_t;   /* for BER tags */
typedef int ber_int_t;            /* for BER ints, enums, and Booleans */
typedef unsigned int ber_uint_t;  /* unsigned equivalent of ber_int_t */
typedef int ber_slen_t;           /* signed equivalent of ber_len_t */

//
// This constructs a new BerElement structure containing a copy of the
// data in the supplied berval structure.
//

WINBERAPI BerElement * BERAPI ber_init( BERVAL *pBerVal );

//
// This frees a BerElement which is returned from ber_alloc_t()
// or ber_init(). The second argument - fbuf should always be set
// to 1.
//
//

WINBERAPI VOID BERAPI ber_free( BerElement *pBerElement, INT fbuf );

//
// Frees a BERVAL structure. Applications should not call
// this API to free BERVAL structures which they themselves
// have allocated
//

WINBERAPI VOID BERAPI ber_bvfree( BERVAL *pBerVal );


//
// Frees an array of BERVAL structures.
//

WINBERAPI VOID BERAPI ber_bvecfree( PBERVAL *pBerVal );

//
// Returns a copy of a the supplied berval structure
//

WINBERAPI BERVAL * BERAPI ber_bvdup( BERVAL *pBerVal );


//
// Constructs and returns a BerElement structure. The options field
// contains a bitwise-or of options which are to be used when generating
// the encoding of the BerElement
//
// The LBER_USE_DER options should always be specified.
//

WINBERAPI BerElement * BERAPI ber_alloc_t( INT options );


//
// This skips over the current tag and returns the tag of the next
// element in the supplied BerElement. The length of this element is
// stored in the pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
// The difference between ber_skip_tag() and ber_peek_tag() is that the
// state pointer is advanced past the first tag+length and is pointed to
// the value part of the next element
//

WINBERAPI ULONG BERAPI ber_skip_tag( BerElement *pBerElement, ULONG *pLen );

//
// This returns the tag of the next element to be parsed in the
// supplied BerElement. The length of this element is stored in the
// pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//

WINBERAPI ULONG BERAPI ber_peek_tag( BerElement *pBerElement, ULONG *pLen);

//
// This returns the tag and length of the first element in a SET, SET OF
// or SEQUENCE OF data value.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned. It also returns an opaque cookie which has to be passed to
// subsequent invocations of ber_next_element().
//

WINBERAPI ULONG BERAPI ber_first_element( BerElement *pBerElement, ULONG *pLen, CHAR **ppOpaque );

//
// This positions the state at the start of the next element in the
// constructed type.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned.
//

WINBERAPI ULONG BERAPI ber_next_element( BerElement *pBerElement, ULONG *pLen, CHAR *opaque );

//
// This allocates a BerVal structure whose contents are taken from the
// supplied BerElement structure.
//
// The return values are 0 on success and -1 on error.
//

WINBERAPI INT BERAPI ber_flatten( BerElement *pBerElement, PBERVAL *pBerVal );


/*
The ber_printf() routine is used to encode a BER element in much the
same way that sprintf() works.  One important difference, though, is
that state information is kept in the ber argument so that multiple
calls can be made to ber_printf() to append to the end of the BER ele-
ment. ber MUST be a pointer to a BerElement returned by ber_alloc_t().
ber_printf() interprets and formats its arguments according to the for-
mat string fmt.  ber_printf() returns -1 if there is an error during
encoding and a non-negative number if successful.  As with sprintf(),
each character in fmt refers to an argument to ber_printf().
 
The format string can contain the following format characters:

't'     Tag.  The next argument is a ber_tag_t specifying the tag to
        override the next element to be written to the ber.  This works
        across calls.  The integer tag value SHOULD contain the tag
        class, constructed bit, and tag value.  For example, a tag of
        "[3]" for a constructed type is 0xA3U.  All implementations MUST
        support tags that fit in a single octet (i.e., where the tag
        value is less than 32) and they MAY support larger tags.

'b'     Boolean.  The next argument is an ber_int_t, containing either 0
        for FALSE or 0xff for TRUE.  A boolean element is output.  If
        this format character is not preceded by the 't' format modif-
        ier, the tag 0x01U is used for the element.

'e'     Enumerated.  The next argument is a ber_int_t, containing the
        enumerated value in the host's byte order.  An enumerated ele-
        ment is output.  If this format character is not preceded by the
        't' format modifier, the tag 0x0AU is used for the element.

'i'     Integer.  The next argument is a ber_int_t, containing the
        integer in the host's byte order.  An integer element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x02U is used for the element.

'n'     Null.  No argument is needed.  An ASN.1 NULL element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x05U is used for the element.
        
'o'     Octet string.  The next two arguments are a char *, followed by
        a ber_len_t with the length of the string.  The string MAY con-
        tain null bytes and are do not have to be zero-terminated.   An
        octet string element is output, in primitive form.  If this for-
        mat character is not preceded by the 't' format modifier, the
        tag 0x04U is used for the element.

's'     Octet string.  The next argument is a char * pointing to a
        zero-terminated string.  An octet string element in primitive
        form is output, which does not include the trailing '\0' (null)
        byte. If this format character is not preceded by the 't' format
        modifier, the tag 0x04U is used for the element.

'v'     Several octet strings.  The next argument is a char **, an array
        of char * pointers to zero-terminated strings.  The last element
        in the array MUST be a NULL pointer. The octet strings do not
        include the trailing '\0' (null) byte.  Note that a construct
        like '{v}' is used to get an actual SEQUENCE OF octet strings.
        The 't' format modifier cannot be used with this format charac-
        ter.

'V'     Several octet strings.  A NULL-terminated array of struct berval
        *'s is supplied.  Note that a construct like '{V}' is used to
        get an actual SEQUENCE OF octet strings. The 't' format modifier
        cannot be used with this format character.

'{'     Begin sequence.  No argument is needed.  If this format charac-
        ter is not preceded by the 't' format modifier, the tag 0x30U is
        used.

'}'     End sequence.  No argument is needed.  The 't' format modifier
        cannot be used with this format character.

'['     Begin set.  No argument is needed.  If this format character is
        not preceded by the 't' format modifier, the tag 0x31U is used.

']'     End set.  No argument is needed.  The 't' format modifier cannot
        be used with this format character.
*/

WINBERAPI INT BERAPI ber_printf( BerElement *pBerElement, PCHAR fmt, ... );

/*
The ber_scanf() routine is used to decode a BER element in much the same
way that sscanf() works.  One important difference, though, is that some
state information is kept with the ber argument so that multiple calls
can be made to ber_scanf() to sequentially read from the BER element.
The ber argument SHOULD be a pointer to a BerElement returned by
ber_init().  ber_scanf interprets the bytes according to the format
string fmt, and stores the results in its additional arguments.
ber_scanf() returns LBER_ERROR on error, and a different value on suc-
cess.

The format string contains conversion specifications which are used to
direct the interpretation of the BER element.  The format string can
contain the following characters:

'a'     Octet string.  A char ** argument MUST be supplied.  Memory is
        allocated, filled with the contents of the octet string, zero-
        terminated, and the pointer to the string is stored in the argu-
        ment.  The returned value SHOULD be freed using ldap_memfree.
        The tag of the element MUST indicate the primitive form
        (constructed strings are not supported) but is otherwise ignored
        and discarded during the decoding.  This format cannot be used
        with octet strings which could contain null bytes.        
        
'O'     Octet string.  A struct berval ** argument MUST be supplied,
        which upon return points to an allocated struct berval contain-
        ing the octet string and its length.  ber_bvfree() SHOULD be
        called to free the allocated memory.  The tag of the element
        MUST indicate the primitive form (constructed strings are not
        supported) but is otherwise ignored during the decoding.

'b'     Boolean.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be 0 for FALSE or nonzero for TRUE.
        The tag of the element MUST indicate the primitive form but is
        otherwise ignored during the decoding.

'e'     Enumerated.  A pointer to a ber_int_t MUST be supplied. The
        enumerated value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the value of the enumerated value cannot be stored in a
        ber_int_t.

'i'     Integer.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the integer cannot be stored in a ber_int_t.

'B'     Bitstring.  A char ** argument MUST be supplied which will point
        to the allocated bits, followed by a ber_len_t * argument, which
        will point to the length (in bits) of the bitstring returned.
        ldap_memfree SHOULD be called to free the bitstring.  The tag of
        the element MUST indicate the primitive form (constructed bit-
        strings are not supported) but is otherwise ignored during the
        decoding.

'n'     Null.  No argument is needed.  The element is verified to have a
        zero-length value and is skipped.  The tag is ignored.

'v'     Several octet strings.  A char *** argument MUST be supplied,
        which upon return points to an allocated NULL-terminated array
        of char *'s containing the octet strings.  NULL is stored if the
        sequence is empty.  ldap_memfree SHOULD be called to free each
        element of the array and the array itself.  The tag of the
        sequence and of the octet strings are ignored.

'V'     Several octet strings (which could contain null bytes).  A
        struct berval *** MUST be supplied, which upon return points to
        a allocated NULL-terminated array of struct berval *'s contain-
        ing the octet strings and their lengths.  NULL is stored if the
        sequence is empty. ber_bvecfree() can be called to free the
        allocated memory.  The tag of the sequence and of the octet
        strings are ignored.

'x'     Skip element.  The next element is skipped.  No argument is
        needed.

'{'     Begin sequence.  No argument is needed.  The initial sequence
        tag and length are skipped.

'}'     End sequence.  No argument is needed.

'['     Begin set.  No argument is needed.  The initial set tag and
        length are skipped.

']'     End set.  No argument is needed.

*/

WINBERAPI ULONG BERAPI ber_scanf( BerElement *pBerElement, PCHAR fmt, ... );


#ifdef __cplusplus
}
#endif


#endif  // _WINBER_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\winbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++


Module Name: winbase.h

Purpose:This header file declares the Base APIs.

--*/

#pragma once

#ifndef __WINBASE_H__
#define __WINBASE_H__
#define _WINBASE_

//
// Define API decoration for direct importing of DLL references.
//

#if defined (_M_CEE)
#   if defined(_ADVAPI32_) || defined(COREDLL)
#       pragma message (__FILE__ ": CEF not supported for building COREDLL contents")
#   endif
#endif // _M_CEE UNDER_CE

#if !defined(_ADVAPI32_) && !defined(_SYSCRT_)
#define WINADVAPI  DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#if !defined(COREDLL) && !defined(_SYSCRT_)
#define WINBASEAPI DECLSPEC_IMPORT
#else
#define WINBASEAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <windef.h>
#include <winver.h>

#define MAX_COMPUTERNAME_LENGTH 15
#define INVALID_HANDLE_VALUE (HANDLE)-1
#define INVALID_FILE_SIZE (DWORD)0xFFFFFFFF
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)

#define FILE_BEGIN           0
#define FILE_CURRENT         1
#define FILE_END             2
//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *LPSYSTEMTIME;

#ifdef MIPS_R4000 /* or above */

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange

LONG
WINAPI
InterlockedIncrement(
    LONG volatile *lpAddend
    );

LONG
WINAPI
InterlockedDecrement(
    LONG volatile *lpAddend
    );

LONG
WINAPI
InterlockedExchange(
    LONG volatile *Target,
    LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)

#define InterlockedCompareExchange(ptr, newval, oldval) \
    ((PVOID)InterlockedTestExchange((LONG volatile *)(ptr), (LONG)(oldval), (LONG) (newval)))

#elif defined(_X86_)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

LONG
WINAPI
InterlockedIncrement(
    LONG volatile *lpAddend
    );

LONG
WINAPI
InterlockedDecrement(
    LONG volatile *lpAddend
    );

LONG
WINAPI
InterlockedExchange(
    LONG volatile *Target,
    LONG Value
    );

LONG
WINAPI
InterlockedCompareExchange(
    LONG volatile *Target,
    LONG Exchange,
    LONG Comperand
    );

LONG
WINAPI
InterlockedExchangeAdd(
    LONG volatile *lpAddend,
    LONG  Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)

#define InterlockedTestExchange(Target, oldValue, newValue) \
    InterlockedCompareExchange((Target), (newValue), (oldValue))


#else // not _X86_

LONG
WINAPI
InterlockedIncrement(
    LONG volatile *lpAddend
    );


LONG
WINAPI
InterlockedDecrement(
    LONG volatile *lpAddend
    );


LONG
WINAPI
InterlockedExchange(
    LONG volatile *Target,
    LONG Value
    );

LONG
WINAPI
InterlockedCompareExchange(
    LONG volatile *Target,
    LONG Exchange,
    LONG Comperand
    );

LONG
WINAPI
InterlockedExchangeAdd(
    LONG volatile *lpAddend,
    LONG Value
    );


#define InterlockedTestExchange(Target, oldValue, newValue) \
    InterlockedCompareExchange((Target), (newValue), (oldValue))

#endif

#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
    ((PVOID)InterlockedExchange((LONG volatile *)(Target), (LONG)(Value)))
#endif

#ifndef InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    ((PVOID)InterlockedCompareExchange((LONG volatile *)(Destination), (LONG)(ExChange), (LONG)(Comperand)))
#endif

#define MAXINTATOM 0xC000
#define MAKEINTATOM(i)  (LPTSTR)((DWORD)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)

DWORD
WINAPI
Random();

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
#ifdef UNDER_CE
    LPWSTR lpCmdLine,
#else
    LPSTR lpCmdLine,
#endif
    int nShowCmd
    );

LONG WINAPI CompareFileTime(const FILETIME *lpft1, const FILETIME *lpft2);
BOOL WINAPI FileTimeToSystemTime(const FILETIME *lpft, LPSYSTEMTIME lpst);
BOOL WINAPI SystemTimeToFileTime(const SYSTEMTIME *lpst, LPFILETIME lpft);
BOOL WINAPI FileTimeToLocalFileTime(const FILETIME *lpft, LPFILETIME lpftLocal);
BOOL WINAPI LocalFileTimeToFileTime(const FILETIME *lpftLocal, LPFILETIME lpft);

// Internal API for the file system
VOID GetCurrentFT(LPFILETIME lpFileTime);

/* Derived from process.h file from Windows NT */
BOOL
WINAPI
DllMain (
    HANDLE hinstDLL,
    DWORD dwReason,
    LPVOID lpvReserved
    );

#ifdef UNDER_CE
#define GetProcAddress GetProcAddressW

WINBASEAPI
FARPROC
WINAPI
GetProcAddressW(
    __in HMODULE hModule,
    __in LPCWSTR lpProcName
    );

WINBASEAPI
FARPROC
WINAPI
GetProcAddressA(
    __in HMODULE hModule,
    __in LPCSTR lpProcName
    );

#else

WINBASEAPI
FARPROC
WINAPI
GetProcAddress(
    __in HMODULE hModule,
    __in LPCSTR lpProcName
    );

#endif

WINBASEAPI
int
WINAPI
MulDiv(
    IN int nNumber,
    IN int nNumerator,
    IN int nDenominator
    );

VOID
WINAPI
GetLocalTime (
    __out LPSYSTEMTIME lpSystemTime
    );

VOID
WINAPI
GetSystemTime (
    __out LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetSystemTimeAsFileTime(
    __out LPFILETIME lpSystemTimeAsFileTime
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

#define INVALID_TIMEZONE_ID 0xFFFFFFFF

typedef struct _TIME_ZONE_INFORMATION_WITH_ID {
    UINT uId;
    TIME_ZONE_INFORMATION tzi;
    WCHAR DisplayName[ 70 ];
    WCHAR ReferenceName[ 64 ];
} TIME_ZONE_INFORMATION_WITH_ID, *LPTIME_ZONE_INFORMATION_WITH_ID;

DWORD
WINAPI
GetTimeZoneInformation (
    __out LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

BOOL
WINAPI
SetLocalTime (
    __in CONST SYSTEMTIME *lpSystemTime
    );

BOOL
WINAPI
SetSystemTime (
    __in CONST SYSTEMTIME *lpSystemTime
    );

// @CESYSGEN IF !SERVERS_MODULES_DSTSVC 
// @CESYSGEN ENDIF

BOOL
WINAPI
SetTimeZoneInformation (
    __in CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );

BOOL
WINAPI
SetTimeZoneInformationByID (
    __in UINT nID
    );

UINT
WINAPI
GetTimeZoneInformationID (void);

UINT
WINAPI
GetTimeZoneList (
    __in TIME_ZONE_INFORMATION_WITH_ID *rgTimeZoneList,
    __in UINT cTimeZoneList
    );

/*
    @doc BOTH EXTERNAL

    @func LPTSTR | lstrcat| Appends one string to another.
    @parm LPTSTR | lpszString1 | address of buffer for concatenated strings
    @parm LPTSTR | lpszString2 | address of string to add to string1

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.

*/
WINBASEAPI
LPSTR
WINAPI
lstrcatA(
    __inout LPSTR lpString1,
    __in LPCSTR lpString2
    );

#define lstrcatW wcscat
#ifdef UNICODE
#define lstrcat lstrcatW
#else
#define lstrcat lstrcatA
#endif

/*
    @doc BOTH EXTERNAL

    @func int | lstrcmp| Compares two character strings. The comparison is case sensitive.
    @parm LPTSTR | lpszString1 | address of first string
    @parm LPTSTR | lpszString2 | address of second string

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.

*/

WINBASEAPI
int
WINAPI
lstrcmpA(
    __in LPCSTR lpString1,
    __in LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpW(
    __in LPCWSTR lpString1,
    __in LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmp  lstrcmpW
#else
#define lstrcmp  lstrcmpA
#endif // !UNICODE

/*
    @doc BOTH EXTERNAL

    @func int | lstrcmpi| Compares two character strings. The comparison is
    not case sensitive.
    @parm LPTSTR | lpszString1 | address of first string
    @parm LPTSTR | lpszString2 | address of second string

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.

*/

WINBASEAPI
int
WINAPI
lstrcmpiA(
    __in LPCSTR lpString1,
    LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpiW(
    __in LPCWSTR lpString1,
    __in LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmpi  lstrcmpiW
#else
#define lstrcmpi  lstrcmpiA
#endif // !UNICODE

/*
    @doc BOTH EXTERNAL

    @func LPTSTR | lstrcpy| Copies a string to a buffer.
    @parm LPTSTR | lpszString1 | address of buffer
    @parm LPTSTR | lpszString2 | address of string to copy

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.

*/
WINBASEAPI
LPSTR
WINAPI
lstrcpyA(
    __out LPSTR lpString1,
    __in LPCSTR lpString2
    );
#define lstrcpyW wcscpy
#ifdef UNICODE
#define lstrcpy lstrcpyW
#else
#define lstrcpy lstrcpyA
#endif

/*
    @doc BOTH EXTERNAL

    @func int | lstrlen| The lstrlen function returns the length, in characters, of
    the specified string (not including the terminating null character).
    @parm LPTSTR | lpszString | address of string to count

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.

*/
WINBASEAPI
int
WINAPI
lstrlenA(
    __in LPCSTR lpString
    );
#define lstrlenW wcslen
#ifdef UNICODE
#define lstrlen lstrlenW
#else
#define lstrlen lstrlenA
#endif

DWORD
WINAPI
CharLowerBuffA (
    __inout_opt LPSTR lpsz,
    DWORD cchLength
    );
DWORD
WINAPI
CharLowerBuffW (
    __out_opt LPWSTR lpsz,
    DWORD cchLength
    );
#ifdef UNICODE
#define CharLowerBuff CharLowerBuffW
#else
#define CharLowerBuff CharLowerBuffA
#endif

DWORD
WINAPI
CharUpperBuffA (
    __inout_opt LPSTR lpsz,
    DWORD cchLength
    );
DWORD
WINAPI
CharUpperBuffW (
    __out_opt LPWSTR lpsz,
    DWORD cchLength
    );
#ifdef UNICODE
#define CharUpperBuff CharUpperBuffW
#else
#define CharUpperBuff CharUpperBuffA
#endif

LPSTR WINAPI CharLowerA(__inout LPSTR lpsz);
LPWSTR WINAPI CharLowerW(__inout LPWSTR lpsz);

#ifdef UNICODE
#define CharLower CharLowerW
#else
#define CharLower CharLowerA
#endif

LPSTR WINAPI CharUpperA(__inout LPSTR lpsz);
LPWSTR WINAPI CharUpperW(__inout LPWSTR lpsz);

#ifdef UNICODE
#define CharUpper CharUpperW
#else
#define CharUpper CharUpperA
#endif

LPSTR
WINAPI
CharPrevA(
    __in LPCSTR lpszStart,
    __in LPCSTR lpszCurrent);

LPWSTR
WINAPI
CharPrevW(
    __in LPCWSTR lpszStart,
    __in LPCWSTR lpszCurrent);

#ifdef UNICODE
#define CharPrev  CharPrevW
#else
#define CharPrev  CharPrevA
#endif // !UNICODE

LPSTR
WINAPI
CharNextA(
    LPCSTR __in lpsz);

LPWSTR
WINAPI
CharNextW(
    LPCWSTR __in lpsz);

#ifdef UNICODE
#define CharNext  CharNextW
#else
#define CharNext  CharNextA
#endif // !UNICODE



/*
    @doc BOTH EXTERNAL

    @func BOOL | IsCharAlpha| Determines whether a character is an alphabetic character.
    @parm TCHAR | ch | character to test

    @comm Follows the Win32 reference description without restrictions or modifications.
*/

#define IsCharAlphaA isalpha
#define IsCharAlphaW iswalpha
#ifdef UNICODE
#define IsCharAlpha IsCharAlphaW
#else
#define IsCharAlpha IsCharAlphaA
#endif


/*
    @doc BOTH EXTERNAL

    @func BOOL | IsCharAlphaNumericW| Determines whether a character is either an
    alphabetic or a numeric character.

    @comm Follows the Win32 reference description without restrictions or modifications.
*/

#define IsCharAlphaNumericA isalnum
#define IsCharAlphaNumericW iswalnum
#ifdef UNICODE
#define IsCharAlphaNumeric IsCharAlphaNumericW
#else
#define IsCharAlphaNumeric IsCharAlphaNumericA
#endif

/*
    @doc BOTH EXTERNAL

    @func BOOL | IsCharLower | Determines whether a character is lowercase.
    @parm TCHAR | ch | character to test

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.
*/

#define IsCharLowerA islower
#define IsCharLowerW iswlower
#ifdef UNICODE
#define IsCharLower IsCharLowerW
#else
#define IsCharLower IsCharLowerA
#endif

/*
    @doc BOTH EXTERNAL

    @func BOOL | IsCharUpper | Determines whether a character is uppercase.
    @parm TCHAR | ch | character to test

    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.
*/

#define IsCharUpperA isupper
#define IsCharUpperW iswupper
#ifdef UNICODE
#define IsCharUpper IsCharUpperW
#else
#define IsCharUpper IsCharUpperA
#endif

#include <stdarg.h>

int
WINAPIV
wsprintfA (
    __inout LPSTR,
    __in __format_string LPCSTR,
    ...
    );
int
WINAPIV
wsprintfW (
    __inout LPWSTR,
    __in __format_string LPCWSTR,
    ...
    );

#ifdef UNICODE
#define wsprintf wsprintfW
#else
#define wsprintf wsprintfA
#endif

int
WINAPI
wvsprintfA (
    __inout LPSTR,
    __in __format_string LPCSTR,
    __in va_list arglist
    );

int
WINAPI
wvsprintfW (
    __inout LPWSTR,
    __in __format_string LPCWSTR,
    __in va_list arglist
    );

#ifdef UNICODE
#define wvsprintf wvsprintfW
#else
#define wvsprintf wvsprintfA
#endif

#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010       /**** Used for Moveable Memory  ***/
#define LMEM_NODISCARD      0x0020       /**** Ignored *****/
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080       /*** Used only in LocalReAlloc() **/
#define LMEM_DISCARDABLE    0x0F00       /**** Ignored ****/
#define LMEM_VALID_FLAGS    0x0F72
#define LMEM_INVALID_HANDLE 0x8000
#define LMEM_DDESHARE       0x0000       /**** Ignored ****/
#define LMEM_LOWER          0x0000       /**** Ignored ****/
#define LMEM_NOT_BANKED     0x0000       /**** Ignored ****/
#define LMEM_NOTIFY         0x0000       /**** Ignored ****/
#define LMEM_SHARE          0x0000       /**** Ignored ****/

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

#ifdef UNDER_CE
#define GMEM_FIXED          LMEM_FIXED
#define GMEM_MOVEABLE       LMEM_MOVEABLE
#define GPTR                LPTR
#define GHND                LHND
#define GMEM_DDESHARE       LMEM_DDESHARE
#define GMEM_DISCARDABLE    LMEM_DISCARDABLE
#define GMEM_LOWER          LMEM_LOWER
#define GMEM_NOCOMPACT      LMEM_NOCOMPACT
#define GMEM_NODISCARD      LMEM_NODISCARD
#define GMEM_NOT_BANKED     LMEM_NOT_BANKED
#define GMEM_NOTIFY         LMEM_NOTIFY
#define GMEM_SHARE          LMEM_SHARE
#define GMEM_ZEROINIT       LMEM_ZEROINIT
#endif

typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORD dwTotalPhys;
    DWORD dwAvailPhys;
    DWORD dwTotalPageFile;
    DWORD dwAvailPageFile;
    DWORD dwTotalVirtual;
    DWORD dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

VOID
WINAPI
GlobalMemoryStatus(
    __inout LPMEMORYSTATUS lpBuffer
    );

#ifdef UNDER_CE
#define LocalLock(X) ((LPVOID)(X))
#define LocalUnlock(X) (0)
#define LocalHandle(X) ((HLOCAL)(X))
#define LocalFlags(X) (0)
#else
WINBASEAPI
LPVOID
WINAPI
LocalLock(
    __in HLOCAL hMem
    );

WINBASEAPI
BOOL
WINAPI
LocalUnlock(
    __in HLOCAL hMem
    );

WINBASEAPI
HLOCAL
WINAPI
LocalHandle(
    __in LPCVOID pMem
    );

WINBASEAPI
UINT
WINAPI
LocalFlags(
    __in HLOCAL hMem
    );
#endif

HLOCAL
WINAPI
LocalAlloc (
    UINT fuFlags,
    UINT cbBytes
    );
HLOCAL
WINAPI
LocalAllocTrace (
    UINT fuFlags,
    UINT cbBytes,
    UINT cLineNum,
    LPCWSTR szFilename
    );

#if defined(DEBUG) || defined(LMEM_DEBUG)
// LocalAllocTrace is no longer supported. AppVerifier is the
// official way to track memory allocations.
//#define LocalAlloc(f,b) LocalAllocTrace(f,b,__LINE__, __FILE__)
#endif

HLOCAL
WINAPI
LocalFree (
    HLOCAL hMem
    );

HLOCAL
WINAPI
LocalReAlloc (
    HLOCAL hMem,
    UINT cbBytes,
    UINT fuFlags
    );

UINT
WINAPI
LocalSize (
    HLOCAL hMem
    );

#ifdef UNDER_CE
#define GlobalAlloc(flags, cb)              LocalAlloc(flags, cb)
#define GlobalFree(handle)                  LocalFree(handle)
#define GlobalReAlloc(handle, cb, flags)    LocalReAlloc(handle, cb, LMEM_MOVEABLE)
#define GlobalLock(lp)                      LocalLock(lp)
#define GlobalHandle(lp)                    LocalHandle(lp)
#define GlobalUnlock(hMem)                  LocalUnlock(hMem)
#define GlobalSize(hMem)                    LocalSize(hMem)
#define GlobalFlags(X)                      LocalFlags(X)
#define LocalPtrHandle(lp)                  ((HLOCAL)LocalHandle(lp))
#define LocalLockPtr(lp)                    ((BOOL)LocalLock(LocalPtrHandle(lp)))
#define LocalUnlockPtr(lp)                  LocalUnlock(LocalPtrHandle(lp))
#define LocalFreePtr(lp)                    (LocalUnlockPtr(lp), (BOOL)LocalFree(LocalPtrHandle(lp)))
#endif

LPVOID
WINAPI
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

LPVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

BOOL
WINAPI
VirtualProtect(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

DWORD
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

DWORD
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

HANDLE WINAPI GetProcessHeap(VOID);

HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwMaximumSize
    );

BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    );

LPVOID
WINAPI
HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

LPVOID
WINAPI
HeapAllocTrace(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes,
    DWORD dwLineNum,
    CONST PCHAR szFilename
    );

#if defined(DEBUG) || defined(LMEM_DEBUG)
#define HeapAlloc(h,f,b) HeapAllocTrace(h,f,b,__LINE__, __FILE__)
#endif

LPVOID
WINAPI
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    );

BOOL
WINAPI
HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );

DWORD
WINAPI
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

UINT
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    );

typedef HANDLE (WINAPI *PFN_HeapCreate)     (DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize);
typedef BOOL   (WINAPI *PFN_HeapDestroy)    (HANDLE hHeap);
typedef LPVOID (WINAPI *PFN_HeapAlloc)      (HANDLE hHeap, DWORD dwFlags, DWORD dwBytes);
typedef LPVOID (WINAPI *PFN_HeapAllocTrace) (HANDLE hHeap, DWORD dwFlags, DWORD dwBytes, DWORD dwLineNum, PCHAR szFileName);
typedef LPVOID (WINAPI *PFN_HeapReAlloc)    (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes);
typedef DWORD  (WINAPI *PFN_HeapSize)       (HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
typedef BOOL   (WINAPI *PFN_HeapFree)       (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
typedef UINT   (WINAPI *PFN_HeapCompact)    (HANDLE hHeap, DWORD dwFlags);

//
// CE Heap extension: Create Heap with custom allocator/deallocator
//
typedef LPVOID (* PFN_AllocHeapMem) (LPVOID pAddr, DWORD cbSize, DWORD fdwAction, LPDWORD pdwUserData);
typedef BOOL (* PFN_FreeHeapMem) (LPVOID pAddr, DWORD cbSize, DWORD fdwAction, DWORD dwUserData);

HANDLE
WINAPI
CeHeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwMaximumSize,
    PFN_AllocHeapMem pfnAlloc,
    PFN_FreeHeapMem pfnFree
    );

VOID
WINAPI
OutputDebugStringA(
    LPCSTR lpOutputString
    );

VOID
WINAPI
OutputDebugStringW(
    LPCWSTR lpOutputString
    );
#ifdef UNICODE
#define OutputDebugString  OutputDebugStringW
#else
#define OutputDebugString  OutputDebugStringA
#endif // !UNICODE

#if defined (_M_CEE) || !defined (UNDER_CE)
WINBASEAPI
VOID
WINAPI
DebugBreak(
    VOID
    );
#endif

VOID SignalStarted(DWORD dw);

BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );

BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2
#define VER_PLATFORM_WIN32_HH           3
#define VER_PLATFORM_WIN32_CE           3

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

BOOL
WINAPI
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );
BOOL
WINAPI
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );
#ifdef UNICODE
#define GetVersionEx  GetVersionExW
#else
#define GetVersionEx  GetVersionExA
#endif // !UNICODE

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

HINSTANCE
WINAPI
LoadLibraryA(
    LPCSTR lpLibFileName
    );

HINSTANCE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
    );
#ifdef UNICODE
#define LoadLibrary  LoadLibraryW
#else
#define LoadLibrary  LoadLibraryA
#endif // !UNICODE

WINBASEAPI
HMODULE
WINAPI
LoadLibraryExA(
    IN LPCSTR lpLibFileName,
    IN HANDLE hFile,
    IN DWORD dwFlags
    );
WINBASEAPI
HMODULE
WINAPI
LoadLibraryExW(
    IN LPCWSTR lpLibFileName,
    IN HANDLE hFile,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define LoadLibraryEx  LoadLibraryExW
#else
#define LoadLibraryEx  LoadLibraryExA
#endif // !UNICODE

#define DONT_RESOLVE_DLL_REFERENCES     0x00000001
#define LOAD_LIBRARY_AS_DATAFILE        0x00000002
#define LOAD_WITH_ALTERED_SEARCH_PATH   0x00000008

WINBASEAPI
DWORD
WINAPI
GetModuleFileNameA(
    HMODULE hModule,
    __out_bcount(nSize) LPSTR lpFilename,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetModuleFileNameW(
    HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpFilename,
    DWORD nSize
    );
#ifdef UNICODE
#define GetModuleFileName  GetModuleFileNameW
#else
#define GetModuleFileName  GetModuleFileNameA
#endif // !UNICODE

WINBASEAPI
HMODULE
WINAPI
GetModuleHandleA(
    LPCSTR lpModuleName
    );
WINBASEAPI
HMODULE
WINAPI
GetModuleHandleW(
    LPCWSTR lpModuleName
    );
#ifdef UNICODE
#define GetModuleHandle  GetModuleHandleW
#else
#define GetModuleHandle  GetModuleHandleA
#endif // !UNICODE

//
//  File structures
//
/////////////////////////////////////////////////////////////////////////////////////////

#define MSGQUEUE_NOPRECOMMIT            0x00000001
#define MSGQUEUE_ALLOW_BROKEN           0x00000002
#define MSGQUEUE_TOKEN_SUPPORT          0x00000004

#define MSGQUEUE_MSGALERT               0x00000001



typedef struct MSGQUEUEOPTIONS_OS {
    DWORD dwSize;                           // size of the structure
    DWORD dwFlags;                          // behavior of message queue
    DWORD dwMaxMessages;                    // max # of msgs in queue
    DWORD cbMaxMessage;                     // max size of msg
    BOOL  bReadAccess;                      // read access requested
} MSGQUEUEOPTIONS, FAR *LPMSGQUEUEOPTIONS, *PMSGQUEUEOPTIONS;

typedef struct MSGQUEUEINFO {
    DWORD dwSize;                           // size of structure
    DWORD dwFlags;                          // behavior of message queue
    DWORD dwMaxMessages;                    // max # of msgs in queue
    DWORD cbMaxMessage;                     // max size of msg
    DWORD dwCurrentMessages;                // # of message in queue currently
    DWORD dwMaxQueueMessages;               // high water mark of queue
    WORD  wNumReaders;                      // # of readers
    WORD  wNumWriters;                      // # of writes
} MSGQUEUEINFO, *PMSGQUEUEINFO, FAR *LPMSGQUEUEINFO;

typedef struct _OVERLAPPED {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef DWORD (WINAPI *LPTHREAD_START_ROUTINE)(LPVOID pvarg);

typedef LPTHREAD_START_ROUTINE PTHREAD_START_ROUTINE;

#define DEBUG_PROCESS                       0x00000001
#define DEBUG_ONLY_THIS_PROCESS             0x00000002
#define CREATE_SUSPENDED                    0x00000004
#define CREATE_NEW_CONSOLE                  0x00000010
#define STACK_SIZE_PARAM_IS_A_RESERVATION   0x00010000
#define INHERIT_CALLER_PRIORITY             0x00020000

#define MAX_CE_PRIORITY_LEVELS              256     // CE support 256 priorities (0-255)
#define MAX_WIN32_PRIORITY_LEVELS           8       // WIN32 supports 8 priority (0-7)

#define PRIO_WIN32_TO_CE(prio)              ((prio)+MAX_CE_PRIORITY_LEVELS-MAX_WIN32_PRIORITY_LEVELS)

#define THREAD_PRIORITY_TIME_CRITICAL       0
#define THREAD_PRIORITY_HIGHEST             1
#define THREAD_PRIORITY_ABOVE_NORMAL        2
#define THREAD_PRIORITY_NORMAL              3
#define THREAD_PRIORITY_BELOW_NORMAL        4
#define THREAD_PRIORITY_LOWEST              5
#define THREAD_PRIORITY_ABOVE_IDLE          6
#define THREAD_PRIORITY_IDLE                7


#define CE_THREAD_PRIO_256_TIME_CRITICAL    PRIO_WIN32_TO_CE(THREAD_PRIORITY_TIME_CRITICAL)
#define CE_THREAD_PRIO_256_HIGHEST          PRIO_WIN32_TO_CE(THREAD_PRIORITY_HIGHEST)
#define CE_THREAD_PRIO_256_ABOVE_NORMAL     PRIO_WIN32_TO_CE(THREAD_PRIORITY_ABOVE_NORMAL)
#define CE_THREAD_PRIO_256_NORMAL           PRIO_WIN32_TO_CE(THREAD_PRIORITY_NORMAL)
#define CE_THREAD_PRIO_256_BELOW_NORMAL     PRIO_WIN32_TO_CE(THREAD_PRIORITY_BELOW_NORMAL)
#define CE_THREAD_PRIO_256_LOWEST           PRIO_WIN32_TO_CE(THREAD_PRIORITY_LOWEST)
#define CE_THREAD_PRIO_256_ABOVE_IDLE       PRIO_WIN32_TO_CE(THREAD_PRIORITY_ABOVE_IDLE)
#define CE_THREAD_PRIO_256_IDLE             PRIO_WIN32_TO_CE(THREAD_PRIORITY_IDLE)


#define THREAD_PRIORITY_ERROR_RETURN    (MAXLONG)

#define EXCEPTION_DEBUG_EVENT       1
#define CREATE_THREAD_DEBUG_EVENT   2
#define CREATE_PROCESS_DEBUG_EVENT  3
#define EXIT_THREAD_DEBUG_EVENT     4
#define EXIT_PROCESS_DEBUG_EVENT    5
#define LOAD_DLL_DEBUG_EVENT        6
#define UNLOAD_DLL_DEBUG_EVENT      7
#define OUTPUT_DEBUG_STRING_EVENT   8
#define RIP_EVENT                   9

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;

typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;
#define WAIT_OBJECT_0       0x00000000L
#define WAIT_ABANDONED      0x00000080L
#define WAIT_ABANDONED_0    0x00000080L
#define WAIT_FAILED         0xffffffffL
#define INFINITE            0xffffffffL

#define EXCEPTION_ACCESS_VIOLATION          STATUS_ACCESS_VIOLATION
#define EXCEPTION_DATATYPE_MISALIGNMENT     STATUS_DATATYPE_MISALIGNMENT
#define EXCEPTION_BREAKPOINT                STATUS_BREAKPOINT
#define EXCEPTION_SINGLE_STEP               STATUS_SINGLE_STEP
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED     STATUS_ARRAY_BOUNDS_EXCEEDED
#define EXCEPTION_FLT_DENORMAL_OPERAND      STATUS_FLOAT_DENORMAL_OPERAND
#define EXCEPTION_FLT_DIVIDE_BY_ZERO        STATUS_FLOAT_DIVIDE_BY_ZERO
#define EXCEPTION_FLT_INEXACT_RESULT        STATUS_FLOAT_INEXACT_RESULT
#define EXCEPTION_FLT_INVALID_OPERATION     STATUS_FLOAT_INVALID_OPERATION
#define EXCEPTION_FLT_OVERFLOW              STATUS_FLOAT_OVERFLOW
#define EXCEPTION_FLT_STACK_CHECK           STATUS_FLOAT_STACK_CHECK
#define EXCEPTION_FLT_UNDERFLOW             STATUS_FLOAT_UNDERFLOW
#define EXCEPTION_INT_DIVIDE_BY_ZERO        STATUS_INTEGER_DIVIDE_BY_ZERO
#define EXCEPTION_INT_OVERFLOW              STATUS_INTEGER_OVERFLOW
#define EXCEPTION_PRIV_INSTRUCTION          STATUS_PRIVILEGED_INSTRUCTION
#define EXCEPTION_IN_PAGE_ERROR             STATUS_IN_PAGE_ERROR
#define EXCEPTION_ILLEGAL_INSTRUCTION       STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_NONCONTINUABLE_EXCEPTION  STATUS_NONCONTINUABLE_EXCEPTION
#define EXCEPTION_STACK_OVERFLOW            STATUS_STACK_OVERFLOW
#define EXCEPTION_INVALID_DISPOSITION       STATUS_INVALID_DISPOSITION
#define EXCEPTION_GUARD_PAGE                STATUS_GUARD_PAGE_VIOLATION
#define EXCEPTION_INVALID_HANDLE            STATUS_INVALID_HANDLE

typedef PCONTEXT LPCONTEXT;

//
// Vector exception handler support
//
typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

WINBASEAPI
PVOID
WINAPI
AddVectoredExceptionHandler(
    IN ULONG FirstHandler,
    IN PVECTORED_EXCEPTION_HANDLER VectoredHandler
    );

WINBASEAPI
ULONG
WINAPI
RemoveVectoredExceptionHandler(
    IN PVOID VectoredHandlerHandle
    );


//
// Critical Section
//
#ifdef UNDER_NT
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    DWORD Reserved;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

#else

typedef struct CRITICAL_SECTION {
    unsigned int LockCount;         /* Nesting count on critical section */
    HANDLE OwnerThread;             /* Handle of owner thread */
    HANDLE hCrit;                   /* Handle to this critical section */
    DWORD needtrap;                 /* Trap in when freeing critical section */
    DWORD dwContentions;            /* Count of contentions */
} CRITICAL_SECTION, *LPCRITICAL_SECTION;
#endif

VOID
WINAPI
EnterCriticalSection (
    LPCRITICAL_SECTION pcsCriticalSection
    );

VOID
WINAPI
LeaveCriticalSection (
    LPCRITICAL_SECTION pcsCriticalSection
    );

VOID
WINAPI
InitializeCriticalSection (
    LPCRITICAL_SECTION pcsCriticalSection
    );

WINBASEAPI
BOOL
WINAPI
TryEnterCriticalSection(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

VOID
WINAPI
DeleteCriticalSection (
    LPCRITICAL_SECTION pcsCriticalSection
    );

BOOL
WINAPI
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    );

BOOL
WINAPI
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    );

BOOL
WINAPI
DebugActiveProcess(
    DWORD dwProcessId
    );

BOOL
WINAPI
DebugActiveProcessStop(
    DWORD dwProcessId
    );

BOOL
WINAPI
DebugSetProcessKillOnExit(
    BOOL KillOnExit
    );

BOOL
WINAPI
CheckRemoteDebuggerPresent(
    HANDLE hProcess,
    PBOOL  pbDebuggerPresent
    );

LPVOID
WINAPI
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

BOOL
WINAPI
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );

WINBASEAPI
BOOL
WINAPI
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    DWORD dwNumberOfBytesToFlush
    );

WINBASEAPI
HANDLE
WINAPI
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

WINBASEAPI
HANDLE
WINAPI
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

#ifdef UNICODE
#define CreateFileMapping  CreateFileMappingW
#else
#define CreateFileMapping  CreateFileMappingA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateFileForMappingW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile);

#ifdef UNICODE
#define CreateFileForMapping  CreateFileForMappingW
#else
#define CreateFileForMapping  CreateFileForMappingA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetTempPathA(
    DWORD nBufferLength,
    __out_ecount_opt(nBufferLength) LPSTR lpBuffer
    );

WINBASEAPI
DWORD
WINAPI
GetTempPathW(
    DWORD nBufferLength,
    __out_ecount_opt(nBufferLength) LPWSTR lpBuffer
    );

#ifdef UNICODE
#define GetTempPath  GetTempPathW
#else
#define GetTempPath  GetTempPathA
#endif // !UNICODE

#define TLS_MINIMUM_AVAILABLE   64

HANDLE
WINAPI
CreateThread (
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD   cbStack,
    LPTHREAD_START_ROUTINE lpStartAddr,
    LPVOID lpvThreadParam,
    DWORD fdwCreate,
    LPDWORD lpIDThread
    );

VOID
WINAPI
ExitThread (
    DWORD   dwExitCode
    );

BOOL
WINAPI
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    );

#define STILL_ACTIVE 0x00000103

// @CESYSGEN IF COREDLL_FIBER

/////////////////////////////////////////////////////
// fiber functions
typedef VOID (CALLBACK *LPFIBER_START_ROUTINE) (PVOID);

LPVOID WINAPI ConvertThreadToFiber (LPVOID lpParameter);
LPVOID WINAPI CreateFiber (DWORD dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
VOID WINAPI DeleteFiber (LPVOID lpFiber);
LPVOID WINAPI GetFiberData (VOID);
LPVOID GetCurrentFiber (VOID);
VOID WINAPI SwitchToFiber (LPVOID lpFiber);

// @CESYSGEN ENDIF

LPVOID
WINAPI
TlsGetValue (
    DWORD dwTlsIndex
    );

BOOL
WINAPI
TlsSetValue (
    DWORD dwTlsIndex,
    LPVOID lpvTlsValue
    );


typedef struct _PROCESS_INFORMATION {
    HANDLE  hProcess;
    HANDLE  hThread;
    DWORD   dwProcessId;
    DWORD   dwThreadId;
} PROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;

typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;

#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif // UNICODE

BOOL
WINAPI
CreateProcessA (
    LPCSTR pszImageName,
    LPCSTR pszCmdLine,
    LPSECURITY_ATTRIBUTES psaProcess,
    LPSECURITY_ATTRIBUTES psaThread,
    BOOL fInheritHandles,
    DWORD fdwCreate,
    LPVOID pvEnvironment,
    LPSTR pszCurDir,
    __reserved LPSTARTUPINFOA psiStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    );
BOOL
WINAPI
CreateProcessW (
    LPCWSTR pszImageName,
    LPCWSTR pszCmdLine,
    LPSECURITY_ATTRIBUTES psaProcess,
    LPSECURITY_ATTRIBUTES psaThread,
    BOOL fInheritHandles,
    DWORD fdwCreate,
    LPVOID pvEnvironment,
    LPWSTR pszCurDir,
    __reserved LPSTARTUPINFOW psiStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    );
#ifdef UNICODE
#define CreateProcess CreateProcessW
#else
#define CreateProcess CreateProcessA
#endif

WINBASEAPI
DWORD
WINAPI
GetProcessVersion(
    DWORD ProcessId
    );

WINBASEAPI
DWORD
WINAPI
GetProcessId (
    HANDLE hProcess
    );

WINBASEAPI
BOOL
WINAPI
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );


#if !defined(__midl)
__inline DWORD GetDllVersion (HMODULE hMod)
{
    // GetProcessVersion now takes module handle
    // as parameter as well as process id.
    return GetProcessVersion ((DWORD) hMod);
}
#endif

WINBASEAPI
LPSTR
WINAPI
GetCommandLineA(
    VOID
    );
WINBASEAPI
LPWSTR
WINAPI
GetCommandLineW(
    VOID
    );
#ifdef UNICODE
#define GetCommandLine  GetCommandLineW
#else
#define GetCommandLine  GetCommandLineA
#endif // !UNICODE

#include <winerror.h>

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)

#define FILE_SHARE_READ                 0x00000001
#define FILE_SHARE_WRITE                0x00000002

//
// File creation flags must start at the high end since they
// are combined with the attributes
//

#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define FILE_FLAG_NO_BUFFERING          0x20000000
#define FILE_FLAG_RANDOM_ACCESS         0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN       0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS      0x02000000
#define FILE_FLAG_POSIX_SEMANTICS       0x01000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5
#define OPEN_FOR_LOADER     6

// Windows CE File API definitions copied from NT's winbase.h

typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR  cFileName[ MAX_PATH ];
    CHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwOID;
    WCHAR cFileName[ MAX_PATH ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#ifdef UNICODE
typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#else
typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#endif // UNICODE

typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

WINBASEAPI
DWORD
WINAPI
GetLastError(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetTickCount(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetIdleTime(
    VOID
    );

// @CESYSGEN IF COREDLL_FMTMSG

WINBASEAPI
DWORD
WINAPI
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );

#ifndef COREDLL
WINBASEAPI
#endif
DWORD
WINAPI
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );

#ifdef UNICODE
#define FormatMessage  FormatMessageW
#else
#define FormatMessage  FormatMessageA
#endif // !UNICODE

// @CESYSGEN ENDIF

#define FORMAT_MESSAGE_ALLOCATE_BUFFER 0x00000100
#define FORMAT_MESSAGE_IGNORE_INSERTS  0x00000200
#define FORMAT_MESSAGE_FROM_STRING     0x00000400
#define FORMAT_MESSAGE_FROM_HMODULE    0x00000800
#define FORMAT_MESSAGE_FROM_SYSTEM     0x00001000
#define FORMAT_MESSAGE_ARGUMENT_ARRAY  0x00002000
#define FORMAT_MESSAGE_MAX_WIDTH_MASK  0x000000FF

WINBASEAPI
BOOL
WINAPI
CloseHandle(
    HANDLE hObject
    );

WINBASEAPI
BOOL
WINAPI
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );

WINBASEAPI
HRSRC
WINAPI
FindResourceForDisplayConfiguration(
    __in_z LPCWSTR pwszModuleBase,
    __out HMODULE *phModule,
    __in_z LPCWSTR pwszName,
    __in_z LPCWSTR pwszType,
    DWORD dwDisplayConfigurationID
);

WINBASEAPI
HGLOBAL
WINAPI
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    );

WINBASEAPI
DWORD
WINAPI
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    );

WINBASEAPI
HRSRC
WINAPI
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );

WINBASEAPI
HRSRC
WINAPI
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );

#ifdef UNICODE
#define FindResource  FindResourceW
#else
#define FindResource  FindResourceA
#endif  // !UNICODE

int
WINAPI
LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    __out_bcount_opt(nBufferMax) LPSTR lpBuffer,
    int nBufferMax);

int
WINAPI
LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    __out_ecount_opt(nBufferMax) LPWSTR lpBuffer,
    int nBufferMax);
#ifdef UNICODE
#define LoadString  LoadStringW
#else
#define LoadString  LoadStringA
#endif // !UNICODE

#ifndef UNDER_CE    // The WinCE case is in kfuncs.h
WINBASEAPI
LPVOID
WINAPI
LockResource(
        HGLOBAL hResData
        );
#endif

// @CESYSGEN IF GWES_ATOM
WINBASEAPI
ATOM
WINAPI
GlobalAddAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalAddAtomW(
    __in LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalAddAtom  GlobalAddAtomW
#else
#define GlobalAddAtom  GlobalAddAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
GlobalFindAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalFindAtomW(
    __in LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalFindAtom  GlobalFindAtomW
#else
#define GlobalFindAtom  GlobalFindAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
GlobalDeleteAtom(
    ATOM nAtom
    );
// @CESYSGEN ENDIF

WINBASEAPI
BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    DWORD uExitCode
    );

#define ExitProcess(code)   TerminateProcess (GetCurrentProcess (), (code))

BOOL
WINAPI
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    DWORD dwSize
    );

BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    );

BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesWritten
    );

HANDLE
WINAPI
OpenProcess(
    DWORD fdwAccess,
    BOOL fInherit,
    DWORD IDProcess
    );

HANDLE
WINAPI
OpenThread(
    DWORD fdwAccess,
    BOOL fInherit,
    DWORD IDThread
    );

WINBASEAPI
BOOL
WINAPI
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    );

WINBASEAPI
BOOL
WINAPI
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    );

WINBASEAPI
DWORD
WINAPI
SuspendThread(
    HANDLE hThread
    );
WINBASEAPI
DWORD
WINAPI
ResumeThread(
    HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );

WINBASEAPI
int
WINAPI
GetThreadPriority(
    HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

WINBASEAPI
int
WINAPI
CeGetThreadPriority(
    HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
CeSetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

WINBASEAPI
DWORD
WINAPI
CeGetThreadQuantum(
    HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
CeSetThreadQuantum(
    HANDLE hThread,
    DWORD dwTime
    );

WINBASEAPI
DWORD
WINAPI
GetThreadId(
    HANDLE hThread
    );

WINBASEAPI
DWORD
WINAPI
GetProcessIdOfThread(
    HANDLE hThread
    );

WINBASEAPI
LPVOID
WINAPI
CeZeroPointer(
    LPVOID ptr
    );

WINBASEAPI
VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    );

WINBASEAPI
UINT
WINAPI
GetTempFileNameA(
    IN LPCSTR lpPathName,
    IN LPCSTR lpPrefixString,
    IN UINT uUnique,
    __out_ecount(MAX_PATH) LPSTR lpTempFileName
    );
WINBASEAPI
UINT
WINAPI
GetTempFileNameW(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    __out_ecount(MAX_PATH) LPWSTR lpTempFileName
    );
#ifdef UNICODE
#define GetTempFileName  GetTempFileNameW
#else
#define GetTempFileName  GetTempFileNameA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
CeGetCanonicalPathNameA(
    IN LPCSTR lpPathName,
    __out_ecount(cchCanonicalPathName) LPSTR lpCanonicalPathName,
    IN DWORD cchCanonicalPathName,
    IN DWORD dwReserved
    );
WINBASEAPI
DWORD
WINAPI
CeGetCanonicalPathNameW(
    IN LPCWSTR lpPathName,
    __out_ecount_opt(cchCanonicalPathName) LPWSTR lpCanonicalPathName,
    IN DWORD cchCanonicalPathName,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CeGetCanonicalPathName  CeGetCanonicalPathNameW
#else
#define CeGetCanonicalPathName  CeGetCanonicalPathNameA
#endif // !UNICODE

// @CESYSGEN IF FILESYS_FSMAIN

BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);

BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);

#ifdef UNICODE
#define GetDiskFreeSpaceEx  GetDiskFreeSpaceExW
#else
#define GetDiskFreeSpaceEx  GetDiskFreeSpaceExA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

WINBASEAPI
HANDLE
WINAPI
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
#ifdef UNICODE
#define CreateFile  CreateFileW
#else
#define CreateFile  CreateFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
DeleteFileA(
    LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
DeleteFileW(
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define DeleteFile  DeleteFileW
#else
#define DeleteFile  DeleteFileA
#endif // !UNICODE

typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;

#define FIND_FIRST_EX_CASE_SENSITIVE   0x00000001

WINBASEAPI
HANDLE
WINAPI
FindFirstFileExA(
    IN LPCSTR lpFileName,
    IN FINDEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFindFileData,
    IN FINDEX_SEARCH_OPS fSearchOp,
    IN LPVOID lpSearchFilter,
    IN DWORD dwAdditionalFlags
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstFileExW(
    IN LPCWSTR lpFileName,
    IN FINDEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFindFileData,
    IN FINDEX_SEARCH_OPS fSearchOp,
    IN LPVOID lpSearchFilter,
    IN DWORD dwAdditionalFlags
    );
#ifdef UNICODE
#define FindFirstFileEx  FindFirstFileExW
#else
#define FindFirstFileEx  FindFirstFileExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
DeleteAndRenameFile(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName
    );

WINBASEAPI
HANDLE
WINAPI
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );

WINBASEAPI
HANDLE
WINAPI
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindFirstFile  FindFirstFileW
#else
#define FindFirstFile  FindFirstFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );

WINBASEAPI
BOOL
WINAPI
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindNextFile  FindNextFileW
#else
#define FindNextFile  FindNextFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );
WINBASEAPI
BOOL
WINAPI
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );
#ifdef UNICODE
#define CopyFile  CopyFileW
#else
#define CopyFile  CopyFileA
#endif // !UNICODE

#define CALLBACK_CHUNK_FINISHED               0x00000000
#define CALLBACK_STREAM_SWITCH                0x00000001

#define COPY_FILE_FAIL_IF_EXISTS              0x00000001
#define COPY_FILE_RESTARTABLE                 0x00000002
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE       0x00000004
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 0x00000008

#define PROGRESS_CONTINUE                     0
#define PROGRESS_CANCEL                       1
#define PROGRESS_STOP                         2
#define PROGRESS_QUIET                        3

typedef
DWORD
(WINAPI* LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData
    );

WINBASEAPI
BOOL
WINAPI
CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );
WINBASEAPI
BOOL
WINAPI
CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );
#ifdef UNICODE
#define CopyFileEx  CopyFileExW
#else
#define CopyFileEx  CopyFileExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
WINBASEAPI
BOOL
WINAPI
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    );
#ifdef UNICODE
#define MoveFile  MoveFileW
#else
#define MoveFile  MoveFileA
#endif // !UNICODE


WINBASEAPI
BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateDirectory  CreateDirectoryW
#else
#define CreateDirectory  CreateDirectoryA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
RemoveDirectoryA(
    LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
RemoveDirectoryW(
    LPCWSTR lpPathName
    );
#ifdef UNICODE
#define RemoveDirectory  RemoveDirectoryW
#else
#define RemoveDirectory  RemoveDirectoryA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetFileSecurityA (
    __in LPCSTR pFileName,
    SECURITY_INFORMATION RequestedInformation,
    __out_bcount_opt (Length) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD Length,
    __out_opt DWORD* pLengthNeeded
    );
WINADVAPI
BOOL
WINAPI
GetFileSecurityW (
    __in LPCWSTR pFileName,
    SECURITY_INFORMATION RequestedInformation,
    __out_bcount_opt (Length) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD Length,
    __out_opt DWORD* pLengthNeeded
    );
#ifdef UNICODE
#define GetFileSecurity GetFileSecurityW
#else
#define GetFileSecurity GetFileSecurityA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
SetFileSecurityA (
    __in LPCSTR pFileName,
    SECURITY_INFORMATION SecurityInformation,
    __in_bcount (Length) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD Length
    );
WINADVAPI
BOOL
WINAPI
SetFileSecurityW (
    __in LPCWSTR pFileName,
    SECURITY_INFORMATION SecurityInformation,
    __in_bcount (Length) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD Length
    );
#ifdef UNICODE
#define SetFileSecurity SetFileSecurityW
#else
#define SetFileSecurity SetFileSecurityA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    __in_bcount(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    __out_bcount(nNumberOfBytesToRead) LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );

#define LOCKFILE_FAIL_IMMEDIATELY 0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK   0x00000002

WINBASEAPI
BOOL
WINAPI
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
CancelIoEx(
    __in HANDLE hFile,
    __in LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
CancelIo(
    __in HANDLE hFile
    );

WINBASEAPI BOOL WINAPI FlushFileBuffers (HANDLE hFile);
WINBASEAPI BOOL WINAPI GetFileTime (HANDLE hFile, LPFILETIME lpCreation, LPFILETIME lpLastAccess, LPFILETIME lpLastWrite);
WINBASEAPI BOOL WINAPI SetFileTime (HANDLE hFile, CONST FILETIME *lpCreation, CONST FILETIME *lpLastAccess, CONST FILETIME *lpLastWrite);
WINBASEAPI BOOL WINAPI SetEndOfFile (HANDLE hFile);
WINBASEAPI BOOL WINAPI DeviceIoControl (HANDLE hDevice, DWORD dwIoControlCode, __inout_bcount_opt(nInBufSize)LPVOID lpInBuf, DWORD nInBufSize, __inout_bcount_opt(nOutBufSize) LPVOID lpOutBuf, DWORD nOutBufSize, __out_opt LPDWORD lpBytesReturned, __reserved LPOVERLAPPED lpOverlapped);

WINBASEAPI
HANDLE
WINAPI
FindFirstChangeNotificationA(
    IN LPCSTR lpPathName,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstChangeNotificationW(
    IN LPCWSTR lpPathName,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter
    );
#ifdef UNICODE
#define FindFirstChangeNotification  FindFirstChangeNotificationW
#else
#define FindFirstChangeNotification  FindFirstChangeNotificationA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextChangeNotification(
    IN HANDLE hChangeHandle
    );

WINBASEAPI
BOOL
WINAPI
CeGetFileNotificationInfo(
    HANDLE hChangeHandle,
    DWORD dwFlags,
    __out_bcount_opt(nBufferLength) LPVOID lpBuffer,
    DWORD nBufferLength,
    LPDWORD lpBytesReturned,
    LPDWORD lpBytesAvailable
    );


WINBASEAPI
BOOL
WINAPI
FindCloseChangeNotification(
    IN HANDLE hChangeHandle
    );

WINBASEAPI
BOOL
CeFsIoControlW(
    IN LPCWSTR pszRootPath,
    IN DWORD dwIoctl,
    IN LPVOID lpInBuf,
    IN DWORD nInBufSize,
    OUT LPVOID lpOutBuf,
    IN DWORD nOutBufSize,
    OUT LPDWORD lpBytesReturned,
    IN LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
CeFsIoControlA(
    IN LPCSTR pszRootPath,
    IN DWORD dwIoctl,
    IN LPVOID lpInBuf,
    IN DWORD nInBufSize,
    OUT LPVOID lpOutBuf,
    IN DWORD nOutBufSize,
    OUT LPDWORD lpBytesReturned,
    IN LPOVERLAPPED lpOverlapped
    );

#ifdef UNICODE
#define CeFsIoControl  CeFsIoControlW
#else
#define CeFsIoControl  CeFsIoControlA
#endif // !UNICODE

// @CESYSGEN IF COREDLL_ASYNCIO

#define HasOverlappedIoCompleted(lpOverlapped) ((lpOverlapped)->Internal != STATUS_PENDING)

WINBASEAPI
BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );

// @CESYSGEN ENDIF

WINBASEAPI
BOOL
WINAPI
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
WINBASEAPI
BOOL
WINAPI
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
#ifdef UNICODE
#define SetFileAttributes  SetFileAttributesW
#else
#define SetFileAttributes  SetFileAttributesA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );

WINBASEAPI
BOOL
WINAPI
FindClose(
    HANDLE hFindFile
    );


WINBASEAPI
DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    );

WINBASEAPI
DWORD
WINAPI
GetFileAttributesA(
    LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetFileAttributesW(
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetFileAttributes  GetFileAttributesW
#else
#define GetFileAttributes  GetFileAttributesA
#endif // !UNICODE

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;

WINBASEAPI
BOOL
WINAPI
GetFileAttributesExA(
    IN LPCSTR lpFileName,
    IN GET_FILEEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFileInformation
    );
WINBASEAPI
BOOL
WINAPI
GetFileAttributesExW(
    IN LPCWSTR lpFileName,
    IN GET_FILEEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFileInformation
    );
#ifdef UNICODE
#define GetFileAttributesEx  GetFileAttributesExW
#else
#define GetFileAttributesEx  GetFileAttributesExA
#endif // !UNICODE
typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
    DWORD dwOID;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

WINBASEAPI
BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );

// @CESYSGEN ENDIF

WINBASEAPI
VOID
WINAPI
Sleep(
    DWORD dwMilliseconds
    );

WINBASEAPI
HANDLE
WINAPI
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpsa,
    BOOL bInitialOwner,
    LPCSTR lpName);

WINBASEAPI
HANDLE
WINAPI
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpsa,
    BOOL bInitialOwner,
    LPCWSTR lpName);

#ifdef UNICODE
#define CreateMutex  CreateMutexW
#else
#define CreateMutex  CreateMutexA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );

WINBASEAPI
HANDLE
WINAPI
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateEvent  CreateEventW
#else
#define CreateEvent  CreateEventA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

WINBASEAPI
HANDLE
WINAPI
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenEvent  OpenEventW
#else
#define OpenEvent  OpenEventA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateSemaphoreA(
    IN LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    IN LONG lInitialCount,
    IN LONG lMaximumCount,
    IN LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
CreateSemaphoreW(
    IN LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    IN LONG lInitialCount,
    IN LONG lMaximumCount,
    IN LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateSemaphore  CreateSemaphoreW
#else
#define CreateSemaphore  CreateSemaphoreA
#endif // !UNICODE

#ifndef UNDER_CE    // The WinCE case is in kfuncs.h
WINBASEAPI
BOOL
WINAPI
SetEvent(
    HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
ResetEvent(
    HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
PulseEvent(
    HANDLE hEvent
    );
#endif

WINBASEAPI
BOOL
WINAPI
ReleaseSemaphore(
    IN HANDLE hSemaphore,
    IN LONG lReleaseCount,
    OUT LPLONG lpPreviousCount
    );

WINBASEAPI
BOOL
WINAPI
ReleaseMutex(
    HANDLE hMutex
    );

WINBASEAPI
DWORD
WINAPI
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );

WINBASEAPI
DWORD
WINAPI
WaitForMultipleObjects(
    DWORD cObjects,
    __in_ecount(cObjects) CONST HANDLE *lphObjects,
    BOOL fWaitAll,
    DWORD dwTimeout
    );

WINBASEAPI
BOOL
WINAPI
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    );

#ifndef UNDER_CE    // The WinCE case is in kfuncs.h
WINBASEAPI
HANDLE
WINAPI
GetCurrentThread(
    VOID
    );

WINBASEAPI
HANDLE
WINAPI
GetCurrentProcess(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentThreadId(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentProcessId(
    VOID
    );
#endif

DWORD
WINAPI
TlsAlloc(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    );

WINBASEAPI
BOOL
WINAPI
IsBadReadPtr(
    __in_bcount(ucb) CONST VOID *lp,
    UINT ucb
    );

BOOL
WINAPI
TlsFree(
    DWORD dwTlsIndex
    );

WINBASEAPI
BOOL
WINAPI
IsBadWritePtr(
    __out_bcount(ucb) LPVOID lp,
    UINT ucb
    );

WINBASEAPI
VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

WINBASEAPI
BOOL
WINAPI
QueryInstructionSet(
    DWORD dwInstructionSet,
    LPDWORD lpdwCurrentInstructionSet
    );

WINBASEAPI
BOOL
WINAPI
IsProcessorFeaturePresent(
    DWORD dwProcessorFeature
    );

WINBASEAPI
VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST DWORD *lpArguments
    );

WINBASEAPI
BOOL
WINAPI
FreeLibrary(
    HMODULE hLibModule
    );

WINBASEAPI
VOID
WINAPI
FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
DisableThreadLibraryCalls(
    IN HMODULE hLibModule
    );

#ifdef UNDER_CE
#include <dbgapi.h>
#include <kfuncs.h>
#endif

#if !defined(__midl)
_inline BOOL IsDebuggerPresent(void) {
    BOOL bIsDebuggerPresent;
    if (CheckRemoteDebuggerPresent(GetCurrentProcess(), &bIsDebuggerPresent)) {
        return bIsDebuggerPresent;
    }
    return FALSE;
}
#endif // !defined(__midl)

#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ
#define FILE_MAP_EXECUTE    SECTION_MAP_EXECUTE
#define FILE_MAP_ALL_ACCESS SECTION_ALL_ACCESS

// @CESYSGEN IF COREDLL_SERDEV

//
// Serial provider type.
//

#define SP_SERIALCOMM    ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED      ((DWORD)0x00000000)
#define PST_RS232            ((DWORD)0x00000001)
#define PST_PARALLELPORT     ((DWORD)0x00000002)
#define PST_RS422            ((DWORD)0x00000003)
#define PST_RS423            ((DWORD)0x00000004)
#define PST_RS449            ((DWORD)0x00000005)
#define PST_MODEM            ((DWORD)0x00000006)
#define PST_FAX              ((DWORD)0x00000021)
#define PST_SCANNER          ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE   ((DWORD)0x00000100)
#define PST_LAT              ((DWORD)0x00000101)
#define PST_TCPIP_TELNET     ((DWORD)0x00000102)
#define PST_X25              ((DWORD)0x00000103)


//
// Provider capabilities flags.
//

#define PCF_DTRDSR        ((DWORD)0x0001)
#define PCF_RTSCTS        ((DWORD)0x0002)
#define PCF_RLSD          ((DWORD)0x0004)
#define PCF_PARITY_CHECK  ((DWORD)0x0008)
#define PCF_XONXOFF       ((DWORD)0x0010)
#define PCF_SETXCHAR      ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS   ((DWORD)0x0080)
#define PCF_SPECIALCHARS  ((DWORD)0x0100)
#define PCF_16BITMODE     ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY         ((DWORD)0x0001)
#define SP_BAUD           ((DWORD)0x0002)
#define SP_DATABITS       ((DWORD)0x0004)
#define SP_STOPBITS       ((DWORD)0x0008)
#define SP_HANDSHAKING    ((DWORD)0x0010)
#define SP_PARITY_CHECK   ((DWORD)0x0020)
#define SP_RLSD           ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075          ((DWORD)0x00000001)
#define BAUD_110          ((DWORD)0x00000002)
#define BAUD_134_5        ((DWORD)0x00000004)
#define BAUD_150          ((DWORD)0x00000008)
#define BAUD_300          ((DWORD)0x00000010)
#define BAUD_600          ((DWORD)0x00000020)
#define BAUD_1200         ((DWORD)0x00000040)
#define BAUD_1800         ((DWORD)0x00000080)
#define BAUD_2400         ((DWORD)0x00000100)
#define BAUD_4800         ((DWORD)0x00000200)
#define BAUD_7200         ((DWORD)0x00000400)
#define BAUD_9600         ((DWORD)0x00000800)
#define BAUD_14400        ((DWORD)0x00001000)
#define BAUD_19200        ((DWORD)0x00002000)
#define BAUD_38400        ((DWORD)0x00004000)
#define BAUD_56K          ((DWORD)0x00008000)
#define BAUD_128K         ((DWORD)0x00010000)
#define BAUD_115200       ((DWORD)0x00020000)
#define BAUD_57600        ((DWORD)0x00040000)
#define BAUD_USER         ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5        ((WORD)0x0001)
#define DATABITS_6        ((WORD)0x0002)
#define DATABITS_7        ((WORD)0x0004)
#define DATABITS_8        ((WORD)0x0008)
#define DATABITS_16       ((WORD)0x0010)
#define DATABITS_16X      ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10       ((WORD)0x0001)
#define STOPBITS_15       ((WORD)0x0002)
#define STOPBITS_20       ((WORD)0x0004)
#define PARITY_NONE       ((WORD)0x0100)
#define PARITY_ODD        ((WORD)0x0200)
#define PARITY_EVEN       ((WORD)0x0400)
#define PARITY_MARK       ((WORD)0x0800)
#define PARITY_SPACE      ((WORD)0x1000)

typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
#define COMMPROP_INITIALIZED ((DWORD)0xE73CF52E)

typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//
#define DTR_CONTROL_DISABLE    0x00
#define DTR_CONTROL_ENABLE     0x01
#define DTR_CONTROL_HANDSHAKE  0x02

//
// RTS Control Flow Values
//
#define RTS_CONTROL_DISABLE    0x00
#define RTS_CONTROL_ENABLE     0x01
#define RTS_CONTROL_HANDSHAKE  0x02
#define RTS_CONTROL_TOGGLE     0x03

typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0       // Ignore signal

//
// Basud rates at which the communication device operates
//

#define CBR_110             110
#define CBR_300             300
#define CBR_600             600
#define CBR_1200            1200
#define CBR_2400            2400
#define CBR_4800            4800
#define CBR_9600            9600
#define CBR_14400           14400
#define CBR_19200           19200
#define CBR_38400           38400
#define CBR_56000           56000
#define CBR_57600           57600
#define CBR_115200          115200
#define CBR_128000          128000
#define CBR_256000          256000

//
// Error Flags
//

#define CE_RXOVER           0x0001  // Receive Queue overflow
#define CE_OVERRUN          0x0002  // Receive Overrun Error
#define CE_RXPARITY         0x0004  // Receive Parity Error
#define CE_FRAME            0x0008  // Receive Framing error
#define CE_BREAK            0x0010  // Break Detected
#define CE_TXFULL           0x0100  // TX Queue is full
#define CE_PTO              0x0200  // LPTx Timeout
#define CE_IOE              0x0400  // LPTx I/O Error
#define CE_DNS              0x0800  // LPTx Device not selected
#define CE_OOP              0x1000  // LPTx Out-Of-Paper
#define CE_MODE             0x8000  // Requested mode unsupported

#define IE_BADID            (-1)    // Invalid or unsupported id
#define IE_OPEN             (-2)    // Device Already Open
#define IE_NOPEN            (-3)    // Device Not Open
#define IE_MEMORY           (-4)    // Unable to allocate queues
#define IE_DEFAULT          (-5)    // Error in default parameters
#define IE_HARDWARE         (-10)   // Hardware Not Present
#define IE_BYTESIZE         (-11)   // Illegal Byte Size
#define IE_BAUDRATE         (-12)   // Unsupported BaudRate

//
// Events
//

#define EV_RXCHAR           0x0001  // Any Character received
#define EV_RXFLAG           0x0002  // Received certain character
#define EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define EV_CTS              0x0008  // CTS changed state
#define EV_DSR              0x0010  // DSR changed state
#define EV_RLSD             0x0020  // RLSD changed state
#define EV_BREAK            0x0040  // BREAK received
#define EV_ERR              0x0080  // Line status error occurred
#define EV_RING             0x0100  // Ring signal detected
#define EV_PERR             0x0200  // Printer error occured
#define EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define EV_EVENT1           0x0800  // Provider specific event 1
#define EV_EVENT2           0x1000  // Provider specific event 2
#define EV_POWER            0x2000  // WINCE Power event.

//
// Escape Functions
//

#define SETXOFF             1       // Simulate XOFF received
#define SETXON              2       // Simulate XON received
#define SETRTS              3       // Set RTS high
#define CLRRTS              4       // Set RTS low
#define SETDTR              5       // Set DTR high
#define CLRDTR              6       // Set DTR low
// Gap for NT code RESETDEV, not supported on CE
#define SETBREAK            8       // Set the device break line.
#define CLRBREAK            9       // Clear the device break line.
// Some CE devices share a UART between an IRDA port and a serial port.
// These escape functions allow control over the mode.
#define SETIR               10      // Set the port to IR mode.
#define CLRIR               11      // Set the port to non-IR mode.

//
// PURGE function flags.
//
#define PURGE_TXABORT       0x0001  // Kill the pending/current writes to the comm port.
#define PURGE_RXABORT       0x0002  // Kill the pending/current reads to the comm port.
#define PURGE_TXCLEAR       0x0004  // Kill the transmit queue if there.
#define PURGE_RXCLEAR       0x0008  // Kill the typeahead buffer if there.

#define LPTx                0x80    // Set if ID is for LPT device

//
// Modem Status Flags
//
#define MS_CTS_ON           ((DWORD)0x0010)
#define MS_DSR_ON           ((DWORD)0x0020)
#define MS_RING_ON          ((DWORD)0x0040)
#define MS_RLSD_ON          ((DWORD)0x0080)

BOOL
WINAPI
ClearCommBreak(
    HANDLE hFile
    );


BOOL
WINAPI
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    );


BOOL
WINAPI
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    );


BOOL
WINAPI
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    );


BOOL
WINAPI
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    );


BOOL
WINAPI
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    );


BOOL
WINAPI
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    );


BOOL
WINAPI
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );


BOOL
WINAPI
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );


BOOL
WINAPI
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    );


BOOL
WINAPI
SetCommBreak(
    HANDLE hFile
    );


BOOL
WINAPI
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    );


BOOL
WINAPI
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );


BOOL
WINAPI
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );


BOOL
WINAPI
TransmitCommChar(
    HANDLE hFile,
    char cChar
    );


BOOL
WINAPI
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    );

// End if IF COREDLL_SERDEV
// @CESYSGEN ENDIF


//
// Power Management APIs
//
#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_UNKNOWN        0xFFFFFFFF

typedef struct _SYSTEM_POWER_STATUS_EX {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
    BYTE Reserved2;
    BYTE BackupBatteryFlag;
    BYTE BackupBatteryLifePercent;
    BYTE Reserved3;
    DWORD BackupBatteryLifeTime;
    DWORD BackupBatteryFullLifeTime;
}   SYSTEM_POWER_STATUS_EX, *PSYSTEM_POWER_STATUS_EX, *LPSYSTEM_POWER_STATUS_EX;



/*
    @struct SYSTEM_POWER_STATUS_EX2 | contains information about the power status
    of the system.

    @field BYTE | ACLineStatus | AC power status. Must be one of
    AC_LINE_OFFLINE, AC_LINE_ONLINE, AC_LINE_BACKUP_POWER, or AC_LINE_UNKNOWN.

    @field BYTE | BatteryFlag | Battery charge status.  Must be one of
    BATTERY_FLAG_HIGH, BATTERY_FLAG_LOW, BATTERY_FLAG_CRITICAL,
    BATTERY_FLAG_CHARGING, BATTERY_FLAG_NO_BATTERY, or BATTERY_FLAG_UNKNOWN

    @field BYTE | BatteryLifePercent | Percentage of full battery charge
    remaining.  Must be in the range 0 to 100, or BATTERY_PERCENTAGE_UNKNOWN.

    @field BYTE | Reserved1 | Must be zero.

    @field DWORD |  BatteryLifeTime | Number of seconds of battery life
    remaining, or BATTERY_LIFE_UNKNOWN if remaining seconds are unknown.

    @field DWORD | BatteryFullLifeTime | Number of seconds of battery life when
    at full charge, or BATTERY_LIFE_UNKNOWN if full lifetime is unknown.

    @field BYTE | Reserved2 | Must be zero.

    @field BYTE | BackupBatteryFlag | Backup battery charge status.  Must be one
    of BATTERY_FLAG_HIGH, BATTERY_FLAG_LOW, BATTERY_FLAG_CRITICAL,
    BATTERY_FLAG_CHARGING, BATTERY_FLAG_NO_BATTERY, or BATTERY_FLAG_UNKNOWN.

    @field BYTE | BackupBatteryLifePercent |  Percentage of full backup battery
    charge remaining.  Must be in the range 0 to 100, or
    BATTERY_PERCENTAGE_UNKNOWN.

    @field BYTE | Reserved3 | Must be zero.

    @field DWORD | BackupBatteryLifeTime | Number of seconds of backup battery
    life remaining, or BATTERY_LIFE_UNKNOWN if remaining seconds are unknown.

    @field DWORD | BackupBatteryFullLifeTime | Number of seconds of backup
    battery life when at full charge, or BATTERY_LIFE_UNKNOWN if full lifetime
    is unknown.

*/

#define BATTERY_CHEMISTRY_ALKALINE     0x01
#define BATTERY_CHEMISTRY_NICD         0x02
#define BATTERY_CHEMISTRY_NIMH         0x03
#define BATTERY_CHEMISTRY_LION         0x04
#define BATTERY_CHEMISTRY_LIPOLY       0x05
#define BATTERY_CHEMISTRY_ZINCAIR      0x06
#define BATTERY_CHEMISTRY_UNKNOWN      0xFF

typedef struct _SYSTEM_POWER_STATUS_EX2 {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
    BYTE Reserved2;
    BYTE BackupBatteryFlag;
    BYTE BackupBatteryLifePercent;
    BYTE Reserved3;
    DWORD BackupBatteryLifeTime;
    DWORD BackupBatteryFullLifeTime;
    // Above here is old struct, below are new fields
    DWORD BatteryVoltage;               // Reports Reading of battery voltage in millivolts (0..65535 mV)
    DWORD BatteryCurrent;               // Reports Instantaneous current drain (mA). 0..32767 for charge, 0 to -32768 for discharge
    DWORD BatteryAverageCurrent;        // Reports short term average of device current drain (mA). 0..32767 for charge, 0 to -32768 for discharge
    DWORD BatteryAverageInterval;       // Reports time constant (mS) of integration used in reporting BatteryAverageCurrent
    DWORD BatterymAHourConsumed;        // Reports long-term cumulative average DISCHARGE (mAH). Reset by charging or changing the batteries. 0 to 32767 mAH
    DWORD BatteryTemperature;           // Reports Battery temp in 0.1 degree C (-3276.8 to 3276.7 degrees C)
    DWORD BackupBatteryVoltage;         // Reports Reading of backup battery voltage
    BYTE  BatteryChemistry;             // See Chemistry defines above

    // New fields can be added below, but don't change any existing ones
}   SYSTEM_POWER_STATUS_EX2, *PSYSTEM_POWER_STATUS_EX2, *LPSYSTEM_POWER_STATUS_EX2;

// @CESYSGEN IF COREDLL_BATTERY
BOOL
WINAPI
GetSystemPowerStatusEx(
    PSYSTEM_POWER_STATUS_EX pSystemPowerStatusEx,
    BOOL fUpdate
    );

// Return value : 0 = fail.  Non-zero indicates length of returned data.
DWORD
WINAPI
GetSystemPowerStatusEx2(
    PSYSTEM_POWER_STATUS_EX2 pSystemPowerStatusEx2,
    DWORD dwLen,
    BOOL fUpdate
    );


void
WINAPI
BatteryNotifyOfTimeChange(
    BOOL fForward,
    FILETIME *pftDelta
    );
// @CESYSGEN ENDIF

// @CESYSGEN IF FILESYS_FSPASS
BOOL CheckPassword (LPWSTR lpszPassword);
// @CESYSGEN ENDIF

// define dwFlag values for LoadFSDEx function...
#define LOADFSD_ASYNCH              0x0000
#define LOADFSD_SYNCH               0x0001


HANDLE RegisterDevice (LPCWSTR lpszName, DWORD index, LPCWSTR lpszLib, DWORD dwInfo);
BOOL DeregisterDevice (__in_opt HANDLE hDevice);
BOOL LoadFSD (HANDLE hDevice, LPCWSTR lpFSDName);
BOOL LoadFSDEx (HANDLE hDevice, LPCWSTR lpFSDName, DWORD dwFlag);
HANDLE ActivateDevice(LPCWSTR lpszDevKey,DWORD dwClientInfo);
HANDLE ActivateDeviceEx(LPCWSTR lpszDevKey, LPCVOID lpRegEnts, DWORD cRegEnts, LPVOID lpvParam);
BOOL DeactivateDevice(__in_opt HANDLE hDevice);
BOOL CeResyncFilesys(HANDLE hDevice);

// This structure is used to obtain information about a device driver.  Some drivers may be
// accessible via multiple names; if a particular name does not exist, the first byte of the
// entry in the structure will be NULL.
typedef struct _DevmgrDeviceInformation_tag {
    DWORD dwSize;                   // size of this structure
    HANDLE hDevice;                 // device handle from ActivateDevice()
    HANDLE hParentDevice;           // parent device's handle from ActivateDevice()
    WCHAR szLegacyName[6];          // e.g, "COM1:"
    WCHAR szDeviceKey[MAX_PATH];    // key path passed to ActivateDevice
    WCHAR szDeviceName[MAX_PATH];   // in $device namespace
    WCHAR szBusName[MAX_PATH];      // in $bus namespace
} DEVMGR_DEVICE_INFORMATION, *PDEVMGR_DEVICE_INFORMATION;

BOOL GetDeviceInformationByDeviceHandle(HANDLE hDevice, __out PDEVMGR_DEVICE_INFORMATION pdi);
BOOL GetDeviceInformationByFileHandle(HANDLE hFile, __out PDEVMGR_DEVICE_INFORMATION pdi);

typedef enum {
    DeviceSearchByLegacyName,
    DeviceSearchByDeviceName,
    DeviceSearchByBusName,
    DeviceSearchByGuid,
    DeviceSearchByParent
} DeviceSearchType;

HANDLE FindFirstDevice(DeviceSearchType searchType, LPCVOID pvSearchParam, __out PDEVMGR_DEVICE_INFORMATION pdi);
BOOL FindNextDevice(HANDLE h, __out PDEVMGR_DEVICE_INFORMATION pdi);

BOOL EnumDeviceInterfaces(HANDLE h, DWORD dwIndex, GUID *pClass, __out_bcount_opt(*lpdwNameBufSize) LPWSTR pszNameBuf, __inout_opt LPDWORD lpdwNameBufSize);

// It looks like a registry operation but it's really a device operation
HKEY RegOpenProcessKey(DWORD hPnp);

// This function is also exported by FILESYS
BOOL CeGenRandom(DWORD dwLen, __inout_bcount(dwLen) PBYTE pbBuffer);

// @CESYSGEN IF DEVICE_IORM
BOOL ResourceCreateList (DWORD dwResId, DWORD dwMinimum, DWORD dwCount);
BOOL ResourceDestroyList (DWORD dwResId);
BOOL ResourceRequest (DWORD dwResId, DWORD dwId, DWORD dwLen);
BOOL ResourceRequestEx (DWORD dwResId, DWORD dwId, DWORD dwLen, DWORD dwFlags);
BOOL ResourceRelease (DWORD dwResId, DWORD dwId, DWORD dwLen);
BOOL ResourceMarkAsShareable(DWORD dwResId, DWORD dwId, DWORD dwLen, BOOL fShareable);

// flag values for ResourceRequestEx()
#define RREXF_REQUEST_EXCLUSIVE         0x0001
// @CESYSGEN ENDIF

// @CESYSGEN IF FILESYS_FSADVERTISE
HANDLE RequestDeviceNotifications (const GUID *devclass, HANDLE hMsgQ, BOOL fAll);
BOOL StopDeviceNotifications (HANDLE h);
BOOL AdvertiseInterface (const GUID *devclass, LPCWSTR name, BOOL fAdd);
// @CESYSGEN ENDIF

// @CESYSGEN IF NK_NKMSGQ

// NOTE: DO NOT USE '<msgqueue.h>' to ensure we include the file locally
#include "msgqueue.h"

// @CESYSGEN ENDIF


//
// Extended Name APIs for NTDS
//

typedef enum
{
    // Examples for the following formats assume a fictitous company
    // which hooks into the global X.500 and DNS name spaces as follows.
    //
    // Enterprise root domain in DNS is
    //
    //      widget.com
    //
    // Enterprise root domain in X.500 (RFC 1779 format) is
    //
    //      O=Widget, C=US
    //
    // There exists the child domain
    //
    //      engineering.widget.com
    //
    // equivalent to
    //
    //      OU=Engineering, O=Widget, C=US
    //
    // There exists a container within the Engineering domain
    //
    //      OU=Software, OU=Engineering, O=Widget, C=US
    //
    // There exists the user
    //
    //      CN=Spencer Katt, OU=Software, OU=Engineering, O=Widget, C=US
    //
    // And this user's downlevel (pre-NTDS) user name is
    //
    //      Engineering\SpencerK

    // unknown name type
    NameUnknown = 0,

    // CN=Spencer Katt, OU=Software, OU=Engineering, O=Widget, C=US
    NameFullyQualifiedDN = 1,

    // Engineering\SpencerK
    NameSamCompatible = 2,

    // Probably "Spencer Katt" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    NameDisplay = 3,

    // xxx@engineering.widget.com where xxx could be "SpencerK" or
    // anything else.  Could be multi-valued to handle migration and aliasing.
    NameDomainSimple = 4,

    // xxx@widget.com where xxx could be "SpencerK" or anything else.
    // Could be multi-valued to handle migration and aliasing.
    NameEnterpriseSimple = 5,

    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    NameUniqueId = 6,

    // engineering.widget.com/software/spencer katt
    NameCanonical = 7,

    // local logon name
    NameWindowsCeLocal = 0x80000001

} EXTENDED_NAME_FORMAT, * PEXTENDED_NAME_FORMAT ;

BOOLEAN
WINAPI
GetUserNameExA(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );

BOOLEAN
WINAPI
GetUserNameExW(
    EXTENDED_NAME_FORMAT NameFormat,
    __out_bcount(*nSize) LPWSTR lpNameBuffer,
    PULONG nSize
    );

//
// Event logging APIs
//

BOOL WINAPI ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID,
                 PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize,
                 __out_ecount(wNumStrings) LPCWSTR* lpStrings, LPVOID lpRawData);

HANDLE WINAPI RegisterEventSourceW(LPCWSTR lpUNCServerName,  LPCWSTR lpSourceName);

BOOL WINAPI DeregisterEventSource(HANDLE hEventLog);
BOOL WINAPI ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName);

HANDLE WINAPI OpenEventLogW(LPCTSTR lpUNCServerName, LPCTSTR lpSourceName);
BOOL WINAPI CloseEventLog(HANDLE hEventLog);
BOOL WINAPI BackupEventLogW(HANDLE hEventLog, LPCTSTR szBackupFileName);
BOOL WINAPI LockEventLog(HANDLE hEventLog);
BOOL WINAPI UnLockEventLog(HANDLE hEventLog);
BOOL WINAPI ReadEventLogRaw(HANDLE hEventLog, BYTE *pReadBuffer, DWORD dwReadBufferSize, DWORD *pdwBytesRead);

#define ReportEvent           ReportEventW
#define RegisterEventSource   RegisterEventSourceW
#define ClearEventLog         ClearEventLogW
#define OpenEventLog          OpenEventLogW
#define BackupEventLog        BackupEventLogW


#ifdef UNICODE
#define GetUserNameEx   GetUserNameExW
#else
#define GetUserNameEx   GetUserNameExA
#endif

DWORD
WINAPI
CeCertVerify (
    HANDLE hFile,
    HANDLE * phHandle,
    LPCWSTR pszFileName,
    LPWSTR pszAccountName,
    DWORD cbAccountNameSize,
    DWORD dwFlags);


#include <winnls.h>

#ifdef UNDER_CE
#ifdef WINCEOEM
#include <pwinbase.h>   // internal defines
#ifdef WINCEMACRO
#include <mwinbase.h>
#endif
#endif
#include <windbase.h>
#endif

#ifdef UNDER_CE
// special multi-language redirection resource previously defined in oak\inc\pwinbase.h
#define RT_MUI  222 // type of the redirection resource
#define ID_MUI  1   // ID of the redirection resource
// the redirection resource is a wide-string, whose value is the basename of the resource DLL
#endif

#ifdef __cplusplus
}
#endif

#endif /* __WINBASE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\winctrl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Video control interface base classes, December 1995

#ifndef __WINCTRL__
#define __WINCTRL__

#define ABSOL(x) (x < 0 ? -x : x)
#define NEGAT(x) (x > 0 ? -x : x)

//  Helper
BOOL WINAPI PossiblyEatMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CBaseControlWindow : public CBaseVideoWindow, public CBaseWindow
{
protected:

    CBaseFilter *m_pFilter;            // Pointer to owning media filter
    CBasePin *m_pPin;                  // Controls media types for connection
    CCritSec *m_pInterfaceLock;        // Externally defined critical section
    COLORREF m_BorderColour;           // Current window border colour
    BOOL m_bAutoShow;                  // What happens when the state changes
    HWND m_hwndOwner;                  // Owner window that we optionally have
    HWND m_hwndDrain;                  // HWND to post any messages received
    BOOL m_bCursorHidden;              // Should we hide the window cursor

public:

    // Internal methods for other objects to get information out

    HRESULT DoSetWindowStyle(long Style,long WindowLong);
    HRESULT DoGetWindowStyle(long *pStyle,long WindowLong);
    BOOL IsAutoShowEnabled() { return m_bAutoShow; };
    COLORREF GetBorderColour() { return m_BorderColour; };
    HWND GetOwnerWindow() { return m_hwndOwner; };
    BOOL IsCursorHidden() { return m_bCursorHidden; };

    inline BOOL PossiblyEatMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::PossiblyEatMessage(m_hwndDrain, uMsg, wParam, lParam);
    }

    // Derived classes must call this to set the pin the filter is using
    // We don't have the pin passed in to the constructor (as we do with
    // the CBaseFilter object) because filters typically create the
    // pins dynamically when requested in CBaseFilter::GetPin. This can
    // not be called from our constructor because is is a virtual method

    void SetControlWindowPin(CBasePin *pPin) {
        m_pPin = pPin;
    }

public:

    CBaseControlWindow(CBaseFilter *pFilter,   // Owning media filter
                       CCritSec *pInterfaceLock,    // Locking object
                       TCHAR *pName,                // Object description
                       LPUNKNOWN pUnk,              // Normal COM ownership
                       HRESULT *phr);               // OLE return code

    // These are the properties we support

    STDMETHODIMP put_Caption(BSTR strCaption);
    STDMETHODIMP get_Caption(BSTR *pstrCaption);
    STDMETHODIMP put_AutoShow(long AutoShow);
    STDMETHODIMP get_AutoShow(long *AutoShow);
    STDMETHODIMP put_WindowStyle(long WindowStyle);
    STDMETHODIMP get_WindowStyle(long *pWindowStyle);
    STDMETHODIMP put_WindowStyleEx(long WindowStyleEx);
    STDMETHODIMP get_WindowStyleEx(long *pWindowStyleEx);
    STDMETHODIMP put_WindowState(long WindowState);
    STDMETHODIMP get_WindowState(long *pWindowState);
    STDMETHODIMP put_BackgroundPalette(long BackgroundPalette);
    STDMETHODIMP get_BackgroundPalette(long *pBackgroundPalette);
    STDMETHODIMP put_Visible(long Visible);
    STDMETHODIMP get_Visible(long *pVisible);
    STDMETHODIMP put_Left(long Left);
    STDMETHODIMP get_Left(long *pLeft);
    STDMETHODIMP put_Width(long Width);
    STDMETHODIMP get_Width(long *pWidth);
    STDMETHODIMP put_Top(long Top);
    STDMETHODIMP get_Top(long *pTop);
    STDMETHODIMP put_Height(long Height);
    STDMETHODIMP get_Height(long *pHeight);
    STDMETHODIMP put_Owner(OAHWND Owner);
    STDMETHODIMP get_Owner(OAHWND *Owner);
    STDMETHODIMP put_MessageDrain(OAHWND Drain);
    STDMETHODIMP get_MessageDrain(OAHWND *Drain);
    STDMETHODIMP get_BorderColor(long *Color);
    STDMETHODIMP put_BorderColor(long Color);
    STDMETHODIMP get_FullScreenMode(long *FullScreenMode);
    STDMETHODIMP put_FullScreenMode(long FullScreenMode);

    // And these are the methods

    STDMETHODIMP SetWindowForeground(long Focus);
    STDMETHODIMP NotifyOwnerMessage(OAHWND hwnd,long uMsg,LONG_PTR wParam,LONG_PTR lParam);
    STDMETHODIMP GetMinIdealImageSize(long *pWidth,long *pHeight);
    STDMETHODIMP GetMaxIdealImageSize(long *pWidth,long *pHeight);
    STDMETHODIMP SetWindowPosition(long Left,long Top,long Width,long Height);
    STDMETHODIMP GetWindowPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight);
    STDMETHODIMP GetRestorePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight);
	STDMETHODIMP HideCursor(long HideCursor);
    STDMETHODIMP IsCursorHidden(long *CursorHidden);
};

// This class implements the IBasicVideo interface

class CBaseControlVideo : public CBaseBasicVideo
{
protected:

    CBaseFilter *m_pFilter;   // Pointer to owning media filter
    CBasePin *m_pPin;                   // Controls media types for connection
    CCritSec *m_pInterfaceLock;         // Externally defined critical section

public:

    // Derived classes must provide these for the implementation

    virtual HRESULT IsDefaultTargetRect() PURE;
    virtual HRESULT SetDefaultTargetRect() PURE;
    virtual HRESULT SetTargetRect(RECT *pTargetRect) PURE;
    virtual HRESULT GetTargetRect(RECT *pTargetRect) PURE;
    virtual HRESULT IsDefaultSourceRect() PURE;
    virtual HRESULT SetDefaultSourceRect() PURE;
    virtual HRESULT SetSourceRect(RECT *pSourceRect) PURE;
    virtual HRESULT GetSourceRect(RECT *pSourceRect) PURE;
    virtual HRESULT GetStaticImage(long *pBufferSize,long *pDIBImage) PURE;

    // Derived classes must override this to return a VIDEOINFO representing
    // the video format. We cannot call IPin ConnectionMediaType to get this
    // format because various filters dynamically change the type when using
    // DirectDraw such that the format shows the position of the logical
    // bitmap in a frame buffer surface, so the size might be returned as
    // 1024x768 pixels instead of 320x240 which is the real video dimensions

    virtual VIDEOINFOHEADER *GetVideoFormat() PURE;

    // Helper functions for creating memory renderings of a DIB image

    HRESULT GetImageSize(VIDEOINFOHEADER *pVideoInfo,
                         LONG *pBufferSize,
                         RECT *pSourceRect);

    HRESULT CopyImage(IMediaSample *pMediaSample,
                      VIDEOINFOHEADER *pVideoInfo,
                      LONG *pBufferSize,
                      BYTE *pVideoImage,
                      RECT *pSourceRect);

    // Override this if you want notifying when the rectangles change
    virtual HRESULT OnUpdateRectangles() { return NOERROR; };
    virtual HRESULT OnVideoSizeChange();

    // Derived classes must call this to set the pin the filter is using
    // We don't have the pin passed in to the constructor (as we do with
    // the CBaseFilter object) because filters typically create the
    // pins dynamically when requested in CBaseFilter::GetPin. This can
    // not be called from our constructor because is is a virtual method

    void SetControlVideoPin(CBasePin *pPin) {
        m_pPin = pPin;
    }

    // Helper methods for checking rectangles
    virtual HRESULT CheckSourceRect(RECT *pSourceRect);
    virtual HRESULT CheckTargetRect(RECT *pTargetRect);

public:

    CBaseControlVideo(CBaseFilter *pFilter,    // Owning media filter
                      CCritSec *pInterfaceLock,     // Serialise interface
                      TCHAR *pName,                 // Object description
                      LPUNKNOWN pUnk,               // Normal COM ownership
                      HRESULT *phr);                // OLE return code

    // These are the properties we support

    STDMETHODIMP get_AvgTimePerFrame(REFTIME *pAvgTimePerFrame);
    STDMETHODIMP get_BitRate(long *pBitRate);
    STDMETHODIMP get_BitErrorRate(long *pBitErrorRate);
    STDMETHODIMP get_VideoWidth(long *pVideoWidth);
    STDMETHODIMP get_VideoHeight(long *pVideoHeight);
    STDMETHODIMP put_SourceLeft(long SourceLeft);
    STDMETHODIMP get_SourceLeft(long *pSourceLeft);
    STDMETHODIMP put_SourceWidth(long SourceWidth);
    STDMETHODIMP get_SourceWidth(long *pSourceWidth);
    STDMETHODIMP put_SourceTop(long SourceTop);
    STDMETHODIMP get_SourceTop(long *pSourceTop);
    STDMETHODIMP put_SourceHeight(long SourceHeight);
    STDMETHODIMP get_SourceHeight(long *pSourceHeight);
    STDMETHODIMP put_DestinationLeft(long DestinationLeft);
    STDMETHODIMP get_DestinationLeft(long *pDestinationLeft);
    STDMETHODIMP put_DestinationWidth(long DestinationWidth);
    STDMETHODIMP get_DestinationWidth(long *pDestinationWidth);
    STDMETHODIMP put_DestinationTop(long DestinationTop);
    STDMETHODIMP get_DestinationTop(long *pDestinationTop);
    STDMETHODIMP put_DestinationHeight(long DestinationHeight);
    STDMETHODIMP get_DestinationHeight(long *pDestinationHeight);

    // And these are the methods

    STDMETHODIMP GetVideoSize(long *pWidth,long *pHeight);
    STDMETHODIMP SetSourcePosition(long Left,long Top,long Width,long Height);
    STDMETHODIMP GetSourcePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight);
    STDMETHODIMP GetVideoPaletteEntries(long StartIndex,long Entries,long *pRetrieved,long *pPalette);
    STDMETHODIMP SetDefaultSourcePosition();
    STDMETHODIMP IsUsingDefaultSource();
    STDMETHODIMP SetDestinationPosition(long Left,long Top,long Width,long Height);
    STDMETHODIMP GetDestinationPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight);
    STDMETHODIMP SetDefaultDestinationPosition();
    STDMETHODIMP IsUsingDefaultDestination();
    STDMETHODIMP GetCurrentImage(long *pBufferSize,long *pVideoImage);
};

#endif // __WINCTRL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wincrypt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __WINCRYPT_H__
#define __WINCRYPT_H__

#include <specstrings.h>        /* for SAL annotations */

#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef __success(return >= 0) long HRESULT;
#endif

#ifndef WINADVAPI
#define WINADVAPI
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef CALLBACK
#define CALLBACK __stdcall
#endif

#ifndef DECLSPEC_IMPORT
#define DECLSPEC_IMPORT
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#if !defined(WINCRYPT32API)
#if !defined(_CRYPT32_)
#define WINCRYPT32API DECLSPEC_IMPORT
#else
#define WINCRYPT32API
#endif
#endif

#if !defined(WINCRYPT32STRINGAPI)
#if !defined(_CRYPT32STRING_)
#define WINCRYPT32STRINGAPI WINCRYPT32API
#else
#define WINCRYPT32STRINGAPI
#endif
#endif

//
// Algorithm IDs and Flags
//

// ALG_ID crackers
#define GET_ALG_CLASS(x)                (x & (7 << 13))
#define GET_ALG_TYPE(x)                 (x & (15 << 9))
#define GET_ALG_SID(x)                  (x & (511))

// Algorithm classes
// certenrolld_begin -- ALG_CLASS_*
#define ALG_CLASS_ANY                   (0)
#define ALG_CLASS_SIGNATURE             (1 << 13)
#define ALG_CLASS_MSG_ENCRYPT           (2 << 13)
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_CLASS_HASH                  (4 << 13)
#define ALG_CLASS_KEY_EXCHANGE          (5 << 13)
#define ALG_CLASS_ALL                   (7 << 13)
// certenrolld_end

// Algorithm types
#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSS                    (1 << 9)
#define ALG_TYPE_RSA                    (2 << 9)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_TYPE_STREAM                 (4 << 9)
#define ALG_TYPE_DH                     (5 << 9)
#define ALG_TYPE_SECURECHANNEL          (6 << 9)

// Generic sub-ids
#define ALG_SID_ANY                     (0)

// Some RSA sub-ids
#define ALG_SID_RSA_ANY                 0
#define ALG_SID_RSA_PKCS                1
#define ALG_SID_RSA_MSATWORK            2
#define ALG_SID_RSA_ENTRUST             3
#define ALG_SID_RSA_PGP                 4

// Some DSS sub-ids
//
#define ALG_SID_DSS_ANY                 0
#define ALG_SID_DSS_PKCS                1
#define ALG_SID_DSS_DMS                 2
#define ALG_SID_ECDSA                   3

// Block cipher sub ids
// DES sub_ids
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_IDEA                    5
#define ALG_SID_CAST                    6
#define ALG_SID_SAFERSK64               7
#define ALG_SID_SAFERSK128              8
#define ALG_SID_3DES_112                9
#define ALG_SID_CYLINK_MEK              12
#define ALG_SID_RC5                     13
#define ALG_SID_AES_128                 14
#define ALG_SID_AES_192                 15
#define ALG_SID_AES_256                 16
#define ALG_SID_AES                     17

// Fortezza sub-ids
#define ALG_SID_SKIPJACK                10
#define ALG_SID_TEK                     11

// KP_MODE
#define CRYPT_MODE_CBCI                 6       // ANSI CBC Interleaved
#define CRYPT_MODE_CFBP                 7       // ANSI CFB Pipelined
#define CRYPT_MODE_OFBP                 8       // ANSI OFB Pipelined
#define CRYPT_MODE_CBCOFM               9       // ANSI CBC + OF Masking
#define CRYPT_MODE_CBCOFMI              10      // ANSI CBC + OFM Interleaved

// RC2 sub-ids
#define ALG_SID_RC2                     2

// Stream cipher sub-ids
#define ALG_SID_RC4                     1
#define ALG_SID_SEAL                    2

// Diffie-Hellman sub-ids
#define ALG_SID_DH_SANDF                1
#define ALG_SID_DH_EPHEM                2
#define ALG_SID_AGREED_KEY_ANY          3
#define ALG_SID_KEA                     4
#define ALG_SID_ECDH                    5

// Hash sub ids
#define ALG_SID_MD2                     1
#define ALG_SID_MD4                     2
#define ALG_SID_MD5                     3
#define ALG_SID_SHA                     4
#define ALG_SID_SHA1                    4
#define ALG_SID_MAC                     5
#define ALG_SID_RIPEMD                  6
#define ALG_SID_RIPEMD160               7
#define ALG_SID_SSL3SHAMD5              8
#define ALG_SID_HMAC                    9
#define ALG_SID_TLS1PRF                 10
#define ALG_SID_HASH_REPLACE_OWF        11
#define ALG_SID_SHA_256                 12
#define ALG_SID_SHA_384                 13
#define ALG_SID_SHA_512                 14

// secure channel sub ids
#define ALG_SID_SSL3_MASTER             1
#define ALG_SID_SCHANNEL_MASTER_HASH    2
#define ALG_SID_SCHANNEL_MAC_KEY        3
#define ALG_SID_PCT1_MASTER             4
#define ALG_SID_SSL2_MASTER             5
#define ALG_SID_TLS1_MASTER             6
#define ALG_SID_SCHANNEL_ENC_KEY        7

// misc ECC sub ids
#define ALG_SID_ECMQV                   1

// Our silly example sub-id
#define ALG_SID_EXAMPLE                 80

// certenrolls_begin -- PROV_ENUMALGS_EX
#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif
// certenrolls_end

// algorithm identifier definitions
#define CALG_MD2                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2)
#define CALG_MD4                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4)
#define CALG_MD5                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define CALG_SHA                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA)
#define CALG_SHA1               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1)
#define CALG_MAC                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MAC)
#define CALG_RSA_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY)
#define CALG_DSS_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_DSS_ANY)
#define CALG_NO_SIGN            (ALG_CLASS_SIGNATURE | ALG_TYPE_ANY | ALG_SID_ANY)
#define CALG_RSA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_3DES_112           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES_112)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_DESX               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DESX)
#define CALG_RC2                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2)
#define CALG_RC4                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)
#define CALG_SEAL               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_SEAL)
#define CALG_DH_SF              (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_SANDF)
#define CALG_DH_EPHEM           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_EPHEM)
#define CALG_AGREEDKEY_ANY      (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_AGREED_KEY_ANY)
#define CALG_KEA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_KEA)
#define CALG_HUGHES_MD5         (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_ANY|ALG_SID_MD5)
#define CALG_SKIPJACK           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_SKIPJACK)
#define CALG_TEK                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_TEK)
#define CALG_CYLINK_MEK         (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_CYLINK_MEK)
#define CALG_SSL3_SHAMD5        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)
#define CALG_SSL3_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL3_MASTER)
#define CALG_SCHANNEL_MASTER_HASH   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MASTER_HASH)
#define CALG_SCHANNEL_MAC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MAC_KEY)
#define CALG_SCHANNEL_ENC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_ENC_KEY)
#define CALG_PCT1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_PCT1_MASTER)
#define CALG_SSL2_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL2_MASTER)
#define CALG_TLS1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_TLS1_MASTER)
#define CALG_RC5                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC5)
#define CALG_HMAC               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HMAC)
#define CALG_TLS1PRF            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_TLS1PRF)
#define CALG_HASH_REPLACE_OWF   (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HASH_REPLACE_OWF)
#define CALG_AES_128            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_128)
#define CALG_AES_192            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_192)
#define CALG_AES_256            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_256)
#define CALG_AES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES)
#define CALG_SHA_256            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_256)
#define CALG_SHA_384            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_384)
#define CALG_SHA_512            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_512)
#define CALG_ECDH               (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_DH | ALG_SID_ECDH)
#define CALG_ECMQV              (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_ANY | ALG_SID_ECMQV)
#define CALG_ECDSA              (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_ECDSA)


#ifdef UNDER_CE
// resource number for signatures in the CSP
#define SIGNATURE_RESOURCE_NUMBER       0x29A

typedef struct _VTableProvStruc {
    DWORD   Version;
    FARPROC FuncVerifyImage;
    FARPROC FuncReturnhWnd;
    DWORD   dwProvType;
    BYTE        *pbContextInfo;
    DWORD       cbContextInfo;
    LPWSTR   pszProvName;   // WinCE: LPWSTR, otherwise LPSTR
} VTableProvStruc, *PVTableProvStruc;
#endif 

// Used for certenroll.idl:
// certenrolls_begin -- HCRYPT*
typedef ULONG_PTR HCRYPTPROV;
typedef ULONG_PTR HCRYPTKEY;
typedef ULONG_PTR HCRYPTHASH;
// certenrolls_end



// dwFlags definitions for CryptAcquireContext
#define CRYPT_VERIFYCONTEXT     0xF0000000
#define CRYPT_NEWKEYSET         0x00000008
#define CRYPT_DELETEKEYSET      0x00000010
#define CRYPT_MACHINE_KEYSET    0x00000020
#define CRYPT_SILENT            0x00000040
#define CRYPT_DEFAULT_CONTAINER_OPTIONAL 0x00000080

// dwFlag definitions for CryptGenKey
#define CRYPT_EXPORTABLE        0x00000001
#define CRYPT_USER_PROTECTED    0x00000002
#define CRYPT_CREATE_SALT       0x00000004
#define CRYPT_UPDATE_KEY        0x00000008
#define CRYPT_NO_SALT           0x00000010
#define CRYPT_PREGEN            0x00000040
#define CRYPT_RECIPIENT         0x00000010
#define CRYPT_INITIATOR         0x00000040
#define CRYPT_ONLINE            0x00000080
#define CRYPT_SF                0x00000100
#define CRYPT_CREATE_IV         0x00000200
#define CRYPT_KEK               0x00000400
#define CRYPT_DATA_KEY          0x00000800
#define CRYPT_VOLATILE          0x00001000
#define CRYPT_SGCKEY            0x00002000
#define CRYPT_ARCHIVABLE        0x00004000
#define CRYPT_FORCE_KEY_PROTECTION_HIGH 0x00008000

#define RSA1024BIT_KEY          0x04000000

// dwFlags definitions for CryptDeriveKey
#define CRYPT_SERVER            0x00000400

#define ALGID_MASK_SIZE         0x10
#define ALGID_MASK              ( ( 0x1 << ALGID_MASK_SIZE ) - 1 )
#define KEY_LENGTH_MASK         ( ALGID_MASK << ALGID_MASK_SIZE )

// dwFlag definitions for CryptExportKey
#define CRYPT_Y_ONLY            0x00000001
#define CRYPT_SSL2_FALLBACK     0x00000002
#define CRYPT_DESTROYKEY        0x00000004
#define CRYPT_OAEP              0x00000040  // used with RSA encryptions/decryptions
                                            // CryptExportKey, CryptImportKey,
                                            // CryptEncrypt and CryptDecrypt

#define CRYPT_BLOB_VER3         0x00000080  // export version 3 of a blob type
#define CRYPT_IPSEC_HMAC_KEY    0x00000100  // CryptImportKey only

// dwFlags definitions for CryptDecrypt
//  See also CRYPT_OAEP, above.
//  Note, the following flag is not supported for CryptEncrypt
#define CRYPT_DECRYPT_RSA_NO_PADDING_CHECK      0x00000020

// dwFlags definitions for CryptCreateHash
#define CRYPT_SECRETDIGEST      0x00000001

// dwFlags definitions for CryptHashData
#define CRYPT_OWF_REPL_LM_HASH  0x00000001  // this is only for the OWF replacement CSP

// dwFlags definitions for CryptHashSessionKey
#define CRYPT_LITTLE_ENDIAN     0x00000001

// dwFlags definitions for CryptSignHash and CryptVerifySignature
#define CRYPT_NOHASHOID         0x00000001
#define CRYPT_TYPE2_FORMAT      0x00000002
#define CRYPT_X931_FORMAT       0x00000004

// dwFlag definitions for CryptSetProviderEx and CryptGetDefaultProvider
#define CRYPT_MACHINE_DEFAULT   0x00000001
#define CRYPT_USER_DEFAULT      0x00000002
#define CRYPT_DELETE_DEFAULT    0x00000004

// exported key blob definitions
// certenrolld_begin -- *BLOB
#define SIMPLEBLOB              0x1
#define PUBLICKEYBLOB           0x6
#define PRIVATEKEYBLOB          0x7
#define PLAINTEXTKEYBLOB        0x8
#define OPAQUEKEYBLOB           0x9
#define PUBLICKEYBLOBEX         0xA
#define SYMMETRICWRAPKEYBLOB    0xB
#define KEYSTATEBLOB            0xC
// certenrolld_end

// certenrolld_begin -- AT_*
#define AT_KEYEXCHANGE          1
#define AT_SIGNATURE            2
// certenrolld_end

#define CRYPT_USERDATA          1

// dwParam
#define KP_IV                   1       // Initialization vector
#define KP_SALT                 2       // Salt value
#define KP_PADDING              3       // Padding values
#define KP_MODE                 4       // Mode of the cipher
#define KP_MODE_BITS            5       // Number of bits to feedback
#define KP_PERMISSIONS          6       // Key permissions DWORD
#define KP_ALGID                7       // Key algorithm
#define KP_BLOCKLEN             8       // Block size of the cipher
#define KP_KEYLEN               9       // Length of key in bits
#define KP_SALT_EX              10      // Length of salt in bytes
#define KP_P                    11      // DSS/Diffie-Hellman P value
#define KP_G                    12      // DSS/Diffie-Hellman G value
#define KP_Q                    13      // DSS Q value
#define KP_X                    14      // Diffie-Hellman X value
#define KP_Y                    15      // Y value
#define KP_RA                   16      // Fortezza RA value
#define KP_RB                   17      // Fortezza RB value
#define KP_INFO                 18      // for putting information into an RSA envelope
#define KP_EFFECTIVE_KEYLEN     19      // setting and getting RC2 effective key length
#define KP_SCHANNEL_ALG         20      // for setting the Secure Channel algorithms
#define KP_CLIENT_RANDOM        21      // for setting the Secure Channel client random data
#define KP_SERVER_RANDOM        22      // for setting the Secure Channel server random data
#define KP_RP                   23
#define KP_PRECOMP_MD5          24
#define KP_PRECOMP_SHA          25
#define KP_CERTIFICATE          26      // for setting Secure Channel certificate data (PCT1)
#define KP_CLEAR_KEY            27      // for setting Secure Channel clear key data (PCT1)
#define KP_PUB_EX_LEN           28
#define KP_PUB_EX_VAL           29
#define KP_KEYVAL               30
#define KP_ADMIN_PIN            31
#define KP_KEYEXCHANGE_PIN      32
#define KP_SIGNATURE_PIN        33
#define KP_PREHASH              34
#define KP_ROUNDS               35
#define KP_OAEP_PARAMS          36      // for setting OAEP params on RSA keys
#define KP_CMS_KEY_INFO         37
#define KP_CMS_DH_KEY_INFO      38
#define KP_PUB_PARAMS           39      // for setting public parameters
#define KP_VERIFY_PARAMS        40      // for verifying DSA and DH parameters
#define KP_HIGHEST_VERSION      41      // for TLS protocol version setting
#define KP_GET_USE_COUNT        42      // for use with PP_CRYPT_COUNT_KEY_USE contexts

// KP_PADDING
#define PKCS5_PADDING           1       // PKCS 5 (sec 6.2) padding method
#define RANDOM_PADDING          2
#define ZERO_PADDING            3

// KP_MODE
#define CRYPT_MODE_CBC          1       // Cipher block chaining
#define CRYPT_MODE_ECB          2       // Electronic code book
#define CRYPT_MODE_OFB          3       // Output feedback mode
#define CRYPT_MODE_CFB          4       // Cipher feedback mode
#define CRYPT_MODE_CTS          5       // Ciphertext stealing mode

//
// KP_MODE Flags (High 16 Bits)
//

#define CRYPT_MODE_NOPAD        0x00010000

// KP_PERMISSIONS
#define CRYPT_ENCRYPT           0x0001  // Allow encryption
#define CRYPT_DECRYPT           0x0002  // Allow decryption
#define CRYPT_EXPORT            0x0004  // Allow key to be exported
#define CRYPT_READ              0x0008  // Allow parameters to be read
#define CRYPT_WRITE             0x0010  // Allow parameters to be set
#define CRYPT_MAC               0x0020  // Allow MACs to be used with key
#define CRYPT_EXPORT_KEY        0x0040  // Allow key to be used for exporting keys
#define CRYPT_IMPORT_KEY        0x0080  // Allow key to be used for importing keys
#define CRYPT_ARCHIVE           0x0100  // Allow key to be exported at creation only

#define HP_ALGID                0x0001  // Hash algorithm
#define HP_HASHVAL              0x0002  // Hash value
#define HP_HASHSIZE             0x0004  // Hash value size
#define HP_HMAC_INFO            0x0005  // information for creating an HMAC
#define HP_TLS1PRF_LABEL        0x0006  // label for TLS1 PRF
#define HP_TLS1PRF_SEED         0x0007  // seed for TLS1 PRF

#define CRYPT_FAILED            FALSE
#define CRYPT_SUCCEED           TRUE

#define RCRYPT_SUCCEEDED(rt)     ((rt) == CRYPT_SUCCEED)
#define RCRYPT_FAILED(rt)        ((rt) == CRYPT_FAILED)

//
// CryptGetProvParam
//
#define PP_ENUMALGS             1
#define PP_ENUMCONTAINERS       2
#define PP_IMPTYPE              3
#define PP_NAME                 4
#define PP_VERSION              5
#define PP_CONTAINER            6
#define PP_CHANGE_PASSWORD      7
#define PP_KEYSET_SEC_DESCR     8       // get/set security descriptor of keyset
#define PP_CERTCHAIN            9       // for retrieving certificates from tokens
#define PP_KEY_TYPE_SUBTYPE     10
#define PP_PROVTYPE             16
#define PP_KEYSTORAGE           17
#define PP_APPLI_CERT           18
#define PP_SYM_KEYSIZE          19
#define PP_SESSION_KEYSIZE      20
#define PP_UI_PROMPT            21
#define PP_ENUMALGS_EX          22
#define PP_ENUMMANDROOTS        25
#define PP_ENUMELECTROOTS       26
#define PP_KEYSET_TYPE          27
#define PP_ADMIN_PIN            31
#define PP_KEYEXCHANGE_PIN      32
#define PP_SIGNATURE_PIN        33
#define PP_SIG_KEYSIZE_INC      34
#define PP_KEYX_KEYSIZE_INC     35
#define PP_UNIQUE_CONTAINER     36
#define PP_SGC_INFO             37
#define PP_USE_HARDWARE_RNG     38
#define PP_KEYSPEC              39
#define PP_ENUMEX_SIGNING_PROT  40
#define PP_CRYPT_COUNT_KEY_USE  41
#define PP_USER_CERTSTORE       42
#define PP_SMARTCARD_READER     43
#define PP_SMARTCARD_GUID       45
#define PP_ROOT_CERTSTORE       46

#define CRYPT_FIRST             1
#define CRYPT_NEXT              2
#define CRYPT_SGC_ENUM          4

#define CRYPT_IMPL_HARDWARE     1
#define CRYPT_IMPL_SOFTWARE     2
#define CRYPT_IMPL_MIXED        3
#define CRYPT_IMPL_UNKNOWN      4
#define CRYPT_IMPL_REMOVABLE    8

// key storage flags
#define CRYPT_SEC_DESCR         0x00000001
#define CRYPT_PSTORE            0x00000002
#define CRYPT_UI_PROMPT         0x00000004

// protocol flags
#define CRYPT_FLAG_PCT1         0x0001
#define CRYPT_FLAG_SSL2         0x0002
#define CRYPT_FLAG_SSL3         0x0004
#define CRYPT_FLAG_TLS1         0x0008
#define CRYPT_FLAG_IPSEC        0x0010
#define CRYPT_FLAG_SIGNING      0x0020

// SGC flags
#define CRYPT_SGC               0x0001
#define CRYPT_FASTSGC           0x0002

//
// CryptSetProvParam
//
#define PP_CLIENT_HWND          1
#define PP_CONTEXT_INFO         11
#define PP_KEYEXCHANGE_KEYSIZE  12
#define PP_SIGNATURE_KEYSIZE    13
#define PP_KEYEXCHANGE_ALG      14
#define PP_SIGNATURE_ALG        15
#define PP_DELETEKEY            24
#define PP_PIN_PROMPT_STRING    44

// certenrolld_begin -- PROV_RSA_*
#define PROV_RSA_FULL           1
#define PROV_RSA_SIG            2
#define PROV_DSS                3
#define PROV_FORTEZZA           4
#define PROV_MS_EXCHANGE        5
#define PROV_SSL                6
#define PROV_RSA_SCHANNEL       12
#define PROV_DSS_DH             13
#define PROV_EC_ECDSA_SIG       14
#define PROV_EC_ECNRA_SIG       15
#define PROV_EC_ECDSA_FULL      16
#define PROV_EC_ECNRA_FULL      17
#define PROV_DH_SCHANNEL        18
#define PROV_SPYRUS_LYNKS       20
#define PROV_RNG                21
#define PROV_INTEL_SEC          22
#define PROV_REPLACE_OWF        23
#define PROV_RSA_AES            24
// certenrolld_end

//
// Provider friendly names
//
#define MS_DEF_PROV_A           "Microsoft Base Cryptographic Provider v1.0"
#define MS_DEF_PROV_W           L"Microsoft Base Cryptographic Provider v1.0"
#ifdef UNICODE
#define MS_DEF_PROV             MS_DEF_PROV_W
#else
#define MS_DEF_PROV             MS_DEF_PROV_A
#endif

#define MS_ENHANCED_PROV_A      "Microsoft Enhanced Cryptographic Provider v1.0"
#define MS_ENHANCED_PROV_W      L"Microsoft Enhanced Cryptographic Provider v1.0"
#ifdef UNICODE
#define MS_ENHANCED_PROV        MS_ENHANCED_PROV_W
#else
#define MS_ENHANCED_PROV        MS_ENHANCED_PROV_A
#endif

#define MS_STRONG_PROV_A        "Microsoft Strong Cryptographic Provider"
#define MS_STRONG_PROV_W        L"Microsoft Strong Cryptographic Provider"
#ifdef UNICODE
#define MS_STRONG_PROV          MS_STRONG_PROV_W
#else
#define MS_STRONG_PROV          MS_STRONG_PROV_A
#endif

#define MS_DEF_RSA_SIG_PROV_A   "Microsoft RSA Signature Cryptographic Provider"
#define MS_DEF_RSA_SIG_PROV_W   L"Microsoft RSA Signature Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_RSA_SIG_PROV     MS_DEF_RSA_SIG_PROV_W
#else
#define MS_DEF_RSA_SIG_PROV     MS_DEF_RSA_SIG_PROV_A
#endif

#define MS_DEF_RSA_SCHANNEL_PROV_A  "Microsoft RSA SChannel Cryptographic Provider"
#define MS_DEF_RSA_SCHANNEL_PROV_W  L"Microsoft RSA SChannel Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_RSA_SCHANNEL_PROV    MS_DEF_RSA_SCHANNEL_PROV_W
#else
#define MS_DEF_RSA_SCHANNEL_PROV    MS_DEF_RSA_SCHANNEL_PROV_A
#endif

#define MS_DEF_DSS_PROV_A       "Microsoft Base DSS Cryptographic Provider"
#define MS_DEF_DSS_PROV_W       L"Microsoft Base DSS Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DSS_PROV         MS_DEF_DSS_PROV_W
#else
#define MS_DEF_DSS_PROV         MS_DEF_DSS_PROV_A
#endif

#define MS_DEF_DSS_DH_PROV_A    "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
#define MS_DEF_DSS_DH_PROV_W    L"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DSS_DH_PROV      MS_DEF_DSS_DH_PROV_W
#else
#define MS_DEF_DSS_DH_PROV      MS_DEF_DSS_DH_PROV_A
#endif

#define MS_ENH_DSS_DH_PROV_A    "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
#define MS_ENH_DSS_DH_PROV_W    L"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
#ifdef UNICODE
#define MS_ENH_DSS_DH_PROV      MS_ENH_DSS_DH_PROV_W
#else
#define MS_ENH_DSS_DH_PROV      MS_ENH_DSS_DH_PROV_A
#endif

#define MS_DEF_DH_SCHANNEL_PROV_A  "Microsoft DH SChannel Cryptographic Provider"
#define MS_DEF_DH_SCHANNEL_PROV_W  L"Microsoft DH SChannel Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DH_SCHANNEL_PROV MS_DEF_DH_SCHANNEL_PROV_W
#else
#define MS_DEF_DH_SCHANNEL_PROV MS_DEF_DH_SCHANNEL_PROV_A
#endif

#define MS_SCARD_PROV_A         "Microsoft Base Smart Card Crypto Provider"
#define MS_SCARD_PROV_W         L"Microsoft Base Smart Card Crypto Provider"
#ifdef UNICODE
#define MS_SCARD_PROV           MS_SCARD_PROV_W
#else
#define MS_SCARD_PROV           MS_SCARD_PROV_A
#endif

#define MS_ENH_RSA_AES_PROV_A   "Microsoft Enhanced RSA and AES Cryptographic Provider"
#define MS_ENH_RSA_AES_PROV_W   L"Microsoft Enhanced RSA and AES Cryptographic Provider"
#ifdef UNICODE
#define MS_ENH_RSA_AES_PROV     MS_ENH_RSA_AES_PROV_W
#else
#define MS_ENH_RSA_AES_PROV     MS_ENH_RSA_AES_PROV_A
#endif

#define MAXUIDLEN               64

// Exponentiation Offload Reg Location
#define EXPO_OFFLOAD_REG_VALUE "ExpoOffload"
#define EXPO_OFFLOAD_FUNC_NAME "OffloadModExpo"

//
// Registry key in which the following private key-related
// values are created.
//
#define wszKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS \
    L"Comm\\Security\\Cryptography"

//
// Registry value for controlling Data Protection API (DPAPI) UI settings.
//

#define wszFORCE_KEY_PROTECTION             L"ForceKeyProtection"

#define dwFORCE_KEY_PROTECTION_DISABLED     0x0
#define dwFORCE_KEY_PROTECTION_USER_SELECT  0x1
#define dwFORCE_KEY_PROTECTION_HIGH         0x2

//
// Registry values for enabling and controlling the caching (and timeout)
// of private keys.  This feature is intended for UI-protected private
// keys.
//
// Note that in Windows 2000 and later, private keys, once read from storage,
// are cached in the associated HCRYPTPROV structure for subsequent use.
//
// In Server 2003 and XP SP1, new key caching behavior is available.  Keys
// that have been read from storage and cached may now be considered "stale"
// if a period of time has elapsed since the key was last used.  This forces
// the key to be re-read from storage (which will make the DPAPI UI appear
// again).
//
// Optional Key Timeouts:
//
// In Windows Server 2003, XP SP1, and later, new key caching behavior is
// available.  Keys that have been read from storage and cached per-context
// may now be considered "stale" if a period of time has elapsed since the
// key was last used.  This forces the key to be re-read from storage (which
// will make the Data Protection API dialog appear again if the key is
// UI-protected).
//
// To enable the new behavior, create the registry DWORD value
// szKEY_CACHE_ENABLED and set it to 1.  The registry DWORD value
// szKEY_CACHE_SECONDS must also be created and set to the number of seconds
// that a cached private key may still be considered usable.
//
#define wszKEY_CACHE_ENABLED                     L"CachePrivateKeys"
#define wszKEY_CACHE_SECONDS                     L"PrivateKeyLifetimeSeconds"

//
// In platforms later than (and not including) Windows Server 2003, private
// keys are always cached for a period of time per-process, even when
// not being used in any context.
//
// The differences between the process-wide caching settings described below
// and the Optional Key Timeouts described above are subtle.
//
//  - The Optional Key Timeout policy is applied only when an attempt is made
//    to use a specific private key with an open context handle (HCRYPTPROV).
//    If szKEY_CACHE_SECONDS have elapsed since the key was last used, the
//    private key will be re-read from storage.
//
//  - The Cache Purge Interval policy, below, is applied whenever any
//    non-ephemeral private key is used or read from storage.  If
//    szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS have elapsed since the last
//    purge occurred, all cached keys that have not been referenced since the
//    last purge will be removed from the cache.
//
//    If a private key that is purged from the cache is currently
//    referenced in an open context, then the key will be re-read from storage
//    the next time an attempt is made to use it (via any context).
//
// The following two registry DWORD values control this behavior.
//

//
// Registry value for controlling the maximum number of persisted
// (non-ephemeral) private keys that can be cached per-process.  If the cache
// fills up, keys will be replaced on a least-recently-used basis.  If the
// maximum number of cached keys is set to zero, no keys will be globally
// cached.
//
#define szPRIV_KEY_CACHE_MAX_ITEMS              "PrivKeyCacheMaxItems"
#define cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT       20

//
// Registry value for controlling the interval at which the private key
// cache is proactively purged of outdated keys.
//
#define szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS "PrivKeyCachePurgeIntervalSeconds"
#define cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT 86400 // 1 day

#define CUR_BLOB_VERSION        2

// structure for use with CryptSetKeyParam for CMS keys
// DO NOT USE THIS STRUCTURE!!!!!
typedef struct _CMS_KEY_INFO {
    DWORD       dwVersion;                      // sizeof(CMS_KEY_INFO)
    ALG_ID  Algid;                              // algorithmm id for the key to be converted
    BYTE    *pbOID;                             // pointer to OID to hash in with Z
    DWORD   cbOID;                              // length of OID to hash in with Z
} CMS_KEY_INFO, *PCMS_KEY_INFO;

// structure for use with CryptSetHashParam with CALG_HMAC
typedef struct _HMAC_Info {
    ALG_ID  HashAlgid;
    BYTE    *pbInnerString;
    DWORD   cbInnerString;
    BYTE    *pbOuterString;
    DWORD   cbOuterString;
} HMAC_INFO, *PHMAC_INFO;

// structure for use with CryptSetKeyParam with KP_SCHANNEL_ALG
typedef struct _SCHANNEL_ALG {
    DWORD   dwUse;
    ALG_ID  Algid;
    DWORD   cBits;
    DWORD   dwFlags;
    DWORD   dwReserved;
} SCHANNEL_ALG, *PSCHANNEL_ALG;

// uses of algortihms for SCHANNEL_ALG structure
#define     SCHANNEL_MAC_KEY    0x00000000
#define     SCHANNEL_ENC_KEY    0x00000001

// uses of dwFlags SCHANNEL_ALG structure
#define     INTERNATIONAL_USAGE 0x00000001

typedef struct _PROV_ENUMALGS {
    ALG_ID    aiAlgid;
    DWORD     dwBitLen;
    DWORD     dwNameLen;
    WCHAR      szName[20];      // WinCE : WCHAR, otherwise CHAR
} PROV_ENUMALGS;

// certenrolls_begin -- PROV_ENUMALGS_EX
typedef struct _PROV_ENUMALGS_EX {
    ALG_ID    aiAlgid;
    DWORD     dwDefaultLen;
    DWORD     dwMinLen;
    DWORD     dwMaxLen;
    DWORD     dwProtocols;
    DWORD     dwNameLen;
    WCHAR      szName[20];      // WinCE : WCHAR, otherwise CHAR
    DWORD     dwLongNameLen;
    WCHAR      szLongName[40];  // WinCE : WCHAR, otherwise CHAR
} PROV_ENUMALGS_EX;
// certenrolls_end

typedef struct _PUBLICKEYSTRUC {
        BYTE    bType;
        BYTE    bVersion;
        WORD    reserved;
        ALG_ID  aiKeyAlg;
} BLOBHEADER, PUBLICKEYSTRUC;

typedef struct _RSAPUBKEY {
        DWORD   magic;                  // Has to be RSA1
        DWORD   bitlen;                 // # of bits in modulus
        DWORD   pubexp;                 // public exponent
                                        // Modulus data follows
} RSAPUBKEY;

typedef struct _PUBKEY {
        DWORD   magic;
        DWORD   bitlen;                 // # of bits in modulus
} DHPUBKEY, DSSPUBKEY, KEAPUBKEY, TEKPUBKEY;

typedef struct _DSSSEED {
        DWORD   counter;
        BYTE    seed[20];
} DSSSEED;

typedef struct _PUBKEYVER3 {
        DWORD   magic;
        DWORD   bitlenP;                // # of bits in prime modulus
        DWORD   bitlenQ;                // # of bits in prime q, 0 if not available
        DWORD   bitlenJ;                // # of bits in (p-1)/q, 0 if not available
        DSSSEED DSSSeed;
} DHPUBKEY_VER3, DSSPUBKEY_VER3;

typedef struct _PRIVKEYVER3 {
        DWORD   magic;
        DWORD   bitlenP;                // # of bits in prime modulus
        DWORD   bitlenQ;                // # of bits in prime q, 0 if not available
        DWORD   bitlenJ;                // # of bits in (p-1)/q, 0 if not available
        DWORD   bitlenX;                // # of bits in X
        DSSSEED DSSSeed;
} DHPRIVKEY_VER3, DSSPRIVKEY_VER3;

typedef struct _KEY_TYPE_SUBTYPE {
        DWORD   dwKeySpec;
        GUID    Type;
        GUID    Subtype;
} KEY_TYPE_SUBTYPE, *PKEY_TYPE_SUBTYPE;

typedef struct _CERT_FORTEZZA_DATA_PROP {
    unsigned char   SerialNumber[8];
    int             CertIndex;
    unsigned char   CertLabel[36];
} CERT_FORTEZZA_DATA_PROP;

typedef struct _CRYPT_RC4_KEY_STATE {
    unsigned char Key[16];
    unsigned char SBox[256];
    unsigned char i;
    unsigned char j;
} CRYPT_RC4_KEY_STATE, *PCRYPT_RC4_KEY_STATE;

typedef struct _CRYPT_DES_KEY_STATE {
    unsigned char Key[8];
    unsigned char IV[8];
    unsigned char Feedback[8];
} CRYPT_DES_KEY_STATE, *PCRYPT_DES_KEY_STATE;

typedef struct _CRYPT_3DES_KEY_STATE {
    unsigned char Key[24];
    unsigned char IV[8];
    unsigned char Feedback[8];
} CRYPT_3DES_KEY_STATE, *PCRYPT_3DES_KEY_STATE;

typedef struct _CRYPT_AES_128_KEY_STATE {
    unsigned char Key[16];
    unsigned char IV[16];
    unsigned char EncryptionState[11][16];      // 10 rounds + 1
    unsigned char DecryptionState[11][16];
    unsigned char Feedback[16];
} CRYPT_AES_128_KEY_STATE, *PCRYPT_AES_128_KEY_STATE;

typedef struct _CRYPT_AES_256_KEY_STATE {
    unsigned char Key[32];
    unsigned char IV[16];
    unsigned char EncryptionState[15][16];      // 14 rounds + 1
    unsigned char DecryptionState[15][16];
    unsigned char Feedback[16];
} CRYPT_AES_256_KEY_STATE, *PCRYPT_AES_256_KEY_STATE;


//+-------------------------------------------------------------------------
//  CRYPTOAPI BLOB definitions
//--------------------------------------------------------------------------
// certenrolls_begin -- *_BLOB
typedef struct _CRYPTOAPI_BLOB {
                            DWORD   cbData;
    __field_bcount(cbData)  BYTE    *pbData;
} CRYPT_INTEGER_BLOB, *PCRYPT_INTEGER_BLOB,
CRYPT_UINT_BLOB, *PCRYPT_UINT_BLOB,
CRYPT_OBJID_BLOB, *PCRYPT_OBJID_BLOB,
CERT_NAME_BLOB, *PCERT_NAME_BLOB,
CERT_RDN_VALUE_BLOB, *PCERT_RDN_VALUE_BLOB,
CERT_BLOB, *PCERT_BLOB,
CRL_BLOB, *PCRL_BLOB,
DATA_BLOB, *PDATA_BLOB,
CRYPT_DATA_BLOB, *PCRYPT_DATA_BLOB,
CRYPT_HASH_BLOB, *PCRYPT_HASH_BLOB,
CRYPT_DIGEST_BLOB, *PCRYPT_DIGEST_BLOB,
CRYPT_DER_BLOB, *PCRYPT_DER_BLOB,
CRYPT_ATTR_BLOB, *PCRYPT_ATTR_BLOB;
// certenrolls_end

// structure for use with CryptSetKeyParam for CMS keys
typedef struct _CMS_DH_KEY_INFO {
    DWORD               dwVersion;                      // sizeof(CMS_DH_KEY_INFO)
    ALG_ID          Algid;                              // algorithmm id for the key to be converted
    LPSTR           pszContentEncObjId; // pointer to OID to hash in with Z
    CRYPT_DATA_BLOB PubInfo;            // OPTIONAL - public information
    void            *pReserved;         // reserved - should be NULL
} CMS_DH_KEY_INFO, *PCMS_DH_KEY_INFO;

WINADVAPI
BOOL
WINAPI
CryptAcquireContextA(
    __out       HCRYPTPROV  *phProv,
    __in_opt    LPCSTR    szContainer,
    __in_opt    LPCSTR    szProvider,
    __in        DWORD       dwProvType,
    __in        DWORD       dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    __out       HCRYPTPROV  *phProv,
    __in_opt    LPCWSTR    szContainer,
    __in_opt    LPCWSTR    szProvider,
    __in        DWORD       dwProvType,
    __in        DWORD       dwFlags
    );
#ifdef UNICODE
#define CryptAcquireContext  CryptAcquireContextW
#else
#define CryptAcquireContext  CryptAcquireContextA
#endif // !UNICODE

#ifdef UNICODE
#define CryptAcquireContext  CryptAcquireContextW
#else
#define CryptAcquireContext  CryptAcquireContextA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CryptReleaseContext(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGenKey(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    DWORD       dwFlags,
    __out   HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDeriveKey(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    HCRYPTHASH  hBaseData,
    __in    DWORD       dwFlags,
    __out   HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDestroyKey(
    __in    HCRYPTKEY   hKey
    );

WINADVAPI
BOOL
WINAPI
CryptSetKeyParam(
    __in    HCRYPTKEY   hKey,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGetKeyParam(
    __in                                        HCRYPTKEY   hKey,
    __in                                        DWORD   dwParam,
    __out_bcount_part(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                     DWORD   *pdwDataLen,
    __in                                        DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptSetHashParam(
    __in    HCRYPTHASH  hHash,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGetHashParam(
    __in                                        HCRYPTHASH  hHash,
    __in                                        DWORD   dwParam,
    __out_bcount_part(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                     DWORD   *pdwDataLen,
    __in                                        DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptSetProvParam(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGetProvParam(
    __in                                            HCRYPTPROV  hProv,
    __in                                            DWORD   dwParam,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen,
    __in                                            DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGenRandom(
    __in                    HCRYPTPROV  hProv,
    __in                    DWORD   dwLen,
    __inout_bcount(dwLen)   BYTE    *pbBuffer
    );

WINADVAPI
BOOL
WINAPI
CryptGetUserKey(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwKeySpec,
    __out   HCRYPTKEY   *phUserKey
    );

WINADVAPI
BOOL
WINAPI
CryptExportKey(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTKEY   hExpKey,
    __in                                            DWORD   dwBlobType,
    __in                                            DWORD   dwFlags,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen
    );

WINADVAPI
BOOL
WINAPI
CryptImportKey(
    __in                    HCRYPTPROV  hProv,
    __in_bcount(dwDataLen)  CONST BYTE  *pbData,
    __in                    DWORD       dwDataLen,
    __in                    HCRYPTKEY   hPubKey,
    __in                    DWORD       dwFlags,
    __out                   HCRYPTKEY   *phKey
    );

WINADVAPI
__success(0 < return) BOOL
WINAPI
CryptEncrypt(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTHASH  hHash,
    __in                                            BOOL    Final,
    __in                                            DWORD   dwFlags,
    __inout_bcount_part(dwBufLen, *pdwDataLen)      BYTE    *pbData,
    __out                                     DWORD   *pdwDataLen,
    __in                                            DWORD   dwBufLen
    );

WINADVAPI
BOOL
WINAPI
CryptDecrypt(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTHASH  hHash,
    __in                                            BOOL        Final,
    __in                                            DWORD       dwFlags,
    __inout_bcount_part(*pdwDataLen, *pdwDataLen)   BYTE        *pbData,
    __deref_inout                                   DWORD       *pdwDataLen
    );

WINADVAPI
BOOL
WINAPI
CryptCreateHash(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    HCRYPTKEY   hKey,
    __in    DWORD       dwFlags,
    __out   HCRYPTHASH  *phHash
    );

WINADVAPI
BOOL
WINAPI
CryptHashData(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwDataLen)  CONST BYTE  *pbData,
    __in                    DWORD   dwDataLen,
    __in                    DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptHashSessionKey(
    __in    HCRYPTHASH  hHash,
    __in    HCRYPTKEY   hKey,
    __in    DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptDestroyHash(
    __in    HCRYPTHASH  hHash
    );

WINADVAPI
BOOL
WINAPI
CryptSignHashA(
    __in                                          HCRYPTHASH  hHash,
    __in                                          DWORD       dwKeySpec,
    __in                                          LPCSTR    szDescription,
    __in                                          DWORD       dwFlags,
    __out_bcount_part_opt(*pdwSigLen, *pdwSigLen) BYTE        *pbSignature,
    __inout                                       DWORD       *pdwSigLen
    );
WINADVAPI
BOOL
WINAPI
CryptSignHashW(
    __in                                          HCRYPTHASH  hHash,
    __in                                          DWORD       dwKeySpec,
    __in                                          LPCWSTR    szDescription,
    __in                                          DWORD       dwFlags,
    __out_bcount_part_opt(*pdwSigLen, *pdwSigLen) BYTE        *pbSignature,
    __inout                                       DWORD       *pdwSigLen
    );
#ifdef UNICODE
#define CryptSignHash  CryptSignHashW
#else
#define CryptSignHash  CryptSignHashA
#endif // !UNICODE

#if 0//(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR szDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
WINADVAPI
BOOL
WINAPI
CryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR szDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

WINADVAPI
BOOL
WINAPI
CryptVerifySignatureA(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwSigLen)   CONST BYTE  *pbSignature,
    __in                    DWORD       dwSigLen,
    __in                    HCRYPTKEY   hPubKey,
    __in                    LPCSTR    szDescription,
    __in                    DWORD       dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureW(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwSigLen)   CONST BYTE  *pbSignature,
    __in                    DWORD       dwSigLen,
    __in                    HCRYPTKEY   hPubKey,
    __in                    LPCWSTR    szDescription,
    __in                    DWORD       dwFlags
    );
#ifdef UNICODE
#define CryptVerifySignature  CryptVerifySignatureW
#else
#define CryptVerifySignature  CryptVerifySignatureA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CryptSetProviderA(
    __in    LPCSTR    pszProvName,
    __in    DWORD       dwProvType
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderW(
    __in    LPCWSTR    pszProvName,
    __in    DWORD       dwProvType
    );
#ifdef UNICODE
#define CryptSetProvider  CryptSetProviderW
#else
#define CryptSetProvider  CryptSetProviderA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CryptSetProviderExA(
    __in        LPCSTR pszProvName,
    __in        DWORD dwProvType,
    __reserved  DWORD *pdwReserved,
    __in        DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderExW(
    __in        LPCWSTR pszProvName,
    __in        DWORD dwProvType,
    __reserved  DWORD *pdwReserved,
    __in        DWORD dwFlags
    );
#ifdef UNICODE
#define CryptSetProviderEx  CryptSetProviderExW
#else
#define CryptSetProviderEx  CryptSetProviderExA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CryptGetDefaultProviderA(
    __in                                            DWORD   dwProvType,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out_bcount_part(*pcbProvName, *pcbProvName)   LPSTR pszProvName,
    __out                                     DWORD   *pcbProvName
    );
WINADVAPI
BOOL
WINAPI
CryptGetDefaultProviderW(
    __in                                            DWORD   dwProvType,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out_bcount_part(*pcbProvName, *pcbProvName)   LPWSTR pszProvName,
    __out                                     DWORD   *pcbProvName
    );
#ifdef UNICODE
#define CryptGetDefaultProvider  CryptGetDefaultProviderW
#else
#define CryptGetDefaultProvider  CryptGetDefaultProviderA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesA(
    __in                                            DWORD   dwIndex,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out                                           DWORD   *pdwProvType,
    __out_bcount_part(*pcbTypeName, *pcbTypeName)   LPSTR szTypeName,
    __out                                     DWORD   *pcbTypeName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesW(
    __in                                            DWORD   dwIndex,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out                                           DWORD   *pdwProvType,
    __out_bcount_part(*pcbTypeName, *pcbTypeName)   LPWSTR szTypeName,
    __out                                     DWORD   *pcbTypeName
    );
#ifdef UNICODE
#define CryptEnumProviderTypes  CryptEnumProviderTypesW
#else
#define CryptEnumProviderTypes  CryptEnumProviderTypesA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersA(
    __in                                                DWORD   dwIndex,
    __reserved                                          DWORD   *pdwReserved,
    __in                                                DWORD   dwFlags,
    __out                                               DWORD   *pdwProvType,
    __out_bcount_opt(*pcbProvName)                      LPSTR    szProvName,
    __inout                                             DWORD   *pcbProvName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersW(
    __in                                                DWORD   dwIndex,
    __reserved                                          DWORD   *pdwReserved,
    __in                                                DWORD   dwFlags,
    __out                                               DWORD   *pdwProvType,
    __out_bcount_opt(*pcbProvName)                      LPWSTR   szProvName,
    __inout                                             DWORD   *pcbProvName
    );
#ifdef UNICODE
#define CryptEnumProviders  CryptEnumProvidersW
#else
#define CryptEnumProviders  CryptEnumProvidersA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

WINADVAPI
BOOL
WINAPI
CryptContextAddRef(
    __in        HCRYPTPROV  hProv,
    __reserved  DWORD       *pdwReserved,
    __in        DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptDuplicateKey(
    __in        HCRYPTKEY   hKey,
    __reserved  DWORD   *pdwReserved,
    __in        DWORD   dwFlags,
    __out       HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDuplicateHash(
    __in        HCRYPTHASH  hHash,
    __reserved  DWORD       *pdwReserved,
    __in        DWORD       dwFlags,
    __out       HCRYPTHASH  *phHash
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
//
// This function is provided in Microsoft Windows 2000 as a means of
// installing the 128-bit encryption provider. This function is unavailable
// in Microsoft Windows XP, because Windows XP ships with the 128-bit
// encryption provider.
//
BOOL
__cdecl
GetEncSChannel(
    BYTE **pData,
    DWORD *dwDecSize
    );
#endif //(NTDDI_VERSION >= NTDDI_WS03)

#if !defined(_DDK_DRIVER_)

// In Longhorn, the following APIs were updated to support the new
// CNG (Cryptography Next Generation) BCrypt* and NCrypt* APIs in addition
// to the above CAPI1 APIs.

// Include the definitions for the CNG APIs
#include <bcrypt.h>
#include <ncrypt.h>

// This type is used when the API can take either the CAPI1 HCRYPTPROV or
// the CNG NCRYPT_KEY_HANDLE. Where appropriate, the HCRYPTPROV will be
// converted to a NCRYPT_KEY_HANDLE via the CNG NCryptTranslateHandle().
typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE;

// This type is used where the HCRYPTPROV parameter is no longer used.
// The caller should always pass in NULL.
typedef ULONG_PTR HCRYPTPROV_LEGACY;

//+-------------------------------------------------------------------------
//  In a CRYPT_BIT_BLOB the last byte may contain 0-7 unused bits. Therefore, the
//  overall bit length is cbData * 8 - cUnusedBits.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CRYPT_BIT_BLOB {
    DWORD   cbData;
    BYTE    *pbData;
    DWORD   cUnusedBits;
} CRYPT_BIT_BLOB, *PCRYPT_BIT_BLOB;

//+-------------------------------------------------------------------------
//  Type used for any algorithm
//
//  Where the Parameters CRYPT_OBJID_BLOB is in its encoded representation. For most
//  algorithm types, the Parameters CRYPT_OBJID_BLOB is NULL (Parameters.cbData = 0).
//--------------------------------------------------------------------------
typedef struct _CRYPT_ALGORITHM_IDENTIFIER {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Parameters;
} CRYPT_ALGORITHM_IDENTIFIER, *PCRYPT_ALGORITHM_IDENTIFIER;
// certenrolls_end


// Following are the definitions of various algorithm object identifiers
// RSA
#define szOID_RSA               "1.2.840.113549"
#define szOID_PKCS              "1.2.840.113549.1"
#define szOID_RSA_HASH          "1.2.840.113549.2"
#define szOID_RSA_ENCRYPT       "1.2.840.113549.3"

#define szOID_PKCS_1            "1.2.840.113549.1.1"
#define szOID_PKCS_2            "1.2.840.113549.1.2"
#define szOID_PKCS_3            "1.2.840.113549.1.3"
#define szOID_PKCS_4            "1.2.840.113549.1.4"
#define szOID_PKCS_5            "1.2.840.113549.1.5"
#define szOID_PKCS_6            "1.2.840.113549.1.6"
#define szOID_PKCS_7            "1.2.840.113549.1.7"
#define szOID_PKCS_8            "1.2.840.113549.1.8"
#define szOID_PKCS_9            "1.2.840.113549.1.9"
#define szOID_PKCS_10           "1.2.840.113549.1.10"
#define szOID_PKCS_12           "1.2.840.113549.1.12"

#define szOID_RSA_RSA           "1.2.840.113549.1.1.1"
#define szOID_RSA_MD2RSA        "1.2.840.113549.1.1.2"
#define szOID_RSA_MD4RSA        "1.2.840.113549.1.1.3"
#define szOID_RSA_MD5RSA        "1.2.840.113549.1.1.4"
#define szOID_RSA_SHA1RSA       "1.2.840.113549.1.1.5"
#define szOID_RSA_SETOAEP_RSA   "1.2.840.113549.1.1.6"

#define szOID_RSAES_OAEP        "1.2.840.113549.1.1.7"
#define szOID_RSA_MGF1          "1.2.840.113549.1.1.8"
#define szOID_RSA_PSPECIFIED    "1.2.840.113549.1.1.9"
#define szOID_RSA_SSA_PSS       "1.2.840.113549.1.1.10"
#define szOID_RSA_SHA256RSA     "1.2.840.113549.1.1.11"
#define szOID_RSA_SHA384RSA     "1.2.840.113549.1.1.12"
#define szOID_RSA_SHA512RSA     "1.2.840.113549.1.1.13"

#define szOID_RSA_DH            "1.2.840.113549.1.3.1"

#define szOID_RSA_data          "1.2.840.113549.1.7.1"
#define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
#define szOID_RSA_envelopedData "1.2.840.113549.1.7.3"
#define szOID_RSA_signEnvData   "1.2.840.113549.1.7.4"
#define szOID_RSA_digestedData  "1.2.840.113549.1.7.5"
#define szOID_RSA_hashedData    "1.2.840.113549.1.7.5"
#define szOID_RSA_encryptedData "1.2.840.113549.1.7.6"

#define szOID_RSA_emailAddr     "1.2.840.113549.1.9.1"
#define szOID_RSA_unstructName  "1.2.840.113549.1.9.2"
#define szOID_RSA_contentType   "1.2.840.113549.1.9.3"
#define szOID_RSA_messageDigest "1.2.840.113549.1.9.4"
#define szOID_RSA_signingTime   "1.2.840.113549.1.9.5"
#define szOID_RSA_counterSign   "1.2.840.113549.1.9.6"
#define szOID_RSA_challengePwd  "1.2.840.113549.1.9.7"
#define szOID_RSA_unstructAddr  "1.2.840.113549.1.9.8"
#define szOID_RSA_extCertAttrs  "1.2.840.113549.1.9.9"
#define szOID_RSA_certExtensions "1.2.840.113549.1.9.14"
#define szOID_RSA_SMIMECapabilities "1.2.840.113549.1.9.15"
#define szOID_RSA_preferSignedData "1.2.840.113549.1.9.15.1"

#define szOID_RSA_SMIMEalg              "1.2.840.113549.1.9.16.3"
#define szOID_RSA_SMIMEalgESDH          "1.2.840.113549.1.9.16.3.5"
#define szOID_RSA_SMIMEalgCMS3DESwrap   "1.2.840.113549.1.9.16.3.6"
#define szOID_RSA_SMIMEalgCMSRC2wrap    "1.2.840.113549.1.9.16.3.7"

#define szOID_RSA_MD2           "1.2.840.113549.2.2"
#define szOID_RSA_MD4           "1.2.840.113549.2.4"
#define szOID_RSA_MD5           "1.2.840.113549.2.5"

#define szOID_RSA_RC2CBC        "1.2.840.113549.3.2"
#define szOID_RSA_RC4           "1.2.840.113549.3.4"
#define szOID_RSA_DES_EDE3_CBC  "1.2.840.113549.3.7"
#define szOID_RSA_RC5_CBCPad    "1.2.840.113549.3.9"


#define szOID_ANSI_X942         "1.2.840.10046"
#define szOID_ANSI_X942_DH      "1.2.840.10046.2.1"

#define szOID_X957              "1.2.840.10040"
#define szOID_X957_DSA          "1.2.840.10040.4.1"
#define szOID_X957_SHA1DSA      "1.2.840.10040.4.3"


// iso(1) member-body(2) us(840) 10045 keyType(2) unrestricted(1)
#define szOID_ECC_PUBLIC_KEY    "1.2.840.10045.2.1"

// iso(1) member-body(2) us(840) 10045 curves(3) prime(1) 7
#define szOID_ECC_CURVE_P256    "1.2.840.10045.3.1.7"

// iso(1) identified-organization(3) certicom(132) curve(0) 34
#define szOID_ECC_CURVE_P384    "1.3.132.0.34"

// iso(1) identified-organization(3) certicom(132) curve(0) 35
#define szOID_ECC_CURVE_P521    "1.3.132.0.35"


// iso(1) member-body(2) us(840) 10045 signatures(4) sha1(1)
#define szOID_ECDSA_SHA1        "1.2.840.10045.4.1"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3)
#define szOID_ECDSA_SPECIFIED   "1.2.840.10045.4.3"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 2
#define szOID_ECDSA_SHA256      "1.2.840.10045.4.3.2"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 3
#define szOID_ECDSA_SHA384      "1.2.840.10045.4.3.3"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 4
#define szOID_ECDSA_SHA512      "1.2.840.10045.4.3.4"


// NIST AES CBC Algorithms
// joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistAlgorithms(4)  aesAlgs(1) }

#define szOID_NIST_AES128_CBC        "2.16.840.1.101.3.4.1.2"
#define szOID_NIST_AES192_CBC        "2.16.840.1.101.3.4.1.22"
#define szOID_NIST_AES256_CBC        "2.16.840.1.101.3.4.1.42"

// For the above Algorithms, the AlgorithmIdentifier parameters must be
// present and the parameters field MUST contain an AES-IV:
//
//  AES-IV ::= OCTET STRING (SIZE(16))

// NIST AES WRAP Algorithms
#define szOID_NIST_AES128_WRAP       "2.16.840.1.101.3.4.1.5"
#define szOID_NIST_AES192_WRAP       "2.16.840.1.101.3.4.1.25"
#define szOID_NIST_AES256_WRAP       "2.16.840.1.101.3.4.1.45"


//      x9-63-scheme OBJECT IDENTIFIER ::= { iso(1)
//         identified-organization(3) tc68(133) country(16) x9(840)
//         x9-63(63) schemes(0) }


// ECDH single pass ephemeral-static KeyAgreement KeyEncryptionAlgorithm
#define szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF "1.3.133.16.840.63.0.2"

// For the above KeyEncryptionAlgorithm the following wrap algorithms are
// supported:
//  szOID_RSA_SMIMEalgCMS3DESwrap
//  szOID_RSA_SMIMEalgCMSRC2wrap
//  szOID_NIST_AES128_WRAP
//  szOID_NIST_AES192_WRAP
//  szOID_NIST_AES256_WRAP



// ITU-T UsefulDefinitions
#define szOID_DS                "2.5"
#define szOID_DSALG             "2.5.8"
#define szOID_DSALG_CRPT        "2.5.8.1"
#define szOID_DSALG_HASH        "2.5.8.2"
#define szOID_DSALG_SIGN        "2.5.8.3"
#define szOID_DSALG_RSA         "2.5.8.1.1"
// NIST OSE Implementors' Workshop (OIW)
// http://nemo.ncsl.nist.gov/oiw/agreements/stable/OSI/12s_9506.w51
// http://nemo.ncsl.nist.gov/oiw/agreements/working/OSI/12w_9503.w51
#define szOID_OIW               "1.3.14"
// NIST OSE Implementors' Workshop (OIW) Security SIG algorithm identifiers
#define szOID_OIWSEC            "1.3.14.3.2"
#define szOID_OIWSEC_md4RSA     "1.3.14.3.2.2"
#define szOID_OIWSEC_md5RSA     "1.3.14.3.2.3"
#define szOID_OIWSEC_md4RSA2    "1.3.14.3.2.4"
#define szOID_OIWSEC_desECB     "1.3.14.3.2.6"
#define szOID_OIWSEC_desCBC     "1.3.14.3.2.7"
#define szOID_OIWSEC_desOFB     "1.3.14.3.2.8"
#define szOID_OIWSEC_desCFB     "1.3.14.3.2.9"
#define szOID_OIWSEC_desMAC     "1.3.14.3.2.10"
#define szOID_OIWSEC_rsaSign    "1.3.14.3.2.11"
#define szOID_OIWSEC_dsa        "1.3.14.3.2.12"
#define szOID_OIWSEC_shaDSA     "1.3.14.3.2.13"
#define szOID_OIWSEC_mdc2RSA    "1.3.14.3.2.14"
#define szOID_OIWSEC_shaRSA     "1.3.14.3.2.15"
#define szOID_OIWSEC_dhCommMod  "1.3.14.3.2.16"
#define szOID_OIWSEC_desEDE     "1.3.14.3.2.17"
#define szOID_OIWSEC_sha        "1.3.14.3.2.18"
#define szOID_OIWSEC_mdc2       "1.3.14.3.2.19"
#define szOID_OIWSEC_dsaComm    "1.3.14.3.2.20"
#define szOID_OIWSEC_dsaCommSHA "1.3.14.3.2.21"
#define szOID_OIWSEC_rsaXchg    "1.3.14.3.2.22"
#define szOID_OIWSEC_keyHashSeal "1.3.14.3.2.23"
#define szOID_OIWSEC_md2RSASign "1.3.14.3.2.24"
#define szOID_OIWSEC_md5RSASign "1.3.14.3.2.25"
#define szOID_OIWSEC_sha1       "1.3.14.3.2.26"
#define szOID_OIWSEC_dsaSHA1    "1.3.14.3.2.27"
#define szOID_OIWSEC_dsaCommSHA1 "1.3.14.3.2.28"
#define szOID_OIWSEC_sha1RSASign "1.3.14.3.2.29"
// NIST OSE Implementors' Workshop (OIW) Directory SIG algorithm identifiers
#define szOID_OIWDIR            "1.3.14.7.2"
#define szOID_OIWDIR_CRPT       "1.3.14.7.2.1"
#define szOID_OIWDIR_HASH       "1.3.14.7.2.2"
#define szOID_OIWDIR_SIGN       "1.3.14.7.2.3"
#define szOID_OIWDIR_md2        "1.3.14.7.2.2.1"
#define szOID_OIWDIR_md2RSA     "1.3.14.7.2.3.1"


// INFOSEC Algorithms
// joint-iso-ccitt(2) country(16) us(840) organization(1) us-government(101) dod(2) id-infosec(1)
#define szOID_INFOSEC                       "2.16.840.1.101.2.1"
#define szOID_INFOSEC_sdnsSignature         "2.16.840.1.101.2.1.1.1"
#define szOID_INFOSEC_mosaicSignature       "2.16.840.1.101.2.1.1.2"
#define szOID_INFOSEC_sdnsConfidentiality   "2.16.840.1.101.2.1.1.3"
#define szOID_INFOSEC_mosaicConfidentiality "2.16.840.1.101.2.1.1.4"
#define szOID_INFOSEC_sdnsIntegrity         "2.16.840.1.101.2.1.1.5"
#define szOID_INFOSEC_mosaicIntegrity       "2.16.840.1.101.2.1.1.6"
#define szOID_INFOSEC_sdnsTokenProtection   "2.16.840.1.101.2.1.1.7"
#define szOID_INFOSEC_mosaicTokenProtection "2.16.840.1.101.2.1.1.8"
#define szOID_INFOSEC_sdnsKeyManagement     "2.16.840.1.101.2.1.1.9"
#define szOID_INFOSEC_mosaicKeyManagement   "2.16.840.1.101.2.1.1.10"
#define szOID_INFOSEC_sdnsKMandSig          "2.16.840.1.101.2.1.1.11"
#define szOID_INFOSEC_mosaicKMandSig        "2.16.840.1.101.2.1.1.12"
#define szOID_INFOSEC_SuiteASignature       "2.16.840.1.101.2.1.1.13"
#define szOID_INFOSEC_SuiteAConfidentiality "2.16.840.1.101.2.1.1.14"
#define szOID_INFOSEC_SuiteAIntegrity       "2.16.840.1.101.2.1.1.15"
#define szOID_INFOSEC_SuiteATokenProtection "2.16.840.1.101.2.1.1.16"
#define szOID_INFOSEC_SuiteAKeyManagement   "2.16.840.1.101.2.1.1.17"
#define szOID_INFOSEC_SuiteAKMandSig        "2.16.840.1.101.2.1.1.18"
#define szOID_INFOSEC_mosaicUpdatedSig      "2.16.840.1.101.2.1.1.19"
#define szOID_INFOSEC_mosaicKMandUpdSig     "2.16.840.1.101.2.1.1.20"
#define szOID_INFOSEC_mosaicUpdatedInteg    "2.16.840.1.101.2.1.1.21"

// NIST Hash Algorithms
// joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2)

#define szOID_NIST_sha256                   "2.16.840.1.101.3.4.2.1"
#define szOID_NIST_sha384                   "2.16.840.1.101.3.4.2.2"
#define szOID_NIST_sha512                   "2.16.840.1.101.3.4.2.3"

typedef struct _CRYPT_OBJID_TABLE {
    DWORD   dwAlgId;
    LPCSTR  pszObjId;
} CRYPT_OBJID_TABLE, *PCRYPT_OBJID_TABLE;


//+-------------------------------------------------------------------------
//  PKCS #1 HashInfo (DigestInfo)
//--------------------------------------------------------------------------
typedef struct _CRYPT_HASH_INFO {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_HASH_BLOB             Hash;
} CRYPT_HASH_INFO, *PCRYPT_HASH_INFO;

//+-------------------------------------------------------------------------
//  Type used for an extension to an encoded content
//
//  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_EXTENSION {
    LPSTR               pszObjId;
    BOOL                fCritical;
    CRYPT_OBJID_BLOB    Value;
} CERT_EXTENSION, *PCERT_EXTENSION;
// certenrolls_end

//+-------------------------------------------------------------------------
//  AttributeTypeValue
//
//  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CRYPT_ATTRIBUTE_TYPE_VALUE
typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Value;
} CRYPT_ATTRIBUTE_TYPE_VALUE, *PCRYPT_ATTRIBUTE_TYPE_VALUE;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Attributes
//
//  Where the Value's PATTR_BLOBs are in their encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CRYPT_ATTRIBUTE
typedef struct _CRYPT_ATTRIBUTE {
    LPSTR               pszObjId;
    DWORD               cValue;
    PCRYPT_ATTR_BLOB    rgValue;
} CRYPT_ATTRIBUTE, *PCRYPT_ATTRIBUTE;

typedef struct _CRYPT_ATTRIBUTES {
    DWORD                cAttr;
    PCRYPT_ATTRIBUTE     rgAttr;
} CRYPT_ATTRIBUTES, *PCRYPT_ATTRIBUTES;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Attributes making up a Relative Distinguished Name (CERT_RDN)
//
//  The interpretation of the Value depends on the dwValueType.
//  See below for a list of the types.
//--------------------------------------------------------------------------
typedef struct _CERT_RDN_ATTR {
    LPSTR                   pszObjId;
    DWORD                   dwValueType;
    CERT_RDN_VALUE_BLOB     Value;
} CERT_RDN_ATTR, *PCERT_RDN_ATTR;

//+-------------------------------------------------------------------------
//  CERT_RDN attribute Object Identifiers
//--------------------------------------------------------------------------
// Labeling attribute types:
#define szOID_COMMON_NAME                   "2.5.4.3"  // case-ignore string
#define szOID_SUR_NAME                      "2.5.4.4"  // case-ignore string
#define szOID_DEVICE_SERIAL_NUMBER          "2.5.4.5"  // printable string

// Geographic attribute types:
#define szOID_COUNTRY_NAME                  "2.5.4.6"  // printable 2char string
#define szOID_LOCALITY_NAME                 "2.5.4.7"  // case-ignore string
#define szOID_STATE_OR_PROVINCE_NAME        "2.5.4.8"  // case-ignore string
#define szOID_STREET_ADDRESS                "2.5.4.9"  // case-ignore string

// Organizational attribute types:
#define szOID_ORGANIZATION_NAME             "2.5.4.10" // case-ignore string
#define szOID_ORGANIZATIONAL_UNIT_NAME      "2.5.4.11" // case-ignore string
#define szOID_TITLE                         "2.5.4.12" // case-ignore string

// Explanatory attribute types:
#define szOID_DESCRIPTION                   "2.5.4.13" // case-ignore string
#define szOID_SEARCH_GUIDE                  "2.5.4.14"
#define szOID_BUSINESS_CATEGORY             "2.5.4.15" // case-ignore string

// Postal addressing attribute types:
#define szOID_POSTAL_ADDRESS                "2.5.4.16"
#define szOID_POSTAL_CODE                   "2.5.4.17" // case-ignore string
#define szOID_POST_OFFICE_BOX               "2.5.4.18" // case-ignore string
#define szOID_PHYSICAL_DELIVERY_OFFICE_NAME "2.5.4.19" // case-ignore string

// Telecommunications addressing attribute types:
#define szOID_TELEPHONE_NUMBER              "2.5.4.20" // telephone number
#define szOID_TELEX_NUMBER                  "2.5.4.21"
#define szOID_TELETEXT_TERMINAL_IDENTIFIER  "2.5.4.22"
#define szOID_FACSIMILE_TELEPHONE_NUMBER    "2.5.4.23"
#define szOID_X21_ADDRESS                   "2.5.4.24" // numeric string
#define szOID_INTERNATIONAL_ISDN_NUMBER     "2.5.4.25" // numeric string
#define szOID_REGISTERED_ADDRESS            "2.5.4.26"
#define szOID_DESTINATION_INDICATOR         "2.5.4.27" // printable string

// Preference attribute types:
#define szOID_PREFERRED_DELIVERY_METHOD     "2.5.4.28"

// OSI application attribute types:
#define szOID_PRESENTATION_ADDRESS          "2.5.4.29"
#define szOID_SUPPORTED_APPLICATION_CONTEXT "2.5.4.30"

// Relational application attribute types:
#define szOID_MEMBER                        "2.5.4.31"
#define szOID_OWNER                         "2.5.4.32"
#define szOID_ROLE_OCCUPANT                 "2.5.4.33"
#define szOID_SEE_ALSO                      "2.5.4.34"

// Security attribute types:
#define szOID_USER_PASSWORD                 "2.5.4.35"
#define szOID_USER_CERTIFICATE              "2.5.4.36"
#define szOID_CA_CERTIFICATE                "2.5.4.37"
#define szOID_AUTHORITY_REVOCATION_LIST     "2.5.4.38"
#define szOID_CERTIFICATE_REVOCATION_LIST   "2.5.4.39"
#define szOID_CROSS_CERTIFICATE_PAIR        "2.5.4.40"

// Undocumented attribute types???
//#define szOID_???                         "2.5.4.41"
#define szOID_GIVEN_NAME                    "2.5.4.42" // case-ignore string
#define szOID_INITIALS                      "2.5.4.43" // case-ignore string

// The DN Qualifier attribute type specifies disambiguating information to add
// to the relative distinguished name of an entry. It is intended to be used
// for entries held in multiple DSAs which would otherwise have the same name,
// and that its value be the same in a given DSA for all entries to which
// the information has been added.
#define szOID_DN_QUALIFIER                  "2.5.4.46"

// Pilot user attribute types:
#define szOID_DOMAIN_COMPONENT  "0.9.2342.19200300.100.1.25" // IA5, UTF8 string

// used for PKCS 12 attributes
#define szOID_PKCS_12_FRIENDLY_NAME_ATTR     "1.2.840.113549.1.9.20"
#define szOID_PKCS_12_LOCAL_KEY_ID           "1.2.840.113549.1.9.21"
#define szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR "1.3.6.1.4.1.311.17.1"
#define szOID_LOCAL_MACHINE_KEYSET           "1.3.6.1.4.1.311.17.2"
#define szOID_PKCS_12_EXTENDED_ATTRIBUTES    "1.3.6.1.4.1.311.17.3"

//+-------------------------------------------------------------------------
//  Microsoft CERT_RDN attribute Object Identifiers
//--------------------------------------------------------------------------
// Special RDN containing the KEY_ID. Its value type is CERT_RDN_OCTET_STRING.
#define szOID_KEYID_RDN                     "1.3.6.1.4.1.311.10.7.1"

//+-------------------------------------------------------------------------
//  CERT_RDN Attribute Value Types
//
//  For RDN_ENCODED_BLOB, the Value's CERT_RDN_VALUE_BLOB is in its encoded
//  representation. Otherwise, its an array of bytes.
//
//  For all CERT_RDN types, Value.cbData is always the number of bytes, not
//  necessarily the number of elements in the string. For instance,
//  RDN_UNIVERSAL_STRING is an array of ints (cbData == intCnt * 4) and
//  RDN_BMP_STRING is an array of unsigned shorts (cbData == ushortCnt * 2).
//
//  A RDN_UTF8_STRING is an array of UNICODE characters (cbData == charCnt *2).
//  These UNICODE characters are encoded as UTF8 8 bit characters.
//
//  For CertDecodeName, two 0 bytes are always appended to the end of the
//  string (ensures a CHAR or WCHAR string is null terminated).
//  These added 0 bytes are't included in the BLOB.cbData.
//--------------------------------------------------------------------------
#define CERT_RDN_ANY_TYPE                0
#define CERT_RDN_ENCODED_BLOB            1
#define CERT_RDN_OCTET_STRING            2
#define CERT_RDN_NUMERIC_STRING          3
#define CERT_RDN_PRINTABLE_STRING        4
#define CERT_RDN_TELETEX_STRING          5
#define CERT_RDN_T61_STRING              5
#define CERT_RDN_VIDEOTEX_STRING         6
#define CERT_RDN_IA5_STRING              7
#define CERT_RDN_GRAPHIC_STRING          8
#define CERT_RDN_VISIBLE_STRING          9
#define CERT_RDN_ISO646_STRING           9
#define CERT_RDN_GENERAL_STRING          10
#define CERT_RDN_UNIVERSAL_STRING        11
#define CERT_RDN_INT4_STRING             11
#define CERT_RDN_BMP_STRING              12
#define CERT_RDN_UNICODE_STRING          12
#define CERT_RDN_UTF8_STRING             13

#define CERT_RDN_TYPE_MASK                  0x000000FF
#define CERT_RDN_FLAGS_MASK                 0xFF000000

//+-------------------------------------------------------------------------
//  Flags that can be or'ed with the above Value Type when encoding/decoding
//--------------------------------------------------------------------------
// For encoding: when set, CERT_RDN_T61_STRING is selected instead of
// CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF
#define CERT_RDN_ENABLE_T61_UNICODE_FLAG    0x80000000

// For encoding: when set, CERT_RDN_UTF8_STRING is selected instead of
// CERT_RDN_UNICODE_STRING.
#define CERT_RDN_ENABLE_UTF8_UNICODE_FLAG   0x20000000

// For encoding: when set, CERT_RDN_UTF8_STRING is selected instead of
// CERT_RDN_PRINTABLE_STRING for DirectoryString types. Also,
// enables CERT_RDN_ENABLE_UTF8_UNICODE_FLAG.
#define CERT_RDN_FORCE_UTF8_UNICODE_FLAG    0x10000000

// For encoding: when set, the characters aren't checked to see if they
// are valid for the Value Type.
#define CERT_RDN_DISABLE_CHECK_TYPE_FLAG    0x40000000

// For decoding: by default, CERT_RDN_T61_STRING values are initially decoded
// as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
// Setting this flag skips the initial attempt to decode as UTF8.
#define CERT_RDN_DISABLE_IE4_UTF8_FLAG      0x01000000


// Macro to check that the dwValueType is a character string and not an
// encoded blob or octet string
#define IS_CERT_RDN_CHAR_STRING(X)      \
                (((X) & CERT_RDN_TYPE_MASK) >= CERT_RDN_NUMERIC_STRING)


//+-------------------------------------------------------------------------
//  A CERT_RDN consists of an array of the above attributes
//--------------------------------------------------------------------------
typedef struct _CERT_RDN {
    DWORD           cRDNAttr;
    PCERT_RDN_ATTR  rgRDNAttr;
} CERT_RDN, *PCERT_RDN;

//+-------------------------------------------------------------------------
//  Information stored in a subject's or issuer's name. The information
//  is represented as an array of the above RDNs.
//--------------------------------------------------------------------------
typedef struct _CERT_NAME_INFO {
    DWORD       cRDN;
    PCERT_RDN   rgRDN;
} CERT_NAME_INFO, *PCERT_NAME_INFO;

//+-------------------------------------------------------------------------
//  Name attribute value without the Object Identifier
//
//  The interpretation of the Value depends on the dwValueType.
//  See above for a list of the types.
//--------------------------------------------------------------------------
typedef struct _CERT_NAME_VALUE {
    DWORD               dwValueType;
    CERT_RDN_VALUE_BLOB Value;
} CERT_NAME_VALUE, *PCERT_NAME_VALUE;

//+-------------------------------------------------------------------------
//  Public Key Info
//
//  The PublicKey is the encoded representation of the information as it is
//  stored in the bit string
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_PUBLIC_KEY_INFO {
    CRYPT_ALGORITHM_IDENTIFIER    Algorithm;
    CRYPT_BIT_BLOB                PublicKey;
} CERT_PUBLIC_KEY_INFO, *PCERT_PUBLIC_KEY_INFO;
// certenrolls_end

#define CERT_RSA_PUBLIC_KEY_OBJID            szOID_RSA_RSA
#define CERT_DEFAULT_OID_PUBLIC_KEY_SIGN     szOID_RSA_RSA
#define CERT_DEFAULT_OID_PUBLIC_KEY_XCHG     szOID_RSA_RSA


//+-------------------------------------------------------------------------
//  structure that contains all the information in a PKCS#8 PrivateKeyInfo
//--------------------------------------------------------------------------
typedef struct _CRYPT_PRIVATE_KEY_INFO{
    DWORD                       Version;
    CRYPT_ALGORITHM_IDENTIFIER  Algorithm;
    CRYPT_DER_BLOB              PrivateKey;
    PCRYPT_ATTRIBUTES           pAttributes;
}  CRYPT_PRIVATE_KEY_INFO, *PCRYPT_PRIVATE_KEY_INFO;

//+-------------------------------------------------------------------------
//  structure that contains all the information in a PKCS#8
//  EncryptedPrivateKeyInfo
//--------------------------------------------------------------------------
typedef struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO{
    CRYPT_ALGORITHM_IDENTIFIER  EncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedPrivateKey;
} CRYPT_ENCRYPTED_PRIVATE_KEY_INFO, *PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO;

//+-------------------------------------------------------------------------
// this callback is given when an EncryptedProvateKeyInfo structure is
// encountered during ImportPKCS8.  the caller is then expected to decrypt
// the private key and hand back the decrypted contents.
//
// the parameters are:
// Algorithm - the algorithm used to encrypt the PrivateKeyInfo
// EncryptedPrivateKey - the encrypted private key blob
// pClearTextKey - a buffer to receive the clear text
// cbClearTextKey - the number of bytes of the pClearTextKey buffer
//                  note the if this is zero then this should be
//                  filled in with the size required to decrypt the
//                  key into, and pClearTextKey should be ignored
// pVoidDecryptFunc - this is the pVoid that was passed into the call
//                    and is preserved and passed back as context
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_DECRYPT_PRIVATE_KEY_FUNC)(
    __in CRYPT_ALGORITHM_IDENTIFIER Algorithm,
    __in CRYPT_DATA_BLOB EncryptedPrivateKey,
    __out_bcount_opt (*pcbClearTextKey) BYTE* pbClearTextKey,
    __inout DWORD* pcbClearTextKey,
    __in LPVOID pVoidDecryptFunc);

//+-------------------------------------------------------------------------
// this callback is given when creating a PKCS8 EncryptedPrivateKeyInfo.
// The caller is then expected to encrypt the private key and hand back
// the encrypted contents.
//
// the parameters are:
// Algorithm - the algorithm used to encrypt the PrivateKeyInfo
// pClearTextPrivateKey - the cleartext private key to be encrypted
// pbEncryptedKey - the output encrypted private key blob
// cbEncryptedKey - the number of bytes of the pbEncryptedKey buffer
//                  note the if this is zero then this should be
//                  filled in with the size required to encrypt the
//                  key into, and pbEncryptedKey should be ignored
// pVoidEncryptFunc - this is the pVoid that was passed into the call
//                    and is preserved and passed back as context
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC)(
    __out CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm,
    __in CRYPT_DATA_BLOB* pClearTextPrivateKey,
    __out_bcount_opt (*pcbEncryptedKey) BYTE* pbEncryptedKey,
    __inout DWORD* pcbEncryptedKey,
    __in LPVOID pVoidEncryptFunc);

//+-------------------------------------------------------------------------
// this callback is given from the context of a ImportPKCS8 calls.  the caller
// is then expected to hand back an HCRYPTPROV to receive the key being imported
//
// the parameters are:
// pPrivateKeyInfo - pointer to a CRYPT_PRIVATE_KEY_INFO structure which
//                   describes the key being imported
// EncryptedPrivateKey - the encrypted private key blob
// phCryptProv - a pointer to a HCRRYPTPROV to be filled in
// pVoidResolveFunc - this is the pVoidResolveFunc passed in by the caller in the
//                    CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS struct
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_RESOLVE_HCRYPTPROV_FUNC)(
                                                       CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,
                                                       HCRYPTPROV                  *phCryptProv,
                                                       LPVOID                      pVoidResolveFunc);

//+-------------------------------------------------------------------------
// this struct contains a PKCS8 private key and two pointers to callback
// functions, with a corresponding pVoids.  the first callback is used to give
// the caller the opportunity to specify where the key is imported to.  the callback
// passes the caller the algoroithm OID and key size to use in making the decision.
// the other callback is used to decrypt the private key if the PKCS8 contains an
// EncryptedPrivateKeyInfo.  both pVoids are preserved and passed back to the caller
// in the respective callback
//+-------------------------------------------------------------------------
typedef struct _CRYPT_PKCS8_IMPORT_PARAMS{
    CRYPT_DIGEST_BLOB               PrivateKey;             // PKCS8 blob
    PCRYPT_RESOLVE_HCRYPTPROV_FUNC  pResolvehCryptProvFunc; // optional
    LPVOID                          pVoidResolveFunc;       // optional
    PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
    LPVOID                          pVoidDecryptFunc;
} CRYPT_PKCS8_IMPORT_PARAMS, *PCRYPT_PKCS8_IMPORT_PARAMS, CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS, *PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS;


//+-------------------------------------------------------------------------
// this struct contains information identifying a private key and a pointer
// to a callback function, with a corresponding pVoid. The callback is used
// to encrypt the private key. If the pEncryptPrivateKeyFunc is NULL, the
// key will not be encrypted and an EncryptedPrivateKeyInfo will not be generated.
// The pVoid is preserved and passed back to the caller in the respective callback
//+-------------------------------------------------------------------------
typedef struct _CRYPT_PKCS8_EXPORT_PARAMS{
    HCRYPTPROV                      hCryptProv;
    DWORD                           dwKeySpec;
    LPSTR                           pszPrivateKeyObjId;

    PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC pEncryptPrivateKeyFunc;
    LPVOID                          pVoidEncryptFunc;
} CRYPT_PKCS8_EXPORT_PARAMS, *PCRYPT_PKCS8_EXPORT_PARAMS;

//+-------------------------------------------------------------------------
//  Information stored in a certificate
//
//  The Issuer, Subject, Algorithm, PublicKey and Extension BLOBs are the
//  encoded representation of the information.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_INFO {
    DWORD                       dwVersion;
    CRYPT_INTEGER_BLOB          SerialNumber;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CERT_NAME_BLOB              Issuer;
    FILETIME                    NotBefore;
    FILETIME                    NotAfter;
    CERT_NAME_BLOB              Subject;
    CERT_PUBLIC_KEY_INFO        SubjectPublicKeyInfo;
    CRYPT_BIT_BLOB              IssuerUniqueId;
    CRYPT_BIT_BLOB              SubjectUniqueId;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} CERT_INFO, *PCERT_INFO;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Certificate versions
//--------------------------------------------------------------------------
#define CERT_V1     0
#define CERT_V2     1
#define CERT_V3     2

//+-------------------------------------------------------------------------
//  Certificate Information Flags
//--------------------------------------------------------------------------
#define CERT_INFO_VERSION_FLAG                      1
#define CERT_INFO_SERIAL_NUMBER_FLAG                2
#define CERT_INFO_SIGNATURE_ALGORITHM_FLAG          3
#define CERT_INFO_ISSUER_FLAG                       4
#define CERT_INFO_NOT_BEFORE_FLAG                   5
#define CERT_INFO_NOT_AFTER_FLAG                    6
#define CERT_INFO_SUBJECT_FLAG                      7
#define CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG      8
#define CERT_INFO_ISSUER_UNIQUE_ID_FLAG             9
#define CERT_INFO_SUBJECT_UNIQUE_ID_FLAG            10
#define CERT_INFO_EXTENSION_FLAG                    11

//+-------------------------------------------------------------------------
//  An entry in a CRL
//
//  The Extension BLOBs are the encoded representation of the information.
//--------------------------------------------------------------------------
typedef struct _CRL_ENTRY {
    CRYPT_INTEGER_BLOB  SerialNumber;
    FILETIME            RevocationDate;
    DWORD               cExtension;
    PCERT_EXTENSION     rgExtension;
} CRL_ENTRY, *PCRL_ENTRY;

//+-------------------------------------------------------------------------
//  Information stored in a CRL
//
//  The Issuer, Algorithm and Extension BLOBs are the encoded
//  representation of the information.
//--------------------------------------------------------------------------
typedef struct _CRL_INFO {
    DWORD                       dwVersion;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CERT_NAME_BLOB              Issuer;
    FILETIME                    ThisUpdate;
    FILETIME                    NextUpdate;
    DWORD                       cCRLEntry;
    PCRL_ENTRY                  rgCRLEntry;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} CRL_INFO, *PCRL_INFO;

//+-------------------------------------------------------------------------
//  CRL versions
//--------------------------------------------------------------------------
#define CRL_V1     0
#define CRL_V2     1


//+-------------------------------------------------------------------------
//  Information stored in a certificate request
//
//  The Subject, Algorithm, PublicKey and Attribute BLOBs are the encoded
//  representation of the information.
//--------------------------------------------------------------------------
typedef struct _CERT_REQUEST_INFO {
    DWORD                   dwVersion;
    CERT_NAME_BLOB          Subject;
    CERT_PUBLIC_KEY_INFO    SubjectPublicKeyInfo;
    DWORD                   cAttribute;
    PCRYPT_ATTRIBUTE        rgAttribute;
} CERT_REQUEST_INFO, *PCERT_REQUEST_INFO;

//+-------------------------------------------------------------------------
//  Certificate Request versions
//--------------------------------------------------------------------------
#define CERT_REQUEST_V1     0

//+-------------------------------------------------------------------------
//  Information stored in Netscape's Keygen request
//--------------------------------------------------------------------------
typedef struct _CERT_KEYGEN_REQUEST_INFO {
    DWORD                   dwVersion;
    CERT_PUBLIC_KEY_INFO    SubjectPublicKeyInfo;
    LPWSTR                  pwszChallengeString;        // encoded as IA5
} CERT_KEYGEN_REQUEST_INFO, *PCERT_KEYGEN_REQUEST_INFO;

#define CERT_KEYGEN_REQUEST_V1     0


//+-------------------------------------------------------------------------
//  Certificate, CRL, Certificate Request or Keygen Request Signed Content
//
//  The "to be signed" encoded content plus its signature. The ToBeSigned
//  is the encoded CERT_INFO, CRL_INFO, CERT_REQUEST_INFO or
//  CERT_KEYGEN_REQUEST_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_SIGNED_CONTENT_INFO {
    CRYPT_DER_BLOB              ToBeSigned;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CRYPT_BIT_BLOB              Signature;
} CERT_SIGNED_CONTENT_INFO, *PCERT_SIGNED_CONTENT_INFO;


//+-------------------------------------------------------------------------
//  Certificate Trust List (CTL)
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CTL Usage. Also used for EnhancedKeyUsage extension.
//--------------------------------------------------------------------------
typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


//+-------------------------------------------------------------------------
//  An entry in a CTL
//--------------------------------------------------------------------------
typedef struct _CTL_ENTRY {
    CRYPT_DATA_BLOB     SubjectIdentifier;          // For example, its hash
    DWORD               cAttribute;
    PCRYPT_ATTRIBUTE    rgAttribute;                // OPTIONAL
} CTL_ENTRY, *PCTL_ENTRY;

//+-------------------------------------------------------------------------
//  Information stored in a CTL
//--------------------------------------------------------------------------
typedef struct _CTL_INFO {
    DWORD                       dwVersion;
    CTL_USAGE                   SubjectUsage;
    CRYPT_DATA_BLOB             ListIdentifier;     // OPTIONAL
    CRYPT_INTEGER_BLOB          SequenceNumber;     // OPTIONAL
    FILETIME                    ThisUpdate;
    FILETIME                    NextUpdate;         // OPTIONAL
    CRYPT_ALGORITHM_IDENTIFIER  SubjectAlgorithm;
    DWORD                       cCTLEntry;
    PCTL_ENTRY                  rgCTLEntry;         // OPTIONAL
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;        // OPTIONAL
} CTL_INFO, *PCTL_INFO;

//+-------------------------------------------------------------------------
//  CTL versions
//--------------------------------------------------------------------------
#define CTL_V1     0


//+-------------------------------------------------------------------------
//  TimeStamp Request
//
//  The pszTimeStamp is the OID for the Time type requested
//  The pszContentType is the Content Type OID for the content, usually DATA
//  The Content is a un-decoded blob
//--------------------------------------------------------------------------
typedef struct _CRYPT_TIME_STAMP_REQUEST_INFO {
    LPSTR                   pszTimeStampAlgorithm;   // pszObjId
    LPSTR                   pszContentType;          // pszObjId
    CRYPT_OBJID_BLOB        Content;
    DWORD                   cAttribute;
    PCRYPT_ATTRIBUTE        rgAttribute;
} CRYPT_TIME_STAMP_REQUEST_INFO, *PCRYPT_TIME_STAMP_REQUEST_INFO;

//+-------------------------------------------------------------------------
//  Name Value Attribute
//--------------------------------------------------------------------------
typedef struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR {
    LPWSTR      pwszName;
    LPWSTR      pwszValue;
} CRYPT_ENROLLMENT_NAME_VALUE_PAIR, * PCRYPT_ENROLLMENT_NAME_VALUE_PAIR;

//+-------------------------------------------------------------------------
//  CSP Provider
//--------------------------------------------------------------------------
typedef struct _CRYPT_CSP_PROVIDER {
    DWORD           dwKeySpec;
    LPWSTR          pwszProviderName;
    CRYPT_BIT_BLOB  Signature;
} CRYPT_CSP_PROVIDER, * PCRYPT_CSP_PROVIDER;

//+-------------------------------------------------------------------------
//  Certificate and Message encoding types
//
//  The encoding type is a DWORD containing both the certificate and message
//  encoding types. The certificate encoding type is stored in the LOWORD.
//  The message encoding type is stored in the HIWORD. Some functions or
//  structure fields require only one of the encoding types. The following
//  naming convention is used to indicate which encoding type(s) are
//  required:
//      dwEncodingType              (both encoding types are required)
//      dwMsgAndCertEncodingType    (both encoding types are required)
//      dwMsgEncodingType           (only msg encoding type is required)
//      dwCertEncodingType          (only cert encoding type is required)
//
//  Its always acceptable to specify both.
//--------------------------------------------------------------------------
#define CERT_ENCODING_TYPE_MASK     0x0000FFFF
#define CMSG_ENCODING_TYPE_MASK     0xFFFF0000
#define GET_CERT_ENCODING_TYPE(X)   (X & CERT_ENCODING_TYPE_MASK)
#define GET_CMSG_ENCODING_TYPE(X)   (X & CMSG_ENCODING_TYPE_MASK)

#define CRYPT_ASN_ENCODING          0x00000001
#define CRYPT_NDR_ENCODING          0x00000002
#define X509_ASN_ENCODING           0x00000001
#define X509_NDR_ENCODING           0x00000002
#define PKCS_7_ASN_ENCODING         0x00010000
#define PKCS_7_NDR_ENCODING         0x00020000


//+-------------------------------------------------------------------------
//  format the specified data structure according to the certificate
//  encoding type.
//
//  The default behavior of CryptFormatObject is to return single line
//  display of the encoded data, that is, each subfield will be concatenated with
//  a ", " on one line.  If user prefers to display the data in multiple line,
//  set the flag CRYPT_FORMAT_STR_MULTI_LINE, that is, each subfield will be displayed
//  on a seperate line.
//
//  If there is no formatting routine installed or registered
//  for the lpszStructType, the hex dump of the encoded BLOB will be returned.
//  User can set the flag CRYPT_FORMAT_STR_NO_HEX to disable the hex dump.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptFormatObject(
    __in DWORD dwCertEncodingType,
    __in DWORD dwFormatType,
    __in DWORD dwFormatStrType,
    __in_opt void *pFormatStruct,
    __in_opt LPCSTR lpszStructType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __out_bcount_part_opt(*pcbFormat, *pcbFormat) __typefix(WCHAR *) void *pbFormat,
    __inout DWORD *pcbFormat
    );
//-------------------------------------------------------------------------
// constants for dwFormatStrType of function CryptFormatObject
//-------------------------------------------------------------------------
#define         CRYPT_FORMAT_STR_MULTI_LINE         0x0001
#define         CRYPT_FORMAT_STR_NO_HEX             0x0010

//-------------------------------------------------------------------------
// constants for dwFormatType of function CryptFormatObject
// when format X509_NAME or X509_UNICODE_NAME
//-------------------------------------------------------------------------
// Just get the simple string
#define         CRYPT_FORMAT_SIMPLE                 0x0001

//Put an attribute name infront of the attribute
//such as "O=Microsoft,DN=xiaohs"
#define         CRYPT_FORMAT_X509                   0x0002

//Put an OID infront of the simple string, such as
//"2.5.4.22=Microsoft,2.5.4.3=xiaohs"
#define         CRYPT_FORMAT_OID                    0x0004

//Put a ";" between each RDN.  The default is ","
#define         CRYPT_FORMAT_RDN_SEMICOLON          0x0100

//Put a "\n" between each RDN.
#define         CRYPT_FORMAT_RDN_CRLF               0x0200


//Unquote the DN value, which is quoated by default va the following
//rules: if the DN contains leading or trailing
//white space or one of the following characters: ",", "+", "=",
//""", "\n",  "<", ">", "#" or ";". The quoting character is ".
//If the DN Value contains a " it is double quoted ("").
#define         CRYPT_FORMAT_RDN_UNQUOTE            0x0400

//reverse the order of the RDNs before converting to the string
#define         CRYPT_FORMAT_RDN_REVERSE            0x0800


//-------------------------------------------------------------------------
//  contants dwFormatType of function CryptFormatObject when format a DN.:
//
//  The following three values are defined in the section above:
//  CRYPT_FORMAT_SIMPLE:    Just a simple string
//                          such as  "Microsoft+xiaohs+NT"
//  CRYPT_FORMAT_X509       Put an attribute name infront of the attribute
//                          such as "O=Microsoft+xiaohs+NT"
//
//  CRYPT_FORMAT_OID        Put an OID infront of the simple string,
//                          such as "2.5.4.22=Microsoft+xiaohs+NT"
//
//  Additional values are defined as following:
//----------------------------------------------------------------------------
//Put a "," between each value.  Default is "+"
#define         CRYPT_FORMAT_COMMA                  0x1000

//Put a ";" between each value
#define         CRYPT_FORMAT_SEMICOLON              CRYPT_FORMAT_RDN_SEMICOLON

//Put a "\n" between each value
#define         CRYPT_FORMAT_CRLF                   CRYPT_FORMAT_RDN_CRLF

//+-------------------------------------------------------------------------
//  Encode / decode the specified data structure according to the certificate
//  encoding type.
//
//  See below for a list of the predefined data structures.
//--------------------------------------------------------------------------

typedef LPVOID (WINAPI *PFN_CRYPT_ALLOC)(
    __in size_t cbSize
    );

typedef VOID (WINAPI *PFN_CRYPT_FREE)(
    __in LPVOID pv
    );


typedef struct _CRYPT_ENCODE_PARA {
    DWORD                   cbSize;
    PFN_CRYPT_ALLOC         pfnAlloc;           // OPTIONAL
    PFN_CRYPT_FREE          pfnFree;            // OPTIONAL
} CRYPT_ENCODE_PARA, *PCRYPT_ENCODE_PARA;


WINCRYPT32API
BOOL
WINAPI
CryptEncodeObjectEx(
    __in DWORD dwCertEncodingType,
    __in LPCSTR lpszStructType,
    __in const void *pvStructInfo,
    __in DWORD dwFlags,
    __in_opt PCRYPT_ENCODE_PARA pEncodePara,
    __out_opt void *pvEncoded,
    IN __out DWORD *pcbEncoded
    );

#ifdef UNDER_CE    
#define  CryptEncodeObject(dwCertEncodingType,lpszStructType,pvStructInfo,       pbEncoded,pcbEncoded)  \
       CryptEncodeObjectEx(dwCertEncodingType,lpszStructType,pvStructInfo,0,NULL,pbEncoded,pcbEncoded)
#else
WINCRYPT32API
BOOL
WINAPI
CryptEncodeObject(
    __in DWORD dwCertEncodingType,
    __in LPCSTR lpszStructType,
    __in const void *pvStructInfo,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded
    );
#endif

// By default the signature bytes are reversed. The following flag can
// be set to inhibit the byte reversal.
//
// This flag is applicable to
//      X509_CERT_TO_BE_SIGNED
#define CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG    0x8


//  When the following flag is set the called encode function allocates
//  memory for the encoded bytes. A pointer to the allocated bytes
//  is returned in pvEncoded. If pEncodePara or pEncodePara->pfnAlloc is
//  NULL, then, LocalAlloc is called for the allocation and LocalFree must
//  be called to do the free. Otherwise, pEncodePara->pfnAlloc is called
//  for the allocation.
//
//  *pcbEncoded is ignored on input and updated with the length of the
//  allocated, encoded bytes.
//
//  If pfnAlloc is set, then, pfnFree should also be set.
#define CRYPT_ENCODE_ALLOC_FLAG             0x8000


//  The following flag is applicable when encoding X509_UNICODE_NAME.
//  When set, CERT_RDN_T61_STRING is selected instead of
//  CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF
#define CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG   \
            CERT_RDN_ENABLE_T61_UNICODE_FLAG

//  The following flag is applicable when encoding X509_UNICODE_NAME.
//  When set, CERT_RDN_UTF8_STRING is selected instead of
//  CERT_RDN_UNICODE_STRING.
#define CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG   \
            CERT_RDN_ENABLE_UTF8_UNICODE_FLAG

//  The following flag is applicable when encoding X509_UNICODE_NAME.
//  When set, CERT_RDN_UTF8_STRING is selected instead of
//  CERT_RDN_PRINTABLE_STRING for DirectoryString types. Also,
//  enables CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG.
#define CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG     \
            CERT_RDN_FORCE_UTF8_UNICODE_FLAG

//  The following flag is applicable when encoding X509_UNICODE_NAME,
//  X509_UNICODE_NAME_VALUE or X509_UNICODE_ANY_STRING.
//  When set, the characters aren't checked to see if they
//  are valid for the specified Value Type.
#define CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG   \
            CERT_RDN_DISABLE_CHECK_TYPE_FLAG

//  The following flag is applicable when encoding the PKCS_SORTED_CTL. This
//  flag should be set if the identifier for the TrustedSubjects is a hash,
//  such as, MD5 or SHA1.
#define CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG     0x10000


typedef struct _CRYPT_DECODE_PARA {
    DWORD                   cbSize;
    PFN_CRYPT_ALLOC         pfnAlloc;           // OPTIONAL
    PFN_CRYPT_FREE          pfnFree;            // OPTIONAL
} CRYPT_DECODE_PARA, *PCRYPT_DECODE_PARA;

WINCRYPT32API
BOOL
WINAPI
CryptDecodeObjectEx(
    __in DWORD dwCertEncodingType,
    __in LPCSTR lpszStructType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __in DWORD dwFlags,
    __in_opt PCRYPT_DECODE_PARA pDecodePara,
    __out_opt void *pvStructInfo,
    __out DWORD *pcbStructInfo
    );

#ifdef UNDER_CE
#define CryptDecodeObject(dwCertEncodingType,lpszStructType,pbEncoded,cbEncoded,dwFlags,     pvStructInfo,pcbStructInfo) \
      CryptDecodeObjectEx(dwCertEncodingType,lpszStructType,pbEncoded,cbEncoded,dwFlags,NULL,pvStructInfo,pcbStructInfo)

#else

WINCRYPT32API
BOOL
WINAPI
CryptDecodeObject(
    __in DWORD dwCertEncodingType,
    __in LPCSTR lpszStructType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbStructInfo, *pcbStructInfo) void *pvStructInfo,
    __inout DWORD *pcbStructInfo
    );

#endif

// When the following flag is set the nocopy optimization is enabled.
// This optimization where appropriate, updates the pvStructInfo fields
// to point to content residing within pbEncoded instead of making a copy
// of and appending to pvStructInfo.
//
// Note, when set, pbEncoded can't be freed until pvStructInfo is freed.
#define CRYPT_DECODE_NOCOPY_FLAG            0x1

// For CryptDecodeObject(), by default the pbEncoded is the "to be signed"
// plus its signature. Set the following flag, if pbEncoded points to only
// the "to be signed".
//
// This flag is applicable to
//      X509_CERT_TO_BE_SIGNED
//      X509_CERT_CRL_TO_BE_SIGNED
//      X509_CERT_REQUEST_TO_BE_SIGNED
//      X509_KEYGEN_REQUEST_TO_BE_SIGNED
#define CRYPT_DECODE_TO_BE_SIGNED_FLAG      0x2

// When the following flag is set, the OID strings are allocated in
// crypt32.dll and shared instead of being copied into the returned
// data structure. This flag may be set if crypt32.dll isn't unloaded
// before the caller is unloaded.
#define CRYPT_DECODE_SHARE_OID_STRING_FLAG  0x4

// By default the signature bytes are reversed. The following flag can
// be set to inhibit the byte reversal.
//
// This flag is applicable to
//      X509_CERT_TO_BE_SIGNED
#define CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG    0x8


// When the following flag is set the called decode function allocates
// memory for the decoded structure. A pointer to the allocated structure
// is returned in pvStructInfo. If pDecodePara or pDecodePara->pfnAlloc is
// NULL, then, LocalAlloc is called for the allocation and LocalFree must
// be called to do the free. Otherwise, pDecodePara->pfnAlloc is called
// for the allocation.
//
// *pcbStructInfo is ignored on input and updated with the length of the
// allocated, decoded structure.
//
// This flag may also be set in the CryptDecodeObject API. Since
// CryptDecodeObject doesn't take a pDecodePara, LocalAlloc is always
// called for the allocation which must be freed by calling LocalFree.
#define CRYPT_DECODE_ALLOC_FLAG             0x8000

// The following flag is applicable when decoding X509_UNICODE_NAME,
// X509_UNICODE_NAME_VALUE or X509_UNICODE_ANY_STRING.
// By default, CERT_RDN_T61_STRING values are initially decoded
// as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
// Setting this flag skips the initial attempt to decode as UTF8.
#define CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG     \
            CERT_RDN_DISABLE_IE4_UTF8_FLAG


//+-------------------------------------------------------------------------
//  Predefined X509 certificate data structures that can be encoded / decoded.
//--------------------------------------------------------------------------
#define CRYPT_ENCODE_DECODE_NONE            0
#define X509_CERT                           ((LPCSTR) 1)
#define X509_CERT_TO_BE_SIGNED              ((LPCSTR) 2)
#define X509_CERT_CRL_TO_BE_SIGNED          ((LPCSTR) 3)
#define X509_CERT_REQUEST_TO_BE_SIGNED      ((LPCSTR) 4)
#define X509_EXTENSIONS                     ((LPCSTR) 5)
#define X509_NAME_VALUE                     ((LPCSTR) 6)
#define X509_NAME                           ((LPCSTR) 7)
#define X509_PUBLIC_KEY_INFO                ((LPCSTR) 8)

//+-------------------------------------------------------------------------
//  Predefined X509 certificate extension data structures that can be
//  encoded / decoded.
//--------------------------------------------------------------------------
#define X509_AUTHORITY_KEY_ID               ((LPCSTR) 9)
#define X509_KEY_ATTRIBUTES                 ((LPCSTR) 10)
#define X509_KEY_USAGE_RESTRICTION          ((LPCSTR) 11)
#define X509_ALTERNATE_NAME                 ((LPCSTR) 12)
#define X509_BASIC_CONSTRAINTS              ((LPCSTR) 13)
#define X509_KEY_USAGE                      ((LPCSTR) 14)
#define X509_BASIC_CONSTRAINTS2             ((LPCSTR) 15)
#define X509_CERT_POLICIES                  ((LPCSTR) 16)

//+-------------------------------------------------------------------------
//  Additional predefined data structures that can be encoded / decoded.
//--------------------------------------------------------------------------
#define PKCS_UTC_TIME                       ((LPCSTR) 17)
#define PKCS_TIME_REQUEST                   ((LPCSTR) 18)
#define RSA_CSP_PUBLICKEYBLOB               ((LPCSTR) 19)
#define X509_UNICODE_NAME                   ((LPCSTR) 20)

#define X509_KEYGEN_REQUEST_TO_BE_SIGNED    ((LPCSTR) 21)
#define PKCS_ATTRIBUTE                      ((LPCSTR) 22)
#define PKCS_CONTENT_INFO_SEQUENCE_OF_ANY   ((LPCSTR) 23)

//+-------------------------------------------------------------------------
//  Predefined primitive data structures that can be encoded / decoded.
//--------------------------------------------------------------------------
#define X509_UNICODE_NAME_VALUE             ((LPCSTR) 24)
#define X509_ANY_STRING                     X509_NAME_VALUE
#define X509_UNICODE_ANY_STRING             X509_UNICODE_NAME_VALUE
#define X509_OCTET_STRING                   ((LPCSTR) 25)
#define X509_BITS                           ((LPCSTR) 26)
#define X509_INTEGER                        ((LPCSTR) 27)
#define X509_MULTI_BYTE_INTEGER             ((LPCSTR) 28)
#define X509_ENUMERATED                     ((LPCSTR) 29)
#define X509_CHOICE_OF_TIME                 ((LPCSTR) 30)

//+-------------------------------------------------------------------------
//  More predefined X509 certificate extension data structures that can be
//  encoded / decoded.
//--------------------------------------------------------------------------
#define X509_AUTHORITY_KEY_ID2              ((LPCSTR) 31)
#define X509_AUTHORITY_INFO_ACCESS          ((LPCSTR) 32)
#define X509_SUBJECT_INFO_ACCESS            X509_AUTHORITY_INFO_ACCESS
#define X509_CRL_REASON_CODE                X509_ENUMERATED
#define PKCS_CONTENT_INFO                   ((LPCSTR) 33)
#define X509_SEQUENCE_OF_ANY                ((LPCSTR) 34)
#define X509_CRL_DIST_POINTS                ((LPCSTR) 35)
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)
#define PKCS_CTL                            ((LPCSTR) 37)

#define X509_MULTI_BYTE_UINT                ((LPCSTR) 38)
#define X509_DSS_PUBLICKEY                  X509_MULTI_BYTE_UINT
#define X509_DSS_PARAMETERS                 ((LPCSTR) 39)
#define X509_DSS_SIGNATURE                  ((LPCSTR) 40)
#define PKCS_RC2_CBC_PARAMETERS             ((LPCSTR) 41)
#define PKCS_SMIME_CAPABILITIES             ((LPCSTR) 42)

// Qualified Certificate Statements Extension uses the same encode/decode
// function as PKCS_SMIME_CAPABILITIES. Its data structures are identical
// except for the names of the fields.
#define X509_QC_STATEMENTS_EXT              ((LPCSTR) 42)

//+-------------------------------------------------------------------------
//  data structures for private keys
//--------------------------------------------------------------------------
#define PKCS_RSA_PRIVATE_KEY                ((LPCSTR) 43)
#define PKCS_PRIVATE_KEY_INFO               ((LPCSTR) 44)
#define PKCS_ENCRYPTED_PRIVATE_KEY_INFO     ((LPCSTR) 45)

//+-------------------------------------------------------------------------
//  certificate policy qualifier
//--------------------------------------------------------------------------
#define X509_PKIX_POLICY_QUALIFIER_USERNOTICE ((LPCSTR) 46)

//+-------------------------------------------------------------------------
//  Diffie-Hellman Key Exchange
//--------------------------------------------------------------------------
#define X509_DH_PUBLICKEY                   X509_MULTI_BYTE_UINT
#define X509_DH_PARAMETERS                  ((LPCSTR) 47)
#define PKCS_ATTRIBUTES                     ((LPCSTR) 48)
#define PKCS_SORTED_CTL                     ((LPCSTR) 49)

//+-------------------------------------------------------------------------
//  ECC Signature
//--------------------------------------------------------------------------
// Uses the same encode/decode function as X509_DH_PARAMETERS. Its data
// structure is identical except for the names of the fields.
#define X509_ECC_SIGNATURE                  ((LPCSTR) 47)

//+-------------------------------------------------------------------------
//  X942 Diffie-Hellman
//--------------------------------------------------------------------------
#define X942_DH_PARAMETERS                  ((LPCSTR) 50)

//+-------------------------------------------------------------------------
//  The following is the same as X509_BITS, except before encoding,
//  the bit length is decremented to exclude trailing zero bits.
//--------------------------------------------------------------------------
#define X509_BITS_WITHOUT_TRAILING_ZEROES   ((LPCSTR) 51)

//+-------------------------------------------------------------------------
//  X942 Diffie-Hellman Other Info
//--------------------------------------------------------------------------
#define X942_OTHER_INFO                     ((LPCSTR) 52)

#define X509_CERT_PAIR                      ((LPCSTR) 53)
#define X509_ISSUING_DIST_POINT             ((LPCSTR) 54)
#define X509_NAME_CONSTRAINTS               ((LPCSTR) 55)
#define X509_POLICY_MAPPINGS                ((LPCSTR) 56)
#define X509_POLICY_CONSTRAINTS             ((LPCSTR) 57)
#define X509_CROSS_CERT_DIST_POINTS         ((LPCSTR) 58)

//+-------------------------------------------------------------------------
//  Certificate Management Messages over CMS (CMC) Data Structures
//--------------------------------------------------------------------------
#define CMC_DATA                            ((LPCSTR) 59)
#define CMC_RESPONSE                        ((LPCSTR) 60)
#define CMC_STATUS                          ((LPCSTR) 61)
#define CMC_ADD_EXTENSIONS                  ((LPCSTR) 62)
#define CMC_ADD_ATTRIBUTES                  ((LPCSTR) 63)

//+-------------------------------------------------------------------------
//  Certificate Template
//--------------------------------------------------------------------------
#define X509_CERTIFICATE_TEMPLATE           ((LPCSTR) 64)

//+-------------------------------------------------------------------------
//  Online Certificate Status Protocol (OCSP) Data Structures
//--------------------------------------------------------------------------
#define OCSP_SIGNED_REQUEST                 ((LPCSTR) 65)
#define OCSP_REQUEST                        ((LPCSTR) 66)
#define OCSP_RESPONSE                       ((LPCSTR) 67)
#define OCSP_BASIC_SIGNED_RESPONSE          ((LPCSTR) 68)
#define OCSP_BASIC_RESPONSE                 ((LPCSTR) 69)

//+-------------------------------------------------------------------------
//  Logotype and Biometric Extensions
//--------------------------------------------------------------------------
#define X509_LOGOTYPE_EXT                   ((LPCSTR) 70)
#define X509_BIOMETRIC_EXT                  ((LPCSTR) 71)

#define CNG_RSA_PUBLIC_KEY_BLOB             ((LPCSTR) 72)
#define X509_OBJECT_IDENTIFIER              ((LPCSTR) 73)
#define X509_ALGORITHM_IDENTIFIER           ((LPCSTR) 74)
#define PKCS_RSA_SSA_PSS_PARAMETERS         ((LPCSTR) 75)
#define PKCS_RSAES_OAEP_PARAMETERS          ((LPCSTR) 76)

#define ECC_CMS_SHARED_INFO                 ((LPCSTR) 77)

//+-------------------------------------------------------------------------
//  Predefined PKCS #7 data structures that can be encoded / decoded.
//--------------------------------------------------------------------------
#define PKCS7_SIGNER_INFO                   ((LPCSTR) 500)

//+-------------------------------------------------------------------------
//  Predefined PKCS #7 data structures that can be encoded / decoded.
//--------------------------------------------------------------------------
#define CMS_SIGNER_INFO                     ((LPCSTR) 501)

//+-------------------------------------------------------------------------
//  Predefined Software Publishing Credential (SPC)  data structures that
//  can be encoded / decoded.
//
//  Predefined values: 2000 .. 2999
//
//  See spc.h for value and data structure definitions.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Extension Object Identifiers
//--------------------------------------------------------------------------
#define szOID_AUTHORITY_KEY_IDENTIFIER  "2.5.29.1"
#define szOID_KEY_ATTRIBUTES            "2.5.29.2"
#define szOID_CERT_POLICIES_95          "2.5.29.3"
#define szOID_KEY_USAGE_RESTRICTION     "2.5.29.4"
#define szOID_SUBJECT_ALT_NAME          "2.5.29.7"
#define szOID_ISSUER_ALT_NAME           "2.5.29.8"
#define szOID_BASIC_CONSTRAINTS         "2.5.29.10"
#define szOID_KEY_USAGE                 "2.5.29.15"
#define szOID_PRIVATEKEY_USAGE_PERIOD   "2.5.29.16"
#define szOID_BASIC_CONSTRAINTS2        "2.5.29.19"

#define szOID_CERT_POLICIES             "2.5.29.32"
#define szOID_ANY_CERT_POLICY           "2.5.29.32.0"
#define szOID_INHIBIT_ANY_POLICY        "2.5.29.54"

#define szOID_AUTHORITY_KEY_IDENTIFIER2 "2.5.29.35"
#define szOID_SUBJECT_KEY_IDENTIFIER    "2.5.29.14"
#define szOID_SUBJECT_ALT_NAME2         "2.5.29.17"
#define szOID_ISSUER_ALT_NAME2          "2.5.29.18"
#define szOID_CRL_REASON_CODE           "2.5.29.21"
#define szOID_REASON_CODE_HOLD          "2.5.29.23"
#define szOID_CRL_DIST_POINTS           "2.5.29.31"
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"

#define szOID_ANY_ENHANCED_KEY_USAGE    "2.5.29.37.0"

// szOID_CRL_NUMBER -- Base CRLs only.  Monotonically increasing sequence
// number for each CRL issued by a CA.
#define szOID_CRL_NUMBER                "2.5.29.20"
// szOID_DELTA_CRL_INDICATOR -- Delta CRLs only.  Marked critical.
// Contains the minimum base CRL Number that can be used with a delta CRL.
#define szOID_DELTA_CRL_INDICATOR       "2.5.29.27"
#define szOID_ISSUING_DIST_POINT        "2.5.29.28"
// szOID_FRESHEST_CRL -- Base CRLs only.  Formatted identically to a CDP
// extension that holds URLs to fetch the delta CRL.
#define szOID_FRESHEST_CRL              "2.5.29.46"
#define szOID_NAME_CONSTRAINTS          "2.5.29.30"

// Note on 1/1/2000 szOID_POLICY_MAPPINGS was changed from "2.5.29.5"
#define szOID_POLICY_MAPPINGS           "2.5.29.33"
#define szOID_LEGACY_POLICY_MAPPINGS    "2.5.29.5"
#define szOID_POLICY_CONSTRAINTS        "2.5.29.36"


// Microsoft PKCS10 Attributes
#define szOID_RENEWAL_CERTIFICATE           "1.3.6.1.4.1.311.13.1"
#define szOID_ENROLLMENT_NAME_VALUE_PAIR    "1.3.6.1.4.1.311.13.2.1"
#define szOID_ENROLLMENT_CSP_PROVIDER       "1.3.6.1.4.1.311.13.2.2"
#define szOID_OS_VERSION                    "1.3.6.1.4.1.311.13.2.3"

//
// Extension contain certificate type
#define szOID_ENROLLMENT_AGENT              "1.3.6.1.4.1.311.20.2.1"

// Internet Public Key Infrastructure (PKIX)
#define szOID_PKIX                      "1.3.6.1.5.5.7"
#define szOID_PKIX_PE                   "1.3.6.1.5.5.7.1"
#define szOID_AUTHORITY_INFO_ACCESS     "1.3.6.1.5.5.7.1.1"
#define szOID_SUBJECT_INFO_ACCESS       "1.3.6.1.5.5.7.1.11"
#define szOID_BIOMETRIC_EXT             "1.3.6.1.5.5.7.1.2"
#define szOID_QC_STATEMENTS_EXT         "1.3.6.1.5.5.7.1.3"
#define szOID_LOGOTYPE_EXT              "1.3.6.1.5.5.7.1.12"

// Microsoft extensions or attributes
#define szOID_CERT_EXTENSIONS           "1.3.6.1.4.1.311.2.1.14"
#define szOID_NEXT_UPDATE_LOCATION      "1.3.6.1.4.1.311.10.2"
#define szOID_REMOVE_CERTIFICATE            "1.3.6.1.4.1.311.10.8.1"
#define szOID_CROSS_CERT_DIST_POINTS    "1.3.6.1.4.1.311.10.9.1"

//  Microsoft PKCS #7 ContentType Object Identifiers
#define szOID_CTL                       "1.3.6.1.4.1.311.10.1"

//  Microsoft Sorted CTL Extension Object Identifier
#define szOID_SORTED_CTL                "1.3.6.1.4.1.311.10.1.1"

// serialized serial numbers for PRS
#ifndef szOID_SERIALIZED
#define szOID_SERIALIZED                "1.3.6.1.4.1.311.10.3.3.1"
#endif

// UPN principal name in SubjectAltName
#ifndef szOID_NT_PRINCIPAL_NAME
#define szOID_NT_PRINCIPAL_NAME         "1.3.6.1.4.1.311.20.2.3"
#endif

// Windows product update unauthenticated attribute
#ifndef szOID_PRODUCT_UPDATE
#define szOID_PRODUCT_UPDATE            "1.3.6.1.4.1.311.31.1"
#endif

// CryptUI
#define szOID_ANY_APPLICATION_POLICY    "1.3.6.1.4.1.311.10.12.1"

//+-------------------------------------------------------------------------
//  Object Identifiers for use with Auto Enrollment
//--------------------------------------------------------------------------
#define szOID_AUTO_ENROLL_CTL_USAGE     "1.3.6.1.4.1.311.20.1"

// Extension contain certificate type
// AKA Certificate template extension (v1)
#define szOID_ENROLL_CERTTYPE_EXTENSION "1.3.6.1.4.1.311.20.2"


#define szOID_CERT_MANIFOLD             "1.3.6.1.4.1.311.20.3"

//+-------------------------------------------------------------------------
//  Object Identifiers for use with the MS Certificate Server
//--------------------------------------------------------------------------
#ifndef szOID_CERTSRV_CA_VERSION
#define szOID_CERTSRV_CA_VERSION        "1.3.6.1.4.1.311.21.1"
#endif


// szOID_CERTSRV_PREVIOUS_CERT_HASH -- Contains the sha1 hash of the previous
// version of the CA certificate.
#define szOID_CERTSRV_PREVIOUS_CERT_HASH    "1.3.6.1.4.1.311.21.2"

// szOID_CRL_VIRTUAL_BASE -- Delta CRLs only.  Contains the base CRL Number
// of the corresponding base CRL.
#define szOID_CRL_VIRTUAL_BASE          "1.3.6.1.4.1.311.21.3"

// szOID_CRL_NEXT_PUBLISH -- Contains the time when the next CRL is expected
// to be published.  This may be sooner than the CRL's NextUpdate field.
#define szOID_CRL_NEXT_PUBLISH          "1.3.6.1.4.1.311.21.4"

// Enhanced Key Usage for CA encryption certificate
#define szOID_KP_CA_EXCHANGE            "1.3.6.1.4.1.311.21.5"

// Enhanced Key Usage for key recovery agent certificate
#define szOID_KP_KEY_RECOVERY_AGENT     "1.3.6.1.4.1.311.21.6"

// Certificate template extension (v2)
#define szOID_CERTIFICATE_TEMPLATE      "1.3.6.1.4.1.311.21.7"

// The root oid for all enterprise specific oids
#define szOID_ENTERPRISE_OID_ROOT       "1.3.6.1.4.1.311.21.8"

// Dummy signing Subject RDN
#define szOID_RDN_DUMMY_SIGNER          "1.3.6.1.4.1.311.21.9"

// Application Policies extension -- same encoding as szOID_CERT_POLICIES
#define szOID_APPLICATION_CERT_POLICIES     "1.3.6.1.4.1.311.21.10"

// Application Policy Mappings -- same encoding as szOID_POLICY_MAPPINGS
#define szOID_APPLICATION_POLICY_MAPPINGS   "1.3.6.1.4.1.311.21.11"

// Application Policy Constraints -- same encoding as szOID_POLICY_CONSTRAINTS
#define szOID_APPLICATION_POLICY_CONSTRAINTS    "1.3.6.1.4.1.311.21.12"

#define szOID_ARCHIVED_KEY_ATTR                "1.3.6.1.4.1.311.21.13"
#define szOID_CRL_SELF_CDP                     "1.3.6.1.4.1.311.21.14"


// Requires all certificates below the root to have a non-empty intersecting
// issuance certificate policy usage.
#define szOID_REQUIRE_CERT_CHAIN_POLICY        "1.3.6.1.4.1.311.21.15"
#define szOID_ARCHIVED_KEY_CERT_HASH           "1.3.6.1.4.1.311.21.16"
#define szOID_ISSUED_CERT_HASH                 "1.3.6.1.4.1.311.21.17"

// Enhanced key usage for DS email replication
#define szOID_DS_EMAIL_REPLICATION             "1.3.6.1.4.1.311.21.19"

#define szOID_REQUEST_CLIENT_INFO              "1.3.6.1.4.1.311.21.20"
#define szOID_ENCRYPTED_KEY_HASH               "1.3.6.1.4.1.311.21.21"
#define szOID_CERTSRV_CROSSCA_VERSION          "1.3.6.1.4.1.311.21.22"

//+-------------------------------------------------------------------------
//  Object Identifiers for use with the MS Directory Service
//--------------------------------------------------------------------------
#define szOID_NTDS_REPLICATION      "1.3.6.1.4.1.311.25.1"


//+-------------------------------------------------------------------------
//  Extension Object Identifiers (currently not implemented)
//--------------------------------------------------------------------------
#define szOID_SUBJECT_DIR_ATTRS         "2.5.29.9"

//+-------------------------------------------------------------------------
//  Enhanced Key Usage (Purpose) Object Identifiers
//--------------------------------------------------------------------------
#define szOID_PKIX_KP                   "1.3.6.1.5.5.7.3"

// Consistent key usage bits: DIGITAL_SIGNATURE, KEY_ENCIPHERMENT
// or KEY_AGREEMENT
#define szOID_PKIX_KP_SERVER_AUTH       "1.3.6.1.5.5.7.3.1"

// Consistent key usage bits: DIGITAL_SIGNATURE
#define szOID_PKIX_KP_CLIENT_AUTH       "1.3.6.1.5.5.7.3.2"

// Consistent key usage bits: DIGITAL_SIGNATURE
#define szOID_PKIX_KP_CODE_SIGNING      "1.3.6.1.5.5.7.3.3"

// Consistent key usage bits: DIGITAL_SIGNATURE, NON_REPUDIATION and/or
// (KEY_ENCIPHERMENT or KEY_AGREEMENT)
#define szOID_PKIX_KP_EMAIL_PROTECTION  "1.3.6.1.5.5.7.3.4"

// Consistent key usage bits: DIGITAL_SIGNATURE and/or
// (KEY_ENCIPHERMENT or KEY_AGREEMENT)
#define szOID_PKIX_KP_IPSEC_END_SYSTEM  "1.3.6.1.5.5.7.3.5"

// Consistent key usage bits: DIGITAL_SIGNATURE and/or
// (KEY_ENCIPHERMENT or KEY_AGREEMENT)
#define szOID_PKIX_KP_IPSEC_TUNNEL      "1.3.6.1.5.5.7.3.6"

// Consistent key usage bits: DIGITAL_SIGNATURE and/or
// (KEY_ENCIPHERMENT or KEY_AGREEMENT)
#define szOID_PKIX_KP_IPSEC_USER        "1.3.6.1.5.5.7.3.7"

// Consistent key usage bits: DIGITAL_SIGNATURE or NON_REPUDIATION
#define szOID_PKIX_KP_TIMESTAMP_SIGNING "1.3.6.1.5.5.7.3.8"

// OCSP response signer
#define szOID_PKIX_KP_OCSP_SIGNING      "1.3.6.1.5.5.7.3.9"

// Following extension is present to indicate no revocation checking
// for the OCSP signer certificate
#define szOID_PKIX_OCSP_NOCHECK         "1.3.6.1.5.5.7.48.1.5"

// OCSP Nonce
#define szOID_PKIX_OCSP_NONCE		"1.3.6.1.5.5.7.48.1.2"

// IKE (Internet Key Exchange) Intermediate KP for an IPsec end entity.
// Defined in draft-ietf-ipsec-pki-req-04.txt, December 14, 1999.
#define szOID_IPSEC_KP_IKE_INTERMEDIATE "1.3.6.1.5.5.8.2.2"


// iso (1) org (3) dod (6) internet (1) security (5) kerberosv5 (2) pkinit (3) 5
#define szOID_PKINIT_KP_KDC             "1.3.6.1.5.2.3.5"

//+-------------------------------------------------------------------------
//  Microsoft Enhanced Key Usage (Purpose) Object Identifiers
//+-------------------------------------------------------------------------

//  Signer of CTLs
#define szOID_KP_CTL_USAGE_SIGNING      "1.3.6.1.4.1.311.10.3.1"

//  Signer of TimeStamps
#define szOID_KP_TIME_STAMP_SIGNING     "1.3.6.1.4.1.311.10.3.2"

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#ifndef szOID_SGC_NETSCAPE
#define szOID_SGC_NETSCAPE              "2.16.840.1.113730.4.1"
#endif

#define szOID_KP_EFS                    "1.3.6.1.4.1.311.10.3.4"
#define szOID_EFS_RECOVERY              "1.3.6.1.4.1.311.10.3.4.1"

// Can use Windows Hardware Compatible (WHQL)
#define szOID_WHQL_CRYPTO               "1.3.6.1.4.1.311.10.3.5"

// Signed by the NT5 build lab
#define szOID_NT5_CRYPTO                "1.3.6.1.4.1.311.10.3.6"

// Signed by and OEM of WHQL
#define szOID_OEM_WHQL_CRYPTO           "1.3.6.1.4.1.311.10.3.7"

// Signed by the Embedded NT
#define szOID_EMBEDDED_NT_CRYPTO        "1.3.6.1.4.1.311.10.3.8"

// Signer of a CTL containing trusted roots
#define szOID_ROOT_LIST_SIGNER      "1.3.6.1.4.1.311.10.3.9"

// Can sign cross-cert and subordinate CA requests with qualified
// subordination (name constraints, policy mapping, etc.)
#define szOID_KP_QUALIFIED_SUBORDINATION    "1.3.6.1.4.1.311.10.3.10"

// Can be used to encrypt/recover escrowed keys
#define szOID_KP_KEY_RECOVERY               "1.3.6.1.4.1.311.10.3.11"

// Signer of documents
#define szOID_KP_DOCUMENT_SIGNING           "1.3.6.1.4.1.311.10.3.12"


// The default WinVerifyTrust Authenticode policy is to treat all time stamped
// signatures as being valid forever. This OID limits the valid lifetime of the
// signature to the lifetime of the certificate. This allows timestamped
// signatures to expire. Normally this OID will be used in conjunction with
// szOID_PKIX_KP_CODE_SIGNING to indicate new time stamp semantics should be
// used. Support for this OID was added in WXP.
#define szOID_KP_LIFETIME_SIGNING           "1.3.6.1.4.1.311.10.3.13"

#define szOID_KP_MOBILE_DEVICE_SOFTWARE     "1.3.6.1.4.1.311.10.3.14"

#define szOID_KP_SMART_DISPLAY          "1.3.6.1.4.1.311.10.3.15"

#define szOID_KP_CSP_SIGNATURE          "1.3.6.1.4.1.311.10.3.16"

#ifndef szOID_DRM
#define szOID_DRM                       "1.3.6.1.4.1.311.10.5.1"
#endif


// Microsoft DRM EKU
#ifndef szOID_DRM_INDIVIDUALIZATION
#define szOID_DRM_INDIVIDUALIZATION "1.3.6.1.4.1.311.10.5.2"
#endif


#ifndef szOID_LICENSES
#define szOID_LICENSES                  "1.3.6.1.4.1.311.10.6.1"
#endif

#ifndef szOID_LICENSE_SERVER
#define szOID_LICENSE_SERVER            "1.3.6.1.4.1.311.10.6.2"
#endif

#ifndef szOID_KP_SMARTCARD_LOGON
#define szOID_KP_SMARTCARD_LOGON        "1.3.6.1.4.1.311.20.2.2"
#endif


#define szOID_KP_KERNEL_MODE_CODE_SIGNING   "1.3.6.1.4.1.311.61.1.1"

//+-------------------------------------------------------------------------
//  Microsoft Attribute Object Identifiers
//+-------------------------------------------------------------------------
#define szOID_YESNO_TRUST_ATTR          "1.3.6.1.4.1.311.10.4.1"

//+-------------------------------------------------------------------------
//  Qualifiers that may be part of the szOID_CERT_POLICIES and
//  szOID_CERT_POLICIES95 extensions
//+-------------------------------------------------------------------------
#define szOID_PKIX_POLICY_QUALIFIER_CPS               "1.3.6.1.5.5.7.2.1"
#define szOID_PKIX_POLICY_QUALIFIER_USERNOTICE        "1.3.6.1.5.5.7.2.2"

#define szOID_ROOT_PROGRAM_FLAGS                      "1.3.6.1.4.1.311.60.1.1"

// OID for old qualifer
#define szOID_CERT_POLICIES_95_QUALIFIER1             "2.16.840.1.113733.1.7.1.1"

//+-------------------------------------------------------------------------
//  X509_CERT
//
//  The "to be signed" encoded content plus its signature. The ToBeSigned
//  content is the CryptEncodeObject() output for one of the following:
//  X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED or
//  X509_CERT_REQUEST_TO_BE_SIGNED.
//
//  pvStructInfo points to CERT_SIGNED_CONTENT_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CERT_TO_BE_SIGNED
//
//  pvStructInfo points to CERT_INFO.
//
//  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
//  signature (output of a X509_CERT CryptEncodeObject()).
//
//  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CERT_CRL_TO_BE_SIGNED
//
//  pvStructInfo points to CRL_INFO.
//
//  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
//  signature (output of a X509_CERT CryptEncodeObject()).
//
//  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CERT_REQUEST_TO_BE_SIGNED
//
//  pvStructInfo points to CERT_REQUEST_INFO.
//
//  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
//  signature (output of a X509_CERT CryptEncodeObject()).
//
//  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_EXTENSIONS
//  szOID_CERT_EXTENSIONS
//
//  pvStructInfo points to following CERT_EXTENSIONS.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXTS
typedef struct _CERT_EXTENSIONS {
    DWORD           cExtension;
    PCERT_EXTENSION rgExtension;
} CERT_EXTENSIONS, *PCERT_EXTENSIONS;
// certenrolls_end

//+-------------------------------------------------------------------------
//  X509_NAME_VALUE
//  X509_ANY_STRING
//
//  pvStructInfo points to CERT_NAME_VALUE.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_UNICODE_NAME_VALUE
//  X509_UNICODE_ANY_STRING
//
//  pvStructInfo points to CERT_NAME_VALUE.
//
//  The name values are unicode strings.
//
//  For CryptEncodeObject:
//    Value.pbData points to the unicode string.
//    If Value.cbData = 0, then, the unicode string is NULL terminated.
//    Otherwise, Value.cbData is the unicode string byte count. The byte count
//    is twice the character count.
//
//    If the unicode string contains an invalid character for the specified
//    dwValueType, then, *pcbEncoded is updated with the unicode character
//    index of the first invalid character. LastError is set to:
//    CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or
//    CRYPT_E_INVALID_IA5_STRING.
//
//    To disable the above check, either set CERT_RDN_DISABLE_CHECK_TYPE_FLAG
//    in dwValueType or set CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG
//    in dwFlags passed to CryptEncodeObjectEx.
//
//    The unicode string is converted before being encoded according to
//    the specified dwValueType. If dwValueType is set to 0, LastError
//    is set to E_INVALIDARG.
//
//    If the dwValueType isn't one of the character strings (its a
//    CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING), then, CryptEncodeObject
//    will return FALSE with LastError set to CRYPT_E_NOT_CHAR_STRING.
//
//  For CryptDecodeObject:
//    Value.pbData points to a NULL terminated unicode string. Value.cbData
//    contains the byte count of the unicode string excluding the NULL
//    terminator. dwValueType contains the type used in the encoded object.
//    Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is
//    converted to the unicode string according to the dwValueType.
//
//    If the encoded object isn't one of the character string types, then,
//    CryptDecodeObject will return FALSE with LastError set to
//    CRYPT_E_NOT_CHAR_STRING. For a non character string, decode using
//    X509_NAME_VALUE or X509_ANY_STRING.
//
//    By default, CERT_RDN_T61_STRING values are initially decoded
//    as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
//    Set CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG in dwFlags
//    passed to either CryptDecodeObject or CryptDecodeObjectEx to
//    skip the initial attempt to decode as UTF8.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_NAME
//
//  pvStructInfo points to CERT_NAME_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_UNICODE_NAME
//
//  pvStructInfo points to CERT_NAME_INFO.
//
//  The RDN attribute values are unicode strings except for the dwValueTypes of
//  CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING. These dwValueTypes are
//  the same as for a X509_NAME. Their values aren't converted to/from unicode.
//
//  For CryptEncodeObject:
//    Value.pbData points to the unicode string.
//    If Value.cbData = 0, then, the unicode string is NULL terminated.
//    Otherwise, Value.cbData is the unicode string byte count. The byte count
//    is twice the character count.
//
//    If dwValueType = 0 (CERT_RDN_ANY_TYPE), the pszObjId is used to find
//    an acceptable dwValueType. If the unicode string contains an
//    invalid character for the found or specified dwValueType, then,
//    *pcbEncoded is updated with the error location of the invalid character.
//    See below for details. LastError is set to:
//    CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or
//    CRYPT_E_INVALID_IA5_STRING.
//
//    To disable the above check, either set CERT_RDN_DISABLE_CHECK_TYPE_FLAG
//    in dwValueType or set CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG
//    in dwFlags passed to CryptEncodeObjectEx.
//
//    Set CERT_RDN_UNICODE_STRING in dwValueType or set
//    CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG in dwFlags passed
//    to CryptEncodeObjectEx to select CERT_RDN_T61_STRING instead of
//    CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF.
//
//    Set CERT_RDN_ENABLE_UTF8_UNICODE_STRING in dwValueType or set
//    CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG in dwFlags passed
//    to CryptEncodeObjectEx to select CERT_RDN_UTF8_STRING instead of
//    CERT_RDN_UNICODE_STRING.
//
//    The unicode string is converted before being encoded according to
//    the specified or ObjId matching dwValueType.
//
//  For CryptDecodeObject:
//    Value.pbData points to a NULL terminated unicode string. Value.cbData
//    contains the byte count of the unicode string excluding the NULL
//    terminator. dwValueType contains the type used in the encoded object.
//    Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is
//    converted to the unicode string according to the dwValueType.
//
//    If the dwValueType of the encoded value isn't a character string
//    type, then, it isn't converted to UNICODE. Use the
//    IS_CERT_RDN_CHAR_STRING() macro on the dwValueType to check
//    that Value.pbData points to a converted unicode string.
//
//    By default, CERT_RDN_T61_STRING values are initially decoded
//    as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
//    Set CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG in dwFlags
//    passed to either CryptDecodeObject or CryptDecodeObjectEx to
//    skip the initial attempt to decode as UTF8.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Unicode Name Value Error Location Definitions
//
//  Error location is returned in *pcbEncoded by
//  CryptEncodeObject(X509_UNICODE_NAME)
//
//  Error location consists of:
//    RDN_INDEX     - 10 bits << 22
//    ATTR_INDEX    - 6 bits << 16
//    VALUE_INDEX   - 16 bits (unicode character index)
//--------------------------------------------------------------------------
#define CERT_UNICODE_RDN_ERR_INDEX_MASK     0x3FF
#define CERT_UNICODE_RDN_ERR_INDEX_SHIFT    22
#define CERT_UNICODE_ATTR_ERR_INDEX_MASK    0x003F
#define CERT_UNICODE_ATTR_ERR_INDEX_SHIFT   16
#define CERT_UNICODE_VALUE_ERR_INDEX_MASK   0x0000FFFF
#define CERT_UNICODE_VALUE_ERR_INDEX_SHIFT  0

#define GET_CERT_UNICODE_RDN_ERR_INDEX(X)   \
    ((X >> CERT_UNICODE_RDN_ERR_INDEX_SHIFT) & CERT_UNICODE_RDN_ERR_INDEX_MASK)
#define GET_CERT_UNICODE_ATTR_ERR_INDEX(X)  \
    ((X >> CERT_UNICODE_ATTR_ERR_INDEX_SHIFT) & CERT_UNICODE_ATTR_ERR_INDEX_MASK)
#define GET_CERT_UNICODE_VALUE_ERR_INDEX(X) \
    (X & CERT_UNICODE_VALUE_ERR_INDEX_MASK)

//+-------------------------------------------------------------------------
//  X509_PUBLIC_KEY_INFO
//
//  pvStructInfo points to CERT_PUBLIC_KEY_INFO.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  X509_AUTHORITY_KEY_ID
//  szOID_AUTHORITY_KEY_IDENTIFIER
//
//  pvStructInfo points to following CERT_AUTHORITY_KEY_ID_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_AUTHORITY_KEY_ID_INFO {
    CRYPT_DATA_BLOB     KeyId;
    CERT_NAME_BLOB      CertIssuer;
    CRYPT_INTEGER_BLOB  CertSerialNumber;
} CERT_AUTHORITY_KEY_ID_INFO, *PCERT_AUTHORITY_KEY_ID_INFO;

//+-------------------------------------------------------------------------
//  X509_KEY_ATTRIBUTES
//  szOID_KEY_ATTRIBUTES
//
//  pvStructInfo points to following CERT_KEY_ATTRIBUTES_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_PRIVATE_KEY_VALIDITY {
    FILETIME            NotBefore;
    FILETIME            NotAfter;
} CERT_PRIVATE_KEY_VALIDITY, *PCERT_PRIVATE_KEY_VALIDITY;

typedef struct _CERT_KEY_ATTRIBUTES_INFO {
    CRYPT_DATA_BLOB             KeyId;
    CRYPT_BIT_BLOB              IntendedKeyUsage;
    PCERT_PRIVATE_KEY_VALIDITY  pPrivateKeyUsagePeriod;     // OPTIONAL
} CERT_KEY_ATTRIBUTES_INFO, *PCERT_KEY_ATTRIBUTES_INFO;

// certenrolld_begin -- CERT_*_KEY_USAGE
// Byte[0]
#define CERT_DIGITAL_SIGNATURE_KEY_USAGE     0x80
#define CERT_NON_REPUDIATION_KEY_USAGE       0x40
#define CERT_KEY_ENCIPHERMENT_KEY_USAGE      0x20
#define CERT_DATA_ENCIPHERMENT_KEY_USAGE     0x10
#define CERT_KEY_AGREEMENT_KEY_USAGE         0x08
#define CERT_KEY_CERT_SIGN_KEY_USAGE         0x04
#define CERT_OFFLINE_CRL_SIGN_KEY_USAGE      0x02
#define CERT_CRL_SIGN_KEY_USAGE              0x02
#define CERT_ENCIPHER_ONLY_KEY_USAGE         0x01
// Byte[1]
#define CERT_DECIPHER_ONLY_KEY_USAGE         0x80
// certenrolld_end

//+-------------------------------------------------------------------------
//  X509_KEY_USAGE_RESTRICTION
//  szOID_KEY_USAGE_RESTRICTION
//
//  pvStructInfo points to following CERT_KEY_USAGE_RESTRICTION_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_POLICY_ID {
    DWORD                   cCertPolicyElementId;
    LPSTR                   *rgpszCertPolicyElementId;  // pszObjId
} CERT_POLICY_ID, *PCERT_POLICY_ID;

typedef struct _CERT_KEY_USAGE_RESTRICTION_INFO {
    DWORD                   cCertPolicyId;
    PCERT_POLICY_ID         rgCertPolicyId;
    CRYPT_BIT_BLOB          RestrictedKeyUsage;
} CERT_KEY_USAGE_RESTRICTION_INFO, *PCERT_KEY_USAGE_RESTRICTION_INFO;

// See CERT_KEY_ATTRIBUTES_INFO for definition of the RestrictedKeyUsage bits

//+-------------------------------------------------------------------------
//  X509_ALTERNATE_NAME
//  szOID_SUBJECT_ALT_NAME
//  szOID_ISSUER_ALT_NAME
//  szOID_SUBJECT_ALT_NAME2
//  szOID_ISSUER_ALT_NAME2
//
//  pvStructInfo points to following CERT_ALT_NAME_INFO.
//--------------------------------------------------------------------------

// certenrolls_begin -- CERT_ALT_NAME_INFO
typedef struct _CERT_OTHER_NAME {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Value;
} CERT_OTHER_NAME, *PCERT_OTHER_NAME;

typedef struct _CERT_ALT_NAME_ENTRY {
    DWORD   dwAltNameChoice;
    union {                                             // certenrolls_skip
        PCERT_OTHER_NAME            pOtherName;         // 1
        LPWSTR                      pwszRfc822Name;     // 2  (encoded IA5)
        LPWSTR                      pwszDNSName;        // 3  (encoded IA5)
        // Not implemented          x400Address;        // 4
        CERT_NAME_BLOB              DirectoryName;      // 5
        // Not implemented          pEdiPartyName;      // 6
        LPWSTR                      pwszURL;            // 7  (encoded IA5)
        CRYPT_DATA_BLOB             IPAddress;          // 8  (Octet String)
        LPSTR                       pszRegisteredID;    // 9  (Object Identifer)
    };                                                  // certenrolls_skip
} CERT_ALT_NAME_ENTRY, *PCERT_ALT_NAME_ENTRY;
// certenrolls_end

// certenrolld_begin -- CERT_ALT_NAME_*
#define CERT_ALT_NAME_OTHER_NAME         1
#define CERT_ALT_NAME_RFC822_NAME        2
#define CERT_ALT_NAME_DNS_NAME           3
#define CERT_ALT_NAME_X400_ADDRESS       4
#define CERT_ALT_NAME_DIRECTORY_NAME     5
#define CERT_ALT_NAME_EDI_PARTY_NAME     6
#define CERT_ALT_NAME_URL                7
#define CERT_ALT_NAME_IP_ADDRESS         8
#define CERT_ALT_NAME_REGISTERED_ID      9
// certenrolld_end

// certenrolls_begin -- CERT_ALT_NAME_INFO
typedef struct _CERT_ALT_NAME_INFO {
    DWORD                   cAltEntry;
    PCERT_ALT_NAME_ENTRY    rgAltEntry;
} CERT_ALT_NAME_INFO, *PCERT_ALT_NAME_INFO;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Alternate name IA5 Error Location Definitions for
//  CRYPT_E_INVALID_IA5_STRING.
//
//  Error location is returned in *pcbEncoded by
//  CryptEncodeObject(X509_ALTERNATE_NAME)
//
//  Error location consists of:
//    ENTRY_INDEX   - 8 bits << 16
//    VALUE_INDEX   - 16 bits (unicode character index)
//--------------------------------------------------------------------------
#define CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK  0xFF
#define CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT 16
#define CERT_ALT_NAME_VALUE_ERR_INDEX_MASK  0x0000FFFF
#define CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT 0

#define GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(X)   \
    ((X >> CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT) & \
    CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK)
#define GET_CERT_ALT_NAME_VALUE_ERR_INDEX(X) \
    (X & CERT_ALT_NAME_VALUE_ERR_INDEX_MASK)


//+-------------------------------------------------------------------------
//  X509_BASIC_CONSTRAINTS
//  szOID_BASIC_CONSTRAINTS
//
//  pvStructInfo points to following CERT_BASIC_CONSTRAINTS_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_BASIC_CONSTRAINTS_INFO {
    CRYPT_BIT_BLOB          SubjectType;
    BOOL                    fPathLenConstraint;
    DWORD                   dwPathLenConstraint;
    DWORD                   cSubtreesConstraint;
    CERT_NAME_BLOB          *rgSubtreesConstraint;
} CERT_BASIC_CONSTRAINTS_INFO, *PCERT_BASIC_CONSTRAINTS_INFO;

#define CERT_CA_SUBJECT_FLAG         0x80
#define CERT_END_ENTITY_SUBJECT_FLAG 0x40

//+-------------------------------------------------------------------------
//  X509_BASIC_CONSTRAINTS2
//  szOID_BASIC_CONSTRAINTS2
//
//  pvStructInfo points to following CERT_BASIC_CONSTRAINTS2_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_BASIC_CONSTRAINTS2_INFO {
    BOOL                    fCA;
    BOOL                    fPathLenConstraint;
    DWORD                   dwPathLenConstraint;
} CERT_BASIC_CONSTRAINTS2_INFO, *PCERT_BASIC_CONSTRAINTS2_INFO;

//+-------------------------------------------------------------------------
//  X509_KEY_USAGE
//  szOID_KEY_USAGE
//
//  pvStructInfo points to a CRYPT_BIT_BLOB. Has same bit definitions as
//  CERT_KEY_ATTRIBUTES_INFO's IntendedKeyUsage.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CERT_POLICIES
//  szOID_CERT_POLICIES
//  szOID_CERT_POLICIES_95   NOTE--Only allowed for decoding!!!
//
//  pvStructInfo points to following CERT_POLICIES_INFO.
//
//  NOTE: when decoding using szOID_CERT_POLICIES_95 the pszPolicyIdentifier
//        may contain an empty string
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_POLICY_QUALIFIER_INFO
typedef struct _CERT_POLICY_QUALIFIER_INFO {
    LPSTR                       pszPolicyQualifierId;   // pszObjId
    CRYPT_OBJID_BLOB            Qualifier;              // optional
} CERT_POLICY_QUALIFIER_INFO, *PCERT_POLICY_QUALIFIER_INFO;

typedef struct _CERT_POLICY_INFO {
    LPSTR                       pszPolicyIdentifier;    // pszObjId
    DWORD                       cPolicyQualifier;       // optional
    CERT_POLICY_QUALIFIER_INFO  *rgPolicyQualifier;
} CERT_POLICY_INFO, *PCERT_POLICY_INFO;

typedef struct _CERT_POLICIES_INFO {
    DWORD                       cPolicyInfo;
    CERT_POLICY_INFO            *rgPolicyInfo;
} CERT_POLICIES_INFO, *PCERT_POLICIES_INFO;
// certenrolls_end

//+-------------------------------------------------------------------------
//  X509_PKIX_POLICY_QUALIFIER_USERNOTICE
//  szOID_PKIX_POLICY_QUALIFIER_USERNOTICE
//
//  pvStructInfo points to following CERT_POLICY_QUALIFIER_USER_NOTICE.
//
//--------------------------------------------------------------------------
typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
    LPSTR   pszOrganization;
    DWORD   cNoticeNumbers;
    int     *rgNoticeNumbers;
} CERT_POLICY_QUALIFIER_NOTICE_REFERENCE, *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE;

typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE {
    CERT_POLICY_QUALIFIER_NOTICE_REFERENCE  *pNoticeReference;  // optional
    LPWSTR                                  pszDisplayText;     // optional
} CERT_POLICY_QUALIFIER_USER_NOTICE, *PCERT_POLICY_QUALIFIER_USER_NOTICE;

//+-------------------------------------------------------------------------
//  szOID_CERT_POLICIES_95_QUALIFIER1 - Decode Only!!!!
//
//  pvStructInfo points to following CERT_POLICY95_QUALIFIER1.
//
//--------------------------------------------------------------------------
typedef struct _CPS_URLS {
    LPWSTR                      pszURL;
    CRYPT_ALGORITHM_IDENTIFIER  *pAlgorithm; // optional
    CRYPT_DATA_BLOB             *pDigest;    // optional
} CPS_URLS, *PCPS_URLS;

typedef struct _CERT_POLICY95_QUALIFIER1 {
    LPWSTR      pszPracticesReference;      // optional
    LPSTR       pszNoticeIdentifier;        // optional
    LPSTR       pszNSINoticeIdentifier;     // optional
    DWORD       cCPSURLs;
    CPS_URLS    *rgCPSURLs;                 // optional
} CERT_POLICY95_QUALIFIER1, *PCERT_POLICY95_QUALIFIER1;

//+-------------------------------------------------------------------------
//  szOID_INHIBIT_ANY_POLICY data structure
//
//  pvStructInfo points to an int.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  X509_POLICY_MAPPINGS
//  szOID_POLICY_MAPPINGS
//  szOID_LEGACY_POLICY_MAPPINGS
//
//  pvStructInfo points to following CERT_POLICY_MAPPINGS_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_POLICY_MAPPING {
    LPSTR                       pszIssuerDomainPolicy;      // pszObjId
    LPSTR                       pszSubjectDomainPolicy;     // pszObjId
} CERT_POLICY_MAPPING, *PCERT_POLICY_MAPPING;

typedef struct _CERT_POLICY_MAPPINGS_INFO {
    DWORD                       cPolicyMapping;
    PCERT_POLICY_MAPPING        rgPolicyMapping;
} CERT_POLICY_MAPPINGS_INFO, *PCERT_POLICY_MAPPINGS_INFO;

//+-------------------------------------------------------------------------
//  X509_POLICY_CONSTRAINTS
//  szOID_POLICY_CONSTRAINTS
//
//  pvStructInfo points to following CERT_POLICY_CONSTRAINTS_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_POLICY_CONSTRAINTS_INFO {
    BOOL                        fRequireExplicitPolicy;
    DWORD                       dwRequireExplicitPolicySkipCerts;

    BOOL                        fInhibitPolicyMapping;
    DWORD                       dwInhibitPolicyMappingSkipCerts;
} CERT_POLICY_CONSTRAINTS_INFO, *PCERT_POLICY_CONSTRAINTS_INFO;

//+-------------------------------------------------------------------------
//  RSA_CSP_PUBLICKEYBLOB
//
//  pvStructInfo points to a PUBLICKEYSTRUC immediately followed by a
//  RSAPUBKEY and the modulus bytes.
//
//  CryptExportKey outputs the above StructInfo for a dwBlobType of
//  PUBLICKEYBLOB. CryptImportKey expects the above StructInfo when
//  importing a public key.
//
//  For dwCertEncodingType = X509_ASN_ENCODING, the RSA_CSP_PUBLICKEYBLOB is
//  encoded as a PKCS #1 RSAPublicKey consisting of a SEQUENCE of a
//  modulus INTEGER and a publicExponent INTEGER. The modulus is encoded
//  as being a unsigned integer. When decoded, if the modulus was encoded
//  as unsigned integer with a leading 0 byte, the 0 byte is removed before
//  converting to the CSP modulus bytes.
//
//  For decode, the aiKeyAlg field of PUBLICKEYSTRUC is always set to
//  CALG_RSA_KEYX.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CNG_RSA_PUBLIC_KEY_BLOB
//
//  pvStructInfo points to a BCRYPT_RSAKEY_BLOB immediately followed by the
//  exponent and the modulus bytes. Both the exponent and modulus are
//  big endian. The private key fields consisting of cbPrime1 and cbPrime2
//  are set to zero.
//
//  For dwCertEncodingType = X509_ASN_ENCODING, the CNG_RSA_PUBLIC_KEY_BLOB is
//  encoded as a PKCS #1 RSAPublicKey consisting of a SEQUENCE of a
//  modulus HUGEINTEGER and a publicExponent HUGEINTEGER.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_KEYGEN_REQUEST_TO_BE_SIGNED
//
//  pvStructInfo points to CERT_KEYGEN_REQUEST_INFO.
//
//  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
//  signature (output of a X509_CERT CryptEncodeObject()).
//
//  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_ATTRIBUTE data structure
//
//  pvStructInfo points to a CRYPT_ATTRIBUTE.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_ATTRIBUTES data structure
//
//  pvStructInfo points to a CRYPT_ATTRIBUTES.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_CONTENT_INFO_SEQUENCE_OF_ANY data structure
//
//  pvStructInfo points to following CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY.
//
//  For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure wrapping
//  a sequence of ANY. The value of the contentType field is pszObjId,
//  while the content field is the following structure:
//      SequenceOfAny ::= SEQUENCE OF ANY
//
//  The CRYPT_DER_BLOBs point to the already encoded ANY content.
//--------------------------------------------------------------------------
typedef struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
    LPSTR               pszObjId;
    DWORD               cValue;
    PCRYPT_DER_BLOB     rgValue;
} CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY, *PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;

//+-------------------------------------------------------------------------
//  PKCS_CONTENT_INFO data structure
//
//  pvStructInfo points to following CRYPT_CONTENT_INFO.
//
//  For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure.
//  The CRYPT_DER_BLOB points to the already encoded ANY content.
//--------------------------------------------------------------------------
typedef struct _CRYPT_CONTENT_INFO {
    LPSTR               pszObjId;
    CRYPT_DER_BLOB      Content;
} CRYPT_CONTENT_INFO, *PCRYPT_CONTENT_INFO;


//+-------------------------------------------------------------------------
//  X509_OCTET_STRING data structure
//
//  pvStructInfo points to a CRYPT_DATA_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_BITS data structure
//
//  pvStructInfo points to a CRYPT_BIT_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_BITS_WITHOUT_TRAILING_ZEROES data structure
//
//  pvStructInfo points to a CRYPT_BIT_BLOB.
//
//  The same as X509_BITS, except before encoding, the bit length is
//  decremented to exclude trailing zero bits.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_INTEGER data structure
//
//  pvStructInfo points to an int.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_MULTI_BYTE_INTEGER data structure
//
//  pvStructInfo points to a CRYPT_INTEGER_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_ENUMERATED data structure
//
//  pvStructInfo points to an int containing the enumerated value
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CHOICE_OF_TIME data structure
//
//  pvStructInfo points to a FILETIME.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_SEQUENCE_OF_ANY data structure
//
//  pvStructInfo points to following CRYPT_SEQUENCE_OF_ANY.
//
//  The CRYPT_DER_BLOBs point to the already encoded ANY content.
//--------------------------------------------------------------------------
typedef struct _CRYPT_SEQUENCE_OF_ANY {
    DWORD               cValue;
    PCRYPT_DER_BLOB     rgValue;
} CRYPT_SEQUENCE_OF_ANY, *PCRYPT_SEQUENCE_OF_ANY;


//+-------------------------------------------------------------------------
//  X509_AUTHORITY_KEY_ID2
//  szOID_AUTHORITY_KEY_IDENTIFIER2
//
//  pvStructInfo points to following CERT_AUTHORITY_KEY_ID2_INFO.
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_AUTHORITY_KEY_ID2)
//
//  See X509_ALTERNATE_NAME for error location defines.
//--------------------------------------------------------------------------
typedef struct _CERT_AUTHORITY_KEY_ID2_INFO {
    CRYPT_DATA_BLOB     KeyId;
    CERT_ALT_NAME_INFO  AuthorityCertIssuer;    // Optional, set cAltEntry
                                                // to 0 to omit.
    CRYPT_INTEGER_BLOB  AuthorityCertSerialNumber;
} CERT_AUTHORITY_KEY_ID2_INFO, *PCERT_AUTHORITY_KEY_ID2_INFO;

//+-------------------------------------------------------------------------
//  szOID_SUBJECT_KEY_IDENTIFIER
//
//  pvStructInfo points to a CRYPT_DATA_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_AUTHORITY_INFO_ACCESS
//  szOID_AUTHORITY_INFO_ACCESS
//
//  X509_SUBJECT_INFO_ACCESS
//  szOID_SUBJECT_INFO_ACCESS
//
//  pvStructInfo points to following CERT_AUTHORITY_INFO_ACCESS.
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_AUTHORITY_INFO_ACCESS)
//
//  Error location consists of:
//    ENTRY_INDEX   - 8 bits << 16
//    VALUE_INDEX   - 16 bits (unicode character index)
//
//  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
//  defines.
//
//  Note, the szOID_SUBJECT_INFO_ACCESS extension has the same ASN.1
//  encoding as the szOID_AUTHORITY_INFO_ACCESS extension.
//--------------------------------------------------------------------------

typedef struct _CERT_ACCESS_DESCRIPTION {
    LPSTR               pszAccessMethod;        // pszObjId
    CERT_ALT_NAME_ENTRY AccessLocation;
} CERT_ACCESS_DESCRIPTION, *PCERT_ACCESS_DESCRIPTION;


typedef struct _CERT_AUTHORITY_INFO_ACCESS {
    DWORD                       cAccDescr;
    PCERT_ACCESS_DESCRIPTION    rgAccDescr;
} CERT_AUTHORITY_INFO_ACCESS, *PCERT_AUTHORITY_INFO_ACCESS,
  CERT_SUBJECT_INFO_ACCESS, *PCERT_SUBJECT_INFO_ACCESS;


//+-------------------------------------------------------------------------
//  PKIX Access Description: Access Method Object Identifiers
//--------------------------------------------------------------------------
#define szOID_PKIX_ACC_DESCR            "1.3.6.1.5.5.7.48"

// For szOID_AUTHORITY_INFO_ACCESS

#define szOID_PKIX_OCSP                 "1.3.6.1.5.5.7.48.1"
#define szOID_PKIX_CA_ISSUERS           "1.3.6.1.5.5.7.48.2"

// For szOID_SUBJECT_INFO_ACCESS
#define szOID_PKIX_TIME_STAMPING        "1.3.6.1.5.5.7.48.3"
#define szOID_PKIX_CA_REPOSITORY        "1.3.6.1.5.5.7.48.5"


//+-------------------------------------------------------------------------
//  X509_CRL_REASON_CODE
//  szOID_CRL_REASON_CODE
//
//  pvStructInfo points to an int which can be set to one of the following
//  enumerated values:
//--------------------------------------------------------------------------
#define CRL_REASON_UNSPECIFIED              0
#define CRL_REASON_KEY_COMPROMISE           1
#define CRL_REASON_CA_COMPROMISE            2
#define CRL_REASON_AFFILIATION_CHANGED      3
#define CRL_REASON_SUPERSEDED               4
#define CRL_REASON_CESSATION_OF_OPERATION   5
#define CRL_REASON_CERTIFICATE_HOLD         6
#define CRL_REASON_REMOVE_FROM_CRL          8


//+-------------------------------------------------------------------------
//  X509_CRL_DIST_POINTS
//  szOID_CRL_DIST_POINTS
//
//  pvStructInfo points to following CRL_DIST_POINTS_INFO.
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_CRL_DIST_POINTS)
//
//  Error location consists of:
//    CRL_ISSUER_BIT    - 1 bit  << 31 (0 for FullName, 1 for CRLIssuer)
//    POINT_INDEX       - 7 bits << 24
//    ENTRY_INDEX       - 8 bits << 16
//    VALUE_INDEX       - 16 bits (unicode character index)
//
//  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
//  defines.
//--------------------------------------------------------------------------
typedef struct _CRL_DIST_POINT_NAME {
    DWORD   dwDistPointNameChoice;
    union {
        CERT_ALT_NAME_INFO      FullName;       // 1
        // Not implemented      IssuerRDN;      // 2
    };
} CRL_DIST_POINT_NAME, *PCRL_DIST_POINT_NAME;

#define CRL_DIST_POINT_NO_NAME          0
#define CRL_DIST_POINT_FULL_NAME        1
#define CRL_DIST_POINT_ISSUER_RDN_NAME  2

typedef struct _CRL_DIST_POINT {
    CRL_DIST_POINT_NAME     DistPointName;      // OPTIONAL
    CRYPT_BIT_BLOB          ReasonFlags;        // OPTIONAL
    CERT_ALT_NAME_INFO      CRLIssuer;          // OPTIONAL
} CRL_DIST_POINT, *PCRL_DIST_POINT;

#define CRL_REASON_UNUSED_FLAG                  0x80
#define CRL_REASON_KEY_COMPROMISE_FLAG          0x40
#define CRL_REASON_CA_COMPROMISE_FLAG           0x20
#define CRL_REASON_AFFILIATION_CHANGED_FLAG     0x10
#define CRL_REASON_SUPERSEDED_FLAG              0x08
#define CRL_REASON_CESSATION_OF_OPERATION_FLAG  0x04
#define CRL_REASON_CERTIFICATE_HOLD_FLAG        0x02

typedef struct _CRL_DIST_POINTS_INFO {
    DWORD                   cDistPoint;
    PCRL_DIST_POINT         rgDistPoint;
} CRL_DIST_POINTS_INFO, *PCRL_DIST_POINTS_INFO;

#define CRL_DIST_POINT_ERR_INDEX_MASK          0x7F
#define CRL_DIST_POINT_ERR_INDEX_SHIFT         24
#define GET_CRL_DIST_POINT_ERR_INDEX(X)   \
    ((X >> CRL_DIST_POINT_ERR_INDEX_SHIFT) & CRL_DIST_POINT_ERR_INDEX_MASK)

#define CRL_DIST_POINT_ERR_CRL_ISSUER_BIT      0x80000000L
#define IS_CRL_DIST_POINT_ERR_CRL_ISSUER(X)   \
    (0 != (X & CRL_DIST_POINT_ERR_CRL_ISSUER_BIT))

//+-------------------------------------------------------------------------
//  X509_CROSS_CERT_DIST_POINTS
//  szOID_CROSS_CERT_DIST_POINTS
//
//  pvStructInfo points to following CROSS_CERT_DIST_POINTS_INFO.
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_CRL_DIST_POINTS)
//
//  Error location consists of:
//    POINT_INDEX       - 8 bits << 24
//    ENTRY_INDEX       - 8 bits << 16
//    VALUE_INDEX       - 16 bits (unicode character index)
//
//  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
//  defines.
//--------------------------------------------------------------------------
typedef struct _CROSS_CERT_DIST_POINTS_INFO {
    // Seconds between syncs. 0 implies use client default.
    DWORD                   dwSyncDeltaTime;

    DWORD                   cDistPoint;
    PCERT_ALT_NAME_INFO     rgDistPoint;
} CROSS_CERT_DIST_POINTS_INFO, *PCROSS_CERT_DIST_POINTS_INFO;

#define CROSS_CERT_DIST_POINT_ERR_INDEX_MASK   0xFF
#define CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT  24
#define GET_CROSS_CERT_DIST_POINT_ERR_INDEX(X)   \
    ((X >> CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT) & \
                CROSS_CERT_DIST_POINT_ERR_INDEX_MASK)



//+-------------------------------------------------------------------------
//  X509_ENHANCED_KEY_USAGE
//  szOID_ENHANCED_KEY_USAGE
//
//  pvStructInfo points to a CERT_ENHKEY_USAGE, CTL_USAGE.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_CERT_PAIR
//
//  pvStructInfo points to the following CERT_PAIR.
//--------------------------------------------------------------------------
typedef struct _CERT_PAIR {
   CERT_BLOB    Forward;        // OPTIONAL, if Forward.cbData == 0, omitted
   CERT_BLOB    Reverse;        // OPTIONAL, if Reverse.cbData == 0, omitted
} CERT_PAIR, *PCERT_PAIR;

//+-------------------------------------------------------------------------
//  szOID_CRL_NUMBER
//
//  pvStructInfo points to an int.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_DELTA_CRL_INDICATOR
//
//  pvStructInfo points to an int.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_ISSUING_DIST_POINT
//  X509_ISSUING_DIST_POINT
//
//  pvStructInfo points to the following CRL_ISSUING_DIST_POINT.
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_ISSUING_DIST_POINT)
//
//  Error location consists of:
//    ENTRY_INDEX       - 8 bits << 16
//    VALUE_INDEX       - 16 bits (unicode character index)
//
//  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
//  defines.
//--------------------------------------------------------------------------
typedef struct _CRL_ISSUING_DIST_POINT {
    CRL_DIST_POINT_NAME     DistPointName;              // OPTIONAL
    BOOL                    fOnlyContainsUserCerts;
    BOOL                    fOnlyContainsCACerts;
    CRYPT_BIT_BLOB          OnlySomeReasonFlags;        // OPTIONAL
    BOOL                    fIndirectCRL;
} CRL_ISSUING_DIST_POINT, *PCRL_ISSUING_DIST_POINT;

//+-------------------------------------------------------------------------
//  szOID_FRESHEST_CRL
//
//  pvStructInfo points to CRL_DIST_POINTS_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NAME_CONSTRAINTS
//  X509_NAME_CONSTRAINTS
//
//  pvStructInfo points to the following CERT_NAME_CONSTRAINTS_INFO
//
//  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
//  *pcbEncoded by CryptEncodeObject(X509_NAME_CONSTRAINTS)
//
//  Error location consists of:
//    EXCLUDED_SUBTREE_BIT  - 1 bit  << 31 (0 for permitted, 1 for excluded)
//    ENTRY_INDEX           - 8 bits << 16
//    VALUE_INDEX           - 16 bits (unicode character index)
//
//  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
//  defines.
//--------------------------------------------------------------------------
typedef struct _CERT_GENERAL_SUBTREE {
    CERT_ALT_NAME_ENTRY     Base;
    DWORD                   dwMinimum;
    BOOL                    fMaximum;
    DWORD                   dwMaximum;
} CERT_GENERAL_SUBTREE, *PCERT_GENERAL_SUBTREE;

typedef struct _CERT_NAME_CONSTRAINTS_INFO {
    DWORD                   cPermittedSubtree;
    PCERT_GENERAL_SUBTREE   rgPermittedSubtree;
    DWORD                   cExcludedSubtree;
    PCERT_GENERAL_SUBTREE   rgExcludedSubtree;
} CERT_NAME_CONSTRAINTS_INFO, *PCERT_NAME_CONSTRAINTS_INFO;

#define CERT_EXCLUDED_SUBTREE_BIT       0x80000000L
#define IS_CERT_EXCLUDED_SUBTREE(X)     \
    (0 != (X & CERT_EXCLUDED_SUBTREE_BIT))

//+-------------------------------------------------------------------------
//  szOID_NEXT_UPDATE_LOCATION
//
//  pvStructInfo points to a CERT_ALT_NAME_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_REMOVE_CERTIFICATE
//
//  pvStructInfo points to an int which can be set to one of the following
//   0 - Add certificate
//   1 - Remove certificate
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_CTL
//  szOID_CTL
//
//  pvStructInfo points to a CTL_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_SORTED_CTL
//
//  pvStructInfo points to a CTL_INFO.
//
//  Same as for PKCS_CTL, except, the CTL entries are sorted. The following
//  extension containing the sort information is inserted as the first
//  extension in the encoded CTL.
//
//  Only supported for Encoding. CRYPT_ENCODE_ALLOC_FLAG flag must be
//  set.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
// Sorted CTL TrustedSubjects extension
//
//  Array of little endian DWORDs:
//   [0] - Flags
//   [1] - Count of HashBucket entry offsets
//   [2] - Maximum HashBucket entry collision count
//   [3 ..] (Count + 1) HashBucket entry offsets
//
//  When this extension is present in the CTL,
//  the ASN.1 encoded sequence of TrustedSubjects are HashBucket ordered.
//
//  The entry offsets point to the start of the first encoded TrustedSubject
//  sequence for the HashBucket. The encoded TrustedSubjects for a HashBucket
//  continue until the encoded offset of the next HashBucket. A HashBucket has
//  no entries if HashBucket[N] == HashBucket[N + 1].
//
//  The HashBucket offsets are from the start of the ASN.1 encoded CTL_INFO.
//--------------------------------------------------------------------------
#define SORTED_CTL_EXT_FLAGS_OFFSET         (0*4)
#define SORTED_CTL_EXT_COUNT_OFFSET         (1*4)
#define SORTED_CTL_EXT_MAX_COLLISION_OFFSET (2*4)
#define SORTED_CTL_EXT_HASH_BUCKET_OFFSET   (3*4)

// If the SubjectIdentifiers are a MD5 or SHA1 hash, the following flag is
// set. When set, the first 4 bytes of the SubjectIdentifier are used as
// the dwhash. Otherwise, the SubjectIdentifier bytes are hashed into dwHash.
// In either case the HashBucket index = dwHash % cHashBucket.
#define SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG       0x1

//+-------------------------------------------------------------------------
//  X509_MULTI_BYTE_UINT
//
//  pvStructInfo points to a CRYPT_UINT_BLOB. Before encoding, inserts a
//  leading 0x00. After decoding, removes a leading 0x00.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_DSS_PUBLICKEY
//
//  pvStructInfo points to a CRYPT_UINT_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_DSS_PARAMETERS
//
//  pvStructInfo points to following CERT_DSS_PARAMETERS data structure.
//--------------------------------------------------------------------------
typedef struct _CERT_DSS_PARAMETERS {
    CRYPT_UINT_BLOB     p;
    CRYPT_UINT_BLOB     q;
    CRYPT_UINT_BLOB     g;
} CERT_DSS_PARAMETERS, *PCERT_DSS_PARAMETERS;

//+-------------------------------------------------------------------------
//  X509_DSS_SIGNATURE
//
//  pvStructInfo is a BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN]. The
//  bytes are ordered as output by the DSS CSP's CryptSignHash().
//--------------------------------------------------------------------------
#define CERT_DSS_R_LEN          20
#define CERT_DSS_S_LEN          20
#define CERT_DSS_SIGNATURE_LEN  (CERT_DSS_R_LEN + CERT_DSS_S_LEN)

// Sequence of 2 unsigned integers (the extra +1 is for a potential leading
// 0x00 to make the integer unsigned)
#define CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN  (2 + 2*(2 + 20 +1))

//+-------------------------------------------------------------------------
//  X509_DH_PUBLICKEY
//
//  pvStructInfo points to a CRYPT_UINT_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_DH_PARAMETERS
//
//  pvStructInfo points to following CERT_DH_PARAMETERS data structure.
//--------------------------------------------------------------------------
typedef struct _CERT_DH_PARAMETERS {
    CRYPT_UINT_BLOB     p;
    CRYPT_UINT_BLOB     g;
} CERT_DH_PARAMETERS, *PCERT_DH_PARAMETERS;

//+-------------------------------------------------------------------------
//  X509_ECC_SIGNATURE
//
//  pvStructInfo points to following CERT_ECC_SIGNATURE data structure.
//
//  Note, identical to the above except for the names of the fields. Same
//  underlying encode/decode functions are used.
//--------------------------------------------------------------------------
typedef struct _CERT_ECC_SIGNATURE {
    CRYPT_UINT_BLOB     r;
    CRYPT_UINT_BLOB     s;
} CERT_ECC_SIGNATURE, *PCERT_ECC_SIGNATURE;

//+-------------------------------------------------------------------------
//  X942_DH_PARAMETERS
//
//  pvStructInfo points to following CERT_X942_DH_PARAMETERS data structure.
//
//  If q.cbData == 0, then, the following fields are zero'ed.
//--------------------------------------------------------------------------
typedef struct _CERT_X942_DH_VALIDATION_PARAMS {
    CRYPT_BIT_BLOB      seed;
    DWORD               pgenCounter;
} CERT_X942_DH_VALIDATION_PARAMS, *PCERT_X942_DH_VALIDATION_PARAMS;

typedef struct _CERT_X942_DH_PARAMETERS {
    CRYPT_UINT_BLOB     p;          // odd prime, p = jq + 1
    CRYPT_UINT_BLOB     g;          // generator, g
    CRYPT_UINT_BLOB     q;          // factor of p - 1, OPTIONAL
    CRYPT_UINT_BLOB     j;          // subgroup factor, OPTIONAL
    PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;  // OPTIONAL
} CERT_X942_DH_PARAMETERS, *PCERT_X942_DH_PARAMETERS;

//+-------------------------------------------------------------------------
//  X942_OTHER_INFO
//
//  pvStructInfo points to following CRYPT_X942_OTHER_INFO data structure.
//
//  rgbCounter and rgbKeyLength are in Little Endian order.
//--------------------------------------------------------------------------
#define CRYPT_X942_COUNTER_BYTE_LENGTH      4
#define CRYPT_X942_KEY_LENGTH_BYTE_LENGTH   4
#define CRYPT_X942_PUB_INFO_BYTE_LENGTH     (512/8)
typedef struct _CRYPT_X942_OTHER_INFO {
    LPSTR               pszContentEncryptionObjId;
    BYTE                rgbCounter[CRYPT_X942_COUNTER_BYTE_LENGTH];
    BYTE                rgbKeyLength[CRYPT_X942_KEY_LENGTH_BYTE_LENGTH];
    CRYPT_DATA_BLOB     PubInfo;    // OPTIONAL
} CRYPT_X942_OTHER_INFO, *PCRYPT_X942_OTHER_INFO;


//+-------------------------------------------------------------------------
//  ECC_CMS_SHARED_INFO
//
//  pvStructInfo points to following ECC_CMS_SHARED_INFO data structure.
//
//  rgbSuppPubInfo is in Little Endian order.
//--------------------------------------------------------------------------
#define CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH   4
typedef struct _CRYPT_ECC_CMS_SHARED_INFO {
    CRYPT_ALGORITHM_IDENTIFIER  Algorithm;
    CRYPT_DATA_BLOB             EntityUInfo;    // OPTIONAL
    BYTE                        rgbSuppPubInfo[CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH];
} CRYPT_ECC_CMS_SHARED_INFO, *PCRYPT_ECC_CMS_SHARED_INFO;


//+-------------------------------------------------------------------------
//  PKCS_RC2_CBC_PARAMETERS
//  szOID_RSA_RC2CBC
//
//  pvStructInfo points to following CRYPT_RC2_CBC_PARAMETERS data structure.
//--------------------------------------------------------------------------
typedef struct _CRYPT_RC2_CBC_PARAMETERS {
    DWORD               dwVersion;
    BOOL                fIV;            // set if has following IV
    BYTE                rgbIV[8];
} CRYPT_RC2_CBC_PARAMETERS, *PCRYPT_RC2_CBC_PARAMETERS;

#define CRYPT_RC2_40BIT_VERSION     160
#define CRYPT_RC2_56BIT_VERSION     52
#define CRYPT_RC2_64BIT_VERSION     120
#define CRYPT_RC2_128BIT_VERSION    58


//+-------------------------------------------------------------------------
//  PKCS_SMIME_CAPABILITIES
//  szOID_RSA_SMIMECapabilities
//
//  pvStructInfo points to following CRYPT_SMIME_CAPABILITIES data structure.
//
//  Note, for CryptEncodeObject(X509_ASN_ENCODING), Parameters.cbData == 0
//  causes the encoded parameters to be omitted and not encoded as a NULL
//  (05 00) as is done when encoding a CRYPT_ALGORITHM_IDENTIFIER. This
//  is per the SMIME specification for encoding capabilities.
//--------------------------------------------------------------------------
// certenrolls_begin -- CRYPT_SMIME_CAPABILITY
typedef struct _CRYPT_SMIME_CAPABILITY {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Parameters;
} CRYPT_SMIME_CAPABILITY, *PCRYPT_SMIME_CAPABILITY;

typedef struct _CRYPT_SMIME_CAPABILITIES {
    DWORD                   cCapability;
    PCRYPT_SMIME_CAPABILITY rgCapability;
} CRYPT_SMIME_CAPABILITIES, *PCRYPT_SMIME_CAPABILITIES;
// certenrolls_end



//+-------------------------------------------------------------------------
//  Qualified Certificate Statements Extension Data Structures
//
//  X509_QC_STATEMENTS_EXT
//  szOID_QC_STATEMENTS_EXT
//
//  pvStructInfo points to following CERT_QC_STATEMENTS_EXT_INFO
//  data structure.
//
//  Note, identical to the above except for the names of the fields. Same
//  underlying encode/decode functions are used.
//--------------------------------------------------------------------------
typedef struct _CERT_QC_STATEMENT {
    LPSTR               pszStatementId;     // pszObjId
    CRYPT_OBJID_BLOB    StatementInfo;      // OPTIONAL
} CERT_QC_STATEMENT, *PCERT_QC_STATEMENT;

typedef struct _CERT_QC_STATEMENTS_EXT_INFO {
    DWORD                   cStatement;
    PCERT_QC_STATEMENT      rgStatement;
} CERT_QC_STATEMENTS_EXT_INFO, *PCERT_QC_STATEMENTS_EXT_INFO;


// QC Statment Ids

// European Union
#define szOID_QC_EU_COMPLIANCE          "0.4.0.1862.1.1"
// Secure Signature Creation Device
#define szOID_QC_SSCD                   "0.4.0.1862.1.4"

//+-------------------------------------------------------------------------
//  X509_OBJECT_IDENTIFIER
//  szOID_ECC_PUBLIC_KEY
//
//  pvStructInfo points to a LPSTR of the dot representation.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  X509_ALGORITHM_IDENTIFIER
//  szOID_ECDSA_SPECIFIED
//
//  pvStructInfo points to a CRYPT_ALGORITHM_IDENTIFIER.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  PKCS_RSA_SSA_PSS_PARAMETERS
//  szOID_RSA_SSA_PSS
//
//  pvStructInfo points to the following CRYPT_RSA_SSA_PSS_PARAMETERS
//  data structure.
//
//  For encoding uses the following defaults if the corresponding field
//  is set to NULL or 0:
//      HashAlgorithm.pszObjId : szOID_OIWSEC_sha1
//      MaskGenAlgorithm.pszObjId : szOID_RSA_MGF1
//      MaskGenAlgorithm.HashAlgorithm.pszObjId : HashAlgorithm.pszObjId
//      dwSaltLength: cbHash
//      dwTrailerField : PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC
//
//  Normally for encoding, only the HashAlgorithm.pszObjId field will
//  need to be set.
//
//  For decoding, all of fields are explicitly set.
//--------------------------------------------------------------------------
typedef struct _CRYPT_MASK_GEN_ALGORITHM {
    LPSTR                       pszObjId;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
} CRYPT_MASK_GEN_ALGORITHM, *PCRYPT_MASK_GEN_ALGORITHM;

typedef struct _CRYPT_RSA_SSA_PSS_PARAMETERS {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_MASK_GEN_ALGORITHM    MaskGenAlgorithm;
    DWORD                       dwSaltLength;
    DWORD                       dwTrailerField;
} CRYPT_RSA_SSA_PSS_PARAMETERS, *PCRYPT_RSA_SSA_PSS_PARAMETERS;

#define PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC       1

//+-------------------------------------------------------------------------
//  PKCS_RSAES_OAEP_PARAMETERS
//  szOID_RSAES_OAEP
//
//  pvStructInfo points to the following CRYPT_RSAES_OAEP_PARAMETERS
//  data structure.
//
//  For encoding uses the following defaults if the corresponding field
//  is set to NULL or 0:
//      HashAlgorithm.pszObjId : szOID_OIWSEC_sha1
//      MaskGenAlgorithm.pszObjId : szOID_RSA_MGF1
//      MaskGenAlgorithm.HashAlgorithm.pszObjId : HashAlgorithm.pszObjId
//      PSourceAlgorithm.pszObjId : szOID_RSA_PSPECIFIED
//      PSourceAlgorithm.EncodingParameters.cbData : 0
//      PSourceAlgorithm.EncodingParameters.pbData : NULL
//
//  Normally for encoding, only the HashAlgorithm.pszObjId field will
//  need to be set.
//
//  For decoding, all of fields are explicitly set.
//--------------------------------------------------------------------------
typedef struct _CRYPT_PSOURCE_ALGORITHM {
    LPSTR                       pszObjId;
    CRYPT_DATA_BLOB             EncodingParameters;
} CRYPT_PSOURCE_ALGORITHM, *PCRYPT_PSOURCE_ALGORITHM;

typedef struct _CRYPT_RSAES_OAEP_PARAMETERS {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_MASK_GEN_ALGORITHM    MaskGenAlgorithm;
    CRYPT_PSOURCE_ALGORITHM     PSourceAlgorithm;
} CRYPT_RSAES_OAEP_PARAMETERS, *PCRYPT_RSAES_OAEP_PARAMETERS;


//+-------------------------------------------------------------------------
//  PKCS7_SIGNER_INFO
//
//  pvStructInfo points to CMSG_SIGNER_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMS_SIGNER_INFO
//
//  pvStructInfo points to CMSG_CMS_SIGNER_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Verisign Certificate Extension Object Identifiers
//--------------------------------------------------------------------------

// Octet String containing Boolean
#define szOID_VERISIGN_PRIVATE_6_9       "2.16.840.1.113733.1.6.9"

// Octet String containing IA5 string: lower case 32 char hex string
#define szOID_VERISIGN_ONSITE_JURISDICTION_HASH "2.16.840.1.113733.1.6.11"

// Octet String containing Bit string
#define szOID_VERISIGN_BITSTRING_6_13    "2.16.840.1.113733.1.6.13"

// EKU
#define szOID_VERISIGN_ISS_STRONG_CRYPTO "2.16.840.1.113733.1.8.1"


//+-------------------------------------------------------------------------
//  Netscape Certificate Extension Object Identifiers
//--------------------------------------------------------------------------
#define szOID_NETSCAPE                  "2.16.840.1.113730"
#define szOID_NETSCAPE_CERT_EXTENSION   "2.16.840.1.113730.1"
#define szOID_NETSCAPE_CERT_TYPE        "2.16.840.1.113730.1.1"
#define szOID_NETSCAPE_BASE_URL         "2.16.840.1.113730.1.2"
#define szOID_NETSCAPE_REVOCATION_URL   "2.16.840.1.113730.1.3"
#define szOID_NETSCAPE_CA_REVOCATION_URL "2.16.840.1.113730.1.4"
#define szOID_NETSCAPE_CERT_RENEWAL_URL "2.16.840.1.113730.1.7"
#define szOID_NETSCAPE_CA_POLICY_URL    "2.16.840.1.113730.1.8"
#define szOID_NETSCAPE_SSL_SERVER_NAME  "2.16.840.1.113730.1.12"
#define szOID_NETSCAPE_COMMENT          "2.16.840.1.113730.1.13"

//+-------------------------------------------------------------------------
//  Netscape Certificate Data Type Object Identifiers
//--------------------------------------------------------------------------
#define szOID_NETSCAPE_DATA_TYPE        "2.16.840.1.113730.2"
#define szOID_NETSCAPE_CERT_SEQUENCE    "2.16.840.1.113730.2.5"


//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_CERT_TYPE extension
//
//  Its value is a bit string. CryptDecodeObject/CryptEncodeObject using
//  X509_BITS or X509_BITS_WITHOUT_TRAILING_ZEROES.
//
//  The following bits are defined:
//--------------------------------------------------------------------------
#define NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE  0x80
#define NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE  0x40
#define NETSCAPE_SMIME_CERT_TYPE            0x20
#define NETSCAPE_SIGN_CERT_TYPE             0x10
#define NETSCAPE_SSL_CA_CERT_TYPE           0x04
#define NETSCAPE_SMIME_CA_CERT_TYPE         0x02
#define NETSCAPE_SIGN_CA_CERT_TYPE          0x01

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_BASE_URL extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  When present this string is added to the beginning of all relative URLs
//  in the certificate.  This extension can be considered an optimization
//  to reduce the size of the URL extensions.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_REVOCATION_URL extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a relative or absolute URL that can be used to check the
//  revocation status of a certificate. The revocation check will be
//  performed as an HTTP GET method using a url that is the concatenation of
//  revocation-url and certificate-serial-number.
//  Where the certificate-serial-number is encoded as a string of
//  ascii hexadecimal digits. For example, if the netscape-base-url is
//  https://www.certs-r-us.com/, the netscape-revocation-url is
//  cgi-bin/check-rev.cgi?, and the certificate serial number is 173420,
//  the resulting URL would be:
//  https://www.certs-r-us.com/cgi-bin/check-rev.cgi?02a56c
//
//  The server should return a document with a Content-Type of
//  application/x-netscape-revocation.  The document should contain
//  a single ascii digit, '1' if the certificate is not curently valid,
//  and '0' if it is curently valid.
//
//  Note: for all of the URLs that include the certificate serial number,
//  the serial number will be encoded as a string which consists of an even
//  number of hexadecimal digits.  If the number of significant digits is odd,
//  the string will have a single leading zero to ensure an even number of
//  digits is generated.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_CA_REVOCATION_URL extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a relative or absolute URL that can be used to check the
//  revocation status of any certificates that are signed by the CA that
//  this certificate belongs to. This extension is only valid in CA
//  certificates.  The use of this extension is the same as the above
//  szOID_NETSCAPE_REVOCATION_URL extension.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_CERT_RENEWAL_URL extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a relative or absolute URL that points to a certificate renewal
//  form. The renewal form will be accessed with an HTTP GET method using a
//  url that is the concatenation of renewal-url and
//  certificate-serial-number. Where the certificate-serial-number is
//  encoded as a string of ascii hexadecimal digits. For example, if the
//  netscape-base-url is https://www.certs-r-us.com/, the
//  netscape-cert-renewal-url is cgi-bin/check-renew.cgi?, and the
//  certificate serial number is 173420, the resulting URL would be:
//  https://www.certs-r-us.com/cgi-bin/check-renew.cgi?02a56c
//  The document returned should be an HTML form that will allow the user
//  to request a renewal of their certificate.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_CA_POLICY_URL extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a relative or absolute URL that points to a web page that
//  describes the policies under which the certificate was issued.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_SSL_SERVER_NAME extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a "shell expression" that can be used to match the hostname of the
//  SSL server that is using this certificate.  It is recommended that if
//  the server's hostname does not match this pattern the user be notified
//  and given the option to terminate the SSL connection.  If this extension
//  is not present then the CommonName in the certificate subject's
//  distinguished name is used for the same purpose.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_COMMENT extension
//
//  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
//  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
//  dwValueType = CERT_RDN_IA5_STRING.
//
//  It is a comment that may be displayed to the user when the certificate
//  is viewed.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_NETSCAPE_CERT_SEQUENCE
//
//  Its value is a PKCS#7 ContentInfo structure wrapping a sequence of
//  certificates. The value of the contentType field is
//  szOID_NETSCAPE_CERT_SEQUENCE, while the content field is the following
//  structure:
//      CertificateSequence ::= SEQUENCE OF Certificate.
//
//  CryptDecodeObject/CryptEncodeObject using
//  PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, where,
//  pszObjId = szOID_NETSCAPE_CERT_SEQUENCE and the CRYPT_DER_BLOBs point
//  to encoded X509 certificates.
//--------------------------------------------------------------------------

//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Data Structures
//==========================================================================

// Content Type (request)
#define szOID_CT_PKI_DATA               "1.3.6.1.5.5.7.12.2"

// Content Type (response)
#define szOID_CT_PKI_RESPONSE           "1.3.6.1.5.5.7.12.3"

// Signature value that only contains the hash octets. The parameters for
// this algorithm must be present and must be encoded as NULL.
#define szOID_PKIX_NO_SIGNATURE         "1.3.6.1.5.5.7.6.2"

#define szOID_CMC                       "1.3.6.1.5.5.7.7"
#define szOID_CMC_STATUS_INFO           "1.3.6.1.5.5.7.7.1"
#define szOID_CMC_IDENTIFICATION        "1.3.6.1.5.5.7.7.2"
#define szOID_CMC_IDENTITY_PROOF        "1.3.6.1.5.5.7.7.3"
#define szOID_CMC_DATA_RETURN           "1.3.6.1.5.5.7.7.4"

// Transaction Id (integer)
#define szOID_CMC_TRANSACTION_ID        "1.3.6.1.5.5.7.7.5"

// Sender Nonce (octet string)
#define szOID_CMC_SENDER_NONCE          "1.3.6.1.5.5.7.7.6"

// Recipient Nonce (octet string)
#define szOID_CMC_RECIPIENT_NONCE       "1.3.6.1.5.5.7.7.7"

#define szOID_CMC_ADD_EXTENSIONS        "1.3.6.1.5.5.7.7.8"
#define szOID_CMC_ENCRYPTED_POP         "1.3.6.1.5.5.7.7.9"
#define szOID_CMC_DECRYPTED_POP         "1.3.6.1.5.5.7.7.10"
#define szOID_CMC_LRA_POP_WITNESS       "1.3.6.1.5.5.7.7.11"

// Issuer Name + Serial
#define szOID_CMC_GET_CERT              "1.3.6.1.5.5.7.7.15"

// Issuer Name [+ CRL Name] + Time [+ Reasons]
#define szOID_CMC_GET_CRL               "1.3.6.1.5.5.7.7.16"

// Issuer Name + Serial [+ Reason] [+ Effective Time] [+ Secret] [+ Comment]
#define szOID_CMC_REVOKE_REQUEST        "1.3.6.1.5.5.7.7.17"

// (octet string) URL-style parameter list (IA5?)
#define szOID_CMC_REG_INFO              "1.3.6.1.5.5.7.7.18"

#define szOID_CMC_RESPONSE_INFO         "1.3.6.1.5.5.7.7.19"

// (octet string)
#define szOID_CMC_QUERY_PENDING         "1.3.6.1.5.5.7.7.21"
#define szOID_CMC_ID_POP_LINK_RANDOM    "1.3.6.1.5.5.7.7.22"
#define szOID_CMC_ID_POP_LINK_WITNESS   "1.3.6.1.5.5.7.7.23"

// optional Name + Integer
#define szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE "1.3.6.1.5.5.7.7.24"

#define szOID_CMC_ADD_ATTRIBUTES        "1.3.6.1.4.1.311.10.10.1"

//+-------------------------------------------------------------------------
//  CMC_DATA
//  CMC_RESPONSE
//
//  Certificate Management Messages over CMS (CMC) PKIData and Response
//  messages.
//
//  For CMC_DATA, pvStructInfo points to a CMC_DATA_INFO.
//  CMC_DATA_INFO contains optional arrays of tagged attributes, requests,
//  content info and/or arbitrary other messages.
//
//  For CMC_RESPONSE, pvStructInfo points to a CMC_RESPONSE_INFO.
//  CMC_RESPONSE_INFO is the same as CMC_DATA_INFO without the tagged
//  requests.
//--------------------------------------------------------------------------
typedef struct _CMC_TAGGED_ATTRIBUTE {
    DWORD               dwBodyPartID;
    CRYPT_ATTRIBUTE     Attribute;
} CMC_TAGGED_ATTRIBUTE, *PCMC_TAGGED_ATTRIBUTE;

typedef struct _CMC_TAGGED_CERT_REQUEST {
    DWORD               dwBodyPartID;
    CRYPT_DER_BLOB      SignedCertRequest;
} CMC_TAGGED_CERT_REQUEST, *PCMC_TAGGED_CERT_REQUEST;

typedef struct _CMC_TAGGED_REQUEST {
    DWORD               dwTaggedRequestChoice;
    union {
        // CMC_TAGGED_CERT_REQUEST_CHOICE
        PCMC_TAGGED_CERT_REQUEST   pTaggedCertRequest;
    };
} CMC_TAGGED_REQUEST, *PCMC_TAGGED_REQUEST;

#define CMC_TAGGED_CERT_REQUEST_CHOICE      1

typedef struct _CMC_TAGGED_CONTENT_INFO {
    DWORD               dwBodyPartID;
    CRYPT_DER_BLOB      EncodedContentInfo;
} CMC_TAGGED_CONTENT_INFO, *PCMC_TAGGED_CONTENT_INFO;

typedef struct _CMC_TAGGED_OTHER_MSG {
    DWORD               dwBodyPartID;
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Value;
} CMC_TAGGED_OTHER_MSG, *PCMC_TAGGED_OTHER_MSG;


// All the tagged arrays are optional
typedef struct _CMC_DATA_INFO {
    DWORD                       cTaggedAttribute;
    PCMC_TAGGED_ATTRIBUTE       rgTaggedAttribute;
    DWORD                       cTaggedRequest;
    PCMC_TAGGED_REQUEST         rgTaggedRequest;
    DWORD                       cTaggedContentInfo;
    PCMC_TAGGED_CONTENT_INFO    rgTaggedContentInfo;
    DWORD                       cTaggedOtherMsg;
    PCMC_TAGGED_OTHER_MSG       rgTaggedOtherMsg;
} CMC_DATA_INFO, *PCMC_DATA_INFO;


// All the tagged arrays are optional
typedef struct _CMC_RESPONSE_INFO {
    DWORD                       cTaggedAttribute;
    PCMC_TAGGED_ATTRIBUTE       rgTaggedAttribute;
    DWORD                       cTaggedContentInfo;
    PCMC_TAGGED_CONTENT_INFO    rgTaggedContentInfo;
    DWORD                       cTaggedOtherMsg;
    PCMC_TAGGED_OTHER_MSG       rgTaggedOtherMsg;
} CMC_RESPONSE_INFO, *PCMC_RESPONSE_INFO;


//+-------------------------------------------------------------------------
//  CMC_STATUS
//
//  Certificate Management Messages over CMS (CMC) Status.
//
//  pvStructInfo points to a CMC_STATUS_INFO.
//--------------------------------------------------------------------------
typedef struct _CMC_PEND_INFO {
    CRYPT_DATA_BLOB             PendToken;
    FILETIME                    PendTime;
} CMC_PEND_INFO, *PCMC_PEND_INFO;

typedef struct _CMC_STATUS_INFO {
    DWORD                       dwStatus;
    DWORD                       cBodyList;
    DWORD                       *rgdwBodyList;
    LPWSTR                      pwszStatusString;   // OPTIONAL
    DWORD                       dwOtherInfoChoice;
    union  {
        // CMC_OTHER_INFO_NO_CHOICE
        //  none
        // CMC_OTHER_INFO_FAIL_CHOICE
        DWORD                       dwFailInfo;
        // CMC_OTHER_INFO_PEND_CHOICE
        PCMC_PEND_INFO              pPendInfo;
    };
} CMC_STATUS_INFO, *PCMC_STATUS_INFO;

#define CMC_OTHER_INFO_NO_CHOICE        0
#define CMC_OTHER_INFO_FAIL_CHOICE      1
#define CMC_OTHER_INFO_PEND_CHOICE      2

//
// dwStatus values
//

// Request was granted
#define CMC_STATUS_SUCCESS          0

// Request failed, more information elsewhere in the message
#define CMC_STATUS_FAILED           2

// The request body part has not yet been processed. Requester is responsible
// to poll back. May only be returned for certificate request operations.
#define CMC_STATUS_PENDING          3

// The requested operation is not supported
#define CMC_STATUS_NO_SUPPORT       4

// Confirmation using the idConfirmCertAcceptance control is required
// before use of certificate
#define CMC_STATUS_CONFIRM_REQUIRED 5


//
// dwFailInfo values
//

// Unrecognized or unsupported algorithm
#define CMC_FAIL_BAD_ALG            0

// Integrity check failed
#define CMC_FAIL_BAD_MESSAGE_CHECK  1

// Transaction not permitted or supported
#define CMC_FAIL_BAD_REQUEST        2

// Message time field was not sufficiently close to the system time
#define CMC_FAIL_BAD_TIME           3

// No certificate could be identified matching the provided criteria
#define CMC_FAIL_BAD_CERT_ID        4

// A requested X.509 extension is not supported by the recipient CA.
#define CMC_FAIL_UNSUPORTED_EXT     5

// Private key material must be supplied
#define CMC_FAIL_MUST_ARCHIVE_KEYS  6

// Identification Attribute failed to verify
#define CMC_FAIL_BAD_IDENTITY       7

// Server requires a POP proof before issuing certificate
#define CMC_FAIL_POP_REQUIRED       8

// POP processing failed
#define CMC_FAIL_POP_FAILED         9

// Server policy does not allow key re-use
#define CMC_FAIL_NO_KEY_REUSE       10

#define CMC_FAIL_INTERNAL_CA_ERROR  11

#define CMC_FAIL_TRY_LATER          12


//+-------------------------------------------------------------------------
//  CMC_ADD_EXTENSIONS
//
//  Certificate Management Messages over CMS (CMC) Add Extensions control
//  attribute.
//
//  pvStructInfo points to a CMC_ADD_EXTENSIONS_INFO.
//--------------------------------------------------------------------------
typedef struct _CMC_ADD_EXTENSIONS_INFO {
    DWORD                       dwCmcDataReference;
    DWORD                       cCertReference;
    DWORD                       *rgdwCertReference;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} CMC_ADD_EXTENSIONS_INFO, *PCMC_ADD_EXTENSIONS_INFO;


//+-------------------------------------------------------------------------
//  CMC_ADD_ATTRIBUTES
//
//  Certificate Management Messages over CMS (CMC) Add Attributes control
//  attribute.
//
//  pvStructInfo points to a CMC_ADD_ATTRIBUTES_INFO.
//--------------------------------------------------------------------------
typedef struct _CMC_ADD_ATTRIBUTES_INFO {
    DWORD                       dwCmcDataReference;
    DWORD                       cCertReference;
    DWORD                       *rgdwCertReference;
    DWORD                       cAttribute;
    PCRYPT_ATTRIBUTE            rgAttribute;
} CMC_ADD_ATTRIBUTES_INFO, *PCMC_ADD_ATTRIBUTES_INFO;


//+-------------------------------------------------------------------------
//  X509_CERTIFICATE_TEMPLATE
//  szOID_CERTIFICATE_TEMPLATE
//
//  pvStructInfo points to following CERT_TEMPLATE_EXT data structure.
//
//--------------------------------------------------------------------------
typedef struct _CERT_TEMPLATE_EXT {
    LPSTR               pszObjId;
    DWORD               dwMajorVersion;
    BOOL                fMinorVersion;      // TRUE for a minor version
    DWORD               dwMinorVersion;
} CERT_TEMPLATE_EXT, *PCERT_TEMPLATE_EXT;


//+=========================================================================
//  Logotype Extension Data Structures
//
//  X509_LOGOTYPE_EXT
//  szOID_LOGOTYPE_EXT
//
//  pvStructInfo points to a CERT_LOGOTYPE_EXT_INFO.
//==========================================================================
typedef struct _CERT_HASHED_URL {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_HASH_BLOB             Hash;
    LPWSTR                      pwszUrl;    // Encoded as IA5, Optional for
                                            // biometric data
} CERT_HASHED_URL, *PCERT_HASHED_URL;

typedef struct _CERT_LOGOTYPE_DETAILS {
    LPWSTR                      pwszMimeType;   // Encoded as IA5
    DWORD                       cHashedUrl;
    PCERT_HASHED_URL            rgHashedUrl;
} CERT_LOGOTYPE_DETAILS, *PCERT_LOGOTYPE_DETAILS;

typedef struct _CERT_LOGOTYPE_REFERENCE {
    DWORD                       cHashedUrl;
    PCERT_HASHED_URL            rgHashedUrl;
} CERT_LOGOTYPE_REFERENCE, *PCERT_LOGOTYPE_REFERENCE;

typedef struct _CERT_LOGOTYPE_IMAGE_INFO {
    // CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE or
    // CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE
    DWORD                       dwLogotypeImageInfoChoice;

    DWORD                       dwFileSize;     // In octets
    DWORD                       dwXSize;        // Horizontal size in pixels
    DWORD                       dwYSize;        // Vertical size in pixels

    DWORD                       dwLogotypeImageResolutionChoice;
    union {
        // CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE
        // No resolution value

        // CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE
        DWORD                       dwNumBits;      // Resolution in bits

        // CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE
        DWORD                       dwTableSize;    // Number of color or grey tones
    };
    LPWSTR                      pwszLanguage;   // Optional. Encoded as IA5.
                                                // RFC 3066 Language Tag
} CERT_LOGOTYPE_IMAGE_INFO, *PCERT_LOGOTYPE_IMAGE_INFO;

#define CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE          1
#define CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE               2

#define CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE            0
#define CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE          1
#define CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE    2

typedef struct _CERT_LOGOTYPE_IMAGE {
    CERT_LOGOTYPE_DETAILS       LogotypeDetails;

    PCERT_LOGOTYPE_IMAGE_INFO   pLogotypeImageInfo; // Optional
} CERT_LOGOTYPE_IMAGE, *PCERT_LOGOTYPE_IMAGE;


typedef struct _CERT_LOGOTYPE_AUDIO_INFO {
    DWORD                       dwFileSize;     // In octets
    DWORD                       dwPlayTime;     // In milliseconds
    DWORD                       dwChannels;     // 1=mono, 2=stereo, 4=quad
    DWORD                       dwSampleRate;   // Optional. 0 => not present.
                                                // Samples per second
    LPWSTR                      pwszLanguage;   // Optional. Encoded as IA5.
                                                // RFC 3066 Language Tag
} CERT_LOGOTYPE_AUDIO_INFO, *PCERT_LOGOTYPE_AUDIO_INFO;

typedef struct _CERT_LOGOTYPE_AUDIO {
    CERT_LOGOTYPE_DETAILS       LogotypeDetails;

    PCERT_LOGOTYPE_AUDIO_INFO   pLogotypeAudioInfo; // Optional
} CERT_LOGOTYPE_AUDIO, *PCERT_LOGOTYPE_AUDIO;


typedef struct _CERT_LOGOTYPE_DATA {
    DWORD                       cLogotypeImage;
    PCERT_LOGOTYPE_IMAGE        rgLogotypeImage;

    DWORD                       cLogotypeAudio;
    PCERT_LOGOTYPE_AUDIO        rgLogotypeAudio;
} CERT_LOGOTYPE_DATA, *PCERT_LOGOTYPE_DATA;


typedef struct _CERT_LOGOTYPE_INFO {
    DWORD                       dwLogotypeInfoChoice;
    union {
        // CERT_LOGOTYPE_DIRECT_INFO_CHOICE
        PCERT_LOGOTYPE_DATA         pLogotypeDirectInfo;

        // CERT_LOGOTYPE_INDIRECT_INFO_CHOICE
        PCERT_LOGOTYPE_REFERENCE    pLogotypeIndirectInfo;
    };
} CERT_LOGOTYPE_INFO, *PCERT_LOGOTYPE_INFO;

#define CERT_LOGOTYPE_DIRECT_INFO_CHOICE    1
#define CERT_LOGOTYPE_INDIRECT_INFO_CHOICE  2

typedef struct _CERT_OTHER_LOGOTYPE_INFO {
    LPSTR                       pszObjId;
    CERT_LOGOTYPE_INFO          LogotypeInfo;
} CERT_OTHER_LOGOTYPE_INFO, *PCERT_OTHER_LOGOTYPE_INFO;

#define szOID_LOYALTY_OTHER_LOGOTYPE                "1.3.6.1.5.5.7.20.1"
#define szOID_BACKGROUND_OTHER_LOGOTYPE             "1.3.6.1.5.5.7.20.2"

typedef struct _CERT_LOGOTYPE_EXT_INFO {
    DWORD                       cCommunityLogo;
    PCERT_LOGOTYPE_INFO         rgCommunityLogo;
    PCERT_LOGOTYPE_INFO         pIssuerLogo;        // Optional
    PCERT_LOGOTYPE_INFO         pSubjectLogo;       // Optional
    DWORD                       cOtherLogo;
    PCERT_OTHER_LOGOTYPE_INFO   rgOtherLogo;
} CERT_LOGOTYPE_EXT_INFO, *PCERT_LOGOTYPE_EXT_INFO;


//+=========================================================================
//  Biometric Extension Data Structures
//
//  X509_BIOMETRIC_EXT
//  szOID_BIOMETRIC_EXT
//
//  pvStructInfo points to following CERT_BIOMETRIC_EXT_INFO data structure.
//==========================================================================

typedef struct _CERT_BIOMETRIC_DATA {
    DWORD                       dwTypeOfBiometricDataChoice;
    union {
        // CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE
        DWORD                       dwPredefined;

        // CERT_BIOMETRIC_OID_DATA_CHOICE
        LPSTR                       pszObjId;
    };

    CERT_HASHED_URL             HashedUrl;      // pwszUrl is Optional.
} CERT_BIOMETRIC_DATA, *PCERT_BIOMETRIC_DATA;

#define CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE   1
#define CERT_BIOMETRIC_OID_DATA_CHOICE          2

#define CERT_BIOMETRIC_PICTURE_TYPE             0
#define CERT_BIOMETRIC_SIGNATURE_TYPE           1


typedef struct _CERT_BIOMETRIC_EXT_INFO {
    DWORD                       cBiometricData;
    PCERT_BIOMETRIC_DATA        rgBiometricData;
} CERT_BIOMETRIC_EXT_INFO, *PCERT_BIOMETRIC_EXT_INFO;


//+=========================================================================
//  Online Certificate Status Protocol (OCSP) Data Structures
//==========================================================================

//+-------------------------------------------------------------------------
//  OCSP_SIGNED_REQUEST
//
//  OCSP signed request.
//
//  Note, in most instances, pOptionalSignatureInfo will be NULL indicating
//  no signature is present.
//--------------------------------------------------------------------------

typedef struct _OCSP_SIGNATURE_INFO {
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CRYPT_BIT_BLOB              Signature;
    DWORD                       cCertEncoded;
    PCERT_BLOB                  rgCertEncoded;
} OCSP_SIGNATURE_INFO, *POCSP_SIGNATURE_INFO;

typedef struct _OCSP_SIGNED_REQUEST_INFO {
    CRYPT_DER_BLOB              ToBeSigned;             // Encoded OCSP_REQUEST
    POCSP_SIGNATURE_INFO        pOptionalSignatureInfo; // NULL, no signature
} OCSP_SIGNED_REQUEST_INFO, *POCSP_SIGNED_REQUEST_INFO;

//+-------------------------------------------------------------------------
//  OCSP_REQUEST
//
//  ToBeSigned OCSP request.
//--------------------------------------------------------------------------

typedef struct _OCSP_CERT_ID {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;  // Normally SHA1
    CRYPT_HASH_BLOB             IssuerNameHash; // Hash of encoded name
    CRYPT_HASH_BLOB             IssuerKeyHash;  // Hash of PublicKey bits
    CRYPT_INTEGER_BLOB          SerialNumber;
} OCSP_CERT_ID, *POCSP_CERT_ID;

typedef struct _OCSP_REQUEST_ENTRY {
    OCSP_CERT_ID                CertId;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} OCSP_REQUEST_ENTRY, *POCSP_REQUEST_ENTRY;

typedef struct _OCSP_REQUEST_INFO {
    DWORD                       dwVersion;
    PCERT_ALT_NAME_ENTRY        pRequestorName;     // OPTIONAL
    DWORD                       cRequestEntry;
    POCSP_REQUEST_ENTRY         rgRequestEntry;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} OCSP_REQUEST_INFO, *POCSP_REQUEST_INFO;

#define OCSP_REQUEST_V1     0

//+-------------------------------------------------------------------------
//  OCSP_RESPONSE
//
//  OCSP outer, unsigned response wrapper.
//--------------------------------------------------------------------------
typedef struct _OCSP_RESPONSE_INFO {
    DWORD                       dwStatus;
    LPSTR                       pszObjId;   // OPTIONAL, may be NULL
    CRYPT_OBJID_BLOB            Value;      // OPTIONAL
} OCSP_RESPONSE_INFO, *POCSP_RESPONSE_INFO;

#define OCSP_SUCCESSFUL_RESPONSE            0
#define OCSP_MALFORMED_REQUEST_RESPONSE     1
#define OCSP_INTERNAL_ERROR_RESPONSE        2
#define OCSP_TRY_LATER_RESPONSE             3
// 4 is not used
#define OCSP_SIG_REQUIRED_RESPONSE          5
#define OCSP_UNAUTHORIZED_RESPONSE          6


#define szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE   "1.3.6.1.5.5.7.48.1.1"

//+-------------------------------------------------------------------------
//  OCSP_BASIC_SIGNED_RESPONSE
//  szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE
//
//  OCSP basic signed response.
//--------------------------------------------------------------------------
typedef struct _OCSP_BASIC_SIGNED_RESPONSE_INFO {
    CRYPT_DER_BLOB              ToBeSigned;     // Encoded OCSP_BASIC_RESPONSE
    OCSP_SIGNATURE_INFO         SignatureInfo;
} OCSP_BASIC_SIGNED_RESPONSE_INFO, *POCSP_BASIC_SIGNED_RESPONSE_INFO;

//+-------------------------------------------------------------------------
//  OCSP_BASIC_RESPONSE
//
//  ToBeSigned OCSP basic response.
//--------------------------------------------------------------------------

typedef struct _OCSP_BASIC_REVOKED_INFO {
    FILETIME                    RevocationDate;

    // See X509_CRL_REASON_CODE for list of reason codes
    DWORD                       dwCrlReasonCode;
} OCSP_BASIC_REVOKED_INFO, *POCSP_BASIC_REVOKED_INFO;

typedef struct _OCSP_BASIC_RESPONSE_ENTRY {
    OCSP_CERT_ID                CertId;
    DWORD                       dwCertStatus;
    union {
        // OCSP_BASIC_GOOD_CERT_STATUS
        // OCSP_BASIC_UNKNOWN_CERT_STATUS
        //  No additional information

        // OCSP_BASIC_REVOKED_CERT_STATUS
        POCSP_BASIC_REVOKED_INFO    pRevokedInfo;

    };
    FILETIME                    ThisUpdate;
    FILETIME                    NextUpdate; // Optional, zero filetime implies
                                            // never expires
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} OCSP_BASIC_RESPONSE_ENTRY, *POCSP_BASIC_RESPONSE_ENTRY;

#define OCSP_BASIC_GOOD_CERT_STATUS         0
#define OCSP_BASIC_REVOKED_CERT_STATUS      1
#define OCSP_BASIC_UNKNOWN_CERT_STATUS      2


typedef struct _OCSP_BASIC_RESPONSE_INFO {
    DWORD                       dwVersion;
    DWORD                       dwResponderIdChoice;
    union {
        // OCSP_BASIC_BY_NAME_RESPONDER_ID
        CERT_NAME_BLOB              ByNameResponderId;
        // OCSP_BASIC_BY_KEY_RESPONDER_ID
        CRYPT_HASH_BLOB              ByKeyResponderId;
    };
    FILETIME                    ProducedAt;
    DWORD                       cResponseEntry;
    POCSP_BASIC_RESPONSE_ENTRY  rgResponseEntry;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} OCSP_BASIC_RESPONSE_INFO, *POCSP_BASIC_RESPONSE_INFO;

#define OCSP_BASIC_RESPONSE_V1  0

#define OCSP_BASIC_BY_NAME_RESPONDER_ID     1
#define OCSP_BASIC_BY_KEY_RESPONDER_ID      2


//+=========================================================================
//  Object IDentifier (OID) Installable Functions:  Data Structures and APIs
//==========================================================================

typedef void *HCRYPTOIDFUNCSET;
typedef void *HCRYPTOIDFUNCADDR;

// Predefined OID Function Names
#define CRYPT_OID_ENCODE_OBJECT_FUNC        "CryptDllEncodeObject"
#define CRYPT_OID_DECODE_OBJECT_FUNC        "CryptDllDecodeObject"
#define CRYPT_OID_ENCODE_OBJECT_EX_FUNC     "CryptDllEncodeObjectEx"
#define CRYPT_OID_DECODE_OBJECT_EX_FUNC     "CryptDllDecodeObjectEx"
#define CRYPT_OID_CREATE_COM_OBJECT_FUNC    "CryptDllCreateCOMObject"
#define CRYPT_OID_VERIFY_REVOCATION_FUNC    "CertDllVerifyRevocation"
#define CRYPT_OID_VERIFY_CTL_USAGE_FUNC     "CertDllVerifyCTLUsage"
#define CRYPT_OID_FORMAT_OBJECT_FUNC        "CryptDllFormatObject"
#define CRYPT_OID_FIND_OID_INFO_FUNC        "CryptDllFindOIDInfo"
#define CRYPT_OID_FIND_LOCALIZED_NAME_FUNC  "CryptDllFindLocalizedName"


// CryptDllEncodeObject has same function signature as CryptEncodeObject.

// CryptDllDecodeObject has same function signature as CryptDecodeObject.

// CryptDllEncodeObjectEx has same function signature as CryptEncodeObjectEx.
// The Ex version MUST support the CRYPT_ENCODE_ALLOC_FLAG option.
//
// If an Ex function isn't installed or registered, then, attempts to find
// a non-EX version. If the ALLOC flag is set, then, CryptEncodeObjectEx,
// does the allocation and calls the non-EX version twice.

// CryptDllDecodeObjectEx has same function signature as CryptDecodeObjectEx.
// The Ex version MUST support the CRYPT_DECODE_ALLOC_FLAG option.
//
// If an Ex function isn't installed or registered, then, attempts to find
// a non-EX version. If the ALLOC flag is set, then, CryptDecodeObjectEx,
// does the allocation and calls the non-EX version twice.

// CryptDllCreateCOMObject has the following signature:
//      BOOL WINAPI CryptDllCreateCOMObject(
//          __in DWORD dwEncodingType,
//          __in LPCSTR pszOID,
//          __In PCRYPT_DATA_BLOB pEncodedContent,
//          __in DWORD dwFlags,
//          __in REFIID riid,
//          __deref_out void **ppvObj);

// CertDllVerifyRevocation has the same signature as CertVerifyRevocation
//  (See CertVerifyRevocation for details on when called)

// CertDllVerifyCTLUsage has the same signature as CertVerifyCTLUsage

// CryptDllFindOIDInfo currently is only used to store values used by
// CryptFindOIDInfo. See CryptFindOIDInfo() for more details.

// CryptDllFindLocalizedName is only used to store localized string
// values used by CryptFindLocalizedName. See CryptFindLocalizedName() for
// more details.

//  Example of a complete OID Function Registry Name:
//    HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\OID
//      Encoding Type 1\CryptDllEncodeObject\1.2.3
//
//  The key's L"Dll" value contains the name of the Dll.
//  The key's L"FuncName" value overrides the default function name
#define CRYPT_OID_REGPATH "Software\\Microsoft\\Cryptography\\OID"
#define CRYPT_OID_REG_ENCODING_TYPE_PREFIX  "EncodingType "
#define CRYPT_OID_REG_DLL_VALUE_NAME        L"Dll"
#define CRYPT_OID_REG_FUNC_NAME_VALUE_NAME  L"FuncName"
#define CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A "FuncName"

// CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG can be set in the key's L"CryptFlags"
// value to register the functions before the installed functions.
//
// CryptSetOIDFunctionValue must be called to set this value. L"CryptFlags"
// must be set using a dwValueType of REG_DWORD.
#define CRYPT_OID_REG_FLAGS_VALUE_NAME      L"CryptFlags"

// OID used for Default OID functions
#define CRYPT_DEFAULT_OID                   "DEFAULT"

typedef struct _CRYPT_OID_FUNC_ENTRY {
    LPCSTR  pszOID;
    void    *pvFuncAddr;
} CRYPT_OID_FUNC_ENTRY, *PCRYPT_OID_FUNC_ENTRY;


#define CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG  1


//+-------------------------------------------------------------------------
//  Install a set of callable OID function addresses.
//
//  By default the functions are installed at end of the list.
//  Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list.
//
//  hModule should be updated with the hModule passed to DllMain to prevent
//  the Dll containing the function addresses from being unloaded by
//  CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the
//  case when the Dll has also regsvr32'ed OID functions via
//  CryptRegisterOIDFunction.
//
//  DEFAULT functions are installed by setting rgFuncEntry[].pszOID =
//  CRYPT_DEFAULT_OID.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptInstallOIDFunctionAddress(
    __in_opt HMODULE hModule,         // hModule passed to DllMain
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in DWORD cFuncEntry,
    __in_ecount(cFuncEntry) const CRYPT_OID_FUNC_ENTRY rgFuncEntry[],
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Initialize and return handle to the OID function set identified by its
//  function name.
//
//  If the set already exists, a handle to the existing set is returned.
//--------------------------------------------------------------------------
WINCRYPT32API
HCRYPTOIDFUNCSET
WINAPI
CryptInitOIDFunctionSet(
    __in LPCSTR pszFuncName,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Search the list of installed functions for an encoding type and OID match.
//  If not found, search the registry.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it.
//
//  For a registry match, the Dll containing the function is loaded.
//
//  By default, both the registered and installed function lists are searched.
//  Set CRYPT_GET_INSTALLED_OID_FUNC_FLAG to only search the installed list
//  of functions. This flag would be set by a registered function to get
//  the address of a pre-installed function it was replacing. For example,
//  the registered function might handle a new special case and call the
//  pre-installed function to handle the remaining cases.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptGetOIDFunctionAddress(
    __in HCRYPTOIDFUNCSET hFuncSet,
    __in DWORD dwEncodingType,
    __in LPCSTR pszOID,
    __in DWORD dwFlags,
    __deref_out void **ppvFuncAddr,
    __out HCRYPTOIDFUNCADDR *phFuncAddr
    );

#define CRYPT_GET_INSTALLED_OID_FUNC_FLAG       0x1


//+-------------------------------------------------------------------------
//  Get the list of registered default Dll entries for the specified
//  function set and encoding type.
//
//  The returned list consists of none, one or more null terminated Dll file
//  names. The list is terminated with an empty (L"\0") Dll file name.
//  For example: L"first.dll" L"\0" L"second.dll" L"\0" L"\0"
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptGetDefaultOIDDllList(
    __in HCRYPTOIDFUNCSET hFuncSet,
    __in DWORD dwEncodingType,
    __out_ecount_part_opt(*pcchDllList, *pcchDllList) __nullnullterminated WCHAR *pwszDllList,
    __inout DWORD *pcchDllList
    );

//+-------------------------------------------------------------------------
//  Either: get the first or next installed DEFAULT function OR
//  load the Dll containing the DEFAULT function.
//
//  If pwszDll is NULL, search the list of installed DEFAULT functions.
//  *phFuncAddr must be set to NULL to get the first installed function.
//  Successive installed functions are returned by setting *phFuncAddr
//  to the hFuncAddr returned by the previous call.
//
//  If pwszDll is NULL, the input *phFuncAddr
//  is always CryptFreeOIDFunctionAddress'ed by this function, even for
//  an error.
//
//  If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT
//  function. *phFuncAddr is ignored upon entry and isn't
//  CryptFreeOIDFunctionAddress'ed.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it or CryptGetDefaultOIDFunctionAddress can also
//  be called for a NULL pwszDll.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptGetDefaultOIDFunctionAddress(
    __in HCRYPTOIDFUNCSET hFuncSet,
    __in DWORD dwEncodingType,
    __in_opt LPCWSTR pwszDll,
    __in DWORD dwFlags,
    __deref_out void **ppvFuncAddr,
    __inout HCRYPTOIDFUNCADDR *phFuncAddr
    );

//+-------------------------------------------------------------------------
//  Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress
//  or CryptGetDefaultOIDFunctionAddress.
//
//  If a Dll was loaded for the function its unloaded. However, before doing
//  the unload, the DllCanUnloadNow function exported by the loaded Dll is
//  called. It should return S_FALSE to inhibit the unload or S_TRUE to enable
//  the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded.
//
//  DllCanUnloadNow has the following signature:
//      STDAPI  DllCanUnloadNow(void);
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptFreeOIDFunctionAddress(
    __in HCRYPTOIDFUNCADDR hFuncAddr,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Register the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
//  In addition to registering the DLL, you may override the
//  name of the function to be called. For example,
//      pszFuncName = "CryptDllEncodeObject",
//      pszOverrideFuncName = "MyEncodeXyz".
//  This allows a Dll to export multiple OID functions for the same
//  function name without needing to interpose its own OID dispatcher function.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptRegisterOIDFunction(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCSTR pszOID,
    __in_opt LPCWSTR pwszDll,
    __in_opt LPCSTR pszOverrideFuncName
    );

//+-------------------------------------------------------------------------
//  Unregister the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptUnregisterOIDFunction(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCSTR pszOID
    );


//+-------------------------------------------------------------------------
//  Register the Dll containing the default function to be called for the
//  specified encoding type and function name.
//
//  Unlike CryptRegisterOIDFunction, you can't override the function name
//  needing to be exported by the Dll.
//
//  The Dll is inserted before the entry specified by dwIndex.
//    dwIndex == 0, inserts at the beginning.
//    dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptRegisterDefaultOIDFunction(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in DWORD dwIndex,
    __in LPCWSTR pwszDll
    );

#define CRYPT_REGISTER_FIRST_INDEX   0
#define CRYPT_REGISTER_LAST_INDEX    0xFFFFFFFF

//+-------------------------------------------------------------------------
//  Unregister the Dll containing the default function to be called for
//  the specified encoding type and function name.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptUnregisterDefaultOIDFunction(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCWSTR pwszDll
    );

//+-------------------------------------------------------------------------
//  Set the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegSetValueEx for the possible value types.
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSetOIDFunctionValue(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCSTR pszOID,
    __in_opt LPCWSTR pwszValueName,
    __in DWORD dwValueType,
    __in_bcount_opt(cbValueData) const BYTE *pbValueData,
    __in DWORD cbValueData
    );

//+-------------------------------------------------------------------------
//  Get the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegEnumValue for the possible value types.
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptGetOIDFunctionValue(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCSTR pszOID,
    __in_opt LPCWSTR pwszValueName,
    __out_opt DWORD *pdwValueType,
    __out_bcount_part_opt(*pcbValueData, *pcbValueData) BYTE *pbValueData,
    __inout_opt DWORD *pcbValueData
    );

typedef BOOL (WINAPI *PFN_CRYPT_ENUM_OID_FUNC)(
    __in DWORD dwEncodingType,
    __in LPCSTR pszFuncName,
    __in LPCSTR pszOID,
    __in DWORD cValue,
    __in_ecount(cValue) const DWORD rgdwValueType[],
    __in_ecount(cValue) LPCWSTR const rgpwszValueName[],
    __in_ecount(cValue) const BYTE * const rgpbValueData[],
    __in_ecount(cValue) const DWORD rgcbValueData[],
    __inout_opt void *pvArg
    );

//+-------------------------------------------------------------------------
//  Enumerate the OID functions identified by their encoding type,
//  function name and OID.
//
//  pfnEnumOIDFunc is called for each registry key matching the input
//  parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches
//  any. Setting pszFuncName or pszOID to NULL matches any.
//
//  Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the
//  DEFAULT functions
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptEnumOIDFunction(
    __in DWORD dwEncodingType,
    __in_opt LPCSTR pszFuncName,
    __in_opt LPCSTR pszOID,
    __in DWORD dwFlags,
    __inout_opt void *pvArg,
    __callback PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc
    );

#define CRYPT_MATCH_ANY_ENCODING_TYPE   0xFFFFFFFF


//+=========================================================================
//  Object IDentifier (OID) Information:  Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  Special ALG_ID's used in CRYPT_OID_INFO
//--------------------------------------------------------------------------
// Algorithm is only implemented in CNG.
#define CALG_OID_INFO_CNG_ONLY                   0xFFFFFFFF

// Algorithm is defined in the encoded parameters. Only supported
// using CNG.
#define CALG_OID_INFO_PARAMETERS                 0xFFFFFFFE

// Macro to check for a special ALG_ID used in CRYPT_OID_INFO
#define IS_SPECIAL_OID_INFO_ALGID(Algid)        (Algid >= CALG_OID_INFO_PARAMETERS)


//+-------------------------------------------------------------------------
// Special CNG Algorithms used in CRYPT_OID_INFO
//--------------------------------------------------------------------------
#define CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM L"CryptOIDInfoHashParameters"
#define CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM  L"CryptOIDInfoECCParameters"
#define CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM L"CryptOIDInfoMgf1Parameters"
#define CRYPT_OID_INFO_NO_SIGN_ALGORITHM         L"CryptOIDInfoNoSign"
#define CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM L"CryptOIDInfoOAEPParameters"
#define CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM L"CryptOIDInfoECCWrapParameters"

//+-------------------------------------------------------------------------
//  OID Information
//--------------------------------------------------------------------------
typedef struct _CRYPT_OID_INFO {
    DWORD           cbSize;
    LPCSTR          pszOID;
    LPCWSTR         pwszName;
    DWORD           dwGroupId;
    union {
        DWORD       dwValue;
        ALG_ID      Algid;
        DWORD       dwLength;
    };
    CRYPT_DATA_BLOB ExtraInfo;


#ifdef CRYPT_OID_INFO_HAS_EXTRA_FIELDS
    // Note, if you #define CRYPT_OID_INFO_HAS_EXTRA_FIELDS, then, you
    // must zero all unused fields in this data structure.
    // More fields could be added in a future release.

    // The following 2 fields are set to an empty string, L"", if not defined.

    // This is the Algid string passed to the BCrypt* and NCrypt* APIs
    // defined in bcrypt.h and ncrypt.h.
    //
    // Its only applicable to the following groups:
    //  CRYPT_HASH_ALG_OID_GROUP_ID
    //  CRYPT_ENCRYPT_ALG_OID_GROUP_ID
    //  CRYPT_PUBKEY_ALG_OID_GROUP_ID
    //  CRYPT_SIGN_ALG_OID_GROUP_ID
    LPCWSTR         pwszCNGAlgid;

    // Following is only applicable to the following groups:
    //  CRYPT_SIGN_ALG_OID_GROUP_ID
    //      The public key pwszCNGAlgid. For ECC,
    //      CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM.
    //  CRYPT_PUBKEY_ALG_OID_GROUP_ID
    //      For the ECC algorithms, CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM.
    LPCWSTR         pwszCNGExtraAlgid;
#endif
} CRYPT_OID_INFO, *PCRYPT_OID_INFO;
typedef const CRYPT_OID_INFO CCRYPT_OID_INFO, *PCCRYPT_OID_INFO;

// certenrolld_begin -- CRYPT_*_OID_GROUP_ID
//+-------------------------------------------------------------------------
//  OID Group IDs
//--------------------------------------------------------------------------
#define CRYPT_HASH_ALG_OID_GROUP_ID             1
#define CRYPT_ENCRYPT_ALG_OID_GROUP_ID          2
#define CRYPT_PUBKEY_ALG_OID_GROUP_ID           3
#define CRYPT_SIGN_ALG_OID_GROUP_ID             4
#define CRYPT_RDN_ATTR_OID_GROUP_ID             5
#define CRYPT_EXT_OR_ATTR_OID_GROUP_ID          6
#define CRYPT_ENHKEY_USAGE_OID_GROUP_ID         7
#define CRYPT_POLICY_OID_GROUP_ID               8
#define CRYPT_TEMPLATE_OID_GROUP_ID             9
#define CRYPT_LAST_OID_GROUP_ID                 9

#define CRYPT_FIRST_ALG_OID_GROUP_ID            CRYPT_HASH_ALG_OID_GROUP_ID
#define CRYPT_LAST_ALG_OID_GROUP_ID             CRYPT_SIGN_ALG_OID_GROUP_ID
// certenrolld_end


// The CRYPT_*_ALG_OID_GROUP_ID's have an Algid. The CRYPT_RDN_ATTR_OID_GROUP_ID
// has a dwLength. The CRYPT_EXT_OR_ATTR_OID_GROUP_ID,
// CRYPT_ENHKEY_USAGE_OID_GROUP_ID, CRYPT_POLICY_OID_GROUP_ID or
// CRYPT_TEMPLATE_OID_GROUP_ID don't have a dwValue.
//

// CRYPT_ENCRYPT_ALG_OID_GROUP_ID has the following optional ExtraInfo
// for AES algorithms:
//  DWORD[0] - dwBitLength

// CRYPT_PUBKEY_ALG_OID_GROUP_ID has the following optional ExtraInfo:
//  DWORD[0] - Flags. CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG can be set to
//             inhibit the reformatting of the signature before
//             CryptVerifySignature is called or after CryptSignHash
//             is called. CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG can
//             be set to include the public key algorithm's parameters
//             in the PKCS7's digestEncryptionAlgorithm's parameters.
//             CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG can be set to omit
//             NULL parameters when encoding.
//
// For the ECC named curve public keys
//  DWORD[1] - BCRYPT_ECCKEY_BLOB dwMagic field value
//  DWORD[2] - dwBitLength. Where BCRYPT_ECCKEY_BLOB's
//             cbKey = dwBitLength / 8 + ((dwBitLength % 8) ? 1 : 0)
//

#define CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG     0x00000001
#define CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG    0x00000002
#define CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG       0x00000004

#define CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG             0x80000000
#define CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG          0x40000000

// CRYPT_SIGN_ALG_OID_GROUP_ID has the following optional ExtraInfo:
//  DWORD[0] - Public Key Algid.
//  DWORD[1] - Flags. Same as above for CRYPT_PUBKEY_ALG_OID_GROUP_ID.
//  DWORD[2] - Optional CryptAcquireContext(CRYPT_VERIFYCONTEXT)'s dwProvType.
//             If omitted or 0, uses Public Key Algid to select
//             appropriate dwProvType for signature verification.

// CRYPT_RDN_ATTR_OID_GROUP_ID has the following optional ExtraInfo:
//  Array of DWORDs:
//   [0 ..] - Null terminated list of acceptable RDN attribute
//            value types. An empty list implies CERT_RDN_PRINTABLE_STRING,
//            CERT_RDN_UNICODE_STRING, 0.

//+-------------------------------------------------------------------------
//  Find OID information. Returns NULL if unable to find any information
//  for the specified key and group. Note, returns a pointer to a constant
//  data structure. The returned pointer MUST NOT be freed.
//
//  dwKeyType's:
//    CRYPT_OID_INFO_OID_KEY, pvKey points to a szOID
//    CRYPT_OID_INFO_NAME_KEY, pvKey points to a wszName
//    CRYPT_OID_INFO_ALGID_KEY, pvKey points to an ALG_ID
//    CRYPT_OID_INFO_SIGN_KEY, pvKey points to an array of two ALG_ID's:
//      ALG_ID[0] - Hash Algid
//      ALG_ID[1] - PubKey Algid
//    CRYPT_OID_INFO_CNG_ALGID_KEY, pvKey points to a wszCNGAlgid
//    CRYPT_OID_INFO_CNG_SIGN_KEY, pvKey is an array of two
//     pwszCNGAlgid's:
//      Algid[0] - Hash pwszCNGAlgid
//      Algid[1] - PubKey pwszCNGAlgid
//
//  For CRYPT_OID_INFO_NAME_KEY, CRYPT_OID_INFO_CNG_ALGID_KEY and
//  CRYPT_OID_INFO_CNG_SIGN_KEY the string comparison is case insensitive.
//
//  Setting dwGroupId to 0, searches all groups according to the dwKeyType.
//  Otherwise, only the dwGroupId is searched.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRYPT_OID_INFO
WINAPI
CryptFindOIDInfo(
    __in DWORD dwKeyType,
    __in void *pvKey,
    __in DWORD dwGroupId
    );

#define CRYPT_OID_INFO_OID_KEY           1
#define CRYPT_OID_INFO_NAME_KEY          2
#define CRYPT_OID_INFO_ALGID_KEY         3
#define CRYPT_OID_INFO_SIGN_KEY          4
#define CRYPT_OID_INFO_CNG_ALGID_KEY     5
#define CRYPT_OID_INFO_CNG_SIGN_KEY      6

// Set the following in the above dwKeyType parameter to restrict public keys
// valid for signing or encrypting
// certenrolld_begin -- CRYPT_*_KEY_FLAG
#define CRYPT_OID_INFO_OID_KEY_FLAGS_MASK           0xFFFF0000
#define CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG         0x80000000
#define CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG      0x40000000

// The following flag can be set in above dwGroupId parameter to disable
// searching the directory server
#define CRYPT_OID_DISABLE_SEARCH_DS_FLAG            0x80000000

#ifdef CRYPT_OID_INFO_HAS_EXTRA_FIELDS

// The following flag can be set in above dwGroupId parameter to search
// through CRYPT_OID_INFO records. If there are multiple records that meet
// the search criteria, the first record with defined pwszCNGAlgid would be
// returned. If none of the records (meeting the search criteria) have 
// pwszCNGAlgid defined, first record (meeting the search criteria) would be
// returned.
#define CRYPT_OID_PREFER_CNG_ALGID_FLAG            0x40000000

#endif

// certenrolld_end -- CRYPT_*_KEY_FLAG

// The bit length shifted left 16 bits can be OR'ed into the above
// dwGroupId parameter. Only applicable to the CRYPT_ENCRYPT_ALG_OID_GROUP_ID.
// Also, only applicable to encryption algorithms having a dwBitLen ExtraInfo.
// Currently, only the AES encryption algorithms have this.
//
// For example, to find the OIDInfo for BCRYPT_AES_ALGORITHM, bit length 192,
// CryptFindOIDInfo would be called as follows:
//  PCCRYPT_OID_INFO pOIDInfo =
//      CryptFindOIDInfo(
//          CRYPT_OID_INFO_CNG_ALGID_KEY,
//          (void *) BCRYPT_AES_ALGORITHM,
//          CRYPT_ENCRYPT_ALG_OID_GROUP_ID |
//              (192 << CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT)
//          );

#define CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK       0x0FFF0000
#define CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT      16

//+-------------------------------------------------------------------------
//  Register OID information. The OID information specified in the
//  CCRYPT_OID_INFO structure is persisted to the registry.
//
//  crypt32.dll contains information for the commonly known OIDs. This function
//  allows applications to augment crypt32.dll's OID information. During
//  CryptFindOIDInfo's first call, the registered OID information is installed.
//
//  By default the registered OID information is installed after crypt32.dll's
//  OID entries. Set CRYPT_INSTALL_OID_INFO_BEFORE_FLAG to install before.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptRegisterOIDInfo(
    __in PCCRYPT_OID_INFO pInfo,
    __in DWORD dwFlags
    );

#define CRYPT_INSTALL_OID_INFO_BEFORE_FLAG  1

//+-------------------------------------------------------------------------
//  Unregister OID information. Only the pszOID and dwGroupId fields are
//  used to identify the OID information to be unregistered.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptUnregisterOIDInfo(
    __in PCCRYPT_OID_INFO pInfo
    );

// If the callback returns FALSE, stops the enumeration.
typedef BOOL (WINAPI *PFN_CRYPT_ENUM_OID_INFO)(
    __in PCCRYPT_OID_INFO pInfo,
    __inout_opt void *pvArg
    );

//+-------------------------------------------------------------------------
//  Enumerate the OID information.
//
//  pfnEnumOIDInfo is called for each OID information entry.
//
//  Setting dwGroupId to 0 matches all groups. Otherwise, only enumerates
//  entries in the specified group.
//
//  dwFlags currently isn't used and must be set to 0.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptEnumOIDInfo(
    __in DWORD dwGroupId,
    __in DWORD dwFlags,
    __inout_opt void *pvArg,
    __callback PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    );

//+-------------------------------------------------------------------------
//  Find the localized name for the specified name. For example, find the
//  localized name for the "Root" system store name. A case insensitive
//  string comparison is done.
//
//  Returns NULL if unable to find the the specified name.
//
//  Localized names for the predefined system stores ("Root", "My") and
//  predefined physical stores (".Default", ".LocalMachine") are pre-installed
//  as resource strings in crypt32.dll. CryptSetOIDFunctionValue can be called
//  as follows to register additional localized strings:
//      dwEncodingType = CRYPT_LOCALIZED_NAME_ENCODING_TYPE
//      pszFuncName = CRYPT_OID_FIND_LOCALIZED_NAME_FUNC
//      pszOID = CRYPT_LOCALIZED_NAME_OID
//      pwszValueName = Name to be localized, for example, L"ApplicationStore"
//      dwValueType = REG_SZ
//      pbValueData = pointer to the UNICODE localized string
//      cbValueData = (wcslen(UNICODE localized string) + 1) * sizeof(WCHAR)
//
//  To unregister, set pbValueData to NULL and cbValueData to 0.
//
//  The registered names are searched before the pre-installed names.
//--------------------------------------------------------------------------
WINCRYPT32API
LPCWSTR
WINAPI
CryptFindLocalizedName(
    __in LPCWSTR pwszCryptName
    );

#define CRYPT_LOCALIZED_NAME_ENCODING_TYPE  0
#define CRYPT_LOCALIZED_NAME_OID            "LocalizedNames"

//+=========================================================================
//  Low Level Cryptographic Message Data Structures and APIs
//==========================================================================

typedef void *HCRYPTMSG;

#define szOID_PKCS_7_DATA               "1.2.840.113549.1.7.1"
#define szOID_PKCS_7_SIGNED             "1.2.840.113549.1.7.2"
#define szOID_PKCS_7_ENVELOPED          "1.2.840.113549.1.7.3"
#define szOID_PKCS_7_SIGNEDANDENVELOPED "1.2.840.113549.1.7.4"
#define szOID_PKCS_7_DIGESTED           "1.2.840.113549.1.7.5"
#define szOID_PKCS_7_ENCRYPTED          "1.2.840.113549.1.7.6"

#define szOID_PKCS_9_CONTENT_TYPE       "1.2.840.113549.1.9.3"
#define szOID_PKCS_9_MESSAGE_DIGEST     "1.2.840.113549.1.9.4"

//+-------------------------------------------------------------------------
//  Message types
//--------------------------------------------------------------------------
#define CMSG_DATA                    1
#define CMSG_SIGNED                  2
#define CMSG_ENVELOPED               3
#define CMSG_SIGNED_AND_ENVELOPED    4
#define CMSG_HASHED                  5
#define CMSG_ENCRYPTED               6

//+-------------------------------------------------------------------------
//  Message Type Bit Flags
//--------------------------------------------------------------------------
#define CMSG_ALL_FLAGS                   (~0UL)
#define CMSG_DATA_FLAG                   (1 << CMSG_DATA)
#define CMSG_SIGNED_FLAG                 (1 << CMSG_SIGNED)
#define CMSG_ENVELOPED_FLAG              (1 << CMSG_ENVELOPED)
#define CMSG_SIGNED_AND_ENVELOPED_FLAG   (1 << CMSG_SIGNED_AND_ENVELOPED)
#define CMSG_HASHED_FLAG                 (1 << CMSG_HASHED)
#define CMSG_ENCRYPTED_FLAG              (1 << CMSG_ENCRYPTED)


//+-------------------------------------------------------------------------
//  Certificate Issuer and SerialNumber
//--------------------------------------------------------------------------
typedef struct _CERT_ISSUER_SERIAL_NUMBER {
    CERT_NAME_BLOB      Issuer;
    CRYPT_INTEGER_BLOB  SerialNumber;
} CERT_ISSUER_SERIAL_NUMBER, *PCERT_ISSUER_SERIAL_NUMBER;

//+-------------------------------------------------------------------------
//  Certificate Identifier
//--------------------------------------------------------------------------
typedef struct _CERT_ID {
    DWORD   dwIdChoice;
    union {
        // CERT_ID_ISSUER_SERIAL_NUMBER
        CERT_ISSUER_SERIAL_NUMBER   IssuerSerialNumber;
        // CERT_ID_KEY_IDENTIFIER
        CRYPT_HASH_BLOB             KeyId;
        // CERT_ID_SHA1_HASH
        CRYPT_HASH_BLOB             HashId;
    };
} CERT_ID, *PCERT_ID;

#define CERT_ID_ISSUER_SERIAL_NUMBER    1
#define CERT_ID_KEY_IDENTIFIER          2
#define CERT_ID_SHA1_HASH               3


//+-------------------------------------------------------------------------
//  The message encode information (pvMsgEncodeInfo) is message type dependent
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_DATA: pvMsgEncodeInfo = NULL
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_SIGNED
//
//  The pCertInfo in the CMSG_SIGNER_ENCODE_INFO provides the Issuer, SerialNumber
//  and PublicKeyInfo.Algorithm. The PublicKeyInfo.Algorithm implicitly
//  specifies the HashEncryptionAlgorithm to be used.
//
//  If the SignerId is present with a nonzero dwIdChoice its used instead
//  of the Issuer and SerialNumber in pCertInfo.
//
//  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs. PKCS #7
//  version 1.5 only supports the ISSUER_SERIAL_NUMBER CERT_ID choice.
//
//  If HashEncryptionAlgorithm is present and not NULL its used instead of
//  the PublicKeyInfo.Algorithm.
//
//  Note, for RSA, the hash encryption algorithm is normally the same as
//  the public key algorithm. For DSA, the hash encryption algorithm is
//  normally a DSS signature algorithm.
//
//  pvHashEncryptionAuxInfo currently isn't used and must be set to NULL if
//  present in the data structure.
//
//  The hCryptProv and dwKeySpec specify the private key to use. If dwKeySpec
//  == 0, then, defaults to AT_SIGNATURE.
//
//  If the HashEncryptionAlgorithm is set to szOID_PKIX_NO_SIGNATURE, then,
//  the signature value only contains the hash octets. hCryptProv must still
//  be specified. However, since a private key isn't used the hCryptProv can be
//  acquired using CRYPT_VERIFYCONTEXT.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), the signer hCryptProv's are released.
//
//  For CNG, this applies to the hNCryptKey.
//
//  pvHashAuxInfo currently isn't used and must be set to NULL.
//
//  CMS signed messages allow the inclusion of Attribute Certs.
//--------------------------------------------------------------------------
typedef struct _CMSG_SIGNER_ENCODE_INFO {
    DWORD                       cbSize;
    PCERT_INFO                  pCertInfo;

    // NCryptIsKeyHandle() is called to determine the union choice.
    union {
        HCRYPTPROV                  hCryptProv;
        NCRYPT_KEY_HANDLE           hNCryptKey;
    };

    // not applicable for hNCryptKey choice
    DWORD                       dwKeySpec;

    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    void                        *pvHashAuxInfo;
    DWORD                       cAuthAttr;
    PCRYPT_ATTRIBUTE            rgAuthAttr;
    DWORD                       cUnauthAttr;
    PCRYPT_ATTRIBUTE            rgUnauthAttr;

#ifdef CMSG_SIGNER_ENCODE_INFO_HAS_CMS_FIELDS
    CERT_ID                     SignerId;

    // This is also referred to as the SignatureAlgorithm
    CRYPT_ALGORITHM_IDENTIFIER  HashEncryptionAlgorithm;
    void                        *pvHashEncryptionAuxInfo;
#endif
} CMSG_SIGNER_ENCODE_INFO, *PCMSG_SIGNER_ENCODE_INFO;

typedef struct _CMSG_SIGNED_ENCODE_INFO {
    DWORD                       cbSize;
    DWORD                       cSigners;
    PCMSG_SIGNER_ENCODE_INFO    rgSigners;
    DWORD                       cCertEncoded;
    PCERT_BLOB                  rgCertEncoded;
    DWORD                       cCrlEncoded;
    PCRL_BLOB                   rgCrlEncoded;

#ifdef CMSG_SIGNED_ENCODE_INFO_HAS_CMS_FIELDS
    DWORD                       cAttrCertEncoded;
    PCERT_BLOB                  rgAttrCertEncoded;
#endif
} CMSG_SIGNED_ENCODE_INFO, *PCMSG_SIGNED_ENCODE_INFO;

//+-------------------------------------------------------------------------
//  CMSG_ENVELOPED
//
//  The PCERT_INFO for the rgRecipients provides the Issuer, SerialNumber
//  and PublicKeyInfo. The PublicKeyInfo.Algorithm implicitly
//  specifies the KeyEncryptionAlgorithm to be used.
//
//  The PublicKeyInfo.PublicKey in PCERT_INFO is used to encrypt the content
//  encryption key for the recipient.
//
//  hCryptProv is used to do the content encryption, recipient key encryption
//  and export. The hCryptProv's private keys aren't used. If hCryptProv
//  is NULL, a default hCryptProv is chosen according to the
//  ContentEncryptionAlgorithm and the first recipient KeyEncryptionAlgorithm.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), the envelope's hCryptProv is released.
//
//  Note: CAPI currently doesn't support more than one KeyEncryptionAlgorithm
//  per provider. This will need to be fixed.
//
//  Currently, pvEncryptionAuxInfo is only defined for RC2 or RC4 encryption
//  algorithms. Otherwise, its not used and must be set to NULL.
//  See CMSG_RC2_AUX_INFO for the RC2 encryption algorithms.
//  See CMSG_RC4_AUX_INFO for the RC4 encryption algorithms.
//
//  To enable SP3 compatible encryption, pvEncryptionAuxInfo should point to
//  a CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
//
//  To enable the CMS envelope enhancements, rgpRecipients must be set to
//  NULL, and rgCmsRecipients updated to point to an array of
//  CMSG_RECIPIENT_ENCODE_INFO's.
//
//  Also, CMS envelope enhancements support the inclusion of a bag of
//  Certs, CRLs, Attribute Certs and/or Unprotected Attributes.
//
//  AES ContentEncryption and ECC KeyAgreement recipients are only supported
//  via CNG. DH KeyAgreement or mail list recipients are only supported via
//  CAPI1. SP3 compatible encryption and RC4 are only supported via CAPI1.
//
//  For an RSA recipient identified via PCERT_INFO, for AES ContentEncryption,
//  szOID_RSAES_OAEP will be implicitly used for the KeyEncryptionAlgorithm.
//--------------------------------------------------------------------------
typedef struct _CMSG_RECIPIENT_ENCODE_INFO CMSG_RECIPIENT_ENCODE_INFO,
    *PCMSG_RECIPIENT_ENCODE_INFO;

typedef struct _CMSG_ENVELOPED_ENCODE_INFO {
    DWORD                       cbSize;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    void                        *pvEncryptionAuxInfo;
    DWORD                       cRecipients;

    // The following array may only be used for transport recipients identified
    // by their IssuereAndSerialNumber. If rgpRecipients != NULL, then,
    // the rgCmsRecipients must be NULL.
    PCERT_INFO                  *rgpRecipients;

#ifdef CMSG_ENVELOPED_ENCODE_INFO_HAS_CMS_FIELDS
    // If rgCmsRecipients != NULL, then, the above rgpRecipients must be
    // NULL.
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
    DWORD                       cCertEncoded;
    PCERT_BLOB                  rgCertEncoded;
    DWORD                       cCrlEncoded;
    PCRL_BLOB                   rgCrlEncoded;
    DWORD                       cAttrCertEncoded;
    PCERT_BLOB                  rgAttrCertEncoded;
    DWORD                       cUnprotectedAttr;
    PCRYPT_ATTRIBUTE            rgUnprotectedAttr;
#endif
} CMSG_ENVELOPED_ENCODE_INFO, *PCMSG_ENVELOPED_ENCODE_INFO;



//+-------------------------------------------------------------------------
//  Key Transport Recipient Encode Info
//
//  hCryptProv is used to do the recipient key encryption
//  and export. The hCryptProv's private keys aren't used.
//
//  If hCryptProv is NULL, then, the hCryptProv specified in
//  CMSG_ENVELOPED_ENCODE_INFO is used.
//
//  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
//
//  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs. PKCS #7
//  version 1.5 only supports the ISSUER_SERIAL_NUMBER CERT_ID choice.
//
//  For RSA AES, KeyEncryptionAlgorithm.pszObjId should be set to
//  szOID_RSAES_OAEP. KeyEncryptionAlgorithm.Parameters should be set
//  to the encoded PKCS_RSAES_OAEP_PARAMETERS. If
//  KeyEncryptionAlgorithm.Parameters.cbData == 0, then, the default
//  parameters are used and encoded.
//--------------------------------------------------------------------------
typedef struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
    DWORD                       cbSize;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    void                        *pvKeyEncryptionAuxInfo;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_BIT_BLOB              RecipientPublicKey;
    CERT_ID                     RecipientId;
} CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO, *PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;


//+-------------------------------------------------------------------------
//  Key Agreement Recipient Encode Info
//
//  If hCryptProv is NULL, then, the hCryptProv specified in
//  CMSG_ENVELOPED_ENCODE_INFO is used.
//
//  For the CMSG_KEY_AGREE_STATIC_KEY_CHOICE, both the hCryptProv and
//  dwKeySpec must be specified to select the sender's private key.
//
//  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
//
//  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs.
//
//  There is 1 key choice, ephemeral originator. The originator's ephemeral
//  key is generated using the public key algorithm parameters shared
//  amongst all the recipients.
//
//  There are 2 key choices: ephemeral originator or static sender. The
//  originator's ephemeral key is generated using the public key algorithm
//  parameters shared amongst all the recipients. For the static sender its
//  private key is used. The hCryptProv and dwKeySpec specify the private key.
//  The pSenderId identifies the certificate containing the sender's public key.
//
//  Currently, pvKeyEncryptionAuxInfo isn't used and must be set to NULL.
//
//  If KeyEncryptionAlgorithm.Parameters.cbData == 0, then, its Parameters
//  are updated with the encoded KeyWrapAlgorithm.
//
//  Currently, pvKeyWrapAuxInfo is only defined for algorithms with
//  RC2. Otherwise, its not used and must be set to NULL.
//  When set for RC2 algorithms, points to a CMSG_RC2_AUX_INFO containing
//  the RC2 effective key length.
//
//  Note, key agreement recipients are not supported in PKCS #7 version 1.5.
//
//  For the ECC szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF KeyEncryptionAlgorithm
//  the CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE must be specified.
//--------------------------------------------------------------------------
typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
    DWORD                       cbSize;
    CRYPT_BIT_BLOB              RecipientPublicKey;
    CERT_ID                     RecipientId;

    // Following fields are optional and only applicable to KEY_IDENTIFIER
    // CERT_IDs.
    FILETIME                    Date;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
} CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
    *PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;

typedef struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
    DWORD                       cbSize;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    void                        *pvKeyEncryptionAuxInfo;
    CRYPT_ALGORITHM_IDENTIFIER  KeyWrapAlgorithm;
    void                        *pvKeyWrapAuxInfo;

    // The following hCryptProv and dwKeySpec must be specified for the
    // CMSG_KEY_AGREE_STATIC_KEY_CHOICE.
    //
    // For CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE, dwKeySpec isn't applicable
    // and hCryptProv is optional.

    HCRYPTPROV_LEGACY           hCryptProv;
    DWORD                       dwKeySpec;

    DWORD                       dwKeyChoice;
    union {
        // CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE
        //
        // The ephemeral public key algorithm and parameters.
        PCRYPT_ALGORITHM_IDENTIFIER pEphemeralAlgorithm;

        // CMSG_KEY_AGREE_STATIC_KEY_CHOICE
        //
        // The CertId of the sender's certificate
        PCERT_ID                    pSenderId;
    };
    CRYPT_DATA_BLOB             UserKeyingMaterial;     // OPTIONAL

    DWORD                                       cRecipientEncryptedKeys;
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO   *rgpRecipientEncryptedKeys;
} CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO, *PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;

#define CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE         1
#define CMSG_KEY_AGREE_STATIC_KEY_CHOICE            2

//+-------------------------------------------------------------------------
//  Mail List Recipient Encode Info
//
//  There is 1 choice for the KeyEncryptionKey: an already created CSP key
//  handle. For the key handle choice, hCryptProv must be nonzero. This key
//  handle isn't destroyed.
//
//  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
//
//  Currently, pvKeyEncryptionAuxInfo is only defined for RC2 key wrap
//  algorithms. Otherwise, its not used and must be set to NULL.
//  When set for RC2 algorithms, points to a CMSG_RC2_AUX_INFO containing
//  the RC2 effective key length.
//
//  Note, mail list recipients are not supported in PKCS #7 version 1.5.
//
//  Mail list recipients aren't supported using CNG.
//--------------------------------------------------------------------------
typedef struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
    DWORD                       cbSize;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    void                        *pvKeyEncryptionAuxInfo;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeyChoice;
    union {
        // CMSG_MAIL_LIST_HANDLE_KEY_CHOICE
        HCRYPTKEY                   hKeyEncryptionKey;
        // Reserve space for a potential pointer choice
        void                        *pvKeyEncryptionKey;
    };
    CRYPT_DATA_BLOB             KeyId;

    // Following fields are optional.
    FILETIME                    Date;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
} CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO, *PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;

#define CMSG_MAIL_LIST_HANDLE_KEY_CHOICE    1

//+-------------------------------------------------------------------------
//  Recipient Encode Info
//
//  Note, only key transport recipients are supported in PKCS #7 version 1.5.
//--------------------------------------------------------------------------
struct _CMSG_RECIPIENT_ENCODE_INFO {
    DWORD   dwRecipientChoice;
    union {
        // CMSG_KEY_TRANS_RECIPIENT
        PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO   pKeyTrans;
        // CMSG_KEY_AGREE_RECIPIENT
        PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO   pKeyAgree;
        // CMSG_MAIL_LIST_RECIPIENT
        PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO   pMailList;
    };
};


#define CMSG_KEY_TRANS_RECIPIENT         1
#define CMSG_KEY_AGREE_RECIPIENT         2
#define CMSG_MAIL_LIST_RECIPIENT         3


//+-------------------------------------------------------------------------
//  CMSG_RC2_AUX_INFO
//
//  AuxInfo for RC2 encryption algorithms. The pvEncryptionAuxInfo field
//  in CMSG_ENCRYPTED_ENCODE_INFO should be updated to point to this
//  structure. If not specified, defaults to 40 bit.
//
//  Note, this AuxInfo is only used when, the ContentEncryptionAlgorithm's
//  Parameter.cbData is zero. Otherwise, the Parameters is decoded to
//  get the bit length.
//
//  If CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwBitLen, then, SP3
//  compatible encryption is done and the bit length is ignored.
//--------------------------------------------------------------------------
typedef struct _CMSG_RC2_AUX_INFO {
    DWORD                       cbSize;
    DWORD                       dwBitLen;
} CMSG_RC2_AUX_INFO, *PCMSG_RC2_AUX_INFO;

//+-------------------------------------------------------------------------
//  CMSG_SP3_COMPATIBLE_AUX_INFO
//
//  AuxInfo for enabling SP3 compatible encryption.
//
//  The CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwFlags to enable SP3
//  compatible encryption. When set, uses zero salt instead of no salt,
//  the encryption algorithm parameters are NULL instead of containing the
//  encoded RC2 parameters or encoded IV octet string and the encrypted
//  symmetric key is encoded little endian instead of big endian.
//
//  SP3 compatible encryption isn't supported using CNG.
//--------------------------------------------------------------------------
typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
    DWORD                       cbSize;
    DWORD                       dwFlags;
} CMSG_SP3_COMPATIBLE_AUX_INFO, *PCMSG_SP3_COMPATIBLE_AUX_INFO;

#define CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG    0x80000000

//+-------------------------------------------------------------------------
//  CMSG_RC4_AUX_INFO
//
//  AuxInfo for RC4 encryption algorithms. The pvEncryptionAuxInfo field
//  in CMSG_ENCRYPTED_ENCODE_INFO should be updated to point to this
//  structure. If not specified, uses the CSP's default bit length with no
//  salt. Note, the base CSP has a 40 bit default and the enhanced CSP has
//  a 128 bit default.
//
//  If CMSG_RC4_NO_SALT_FLAG is set in dwBitLen, then, no salt is generated.
//  Otherwise, (128 - dwBitLen)/8 bytes of salt are generated and encoded
//  as an OCTET STRING in the algorithm parameters field.
//
//  RC4 isn't supported using CNG.
//--------------------------------------------------------------------------
typedef struct _CMSG_RC4_AUX_INFO {
    DWORD                       cbSize;
    DWORD                       dwBitLen;
} CMSG_RC4_AUX_INFO, *PCMSG_RC4_AUX_INFO;

#define CMSG_RC4_NO_SALT_FLAG               0x40000000

//+-------------------------------------------------------------------------
//  CMSG_SIGNED_AND_ENVELOPED
//
//  For PKCS #7, a signed and enveloped message doesn't have the
//  signer's authenticated or unauthenticated attributes. Otherwise, a
//  combination of the CMSG_SIGNED_ENCODE_INFO and CMSG_ENVELOPED_ENCODE_INFO.
//--------------------------------------------------------------------------
typedef struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
    DWORD                       cbSize;
    CMSG_SIGNED_ENCODE_INFO     SignedInfo;
    CMSG_ENVELOPED_ENCODE_INFO  EnvelopedInfo;
} CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO, *PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;

//+-------------------------------------------------------------------------
//  CMSG_HASHED
//
//  hCryptProv is used to do the hash. Doesn't need to use a private key.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
//  passed to CryptMsgOpenToEncode(), the hCryptProv is released.
//
//  IN LH, the hCryptProv isn't used. However, its still released if the
//  above flag is set.
//
//  If fDetachedHash is set, then, the encoded message doesn't contain
//  any content (its treated as NULL Data)
//
//  pvHashAuxInfo currently isn't used and must be set to NULL.
//--------------------------------------------------------------------------
typedef struct _CMSG_HASHED_ENCODE_INFO {
    DWORD                       cbSize;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    void                        *pvHashAuxInfo;
} CMSG_HASHED_ENCODE_INFO, *PCMSG_HASHED_ENCODE_INFO;

//+-------------------------------------------------------------------------
//  CMSG_ENCRYPTED
//
//  The key used to encrypt the message is identified outside of the message
//  content (for example, password).
//
//  The content input to CryptMsgUpdate has already been encrypted.
//
//  pvEncryptionAuxInfo currently isn't used and must be set to NULL.
//--------------------------------------------------------------------------
typedef struct _CMSG_ENCRYPTED_ENCODE_INFO {
    DWORD                       cbSize;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    void                        *pvEncryptionAuxInfo;
} CMSG_ENCRYPTED_ENCODE_INFO, *PCMSG_ENCRYPTED_ENCODE_INFO;

//+-------------------------------------------------------------------------
//  This parameter allows messages to be of variable length with streamed
//  output.
//
//  By default, messages are of a definite length and
//  CryptMsgGetParam(CMSG_CONTENT_PARAM) is
//  called to get the cryptographically processed content. Until closed,
//  the handle keeps a copy of the processed content.
//
//  With streamed output, the processed content can be freed as its streamed.
//
//  If the length of the content to be updated is known at the time of the
//  open, then, ContentLength should be set to that length. Otherwise, it
//  should be set to CMSG_INDEFINITE_LENGTH.
//--------------------------------------------------------------------------
typedef BOOL (WINAPI *PFN_CMSG_STREAM_OUTPUT)(
    __in_opt const void *pvArg,
    __in_bcount_opt(cbData) BYTE *pbData,
    __in DWORD cbData,
    __in BOOL fFinal
    );

#define CMSG_INDEFINITE_LENGTH       (0xFFFFFFFF)

typedef struct _CMSG_STREAM_INFO {
    DWORD                   cbContent;
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput;
    void                    *pvArg;
} CMSG_STREAM_INFO, *PCMSG_STREAM_INFO;

//+-------------------------------------------------------------------------
//  Open dwFlags
//--------------------------------------------------------------------------
#define CMSG_BARE_CONTENT_FLAG              0x00000001
#define CMSG_LENGTH_ONLY_FLAG               0x00000002
#define CMSG_DETACHED_FLAG                  0x00000004
#define CMSG_AUTHENTICATED_ATTRIBUTES_FLAG  0x00000008
#define CMSG_CONTENTS_OCTETS_FLAG           0x00000010
#define CMSG_MAX_LENGTH_FLAG                0x00000020

// When set, nonData type inner content is encapsulated within an
// OCTET STRING. Applicable to both Signed and Enveloped messages.
#define CMSG_CMS_ENCAPSULATED_CONTENT_FLAG  0x00000040

// If set, then, the hCryptProv passed to CryptMsgOpenToEncode or
// CryptMsgOpenToDecode is released on the final CryptMsgClose.
// Not released if CryptMsgOpenToEncode or CryptMsgOpenToDecode fails.
//
// Also applies to hNCryptKey where applicable.
//
// Note, the envelope recipient hCryptProv's aren't released.
#define CMSG_CRYPT_RELEASE_CONTEXT_FLAG     0x00008000

//+-------------------------------------------------------------------------
//  Open a cryptographic message for encoding
//
//  If CMSG_BARE_CONTENT_FLAG is specified for a streamed message,
//  the streamed output will not have an outer ContentInfo wrapper. This
//  makes it suitable to be streamed into an enclosing message.
//
//  The pStreamInfo parameter needs to be set to stream the encoded message
//  output.
//--------------------------------------------------------------------------
WINCRYPT32API
HCRYPTMSG
WINAPI
CryptMsgOpenToEncode(
    __in DWORD dwMsgEncodingType,
    __in DWORD dwFlags,
    __in DWORD dwMsgType,
    __in void const *pvMsgEncodeInfo,
    __in_opt LPSTR pszInnerContentObjID,
    __in_opt PCMSG_STREAM_INFO pStreamInfo
    );

//+-------------------------------------------------------------------------
//  Calculate the length of an encoded cryptographic message.
//
//  Calculates the length of the encoded message given the
//  message type, encoding parameters and total length of
//  the data to be updated. Note, this might not be the exact length. However,
//  it will always be greater than or equal to the actual length.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CryptMsgCalculateEncodedLength(
    __in DWORD dwMsgEncodingType,
    __in DWORD dwFlags,
    __in DWORD dwMsgType,
    __in void const *pvMsgEncodeInfo,
    __in_opt LPSTR pszInnerContentObjID,
    __in DWORD cbData
    );

//+-------------------------------------------------------------------------
//  Open a cryptographic message for decoding
//
//  hCryptProv specifies the crypto provider to use for hashing and/or
//  decrypting the message. If hCryptProv is NULL, a default crypt provider
//  is used.
//
//  Currently pRecipientInfo isn't used and should be set to NULL.
//
//  The pStreamInfo parameter needs to be set to stream the decoded content
//  output.
//--------------------------------------------------------------------------
WINCRYPT32API
HCRYPTMSG
WINAPI
CryptMsgOpenToDecode(
    __in DWORD dwMsgEncodingType,
    __in DWORD dwFlags,
    __in DWORD dwMsgType,
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __reserved PCERT_INFO pRecipientInfo,
    __in_opt PCMSG_STREAM_INFO pStreamInfo
    );

//+-------------------------------------------------------------------------
//  Duplicate a cryptographic message handle
//--------------------------------------------------------------------------
WINCRYPT32API
HCRYPTMSG
WINAPI
CryptMsgDuplicate(
    __in_opt HCRYPTMSG hCryptMsg
    );

//+-------------------------------------------------------------------------
//  Close a cryptographic message handle
//
//  LastError is preserved unless FALSE is returned.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgClose(
    __in_opt HCRYPTMSG hCryptMsg
    );

//+-------------------------------------------------------------------------
//  Update the content of a cryptographic message. Depending on how the
//  message was opened, the content is either encoded or decoded.
//
//  This function is repetitively called to append to the message content.
//  fFinal is set to identify the last update. On fFinal, the encode/decode
//  is completed. The encoded/decoded content and the decoded parameters
//  are valid until the open and all duplicated handles are closed.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgUpdate(
    __in HCRYPTMSG hCryptMsg,
    __in_bcount_opt(cbData) const BYTE *pbData,
    __in DWORD cbData,
    __in BOOL fFinal
    );

//+-------------------------------------------------------------------------
//  Get a parameter after encoding/decoding a cryptographic message. Called
//  after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and
//  CMSG_COMPUTED_HASH_PARAM are valid for an encoded message.
//
//  For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got
//  before any CryptMsgUpdates to get its length.
//
//  The pvData type definition depends on the dwParamType value.
//
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  Upon input, if *pcbData == 0, then, *pcbData is updated with the length
//  of the data and the pvData parameter is ignored.
//
//  Upon return, *pcbData is updated with the length of the data.
//
//  The OBJID BLOBs returned in the pvData structures point to
//  their still encoded representation. The appropriate functions
//  must be called to decode the information.
//
//  See below for a list of the parameters to get.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgGetParam(
    __in HCRYPTMSG hCryptMsg,
    __in DWORD dwParamType,
    __in DWORD dwIndex,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Get parameter types and their corresponding data structure definitions.
//--------------------------------------------------------------------------
#define CMSG_TYPE_PARAM                              1
#define CMSG_CONTENT_PARAM                           2
#define CMSG_BARE_CONTENT_PARAM                      3
#define CMSG_INNER_CONTENT_TYPE_PARAM                4
#define CMSG_SIGNER_COUNT_PARAM                      5
#define CMSG_SIGNER_INFO_PARAM                       6
#define CMSG_SIGNER_CERT_INFO_PARAM                  7
#define CMSG_SIGNER_HASH_ALGORITHM_PARAM             8
#define CMSG_SIGNER_AUTH_ATTR_PARAM                  9
#define CMSG_SIGNER_UNAUTH_ATTR_PARAM                10
#define CMSG_CERT_COUNT_PARAM                        11
#define CMSG_CERT_PARAM                              12
#define CMSG_CRL_COUNT_PARAM                         13
#define CMSG_CRL_PARAM                               14
#define CMSG_ENVELOPE_ALGORITHM_PARAM                15
#define CMSG_RECIPIENT_COUNT_PARAM                   17
#define CMSG_RECIPIENT_INDEX_PARAM                   18
#define CMSG_RECIPIENT_INFO_PARAM                    19
#define CMSG_HASH_ALGORITHM_PARAM                    20
#define CMSG_HASH_DATA_PARAM                         21
#define CMSG_COMPUTED_HASH_PARAM                     22
#define CMSG_ENCRYPT_PARAM                           26
#define CMSG_ENCRYPTED_DIGEST                        27
#define CMSG_ENCODED_SIGNER                          28
#define CMSG_ENCODED_MESSAGE                         29
#define CMSG_VERSION_PARAM                           30
#define CMSG_ATTR_CERT_COUNT_PARAM                   31
#define CMSG_ATTR_CERT_PARAM                         32
#define CMSG_CMS_RECIPIENT_COUNT_PARAM               33
#define CMSG_CMS_RECIPIENT_INDEX_PARAM               34
#define CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM 35
#define CMSG_CMS_RECIPIENT_INFO_PARAM                36
#define CMSG_UNPROTECTED_ATTR_PARAM                  37
#define CMSG_SIGNER_CERT_ID_PARAM                    38
#define CMSG_CMS_SIGNER_INFO_PARAM                   39

//+-------------------------------------------------------------------------
//  CMSG_TYPE_PARAM
//
//  The type of the decoded message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CONTENT_PARAM
//
//  The encoded content of a cryptographic message. Depending on how the
//  message was opened, the content is either the whole PKCS#7
//  message (opened to encode) or the inner content (opened to decode).
//  In the decode case, the decrypted content is returned, if enveloped.
//  If not enveloped, and if the inner content is of type DATA, the returned
//  data is the contents octets of the inner content.
//
//  pvData points to the buffer receiving the content bytes
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_BARE_CONTENT_PARAM
//
//  The encoded content of an encoded cryptographic message, without the
//  outer layer of ContentInfo. That is, only the encoding of the
//  ContentInfo.content field is returned.
//
//  pvData points to the buffer receiving the content bytes
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_INNER_CONTENT_TYPE_PARAM
//
//  The type of the inner content of a decoded cryptographic message,
//  in the form of a NULL-terminated object identifier string
//  (eg. "1.2.840.113549.1.7.1").
//
//  pvData points to the buffer receiving the object identifier string
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_SIGNER_COUNT_PARAM
//
//  Count of signers in a SIGNED or SIGNED_AND_ENVELOPED message
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_SIGNER_CERT_INFO_PARAM
//
//  To get all the signers, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. SignerCount - 1.
//
//  pvData points to a CERT_INFO struct.
//
//  Only the following fields have been updated in the CERT_INFO struct:
//  Issuer and SerialNumber.
//
//  Note, if the KEYID choice was selected for a CMS SignerId, then, the
//  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
//  single Attribute whose OID is szOID_KEYID_RDN, value type is
//  CERT_RDN_OCTET_STRING and value is the KEYID. When the
//  CertGetSubjectCertificateFromStore and
//  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
//  special KEYID Issuer and SerialNumber, they do a KEYID match.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_SIGNER_INFO_PARAM
//
//  To get all the signers, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. SignerCount - 1.
//
//  pvData points to a CMSG_SIGNER_INFO struct.
//
//  Note, if the KEYID choice was selected for a CMS SignerId, then, the
//  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
//  single Attribute whose OID is szOID_KEYID_RDN, value type is
//  CERT_RDN_OCTET_STRING and value is the KEYID. When the
//  CertGetSubjectCertificateFromStore and
//  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
//  special KEYID Issuer and SerialNumber, they do a KEYID match.
//--------------------------------------------------------------------------
typedef struct _CMSG_SIGNER_INFO {
    DWORD                       dwVersion;
    CERT_NAME_BLOB              Issuer;
    CRYPT_INTEGER_BLOB          SerialNumber;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;

    // This is also referred to as the SignatureAlgorithm
    CRYPT_ALGORITHM_IDENTIFIER  HashEncryptionAlgorithm;

    CRYPT_DATA_BLOB             EncryptedHash;
    CRYPT_ATTRIBUTES            AuthAttrs;
    CRYPT_ATTRIBUTES            UnauthAttrs;
} CMSG_SIGNER_INFO, *PCMSG_SIGNER_INFO;


//+-------------------------------------------------------------------------
//  CMSG_SIGNER_CERT_ID_PARAM
//
//  To get all the signers, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. SignerCount - 1.
//
//  pvData points to a CERT_ID struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CMS_SIGNER_INFO_PARAM
//
//  Same as CMSG_SIGNER_INFO_PARAM, except, contains SignerId instead of
//  Issuer and SerialNumber.
//
//  To get all the signers, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. SignerCount - 1.
//
//  pvData points to a CMSG_CMS_SIGNER_INFO struct.
//--------------------------------------------------------------------------
typedef struct _CMSG_CMS_SIGNER_INFO {
    DWORD                       dwVersion;
    CERT_ID                     SignerId;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;

    // This is also referred to as the SignatureAlgorithm
    CRYPT_ALGORITHM_IDENTIFIER  HashEncryptionAlgorithm;

    CRYPT_DATA_BLOB             EncryptedHash;
    CRYPT_ATTRIBUTES            AuthAttrs;
    CRYPT_ATTRIBUTES            UnauthAttrs;
} CMSG_CMS_SIGNER_INFO, *PCMSG_CMS_SIGNER_INFO;


//+-------------------------------------------------------------------------
//  CMSG_SIGNER_HASH_ALGORITHM_PARAM
//
//  This parameter specifies the HashAlgorithm that was used for the signer.
//
//  Set dwIndex to iterate through all the signers.
//
//  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_SIGNER_AUTH_ATTR_PARAM
//
//  The authenticated attributes for the signer.
//
//  Set dwIndex to iterate through all the signers.
//
//  pvData points to a CMSG_ATTR struct.
//--------------------------------------------------------------------------
typedef CRYPT_ATTRIBUTES CMSG_ATTR;
typedef CRYPT_ATTRIBUTES *PCMSG_ATTR;

//+-------------------------------------------------------------------------
//  CMSG_SIGNER_UNAUTH_ATTR_PARAM
//
//  The unauthenticated attributes for the signer.
//
//  Set dwIndex to iterate through all the signers.
//
//  pvData points to a CMSG_ATTR struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CERT_COUNT_PARAM
//
//  Count of certificates in a SIGNED or SIGNED_AND_ENVELOPED message.
//
//  CMS, also supports certificates in an ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CERT_PARAM
//
//  To get all the certificates, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. CertCount - 1.
//
//  pvData points to an array of the certificate's encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CRL_COUNT_PARAM
//
//  Count of CRLs in a SIGNED or SIGNED_AND_ENVELOPED message.
//
//  CMS, also supports CRLs in an ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CRL_PARAM
//
//  To get all the CRLs, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. CrlCount - 1.
//
//  pvData points to an array of the CRL's encoded bytes.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  CMSG_ENVELOPE_ALGORITHM_PARAM
//
//  The ContentEncryptionAlgorithm that was used in
//  an ENVELOPED or SIGNED_AND_ENVELOPED message.
//
//  For streaming you must be able to successfully get this parameter before
//  doing a CryptMsgControl decrypt.
//
//  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_RECIPIENT_COUNT_PARAM
//
//  Count of recipients in an ENVELOPED or SIGNED_AND_ENVELOPED message.
//
//  Count of key transport recepients.
//
//  The CMSG_CMS_RECIPIENT_COUNT_PARAM has the total count of
//  recipients (it also includes key agree and mail list recipients).
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_RECIPIENT_INDEX_PARAM
//
//  Index of the recipient used to decrypt an ENVELOPED or SIGNED_AND_ENVELOPED
//  message.
//
//  Index of a key transport recipient. If a non key transport
//  recipient was used to decrypt, fails with LastError set to
//  CRYPT_E_INVALID_INDEX.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_RECIPIENT_INFO_PARAM
//
//  To get all the recipients, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. RecipientCount - 1.
//
//  Only returns the key transport recepients.
//
//  The CMSG_CMS_RECIPIENT_INFO_PARAM returns all recipients.
//
//  pvData points to a CERT_INFO struct.
//
//  Only the following fields have been updated in the CERT_INFO struct:
//  Issuer, SerialNumber and PublicKeyAlgorithm. The PublicKeyAlgorithm
//  specifies the KeyEncryptionAlgorithm that was used.
//
//  Note, if the KEYID choice was selected for a key transport recipient, then,
//  the SerialNumber is 0 and the Issuer is encoded containing a single RDN
//  with a single Attribute whose OID is szOID_KEYID_RDN, value type is
//  CERT_RDN_OCTET_STRING and value is the KEYID. When the
//  CertGetSubjectCertificateFromStore and
//  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
//  special KEYID Issuer and SerialNumber, they do a KEYID match.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_HASH_ALGORITHM_PARAM
//
//  The HashAlgorithm in a HASHED message.
//
//  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_HASH_DATA_PARAM
//
//  The hash in a HASHED message.
//
//  pvData points to an array of bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_COMPUTED_HASH_PARAM
//
//  The computed hash for a HASHED message.
//  This may be called for either an encoded or decoded message.
//
//  Also, the computed hash for one of the signer's in a SIGNED message.
//  It may be called for either an encoded or decoded message after the
//  final update.  Set dwIndex to iterate through all the signers.
//
//  pvData points to an array of bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_ENCRYPT_PARAM
//
//  The ContentEncryptionAlgorithm that was used in an ENCRYPTED message.
//
//  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_ENCODED_MESSAGE
//
//  The full encoded message. This is useful in the case of a decoded
//  message which has been modified (eg. a signed-data or
//  signed-and-enveloped-data message which has been countersigned).
//
//  pvData points to an array of the message's encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_VERSION_PARAM
//
//  The version of the decoded message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

#define CMSG_SIGNED_DATA_V1                     1
#define CMSG_SIGNED_DATA_V3                     3
#define CMSG_SIGNED_DATA_PKCS_1_5_VERSION       CMSG_SIGNED_DATA_V1
#define CMSG_SIGNED_DATA_CMS_VERSION            CMSG_SIGNED_DATA_V3

#define CMSG_SIGNER_INFO_V1                     1
#define CMSG_SIGNER_INFO_V3                     3
#define CMSG_SIGNER_INFO_PKCS_1_5_VERSION       CMSG_SIGNER_INFO_V1
#define CMSG_SIGNER_INFO_CMS_VERSION            CMSG_SIGNER_INFO_V3

#define CMSG_HASHED_DATA_V0                     0
#define CMSG_HASHED_DATA_V2                     2
#define CMSG_HASHED_DATA_PKCS_1_5_VERSION       CMSG_HASHED_DATA_V0
#define CMSG_HASHED_DATA_CMS_VERSION            CMSG_HASHED_DATA_V2

#define CMSG_ENVELOPED_DATA_V0                  0
#define CMSG_ENVELOPED_DATA_V2                  2
#define CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION    CMSG_ENVELOPED_DATA_V0
#define CMSG_ENVELOPED_DATA_CMS_VERSION         CMSG_ENVELOPED_DATA_V2

//+-------------------------------------------------------------------------
//  CMSG_ATTR_CERT_COUNT_PARAM
//
//  Count of attribute certificates in a SIGNED or ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_ATTR_CERT_PARAM
//
//  To get all the attribute certificates, repetitively call CryptMsgGetParam,
//  with dwIndex set to 0 .. AttrCertCount - 1.
//
//  pvData points to an array of the attribute certificate's encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CMS_RECIPIENT_COUNT_PARAM
//
//  Count of all CMS recipients in an ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CMS_RECIPIENT_INDEX_PARAM
//
//  Index of the CMS recipient used to decrypt an ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM
//
//  For a CMS key agreement recipient, the index of the encrypted key
//  used to decrypt an ENVELOPED message.
//
//  pvData points to a DWORD
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CMS_RECIPIENT_INFO_PARAM
//
//  To get all the CMS recipients, repetitively call CryptMsgGetParam, with
//  dwIndex set to 0 .. CmsRecipientCount - 1.
//
//  pvData points to a CMSG_CMS_RECIPIENT_INFO struct.
//--------------------------------------------------------------------------

typedef struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
    DWORD                       dwVersion;

    // Currently, only ISSUER_SERIAL_NUMBER or KEYID choices
    CERT_ID                     RecipientId;

    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedKey;
} CMSG_KEY_TRANS_RECIPIENT_INFO, *PCMSG_KEY_TRANS_RECIPIENT_INFO;

typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
    // Currently, only ISSUER_SERIAL_NUMBER or KEYID choices
    CERT_ID                     RecipientId;

    CRYPT_DATA_BLOB             EncryptedKey;

    // The following optional fields are only applicable to KEYID choice
    FILETIME                    Date;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
} CMSG_RECIPIENT_ENCRYPTED_KEY_INFO, *PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO;

typedef struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
    DWORD                       dwVersion;
    DWORD                       dwOriginatorChoice;
    union {
        // CMSG_KEY_AGREE_ORIGINATOR_CERT
        CERT_ID                     OriginatorCertId;
        // CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY
        CERT_PUBLIC_KEY_INFO        OriginatorPublicKeyInfo;
    };
    CRYPT_DATA_BLOB             UserKeyingMaterial;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;

    DWORD                                cRecipientEncryptedKeys;
    PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO   *rgpRecipientEncryptedKeys;
} CMSG_KEY_AGREE_RECIPIENT_INFO, *PCMSG_KEY_AGREE_RECIPIENT_INFO;

#define CMSG_KEY_AGREE_ORIGINATOR_CERT         1
#define CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY   2


typedef struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
    DWORD                       dwVersion;
    CRYPT_DATA_BLOB             KeyId;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedKey;

    // The following fields are optional
    FILETIME                    Date;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
} CMSG_MAIL_LIST_RECIPIENT_INFO, *PCMSG_MAIL_LIST_RECIPIENT_INFO;

typedef struct _CMSG_CMS_RECIPIENT_INFO {
    DWORD   dwRecipientChoice;
    union {
        // CMSG_KEY_TRANS_RECIPIENT
        PCMSG_KEY_TRANS_RECIPIENT_INFO   pKeyTrans;
        // CMSG_KEY_AGREE_RECIPIENT
        PCMSG_KEY_AGREE_RECIPIENT_INFO   pKeyAgree;
        // CMSG_MAIL_LIST_RECIPIENT
        PCMSG_MAIL_LIST_RECIPIENT_INFO   pMailList;
    };
} CMSG_CMS_RECIPIENT_INFO, *PCMSG_CMS_RECIPIENT_INFO;


// dwVersion numbers for the KeyTrans, KeyAgree and MailList recipients
#define CMSG_ENVELOPED_RECIPIENT_V0             0
#define CMSG_ENVELOPED_RECIPIENT_V2             2
#define CMSG_ENVELOPED_RECIPIENT_V3             3
#define CMSG_ENVELOPED_RECIPIENT_V4             4
#define CMSG_KEY_TRANS_PKCS_1_5_VERSION         CMSG_ENVELOPED_RECIPIENT_V0
#define CMSG_KEY_TRANS_CMS_VERSION              CMSG_ENVELOPED_RECIPIENT_V2
#define CMSG_KEY_AGREE_VERSION                  CMSG_ENVELOPED_RECIPIENT_V3
#define CMSG_MAIL_LIST_VERSION                  CMSG_ENVELOPED_RECIPIENT_V4

//+-------------------------------------------------------------------------
//  CMSG_UNPROTECTED_ATTR_PARAM
//
//  The unprotected attributes in the envelped message.
//
//  pvData points to a CMSG_ATTR struct.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Perform a special "control" function after the final CryptMsgUpdate of a
//  encoded/decoded cryptographic message.
//
//  The dwCtrlType parameter specifies the type of operation to be performed.
//
//  The pvCtrlPara definition depends on the dwCtrlType value.
//
//  See below for a list of the control operations and their pvCtrlPara
//  type definition.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgControl(
    __in HCRYPTMSG hCryptMsg,
    __in DWORD dwFlags,
    __in DWORD dwCtrlType,
    __in_opt void const *pvCtrlPara
    );

//+-------------------------------------------------------------------------
//  Message control types
//--------------------------------------------------------------------------
#define CMSG_CTRL_VERIFY_SIGNATURE       1
#define CMSG_CTRL_DECRYPT                2
#define CMSG_CTRL_VERIFY_HASH            5
#define CMSG_CTRL_ADD_SIGNER             6
#define CMSG_CTRL_DEL_SIGNER             7
#define CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR 8
#define CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR 9
#define CMSG_CTRL_ADD_CERT               10
#define CMSG_CTRL_DEL_CERT               11
#define CMSG_CTRL_ADD_CRL                12
#define CMSG_CTRL_DEL_CRL                13
#define CMSG_CTRL_ADD_ATTR_CERT          14
#define CMSG_CTRL_DEL_ATTR_CERT          15
#define CMSG_CTRL_KEY_TRANS_DECRYPT      16
#define CMSG_CTRL_KEY_AGREE_DECRYPT      17
#define CMSG_CTRL_MAIL_LIST_DECRYPT      18
#define CMSG_CTRL_VERIFY_SIGNATURE_EX    19
#define CMSG_CTRL_ADD_CMS_SIGNER_INFO    20

//+-------------------------------------------------------------------------
//  CMSG_CTRL_VERIFY_SIGNATURE
//
//  Verify the signature of a SIGNED or SIGNED_AND_ENVELOPED
//  message after it has been decoded.
//
//  For a SIGNED_AND_ENVELOPED message, called after
//  CryptMsgControl(CMSG_CTRL_DECRYPT), if CryptMsgOpenToDecode was called
//  with a NULL pRecipientInfo.
//
//  pvCtrlPara points to a CERT_INFO struct.
//
//  The CERT_INFO contains the Issuer and SerialNumber identifying
//  the Signer of the message. The CERT_INFO also contains the
//  PublicKeyInfo
//  used to verify the signature. The cryptographic provider specified
//  in CryptMsgOpenToDecode is used.
//
//  Note, if the message contains CMS signers identified by KEYID, then,
//  the CERT_INFO's Issuer and SerialNumber is ignored and only the public
//  key is used to find a signer whose signature verifies.
//
//  The following CMSG_CTRL_VERIFY_SIGNATURE_EX should be used instead.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_VERIFY_SIGNATURE_EX
//
//  Verify the signature of a SIGNED message after it has been decoded.
//
//  pvCtrlPara points to the following CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA.
//
//  If hCryptProv is NULL, uses the cryptographic provider specified in
//  CryptMsgOpenToDecode. If CryptMsgOpenToDecode's hCryptProv is also NULL,
//  gets default provider according to the signer's public key OID.
//
//  dwSignerIndex is the index of the signer to use to verify the signature.
//
//  The signer can be a pointer to a CERT_PUBLIC_KEY_INFO, certificate
//  context or a chain context.
//
//  If the signer's HashEncryptionAlgorithm is szOID_PKIX_NO_SIGNATURE, then,
//  the signature is expected to contain the hash octets. Only dwSignerType
//  of CMSG_VERIFY_SIGNER_NULL may be specified to verify this no signature
//  case.
//--------------------------------------------------------------------------
typedef struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
    DWORD               cbSize;
    HCRYPTPROV_LEGACY   hCryptProv;
    DWORD               dwSignerIndex;
    DWORD               dwSignerType;
    void                *pvSigner;
} CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA, *PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;

// Signer Types
#define CMSG_VERIFY_SIGNER_PUBKEY                   1
    // pvSigner :: PCERT_PUBLIC_KEY_INFO
#define CMSG_VERIFY_SIGNER_CERT                     2
    // pvSigner :: PCCERT_CONTEXT
#define CMSG_VERIFY_SIGNER_CHAIN                    3
    // pvSigner :: PCCERT_CHAIN_CONTEXT
#define CMSG_VERIFY_SIGNER_NULL                     4
    // pvSigner :: NULL


//+-------------------------------------------------------------------------
//  CMSG_CTRL_DECRYPT
//
//  Decrypt an ENVELOPED or SIGNED_AND_ENVELOPED message after it has been
//  decoded.
//
//  This decrypt is only applicable to key transport recipients.
//
//  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
//  0, defaults to AT_KEYEXCHANGE.
//
//  hNCryptKey can be set to decrypt using a CNG private key.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
//  to CryptMsgControl, then, the hCryptProv is released on the final
//  CryptMsgClose. Not released if CryptMsgControl fails. Also applies
//  to freeing the hNCryptKey.
//
//  dwRecipientIndex is the index of the recipient in the message associated
//  with the hCryptProv's or hNCryptKey's private key.
//
//  The dwRecipientIndex is the index of a key transport recipient.
//
//  Note, the message can only be decrypted once.
//--------------------------------------------------------------------------
typedef struct _CMSG_CTRL_DECRYPT_PARA {
    DWORD       cbSize;

    // NCryptIsKeyHandle() is called to determine the union choice.
    union {
        HCRYPTPROV                  hCryptProv;
        NCRYPT_KEY_HANDLE           hNCryptKey;
    };

    // not applicable for hNCryptKey choice
    DWORD       dwKeySpec;

    DWORD       dwRecipientIndex;
} CMSG_CTRL_DECRYPT_PARA, *PCMSG_CTRL_DECRYPT_PARA;


//+-------------------------------------------------------------------------
//  CMSG_CTRL_KEY_TRANS_DECRYPT
//
//  Decrypt an ENVELOPED message after it has been decoded for a key
//  transport recipient.
//
//  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
//  0, defaults to AT_KEYEXCHANGE.
//
//  hNCryptKey can be set to decrypt using a CNG private key.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
//  to CryptMsgControl, then, the hCryptProv is released on the final
//  CryptMsgClose. Not released if CryptMsgControl fails. Also applies
//  to freeing the hNCryptKey.
//
//  pKeyTrans points to the CMSG_KEY_TRANS_RECIPIENT_INFO obtained via
//  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)
//
//  dwRecipientIndex is the index of the recipient in the message associated
//  with the hCryptProv's or hNCryptKey's private key.
//
//  Note, the message can only be decrypted once.
//--------------------------------------------------------------------------
typedef struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
    DWORD                           cbSize;
    // NCryptIsKeyHandle() is called to determine the union choice.
    union {
        HCRYPTPROV                  hCryptProv;
        NCRYPT_KEY_HANDLE           hNCryptKey;
    };

    // not applicable for hNCryptKey choice
    DWORD                           dwKeySpec;

    PCMSG_KEY_TRANS_RECIPIENT_INFO  pKeyTrans;
    DWORD                           dwRecipientIndex;
} CMSG_CTRL_KEY_TRANS_DECRYPT_PARA, *PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA;

//+-------------------------------------------------------------------------
//  CMSG_CTRL_KEY_AGREE_DECRYPT
//
//  Decrypt an ENVELOPED message after it has been decoded for a key
//  agreement recipient.
//
//  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
//  0, defaults to AT_KEYEXCHANGE.
//
//  hNCryptKey can be set to decrypt using a CNG private key.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
//  to CryptMsgControl, then, the hCryptProv is released on the final
//  CryptMsgClose. Not released if CryptMsgControl fails. Also applies
//  to freeing the hNCryptKey.
//
//  pKeyAgree points to the CMSG_KEY_AGREE_RECIPIENT_INFO obtained via
//  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM) for dwRecipientIndex.
//
//  dwRecipientIndex, dwRecipientEncryptedKeyIndex are the indices of the
//  recipient's encrypted key in the message associated with the hCryptProv's
//  or hNCryptKey's private key.
//
//  OriginatorPublicKey is the originator's public key obtained from either
//  the originator's certificate or the CMSG_KEY_AGREE_RECIPIENT_INFO obtained
//  via the CMSG_CMS_RECIPIENT_INFO_PARAM.
//
//  Note, the message can only be decrypted once.
//--------------------------------------------------------------------------
typedef struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
    DWORD                           cbSize;

    // NCryptIsKeyHandle() is called to determine the union choice.
    union {
        HCRYPTPROV                  hCryptProv;
        NCRYPT_KEY_HANDLE           hNCryptKey;
    };

    // not applicable for hNCryptKey choice
    DWORD                           dwKeySpec;

    PCMSG_KEY_AGREE_RECIPIENT_INFO  pKeyAgree;
    DWORD                           dwRecipientIndex;
    DWORD                           dwRecipientEncryptedKeyIndex;
    CRYPT_BIT_BLOB                  OriginatorPublicKey;
} CMSG_CTRL_KEY_AGREE_DECRYPT_PARA, *PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA;


//+-------------------------------------------------------------------------
//  CMSG_CTRL_MAIL_LIST_DECRYPT
//
//  Decrypt an ENVELOPED message after it has been decoded for a mail
//  list recipient.
//
//  pMailList points to the CMSG_MAIL_LIST_RECIPIENT_INFO obtained via
//  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM) for dwRecipientIndex.
//
//  There is 1 choice for the KeyEncryptionKey: an already created CSP key
//  handle. For the key handle choice, hCryptProv must be nonzero. This key
//  handle isn't destroyed.
//
//  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
//  to CryptMsgControl, then, the hCryptProv is released on the final
//  CryptMsgClose. Not released if CryptMsgControl fails.
//
//  For RC2 wrap, the effective key length is obtained from the
//  KeyEncryptionAlgorithm parameters and set on the hKeyEncryptionKey before
//  decrypting.
//
//  Note, the message can only be decrypted once.
//
//  Mail list recipients aren't supported using CNG.
//--------------------------------------------------------------------------
typedef struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
    DWORD                           cbSize;
    HCRYPTPROV                      hCryptProv;
    PCMSG_MAIL_LIST_RECIPIENT_INFO  pMailList;
    DWORD                           dwRecipientIndex;
    DWORD                           dwKeyChoice;
    union {
        // CMSG_MAIL_LIST_HANDLE_KEY_CHOICE
        HCRYPTKEY                       hKeyEncryptionKey;
        // Reserve space for a potential pointer choice
        void                            *pvKeyEncryptionKey;
    };
} CMSG_CTRL_MAIL_LIST_DECRYPT_PARA, *PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA;



//+-------------------------------------------------------------------------
//  CMSG_CTRL_VERIFY_HASH
//
//  Verify the hash of a HASHED message after it has been decoded.
//
//  Only the hCryptMsg parameter is used, to specify the message whose
//  hash is being verified.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_SIGNER
//
//  Add a signer to a signed-data message.
//
//  pvCtrlPara points to a CMSG_SIGNER_ENCODE_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_CMS_SIGNER_INFO
//
//  Add a signer to a signed-data message.
//
//  Differs from the above, CMSG_CTRL_ADD_SIGNER, wherein, the signer info
//  already contains the signature.
//
//  pvCtrlPara points to a CMSG_CMS_SIGNER_INFO.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_DEL_SIGNER
//
//  Remove a signer from a signed-data or signed-and-enveloped-data message.
//
//  pvCtrlPara points to a DWORD containing the 0-based index of the
//  signer to be removed.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR
//
//  Add an unauthenticated attribute to the SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//
//  The unauthenticated attribute is input in the form of an encoded blob.
//--------------------------------------------------------------------------

typedef struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
    DWORD               cbSize;
    DWORD               dwSignerIndex;
    CRYPT_DATA_BLOB     blob;
} CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA, *PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;

//+-------------------------------------------------------------------------
//  CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR
//
//  Delete an unauthenticated attribute from the SignerInfo of a signed-data
//  or signed-and-enveloped-data message.
//
//  The unauthenticated attribute to be removed is specified by
//  a 0-based index.
//--------------------------------------------------------------------------

typedef struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
    DWORD               cbSize;
    DWORD               dwSignerIndex;
    DWORD               dwUnauthAttrIndex;
} CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA, *PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_CERT
//
//  Add a certificate to a signed-data or signed-and-enveloped-data message.
//
//  pvCtrlPara points to a CRYPT_DATA_BLOB containing the certificate's
//  encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_DEL_CERT
//
//  Delete a certificate from a signed-data or signed-and-enveloped-data
//  message.
//
//  pvCtrlPara points to a DWORD containing the 0-based index of the
//  certificate to be removed.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_CRL
//
//  Add a CRL to a signed-data or signed-and-enveloped-data message.
//
//  pvCtrlPara points to a CRYPT_DATA_BLOB containing the CRL's
//  encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_DEL_CRL
//
//  Delete a CRL from a signed-data or signed-and-enveloped-data message.
//
//  pvCtrlPara points to a DWORD containing the 0-based index of the CRL
//  to be removed.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_ADD_ATTR_CERT
//
//  Add an attribute certificate to a signed-data message.
//
//  pvCtrlPara points to a CRYPT_DATA_BLOB containing the attribute
//  certificate's encoded bytes.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CMSG_CTRL_DEL_ATTR_CERT
//
//  Delete an attribute certificate from a signed-data message.
//
//  pvCtrlPara points to a DWORD containing the 0-based index of the
//  attribute certificate to be removed.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level.
//  ie. verify that pbSignerInfoCountersignature contains the encrypted
//  hash of the encryptedDigest field of pbSignerInfo.
//
//  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
//  The only fields referenced from pciCountersigner are SerialNumber, Issuer,
//  and SubjectPublicKeyInfo.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwEncodingType,
    __in_bcount(cbSignerInfo) PBYTE pbSignerInfo,
    __in DWORD cbSignerInfo,
    __in_bcount(cbSignerInfoCountersignature) PBYTE pbSignerInfoCountersignature,
    __in DWORD cbSignerInfoCountersignature,
    __in PCERT_INFO pciCountersigner
    );


//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level.
//  ie. verify that pbSignerInfoCountersignature contains the encrypted
//  hash of the encryptedDigest field of pbSignerInfo.
//
//  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
//
//  The signer can be a CERT_PUBLIC_KEY_INFO, certificate context or a
//  chain context.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncodedEx(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwEncodingType,
    __in_bcount(cbSignerInfo) PBYTE pbSignerInfo,
    __in DWORD cbSignerInfo,
    __in_bcount(cbSignerInfoCountersignature) PBYTE pbSignerInfoCountersignature,
    __in DWORD cbSignerInfoCountersignature,
    __in DWORD dwSignerType,
    __in void *pvSigner,
    __reserved DWORD dwFlags,
    __reserved void *pvReserved
    );


// See CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA for dwSignerType definitions


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature in a message
//
//  dwIndex is a zero-based index of the SignerInfo to be countersigned.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgCountersign(
    __in HCRYPTMSG hCryptMsg,
    __in DWORD dwIndex,
    __in DWORD cCountersigners,
    __in_ecount(cCountersigners) PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    );

//+-------------------------------------------------------------------------
//  Countersign an already-existing signature (encoded SignerInfo).
//  Output an encoded SignerInfo blob, suitable for use as a countersignature
//  attribute in the unauthenticated attributes of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgCountersignEncoded(
    __in DWORD dwEncodingType,
    __in_bcount(cbSignerInfo) PBYTE pbSignerInfo,
    __in DWORD cbSignerInfo,
    __in DWORD cCountersigners,
    __in_ecount(cCountersigners) PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    __out_bcount_part_opt(*pcbCountersignature, *pcbCountersignature) PBYTE pbCountersignature,
    __inout PDWORD pcbCountersignature
    );




//+-------------------------------------------------------------------------
//  CryptMsg OID installable functions
//--------------------------------------------------------------------------

typedef void * (WINAPI *PFN_CMSG_ALLOC) (
    __in size_t cb
    );

typedef void (WINAPI *PFN_CMSG_FREE)(
    __inout void *pv
    );

// Note, the following 3 installable functions are obsolete and have been
// replaced with GenContentEncryptKey, ExportKeyTrans, ExportKeyAgree,
// ExportMailList, ImportKeyTrans, ImportKeyAgree and ImportMailList
// installable functions.

// If *phCryptProv is NULL upon entry, then, if supported, the installable
// function should acquire a default provider and return. Note, its up
// to the installable function to release at process detach.
//
// If paiEncrypt->Parameters.cbData is 0, then, the callback may optionally
// return default encoded parameters in *ppbEncryptParameters and
// *pcbEncryptParameters. pfnAlloc must be called for the allocation.
#define CMSG_OID_GEN_ENCRYPT_KEY_FUNC   "CryptMsgDllGenEncryptKey"
typedef __success(return == TRUE) BOOL (WINAPI *PFN_CMSG_GEN_ENCRYPT_KEY) (
    __inout HCRYPTPROV *phCryptProv,
    __in PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    __in_opt PVOID pvEncryptAuxInfo,
    __in PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    __callback PFN_CMSG_ALLOC pfnAlloc,
    __out HCRYPTKEY *phEncryptKey,
    __deref_out_bcount(*pcbEncryptParameters) PBYTE *ppbEncryptParameters,
    __out PDWORD pcbEncryptParameters
    );

#define CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC   "CryptMsgDllExportEncryptKey"
typedef BOOL (WINAPI *PFN_CMSG_EXPORT_ENCRYPT_KEY) (
    __in HCRYPTPROV hCryptProv,
    __in HCRYPTKEY hEncryptKey,
    __in PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    __out_bcount_part_opt(*pcbData, *pcbData) PBYTE pbData,
    __inout PDWORD pcbData
    );

#define CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC   "CryptMsgDllImportEncryptKey"
typedef BOOL (WINAPI *PFN_CMSG_IMPORT_ENCRYPT_KEY) (
    __in HCRYPTPROV hCryptProv,
    __in DWORD dwKeySpec,
    __in PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    __in PCRYPT_ALGORITHM_IDENTIFIER paiPubKey,
    __in_bcount(cbEncodedKey) PBYTE pbEncodedKey,
    __in DWORD cbEncodedKey,
    __out HCRYPTKEY *phEncryptKey
    );


// To get the default installable function for GenContentEncryptKey,
// ExportKeyTrans, ExportKeyAgree, ExportMailList, ImportKeyTrans,
// ImportKeyAgree or ImportMailList call CryptGetOIDFunctionAddress()
// with the pszOID argument set to the following constant. dwEncodingType
// should be set to CRYPT_ASN_ENCODING or X509_ASN_ENCODING.
#define CMSG_DEFAULT_INSTALLABLE_FUNC_OID   ((LPCSTR) 1)

//+-------------------------------------------------------------------------
//  Content Encrypt Info
//
//  The following data structure contains the information shared between
//  the GenContentEncryptKey and the ExportKeyTrans, ExportKeyAgree and
//  ExportMailList installable functions.
//
//  For a ContentEncryptionAlgorithm.pszObjId having a "Special" algid, only
//  supported via CNG, for example, AES, then, fCNG will be set.
//  fCNG will also be set to TRUE for any ECC agreement or OAEP RSA transport
//  recipients.
//
//  When, fCNG is TRUE, the hCNGContentEncryptKey choice is selected and
//  pbCNGContentEncryptKeyObject and pbContentEncryptKey will be pfnAlloc'ed.
//--------------------------------------------------------------------------
typedef struct _CMSG_CONTENT_ENCRYPT_INFO {
    DWORD                       cbSize;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    void                        *pvEncryptionAuxInfo;
    DWORD                       cRecipients;
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
    PFN_CMSG_ALLOC              pfnAlloc;
    PFN_CMSG_FREE               pfnFree;
    DWORD                       dwEncryptFlags;
    union {
        // fCNG == FALSE
        HCRYPTKEY                   hContentEncryptKey;
        // fCNG == TRUE
        BCRYPT_KEY_HANDLE           hCNGContentEncryptKey;
    };
    DWORD                       dwFlags;

    BOOL                        fCNG;
    // When fCNG == TRUE, pfnAlloc'ed
    BYTE                        *pbCNGContentEncryptKeyObject;
    BYTE                        *pbContentEncryptKey;
    DWORD                       cbContentEncryptKey;
} CMSG_CONTENT_ENCRYPT_INFO, *PCMSG_CONTENT_ENCRYPT_INFO;

#define CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG   0x00000001

#define CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG         0x00000001
#define CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG        0x00000002
#define CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG   0x00008000

//+-------------------------------------------------------------------------
// Upon input, ContentEncryptInfo has been initialized from the
// EnvelopedEncodeInfo.
//
// Note, if rgpRecipients instead of rgCmsRecipients are set in the
// EnvelopedEncodeInfo, then, the rgpRecipients have been converted
// to rgCmsRecipients in the ContentEncryptInfo.
//
// For fCNG == FALSE, the following fields may be changed in ContentEncryptInfo:
//      hContentEncryptKey
//      hCryptProv
//      ContentEncryptionAlgorithm.pszObjId
//      ContentEncryptionAlgorithm.Parameters
//      dwFlags
//
// For fCNG == TRUE, the following fields may be changed in ContentEncryptInfo:
//      hCNGContentEncryptKey
//      pbCNGContentEncryptKeyObject
//      pbContentEncryptKey
//      cbContentEncryptKey
//      ContentEncryptionAlgorithm.pszObjId
//      ContentEncryptionAlgorithm.Parameters
//      dwFlags
//
// All other fields in the ContentEncryptInfo are READONLY.
//
// If CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG is set upon entry
// in dwEncryptFlags, then, any potentially variable length encoded
// output should be padded with zeroes to always obtain the
// same maximum encoded length. This is necessary for
// CryptMsgCalculateEncodedLength() or CryptMsgOpenToEncode() with
// definite length streaming.
//
// For fCNG == FALSE:
//      The hContentEncryptKey must be updated.
//
//      If hCryptProv is NULL upon input, then, it must be updated.
//      If a HCRYPTPROV is acquired that must be released, then, the
//      CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG must be set in dwFlags.
// Otherwise, for fCNG == TRUE:
//      The hCNGContentEncryptKey and cbContentEncryptKey must be updated and
//      pbCNGContentEncryptKeyObject and pbContentEncryptKey pfnAlloc'ed.
//      This key will be freed and destroyed when hCryptMsg is closed.
//
// If ContentEncryptionAlgorithm.pszObjId is changed, then, the
// CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG must be set in dwFlags.
// If ContentEncryptionAlgorithm.Parameters is updated, then, the
// CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags. pfnAlloc and
// pfnFree must be used for doing the allocation.
//
// ContentEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
//--------------------------------------------------------------------------

// The following CAPI1 installable function is called when fCNG == FALSE.
#define CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC  "CryptMsgDllGenContentEncryptKey"
#define CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC

typedef BOOL (WINAPI *PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY) (
    __inout PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

// The following installable function is called when fCNG == TRUE. It has the
// same API signature as for the above
// CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC.
#define CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC  "CryptMsgDllCNGGenContentEncryptKey"

//+-------------------------------------------------------------------------
//  Key Transport Encrypt Info
//
//  The following data structure contains the information updated by the
//  ExportKeyTrans installable function.
//--------------------------------------------------------------------------
typedef struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
    DWORD                       cbSize;
    DWORD                       dwRecipientIndex;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedKey;
    DWORD                       dwFlags;
} CMSG_KEY_TRANS_ENCRYPT_INFO, *PCMSG_KEY_TRANS_ENCRYPT_INFO;

#define CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG       0x00000001
#define CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG      0x00000002


//+-------------------------------------------------------------------------
// Upon input, KeyTransEncryptInfo has been initialized from the
// KeyTransEncodeInfo.
//
// The following fields may be changed in KeyTransEncryptInfo:
//      EncryptedKey
//      KeyEncryptionAlgorithm.pszObjId
//      KeyEncryptionAlgorithm.Parameters
//      dwFlags
//
// All other fields in the KeyTransEncryptInfo are READONLY.
//
// The EncryptedKey must be updated. The pfnAlloc and pfnFree specified in
// ContentEncryptInfo must be used for doing the allocation.
//
// If the KeyEncryptionAlgorithm.pszObjId is changed, then, the
// CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG  must be set in dwFlags.
// If the KeyEncryptionAlgorithm.Parameters is updated, then, the
// CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
// The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
// for doing the allocation.
//
// KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
//--------------------------------------------------------------------------

// The following CAPI1 installable function is called when
// pContentEncryptInfo->fCNG == FALSE.
#define CMSG_OID_EXPORT_KEY_TRANS_FUNC  "CryptMsgDllExportKeyTrans"
#define CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC CMSG_OID_EXPORT_KEY_TRANS_FUNC
typedef BOOL (WINAPI *PFN_CMSG_EXPORT_KEY_TRANS) (
    __in PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    __in PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    __inout PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

// The following CNG installable function is called when
// pContentEncryptInfo->fCNG == TRUE. It has the same API signature as for
// the above CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC.
#define CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC  "CryptMsgDllCNGExportKeyTrans"

//+-------------------------------------------------------------------------
//  Key Agree Key Encrypt Info
//
//  The following data structure contains the information updated by the
//  ExportKeyAgree installable function for each encrypted key agree
//  recipient.
//--------------------------------------------------------------------------
typedef struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
    DWORD                       cbSize;
    CRYPT_DATA_BLOB             EncryptedKey;
} CMSG_KEY_AGREE_KEY_ENCRYPT_INFO, *PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO;

//+-------------------------------------------------------------------------
//  Key Agree Encrypt Info
//
//  The following data structure contains the information applicable to
//  all recipients. Its updated by the ExportKeyAgree installable function.
//--------------------------------------------------------------------------
typedef struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
    DWORD                       cbSize;
    DWORD                       dwRecipientIndex;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    CRYPT_DATA_BLOB             UserKeyingMaterial;
    DWORD                       dwOriginatorChoice;
    union {
        // CMSG_KEY_AGREE_ORIGINATOR_CERT
        CERT_ID                     OriginatorCertId;
        // CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY
        CERT_PUBLIC_KEY_INFO        OriginatorPublicKeyInfo;
    };
    DWORD                       cKeyAgreeKeyEncryptInfo;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo;
    DWORD                       dwFlags;
} CMSG_KEY_AGREE_ENCRYPT_INFO, *PCMSG_KEY_AGREE_ENCRYPT_INFO;

#define CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG           0x00000001
#define CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG       0x00000002
#define CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG     0x00000004
#define CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG    0x00000008
#define CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG    0x00000010
#define CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG          0x00000020


//+-------------------------------------------------------------------------
// Upon input, KeyAgreeEncryptInfo has been initialized from the
// KeyAgreeEncodeInfo.
//
// The following fields may be changed in KeyAgreeEncryptInfo:
//      KeyEncryptionAlgorithm.pszObjId
//      KeyEncryptionAlgorithm.Parameters
//      UserKeyingMaterial
//      dwOriginatorChoice
//      OriginatorCertId
//      OriginatorPublicKeyInfo
//      dwFlags
//
// All other fields in the KeyAgreeEncryptInfo are READONLY.
//
// If the KeyEncryptionAlgorithm.pszObjId is changed, then, the
// CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG  must be set in dwFlags.
// If the KeyEncryptionAlgorithm.Parameters is updated, then, the
// CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
// The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
// for doing the allocation.
//
// If the UserKeyingMaterial is updated, then, the
// CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG must be set in dwFlags.
// pfnAlloc and pfnFree must be used for doing the allocation.
//
// The dwOriginatorChoice must be updated to either
// CMSG_KEY_AGREE_ORIGINATOR_CERT or CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY.
//
// If the OriginatorPublicKeyInfo is updated, then, the appropriate
// CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_*_FLAG must be set in dwFlags and
// pfnAlloc and pfnFree must be used for doing the allocation.
//
// If CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG is set upon entry
// in pContentEncryptInfo->dwEncryptFlags, then, the OriginatorPublicKeyInfo's
// Ephemeral PublicKey should be padded with zeroes to always obtain the
// same maximum encoded length. Note, the length of the generated ephemeral Y
// public key can vary depending on the number of leading zero bits.
//
// Upon input, the array of *rgpKeyAgreeKeyEncryptInfo has been initialized.
// The EncryptedKey must be updated for each recipient key.
// The pfnAlloc and pfnFree specified in
// ContentEncryptInfo must be used for doing the allocation.
//
// KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
//--------------------------------------------------------------------------

// The following CAPI1 installable function is called when
// pContentEncryptInfo->fCNG == FALSE.
#define CMSG_OID_EXPORT_KEY_AGREE_FUNC  "CryptMsgDllExportKeyAgree"
#define CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC CMSG_OID_EXPORT_KEY_AGREE_FUNC
typedef BOOL (WINAPI *PFN_CMSG_EXPORT_KEY_AGREE) (
    __in PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    __in PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    __inout PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

// The following CNG installable function is called when
// pContentEncryptInfo->fCNG == TRUE. It has the same API signature as for
// the above CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC.
#define CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC  "CryptMsgDllCNGExportKeyAgree"

//+-------------------------------------------------------------------------
//  Mail List Encrypt Info
//
//  The following data structure contains the information updated by the
//  ExportMailList installable function.
//--------------------------------------------------------------------------
typedef struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
    DWORD                       cbSize;
    DWORD                       dwRecipientIndex;
    CRYPT_ALGORITHM_IDENTIFIER  KeyEncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedKey;
    DWORD                       dwFlags;
} CMSG_MAIL_LIST_ENCRYPT_INFO, *PCMSG_MAIL_LIST_ENCRYPT_INFO;

#define CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG       0x00000001
#define CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG      0x00000002


//+-------------------------------------------------------------------------
// Upon input, MailListEncryptInfo has been initialized from the
// MailListEncodeInfo.
//
// The following fields may be changed in MailListEncryptInfo:
//      EncryptedKey
//      KeyEncryptionAlgorithm.pszObjId
//      KeyEncryptionAlgorithm.Parameters
//      dwFlags
//
// All other fields in the MailListEncryptInfo are READONLY.
//
// The EncryptedKey must be updated. The pfnAlloc and pfnFree specified in
// ContentEncryptInfo must be used for doing the allocation.
//
// If the KeyEncryptionAlgorithm.pszObjId is changed, then, the
// CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG must be set in dwFlags.
// If the KeyEncryptionAlgorithm.Parameters is updated, then, the
// CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
// The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
// for doing the allocation.
//
// KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
//
// Note, only has a CAPI1 installable function. No CNG installable function.
//--------------------------------------------------------------------------
// The following CAPI1 installable function is called when
// pContentEncryptInfo->fCNG == FALSE.
#define CMSG_OID_EXPORT_MAIL_LIST_FUNC  "CryptMsgDllExportMailList"
#define CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC CMSG_OID_EXPORT_MAIL_LIST_FUNC
typedef BOOL (WINAPI *PFN_CMSG_EXPORT_MAIL_LIST) (
    __in PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    __in PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    __inout PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );


//+-------------------------------------------------------------------------
// CAPI1 OID Installable functions for importing an encoded and encrypted
// content encryption key.
//
// There's a different installable function for each CMS Recipient choice:
//  ImportKeyTrans
//  ImportKeyAgree
//  ImportMailList
//
// Iterates through the following OIDs to get the OID installable function:
//   KeyEncryptionOID!ContentEncryptionOID
//   KeyEncryptionOID
//   ContentEncryptionOID
//
// If the OID installable function doesn't support the specified
// KeyEncryption and ContentEncryption OIDs, then, return FALSE with
// LastError set to E_NOTIMPL.
//--------------------------------------------------------------------------
#define CMSG_OID_IMPORT_KEY_TRANS_FUNC   "CryptMsgDllImportKeyTrans"
#define CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC CMSG_OID_IMPORT_KEY_TRANS_FUNC
typedef BOOL (WINAPI *PFN_CMSG_IMPORT_KEY_TRANS) (
    __in PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    __in PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out HCRYPTKEY *phContentEncryptKey
    );

#define CMSG_OID_IMPORT_KEY_AGREE_FUNC   "CryptMsgDllImportKeyAgree"
#define CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC CMSG_OID_IMPORT_KEY_AGREE_FUNC
typedef BOOL (WINAPI *PFN_CMSG_IMPORT_KEY_AGREE) (
    __in PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    __in PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out HCRYPTKEY *phContentEncryptKey
    );

#define CMSG_OID_IMPORT_MAIL_LIST_FUNC   "CryptMsgDllImportMailList"
#define CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC  CMSG_OID_IMPORT_MAIL_LIST_FUNC
typedef BOOL (WINAPI *PFN_CMSG_IMPORT_MAIL_LIST) (
    __in PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    __in PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out HCRYPTKEY *phContentEncryptKey
    );

//+-------------------------------------------------------------------------
//  CNG Content Decrypt Info
//
//  The following data structure contains the information shared between
//  CNGImportKeyTrans, CNGImportKeyAgree and CNGImportContentEncryptKey
//  installable functions.
//
//  pbContentEncryptKey and pbCNGContentEncryptKeyObject are allocated
//  and freed via pfnAlloc and pfnFree.
//--------------------------------------------------------------------------
typedef struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
    DWORD                       cbSize;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PFN_CMSG_ALLOC              pfnAlloc;
    PFN_CMSG_FREE               pfnFree;

    // This key must be used over the one in the DecryptPara. An
    // HCRYPTPROV in the DecryptPara may have been converted to a
    // NCRYPT_KEY_HANDLE.
    NCRYPT_KEY_HANDLE           hNCryptKey;

    BYTE                        *pbContentEncryptKey;
    DWORD                       cbContentEncryptKey;

    BCRYPT_KEY_HANDLE           hCNGContentEncryptKey;
    BYTE                        *pbCNGContentEncryptKeyObject;
} CMSG_CNG_CONTENT_DECRYPT_INFO, *PCMSG_CNG_CONTENT_DECRYPT_INFO;


//+-------------------------------------------------------------------------
// CNG OID Installable function for importing and decrypting a key transport
// recipient encrypted content encryption key.
//
// Upon input, CNGContentDecryptInfo has been initialized.
//
// The following fields must be updated using hNCryptKey to decrypt
// pKeyTransDecryptPara->pKeyTrans->EncryptedKey.
//      pbContentEncryptKey (pfnAlloc'ed)
//      cbContentEncryptKey
//
// All other fields in the CNGContentEncryptInfo are READONLY.
//
// pKeyTransDecryptPara->pKeyTrans->KeyEncryptionAlgorithm.pszObjId is used
// to get the OIDFunctionAddress.
//--------------------------------------------------------------------------
#define CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC  "CryptMsgDllCNGImportKeyTrans"
typedef BOOL (WINAPI *PFN_CMSG_CNG_IMPORT_KEY_TRANS) (
    __inout PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
    __in PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

//+-------------------------------------------------------------------------
// CNG OID Installable function for importing and decrypting a key agreement
// recipient encrypted content encryption key.
//
// Upon input, CNGContentDecryptInfo has been initialized.
//
// The following fields must be updated using hNCryptKey to decrypt
// pKeyAgreeDecryptPara->pKeyAgree->rgpRecipientEncryptedKeys[
//  pKeyAgreeDecryptPara->dwRecipientEncryptedKeyIndex]->EncryptedKey.
//      pbContentEncryptKey (pfnAlloc'ed)
//      cbContentEncryptKey
//
// All other fields in the CNGContentEncryptInfo are READONLY.
//
// pKeyAgreeDecryptPara->pKeyAgree->KeyEncryptionAlgorithm.pszObjId is used
// to get the OIDFunctionAddress.
//--------------------------------------------------------------------------
#define CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC   "CryptMsgDllCNGImportKeyAgree"
typedef BOOL (WINAPI *PFN_CMSG_CNG_IMPORT_KEY_AGREE) (
    __inout PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
    __in PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

//+-------------------------------------------------------------------------
// CNG OID Installable function for importing an already decrypted
// content encryption key.
//
// Upon input, CNGContentDecryptInfo has been initialized.
//
// The following fields must be updated using pbContentEncryptKey and
// cbContentEncryptKey:
//      hCNGContentEncryptKey
//      pbCNGContentEncryptKeyObject (pfnAlloc'ed)
//
// The hCNGContentEncryptKey will be destroyed when hCryptMsg is closed.
//
// All other fields in the CNGContentEncryptInfo are READONLY.
//
// ContentEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
//--------------------------------------------------------------------------
#define CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC  "CryptMsgDllCNGImportContentEncryptKey"
typedef BOOL (WINAPI *PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY) (
    __inout PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );


//+=========================================================================
//  Certificate Store Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//              In its most basic implementation, a cert store is simply a
//              collection of certificates and/or CRLs. This is the case when
//              a cert store is opened with all of its certificates and CRLs
//              coming from a PKCS #7 encoded cryptographic message.
//
//              Nonetheless, all cert stores have the following properties:
//               - A public key may have more than one certificate in the store.
//                 For example, a private/public key used for signing may have a
//                 certificate issued for VISA and another issued for
//                 Mastercard. Also, when a certificate is renewed there might
//                 be more than one certificate with the same subject and
//                 issuer.
//               - However, each certificate in the store is uniquely
//                 identified by its Issuer and SerialNumber.
//               - There's an issuer of subject certificate relationship. A
//                 certificate's issuer is found by doing a match of
//                 pSubjectCert->Issuer with pIssuerCert->Subject.
//                 The relationship is verified by using
//                 the issuer's public key to verify the subject certificate's
//                 signature. Note, there might be X.509 v3 extensions
//                 to assist in finding the issuer certificate.
//               - Since issuer certificates might be renewed, a subject
//                 certificate might have more than one issuer certificate.
//               - There's an issuer of CRL relationship. An
//                 issuer's CRL is found by doing a match of
//                 pIssuerCert->Subject with pCrl->Issuer.
//                 The relationship is verified by using
//                 the issuer's public key to verify the CRL's
//                 signature. Note, there might be X.509 v3 extensions
//                 to assist in finding the CRL.
//               - Since some issuers might support the X.509 v3 delta CRL
//                 extensions, an issuer might have more than one CRL.
//               - The store shouldn't have any redundant certificates or
//                 CRLs. There shouldn't be two certificates with the same
//                 Issuer and SerialNumber. There shouldn't be two CRLs with
//                 the same Issuer, ThisUpdate and NextUpdate.
//               - The store has NO policy or trust information. No
//                 certificates are tagged as being "root". Its up to
//                 the application to maintain a list of CertIds (Issuer +
//                 SerialNumber) for certificates it trusts.
//               - The store might contain bad certificates and/or CRLs.
//                 The issuer's signature of a subject certificate or CRL may
//                 not verify. Certificates or CRLs may not satisfy their
//                 time validity requirements. Certificates may be
//                 revoked.
//
//              In addition to the certificates and CRLs, properties can be
//              stored. There are two predefined property IDs for a user
//              certificate: CERT_KEY_PROV_HANDLE_PROP_ID and
//              CERT_KEY_PROV_INFO_PROP_ID. The CERT_KEY_PROV_HANDLE_PROP_ID
//              is a HCRYPTPROV handle to the private key assoicated
//              with the certificate. The CERT_KEY_PROV_INFO_PROP_ID contains
//              information to be used to call
//              CryptAcquireContext and CryptSetProvParam to get a handle
//              to the private key associated with the certificate.
//
//              There exists two more predefined property IDs for certificates
//              and CRLs, CERT_SHA1_HASH_PROP_ID and CERT_MD5_HASH_PROP_ID.
//              If these properties don't already exist, then, a hash of the
//              content is computed. (CERT_HASH_PROP_ID maps to the default
//              hash algorithm, currently, CERT_SHA1_HASH_PROP_ID).
//
//              There are additional APIs for creating certificate and CRL
//      contexts not in a store (CertCreateCertificateContext and
//      CertCreateCRLContext).
//
//--------------------------------------------------------------------------


typedef void *HCERTSTORE;

//+-------------------------------------------------------------------------
//  Certificate context.
//
//  A certificate context contains both the encoded and decoded representation
//  of a certificate. A certificate context returned by a cert store function
//  must be freed by calling the CertFreeCertificateContext function. The
//  CertDuplicateCertificateContext function can be called to make a duplicate
//  copy (which also must be freed by calling CertFreeCertificateContext).
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_CONTEXT {
    DWORD                   dwCertEncodingType;
    BYTE                    *pbCertEncoded;
    DWORD                   cbCertEncoded;
    PCERT_INFO              pCertInfo;
    HCERTSTORE              hCertStore;
} CERT_CONTEXT, *PCERT_CONTEXT;
typedef const CERT_CONTEXT *PCCERT_CONTEXT;
// certenrolls_end

//+-------------------------------------------------------------------------
//  CRL context.
//
//  A CRL context contains both the encoded and decoded representation
//  of a CRL. A CRL context returned by a cert store function
//  must be freed by calling the CertFreeCRLContext function. The
//  CertDuplicateCRLContext function can be called to make a duplicate
//  copy (which also must be freed by calling CertFreeCRLContext).
//--------------------------------------------------------------------------
typedef struct _CRL_CONTEXT {
    DWORD                   dwCertEncodingType;
    BYTE                    *pbCrlEncoded;
    DWORD                   cbCrlEncoded;
    PCRL_INFO               pCrlInfo;
    HCERTSTORE              hCertStore;
} CRL_CONTEXT, *PCRL_CONTEXT;
typedef const CRL_CONTEXT *PCCRL_CONTEXT;

//+-------------------------------------------------------------------------
//  Certificate Trust List (CTL) context.
//
//  A CTL context contains both the encoded and decoded representation
//  of a CTL. Also contains an opened HCRYPTMSG handle to the decoded
//  cryptographic signed message containing the CTL_INFO as its inner content.
//  pbCtlContent is the encoded inner content of the signed message.
//
//  The CryptMsg APIs can be used to extract additional signer information.
//--------------------------------------------------------------------------
typedef struct _CTL_CONTEXT {
    DWORD                   dwMsgAndCertEncodingType;
    BYTE                    *pbCtlEncoded;
    DWORD                   cbCtlEncoded;
    PCTL_INFO               pCtlInfo;
    HCERTSTORE              hCertStore;
    HCRYPTMSG               hCryptMsg;
    BYTE                    *pbCtlContent;
    DWORD                   cbCtlContent;
} CTL_CONTEXT, *PCTL_CONTEXT;
typedef const CTL_CONTEXT *PCCTL_CONTEXT;


// certenrolld_begin -- CERT_*_PROP_ID
//+-------------------------------------------------------------------------
//  Certificate, CRL and CTL property IDs
//
//  See CertSetCertificateContextProperty or CertGetCertificateContextProperty
//  for usage information.
//--------------------------------------------------------------------------
#define CERT_KEY_PROV_HANDLE_PROP_ID        1
#define CERT_KEY_PROV_INFO_PROP_ID          2	// CRYPT_KEY_PROV_INFO
#define CERT_SHA1_HASH_PROP_ID              3
#define CERT_MD5_HASH_PROP_ID               4
#define CERT_HASH_PROP_ID                   CERT_SHA1_HASH_PROP_ID
#define CERT_KEY_CONTEXT_PROP_ID            5
#define CERT_KEY_SPEC_PROP_ID               6
#define CERT_IE30_RESERVED_PROP_ID          7
#define CERT_PUBKEY_HASH_RESERVED_PROP_ID   8
#define CERT_ENHKEY_USAGE_PROP_ID           9
#define CERT_CTL_USAGE_PROP_ID              CERT_ENHKEY_USAGE_PROP_ID
#define CERT_NEXT_UPDATE_LOCATION_PROP_ID   10
#define CERT_FRIENDLY_NAME_PROP_ID          11	// string
#define CERT_PVK_FILE_PROP_ID               12
#define CERT_DESCRIPTION_PROP_ID            13	// string
#define CERT_ACCESS_STATE_PROP_ID           14
#define CERT_SIGNATURE_HASH_PROP_ID         15
#define CERT_SMART_CARD_DATA_PROP_ID        16
#define CERT_EFS_PROP_ID                    17
#define CERT_FORTEZZA_DATA_PROP_ID          18
#define CERT_ARCHIVED_PROP_ID               19
#define CERT_KEY_IDENTIFIER_PROP_ID         20
#define CERT_AUTO_ENROLL_PROP_ID            21	// string:machine DNS name
#define CERT_PUBKEY_ALG_PARA_PROP_ID        22
#define CERT_CROSS_CERT_DIST_POINTS_PROP_ID 23
#define CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID     24
#define CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID    25
#define CERT_ENROLLMENT_PROP_ID             26	// RequestId+CADNS+CACN+Friendly Name
#define CERT_DATE_STAMP_PROP_ID             27
#define CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID  28
#define CERT_SUBJECT_NAME_MD5_HASH_PROP_ID  29
#define CERT_EXTENDED_ERROR_INFO_PROP_ID    30	// string

// Note, 32 - 35 are reserved for the CERT, CRL, CTL and KeyId file element IDs.
//       36 - 63 are reserved for future element IDs.

#define CERT_RENEWAL_PROP_ID                64
#define CERT_ARCHIVED_KEY_HASH_PROP_ID      65	// Encrypted key hash
#define CERT_AUTO_ENROLL_RETRY_PROP_ID      66	// AE_RETRY_INFO:cb+cRetry+FILETIME
#define CERT_AIA_URL_RETRIEVED_PROP_ID      67
#define CERT_AUTHORITY_INFO_ACCESS_PROP_ID  68
#define CERT_BACKED_UP_PROP_ID              69	// VARIANT_BOOL+FILETIME
#define CERT_OCSP_RESPONSE_PROP_ID          70
#define CERT_REQUEST_ORIGINATOR_PROP_ID     71	// string:machine DNS name
#define CERT_SOURCE_LOCATION_PROP_ID        72	// string
#define CERT_SOURCE_URL_PROP_ID             73	// string
#define CERT_NEW_KEY_PROP_ID                74
#define CERT_OCSP_CACHE_PREFIX_PROP_ID      75	// string
#define CERT_SMART_CARD_ROOT_INFO_PROP_ID   76	// CRYPT_SMART_CARD_ROOT_INFO
#define CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID   77
#define CERT_NCRYPT_KEY_HANDLE_PROP_ID      78
#define CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID   79

#define CERT_SUBJECT_INFO_ACCESS_PROP_ID    80
#define CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID  81
#define CERT_CA_DISABLE_CRL_PROP_ID         82
#define CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID    83
#define CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID 84
#define CERT_FIRST_RESERVED_PROP_ID         85

#define CERT_LAST_RESERVED_PROP_ID          0x00007FFF
#define CERT_FIRST_USER_PROP_ID             0x00008000
#define CERT_LAST_USER_PROP_ID              0x0000FFFF
// certenrolld_end


#define IS_CERT_HASH_PROP_ID(X)     (CERT_SHA1_HASH_PROP_ID == (X) || \
                                        CERT_MD5_HASH_PROP_ID == (X) || \
                                        CERT_SIGNATURE_HASH_PROP_ID == (X))

#define IS_PUBKEY_HASH_PROP_ID(X)     (CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID == (X) || \
                                        CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID == (X))

#define IS_CHAIN_HASH_PROP_ID(X)     (CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID == (X) || \
                                        CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID == (X) || \
                                        CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID == (X) || \
                                        CERT_SUBJECT_NAME_MD5_HASH_PROP_ID == (X))


//+-------------------------------------------------------------------------
//  Property OIDs
//--------------------------------------------------------------------------
// The OID component following the prefix contains the PROP_ID (decimal)
#define szOID_CERT_PROP_ID_PREFIX           "1.3.6.1.4.1.311.10.11."

#define _szPROP_ID(PropId)       #PropId

// Ansi OID string from Property Id:
#define szOID_CERT_PROP_ID(PropId) szOID_CERT_PROP_ID_PREFIX _szPROP_ID(PropId)

// Unicode OID string from Property Id:
#define __CRYPT32WTEXT(quote)           L##quote
#define _CRYPT32WTEXT(quote)            __CRYPT32WTEXT(quote)
#define wszOID_CERT_PROP_ID(PropId) \
        _CRYPT32WTEXT(szOID_CERT_PROP_ID_PREFIX) _CRYPT32WTEXT(_szPROP_ID(PropId))

// Use szOID_CERT_PROP_ID(CERT_KEY_IDENTIFIER_PROP_ID) instead:
#define szOID_CERT_KEY_IDENTIFIER_PROP_ID   "1.3.6.1.4.1.311.10.11.20"

// Use szOID_CERT_PROP_ID(CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID) instead:
#define szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID \
                                            "1.3.6.1.4.1.311.10.11.28"
// Use szOID_CERT_PROP_ID(CERT_SUBJECT_NAME_MD5_HASH_PROP_ID) instead:
#define szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID \
                                            "1.3.6.1.4.1.311.10.11.29"

// Use szOID_CERT_PROP_ID(CERT_MD5_HASH_PROP_ID) instead:
#define szOID_CERT_MD5_HASH_PROP_ID         "1.3.6.1.4.1.311.10.11.4"

//+-------------------------------------------------------------------------
//  Access State flags returned by CERT_ACCESS_STATE_PROP_ID. Note,
//  CERT_ACCESS_PROP_ID is read only.
//--------------------------------------------------------------------------

// Set if context property writes are persisted. For instance, not set for
// memory store contexts. Set for registry based stores opened as read or write.
// Not set for registry based stores opened as read only.
#define CERT_ACCESS_STATE_WRITE_PERSIST_FLAG    0x1

// Set if context resides in a SYSTEM or SYSTEM_REGISTRY store.
#define CERT_ACCESS_STATE_SYSTEM_STORE_FLAG     0x2

// Set if context resides in a LocalMachine SYSTEM or SYSTEM_REGISTRY store.
#define CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG  0x4

// Set if context resides in a GroupPolicy SYSTEM or SYSTEM_REGISTRY store.
#define CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG  0x8

//+-------------------------------------------------------------------------
//  Cryptographic Key Provider Information
//
//  CRYPT_KEY_PROV_INFO defines the CERT_KEY_PROV_INFO_PROP_ID's pvData.
//
//  The CRYPT_KEY_PROV_INFO fields are passed to CryptAcquireContext
//  to get a HCRYPTPROV handle. The optional CRYPT_KEY_PROV_PARAM fields are
//  passed to CryptSetProvParam to further initialize the provider.
//
//  The dwKeySpec field identifies the private key to use from the container
//  For example, AT_KEYEXCHANGE or AT_SIGNATURE.
//--------------------------------------------------------------------------
typedef struct _CRYPT_KEY_PROV_PARAM {
    DWORD           dwParam;
    BYTE            *pbData;
    DWORD           cbData;
    DWORD           dwFlags;
} CRYPT_KEY_PROV_PARAM, *PCRYPT_KEY_PROV_PARAM;

typedef struct _CRYPT_KEY_PROV_INFO {
    LPWSTR                  pwszContainerName;
    LPWSTR                  pwszProvName;
    DWORD                   dwProvType;
    DWORD                   dwFlags;
    DWORD                   cProvParam;
    PCRYPT_KEY_PROV_PARAM   rgProvParam;
    DWORD                   dwKeySpec;
} CRYPT_KEY_PROV_INFO, *PCRYPT_KEY_PROV_INFO;

//+-------------------------------------------------------------------------
//  The following flag should be set in the above dwFlags to enable
//  a CertSetCertificateContextProperty(CERT_KEY_CONTEXT_PROP_ID) after a
//  CryptAcquireContext is done in the Sign or Decrypt Message functions.
//
//  The following define must not collide with any of the
//  CryptAcquireContext dwFlag defines.
//--------------------------------------------------------------------------
#define CERT_SET_KEY_PROV_HANDLE_PROP_ID    0x00000001
#define CERT_SET_KEY_CONTEXT_PROP_ID        0x00000001

// Special dwKeySpec indicating a CNG NCRYPT_KEY_HANDLE instead of a CAPI1
// HCRYPTPROV
#define CERT_NCRYPT_KEY_SPEC                0xFFFFFFFF

//+-------------------------------------------------------------------------
//  Certificate Key Context
//
//  CERT_KEY_CONTEXT defines the CERT_KEY_CONTEXT_PROP_ID's pvData.
//
//  dwKeySpec is set to the special CERT_NCRYPT_KEY_SPEC to select the
//  hNCryptKey choice.
//--------------------------------------------------------------------------
typedef struct _CERT_KEY_CONTEXT {
    DWORD           cbSize;           // sizeof(CERT_KEY_CONTEXT)
    union {
        HCRYPTPROV          hCryptProv;

        // dwKeySpec == CERT_NCRYPT_KEY_SPEC
        NCRYPT_KEY_HANDLE   hNCryptKey;
    };
    DWORD           dwKeySpec;
} CERT_KEY_CONTEXT, *PCERT_KEY_CONTEXT;

//+-------------------------------------------------------------------------
//  Cryptographic Smart Card Root Information
//
//  CRYPT_SMART_CARD_ROOT_INFO defines the
//  CERT_SMART_CARD_ROOT_INFO_PROP_ID's pvData.
//--------------------------------------------------------------------------
typedef struct _ROOT_INFO_LUID {
    DWORD LowPart;
    LONG HighPart;
} ROOT_INFO_LUID, *PROOT_INFO_LUID;

typedef struct _CRYPT_SMART_CARD_ROOT_INFO {
    BYTE                rgbCardID [16];
    ROOT_INFO_LUID      luid;
} CRYPT_SMART_CARD_ROOT_INFO, *PCRYPT_SMART_CARD_ROOT_INFO;

//+-------------------------------------------------------------------------
//  Certificate Store Provider Types
//--------------------------------------------------------------------------
#define CERT_STORE_PROV_MSG                 ((LPCSTR) 1)
#define CERT_STORE_PROV_MEMORY              ((LPCSTR) 2)
#define CERT_STORE_PROV_FILE                ((LPCSTR) 3)
#define CERT_STORE_PROV_REG                 ((LPCSTR) 4)

#define CERT_STORE_PROV_PKCS7               ((LPCSTR) 5)
#define CERT_STORE_PROV_SERIALIZED          ((LPCSTR) 6)
#define CERT_STORE_PROV_FILENAME_A          ((LPCSTR) 7)
#define CERT_STORE_PROV_FILENAME_W          ((LPCSTR) 8)
#define CERT_STORE_PROV_FILENAME            CERT_STORE_PROV_FILENAME_W
#define CERT_STORE_PROV_SYSTEM_A            ((LPCSTR) 9)
#define CERT_STORE_PROV_SYSTEM_W            ((LPCSTR) 10)
#define CERT_STORE_PROV_SYSTEM              CERT_STORE_PROV_SYSTEM_W

#define CERT_STORE_PROV_COLLECTION          ((LPCSTR) 11)
#define CERT_STORE_PROV_SYSTEM_REGISTRY_A   ((LPCSTR) 12)
#define CERT_STORE_PROV_SYSTEM_REGISTRY_W   ((LPCSTR) 13)
#define CERT_STORE_PROV_SYSTEM_REGISTRY     CERT_STORE_PROV_SYSTEM_REGISTRY_W
#define CERT_STORE_PROV_PHYSICAL_W          ((LPCSTR) 14)
#define CERT_STORE_PROV_PHYSICAL            CERT_STORE_PROV_PHYSICAL_W

// SmartCard Store Provider isn't supported
#define CERT_STORE_PROV_SMART_CARD_W        ((LPCSTR) 15)
#define CERT_STORE_PROV_SMART_CARD          CERT_STORE_PROV_SMART_CARD_W

#define CERT_STORE_PROV_LDAP_W              ((LPCSTR) 16)
#define CERT_STORE_PROV_LDAP                CERT_STORE_PROV_LDAP_W
#define CERT_STORE_PROV_PKCS12              ((LPCSTR) 17)

#define sz_CERT_STORE_PROV_MEMORY           "Memory"
#define sz_CERT_STORE_PROV_FILENAME_W       "File"
#define sz_CERT_STORE_PROV_FILENAME         sz_CERT_STORE_PROV_FILENAME_W
#define sz_CERT_STORE_PROV_SYSTEM_W         "System"
#define sz_CERT_STORE_PROV_SYSTEM           sz_CERT_STORE_PROV_SYSTEM_W
#define sz_CERT_STORE_PROV_PKCS7            "PKCS7"
#define sz_CERT_STORE_PROV_PKCS12           "PKCS12"
#define sz_CERT_STORE_PROV_SERIALIZED       "Serialized"

#define sz_CERT_STORE_PROV_COLLECTION       "Collection"
#define sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W "SystemRegistry"
#define sz_CERT_STORE_PROV_SYSTEM_REGISTRY  sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W
#define sz_CERT_STORE_PROV_PHYSICAL_W       "Physical"
#define sz_CERT_STORE_PROV_PHYSICAL         sz_CERT_STORE_PROV_PHYSICAL_W

// SmartCard Store Provider isn't supported
#define sz_CERT_STORE_PROV_SMART_CARD_W     "SmartCard"
#define sz_CERT_STORE_PROV_SMART_CARD       sz_CERT_STORE_PROV_SMART_CARD_W

#define sz_CERT_STORE_PROV_LDAP_W           "Ldap"
#define sz_CERT_STORE_PROV_LDAP             sz_CERT_STORE_PROV_LDAP_W

//+-------------------------------------------------------------------------
//  Certificate Store verify/results flags
//--------------------------------------------------------------------------
#define CERT_STORE_SIGNATURE_FLAG           0x00000001
#define CERT_STORE_TIME_VALIDITY_FLAG       0x00000002
#define CERT_STORE_REVOCATION_FLAG          0x00000004
#define CERT_STORE_NO_CRL_FLAG              0x00010000
#define CERT_STORE_NO_ISSUER_FLAG           0x00020000

#define CERT_STORE_BASE_CRL_FLAG            0x00000100
#define CERT_STORE_DELTA_CRL_FLAG           0x00000200


//+-------------------------------------------------------------------------
//  Certificate Store open/property flags
//--------------------------------------------------------------------------
#define CERT_STORE_NO_CRYPT_RELEASE_FLAG                0x00000001
#define CERT_STORE_SET_LOCALIZED_NAME_FLAG              0x00000002
#define CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG     0x00000004
#define CERT_STORE_DELETE_FLAG                          0x00000010
#define CERT_STORE_UNSAFE_PHYSICAL_FLAG                 0x00000020
#define CERT_STORE_SHARE_STORE_FLAG                     0x00000040
#define CERT_STORE_SHARE_CONTEXT_FLAG                   0x00000080
#define CERT_STORE_MANIFOLD_FLAG                        0x00000100
#define CERT_STORE_ENUM_ARCHIVED_FLAG                   0x00000200
#define CERT_STORE_UPDATE_KEYID_FLAG                    0x00000400
#define CERT_STORE_BACKUP_RESTORE_FLAG                  0x00000800
#define CERT_STORE_READONLY_FLAG                        0x00008000
#define CERT_STORE_OPEN_EXISTING_FLAG                   0x00004000
#define CERT_STORE_CREATE_NEW_FLAG                      0x00002000
#define CERT_STORE_MAXIMUM_ALLOWED_FLAG                 0x00001000

//+-------------------------------------------------------------------------
//  Certificate Store Provider flags are in the HiWord (0xFFFF0000)
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Certificate System Store Flag Values
//--------------------------------------------------------------------------
// Includes flags and location
#define CERT_SYSTEM_STORE_MASK                  0xFFFF0000

// Set if pvPara points to a CERT_SYSTEM_STORE_RELOCATE_PARA structure
#define CERT_SYSTEM_STORE_RELOCATE_FLAG         0x80000000

typedef struct _CERT_SYSTEM_STORE_RELOCATE_PARA {
    union {
        HKEY                hKeyBase;
        void                *pvBase;
    };
    union {
        void                *pvSystemStore;
        LPCSTR              pszSystemStore;
        LPCWSTR             pwszSystemStore;
    };
} CERT_SYSTEM_STORE_RELOCATE_PARA, *PCERT_SYSTEM_STORE_RELOCATE_PARA;

// By default, when the CurrentUser "Root" store is opened, any SystemRegistry
// roots not also on the protected root list are deleted from the cache before
// CertOpenStore() returns. Set the following flag to return all the roots
// in the SystemRegistry without checking the protected root list.
#define CERT_SYSTEM_STORE_UNPROTECTED_FLAG      0x40000000

// Location of the system store:
#define CERT_SYSTEM_STORE_LOCATION_MASK         0x00FF0000
#define CERT_SYSTEM_STORE_LOCATION_SHIFT        16


//  Registry: HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
#define CERT_SYSTEM_STORE_CURRENT_USER_ID       1
#define CERT_SYSTEM_STORE_LOCAL_MACHINE_ID      2
//  Registry: HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\Services
#define CERT_SYSTEM_STORE_CURRENT_SERVICE_ID    4
#define CERT_SYSTEM_STORE_SERVICES_ID           5
//  Registry: HKEY_USERS
#define CERT_SYSTEM_STORE_USERS_ID              6

//  Registry: HKEY_CURRENT_USER\Software\Policies\Microsoft\SystemCertificates
#define CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID    7
//  Registry: HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\SystemCertificates
#define CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID   8

//  Registry: HKEY_LOCAL_MACHINE\Software\Microsoft\EnterpriseCertificates
#define CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID     9

#define CERT_SYSTEM_STORE_CURRENT_USER          \
    (CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT)
#define CERT_SYSTEM_STORE_LOCAL_MACHINE         \
    (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT)
#define CERT_SYSTEM_STORE_CURRENT_SERVICE       \
    (CERT_SYSTEM_STORE_CURRENT_SERVICE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT)
#define CERT_SYSTEM_STORE_SERVICES              \
    (CERT_SYSTEM_STORE_SERVICES_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT)
#define CERT_SYSTEM_STORE_USERS                 \
    (CERT_SYSTEM_STORE_USERS_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT)

#define CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY   \
    (CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID << \
        CERT_SYSTEM_STORE_LOCATION_SHIFT)
#define CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY  \
    (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID << \
        CERT_SYSTEM_STORE_LOCATION_SHIFT)

#define CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE  \
    (CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID << \
        CERT_SYSTEM_STORE_LOCATION_SHIFT)


//+-------------------------------------------------------------------------
//  Group Policy Store Defines
//--------------------------------------------------------------------------
// Registry path to the Group Policy system stores
#define CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH \
    L"Software\\Policies\\Microsoft\\SystemCertificates"

//+-------------------------------------------------------------------------
//  EFS Defines
//--------------------------------------------------------------------------
// Registry path to the EFS EFSBlob SubKey - Value type is REG_BINARY
#define CERT_EFSBLOB_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\EFS"
#define CERT_EFSBLOB_VALUE_NAME L"EFSBlob"

//+-------------------------------------------------------------------------
//  Protected Root Defines
//--------------------------------------------------------------------------
// Registry path to the Protected Roots Flags SubKey
#define CERT_PROT_ROOT_FLAGS_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\Root\\ProtectedRoots"

// The following is a REG_DWORD. The bit definitions follow.
#define CERT_PROT_ROOT_FLAGS_VALUE_NAME L"Flags"

// Set the following flag to inhibit the opening of the CurrentUser's
// .Default physical store when opening the CurrentUser's "Root" system store.
// The .Default physical store open's the CurrentUser SystemRegistry "Root"
// store.
#define CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG    0x1

// Set the following flag to inhibit the adding of roots from the
// CurrentUser SystemRegistry "Root" store to the protected root list
// when the "Root" store is initially protected.
#define CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG     0x2

// Set the following flag to inhibit the purging of protected roots from the
// CurrentUser SystemRegistry "Root" store that are
// also in the LocalMachine SystemRegistry "Root" store. Note, when not
// disabled, the purging is done silently without UI.
#define CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG        0x4

// Set the following flag to inhibit the opening of the LocalMachine's
// .AuthRoot physical store when opening the LocalMachine's "Root" system store.
// The .AuthRoot physical store open's the LocalMachine SystemRegistry
// "AuthRoot" store. The "AuthRoot" store contains the pre-installed
// SSL ServerAuth and the ActiveX Authenticode "root" certificates.
#define CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG         0x8

// The semantics for the following legacy definition has been changed to be
// the same as for the CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG.
#define CERT_PROT_ROOT_ONLY_LM_GPT_FLAG             0x8

// Set the following flag to disable the requiring of the issuing CA
// certificate being in the "NTAuth" system registry store found in the
// CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location.
//
// When set, CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)
// will check that the chain has a valid name constraint for all name
// spaces, including UPN if the issuing CA isn't in the "NTAuth" store.
#define CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG 0x10

// Set the following flag to disable checking for not defined name
// constraints.
//
// When set, CertGetCertificateChain won't check for or set the following
// dwErrorStatus: CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT.
//
// In LH, checking for not defined name constraints is always disabled.
#define CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG 0x20

// Set the following flag to disallow the users to trust peer-trust
#define CERT_PROT_ROOT_DISABLE_PEER_TRUST                       0x10000

// The following is a REG_MULTI_SZ containing the list of user allowed
// Enhanced Key Usages for peer trust.
#define CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME     L"PeerUsages"
#define CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A   "PeerUsages"

// If the above REG_MULTI_SZ isn't defined or is empty, defaults to
// the following multi-string value
#define CERT_PROT_ROOT_PEER_USAGES_DEFAULT_A      \
    szOID_PKIX_KP_CLIENT_AUTH "\0"                  \
    szOID_PKIX_KP_EMAIL_PROTECTION "\0"             \
    szOID_KP_EFS "\0"

//+-------------------------------------------------------------------------
//  Trusted Publisher Definitions
//--------------------------------------------------------------------------
// Registry path to the trusted publisher "Safer" group policy subkey
#define CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\TrustedPublisher\\Safer"


// Registry path to the Local Machine system stores
#define CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH \
    L"Software\\Microsoft\\SystemCertificates"

// Registry path to the trusted publisher "Safer" local machine subkey
#define CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH    \
    CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH L"\\TrustedPublisher\\Safer"


// "Safer" subkey value names. All values are DWORDs.
#define CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME    L"AuthenticodeFlags"


// AuthenticodeFlags definitions

// Definition of who is allowed to trust publishers
//
// Setting allowed trust to MACHINE_ADMIN or ENTERPRISE_ADMIN disables UI,
// only trusts publishers in the "TrustedPublisher" system store and
// inhibits the opening of the CurrentUser's .Default physical store when
// opening the CurrentUsers's "TrustedPublisher" system store.
//
// The .Default physical store open's the CurrentUser SystemRegistry
// "TrustedPublisher" store.
//
// Setting allowed trust to ENTERPRISE_ADMIN only opens the
// LocalMachine's .GroupPolicy and .Enterprise physical stores when opening
// the CurrentUser's "TrustedPublisher" system store or when opening the
// LocalMachine's "TrustedPublisher" system store.

#define CERT_TRUST_PUB_ALLOW_TRUST_MASK                 0x00000003
#define CERT_TRUST_PUB_ALLOW_END_USER_TRUST             0x00000000
#define CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST        0x00000001
#define CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST     0x00000002

// Set the following flag to enable revocation checking of the publisher
// chain.
#define CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG         0x00000100

// Set the following flag to enable revocation checking of the time stamp
// chain.
#define CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG         0x00000200


//+-------------------------------------------------------------------------
//  OCM Subcomponents Definitions
//
//  Reading of the following registry key has been deprecated on Longhorn.
//--------------------------------------------------------------------------

// Registry path to the OCM Subcomponents local machine subkey
#define CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH        \
    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents"

// REG_DWORD, 1 is installed, 0 is NOT installed
#define CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME  L"RootAutoUpdate"


//+-------------------------------------------------------------------------
//  DisableRootAutoUpdate Defines
//--------------------------------------------------------------------------
// Registry path to the DisableRootAutoUpdate SubKey
#define CERT_DISABLE_ROOT_AUTO_UPDATE_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\AuthRoot"

// REG_DWORD Value Name, 1 - disables, 0 - enables
#define CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME L"DisableRootAutoUpdate"

//+-------------------------------------------------------------------------
//  AuthRoot Auto Update Definitions
//--------------------------------------------------------------------------

// Registry path to the AuthRoot "Auto Update" local machine subkey
#define CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH    \
    CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH L"\\AuthRoot\\AutoUpdate"


// AuthRoot Auto Update subkey value names.

// REG_SZ, URL to the directory containing the AuthRoots, CTL and Seq files
#define CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME      L"RootDirUrl"

// REG_DWORD, seconds between syncs. 0 implies use default.
#define CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME   L"SyncDeltaTime"

// REG_DWORD, misc flags
#define CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME             L"Flags"

#define CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG  0x1
#define CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG   0x2


// AuthRoot Auto Update filenames

// CTL containing the list of certs in the AuthRoot store
#define CERT_AUTH_ROOT_CTL_FILENAME                             L"authroot.stl"
#define CERT_AUTH_ROOT_CTL_FILENAME_A                           "authroot.stl"

// Cab containing the above CTL
#define CERT_AUTH_ROOT_CAB_FILENAME                             L"authrootstl.cab"

// SequenceNumber (Formatted as big endian ascii hex)
#define CERT_AUTH_ROOT_SEQ_FILENAME                             L"authrootseq.txt"

// Root certs extension
#define CERT_AUTH_ROOT_CERT_EXT                                 L".crt"



//+-------------------------------------------------------------------------
//  Certificate Registry Store Flag Values (CERT_STORE_REG)
//--------------------------------------------------------------------------

// Set this flag if the HKEY passed in pvPara points to a remote computer
// registry key.
#define CERT_REGISTRY_STORE_REMOTE_FLAG         0x10000

// Set this flag if the contexts are to be persisted as a single serialized
// store in the registry. Mainly used for stores downloaded from the GPT.
// Such as the CurrentUserGroupPolicy or LocalMachineGroupPolicy stores.
#define CERT_REGISTRY_STORE_SERIALIZED_FLAG     0x20000

// The following flags are for internal use. When set, the
// pvPara parameter passed to CertOpenStore is a pointer to the following
// data structure and not the HKEY. The above CERT_REGISTRY_STORE_REMOTE_FLAG
// is also set if hKeyBase was obtained via RegConnectRegistry().
#define CERT_REGISTRY_STORE_CLIENT_GPT_FLAG     0x80000000
#define CERT_REGISTRY_STORE_LM_GPT_FLAG         0x01000000

typedef struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
    HKEY                hKeyBase;
    LPWSTR              pwszRegPath;
} CERT_REGISTRY_STORE_CLIENT_GPT_PARA, *PCERT_REGISTRY_STORE_CLIENT_GPT_PARA;

// The following flag is for internal use. When set, the contexts are
// persisted into roaming files instead of the registry. Such as, the
// CurrentUser "My" store. When this flag is set, the following data structure
// is passed to CertOpenStore instead of HKEY.
#define CERT_REGISTRY_STORE_ROAMING_FLAG        0x40000

// hKey may be NULL or non-NULL. When non-NULL, existing contexts are
// moved from the registry to roaming files.
typedef struct _CERT_REGISTRY_STORE_ROAMING_PARA {
    HKEY                hKey;
    LPWSTR              pwszStoreDirectory;
} CERT_REGISTRY_STORE_ROAMING_PARA, *PCERT_REGISTRY_STORE_ROAMING_PARA;

// The following flag is for internal use. When set, the "My" DWORD value
// at HKLM\Software\Microsoft\Cryptography\IEDirtyFlags is set to 0x1
// whenever a certificate is added to the registry store.
//
// Legacy definition, no longer supported after 01-May-02 (Server 2003)
#define CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG    0x80000

// Registry path to the subkey containing the "My" DWORD value to be set
//
// Legacy definition, no longer supported after 01-May-02 (Server 2003)
#define CERT_IE_DIRTY_FLAGS_REGPATH \
    L"Software\\Microsoft\\Cryptography\\IEDirtyFlags"

//+-------------------------------------------------------------------------
//  Certificate File Store Flag Values for the providers:
//      CERT_STORE_PROV_FILE
//      CERT_STORE_PROV_FILENAME
//      CERT_STORE_PROV_FILENAME_A
//      CERT_STORE_PROV_FILENAME_W
//      sz_CERT_STORE_PROV_FILENAME_W
//--------------------------------------------------------------------------

// Set this flag if any store changes are to be committed to the file.
// The changes are committed at CertCloseStore or by calling
// CertControlStore(CERT_STORE_CTRL_COMMIT).
//
// The open fails with E_INVALIDARG if both CERT_FILE_STORE_COMMIT_ENABLE_FLAG
// and CERT_STORE_READONLY_FLAG are set in dwFlags.
//
// For the FILENAME providers:  if the file contains an X509 encoded
// certificate, the open fails with ERROR_ACCESS_DENIED.
//
// For the FILENAME providers: if CERT_STORE_CREATE_NEW_FLAG is set, the
// CreateFile uses CREATE_NEW. If CERT_STORE_OPEN_EXISTING is set, uses
// OPEN_EXISTING. Otherwise, defaults to OPEN_ALWAYS.
//
// For the FILENAME providers:  the file is committed as either a PKCS7 or
// serialized store depending on the type read at open. However, if the
// file is empty then, if the filename has either a ".p7c" or ".spc"
// extension its committed as a PKCS7. Otherwise, its committed as a
// serialized store.
//
// For CERT_STORE_PROV_FILE, the file handle is duplicated. Its always
// committed as a serialized store.
//
#define CERT_FILE_STORE_COMMIT_ENABLE_FLAG      0x10000


//+-------------------------------------------------------------------------
//  Certificate LDAP Store Flag Values for the providers:
//      CERT_STORE_PROV_LDAP
//      CERT_STORE_PROV_LDAP_W
//      sz_CERT_STORE_PROV_LDAP_W
//      sz_CERT_STORE_PROV_LDAP
//--------------------------------------------------------------------------

// Set this flag to digitally sign all of the ldap traffic to and from a
// Windows 2000 LDAP server using the Kerberos authentication protocol.
// This feature provides integrity required by some applications.
//
#define CERT_LDAP_STORE_SIGN_FLAG               0x10000

// Performs an A-Record only DNS lookup on the supplied host string.
// This prevents bogus DNS queries from being generated when resolving host
// names. Use this flag whenever passing a hostname as opposed to a
// domain name for the hostname parameter.
//
// See LDAP_OPT_AREC_EXCLUSIVE defined in winldap.h for more details.
#define CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG     0x20000

// Set this flag if the LDAP session handle has already been opened. When
// set, pvPara points to the following CERT_LDAP_STORE_OPENED_PARA structure.
#define CERT_LDAP_STORE_OPENED_FLAG             0x40000

typedef struct _CERT_LDAP_STORE_OPENED_PARA {
    void        *pvLdapSessionHandle;   // The (LDAP *) handle returned by
                                        // ldap_init
    LPCWSTR     pwszLdapUrl;
} CERT_LDAP_STORE_OPENED_PARA, *PCERT_LDAP_STORE_OPENED_PARA;


// Set this flag if the above CERT_LDAP_STORE_OPENED_FLAG is set and
// you want an ldap_unbind() of the above pvLdapSessionHandle when the
// store is closed. Note, if CertOpenStore() fails, then, ldap_unbind()
// isn't called.
#define CERT_LDAP_STORE_UNBIND_FLAG             0x80000

//+-------------------------------------------------------------------------
//  Open the cert store using the specified store provider.
//
//  If CERT_STORE_DELETE_FLAG is set, then, the store is deleted. NULL is
//  returned for both success and failure. However, GetLastError() returns 0
//  for success and nonzero for failure.
//
//  If CERT_STORE_SET_LOCALIZED_NAME_FLAG is set, then, if supported, the
//  provider sets the store's CERT_STORE_LOCALIZED_NAME_PROP_ID property.
//  The store's localized name can be retrieved by calling
//  CertSetStoreProperty(dwPropID = CERT_STORE_LOCALIZED_NAME_PROP_ID).
//  This flag is supported by the following providers (and their sz_
//  equivalent):
//      CERT_STORE_PROV_FILENAME_A
//      CERT_STORE_PROV_FILENAME_W
//      CERT_STORE_PROV_SYSTEM_A
//      CERT_STORE_PROV_SYSTEM_W
//      CERT_STORE_PROV_SYSTEM_REGISTRY_A
//      CERT_STORE_PROV_SYSTEM_REGISTRY_W
//      CERT_STORE_PROV_PHYSICAL_W
//
//  If CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG is set, then, the
//  closing of the store's provider is deferred until all certificate,
//  CRL and CTL contexts obtained from the store are freed. Also,
//  if a non NULL HCRYPTPROV was passed, then, it will continue to be used.
//  By default, the store's provider is closed on the final CertCloseStore.
//  If this flag isn't set, then, any property changes made to previously
//  duplicated contexts after the final CertCloseStore will not be persisted.
//  By setting this flag, property changes made
//  after the CertCloseStore will be persisted. Note, setting this flag
//  causes extra overhead in doing context duplicates and frees.
//  If CertCloseStore is called with CERT_CLOSE_STORE_FORCE_FLAG, then,
//  the CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG flag is ignored.
//
//  CERT_STORE_MANIFOLD_FLAG can be set to check for certificates having the
//  manifold extension and archive the "older" certificates with the same
//  manifold extension value. A certificate is archived by setting the
//  CERT_ARCHIVED_PROP_ID.
//
//  By default, contexts having the CERT_ARCHIVED_PROP_ID, are skipped
//  during enumeration. CERT_STORE_ENUM_ARCHIVED_FLAG can be set to include
//  archived contexts when enumerating. Note, contexts having the
//  CERT_ARCHIVED_PROP_ID are still found for explicit finds, such as,
//  finding a context with a specific hash or finding a certificate having
//  a specific issuer and serial number.
//
//  CERT_STORE_UPDATE_KEYID_FLAG can be set to also update the Key Identifier's
//  CERT_KEY_PROV_INFO_PROP_ID property whenever a certificate's
//  CERT_KEY_IDENTIFIER_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID property is set
//  and the other property already exists. If the Key Identifier's
//  CERT_KEY_PROV_INFO_PROP_ID already exists, it isn't updated. Any
//  errors encountered are silently ignored.
//
//  By default, this flag is implicitly set for the "My\.Default" CurrentUser
//  and LocalMachine physical stores.
//
//  CERT_STORE_READONLY_FLAG can be set to open the store as read only.
//  Otherwise, the store is opened as read/write.
//
//  CERT_STORE_OPEN_EXISTING_FLAG can be set to only open an existing
//  store. CERT_STORE_CREATE_NEW_FLAG can be set to create a new store and
//  fail if the store already exists. Otherwise, the default is to open
//  an existing store or create a new store if it doesn't already exist.
//
//  hCryptProv specifies the crypto provider to use to create the hash
//  properties or verify the signature of a subject certificate or CRL.
//  The store doesn't need to use a private
//  key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is
//  CryptReleaseContext'ed on the final CertCloseStore.
//
//  Note, if the open fails, hCryptProv is released if it would have been
//  released when the store was closed.
//
//  If hCryptProv is zero, then, the default provider and container for the
//  PROV_RSA_FULL provider type is CryptAcquireContext'ed with
//  CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until
//  the first create hash or verify signature. In addition, once acquired,
//  the default provider isn't released until process exit when crypt32.dll
//  is unloaded. The acquired default provider is shared across all stores
//  and threads.
//
//  After initializing the store's data structures and optionally acquiring a
//  default crypt provider, CertOpenStore calls CryptGetOIDFunctionAddress to
//  get the address of the CRYPT_OID_OPEN_STORE_PROV_FUNC specified by
//  lpszStoreProvider. Since a store can contain certificates with different
//  encoding types, CryptGetOIDFunctionAddress is called with dwEncodingType
//  set to 0 and not the dwEncodingType passed to CertOpenStore.
//  PFN_CERT_DLL_OPEN_STORE_FUNC specifies the signature of the provider's
//  open function. This provider open function is called to load the
//  store's certificates and CRLs. Optionally, the provider may return an
//  array of functions called before a certificate or CRL is added or deleted
//  or has a property that is set.
//
//  Use of the dwEncodingType parameter is provider dependent. The type
//  definition for pvPara also depends on the provider.
//
//  Store providers are installed or registered via
//  CryptInstallOIDFunctionAddress or CryptRegisterOIDFunction, where,
//  dwEncodingType is 0 and pszFuncName is CRYPT_OID_OPEN_STORE_PROV_FUNC.
//
//  Here's a list of the predefined provider types (implemented in crypt32.dll):
//
//  CERT_STORE_PROV_MSG:
//      Gets the certificates and CRLs from the specified cryptographic message.
//      dwEncodingType contains the message and certificate encoding types.
//      The message's handle is passed in pvPara. Given,
//          HCRYPTMSG hCryptMsg; pvPara = (const void *) hCryptMsg;
//
//  CERT_STORE_PROV_MEMORY
//  sz_CERT_STORE_PROV_MEMORY:
//      Opens a store without any initial certificates or CRLs. pvPara
//      isn't used.
//
//  CERT_STORE_PROV_FILE:
//      Reads the certificates and CRLs from the specified file. The file's
//      handle is passed in pvPara. Given,
//          HANDLE hFile; pvPara = (const void *) hFile;
//
//      For a successful open, the file pointer is advanced past
//      the certificates and CRLs and their properties read from the file.
//      Note, only expects a serialized store and not a file containing
//      either a PKCS #7 signed message or a single encoded certificate.
//
//      The hFile isn't closed.
//
//  CERT_STORE_PROV_REG:
//      Reads the certificates and CRLs from the registry. The registry's
//      key handle is passed in pvPara. Given,
//          HKEY hKey; pvPara = (const void *) hKey;
//
//      The input hKey isn't closed by the provider. Before returning, the
//      provider opens it own copy of the hKey.
//
//      If CERT_STORE_READONLY_FLAG is set, then, the registry subkeys are
//      RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry subkeys
//      are RegCreateKey'ed with KEY_ALL_ACCESS.
//
//      This provider returns the array of functions for reading, writing,
//      deleting and property setting certificates and CRLs.
//      Any changes to the opened store are immediately pushed through to
//      the registry. However, if CERT_STORE_READONLY_FLAG is set, then,
//      writing, deleting or property setting results in a
//      SetLastError(E_ACCESSDENIED).
//
//      Note, all the certificates and CRLs are read from the registry
//      when the store is opened. The opened store serves as a write through
//      cache.
//
//      If CERT_REGISTRY_STORE_SERIALIZED_FLAG is set, then, the
//      contexts are persisted as a single serialized store subkey in the
//      registry.
//
//  CERT_STORE_PROV_PKCS7:
//  sz_CERT_STORE_PROV_PKCS7:
//      Gets the certificates and CRLs from the encoded PKCS #7 signed message.
//      dwEncodingType specifies the message and certificate encoding types.
//      The pointer to the encoded message's blob is passed in pvPara. Given,
//          CRYPT_DATA_BLOB EncodedMsg; pvPara = (const void *) &EncodedMsg;
//
//      Note, also supports the IE3.0 special version of a
//      PKCS #7 signed message referred to as a "SPC" formatted message.
//
//  CERT_STORE_PROV_SERIALIZED:
//  sz_CERT_STORE_PROV_SERIALIZED:
//      Gets the certificates and CRLs from memory containing a serialized
//      store.  The pointer to the serialized memory blob is passed in pvPara.
//      Given,
//          CRYPT_DATA_BLOB Serialized; pvPara = (const void *) &Serialized;
//
//  CERT_STORE_PROV_FILENAME_A:
//  CERT_STORE_PROV_FILENAME_W:
//  CERT_STORE_PROV_FILENAME:
//  sz_CERT_STORE_PROV_FILENAME_W:
//  sz_CERT_STORE_PROV_FILENAME:
//      Opens the file and first attempts to read as a serialized store. Then,
//      as a PKCS #7 signed message. Finally, as a single encoded certificate.
//      The filename is passed in pvPara. The filename is UNICODE for the
//      "_W" provider and ASCII for the "_A" provider. For "_W": given,
//          LPCWSTR pwszFilename; pvPara = (const void *) pwszFilename;
//      For "_A": given,
//          LPCSTR pszFilename; pvPara = (const void *) pszFilename;
//
//      Note, the default (without "_A" or "_W") is unicode.
//
//      Note, also supports the reading of the IE3.0 special version of a
//      PKCS #7 signed message file referred to as a "SPC" formatted file.
//
//  CERT_STORE_PROV_SYSTEM_A:
//  CERT_STORE_PROV_SYSTEM_W:
//  CERT_STORE_PROV_SYSTEM:
//  sz_CERT_STORE_PROV_SYSTEM_W:
//  sz_CERT_STORE_PROV_SYSTEM:
//      Opens the specified logical "System" store. The upper word of the
//      dwFlags parameter is used to specify the location of the system store.
//
//      A "System" store is a collection consisting of one or more "Physical"
//      stores. A "Physical" store is registered via the
//      CertRegisterPhysicalStore API. Each of the registered physical stores
//      is CertStoreOpen'ed and added to the collection via
//      CertAddStoreToCollection.
//
//      The CERT_SYSTEM_STORE_CURRENT_USER, CERT_SYSTEM_STORE_LOCAL_MACHINE,
//      CERT_SYSTEM_STORE_CURRENT_SERVICE, CERT_SYSTEM_STORE_SERVICES,
//      CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
//      CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY and
//      CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRSE
//      system stores by default have a "SystemRegistry" store that is
//      opened and added to the collection.
//
//      The system store name is passed in pvPara. The name is UNICODE for the
//      "_W" provider and ASCII for the "_A" provider. For "_W": given,
//          LPCWSTR pwszSystemName; pvPara = (const void *) pwszSystemName;
//      For "_A": given,
//          LPCSTR pszSystemName; pvPara = (const void *) pszSystemName;
//
//      Note, the default (without "_A" or "_W") is UNICODE.
//
//      The system store name can't contain any backslashes.
//
//      If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
//      points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
//      of pointing to a null terminated UNICODE or ASCII string.
//      Sibling physical stores are also opened as relocated using
//      pvPara's hKeyBase.
//
//      The CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS system
//      store name must be prefixed with the ServiceName or UserName.
//      For example, "ServiceName\Trust".
//
//      Stores on remote computers can be accessed for the
//      CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
//      CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
//      or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//      locations by prepending the computer name. For example, a remote
//      local machine store is accessed via "\\ComputerName\Trust" or
//      "ComputerName\Trust". A remote service store is accessed via
//      "\\ComputerName\ServiceName\Trust". The leading "\\" backslashes are
//      optional in the ComputerName.
//
//      If CERT_STORE_READONLY_FLAG is set, then, the registry is
//      RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry is
//      RegCreateKey'ed with KEY_ALL_ACCESS.
//
//      The "root" store is treated differently from the other system
//      stores. Before a certificate is added to or deleted from the "root"
//      store, a pop up message box is displayed. The certificate's subject,
//      issuer, serial number, time validity, sha1 and md5 thumbprints are
//      displayed. The user is given the option to do the add or delete.
//      If they don't allow the operation, LastError is set to E_ACCESSDENIED.
//
//  CERT_STORE_PROV_SYSTEM_REGISTRY_A
//  CERT_STORE_PROV_SYSTEM_REGISTRY_W
//  CERT_STORE_PROV_SYSTEM_REGISTRY
//  sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W
//  sz_CERT_STORE_PROV_SYSTEM_REGISTRY
//      Opens the "System" store's default "Physical" store residing in the
//      registry. The upper word of the dwFlags
//      parameter is used to specify the location of the system store.
//
//      After opening the registry key associated with the system name,
//      the CERT_STORE_PROV_REG provider is called to complete the open.
//
//      The system store name is passed in pvPara. The name is UNICODE for the
//      "_W" provider and ASCII for the "_A" provider. For "_W": given,
//          LPCWSTR pwszSystemName; pvPara = (const void *) pwszSystemName;
//      For "_A": given,
//          LPCSTR pszSystemName; pvPara = (const void *) pszSystemName;
//
//      Note, the default (without "_A" or "_W") is UNICODE.
//
//      If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
//      points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
//      of pointing to a null terminated UNICODE or ASCII string.
//
//      See above for details on prepending a ServiceName and/or ComputerName
//      to the store name.
//
//      If CERT_STORE_READONLY_FLAG is set, then, the registry is
//      RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry is
//      RegCreateKey'ed with KEY_ALL_ACCESS.
//
//      The "root" store is treated differently from the other system
//      stores. Before a certificate is added to or deleted from the "root"
//      store, a pop up message box is displayed. The certificate's subject,
//      issuer, serial number, time validity, sha1 and md5 thumbprints are
//      displayed. The user is given the option to do the add or delete.
//      If they don't allow the operation, LastError is set to E_ACCESSDENIED.
//
//  CERT_STORE_PROV_PHYSICAL_W
//  CERT_STORE_PROV_PHYSICAL
//  sz_CERT_STORE_PROV_PHYSICAL_W
//  sz_CERT_STORE_PROV_PHYSICAL
//      Opens the specified "Physical" store in the "System" store.
//
//      Both the system store and physical names are passed in pvPara. The
//      names are separated with an intervening "\". For example,
//      "Root\.Default". The string is UNICODE.
//
//      The system and physical store names can't contain any backslashes.
//
//      If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
//      points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
//      of pointing to a null terminated UNICODE string.
//      The specified physical store is opened as relocated using pvPara's
//      hKeyBase.
//
//      For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
//      the system and physical store names
//      must be prefixed with the ServiceName or UserName. For example,
//      "ServiceName\Root\.Default".
//
//      Physical stores on remote computers can be accessed for the
//      CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
//      CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
//      or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//      locations by prepending the computer name. For example, a remote
//      local machine store is accessed via "\\ComputerName\Root\.Default"
//      or "ComputerName\Root\.Default". A remote service store is
//      accessed via "\\ComputerName\ServiceName\Root\.Default". The
//      leading "\\" backslashes are optional in the ComputerName.
//
//  CERT_STORE_PROV_COLLECTION
//  sz_CERT_STORE_PROV_COLLECTION
//      Opens a store that is a collection of other stores. Stores are
//      added or removed to/from the collection via the CertAddStoreToCollection
//      and CertRemoveStoreFromCollection APIs.
//
//  CERT_STORE_PROV_SMART_CARD_W
//  CERT_STORE_PROV_SMART_CARD
//  sz_CERT_STORE_PROV_SMART_CARD_W
//  sz_CERT_STORE_PROV_SMART_CARD
//      Opens a store instantiated over a particular smart card storage.  pvPara
//      identifies where on the card the store is located and is of the
//      following format:
//
//                Card Name\Provider Name\Provider Type[\Container Name]
//
//      Container Name is optional and if NOT specified the Card Name is used
//      as the Container Name.  Future versions of the provider will support
//      instantiating the store over the entire card in which case just
//      Card Name ( or id ) will be sufficient.
//
//  Here's a list of the predefined provider types (implemented in
//  cryptnet.dll):
//
//  CERT_STORE_PROV_LDAP_W
//  CERT_STORE_PROV_LDAP
//  sz_CERT_STORE_PROV_LDAP_W
//  sz_CERT_STORE_PROV_LDAP
//      Opens a store over the results of the query specified by and LDAP
//      URL which is passed in via pvPara.  In order to do writes to the
//      store the URL must specify a BASE query, no filter and a single
//      attribute.
//
//--------------------------------------------------------------------------
WINCRYPT32API
__checkReturn
HCERTSTORE
WINAPI
CertOpenStore(
    __in LPCSTR lpszStoreProvider,
    __in DWORD dwEncodingType,
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwFlags,
    __in_opt const void *pvPara
    );


//+-------------------------------------------------------------------------
//  OID Installable Certificate Store Provider Data Structures
//--------------------------------------------------------------------------

// Handle returned by the store provider when opened.
typedef void *HCERTSTOREPROV;

// Store Provider OID function's pszFuncName.
#define CRYPT_OID_OPEN_STORE_PROV_FUNC   "CertDllOpenStoreProv"

// Note, the Store Provider OID function's dwEncodingType is always 0.

// The following information is returned by the provider when opened. Its
// zeroed with cbSize set before the provider is called. If the provider
// doesn't need to be called again after the open it doesn't need to
// make any updates to the CERT_STORE_PROV_INFO.
typedef struct _CERT_STORE_PROV_INFO {
    DWORD               cbSize;
    DWORD               cStoreProvFunc;
    void                **rgpvStoreProvFunc;
    HCERTSTOREPROV      hStoreProv;
    DWORD               dwStoreProvFlags;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr2;
} CERT_STORE_PROV_INFO, *PCERT_STORE_PROV_INFO;

// Definition of the store provider's open function.
//
// *pStoreProvInfo has been zeroed before the call.
//
// Note, pStoreProvInfo->cStoreProvFunc should be set last.  Once set,
// all subsequent store calls, such as CertAddSerializedElementToStore will
// call the appropriate provider callback function.
typedef BOOL (WINAPI *PFN_CERT_DLL_OPEN_STORE_PROV_FUNC)(
    __in LPCSTR lpszStoreProvider,
    __in DWORD dwEncodingType,
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwFlags,
    __in_opt const void *pvPara,
    __in HCERTSTORE hCertStore,
    __inout PCERT_STORE_PROV_INFO pStoreProvInfo
    );

// The open callback sets the following flag, if it maintains its
// contexts externally and not in the cached store.
#define CERT_STORE_PROV_EXTERNAL_FLAG           0x1

// The open callback sets the following flag for a successful delete.
// When set, the close callback isn't called.
#define CERT_STORE_PROV_DELETED_FLAG            0x2

// The open callback sets the following flag if it doesn't persist store
// changes.
#define CERT_STORE_PROV_NO_PERSIST_FLAG         0x4

// The open callback sets the following flag if the contexts are persisted
// to a system store.
#define CERT_STORE_PROV_SYSTEM_STORE_FLAG       0x8

// The open callback sets the following flag if the contexts are persisted
// to a LocalMachine system store.
#define CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG    0x10

// The open callback sets the following flag if the contexts are persisted
// to a GroupPolicy system store.
#define CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG    0x20

// Indices into the store provider's array of callback functions.
//
// The provider can implement any subset of the following functions. It
// sets pStoreProvInfo->cStoreProvFunc to the last index + 1 and any
// preceding not implemented functions to NULL.
#define CERT_STORE_PROV_CLOSE_FUNC              0
#define CERT_STORE_PROV_READ_CERT_FUNC          1
#define CERT_STORE_PROV_WRITE_CERT_FUNC         2
#define CERT_STORE_PROV_DELETE_CERT_FUNC        3
#define CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
#define CERT_STORE_PROV_READ_CRL_FUNC           5
#define CERT_STORE_PROV_WRITE_CRL_FUNC          6
#define CERT_STORE_PROV_DELETE_CRL_FUNC         7
#define CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
#define CERT_STORE_PROV_READ_CTL_FUNC           9
#define CERT_STORE_PROV_WRITE_CTL_FUNC          10
#define CERT_STORE_PROV_DELETE_CTL_FUNC         11
#define CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
#define CERT_STORE_PROV_CONTROL_FUNC            13
#define CERT_STORE_PROV_FIND_CERT_FUNC          14
#define CERT_STORE_PROV_FREE_FIND_CERT_FUNC     15
#define CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC  16
#define CERT_STORE_PROV_FIND_CRL_FUNC           17
#define CERT_STORE_PROV_FREE_FIND_CRL_FUNC      18
#define CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC   19
#define CERT_STORE_PROV_FIND_CTL_FUNC           20
#define CERT_STORE_PROV_FREE_FIND_CTL_FUNC      21
#define CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC   22


// Called by CertCloseStore when the store's reference count is
// decremented to 0.
typedef void (WINAPI *PFN_CERT_STORE_PROV_CLOSE)(
    __inout_opt HCERTSTOREPROV hStoreProv,
    __in DWORD dwFlags
    );

// Currently not called directly by the store APIs. However, may be exported
// to support other providers based on it.
//
// Reads the provider's copy of the certificate context. If it exists,
// creates a new certificate context.
typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_READ_CERT)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pStoreCertContext,
    __in DWORD dwFlags,
    __deref_out PCCERT_CONTEXT *ppProvCertContext
    );

#define CERT_STORE_PROV_WRITE_ADD_FLAG      0x1

// Called by CertAddEncodedCertificateToStore,
// CertAddCertificateContextToStore or CertAddSerializedElementToStore before
// adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
// addition to the encoded certificate, the added pCertContext might also
// have properties.
//
// Returns TRUE if its OK to update the the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_WRITE_CERT)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwFlags
    );

// Called by CertDeleteCertificateFromStore before deleting from the
// store.
//
// Returns TRUE if its OK to delete from the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_DELETE_CERT)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwFlags
    );

// Called by CertSetCertificateContextProperty before setting the
// certificate's property. Also called by CertGetCertificateContextProperty,
// when getting a hash property that needs to be created and then persisted
// via the set.
//
// Upon input, the property hasn't been set for the pCertContext parameter.
//
// Returns TRUE if its OK to set the property.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_SET_CERT_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

// Currently not called directly by the store APIs. However, may be exported
// to support other providers based on it.
//
// Reads the provider's copy of the CRL context. If it exists,
// creates a new CRL context.
typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_READ_CRL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pStoreCrlContext,
    __in DWORD dwFlags,
    __deref_out PCCRL_CONTEXT *ppProvCrlContext
    );

// Called by CertAddEncodedCRLToStore,
// CertAddCRLContextToStore or CertAddSerializedElementToStore before
// adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
// addition to the encoded CRL, the added pCertContext might also
// have properties.
//
// Returns TRUE if its OK to update the the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_WRITE_CRL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwFlags
    );

// Called by CertDeleteCRLFromStore before deleting from the store.
//
// Returns TRUE if its OK to delete from the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_DELETE_CRL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwFlags
    );

// Called by CertSetCRLContextProperty before setting the
// CRL's property. Also called by CertGetCRLContextProperty,
// when getting a hash property that needs to be created and then persisted
// via the set.
//
// Upon input, the property hasn't been set for the pCrlContext parameter.
//
// Returns TRUE if its OK to set the property.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_SET_CRL_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

// Currently not called directly by the store APIs. However, may be exported
// to support other providers based on it.
//
// Reads the provider's copy of the CTL context. If it exists,
// creates a new CTL context.
typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_READ_CTL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pStoreCtlContext,
    __in DWORD dwFlags,
    __deref_out PCCTL_CONTEXT *ppProvCtlContext
    );

// Called by CertAddEncodedCTLToStore,
// CertAddCTLContextToStore or CertAddSerializedElementToStore before
// adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
// addition to the encoded CTL, the added pCertContext might also
// have properties.
//
// Returns TRUE if its OK to update the the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_WRITE_CTL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwFlags
    );

// Called by CertDeleteCTLFromStore before deleting from the store.
//
// Returns TRUE if its OK to delete from the store.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_DELETE_CTL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwFlags
                                                     );

// Called by CertSetCTLContextProperty before setting the
// CTL's property. Also called by CertGetCTLContextProperty,
// when getting a hash property that needs to be created and then persisted
// via the set.
//
// Upon input, the property hasn't been set for the pCtlContext parameter.
//
// Returns TRUE if its OK to set the property.
typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_SET_CTL_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_CONTROL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in DWORD dwFlags,
    __in DWORD dwCtrlType,
    __in_opt void const *pvCtrlPara
    );

typedef struct _CERT_STORE_PROV_FIND_INFO {
    DWORD               cbSize;
    DWORD               dwMsgAndCertEncodingType;
    DWORD               dwFindFlags;
    DWORD               dwFindType;
    const void          *pvFindPara;
} CERT_STORE_PROV_FIND_INFO, *PCERT_STORE_PROV_FIND_INFO;
typedef const CERT_STORE_PROV_FIND_INFO CCERT_STORE_PROV_FIND_INFO,
*PCCERT_STORE_PROV_FIND_INFO;

typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_FIND_CERT)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    __in PCCERT_CONTEXT pPrevCertContext,
    __in DWORD dwFlags,
    __deref_inout void **ppvStoreProvFindInfo,
    __deref_out PCCERT_CONTEXT *ppProvCertContext
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_FREE_FIND_CERT)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pCertContext,
    __in void *pvStoreProvFindInfo,
    __in DWORD dwFlags
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_GET_CERT_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );


typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_FIND_CRL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    __in PCCRL_CONTEXT pPrevCrlContext,
    __in DWORD dwFlags,
    __deref_inout void **ppvStoreProvFindInfo,
    __deref_out PCCRL_CONTEXT *ppProvCrlContext
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_FREE_FIND_CRL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pCrlContext,
    __in void *pvStoreProvFindInfo,
    __in DWORD dwFlags
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_GET_CRL_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

typedef __success(return == TRUE) BOOL (WINAPI *PFN_CERT_STORE_PROV_FIND_CTL)(
    __in HCERTSTOREPROV hStoreProv,
    __in PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    __in PCCTL_CONTEXT pPrevCtlContext,
    __in DWORD dwFlags,
    __deref_inout void **ppvStoreProvFindInfo,
    __deref_out PCCTL_CONTEXT *ppProvCtlContext
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_FREE_FIND_CTL)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pCtlContext,
    __in void *pvStoreProvFindInfo,
    __in DWORD dwFlags
    );

typedef BOOL (WINAPI *PFN_CERT_STORE_PROV_GET_CTL_PROPERTY)(
    __inout HCERTSTOREPROV hStoreProv,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );


//+-------------------------------------------------------------------------
//  Duplicate a cert store handle
//--------------------------------------------------------------------------
WINCRYPT32API
HCERTSTORE
WINAPI
CertDuplicateStore(
    __in HCERTSTORE hCertStore
    );

#define CERT_STORE_SAVE_AS_STORE        1
#define CERT_STORE_SAVE_AS_PKCS7        2
#define CERT_STORE_SAVE_AS_PKCS12       3

#define CERT_STORE_SAVE_TO_FILE         1
#define CERT_STORE_SAVE_TO_MEMORY       2
#define CERT_STORE_SAVE_TO_FILENAME_A   3
#define CERT_STORE_SAVE_TO_FILENAME_W   4
#define CERT_STORE_SAVE_TO_FILENAME     CERT_STORE_SAVE_TO_FILENAME_W

//+-------------------------------------------------------------------------
//  Save the cert store. Extended version with lots of options.
//
//  According to the dwSaveAs parameter, the store can be saved as a
//  serialized store (CERT_STORE_SAVE_AS_STORE) containing properties in
//  addition to encoded certificates, CRLs and CTLs or the store can be saved
//  as a PKCS #7 signed message (CERT_STORE_SAVE_AS_PKCS7) which doesn't
//  include the properties or CTLs.
//
//  Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
//  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't saved into
//  a serialized store.
//
//  For CERT_STORE_SAVE_AS_PKCS7, the dwEncodingType specifies the message
//  encoding type. The dwEncodingType parameter isn't used for
//  CERT_STORE_SAVE_AS_STORE.
//
//  The dwFlags parameter currently isn't used and should be set to 0.
//
//  The dwSaveTo and pvSaveToPara parameters specify where to save the
//  store as follows:
//    CERT_STORE_SAVE_TO_FILE:
//      Saves to the specified file. The file's handle is passed in
//      pvSaveToPara. Given,
//          HANDLE hFile; pvSaveToPara = (void *) hFile;
//
//      For a successful save, the file pointer is positioned after the
//      last write.
//
//    CERT_STORE_SAVE_TO_MEMORY:
//      Saves to the specified memory blob. The pointer to
//      the memory blob is passed in pvSaveToPara. Given,
//          CRYPT_DATA_BLOB SaveBlob; pvSaveToPara = (void *) &SaveBlob;
//      Upon entry, the SaveBlob's pbData and cbData need to be initialized.
//      Upon return, cbData is updated with the actual length.
//      For a length only calculation, pbData should be set to NULL. If
//      pbData is non-NULL and cbData isn't large enough, FALSE is returned
//      with a last error of ERRROR_MORE_DATA.
//
//    CERT_STORE_SAVE_TO_FILENAME_A:
//    CERT_STORE_SAVE_TO_FILENAME_W:
//    CERT_STORE_SAVE_TO_FILENAME:
//      Opens the file and saves to it. The filename is passed in pvSaveToPara.
//      The filename is UNICODE for the "_W" option and ASCII for the "_A"
//      option. For "_W": given,
//          LPCWSTR pwszFilename; pvSaveToPara = (void *) pwszFilename;
//      For "_A": given,
//          LPCSTR pszFilename; pvSaveToPara = (void *) pszFilename;
//
//      Note, the default (without "_A" or "_W") is UNICODE.
//
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSaveStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwEncodingType,
    __in DWORD dwSaveAs,
    __in DWORD dwSaveTo,
    __inout void *pvSaveToPara,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Certificate Store close flags
//--------------------------------------------------------------------------
#define CERT_CLOSE_STORE_FORCE_FLAG         0x00000001
#define CERT_CLOSE_STORE_CHECK_FLAG         0x00000002

//+-------------------------------------------------------------------------
//  Close a cert store handle.
//
//  There needs to be a corresponding close for each open and duplicate.
//
//  Even on the final close, the cert store isn't freed until all of its
//  certificate and CRL contexts have also been freed.
//
//  On the final close, the hCryptProv passed to CertStoreOpen is
//  CryptReleaseContext'ed.
//
//  To force the closure of the store with all of its memory freed, set the
//  CERT_STORE_CLOSE_FORCE_FLAG. This flag should be set when the caller does
//  its own reference counting and wants everything to vanish.
//
//  To check if all the store's certificates and CRLs have been freed and that
//  this is the last CertCloseStore, set the CERT_CLOSE_STORE_CHECK_FLAG. If
//  set and certs, CRLs or stores still need to be freed/closed, FALSE is
//  returned with LastError set to CRYPT_E_PENDING_CLOSE. Note, for FALSE,
//  the store is still closed. This is a diagnostic flag.
//
//  LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE
//  is returned.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertCloseStore(
    __in_opt HCERTSTORE hCertStore,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Get the subject certificate context uniquely identified by its Issuer and
//  SerialNumber from the store.
//
//  If the certificate isn't found, NULL is returned. Otherwise, a pointer to
//  a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling
//  CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a
//  duplicate.
//
//  The returned certificate might not be valid. Normally, it would be
//  verified when getting its issuer certificate (CertGetIssuerCertificateFromStore).
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertGetSubjectCertificateFromStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                      // fields are used
    );

//+-------------------------------------------------------------------------
//  Enumerate the certificate contexts in the store.
//
//  If a certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL to enumerate the first
//  certificate in the store. Successive certificates are enumerated by setting
//  pPrevCertContext to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    __in HCERTSTORE hCertStore,
    __in_opt PCCERT_CONTEXT pPrevCertContext
    );

//+-------------------------------------------------------------------------
//  Find the first or next certificate context in the store.
//
//  The certificate is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR,
//  CERT_FIND_ISSUER_ATTR or CERT_FIND_CTL_USAGE. Otherwise, must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL on the first
//  call to find the certificate. To find the next certificate, the
//  pPrevCertContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in DWORD dwFindFlags,
    __in DWORD dwFindType,
    __in_opt const void *pvFindPara,
    __in_opt PCCERT_CONTEXT pPrevCertContext
    );


//+-------------------------------------------------------------------------
// Certificate comparison functions
//--------------------------------------------------------------------------
#define CERT_COMPARE_MASK           0xFFFF
#define CERT_COMPARE_SHIFT          16
#define CERT_COMPARE_ANY            0
#define CERT_COMPARE_SHA1_HASH      1
#define CERT_COMPARE_NAME           2
#define CERT_COMPARE_ATTR           3
#define CERT_COMPARE_MD5_HASH       4
#define CERT_COMPARE_PROPERTY       5
#define CERT_COMPARE_PUBLIC_KEY     6
#define CERT_COMPARE_HASH           CERT_COMPARE_SHA1_HASH
#define CERT_COMPARE_NAME_STR_A     7
#define CERT_COMPARE_NAME_STR_W     8
#define CERT_COMPARE_KEY_SPEC       9
#define CERT_COMPARE_ENHKEY_USAGE   10
#define CERT_COMPARE_CTL_USAGE      CERT_COMPARE_ENHKEY_USAGE
#define CERT_COMPARE_SUBJECT_CERT   11
#define CERT_COMPARE_ISSUER_OF      12
#define CERT_COMPARE_EXISTING       13
#define CERT_COMPARE_SIGNATURE_HASH 14
#define CERT_COMPARE_KEY_IDENTIFIER 15
#define CERT_COMPARE_CERT_ID        16
#define CERT_COMPARE_CROSS_CERT_DIST_POINTS 17

#define CERT_COMPARE_PUBKEY_MD5_HASH 18

#define CERT_COMPARE_SUBJECT_INFO_ACCESS 19

//+-------------------------------------------------------------------------
//  dwFindType
//
//  The dwFindType definition consists of two components:
//   - comparison function
//   - certificate information flag
//--------------------------------------------------------------------------
#define CERT_FIND_ANY           (CERT_COMPARE_ANY << CERT_COMPARE_SHIFT)
#define CERT_FIND_SHA1_HASH     (CERT_COMPARE_SHA1_HASH << CERT_COMPARE_SHIFT)
#define CERT_FIND_MD5_HASH      (CERT_COMPARE_MD5_HASH << CERT_COMPARE_SHIFT)
#define CERT_FIND_SIGNATURE_HASH (CERT_COMPARE_SIGNATURE_HASH << CERT_COMPARE_SHIFT)
#define CERT_FIND_KEY_IDENTIFIER (CERT_COMPARE_KEY_IDENTIFIER << CERT_COMPARE_SHIFT)
#define CERT_FIND_HASH          CERT_FIND_SHA1_HASH
#define CERT_FIND_PROPERTY      (CERT_COMPARE_PROPERTY << CERT_COMPARE_SHIFT)
#define CERT_FIND_PUBLIC_KEY    (CERT_COMPARE_PUBLIC_KEY << CERT_COMPARE_SHIFT)
#define CERT_FIND_SUBJECT_NAME  (CERT_COMPARE_NAME << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_SUBJECT_FLAG)
#define CERT_FIND_SUBJECT_ATTR  (CERT_COMPARE_ATTR << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_SUBJECT_FLAG)
#define CERT_FIND_ISSUER_NAME   (CERT_COMPARE_NAME << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_ISSUER_FLAG)
#define CERT_FIND_ISSUER_ATTR   (CERT_COMPARE_ATTR << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_ISSUER_FLAG)
#define CERT_FIND_SUBJECT_STR_A (CERT_COMPARE_NAME_STR_A << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_SUBJECT_FLAG)
#define CERT_FIND_SUBJECT_STR_W (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_SUBJECT_FLAG)
#define CERT_FIND_SUBJECT_STR   CERT_FIND_SUBJECT_STR_W
#define CERT_FIND_ISSUER_STR_A  (CERT_COMPARE_NAME_STR_A << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_ISSUER_FLAG)
#define CERT_FIND_ISSUER_STR_W  (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | \
                                 CERT_INFO_ISSUER_FLAG)
#define CERT_FIND_ISSUER_STR    CERT_FIND_ISSUER_STR_W
#define CERT_FIND_KEY_SPEC      (CERT_COMPARE_KEY_SPEC << CERT_COMPARE_SHIFT)
#define CERT_FIND_ENHKEY_USAGE  (CERT_COMPARE_ENHKEY_USAGE << CERT_COMPARE_SHIFT)
#define CERT_FIND_CTL_USAGE     CERT_FIND_ENHKEY_USAGE

#define CERT_FIND_SUBJECT_CERT  (CERT_COMPARE_SUBJECT_CERT << CERT_COMPARE_SHIFT)
#define CERT_FIND_ISSUER_OF     (CERT_COMPARE_ISSUER_OF << CERT_COMPARE_SHIFT)
#define CERT_FIND_EXISTING      (CERT_COMPARE_EXISTING << CERT_COMPARE_SHIFT)
#define CERT_FIND_CERT_ID       (CERT_COMPARE_CERT_ID << CERT_COMPARE_SHIFT)
#define CERT_FIND_CROSS_CERT_DIST_POINTS \
                    (CERT_COMPARE_CROSS_CERT_DIST_POINTS << CERT_COMPARE_SHIFT)


#define CERT_FIND_PUBKEY_MD5_HASH \
                    (CERT_COMPARE_PUBKEY_MD5_HASH << CERT_COMPARE_SHIFT)

#define CERT_FIND_SUBJECT_INFO_ACCESS \
                    (CERT_COMPARE_SUBJECT_INFO_ACCESS << CERT_COMPARE_SHIFT)

//+-------------------------------------------------------------------------
//  CERT_FIND_ANY
//
//  Find any certificate.
//
//  pvFindPara isn't used.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_HASH
//
//  Find a certificate with the specified hash.
//
//  pvFindPara points to a CRYPT_HASH_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_KEY_IDENTIFIER
//
//  Find a certificate with the specified KeyIdentifier. Gets the
//  CERT_KEY_IDENTIFIER_PROP_ID property and compares with the input
//  CRYPT_HASH_BLOB.
//
//  pvFindPara points to a CRYPT_HASH_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_PROPERTY
//
//  Find a certificate having the specified property.
//
//  pvFindPara points to a DWORD containing the PROP_ID
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_PUBLIC_KEY
//
//  Find a certificate matching the specified public key.
//
//  pvFindPara points to a CERT_PUBLIC_KEY_INFO containing the public key
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_SUBJECT_NAME
//  CERT_FIND_ISSUER_NAME
//
//  Find a certificate with the specified subject/issuer name. Does an exact
//  match of the entire name.
//
//  Restricts search to certificates matching the dwCertEncodingType.
//
//  pvFindPara points to a CERT_NAME_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_SUBJECT_ATTR
//  CERT_FIND_ISSUER_ATTR
//
//  Find a certificate with the specified subject/issuer attributes.
//
//  Compares the attributes in the subject/issuer name with the
//  Relative Distinguished Name's (CERT_RDN) array of attributes specified in
//  pvFindPara. The comparison iterates through the CERT_RDN attributes and looks
//  for an attribute match in any of the subject/issuer's RDNs.
//
//  The CERT_RDN_ATTR fields can have the following special values:
//    pszObjId == NULL              - ignore the attribute object identifier
//    dwValueType == RDN_ANY_TYPE   - ignore the value type
//    Value.pbData == NULL          - match any value
//
//  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set in dwFindFlags to do
//  a case insensitive match. Otherwise, defaults to an exact, case sensitive
//  match.
//
//  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set in dwFindFlags if the RDN was
//  initialized with unicode strings as for
//  CryptEncodeObject(X509_UNICODE_NAME).
//
//  Restricts search to certificates matching the dwCertEncodingType.
//
//  pvFindPara points to a CERT_RDN (defined in wincert.h).
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_SUBJECT_STR_A
//  CERT_FIND_SUBJECT_STR_W | CERT_FIND_SUBJECT_STR
//  CERT_FIND_ISSUER_STR_A
//  CERT_FIND_ISSUER_STR_W  | CERT_FIND_ISSUER_STR
//
//  Find a certificate containing the specified subject/issuer name string.
//
//  First, the certificate's subject/issuer is converted to a name string
//  via CertNameToStrA/CertNameToStrW(CERT_SIMPLE_NAME_STR). Then, a
//  case insensitive substring within string match is performed.
//
//  Restricts search to certificates matching the dwCertEncodingType.
//
//  For *_STR_A, pvFindPara points to a null terminated character string.
//  For *_STR_W, pvFindPara points to a null terminated wide character string.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_KEY_SPEC
//
//  Find a certificate having a CERT_KEY_SPEC_PROP_ID property matching
//  the specified KeySpec.
//
//  pvFindPara points to a DWORD containing the KeySpec.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_ENHKEY_USAGE
//
//  Find a certificate having the szOID_ENHANCED_KEY_USAGE extension or
//  the CERT_ENHKEY_USAGE_PROP_ID and matching the specified pszUsageIdentifers.
//
//  pvFindPara points to a CERT_ENHKEY_USAGE data structure. If pvFindPara
//  is NULL or CERT_ENHKEY_USAGE's cUsageIdentifier is 0, then, matches any
//  certificate having enhanced key usage.
//
//  If the CERT_FIND_VALID_ENHKEY_USAGE_FLAG is set, then, only does a match
//  for certificates that are valid for the specified usages. By default,
//  the ceriticate must be valid for all usages. CERT_FIND_OR_ENHKEY_USAGE_FLAG
//  can be set, if the certificate only needs to be valid for one of the
//  specified usages. Note, CertGetValidUsages() is called to get the
//  certificate's list of valid usages. Only the CERT_FIND_OR_ENHKEY_USAGE_FLAG
//  is applicable when this flag is set.
//
//  The CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG can be set in dwFindFlags to
//  also match a certificate without either the extension or property.
//
//  If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set in dwFindFlags, finds
//  certificates without the key usage extension or property. Setting this
//  flag takes precedence over pvFindPara being NULL.
//
//  If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only does a match
//  using the extension. If pvFindPara is NULL or cUsageIdentifier is set to
//  0, finds certificates having the extension. If
//  CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate
//  without the extension. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds
//  certificates without the extension.
//
//  If the CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG is set, then, only does a match
//  using the property. If pvFindPara is NULL or cUsageIdentifier is set to
//  0, finds certificates having the property. If
//  CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate
//  without the property. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds
//  certificates without the property.
//
//  If CERT_FIND_OR_ENHKEY_USAGE_FLAG is set, does an "OR" match of any of
//  the specified pszUsageIdentifiers. If not set, then, does an "AND" match
//  of all of the specified pszUsageIdentifiers.
//--------------------------------------------------------------------------

#define CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG  0x1
#define CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG  0x2
#define CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG 0x4
#define CERT_FIND_NO_ENHKEY_USAGE_FLAG        0x8
#define CERT_FIND_OR_ENHKEY_USAGE_FLAG        0x10
#define CERT_FIND_VALID_ENHKEY_USAGE_FLAG     0x20

#define CERT_FIND_OPTIONAL_CTL_USAGE_FLAG   CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG

#define CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG \
        CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG

#define CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG \
        CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG

#define CERT_FIND_NO_CTL_USAGE_FLAG         CERT_FIND_NO_ENHKEY_USAGE_FLAG
#define CERT_FIND_OR_CTL_USAGE_FLAG         CERT_FIND_OR_ENHKEY_USAGE_FLAG
#define CERT_FIND_VALID_CTL_USAGE_FLAG      CERT_FIND_VALID_ENHKEY_USAGE_FLAG

//+-------------------------------------------------------------------------
//  CERT_FIND_CERT_ID
//
//  Find a certificate with the specified CERT_ID.
//
//  pvFindPara points to a CERT_ID.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_CROSS_CERT_DIST_POINTS
//
//  Find a certificate having either a cross certificate distribution
//  point extension or property.
//
//  pvFindPara isn't used.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_FIND_SUBJECT_INFO_ACCESS
//
//  Find a certificate having either a SubjectInfoAccess extension or
//  property.
//
//  pvFindPara isn't used.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Get the certificate context from the store for the first or next issuer
//  of the specified subject certificate. Perform the enabled
//  verification checks on the subject. (Note, the checks are on the subject
//  using the returned issuer certificate.)
//
//  If the first or next issuer certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  For a self signed subject certificate, NULL is returned with LastError set
//  to CERT_STORE_SELF_SIGNED. The enabled verification checks are still done.
//
//  The pSubjectContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  An issuer may have multiple certificates. This may occur when the validity
//  period is about to change. pPrevIssuerContext MUST BE NULL on the first
//  call to get the issuer. To get the next certificate for the issuer, the
//  pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the subject certificate context:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the returned
//                                      issuer certificate to verify the
//                                      signature on the subject certificate.
//                                      Note, if pSubjectContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the subject certificate's
//                                      validity period
//      CERT_STORE_REVOCATION_FLAG    - check if the subject certificate is on
//                                      the issuer's revocation list
//
//  If an enabled verification check fails, then, its flag is set upon return.
//  If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a
//  CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to
//  the CERT_STORE_REVOCATION_FLAG.
//
//  If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then,
//  CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate
//  in the store.
//
//  For a verification check failure, a pointer to the issuer's CERT_CONTEXT
//  is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    __in HCERTSTORE hCertStore,
    __in PCCERT_CONTEXT pSubjectContext,
    __in_opt PCCERT_CONTEXT pPrevIssuerContext,
    __inout DWORD *pdwFlags
    );

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer. Same checks and flags definitions as for the above
//  CertGetIssuerCertificateFromStore.
//
//  If you are only checking CERT_STORE_TIME_VALIDITY_FLAG, then, the
//  issuer can be NULL.
//
//  For a verification check failure, SUCCESS is still returned.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    __in PCCERT_CONTEXT pSubject,
    __in_opt PCCERT_CONTEXT pIssuer,
    __inout DWORD *pdwFlags
    );

//+-------------------------------------------------------------------------
//  Duplicate a certificate context
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    __in_opt PCCERT_CONTEXT pCertContext
    );

//+-------------------------------------------------------------------------
//  Create a certificate context from the encoded certificate. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded certificate in the created context.
//
//  If unable to decode and create the certificate context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned.
//  CERT_CONTEXT must be freed by calling CertFreeCertificateContext.
//  CertDuplicateCertificateContext can be called to make a duplicate.
//
//  CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called
//  to store properties for the certificate.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    __in DWORD dwCertEncodingType,
    __in_bcount(cbCertEncoded) const BYTE *pbCertEncoded,
    __in DWORD cbCertEncoded
    );

//+-------------------------------------------------------------------------
//  Free a certificate context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, find, duplicate or create.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertFreeCertificateContext(
    __in_opt PCCERT_CONTEXT pCertContext
    );

//+-------------------------------------------------------------------------
//  Set the property for the specified certificate context.
//
//  The type definition for pvData depends on the dwPropId value. There are
//  five predefined types:
//      CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's
//      private key is passed in pvData. Updates the hCryptProv field
//      of the CERT_KEY_CONTEXT_PROP_ID. If the CERT_KEY_CONTEXT_PROP_ID
//      doesn't exist, its created with all the other fields zeroed out. If
//      CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly
//      released when either the property is set to NULL or on the final
//      free of the CertContext.
//
//      CERT_NCRYPT_KEY_HANDLE_PROP_ID - a NCRYPT_KEY_HANDLE for the
//      certificate's private key is passed in pvData. The dwKeySpec is
//      set to CERT_NCRYPT_KEY_SPEC.
//
//      CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID - a
//      HCRYPTPROV_OR_NCRYPT_KEY_HANDLE for the certificates's private
//      key is passed in pvData.  NCryptIsKeyHandle()
//      is called to determine if this is a CNG NCRYPT_KEY_HANDLE.
//      For a NCRYPT_KEY_HANDLE does a CERT_NCRYPT_KEY_HANDLE_PROP_ID set.
//      Otherwise, does a CERT_KEY_PROV_HANDLE_PROP_ID set.
//
//      CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's
//      private key is passed in pvData.
//
//      CERT_SHA1_HASH_PROP_ID       -
//      CERT_MD5_HASH_PROP_ID        -
//      CERT_SIGNATURE_HASH_PROP_ID  - normally, a hash property is implicitly
//      set by doing a CertGetCertificateContextProperty. pvData points to a
//      CRYPT_HASH_BLOB.
//
//      CERT_KEY_CONTEXT_PROP_ID - a PCERT_KEY_CONTEXT for the certificate's
//      private key is passed in pvData. The CERT_KEY_CONTEXT contains both the
//      hCryptProv and dwKeySpec for the private key. A dwKeySpec of
//      CERT_NCRYPT_KEY_SPEC selects the hNCryptKey choice.
//      See the CERT_KEY_PROV_HANDLE_PROP_ID for more information about
//      the hCryptProv field and dwFlags settings. Note, more fields may
//      be added for this property. The cbSize field value will be adjusted
//      accordingly.
//
//      CERT_KEY_SPEC_PROP_ID - the dwKeySpec for the private key. pvData
//      points to a DWORD containing the KeySpec
//
//      CERT_ENHKEY_USAGE_PROP_ID - enhanced key usage definition for the
//      certificate. pvData points to a CRYPT_DATA_BLOB containing an
//      ASN.1 encoded CERT_ENHKEY_USAGE (encoded via
//      CryptEncodeObject(X509_ENHANCED_KEY_USAGE).
//
//      CERT_NEXT_UPDATE_LOCATION_PROP_ID - location of the next update.
//      Currently only applicable to CTLs. pvData points to a CRYPT_DATA_BLOB
//      containing an ASN.1 encoded CERT_ALT_NAME_INFO (encoded via
//      CryptEncodeObject(X509_ALTERNATE_NAME)).
//
//      CERT_FRIENDLY_NAME_PROP_ID - friendly name for the cert, CRL or CTL.
//      pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
//      terminated unicode, wide character string.
//      cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
//
//      CERT_DESCRIPTION_PROP_ID - description for the cert, CRL or CTL.
//      pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
//      terminated unicode, wide character string.
//      cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
//
//      CERT_ARCHIVED_PROP_ID - when this property is set, the certificate
//      is skipped during enumeration. Note, certificates having this property
//      are still found for explicit finds, such as, finding a certificate
//      with a specific hash or finding a certificate having a specific issuer
//      and serial number. pvData points to a CRYPT_DATA_BLOB. This blob
//      can be NULL (pbData = NULL, cbData = 0).
//
//      CERT_PUBKEY_ALG_PARA_PROP_ID - for public keys supporting
//      algorithm parameter inheritance. pvData points to a CRYPT_OBJID_BLOB
//      containing the ASN.1 encoded PublicKey Algorithm Parameters. For
//      DSS this would be the parameters encoded via
//      CryptEncodeObject(X509_DSS_PARAMETERS). This property may be set
//      by CryptVerifyCertificateSignatureEx().
//
//      CERT_CROSS_CERT_DIST_POINTS_PROP_ID - location of the cross certs.
//      Currently only applicable to certs. pvData points to a CRYPT_DATA_BLOB
//      containing an ASN.1 encoded CROSS_CERT_DIST_POINTS_INFO (encoded via
//      CryptEncodeObject(X509_CROSS_CERT_DIST_POINTS)).
//
//      CERT_ENROLLMENT_PROP_ID - enrollment information of the pending request.
//      It contains RequestID, CADNSName, CAName, and FriendlyName.
//      The data format is defined as, the first 4 bytes - pending request ID,
//      next 4 bytes - CADNSName size in characters including null-terminator
//      followed by CADNSName string with null-terminator,
//      next 4 bytes - CAName size in characters including null-terminator
//      followed by CAName string with null-terminator,
//      next 4 bytes - FriendlyName size in characters including null-terminator
//      followed by FriendlyName string with null-terminator.
//
//      CERT_DATE_STAMP_PROP_ID - contains the time when added to the store
//      by an admin tool. pvData points to a CRYPT_DATA_BLOB containing
//      the FILETIME.
//
//      CERT_RENEWAL_PROP_ID - contains the hash of renewed certificate
//
//      CERT_OCSP_RESPONSE_PROP_ID - contains the encoded OCSP response.
//      CryptDecodeObject/CryptEncodeObject using
//      lpszStructType = OCSP_RESPONSE.
//      pvData points to a CRYPT_DATA_BLOB containing the encoded OCSP response.
//      If this property is present, CertVerifyRevocation() will first attempt
//      to use before doing an URL retrieval.
//
//      CERT_SOURCE_LOCATION_PROP_ID - contains source location of the CRL or
//      OCSP. pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
//      terminated unicode, wide character string. Where,
//      cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
//
//      CERT_SOURCE_URL_PROP_ID - contains URL for the CRL or OCSP. pvData
//      is the same as for CERT_SOURCE_LOCATION_PROP_ID.
//
//  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
//
//  If the property already exists, then, the old value is deleted and silently
//  replaced. Setting, pvData to NULL, deletes the property.
//
//  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG can be set to ignore any
//  provider write errors and always update the cached context's property.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetCertificateContextProperty(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

// Set this flag to ignore any store provider write errors and always update
// the cached context's property
#define CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG     0x80000000

// Set this flag to inhibit the persisting of this property
#define CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG          0x40000000

//+-------------------------------------------------------------------------
//  Get the property for the specified certificate context.
//
//  For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV.
//  The CERT_NCRYPT_KEY_SPEC NCRYPT_KEY_HANDLE choice isn't returned.
//
//  For CERT_NCRYPT_KEY_HANDLE_PROP_ID, pvData points to a NCRYPT_KEY_HANDLE.
//  Only returned for the CERT_NCRYPT_KEY_SPEC choice.
//
//  For CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID, pvData points to a
//  HCRYPTPROV_OR_NCRYPT_KEY_HANDLE. Returns either the HCRYPTPROV or
//  NCRYPT_KEY_HANDLE choice.
//
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure.
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  For CERT_KEY_CONTEXT_PROP_ID, pvData points to a CERT_KEY_CONTEXT structure.
//
//  For CERT_KEY_SPEC_PROP_ID, pvData points to a DWORD containing the KeySpec.
//  If the CERT_KEY_CONTEXT_PROP_ID exists, the KeySpec is obtained from there.
//  Otherwise, if the CERT_KEY_PROV_INFO_PROP_ID exists, its the source
//  of the KeySpec. CERT_NCRYPT_KEY_SPEC is returned if the
//  CERT_NCRYPT_KEY_HANDLE_PROP_ID has been set.
//
//  For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashCertificate()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//
//  For CERT_SIGNATURE_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashToBeSigned()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//
//  For CERT_ACCESS_STATE_PROP_ID, pvData points to a DWORD containing the
//  access state flags. The appropriate CERT_ACCESS_STATE_*_FLAG's are set
//  in the returned DWORD. See the CERT_ACCESS_STATE_*_FLAG definitions
//  above. Note, this property is read only. It can't be set.
//
//  For CERT_KEY_IDENTIFIER_PROP_ID, if property doesn't already exist,
//  first searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. Next,
//  does SHA1 hash of the certficate's SubjectPublicKeyInfo. pvData
//  points to the key identifier bytes. Normally, the length is 20 bytes.
//
//  For CERT_PUBKEY_ALG_PARA_PROP_ID, pvPara points to the ASN.1 encoded
//  PublicKey Algorithm Parameters. This property will only be set
//  for public keys supporting algorithm parameter inheritance and when the
//  parameters have been omitted from the encoded and signed certificate.
//
//  For CERT_DATE_STAMP_PROP_ID, pvPara points to a FILETIME updated by
//  an admin tool to indicate when the certificate was added to the store.
//
//  For CERT_OCSP_RESPONSE_PROP_ID, pvPara points to an encoded OCSP response.
//
//  For CERT_SOURCE_LOCATION_PROP_ID and CERT_SOURCE_URL_PROP_ID,
//  pvPara points to a NULL terminated unicode, wide character string.
//
//  For all other PROP_IDs, pvData points to an encoded array of bytes.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetCertificateContextProperty(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwPropId,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified certificate context.
//
//  To get the first property, set dwPropId to 0. The ID of the first
//  property is returned. To get the next property, set dwPropId to the
//  ID returned by the last call. To enumerate all the properties continue
//  until 0 is returned.
//
//  CertGetCertificateContextProperty is called to get the property's data.
//
//  Note, since, the CERT_KEY_PROV_HANDLE_PROP_ID and CERT_KEY_SPEC_PROP_ID
//  properties are stored as fields in the CERT_KEY_CONTEXT_PROP_ID
//  property, they aren't enumerated individually.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertEnumCertificateContextProperties(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwPropId
    );


//+-------------------------------------------------------------------------
//  Creates a CTL entry whose attributes are the certificate context's
//  properties.
//
//  The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
//
//  The certificate properties are added as attributes. The property attribute
//  OID is the decimal PROP_ID preceded by szOID_CERT_PROP_ID_PREFIX. Each
//  property value is copied as a single attribute value.
//
//  Any additional attributes to be included in the CTL entry can be passed
//  in via the cOptAttr and rgOptAttr parameters.
//
//  CTL_ENTRY_FROM_PROP_CHAIN_FLAG can be set in dwFlags, to force the
//  inclusion of the chain building hash properties as attributes.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertCreateCTLEntryFromCertificateContextProperties(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD cOptAttr,
    __in_ecount_opt(cOptAttr) PCRYPT_ATTRIBUTE rgOptAttr,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out_bcount_part_opt(*pcbCtlEntry, *pcbCtlEntry) PCTL_ENTRY pCtlEntry,
    __inout DWORD *pcbCtlEntry
    );

// Set this flag to get and include the chain building hash properties
// as attributes in the CTL entry
#define CTL_ENTRY_FROM_PROP_CHAIN_FLAG                  0x1


//+-------------------------------------------------------------------------
//  Sets properties on the certificate context using the attributes in
//  the CTL entry.
//
//  The property attribute OID is the decimal PROP_ID preceded by
//  szOID_CERT_PROP_ID_PREFIX. Only attributes containing such an OID are
//  copied.
//
//  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG may be set in dwFlags.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetCertificateContextPropertiesFromCTLEntry(
    __in PCCERT_CONTEXT pCertContext,
    __in PCTL_ENTRY pCtlEntry,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Get the first or next CRL context from the store for the specified
//  issuer certificate. Perform the enabled verification checks on the CRL.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext. However, the free must be
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  The pIssuerContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  If pIssuerContext == NULL, finds all the CRLs in the store.
//
//  An issuer may have multiple CRLs. For example, it generates delta CRLs
//  using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first
//  call to get the CRL. To get the next CRL for the issuer, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the returned CRL:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the
//                                      issuer's certificate to verify the
//                                      signature on the returned CRL.
//                                      Note, if pIssuerContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the CRL's ThisUpdate and
//                                      NextUpdate validity period.
//      CERT_STORE_BASE_CRL_FLAG      - get base CRL.
//      CERT_STORE_DELTA_CRL_FLAG     - get delta CRL.
//
//  If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is
//  set, then, only returns either a base or delta CRL. In any case, the
//  appropriate base or delta flag will be cleared upon returned. If both
//  flags are set, then, only one of flags will be cleared.
//
//  If an enabled verification check fails, then, its flag is set upon return.
//
//  If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG
//  always fails and the CERT_STORE_NO_ISSUER_FLAG is also set.
//
//  For a verification check failure, a pointer to the first or next
//  CRL_CONTEXT is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CertGetCRLFromStore(
    __in HCERTSTORE hCertStore,
    __in_opt PCCERT_CONTEXT pIssuerContext,
    __in_opt PCCRL_CONTEXT pPrevCrlContext,
    __inout DWORD *pdwFlags
    );

//+-------------------------------------------------------------------------
//  Enumerate the CRL contexts in the store.
//
//  If a CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL to enumerate the first
//  CRL in the store. Successive CRLs are enumerated by setting
//  pPrevCrlContext to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CertEnumCRLsInStore(
    __in HCERTSTORE hCertStore,
    __in_opt PCCRL_CONTEXT pPrevCrlContext
    );

//+-------------------------------------------------------------------------
//  Find the first or next CRL context in the store.
//
//  The CRL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL on the first
//  call to find the CRL. To find the next CRL, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CertFindCRLInStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in DWORD dwFindFlags,
    __in DWORD dwFindType,
    __in_opt const void *pvFindPara,
    __in_opt PCCRL_CONTEXT pPrevCrlContext
    );

#define CRL_FIND_ANY                0
#define CRL_FIND_ISSUED_BY          1
#define CRL_FIND_EXISTING           2
#define CRL_FIND_ISSUED_FOR         3

//+-------------------------------------------------------------------------
//  CRL_FIND_ANY
//
//  Find any CRL.
//
//  pvFindPara isn't used.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CRL_FIND_ISSUED_BY
//
//  Find CRL matching the specified issuer.
//
//  pvFindPara is the PCCERT_CONTEXT of the CRL issuer. May be NULL to
//  match any issuer.
//
//  By default, only does issuer name matching. The following flags can be
//  set in dwFindFlags to do additional filtering.
//
//  If CRL_FIND_ISSUED_BY_AKI_FLAG is set in dwFindFlags, then, checks if the
//  CRL has an Authority Key Identifier (AKI) extension. If the CRL has an
//  AKI, then, only returns a CRL whose AKI matches the issuer.
//
//  Note, the AKI extension has the following OID:
//  szOID_AUTHORITY_KEY_IDENTIFIER2 and its corresponding data structure.
//
//  If CRL_FIND_ISSUED_BY_SIGNATURE_FLAG is set in dwFindFlags, then,
//  uses the public key in the issuer's certificate to verify the
//  signature on the CRL. Only returns a CRL having a valid signature.
//
//  If CRL_FIND_ISSUED_BY_DELTA_FLAG is set in dwFindFlags, then, only
//  returns a delta CRL.
//
//  If CRL_FIND_ISSUED_BY_BASE_FLAG is set in dwFindFlags, then, only
//  returns a base CRL.
//--------------------------------------------------------------------------
#define CRL_FIND_ISSUED_BY_AKI_FLAG         0x1
#define CRL_FIND_ISSUED_BY_SIGNATURE_FLAG   0x2
#define CRL_FIND_ISSUED_BY_DELTA_FLAG       0x4
#define CRL_FIND_ISSUED_BY_BASE_FLAG        0x8

//+-------------------------------------------------------------------------
//  CRL_FIND_EXISTING
//
//  Find existing CRL in the store.
//
//  pvFindPara is the PCCRL_CONTEXT of the CRL to check if it already
//  exists in the store.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CRL_FIND_ISSUED_FOR
//
//  Find CRL for the specified subject and its issuer.
//
//  pvFindPara points to the following CRL_FIND_ISSUED_FOR_PARA which contains
//  both the subject and issuer certificates. Not optional.
//
//  The subject's issuer name is used to match the CRL's issuer name. Otherwise,
//  the issuer's certificate is used the same as in the above
//  CRL_FIND_ISSUED_BY.
//
//  Note, when cross certificates are used, the subject name in the issuer's
//  certificate may not match the issuer name in the subject certificate and
//  its corresponding CRL.
//
//  All of the above CRL_FIND_ISSUED_BY_*_FLAGS apply to this find type.
//--------------------------------------------------------------------------
typedef struct _CRL_FIND_ISSUED_FOR_PARA {
    PCCERT_CONTEXT              pSubjectCert;
    PCCERT_CONTEXT              pIssuerCert;
} CRL_FIND_ISSUED_FOR_PARA, *PCRL_FIND_ISSUED_FOR_PARA;


//+-------------------------------------------------------------------------
//  Duplicate a CRL context
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CertDuplicateCRLContext(
    __in_opt PCCRL_CONTEXT pCrlContext
    );

//+-------------------------------------------------------------------------
//  Create a CRL context from the encoded CRL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CRL in the created context.
//
//  If unable to decode and create the CRL context, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned.
//  CRL_CONTEXT must be freed by calling CertFreeCRLContext.
//  CertDuplicateCRLContext can be called to make a duplicate.
//
//  CertSetCRLContextProperty and CertGetCRLContextProperty can be called
//  to store properties for the CRL.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CertCreateCRLContext(
    __in DWORD dwCertEncodingType,
    __in_bcount(cbCrlEncoded) const BYTE *pbCrlEncoded,
    __in DWORD cbCrlEncoded
    );

//+-------------------------------------------------------------------------
//  Free a CRL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertFreeCRLContext(
    __in_opt PCCRL_CONTEXT pCrlContext
    );

//+-------------------------------------------------------------------------
//  Set the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetCRLContextProperty(
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

//+-------------------------------------------------------------------------
//  Get the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID, CERT_MD5_HASH_PROP_ID or
//  CERT_SIGNATURE_HASH_PROP_ID is the predefined property of most interest.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetCRLContextProperty(
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwPropId,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CRL context.
//
//  To get the first property, set dwPropId to 0. The ID of the first
//  property is returned. To get the next property, set dwPropId to the
//  ID returned by the last call. To enumerate all the properties continue
//  until 0 is returned.
//
//  CertGetCRLContextProperty is called to get the property's data.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertEnumCRLContextProperties(
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwPropId
    );


//+-------------------------------------------------------------------------
//  Search the CRL's list of entries for the specified certificate.
//
//  TRUE is returned if we were able to search the list. Otherwise, FALSE is
//  returned,
//
//  For success, if the certificate was found in the list, *ppCrlEntry is
//  updated with a pointer to the entry. Otherwise, *ppCrlEntry is set to NULL.
//  The returned entry isn't allocated and must not be freed.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 or NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertFindCertificateInCRL(
    __in PCCERT_CONTEXT pCert,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __deref_out_opt PCRL_ENTRY *ppCrlEntry
    );

//+-------------------------------------------------------------------------
//  Is the specified CRL valid for the certificate.
//
//  Returns TRUE if the CRL's list of entries would contain the certificate
//  if it was revoked. Note, doesn't check that the certificate is in the
//  list of entries.
//
//  If the CRL has an Issuing Distribution Point (IDP) extension, checks
//  that it's valid for the subject certificate.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 and NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertIsValidCRLForCertificate(
    __in PCCERT_CONTEXT pCert,
    __in PCCRL_CONTEXT pCrl,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );


//+-------------------------------------------------------------------------
// Add certificate/CRL, encoded, context or element disposition values.
//--------------------------------------------------------------------------
#define CERT_STORE_ADD_NEW                                  1
#define CERT_STORE_ADD_USE_EXISTING                         2
#define CERT_STORE_ADD_REPLACE_EXISTING                     3
#define CERT_STORE_ADD_ALWAYS                               4
#define CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES  5
#define CERT_STORE_ADD_NEWER                                6
#define CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES             7


//+-------------------------------------------------------------------------
//  Add the encoded certificate to the store according to the specified
//  disposition action.
//
//  Makes a copy of the encoded certificate before adding to the store.
//
//  dwAddDispostion specifies the action to take if the certificate
//  already exists in the store. This parameter must be one of the following
//  values:
//    CERT_STORE_ADD_NEW
//      Fails if the certificate already exists in the store. LastError
//      is set to CRYPT_E_EXISTS.
//    CERT_STORE_ADD_USE_EXISTING
//      If the certifcate already exists, then, its used and if ppCertContext
//      is non-NULL, the existing context is duplicated.
//    CERT_STORE_ADD_REPLACE_EXISTING
//      If the certificate already exists, then, the existing certificate
//      context is deleted before creating and adding the new context.
//    CERT_STORE_ADD_ALWAYS
//      No check is made to see if the certificate already exists. A
//      new certificate context is always created. This may lead to
//      duplicates in the store.
//    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
//      If the certificate already exists, then, its used.
//    CERT_STORE_ADD_NEWER
//      Fails if the certificate already exists in the store AND the NotBefore
//      time of the existing certificate is equal to or greater than the
//      NotBefore time of the new certificate being added. LastError
//      is set to CRYPT_E_EXISTS.
//
//      If an older certificate is replaced, same as
//      CERT_STORE_ADD_REPLACE_EXISTING.
//
//      For CRLs or CTLs compares the ThisUpdate times.
//
//    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
//      Same as CERT_STORE_ADD_NEWER. However, if an older certificate is
//      replaced, same as CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES.
//
//  CertGetSubjectCertificateFromStore is called to determine if the
//  certificate already exists in the store.
//
//  ppCertContext can be NULL, indicating the caller isn't interested
//  in getting the CERT_CONTEXT of the added or existing certificate.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddEncodedCertificateToStore(
    __in_opt HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in_bcount(cbCertEncoded) const BYTE *pbCertEncoded,
    __in DWORD cbCertEncoded,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCERT_CONTEXT *ppCertContext
    );

//+-------------------------------------------------------------------------
//  Add the certificate context to the store according to the specified
//  disposition action.
//
//  In addition to the encoded certificate, the context's properties are
//  also copied.  Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
//  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
//
//  Makes a copy of the certificate context before adding to the store.
//
//  dwAddDispostion specifies the action to take if the certificate
//  already exists in the store. This parameter must be one of the following
//  values:
//    CERT_STORE_ADD_NEW
//      Fails if the certificate already exists in the store. LastError
//      is set to CRYPT_E_EXISTS.
//    CERT_STORE_ADD_USE_EXISTING
//      If the certifcate already exists, then, its used and if ppStoreContext
//      is non-NULL, the existing context is duplicated. Iterates
//      through pCertContext's properties and only copies the properties
//      that don't already exist. The SHA1 and MD5 hash properties aren't
//      copied.
//    CERT_STORE_ADD_REPLACE_EXISTING
//      If the certificate already exists, then, the existing certificate
//      context is deleted before creating and adding a new context.
//      Properties are copied before doing the add.
//    CERT_STORE_ADD_ALWAYS
//      No check is made to see if the certificate already exists. A
//      new certificate context is always created and added. This may lead to
//      duplicates in the store. Properties are
//      copied before doing the add.
//    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
//      If the certificate already exists, then, the existing certificate
//      context is used. Properties from the added context are copied and
//      replace existing properties. However, any existing properties not
//      in the added context remain and aren't deleted.
//    CERT_STORE_ADD_NEWER
//      Fails if the certificate already exists in the store AND the NotBefore
//      time of the existing context is equal to or greater than the
//      NotBefore time of the new context being added. LastError
//      is set to CRYPT_E_EXISTS.
//
//      If an older context is replaced, same as
//      CERT_STORE_ADD_REPLACE_EXISTING.
//
//      For CRLs or CTLs compares the ThisUpdate times.
//
//    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
//      Same as CERT_STORE_ADD_NEWER. However, if an older context is
//      replaced, same as CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES.
//
//  CertGetSubjectCertificateFromStore is called to determine if the
//  certificate already exists in the store.
//
//  ppStoreContext can be NULL, indicating the caller isn't interested
//  in getting the CERT_CONTEXT of the added or existing certificate.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCertificateContextToStore(
    __in_opt HCERTSTORE hCertStore,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCERT_CONTEXT *ppStoreContext
    );


//+-------------------------------------------------------------------------
//  Certificate Store Context Types
//--------------------------------------------------------------------------
#define CERT_STORE_CERTIFICATE_CONTEXT  1
#define CERT_STORE_CRL_CONTEXT          2
#define CERT_STORE_CTL_CONTEXT          3

//+-------------------------------------------------------------------------
//  Certificate Store Context Bit Flags
//--------------------------------------------------------------------------
#define CERT_STORE_ALL_CONTEXT_FLAG             (~0UL)
#define CERT_STORE_CERTIFICATE_CONTEXT_FLAG     \
                (1 << CERT_STORE_CERTIFICATE_CONTEXT)
#define CERT_STORE_CRL_CONTEXT_FLAG             \
                (1 << CERT_STORE_CRL_CONTEXT)
#define CERT_STORE_CTL_CONTEXT_FLAG             \
                (1 << CERT_STORE_CTL_CONTEXT)

//+-------------------------------------------------------------------------
//  Add the serialized certificate or CRL element to the store.
//
//  The serialized element contains the encoded certificate, CRL or CTL and
//  its properties, such as, CERT_KEY_PROV_INFO_PROP_ID.
//
//  If hCertStore is NULL, creates a certificate, CRL or CTL context not
//  residing in any store.
//
//  dwAddDispostion specifies the action to take if the certificate or CRL
//  already exists in the store. See CertAddCertificateContextToStore for a
//  list of and actions taken.
//
//  dwFlags currently isn't used and should be set to 0.
//
//  dwContextTypeFlags specifies the set of allowable contexts. For example, to
//  add either a certificate or CRL, set dwContextTypeFlags to:
//      CERT_STORE_CERTIFICATE_CONTEXT_FLAG | CERT_STORE_CRL_CONTEXT_FLAG
//
//  *pdwContextType is updated with the type of the context returned in
//  *ppvContxt. pdwContextType or ppvContext can be NULL, indicating the
//  caller isn't interested in getting the output. If *ppvContext is
//  returned it must be freed by calling CertFreeCertificateContext or
//  CertFreeCRLContext.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddSerializedElementToStore(
    __in_opt HCERTSTORE hCertStore,
    __in_bcount(cbElement) const BYTE *pbElement,
    __in DWORD cbElement,
    __in DWORD dwAddDisposition,
    __in DWORD dwFlags,
    __in DWORD dwContextTypeFlags,
    __out_opt DWORD *pdwContextType,
    __deref_opt_out const void **ppvContext
    );

//+-------------------------------------------------------------------------
//  Delete the specified certificate from the store.
//
//  All subsequent gets or finds for the certificate will fail. However,
//  memory allocated for the certificate isn't freed until all of its contexts
//  have also been freed.
//
//  The pCertContext is obtained from a get, enum, find or duplicate.
//
//  Some store provider implementations might also delete the issuer's CRLs
//  if this is the last certificate for the issuer in the store.
//
//  NOTE: the pCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertDeleteCertificateFromStore(
    __in PCCERT_CONTEXT pCertContext
    );

//+-------------------------------------------------------------------------
//  Add the encoded CRL to the store according to the specified
//  disposition option.
//
//  Makes a copy of the encoded CRL before adding to the store.
//
//  dwAddDispostion specifies the action to take if the CRL
//  already exists in the store. See CertAddEncodedCertificateToStore for a
//  list of and actions taken.
//
//  Compares the CRL's Issuer to determine if the CRL already exists in the
//  store.
//
//  ppCrlContext can be NULL, indicating the caller isn't interested
//  in getting the CRL_CONTEXT of the added or existing CRL.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddEncodedCRLToStore(
    __in_opt HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in_bcount(cbCrlEncoded) const BYTE *pbCrlEncoded,
    __in DWORD cbCrlEncoded,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCRL_CONTEXT *ppCrlContext
    );

//+-------------------------------------------------------------------------
//  Add the CRL context to the store according to the specified
//  disposition option.
//
//  In addition to the encoded CRL, the context's properties are
//  also copied.  Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
//  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
//
//  Makes a copy of the encoded CRL before adding to the store.
//
//  dwAddDispostion specifies the action to take if the CRL
//  already exists in the store. See CertAddCertificateContextToStore for a
//  list of and actions taken.
//
//  Compares the CRL's Issuer, ThisUpdate and NextUpdate to determine
//  if the CRL already exists in the store.
//
//  ppStoreContext can be NULL, indicating the caller isn't interested
//  in getting the CRL_CONTEXT of the added or existing CRL.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCRLContextToStore(
    __in_opt HCERTSTORE hCertStore,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCRL_CONTEXT *ppStoreContext
    );

//+-------------------------------------------------------------------------
//  Delete the specified CRL from the store.
//
//  All subsequent gets for the CRL will fail. However,
//  memory allocated for the CRL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCrlContext is obtained from a get or duplicate.
//
//  NOTE: the pCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertDeleteCRLFromStore(
    __in PCCRL_CONTEXT pCrlContext
    );

//+-------------------------------------------------------------------------
//  Serialize the certificate context's encoded certificate and its
//  properties.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSerializeCertificateStoreElement(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbElement, *pcbElement) BYTE *pbElement,
    __inout DWORD *pcbElement
    );


//+-------------------------------------------------------------------------
//  Serialize the CRL context's encoded CRL and its properties.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSerializeCRLStoreElement(
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbElement, *pcbElement) BYTE *pbElement,
    __inout DWORD *pcbElement
    );



//+=========================================================================
//  Certificate Trust List (CTL) Store Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  Duplicate a CTL context
//--------------------------------------------------------------------------
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    __in_opt PCCTL_CONTEXT pCtlContext
    );

//+-------------------------------------------------------------------------
//  Create a CTL context from the encoded CTL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CTL in the created context.
//
//  If unable to decode and create the CTL context, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned.
//  CTL_CONTEXT must be freed by calling CertFreeCTLContext.
//  CertDuplicateCTLContext can be called to make a duplicate.
//
//  CertSetCTLContextProperty and CertGetCTLContextProperty can be called
//  to store properties for the CTL.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    __in DWORD dwMsgAndCertEncodingType,
    __in_bcount(cbCtlEncoded) const BYTE *pbCtlEncoded,
    __in DWORD cbCtlEncoded
    );

//+-------------------------------------------------------------------------
//  Free a CTL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertFreeCTLContext(
    __in_opt PCCTL_CONTEXT pCtlContext
    );

//+-------------------------------------------------------------------------
//  Set the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetCTLContextProperty(
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

//+-------------------------------------------------------------------------
//  Get the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID or CERT_NEXT_UPDATE_LOCATION_PROP_ID are the
//  predefined properties of most interest.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetCTLContextProperty(
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwPropId,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CTL context.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertEnumCTLContextProperties(
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Enumerate the CTL contexts in the store.
//
//  If a CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL to enumerate the first
//  CTL in the store. Successive CTLs are enumerated by setting
//  pPrevCtlContext to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertEnumCTLsInStore(
    __in HCERTSTORE hCertStore,
    __in_opt PCCTL_CONTEXT pPrevCtlContext
    );

//+-------------------------------------------------------------------------
//  Attempt to find the specified subject in the CTL.
//
//  For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's
//  SubjectAlgorithm is examined to determine the representation of the
//  subject's identity. Initially, only SHA1 or MD5 hash will be supported.
//  The appropriate hash property is obtained from the CERT_CONTEXT.
//
//  For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO
//  structure which contains the SubjectAlgorithm to be matched in the CTL
//  and the SubjectIdentifer to be matched in one of the CTL entries.
//
//  The certificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier
//  is used as the key in searching the subject entries. A binary
//  memory comparison is done between the key and the entry's SubjectIdentifer.
//
//  dwEncodingType isn't used for either of the above SubjectTypes.
//--------------------------------------------------------------------------
WINCRYPT32API
PCTL_ENTRY
WINAPI
CertFindSubjectInCTL(
    __in DWORD dwEncodingType,
    __in DWORD dwSubjectType,
    __in void *pvSubject,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwFlags
    );

// Subject Types:
//  CTL_ANY_SUBJECT_TYPE, pvSubject points to following CTL_ANY_SUBJECT_INFO.
//  CTL_CERT_SUBJECT_TYPE, pvSubject points to CERT_CONTEXT.
#define CTL_ANY_SUBJECT_TYPE            1
#define CTL_CERT_SUBJECT_TYPE           2

typedef struct _CTL_ANY_SUBJECT_INFO {
    CRYPT_ALGORITHM_IDENTIFIER  SubjectAlgorithm;
    CRYPT_DATA_BLOB             SubjectIdentifier;
} CTL_ANY_SUBJECT_INFO, *PCTL_ANY_SUBJECT_INFO;

//+-------------------------------------------------------------------------
//  Find the first or next CTL context in the store.
//
//  The CTL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwMsgAndCertEncodingType depends on the dwFindType.
//
//  If the first or next CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL on the first
//  call to find the CTL. To find the next CTL, the
//  pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwMsgAndCertEncodingType,
    __in DWORD dwFindFlags,
    __in DWORD dwFindType,
    __in_opt const void *pvFindPara,
    __in_opt PCCTL_CONTEXT pPrevCtlContext
    );

#define CTL_FIND_ANY                0
#define CTL_FIND_SHA1_HASH          1
#define CTL_FIND_MD5_HASH           2
#define CTL_FIND_USAGE              3
#define CTL_FIND_SUBJECT            4
#define CTL_FIND_EXISTING           5

typedef struct _CTL_FIND_USAGE_PARA {
    DWORD               cbSize;
    CTL_USAGE           SubjectUsage;   // optional
    CRYPT_DATA_BLOB     ListIdentifier; // optional
    PCERT_INFO          pSigner;        // optional
} CTL_FIND_USAGE_PARA, *PCTL_FIND_USAGE_PARA;

#define CTL_FIND_NO_LIST_ID_CBDATA  0xFFFFFFFF
#define CTL_FIND_NO_SIGNER_PTR      ((PCERT_INFO) -1)

#define CTL_FIND_SAME_USAGE_FLAG    0x1


typedef struct _CTL_FIND_SUBJECT_PARA {
    DWORD                   cbSize;
    PCTL_FIND_USAGE_PARA    pUsagePara; // optional
    DWORD                   dwSubjectType;
    void                    *pvSubject;
} CTL_FIND_SUBJECT_PARA, *PCTL_FIND_SUBJECT_PARA;


//+-------------------------------------------------------------------------
//  CTL_FIND_ANY
//
//  Find any CTL.
//
//  pvFindPara isn't used.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CTL_FIND_SHA1_HASH
//  CTL_FIND_MD5_HASH
//
//  Find a CTL with the specified hash.
//
//  pvFindPara points to a CRYPT_HASH_BLOB.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CTL_FIND_USAGE
//
//  Find a CTL having the specified usage identifiers, list identifier or
//  signer. The CertEncodingType of the signer is obtained from the
//  dwMsgAndCertEncodingType parameter.
//
//  pvFindPara points to a CTL_FIND_USAGE_PARA data structure. The
//  SubjectUsage.cUsageIdentifer can be 0 to match any usage. The
//  ListIdentifier.cbData can be 0 to match any list identifier. To only match
//  CTLs without a ListIdentifier, cbData must be set to
//  CTL_FIND_NO_LIST_ID_CBDATA. pSigner can be NULL to match any signer. Only
//  the Issuer and SerialNumber fields of the pSigner's PCERT_INFO are used.
//  To only match CTLs without a signer, pSigner must be set to
//  CTL_FIND_NO_SIGNER_PTR.
//
//  The CTL_FIND_SAME_USAGE_FLAG can be set in dwFindFlags to
//  only match CTLs with the same usage identifiers. CTLs having additional
//  usage identifiers aren't matched. For example, if only "1.2.3" is specified
//  in CTL_FIND_USAGE_PARA, then, for a match, the CTL must only contain
//  "1.2.3" and not any additional usage identifers.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CTL_FIND_SUBJECT
//
//  Find a CTL having the specified subject. CertFindSubjectInCTL can be
//  called to get a pointer to the subject's entry in the CTL.  pUsagePara can
//  optionally be set to enable the above CTL_FIND_USAGE matching.
//
//  pvFindPara points to a CTL_FIND_SUBJECT_PARA data structure.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Add the encoded CTL to the store according to the specified
//  disposition option.
//
//  Makes a copy of the encoded CTL before adding to the store.
//
//  dwAddDispostion specifies the action to take if the CTL
//  already exists in the store. See CertAddEncodedCertificateToStore for a
//  list of and actions taken.
//
//  Compares the CTL's SubjectUsage, ListIdentifier and any of its signers
//  to determine if the CTL already exists in the store.
//
//  ppCtlContext can be NULL, indicating the caller isn't interested
//  in getting the CTL_CONTEXT of the added or existing CTL.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddEncodedCTLToStore(
    __in_opt HCERTSTORE hCertStore,
    __in DWORD dwMsgAndCertEncodingType,
    __in_bcount(cbCtlEncoded) const BYTE *pbCtlEncoded,
    __in DWORD cbCtlEncoded,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCTL_CONTEXT *ppCtlContext
    );

//+-------------------------------------------------------------------------
//  Add the CTL context to the store according to the specified
//  disposition option.
//
//  In addition to the encoded CTL, the context's properties are
//  also copied.  Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
//  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
//
//  Makes a copy of the encoded CTL before adding to the store.
//
//  dwAddDispostion specifies the action to take if the CTL
//  already exists in the store. See CertAddCertificateContextToStore for a
//  list of and actions taken.
//
//  Compares the CTL's SubjectUsage, ListIdentifier and any of its signers
//  to determine if the CTL already exists in the store.
//
//  ppStoreContext can be NULL, indicating the caller isn't interested
//  in getting the CTL_CONTEXT of the added or existing CTL.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCTLContextToStore(
    __in_opt HCERTSTORE hCertStore,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCTL_CONTEXT *ppStoreContext
    );

//+-------------------------------------------------------------------------
//  Serialize the CTL context's encoded CTL and its properties.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSerializeCTLStoreElement(
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbElement, *pcbElement) BYTE *pbElement,
    __inout DWORD *pcbElement
    );

//+-------------------------------------------------------------------------
//  Delete the specified CTL from the store.
//
//  All subsequent gets for the CTL will fail. However,
//  memory allocated for the CTL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCtlContext is obtained from a get or duplicate.
//
//  NOTE: the pCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertDeleteCTLFromStore(
    __in PCCTL_CONTEXT pCtlContext
    );


WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCertificateLinkToStore(
    __in HCERTSTORE hCertStore,
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCERT_CONTEXT *ppStoreContext
    );

WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCRLLinkToStore(
    __in HCERTSTORE hCertStore,
    __in PCCRL_CONTEXT pCrlContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCRL_CONTEXT *ppStoreContext
    );

WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertAddCTLLinkToStore(
    __in HCERTSTORE hCertStore,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwAddDisposition,
    __deref_opt_out PCCTL_CONTEXT *ppStoreContext
    );

WINCRYPT32API
BOOL
WINAPI
CertAddStoreToCollection(
    __in HCERTSTORE hCollectionStore,
    __in_opt HCERTSTORE hSiblingStore,
    __in DWORD dwUpdateFlags,
    __in DWORD dwPriority
    );

WINCRYPT32API
void
WINAPI
CertRemoveStoreFromCollection(
    __in HCERTSTORE hCollectionStore,
    __in HCERTSTORE hSiblingStore
    );


WINCRYPT32API
BOOL
WINAPI
CertControlStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwFlags,
    __in DWORD dwCtrlType,
    __in_opt void const *pvCtrlPara
    );

//+-------------------------------------------------------------------------
//  Certificate Store control types
//--------------------------------------------------------------------------
#define CERT_STORE_CTRL_RESYNC              1
#define CERT_STORE_CTRL_NOTIFY_CHANGE       2
#define CERT_STORE_CTRL_COMMIT              3
#define CERT_STORE_CTRL_AUTO_RESYNC         4
#define CERT_STORE_CTRL_CANCEL_NOTIFY       5

#define CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG   0x1

//+-------------------------------------------------------------------------
//  CERT_STORE_CTRL_RESYNC
//
//  Re-synchronize the store.
//
//  The pvCtrlPara points to the event HANDLE to be signaled on
//  the next store change. Normally, this would be the same
//  event HANDLE passed to CERT_STORE_CTRL_NOTIFY_CHANGE during initialization.
//
//  If pvCtrlPara is NULL, no events are re-armed.
//
//  By default the event HANDLE is DuplicateHandle'd.
//  CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG can be set in dwFlags
//  to inhibit a DupicateHandle of the event HANDLE. If this flag
//  is set, then, CertControlStore(CERT_STORE_CTRL_CANCEL_NOTIFY) must be
//  called for this event HANDLE before closing the hCertStore.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_STORE_CTRL_NOTIFY_CHANGE
//
//  Signal the event when the underlying store is changed.
//
//  pvCtrlPara points to the event HANDLE to be signaled.
//
//  pvCtrlPara can be NULL to inform the store of a subsequent
//  CERT_STORE_CTRL_RESYNC and allow it to optimize by only doing a resync
//  if the store has changed. For the registry based stores, an internal
//  notify change event is created and registered to be signaled.
//
//  Recommend calling CERT_STORE_CTRL_NOTIFY_CHANGE once for each event to
//  be passed to CERT_STORE_CTRL_RESYNC. This should only happen after
//  the event has been created. Not after each time the event is signaled.
//
//  By default the event HANDLE is DuplicateHandle'd.
//  CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG can be set in dwFlags
//  to inhibit a DupicateHandle of the event HANDLE. If this flag
//  is set, then, CertControlStore(CERT_STORE_CTRL_CANCEL_NOTIFY) must be
//  called for this event HANDLE before closing the hCertStore.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_STORE_CTRL_CANCEL_NOTIFY
//
//  Cancel notification signaling of the event HANDLE passed in a previous
//  CERT_STORE_CTRL_NOTIFY_CHANGE or CERT_STORE_CTRL_RESYNC.
//
//  pvCtrlPara points to the event HANDLE to be canceled.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_STORE_CTRL_AUTO_RESYNC
//
//  At the start of every enumeration or find store API call, check if the
//  underlying store has changed. If it has changed, re-synchronize.
//
//  This check is only done in the enumeration or find APIs when the
//  pPrevContext is NULL.
//
//  The pvCtrlPara isn't used and must be set to NULL.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_STORE_CTRL_COMMIT
//
//  If any changes have been to the cached store, they are committed to
//  persisted storage. If no changes have been made since the store was
//  opened or the last commit, this call is ignored. May also be ignored by
//  store providers that persist changes immediately.
//
//  CERT_STORE_CTRL_COMMIT_FORCE_FLAG can be set to force the store
//  to be committed even if it hasn't been touched.
//
//  CERT_STORE_CTRL_COMMIT_CLEAR_FLAG can be set to inhibit a commit on
//  store close.
//--------------------------------------------------------------------------

#define CERT_STORE_CTRL_COMMIT_FORCE_FLAG   0x1
#define CERT_STORE_CTRL_COMMIT_CLEAR_FLAG   0x2


//+=========================================================================
//  Cert Store Property Defines and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  Store property IDs. This is a property applicable to the entire store.
//  Its not a property on an individual certificate, CRL or CTL context.
//
//  Currently, no store properties are persisted. (This differs from
//  most context properties which are persisted.)
//
//  See CertSetStoreProperty or CertGetStoreProperty for usage information.
//
//  Note, the range for predefined store properties should be outside
//  the range of predefined context properties. We will start at 4096.
//--------------------------------------------------------------------------
// certenrolld_begin -- CERT_*_PROP_ID
#define CERT_STORE_LOCALIZED_NAME_PROP_ID   0x1000
// certenrolld_end

//+-------------------------------------------------------------------------
//  Set a store property.
//
//  The type definition for pvData depends on the dwPropId value.
//      CERT_STORE_LOCALIZED_NAME_PROP_ID - localized name of the store.
//      pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
//      terminated unicode, wide character string.
//      cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
//
//  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
//
//  If the property already exists, then, the old value is deleted and silently
//  replaced. Setting, pvData to NULL, deletes the property.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetStoreProperty(
    __in HCERTSTORE hCertStore,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt const void *pvData
    );

//+-------------------------------------------------------------------------
//  Get a store property.
//
//  The type definition for pvData depends on the dwPropId value.
//      CERT_STORE_LOCALIZED_NAME_PROP_ID - localized name of the store.
//      pvData points to a NULL terminated unicode, wide character string.
//      cbData = (wcslen((LPWSTR) pvData) + 1) * sizeof(WCHAR).
//
//  For all other PROP_IDs, pvData points to an array of bytes.
//
//  If the property doesn't exist, returns FALSE and sets LastError to
//  CRYPT_E_NOT_FOUND.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetStoreProperty(
    __in HCERTSTORE hCertStore,
    __in DWORD dwPropId,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );


//+-------------------------------------------------------------------------
// If the callback returns FALSE, stops the sort. CertCreateContext
// will return FALSE and set last error to ERROR_CANCELLED if the sort
// was stopped.
//
// Where:
//  cbTotalEncoded  - total byte count of the encoded entries.
//  cbRemainEncoded - remaining byte count of the encoded entries.
//  cEntry          - running count of sorted entries
//  pvSort          - value passed in pCreatePara
//--------------------------------------------------------------------------
typedef BOOL (WINAPI *PFN_CERT_CREATE_CONTEXT_SORT_FUNC)(
    __in DWORD cbTotalEncoded,
    __in DWORD cbRemainEncoded,
    __in DWORD cEntry,
    __inout_opt void *pvSort
    );

typedef struct _CERT_CREATE_CONTEXT_PARA {
    DWORD                               cbSize;
    PFN_CRYPT_FREE                      pfnFree;    // OPTIONAL
    void                                *pvFree;    // OPTIONAL

    // Only applicable to CERT_STORE_CTL_CONTEXT when
    // CERT_CREATE_CONTEXT_SORTED_FLAG is set in dwFlags.
    PFN_CERT_CREATE_CONTEXT_SORT_FUNC   pfnSort;    // OPTIONAL
    void                                *pvSort;    // OPTIONAL
} CERT_CREATE_CONTEXT_PARA, *PCERT_CREATE_CONTEXT_PARA;

//+-------------------------------------------------------------------------
//  Creates the specified context from the encoded bytes. The created
//  context isn't put in a store.
//
//  dwContextType values:
//      CERT_STORE_CERTIFICATE_CONTEXT
//      CERT_STORE_CRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT
//
//  If CERT_CREATE_CONTEXT_NOCOPY_FLAG is set, the created context points
//  directly to the pbEncoded instead of an allocated copy. See flag
//  definition for more details.
//
//  If CERT_CREATE_CONTEXT_SORTED_FLAG is set, the context is created
//  with sorted entries. This flag may only be set for CERT_STORE_CTL_CONTEXT.
//  Setting this flag implicitly sets CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG and
//  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG. See flag definition for
//  more details.
//
//  If CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG is set, the context is created
//  without creating a HCRYPTMSG handle for the context. This flag may only be
//  set for CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If CERT_CREATE_CONTEXT_NO_ENTRY_FLAG is set, the context is created
//  without decoding the entries. This flag may only be set for
//  CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If unable to decode and create the context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT, CRL_CONTEXT or
//  CTL_CONTEXT is returned. The context must be freed by the appropriate
//  free context API. The context can be duplicated by calling the
//  appropriate duplicate context API.
//--------------------------------------------------------------------------
WINCRYPT32API
const void *
WINAPI
CertCreateContext(
    __in DWORD dwContextType,
    __in DWORD dwEncodingType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __in DWORD dwFlags,
    __in_opt PCERT_CREATE_CONTEXT_PARA pCreatePara
    );

// When the following flag is set, the created context points directly to the
// pbEncoded instead of an allocated copy. If pCreatePara and
// pCreatePara->pfnFree are non-NULL, then, pfnFree is called to free
// the pbEncoded when the context is last freed. Otherwise, no attempt is
// made to free the pbEncoded. If pCreatePara->pvFree is non-NULL, then its
// passed to pfnFree instead of pbEncoded.
//
// Note, if CertCreateContext fails, pfnFree is still called.
#define CERT_CREATE_CONTEXT_NOCOPY_FLAG     0x1

// When the following flag is set, a context with sorted entries is created.
// Currently only applicable to a CTL context.
//
// For CTLs: the cCTLEntry in the returned CTL_INFO is always
// 0. CertFindSubjectInSortedCTL and CertEnumSubjectInSortedCTL must be called
// to find or enumerate the CTL entries.
//
// The Sorted CTL TrustedSubjects extension isn't returned in the created
// context's CTL_INFO.
//
// pfnSort and pvSort can be set in the pCreatePara parameter to be called for
// each sorted entry. pfnSort can return FALSE to stop the sorting.
#define CERT_CREATE_CONTEXT_SORTED_FLAG     0x2

// By default when a CTL context is created, a HCRYPTMSG handle to its
// SignedData message is created. This flag can be set to improve performance
// by not creating the HCRYPTMSG handle.
//
// This flag is only applicable to a CTL context.
#define CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG   0x4

// By default when a CTL context is created, its entries are decoded.
// This flag can be set to improve performance by not decoding the
// entries.
//
// This flag is only applicable to a CTL context.
#define CERT_CREATE_CONTEXT_NO_ENTRY_FLAG       0x8


//+=========================================================================
//  Certificate System Store Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  System Store Information
//
//  Currently, no system store information is persisted.
//--------------------------------------------------------------------------
typedef struct _CERT_SYSTEM_STORE_INFO {
    DWORD   cbSize;
} CERT_SYSTEM_STORE_INFO, *PCERT_SYSTEM_STORE_INFO;

//+-------------------------------------------------------------------------
//  Physical Store Information
//
//  The Open fields are passed directly to CertOpenStore() to open
//  the physical store.
//
//  By default all system stores located in the registry have an
//  implicit SystemRegistry physical store that is opened. To disable the
//  opening of this store, the SystemRegistry
//  physical store corresponding to the System store must be registered with
//  CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG set in dwFlags. Alternatively,
//  a physical store with the name of ".Default" may be registered.
//
//  Depending on the store location and store name, additional predefined
//  physical stores may be opened. For example, system stores in
//  CURRENT_USER have the predefined physical store, .LocalMachine.
//  To disable the opening of these predefined physical stores, the
//  corresponding physical store must be registered with
//  CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG set in dwFlags.
//
//  The CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG must be set in dwFlags
//  to enable the adding of a context to the store.
//
//  When a system store is opened via the SERVICES or USERS store location,
//  the ServiceName\ is prepended to the OpenParameters
//  for CERT_SYSTEM_STORE_CURRENT_USER or CERT_SYSTEM_STORE_CURRENT_SERVICE
//  physical stores and the dwOpenFlags store location is changed to
//  CERT_SYSTEM_STORE_USERS or CERT_SYSTEM_STORE_SERVICES.
//
//  By default the SYSTEM, SYSTEM_REGISTRY and PHYSICAL provider
//  stores are also opened remotely when the outer system store is opened.
//  The CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG may be set in dwFlags
//  to disable remote opens.
//
//  When opened remotely, the \\ComputerName is implicitly prepended to the
//  OpenParameters for the SYSTEM, SYSTEM_REGISTRY and PHYSICAL provider types.
//  To also prepend the \\ComputerName to other provider types, set the
//  CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG in dwFlags.
//
//  When the system store is opened, its physical stores are ordered
//  according to the dwPriority. A larger dwPriority indicates higher priority.
//--------------------------------------------------------------------------
typedef struct _CERT_PHYSICAL_STORE_INFO {
    DWORD               cbSize;
    LPSTR               pszOpenStoreProvider;   // REG_SZ
    DWORD               dwOpenEncodingType;     // REG_DWORD
    DWORD               dwOpenFlags;            // REG_DWORD
    CRYPT_DATA_BLOB     OpenParameters;         // REG_BINARY
    DWORD               dwFlags;                // REG_DWORD
    DWORD               dwPriority;             // REG_DWORD
} CERT_PHYSICAL_STORE_INFO, *PCERT_PHYSICAL_STORE_INFO;

//+-------------------------------------------------------------------------
//  Physical Store Information dwFlags
//--------------------------------------------------------------------------
#define CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG                     0x1
#define CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG                   0x2
#define CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG            0x4
#define CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG    0x8


//+-------------------------------------------------------------------------
//  Register a system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  The CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS system store
//  name must be prefixed with the ServiceName or UserName. For example,
//  "ServiceName\Trust".
//
//  Stores on remote computers can be registered for the
//  CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
//  CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
//  or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//  locations by prepending the computer name. For example, a remote
//  local machine store is registered via "\\ComputerName\Trust" or
//  "ComputerName\Trust". A remote service store is registered via
//  "\\ComputerName\ServiceName\Trust". The leading "\\" backslashes are
//  optional in the ComputerName.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the system store
//  already exists in the store location.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertRegisterSystemStore(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __in_opt PCERT_SYSTEM_STORE_INFO pStoreInfo,
    __reserved void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Register a physical store for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  See CertRegisterSystemStore for details on prepending a ServiceName
//  and/or ComputerName to the system store name.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the physical store
//  already exists in the system store.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertRegisterPhysicalStore(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __in LPCWSTR pwszStoreName,
    __in PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    __reserved void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Unregister the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  See CertRegisterSystemStore for details on prepending a ServiceName
//  and/or ComputerName to the system store name.
//
//  CERT_STORE_DELETE_FLAG can optionally be set in dwFlags.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertUnregisterSystemStore(
    __in const void *pvSystemStore,
    __in DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Unregister the physical store from the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  See CertRegisterSystemStore for details on prepending a ServiceName
//  and/or ComputerName to the system store name.
//
//  CERT_STORE_DELETE_FLAG can optionally be set in dwFlags.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertUnregisterPhysicalStore(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __in LPCWSTR pwszStoreName
    );

//+-------------------------------------------------------------------------
//  Enum callbacks
//
//  The CERT_SYSTEM_STORE_LOCATION_MASK bits in the dwFlags parameter
//  specifies the location of the system store
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  The callback returns FALSE and sets LAST_ERROR to stop the enumeration.
//  The LAST_ERROR is returned to the caller of the enumeration.
//
//  The pvSystemStore passed to the callback has leading ComputerName and/or
//  ServiceName prefixes where appropriate.
//--------------------------------------------------------------------------

typedef BOOL (WINAPI *PFN_CERT_ENUM_SYSTEM_STORE_LOCATION)(
    __in LPCWSTR pwszStoreLocation,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __inout_opt void *pvArg
    );

typedef BOOL (WINAPI *PFN_CERT_ENUM_SYSTEM_STORE)(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __in PCERT_SYSTEM_STORE_INFO pStoreInfo,
    __reserved void *pvReserved,
    __inout_opt void *pvArg
    );

typedef BOOL (WINAPI *PFN_CERT_ENUM_PHYSICAL_STORE)(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __in LPCWSTR pwszStoreName,
    __in PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    __reserved void *pvReserved,
    __inout_opt void *pvArg
    );

// In the PFN_CERT_ENUM_PHYSICAL_STORE callback the following flag is
// set if the physical store wasn't registered and is an implicitly created
// predefined physical store.
#define CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG    0x1

// Names of implicitly created predefined physical stores
#define CERT_PHYSICAL_STORE_DEFAULT_NAME            L".Default"
#define CERT_PHYSICAL_STORE_GROUP_POLICY_NAME       L".GroupPolicy"
#define CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME      L".LocalMachine"
#define CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME L".UserCertificate"
#define CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME \
            L".LocalMachineGroupPolicy"
#define CERT_PHYSICAL_STORE_ENTERPRISE_NAME         L".Enterprise"
#define CERT_PHYSICAL_STORE_AUTH_ROOT_NAME          L".AuthRoot"
#define CERT_PHYSICAL_STORE_SMART_CARD_NAME         L".SmartCard"

//+-------------------------------------------------------------------------
//  Enumerate the system store locations.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertEnumSystemStoreLocation(
    __in DWORD dwFlags,
    __inout_opt void *pvArg,
    __callback PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum
    );

//+-------------------------------------------------------------------------
//  Enumerate the system stores.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags,
//  pvSystemStoreLocationPara points to a CERT_SYSTEM_STORE_RELOCATE_PARA
//  data structure. Otherwise, pvSystemStoreLocationPara points to a null
//  terminated UNICODE string.
//
//  For CERT_SYSTEM_STORE_LOCAL_MACHINE,
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, pvSystemStoreLocationPara can
//  optionally be set to a unicode computer name for enumerating local machine
//  stores on a remote computer. For example, "\\ComputerName" or
//  "ComputerName".  The leading "\\" backslashes are optional in the
//  ComputerName.
//
//  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
//  if pvSystemStoreLocationPara is NULL, then,
//  enumerates both the service/user names and the stores for each service/user
//  name. Otherwise, pvSystemStoreLocationPara is a unicode string specifying a
//  remote computer name and/or service/user name. For example:
//      "ServiceName"
//      "\\ComputerName" or "ComputerName\"
//      "ComputerName\ServiceName"
//  Note, if only the ComputerName is specified, then, it must have either
//  the leading "\\" backslashes or a trailing backslash. Otherwise, its
//  interpretted as the ServiceName or UserName.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertEnumSystemStore(
    __in DWORD dwFlags,
    __in_opt void *pvSystemStoreLocationPara,
    __inout_opt void *pvArg,
    __callback PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    );

//+-------------------------------------------------------------------------
//  Enumerate the physical stores for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
//  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
//  pvSystemStore points to a null terminated UNICODE string.
//
//  See CertRegisterSystemStore for details on prepending a ServiceName
//  and/or ComputerName to the system store name.
//
//  If the system store location only supports system stores and doesn't
//  support physical stores, LastError is set to ERROR_CALL_NOT_IMPLEMENTED.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertEnumPhysicalStore(
    __in const void *pvSystemStore,
    __in DWORD dwFlags,
    __inout_opt void *pvArg,
    __callback PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    );


//+-------------------------------------------------------------------------
//  Certificate System Store Installable Functions
//
//  The CERT_SYSTEM_STORE_LOCATION_MASK bits in the dwFlags parameter passed
//  to the CertOpenStore(for "System", "SystemRegistry" or "Physical"
//  Provider), CertRegisterSystemStore,
//  CertUnregisterSystemStore, CertEnumSystemStore, CertRegisterPhysicalStore,
//  CertUnregisterPhysicalStore and CertEnumPhysicalStore APIs is used as the
//  constant pszOID value passed to the OID installable functions.
//  Therefore, the pszOID is restricted to a constant <= (LPCSTR) 0x0FFF.
//
//  The EncodingType is 0.
//--------------------------------------------------------------------------

// Installable System Store Provider OID pszFuncNames.
#define CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC   "CertDllOpenSystemStoreProv"
#define CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC    "CertDllRegisterSystemStore"
#define CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC  "CertDllUnregisterSystemStore"
#define CRYPT_OID_ENUM_SYSTEM_STORE_FUNC        "CertDllEnumSystemStore"
#define CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC  "CertDllRegisterPhysicalStore"
#define CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC "CertDllUnregisterPhysicalStore"
#define CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC      "CertDllEnumPhysicalStore"

// CertDllOpenSystemStoreProv has the same function signature as the
// installable "CertDllOpenStoreProv" function. See CertOpenStore for
// more details.

// CertDllRegisterSystemStore has the same function signature as
// CertRegisterSystemStore.
//
// The "SystemStoreLocation" REG_SZ value must also be set for registered
// CertDllEnumSystemStore OID functions.
#define CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME  L"SystemStoreLocation"

// The remaining Register, Enum and Unregister OID installable functions
// have the same signature as their Cert Store API counterpart.


//+=========================================================================
//  Enhanced Key Usage Helper Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the enhanced key usage extension or property from the certificate
//  and decode.
//
//  If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the
//  extension.
//
//  If the CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the
//  property.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetEnhancedKeyUsage(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbUsage, *pcbUsage) PCERT_ENHKEY_USAGE pUsage,
    __inout DWORD *pcbUsage
    );

//+-------------------------------------------------------------------------
//  Set the enhanced key usage property for the certificate.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertSetEnhancedKeyUsage(
    __in PCCERT_CONTEXT pCertContext,
    __in_opt PCERT_ENHKEY_USAGE pUsage
    );

//+-------------------------------------------------------------------------
//  Add the usage identifier to the certificate's enhanced key usage property.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertAddEnhancedKeyUsageIdentifier(
    __in PCCERT_CONTEXT pCertContext,
    __in LPCSTR pszUsageIdentifier
    );


//+-------------------------------------------------------------------------
//  Remove the usage identifier from the certificate's enhanced key usage
//  property.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertRemoveEnhancedKeyUsageIdentifier(
    __in PCCERT_CONTEXT pCertContext,
    __in LPCSTR pszUsageIdentifier
    );

//+---------------------------------------------------------------------------
//
//
//  Takes an array of certs and returns an array of usages
//  which consists of the intersection of the valid usages for each cert.
//  If each cert is good for all possible usages then the cNumOIDs is set to -1.
//
//----------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetValidUsages(
    __in DWORD cCerts,
    __in_ecount(cCerts) PCCERT_CONTEXT *rghCerts,
    __out int *cNumOIDs,
    __out_bcount_part_opt(*pcbOIDs, *pcbOIDs) LPSTR *rghOIDs,
    __inout DWORD *pcbOIDs);

//+=========================================================================
//  Cryptographic Message helper functions for verifying and signing a
//  CTL.
//==========================================================================

//+-------------------------------------------------------------------------
//  Get and verify the signer of a cryptographic message.
//
//  To verify a CTL, the hCryptMsg is obtained from the CTL_CONTEXT's
//  hCryptMsg field.
//
//  If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being
//  trusted and only search them to find the certificate corresponding to the
//  signer's issuer and serial number.  Otherwise, the SignerStores are
//  optionally provided to supplement the message's store of certificates.
//  If a signer certificate is found, its public key is used to verify
//  the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to
//  return the signer without doing the signature verify.
//
//  If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified
//  by *pdwSignerIndex. Otherwise, iterate through all the signers
//  until a signer verifies or no more signers.
//
//  For a verified signature, *ppSigner is updated with certificate context
//  of the signer and *pdwSignerIndex is updated with the index of the signer.
//  ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't
//  interested in getting the CertContext and/or index of the signer.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    __in HCRYPTMSG hCryptMsg,
    __in DWORD cSignerStore,
    __in_ecount_opt(cSignerStore) HCERTSTORE *rghSignerStore,
    __in DWORD dwFlags,
    __deref_opt_out PCCERT_CONTEXT *ppSigner,
    __inout_opt DWORD *pdwSignerIndex
    );

#define CMSG_TRUSTED_SIGNER_FLAG            0x1
#define CMSG_SIGNER_ONLY_FLAG               0x2
#define CMSG_USE_SIGNER_INDEX_FLAG          0x4

//+-------------------------------------------------------------------------
//  Sign an encoded CTL.
//
//  The pbCtlContent can be obtained via a CTL_CONTEXT's pbCtlContent
//  field or via a CryptEncodeObject(PKCS_CTL or PKCS_SORTED_CTL).
//
//  CMSG_CMS_ENCAPSULATED_CTL_FLAG can be set to encode a CMS compatible
//  V3 SignedData message.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgSignCTL(
    __in DWORD dwMsgEncodingType,
    __in_bcount(cbCtlContent) BYTE *pbCtlContent,
    __in DWORD cbCtlContent,
    __in PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded
    );

// When set, CTL inner content is encapsulated within an OCTET STRING
#define CMSG_CMS_ENCAPSULATED_CTL_FLAG  0x00008000

//+-------------------------------------------------------------------------
//  Encode the CTL and create a signed message containing the encoded CTL.
//
//  Set CMSG_ENCODE_SORTED_CTL_FLAG if the CTL entries are to be sorted
//  before encoding. This flag should be set, if the
//  CertFindSubjectInSortedCTL or CertEnumSubjectInSortedCTL APIs will
//  be called. If the identifier for the CTL entries is a hash, such as,
//  MD5 or SHA1, then, CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG should
//  also be set.
//
//  CMSG_CMS_ENCAPSULATED_CTL_FLAG can be set to encode a CMS compatible
//  V3 SignedData message.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptMsgEncodeAndSignCTL(
    __in DWORD dwMsgEncodingType,
    __in PCTL_INFO pCtlInfo,
    __in PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded
    );

//  The following flag is set if the CTL is to be encoded with sorted
//  trusted subjects and the szOID_SORTED_CTL extension is inserted containing
//  sorted offsets to the encoded subjects.
#define CMSG_ENCODE_SORTED_CTL_FLAG                     0x1

//  If the above sorted flag is set, then, the following flag should also
//  be set if the identifier for the TrustedSubjects is a hash,
//  such as, MD5 or SHA1.
#define CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG      0x2


//+-------------------------------------------------------------------------
//  Returns TRUE if the SubjectIdentifier exists in the CTL. Optionally
//  returns a pointer to and byte count of the Subject's encoded attributes.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertFindSubjectInSortedCTL(
    __in PCRYPT_DATA_BLOB pSubjectIdentifier,
    __in PCCTL_CONTEXT pCtlContext,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out_opt PCRYPT_DER_BLOB pEncodedAttributes
    );

//+-------------------------------------------------------------------------
//  Enumerates through the sequence of TrustedSubjects in a CTL context
//  created with CERT_CREATE_CONTEXT_SORTED_FLAG set.
//
//  To start the enumeration, *ppvNextSubject must be NULL. Upon return,
//  *ppvNextSubject is updated to point to the next TrustedSubject in
//  the encoded sequence.
//
//  Returns FALSE for no more subjects or invalid arguments.
//
//  Note, the returned DER_BLOBs point directly into the encoded
//  bytes (not allocated, and must not be freed).
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertEnumSubjectInSortedCTL(
    __in PCCTL_CONTEXT pCtlContext,
    __deref_inout_opt void **ppvNextSubject,
    __out_opt PCRYPT_DER_BLOB pSubjectIdentifier,
    __out_opt PCRYPT_DER_BLOB pEncodedAttributes
    );


//+=========================================================================
//  Certificate Verify CTL Usage Data Structures and APIs
//==========================================================================

typedef struct _CTL_VERIFY_USAGE_PARA {
    DWORD                   cbSize;
    CRYPT_DATA_BLOB         ListIdentifier;     // OPTIONAL
    DWORD                   cCtlStore;
    HCERTSTORE              *rghCtlStore;       // OPTIONAL
    DWORD                   cSignerStore;
    HCERTSTORE              *rghSignerStore;    // OPTIONAL
} CTL_VERIFY_USAGE_PARA, *PCTL_VERIFY_USAGE_PARA;

typedef struct _CTL_VERIFY_USAGE_STATUS {
    DWORD                   cbSize;
    DWORD                   dwError;
    DWORD                   dwFlags;
    PCCTL_CONTEXT           *ppCtl;             // IN OUT OPTIONAL
    DWORD                   dwCtlEntryIndex;
    PCCERT_CONTEXT          *ppSigner;          // IN OUT OPTIONAL
    DWORD                   dwSignerIndex;
} CTL_VERIFY_USAGE_STATUS, *PCTL_VERIFY_USAGE_STATUS;

#define CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG     0x1
#define CERT_VERIFY_TRUSTED_SIGNERS_FLAG        0x2
#define CERT_VERIFY_NO_TIME_CHECK_FLAG          0x4
#define CERT_VERIFY_ALLOW_MORE_USAGE_FLAG       0x8

#define CERT_VERIFY_UPDATED_CTL_FLAG            0x1

//+-------------------------------------------------------------------------
//  Verify that a subject is trusted for the specified usage by finding a
//  signed and time valid CTL with the usage identifiers and containing the
//  the subject. A subject can be identified by either its certificate context
//  or any identifier such as its SHA1 hash.
//
//  See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject
//  parameters.
//
//  Via pVerifyUsagePara, the caller can specify the stores to be searched
//  to find the CTL. The caller can also specify the stores containing
//  acceptable CTL signers. By setting the ListIdentifier, the caller
//  can also restrict to a particular signer CTL list.
//
//  Via pVerifyUsageStatus, the CTL containing the subject, the subject's
//  index into the CTL's array of entries, and the signer of the CTL
//  are returned. If the caller is not interested, ppCtl and ppSigner can be set
//  to NULL. Returned contexts must be freed via the store's free context APIs.
//
//  If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time
//  invalid CTL in one of the CtlStores may be replaced. When replaced, the
//  CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus->dwFlags.
//
//  If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//  SignerStores specified in pVerifyUsageStatus are searched to find
//  the signer. Otherwise, the SignerStores provide additional sources
//  to find the signer's certificate.
//
//  If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked
//  for time validity.
//
//  If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain
//  additional usage identifiers than specified by pSubjectUsage. Otherwise,
//  the found CTL will contain the same usage identifers and no more.
//
//  CertVerifyCTLUsage will be implemented as a dispatcher to OID installable
//  functions. First, it will try to find an OID function matching the first
//  usage object identifier in the pUsage sequence. Next, it will dispatch
//  to the default CertDllVerifyCTLUsage functions.
//
//  If the subject is trusted for the specified usage, then, TRUE is
//  returned. Otherwise, FALSE is returned with dwError set to one of the
//  following:
//      CRYPT_E_NO_VERIFY_USAGE_DLL
//      CRYPT_E_NO_VERIFY_USAGE_CHECK
//      CRYPT_E_VERIFY_USAGE_OFFLINE
//      CRYPT_E_NOT_IN_CTL
//      CRYPT_E_NO_TRUSTED_SIGNER
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifyCTLUsage(
    __in DWORD dwEncodingType,
    __in DWORD dwSubjectType,
    __in void *pvSubject,
    __in PCTL_USAGE pSubjectUsage,
    __in DWORD dwFlags,
    __in_opt PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    __inout PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    );


//+=========================================================================
//  Certificate Revocation Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  This data structure is updated by a CRL revocation type handler
//  with the base and possibly the delta CRL used.
//--------------------------------------------------------------------------
typedef struct _CERT_REVOCATION_CRL_INFO {
    DWORD                   cbSize;
    PCCRL_CONTEXT           pBaseCrlContext;
    PCCRL_CONTEXT           pDeltaCrlContext;

    // When revoked, points to entry in either of the above CRL contexts.
    // Don't free.
    PCRL_ENTRY              pCrlEntry;
    BOOL                    fDeltaCrlEntry; // TRUE if in pDeltaCrlContext
} CERT_REVOCATION_CRL_INFO, *PCERT_REVOCATION_CRL_INFO;

//+-------------------------------------------------------------------------
//  The following data structure may be passed to CertVerifyRevocation to
//  assist in finding the issuer of the context to be verified.
//
//  When pIssuerCert is specified, pIssuerCert is the issuer of
//  rgpvContext[cContext - 1].
//
//  When cCertStore and rgCertStore are specified, these stores may contain
//  an issuer certificate.
//
//  When hCrlStore is specified then a handler which uses CRLs can search this
//  store for them
//
//  When pftTimeToUse is specified then the handler (if possible) must determine
//  revocation status relative to the time given otherwise the answer may be
//  independent of time or relative to current time
//--------------------------------------------------------------------------
typedef struct _CERT_REVOCATION_PARA {
    DWORD                       cbSize;
    PCCERT_CONTEXT              pIssuerCert;
    DWORD                       cCertStore;
    HCERTSTORE                  *rgCertStore;
    HCERTSTORE                  hCrlStore;
    LPFILETIME                  pftTimeToUse;

#ifdef CERT_REVOCATION_PARA_HAS_EXTRA_FIELDS
    // Note, if you #define CERT_REVOCATION_PARA_HAS_EXTRA_FIELDS, then, you
    // must zero all unused fields in this data structure.
    // More fields could be added in a future release.

    // 0 uses revocation handler's default timeout.
    DWORD                       dwUrlRetrievalTimeout;  // milliseconds

    // When set, checks and attempts to retrieve a CRL where
    // ThisUpdate >= (CurrentTime - dwFreshnessTime). Otherwise, defaults
    // to using the CRL's NextUpdate.
    BOOL                        fCheckFreshnessTime;
    DWORD                       dwFreshnessTime;        // seconds

    // If NULL, revocation handler gets the current time
    LPFILETIME                  pftCurrentTime;

    // If nonNULL, a CRL revocation type handler updates with the base and
    // possibly the delta CRL used. Note, *pCrlInfo must be initialized
    // by the caller. Any nonNULL CRL contexts are freed. Any updated
    // CRL contexts must be freed by the caller.
    //
    // The CRL info is only applicable to the last context checked. If
    // interested in this information, then, CertVerifyRevocation should be
    // called with cContext = 1.
    PCERT_REVOCATION_CRL_INFO   pCrlInfo;

    // If nonNULL, any cached information before this time is considered
    // time invalid and forces a wire retrieval.
    LPFILETIME                  pftCacheResync;
#endif
} CERT_REVOCATION_PARA, *PCERT_REVOCATION_PARA;


//+-------------------------------------------------------------------------
//  The following data structure is returned by CertVerifyRevocation to
//  specify the status of the revoked or unchecked context. Review the
//  following CertVerifyRevocation comments for details.
//
//  Upon input to CertVerifyRevocation, cbSize must be set to a size
//  >= (offsetof(CERT_REVOCATION_STATUS, dwReason) + sizeof(DWORD) ).
//  Otherwise, CertVerifyRevocation returns FALSE and sets LastError to
//  E_INVALIDARG.
//
//  Upon input to the installed or registered CRYPT_OID_VERIFY_REVOCATION_FUNC
//  functions, the dwIndex, dwError and dwReason have been zero'ed.
//  If present, fHasFreshnessTime and dwFreshnessTime have been zero'ed.
//--------------------------------------------------------------------------
typedef struct _CERT_REVOCATION_STATUS {
    DWORD                   cbSize;
    DWORD                   dwIndex;
    DWORD                   dwError;
    DWORD                   dwReason;

    // Depending on cbSize, the following fields may optionally be returned.

    // The Freshness time is only applicable to the last context checked. If
    // interested in this information, then, CertVerifyRevocation should be
    // called with cContext = 1.
    //
    // fHasFreshnessTime is only set if we are able to retrieve revocation
    // information. For a CRL its CurrentTime - ThisUpdate.
    BOOL                    fHasFreshnessTime;
    DWORD                   dwFreshnessTime;    // seconds
} CERT_REVOCATION_STATUS, *PCERT_REVOCATION_STATUS;

//+-------------------------------------------------------------------------
//  Verifies the array of contexts for revocation. The dwRevType parameter
//  indicates the type of the context data structure passed in rgpvContext.
//  Currently only the revocation of certificates is defined.
//
//  If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation
//  is verifying a chain of certs where, rgpvContext[i + 1] is the issuer
//  of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions
//  about the order of the contexts.
//
//  To assist in finding the issuer, the pRevPara may optionally be set. See
//  the CERT_REVOCATION_PARA data structure for details.
//
//  The contexts must contain enough information to allow the
//  installable or registered revocation DLLs to find the revocation server. For
//  certificates, this information would normally be conveyed in an
//  extension such as the IETF's AuthorityInfoAccess extension.
//
//  CertVerifyRevocation returns TRUE if all of the contexts were successfully
//  checked and none were revoked. Otherwise, returns FALSE and updates the
//  returned pRevStatus data structure as follows:
//    dwIndex
//      Index of the first context that was revoked or unable to
//      be checked for revocation
//    dwError
//      Error status. LastError is also set to this error status.
//      dwError can be set to one of the following error codes defined
//      in winerror.h:
//        ERROR_SUCCESS - good context
//        CRYPT_E_REVOKED - context was revoked. dwReason contains the
//           reason for revocation
//        CRYPT_E_REVOCATION_OFFLINE - unable to connect to the
//           revocation server
//        CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked
//           was not found in the revocation server's database.
//        CRYPT_E_NO_REVOCATION_CHECK - the called revocation function
//           wasn't able to do a revocation check on the context
//        CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was
//           found to verify revocation
//    dwReason
//      The dwReason is currently only set for CRYPT_E_REVOKED and contains
//      the reason why the context was revoked. May be one of the following
//      CRL reasons defined by the CRL Reason Code extension ("2.5.29.21")
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6
//
//  For each entry in rgpvContext, CertVerifyRevocation iterates
//  through the CRYPT_OID_VERIFY_REVOCATION_FUNC
//  function set's list of installed DEFAULT functions.
//  CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no
//  installed functions are found capable of doing the revocation verification,
//  CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's
//  list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to
//  get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll.
//
//  The called functions have the same signature as CertVerifyRevocation. A
//  called function returns TRUE if it was able to successfully check all of
//  the contexts and none were revoked. Otherwise, the called function returns
//  FALSE and updates pRevStatus. dwIndex is set to the index of
//  the first context that was found to be revoked or unable to be checked.
//  dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason
//  is updated. Upon input to the called function, dwIndex, dwError and
//  dwReason have been zero'ed. cbSize has been checked to be >=
//  sizeof(CERT_REVOCATION_STATUS).
//
//  If the called function returns FALSE, and dwError isn't set to
//  CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the
//  next DLL in the list for a returned dwIndex of 0 or for a returned
//  dwIndex > 0, restarts the process of finding a verify function by
//  advancing the start of the context array to the returned dwIndex and
//  decrementing the count of remaining contexts.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifyRevocation(
    __in DWORD dwEncodingType,
    __in DWORD dwRevType,
    __in DWORD cContext,
    __in_ecount(cContext) PVOID rgpvContext[],
    __in DWORD dwFlags,
    __in_opt PCERT_REVOCATION_PARA pRevPara,
    __inout PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  Revocation types
//--------------------------------------------------------------------------
#define CERT_CONTEXT_REVOCATION_TYPE        1

//+-------------------------------------------------------------------------
//  When the following flag is set, rgpvContext[] consists of a chain
//  of certificates, where rgpvContext[i + 1] is the issuer of rgpvContext[i].
//--------------------------------------------------------------------------
#define CERT_VERIFY_REV_CHAIN_FLAG                  0x00000001

//+-------------------------------------------------------------------------
// CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION prevents the revocation handler from
// accessing any network based resources for revocation checking
//--------------------------------------------------------------------------
#define CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION     0x00000002

//+-------------------------------------------------------------------------
//  By default, the dwUrlRetrievalTimeout in pRevPara is the timeout used
//  for each URL wire retrieval. When the following flag is set,
//  dwUrlRetrievalTimeout is the accumulative timeout across all URL wire
//  retrievals.
//--------------------------------------------------------------------------
#define CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG   0x00000004

//+-------------------------------------------------------------------------
//  When the following flag is set, only OCSP responses are used for
//  doing revocation checking. If the certificate doesn't have any
//  OCSP AIA URLs, dwError is set to CRYPT_E_NOT_IN_REVOCATION_DATABASE.
//--------------------------------------------------------------------------
#define CERT_VERIFY_REV_SERVER_OCSP_FLAG            0x00000008



//+-------------------------------------------------------------------------
//  CERT_CONTEXT_REVOCATION_TYPE
//
//  pvContext points to a const CERT_CONTEXT.
//--------------------------------------------------------------------------

//+=========================================================================
//  Certificate Helper APIs
//==========================================================================


//+-------------------------------------------------------------------------
//  Compare two multiple byte integer blobs to see if they are identical.
//
//  Before doing the comparison, leading zero bytes are removed from a
//  positive number and leading 0xFF bytes are removed from a negative
//  number.
//
//  The multiple byte integers are treated as Little Endian. pbData[0] is the
//  least significant byte and pbData[cbData - 1] is the most significant
//  byte.
//
//  Returns TRUE if the integer blobs are identical after removing leading
//  0 or 0xFF bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareIntegerBlob(
    __in PCRYPT_INTEGER_BLOB pInt1,
    __in PCRYPT_INTEGER_BLOB pInt2
    );

//+-------------------------------------------------------------------------
//  Compare two certificates to see if they are identical.
//
//  Since a certificate is uniquely identified by its Issuer and SerialNumber,
//  these are the only fields needing to be compared.
//
//  Returns TRUE if the certificates are identical.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertCompareCertificate(
    __in DWORD dwCertEncodingType,
    __in PCERT_INFO pCertId1,
    __in PCERT_INFO pCertId2
    );

//+-------------------------------------------------------------------------
//  Compare two certificate names to see if they are identical.
//
//  Returns TRUE if the names are identical.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertCompareCertificateName(
    __in DWORD dwCertEncodingType,
    __in PCERT_NAME_BLOB pCertName1,
    __in PCERT_NAME_BLOB pCertName2
    );

//+-------------------------------------------------------------------------
//  Compare the attributes in the certificate name with the specified
//  Relative Distinguished Name's (CERT_RDN) array of attributes.
//  The comparison iterates through the CERT_RDN attributes and looks for an
//  attribute match in any of the certificate name's RDNs.
//  Returns TRUE if all the attributes are found and match.
//
//  The CERT_RDN_ATTR fields can have the following special values:
//    pszObjId == NULL              - ignore the attribute object identifier
//    dwValueType == RDN_ANY_TYPE   - ignore the value type
//
//  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set to do
//  a case insensitive match. Otherwise, defaults to an exact, case sensitive
//  match.
//
//  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized
//  with unicode strings as for CryptEncodeObject(X509_UNICODE_NAME).
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertIsRDNAttrsInCertificateName(
    __in DWORD dwCertEncodingType,
    __in DWORD dwFlags,
    __in PCERT_NAME_BLOB pCertName,
    __in PCERT_RDN pRDN
    );

#define CERT_UNICODE_IS_RDN_ATTRS_FLAG              0x1
#define CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG     0x2

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertComparePublicKeyInfo(
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pPublicKey1,
    __in PCERT_PUBLIC_KEY_INFO pPublicKey2
    );

//+-------------------------------------------------------------------------
//  Get the public/private key's bit length.
//
//  Returns 0 if unable to determine the key's length.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertGetPublicKeyLength(
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pPublicKey
    );

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  public key info
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
WINCRYPT32API
__checkReturn
BOOL
WINAPI
CryptVerifyCertificateSignature(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwCertEncodingType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __in PCERT_PUBLIC_KEY_INFO pPublicKey
    );

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate, CRL, certificate request
//  or keygen request using the issuer's public key.
//
//  Returns TRUE for a valid signature.
//
//  The subject can be an encoded blob or a context for a certificate or CRL.
//  For a subject certificate context, if the certificate is missing
//  inheritable PublicKey Algorithm Parameters, the context's
//  CERT_PUBKEY_ALG_PARA_PROP_ID is updated with the issuer's public key
//  algorithm parameters for a valid signature.
//
//  The issuer can be a pointer to a CERT_PUBLIC_KEY_INFO, certificate
//  context or a chain context.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  Its private key isn't used. If hCryptProv is NULL, a default
//  provider is picked according to the PublicKey Algorithm OID.
//
//  If the signature algorithm is a hashing algorithm, then, the
//  signature is expected to contain the hash octets. Only dwIssuerType
//  of CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL may be specified
//  to verify this no signature case. If any other dwIssuerType is
//  specified, the verify will fail with LastError set to E_INVALIDARG.
//--------------------------------------------------------------------------
WINCRYPT32API
__checkReturn
BOOL
WINAPI
CryptVerifyCertificateSignatureEx(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwCertEncodingType,
    __in DWORD dwSubjectType,
    __in void *pvSubject,
    __in DWORD dwIssuerType,
    __in_opt void *pvIssuer,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );


// Subject Types
#define CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB         1
    // pvSubject :: PCRYPT_DATA_BLOB
#define CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT         2
    // pvSubject :: PCCERT_CONTEXT
#define CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL          3
    // pvSubject :: PCCRL_CONTEXT
#define CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE   4
    // pvSubject :: POCSP_BASIC_SIGNED_RESPONSE_INFO

// Issuer Types
#define CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY        1
    // pvIssuer :: PCERT_PUBLIC_KEY_INFO
#define CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT          2
    // pvIssuer :: PCCERT_CONTEXT
#define CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN         3
    // pvIssuer :: PCCERT_CHAIN_CONTEXT
#define CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL          4
    // pvIssuer :: NULL

//+-------------------------------------------------------------------------
//  Compute the hash of the "to be signed" information in the encoded
//  signed content (CERT_SIGNED_CONTENT_INFO).
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptHashToBeSigned(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in DWORD dwCertEncodingType,
    __in_bcount(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Hash the encoded content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//
//  Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the
//  default hash algorithm (currently SHA1) is used.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptHashCertificate(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in ALG_ID Algid,
    __in DWORD dwFlags,
    __in_bcount_opt(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Hash the encoded content using the CNG hash algorithm provider.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptHashCertificate2(
    __in LPCWSTR pwszCNGHashAlgid,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __in_bcount_opt(cbEncoded) const BYTE *pbEncoded,
    __in DWORD cbEncoded,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Sign the "to be signed" information in the encoded signed content.
//
//  hCryptProvOrNCryptKey specifies the crypto provider to use to do the
//  signature.  It uses the specified private key.
//
//  If the SignatureAlgorithm is a hash algorithm, then, the signature
//  contains the hash octets. A private key isn't used to encrypt the hash.
//  dwKeySpec isn't used and hCryptProvOrNCryptKey can be NULL where an
//  appropriate default provider will be used for hashing.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSignCertificate(
    __in_opt HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    __in_opt DWORD dwKeySpec,       // not applicable for NCRYPT_KEY_HANDLE
    __in DWORD dwCertEncodingType,
    __in_bcount(cbEncodedToBeSigned) const BYTE *pbEncodedToBeSigned,
    __in DWORD cbEncodedToBeSigned,
    __in PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __in_opt const void *pvHashAuxInfo,
    __out_bcount_part_opt(*pcbSignature, *pcbSignature) BYTE *pbSignature,
    __inout DWORD *pcbSignature
    );

//+-------------------------------------------------------------------------
//  Encode the "to be signed" information. Sign the encoded "to be signed".
//  Encode the "to be signed" and the signature.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It uses the specified private key.
//
//  If the SignatureAlgorithm is a hash algorithm, then, the signature
//  contains the hash octets. A private key isn't used to encrypt the hash.
//  dwKeySpec isn't used and hCryptProv can be NULL where an appropriate
//  default provider will be used for hashing.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    __in_opt HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    __in_opt DWORD dwKeySpec,       // not applicable for NCRYPT_KEY_HANDLE
    __in DWORD dwCertEncodingType,
    __in LPCSTR lpszStructType,       // "to be signed"
    __in const void *pvStructInfo,
    __in PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __in_opt const void *pvHashAuxInfo,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded
    );


//+-------------------------------------------------------------------------
//  Certificate and CryptMsg encoded signature OID installable functions
//--------------------------------------------------------------------------


// The dwCertEncodingType and pSignatureAlgorithm->pszObjId are used
// to call the signature OID installable functions.
//
// If the OID installable function doesn't support the signature,
// it should return FALSE with LastError set to ERROR_NOT_SUPPORTED.


// Called if the signature has encoded parameters. Returns the CNG
// hash algorithm identifier string. Optionally returns the decoded
// signature parameters passed to either the SignAndEncodeHash or
// VerifyEncodedSignature OID installable function.
//
// Returned allocated parameters are freed via LocalFree().
#define CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC \
    "CryptDllExtractEncodedSignatureParameters"
typedef BOOL (WINAPI *PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC)(
    __in DWORD dwCertEncodingType,
    __in PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __deref_out_opt void **ppvDecodedSignPara, // LocalFree()
    __deref_out LPWSTR *ppwszCNGHashAlgid      // LocalFree()
    );

// Called to sign the computed hash and encode it.
#define CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC \
    "CryptDllSignAndEncodeHash"
typedef BOOL (WINAPI *PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC)(
    __in NCRYPT_KEY_HANDLE hKey,
    __in DWORD dwCertEncodingType,
    __in PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __in_opt void *pvDecodedSignPara,
    __in LPCWSTR pwszCNGPubKeyAlgid,    // obtained from signature OID
    __in LPCWSTR pwszCNGHashAlgid,
    __in_bcount(cbComputedHash) BYTE *pbComputedHash,
    __in DWORD cbComputedHash,
    __out_bcount_part_opt(*pcbSignature, *pcbSignature) BYTE *pbSignature,
    __inout DWORD *pcbSignature
    );

// Called to decode and decrypt the encoded signature and compare it with the
// computed hash.
#define CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC \
    "CryptDllVerifyEncodedSignature"
typedef BOOL (WINAPI *PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC)(
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    __in PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __in_opt void *pvDecodedSignPara,
    __in LPCWSTR pwszCNGPubKeyAlgid,    // obtained from signature OID
    __in LPCWSTR pwszCNGHashAlgid,
    __in_bcount(cbComputedHash) BYTE *pbComputedHash,
    __in DWORD cbComputedHash,
    __in_bcount(cbSignature) BYTE *pbSignature,
    __in DWORD cbSignature
    );


//+-------------------------------------------------------------------------
//  Verify the time validity of a certificate.
//
//  Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for
//  a valid certificate
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
WINCRYPT32API
LONG
WINAPI
CertVerifyTimeValidity(
    __in_opt LPFILETIME pTimeToVerify,
    __in PCERT_INFO pCertInfo
    );


//+-------------------------------------------------------------------------
//  Verify the time validity of a CRL.
//
//  Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for
//  a valid CRL
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
WINCRYPT32API
LONG
WINAPI
CertVerifyCRLTimeValidity(
    __in_opt LPFILETIME pTimeToVerify,
    __in PCRL_INFO pCrlInfo
    );

//+-------------------------------------------------------------------------
//  Verify that the subject's time validity nests within the issuer's time
//  validity.
//
//  Returns TRUE if it nests. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifyValidityNesting(
    __in PCERT_INFO pSubjectInfo,
    __in PCERT_INFO pIssuerInfo
    );

//+-------------------------------------------------------------------------
//  Verify that the subject certificate isn't on its issuer CRL.
//
//  Returns true if the certificate isn't on the CRL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifyCRLRevocation(
    __in DWORD dwCertEncodingType,
    __in PCERT_INFO pCertId,          // Only the Issuer and SerialNumber
                                      // fields are used
    __in DWORD cCrlInfo,
    __in_ecount(cCrlInfo) PCRL_INFO rgpCrlInfo[]
    );

//+-------------------------------------------------------------------------
//  Convert the CAPI AlgId to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the AlgId.
//--------------------------------------------------------------------------
WINCRYPT32API
LPCSTR
WINAPI
CertAlgIdToOID(
    __in DWORD dwAlgId
    );

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the CAPI AlgId.
//
//  Returns 0 if there isn't an AlgId corresponding to the ObjId.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertOIDToAlgId(
    __in LPCSTR pszObjId
    );

//+-------------------------------------------------------------------------
//  Find an extension identified by its Object Identifier.
//
//  If found, returns pointer to the extension. Otherwise, returns NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
PCERT_EXTENSION
WINAPI
CertFindExtension(
    __in LPCSTR pszObjId,
    __in DWORD cExtensions,
    __in_ecount(cExtensions) CERT_EXTENSION rgExtensions[]
    );

//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Object Identifier.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
PCRYPT_ATTRIBUTE
WINAPI
CertFindAttribute(
    __in LPCSTR pszObjId,
    __in DWORD cAttr,
    __in_ecount(cAttr) CRYPT_ATTRIBUTE rgAttr[]
    );

//+-------------------------------------------------------------------------
//  Find the first CERT_RDN attribute identified by its Object Identifier in
//  the name's list of Relative Distinguished Names.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
PCERT_RDN_ATTR
WINAPI
CertFindRDNAttr(
    __in LPCSTR pszObjId,
    __in PCERT_NAME_INFO pName
    );

//+-------------------------------------------------------------------------
//  Get the intended key usage bytes from the certificate.
//
//  If the certificate doesn't have any intended key usage bytes, returns FALSE
//  and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through
//  cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied
//  bytes are zeroed.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertGetIntendedKeyUsage(
    __in DWORD dwCertEncodingType,
    __in PCERT_INFO pCertInfo,
    __out_bcount_full(cbKeyUsage) BYTE *pbKeyUsage,
    __in DWORD cbKeyUsage
    );

typedef void *HCRYPTDEFAULTCONTEXT;

//+-------------------------------------------------------------------------
//  Install a previously CryptAcquiredContext'ed HCRYPTPROV to be used as
//  a default context.
//
//  dwDefaultType and pvDefaultPara specify where the default context is used.
//  For example, install the HCRYPTPROV to be used to verify certificate's
//  having szOID_OIWSEC_md5RSA signatures.
//
//  By default, the installed HCRYPTPROV is only applicable to the current
//  thread. Set CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG to allow the HCRYPTPROV
//  to be used by all threads in the current process.
//
//  For a successful install, TRUE is returned and *phDefaultContext is
//  updated with the HANDLE to be passed to CryptUninstallDefaultContext.
//
//  The installed HCRYPTPROVs are stack ordered (the last installed
//  HCRYPTPROV is checked first). All thread installed HCRYPTPROVs are
//  checked before any process HCRYPTPROVs.
//
//  The installed HCRYPTPROV remains available for default usage until
//  CryptUninstallDefaultContext is called or the thread or process exits.
//
//  If CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG is set, then, the HCRYPTPROV
//  is CryptReleaseContext'ed at thread or process exit. However,
//  not CryptReleaseContext'ed if CryptUninstallDefaultContext is
//  called.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptInstallDefaultContext(
    __in HCRYPTPROV hCryptProv,
    __in DWORD dwDefaultType,
    __in_opt const void *pvDefaultPara,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out HCRYPTDEFAULTCONTEXT *phDefaultContext
    );

// dwFlags
#define CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG             0x00000001
#define CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG                  0x00000002

// List of dwDefaultType's
#define CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID         1
#define CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID   2


//+-------------------------------------------------------------------------
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID
//
//  Install a default HCRYPTPROV used to verify a certificate
//  signature. pvDefaultPara points to the szOID of the certificate
//  signature algorithm, for example, szOID_OIWSEC_md5RSA. If
//  pvDefaultPara is NULL, then, the HCRYPTPROV is used to verify all
//  certificate signatures. Note, pvDefaultPara can't be NULL when
//  CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG is set.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID
//
//  Same as CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID. However, the default
//  HCRYPTPROV is to be used for multiple signature szOIDs. pvDefaultPara
//  points to a CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA structure containing
//  an array of szOID pointers.
//--------------------------------------------------------------------------

typedef struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
    DWORD               cOID;
    LPSTR               *rgpszOID;
} CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA, *PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;


//+-------------------------------------------------------------------------
//  Uninstall a default context previously installed by
//  CryptInstallDefaultContext.
//
//  For a default context installed with CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG
//  set, if any other threads are currently using this context,
//  this function will block until they finish.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptUninstallDefaultContext(
    __in_opt HCRYPTDEFAULTCONTEXT hDefaultContext,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Calls CryptExportPublicKeyInfoEx with pszPublicKeyObjId = NULL,
//  dwFlags = 0 and pvAuxInfo = NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptExportPublicKeyInfo(
    __in HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    __in_opt DWORD dwKeySpec,       // not applicable for NCRYPT_KEY_HANDLE
    __in DWORD dwCertEncodingType,
    __out_bcount_part_opt(*pcbInfo, *pcbInfo) PCERT_PUBLIC_KEY_INFO pInfo,
    __inout DWORD *pcbInfo
    );


//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Uses the dwCertEncodingType and pszPublicKeyObjId to call the
//  installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptExportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszPublicKeyObjId,
//  attempts to export as a RSA Public Key (szOID_RSA_RSA).
//
//  The dwFlags and pvAuxInfo aren't used for szOID_RSA_RSA.
//
//  dwFlags can be set with the following 2 flags passed directly to
//  CryptFindOIDInfo:
//      CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG
//      CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG
//--------------------------------------------------------------------------

WINCRYPT32API
BOOL
WINAPI
CryptExportPublicKeyInfoEx(
    __in HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    __in_opt DWORD dwKeySpec,       // not applicable for NCRYPT_KEY_HANDLE
    __in DWORD dwCertEncodingType,
    __in_opt LPSTR pszPublicKeyObjId,
    __in DWORD dwFlags,
    __in_opt void *pvAuxInfo,
    __out_bcount_part_opt(*pcbInfo, *pcbInfo) PCERT_PUBLIC_KEY_INFO pInfo,
    __inout DWORD *pcbInfo
    );

// Legacy define used for exporting CAPI1 HCRYPTPROV public keys.
#define CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC   "CryptDllExportPublicKeyInfoEx"

//+-------------------------------------------------------------------------
//  Export CNG PublicKeyInfo OID installable function. Note, not called
//  for a HCRYPTPROV choice.
//--------------------------------------------------------------------------
#define CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC \
    "CryptDllExportPublicKeyInfoEx2"
typedef BOOL (WINAPI *PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC) (
    __in NCRYPT_KEY_HANDLE hNCryptKey,
    __in DWORD dwCertEncodingType,
    __in LPSTR pszPublicKeyObjId,
    __in DWORD dwFlags,
    __in_opt void *pvAuxInfo,
    __out_bcount_part_opt(*pcbInfo, *pcbInfo) PCERT_PUBLIC_KEY_INFO pInfo,
    __inout DWORD *pcbInfo
    );


//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and
//  pvAuxInfo = NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfo(
    __in HCRYPTPROV hCryptProv,
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pInfo,
    __out HCRYPTKEY *phKey
    );

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
//  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptImportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszObjId,
//  attempts to import as a RSA Public Key (szOID_RSA_RSA).
//
//  For szOID_RSA_RSA: aiKeyAlg may be set to CALG_RSA_SIGN or CALG_RSA_KEYX.
//  Defaults to CALG_RSA_KEYX. The dwFlags and pvAuxInfo aren't used.
//--------------------------------------------------------------------------
#define CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC   "CryptDllImportPublicKeyInfoEx"

WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    __in HCRYPTPROV hCryptProv,
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pInfo,
    __in ALG_ID aiKeyAlg,
    __in DWORD dwFlags,
    __in_opt void *pvAuxInfo,
    __out HCRYPTKEY *phKey
    );


//+-------------------------------------------------------------------------
//  Convert and import the public key info into the CNG asymmetric or
//  signature algorithm provider and return a BCRYPT_KEY_HANDLE to it.
//
//  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
//  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC. The called function
//  has the same signature as CryptImportPublicKeyInfoEx2.
//
//  dwFlags can be set with the following 2 flags passed directly to
//  CryptFindOIDInfo:
//      CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG
//      CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfoEx2(
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pInfo,
    __in DWORD dwFlags,
    __in_opt void *pvAuxInfo,
    __out BCRYPT_KEY_HANDLE *phKey
    );


//+-------------------------------------------------------------------------
//  Import CNG PublicKeyInfo OID installable function
//--------------------------------------------------------------------------
#define CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC \
    "CryptDllImportPublicKeyInfoEx2"
typedef BOOL (WINAPI *PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC) (
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pInfo,
    __in DWORD dwFlags,
    __in_opt void *pvAuxInfo,
    __out BCRYPT_KEY_HANDLE *phKey
    );


//+-------------------------------------------------------------------------
//  Acquire a HCRYPTPROV and dwKeySpec or NCRYPT_KEY_HANDLE for the
//  specified certificate context. Uses the certificate's
//  CERT_KEY_PROV_INFO_PROP_ID property.
//  The returned HCRYPTPROV or NCRYPT_KEY_HANDLE handle may optionally be
//  cached using the certificate's CERT_KEY_CONTEXT_PROP_ID property.
//
//  If CRYPT_ACQUIRE_CACHE_FLAG is set, then, if an already acquired and
//  cached HCRYPTPROV or NCRYPT_KEY_HANDLE exists for the certificate, its
//  returned. Otherwise, a HCRYPTPROV or NCRYPT_KEY_HANDLE is acquired and
//  then cached via the certificate's CERT_KEY_CONTEXT_PROP_ID.
//
//  The CRYPT_ACQUIRE_USE_PROV_INFO_FLAG can be set to use the dwFlags field of
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property's CRYPT_KEY_PROV_INFO
//  data structure to determine if the returned HCRYPTPROV or
//  NCRYPT_KEY_HANDLE should be cached.
//  Caching is enabled if the CERT_SET_KEY_CONTEXT_PROP_ID flag was
//  set.
//
//  If CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set, then,
//  the public key in the certificate is compared with the public
//  key returned by the cryptographic provider. If the keys don't match, the
//  acquire fails and LastError is set to NTE_BAD_PUBLIC_KEY. Note, if
//  a cached HCRYPTPROV or NCRYPT_KEY_HANDLE is returned, the comparison isn't
//  done. We assume the comparison was done on the initial acquire.
//
//  The CRYPT_ACQUIRE_NO_HEALING flags prohibits this function from
//  attempting to recreate the CERT_KEY_PROV_INFO_PROP_ID in the certificate
//  context if it fails to retrieve this property.
//
//  The CRYPT_ACQUIRE_SILENT_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  The following flags can be set to optionally open and return a CNG
//  NCRYPT_KEY_HANDLE instead of a HCRYPTPROV. *pdwKeySpec is set to
//  CERT_NCRYPT_KEY_SPEC when a NCRYPT_KEY_HANDLE is returned.
//      CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG - if the CryptAcquireContext
//      fails, then, an NCryptOpenKey is attempted.
//
//      CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG - the NCryptOpenKey is
//      first attempted and its handle returned for success.
//
//      CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG - only the NCryptOpenKey is
//      attempted.
//
//  *pfCallerFreeProvOrNCryptKey is returned set to FALSE for:
//    - Acquire or public key comparison fails.
//    - CRYPT_ACQUIRE_CACHE_FLAG is set.
//    - CRYPT_ACQUIRE_USE_PROV_INFO_FLAG is set AND
//      CERT_SET_KEY_CONTEXT_PROP_ID flag is set in the dwFlags field of the
//      certificate's CERT_KEY_PROV_INFO_PROP_ID property's
//      CRYPT_KEY_PROV_INFO data structure.
//  When *pfCallerFreeProvOrNCryptKey is FALSE, the caller must not release. The
//  returned HCRYPTPROV or NCRYPT_KEY_HANDLE will be released on the last
//  free of the certificate context.
//
//  Otherwise, *pfCallerFreeProvOrNCryptKey is TRUE and a returned
//  HCRYPTPROV must be released by the caller by calling CryptReleaseContext.
//  A returned NCRYPT_KEY_HANDLE is freed by calling NCryptFreeObject.
//  *pdwKeySpec MUST be checked when CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG
//  or CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG is set.
//
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptAcquireCertificatePrivateKey(
    __in PCCERT_CONTEXT pCert,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey,
    __out_opt DWORD *pdwKeySpec,
    __out_opt BOOL *pfCallerFreeProvOrNCryptKey
    );

#define CRYPT_ACQUIRE_CACHE_FLAG                0x00000001
#define CRYPT_ACQUIRE_USE_PROV_INFO_FLAG        0x00000002
#define CRYPT_ACQUIRE_COMPARE_KEY_FLAG          0x00000004
#define CRYPT_ACQUIRE_NO_HEALING                0x00000008

#define CRYPT_ACQUIRE_SILENT_FLAG               0x00000040

#define CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK     0x00070000
#define CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG     0x00010000
#define CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG    0x00020000
#define CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG      0x00040000


//+-------------------------------------------------------------------------
//  Enumerates the cryptographic providers and their containers to find the
//  private key corresponding to the certificate's public key. For a match,
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property is updated.
//
//  If the CERT_KEY_PROV_INFO_PROP_ID is already set, then, its checked to
//  see if it matches the provider's public key. For a match, the above
//  enumeration is skipped.
//
//  By default both the user and machine key containers are searched.
//  The CRYPT_FIND_USER_KEYSET_FLAG or CRYPT_FIND_MACHINE_KEYSET_FLAG
//  can be set in dwFlags to restrict the search to either of the containers.
//
//  The CRYPT_FIND_SILENT_KEYSET_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  If a container isn't found, returns FALSE with LastError set to
//  NTE_NO_KEY.
//
//  The above CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS can also be set. The default
//  is CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptFindCertificateKeyProvInfo(
    __in PCCERT_CONTEXT pCert,
    __in DWORD dwFlags,
    __reserved void *pvReserved
    );

#define CRYPT_FIND_USER_KEYSET_FLAG        0x00000001
#define CRYPT_FIND_MACHINE_KEYSET_FLAG     0x00000002
#define CRYPT_FIND_SILENT_KEYSET_FLAG      0x00000040


//+-------------------------------------------------------------------------
//  This is the prototype for the installable function which is called to
//  actually import a key into a CSP.  an installable of this type is called
//  from CryptImportPKCS8.  the algorithm OID of the private key is used
//  to look up the proper installable function to call.
//
//  hCryptProv - the provider to import the key to
//  pPrivateKeyInfo - describes the key to be imported
//  dwFlags - The available flags are:
//              CRYPT_EXPORTABLE
//              this flag is used when importing private keys, for a full
//              explanation please see the documentation for CryptImportKey.
//  pvAuxInfo - reserved for future, must be NULL
//--------------------------------------------------------------------------
typedef BOOL (WINAPI *PFN_IMPORT_PRIV_KEY_FUNC) (
    __in HCRYPTPROV hCryptProv,                     // in
    __in CRYPT_PRIVATE_KEY_INFO* pPrivateKeyInfo,   // in
    __in DWORD dwFlags,                             // in
    __in_opt void* pvAuxInfo                        // in, optional
    );

#define CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC   "CryptDllImportPrivateKeyInfoEx"

//+-------------------------------------------------------------------------
// Convert (from PKCS8 format) and import the private key into a provider
// and return a handle to the provider as well as the KeySpec used to import to.
//
// This function will call the PRESOLVE_HCRYPTPROV_FUNC in the
// privateKeyAndParams to obtain a handle of provider to import the key to.
// if the PRESOLVE_HCRYPTPROV_FUNC is NULL then the default provider will be used.
//
// privateKeyAndParams - private key blob and corresponding parameters
// dwFlags - The available flags are:
//              CRYPT_EXPORTABLE
//              this flag is used when importing private keys, for a full
//              explanation please see the documentation for CryptImportKey.
// phCryptProv - filled in with the handle of the provider the key was
//               imported to, the caller is responsible for freeing it
// pvAuxInfo - This parameter is reserved for future use and should be set
//             to NULL in the interim.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptImportPKCS8(
    __in CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams,    // in
    __in DWORD dwFlags,                                     // in
    __out_opt HCRYPTPROV *phCryptProv,                      // out, optional
    __in_opt void* pvAuxInfo                                // in, optional
    );

//+-------------------------------------------------------------------------
// this is the prototype for installable functions for exporting the private key
//--------------------------------------------------------------------------
typedef BOOL (WINAPI *PFN_EXPORT_PRIV_KEY_FUNC) (
    __in HCRYPTPROV hCryptProv,         // in
    __in DWORD dwKeySpec,               // in
    __in LPSTR pszPrivateKeyObjId,      // in
    __in DWORD dwFlags,                 // in
    __in_opt void* pvAuxInfo,           // in
    __out_bcount_opt (*pcbPrivateKeyInfo) CRYPT_PRIVATE_KEY_INFO* pPrivateKeyInfo,  // out
    __inout DWORD* pcbPrivateKeyInfo    // in, out
    );

#define CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC   "CryptDllExportPrivateKeyInfoEx"

#define CRYPT_DELETE_KEYSET 0x0001
//+-------------------------------------------------------------------------
//  CryptExportPKCS8 -- superseded by CryptExportPKCS8Ex
//
//  Export the private key in PKCS8 format
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptExportPKCS8(
    __in HCRYPTPROV hCryptProv,                                     // in
    __in DWORD dwKeySpec,                                           // in
    __in LPSTR pszPrivateKeyObjId,                                  // in
    __in DWORD dwFlags,                                             // in
    __in_opt void* pvAuxInfo,                                       // in
    __out_bcount_opt (*pcbPrivateKeyBlob) BYTE* pbPrivateKeyBlob,   // out
    __inout DWORD *pcbPrivateKeyBlob                                // in, out
    );

//+-------------------------------------------------------------------------
// CryptExportPKCS8Ex
//
//  Export the private key in PKCS8 format
//
//
//  Uses the pszPrivateKeyObjId to call the
//  installable CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC. The called function
//  has the signature defined by PFN_EXPORT_PRIV_KEY_FUNC.
//
//  If unable to find an installable OID function for the pszPrivateKeyObjId,
//  attempts to export as a RSA Private Key (szOID_RSA_RSA).
//
// psExportParams - specifies information about the key to export
// dwFlags - The flag values. None currently supported
// pvAuxInfo - This parameter is reserved for future use and should be set to
//                         NULL in the interim.
// pbPrivateKeyBlob - A pointer to the private key blob.  It will be encoded
//                                        as a PKCS8 PrivateKeyInfo.
// pcbPrivateKeyBlob - A pointer to a DWORD that contains the size, in bytes,
//                                         of the private key blob being exported.
//+-------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptExportPKCS8Ex(
    __in CRYPT_PKCS8_EXPORT_PARAMS* psExportParams,                 // in
    __in DWORD dwFlags,                                             // in
    __in_opt void* pvAuxInfo,                                       // in
    __out_bcount_opt (*pcbPrivateKeyBlob) BYTE* pbPrivateKeyBlob,   // out
    __inout DWORD* pcbPrivateKeyBlob                                // in, out
    );

//+-------------------------------------------------------------------------
//  Compute the hash of the encoded public key info.
//
//  The public key info is encoded and then hashed.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptHashPublicKeyInfo(
    __in_opt HCRYPTPROV_LEGACY hCryptProv,
    __in ALG_ID Algid,
    __in DWORD dwFlags,
    __in DWORD dwCertEncodingType,
    __in PCERT_PUBLIC_KEY_INFO pInfo,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated char string
//
//  Returns the number of characters converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertRDNValueToStrA(
    __in DWORD dwValueType,
    __in PCERT_RDN_VALUE_BLOB pValue,
    __out_ecount_part_opt(csz, return) LPSTR psz,
    __in DWORD csz
    );
//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated char string
//
//  Returns the number of characters converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertRDNValueToStrW(
    __in DWORD dwValueType,
    __in PCERT_RDN_VALUE_BLOB pValue,
    __out_ecount_part_opt(csz, return) LPWSTR psz,
    __in DWORD csz
    );
#ifdef UNICODE
#define CertRDNValueToStr  CertRDNValueToStrW
#else
#define CertRDNValueToStr  CertRDNValueToStrA
#endif // !UNICODE

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated char string.
//
//  Follows the string representation of distinguished names specified in
//  RFC 1779. (Note, added double quoting "" for embedded quotes, quote
//  empty strings and don't quote strings containing consecutive spaces).
//  RDN values of type CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING are
//  formatted in hexadecimal (e.g. #0A56CF).
//
//  The name string is formatted according to the dwStrType:
//    CERT_SIMPLE_NAME_STR
//      The object identifiers are discarded. CERT_RDN entries are separated
//      by ", ". Multiple attributes per CERT_RDN are separated by " + ".
//      For example:
//          Microsoft, Joe Cool + Programmer
//    CERT_OID_NAME_STR
//      The object identifiers are included with a "=" separator from their
//      attribute value. CERT_RDN entries are separated by ", ".
//      Multiple attributes per CERT_RDN are separated by " + ". For example:
//          2.5.4.11=Microsoft, 2.5.4.3=Joe Cool + 2.5.4.12=Programmer
//    CERT_X500_NAME_STR
//      The object identifiers are converted to their X500 key name. Otherwise,
//      same as CERT_OID_NAME_STR. If the object identifier doesn't have
//      a corresponding X500 key name, then, the object identifier is used with
//      a "OID." prefix. For example:
//          OU=Microsoft, CN=Joe Cool + T=Programmer, OID.1.2.3.4.5.6=Unknown
//    CERT_XML_NAME_STR
//      The object identifiers are converted the same as the above
//      CERT_X500_NAME_STR. However, formatted as sequence of XML elements.
//      Here's an example:
//          <CN>cart.barnesandnoble.com</CN>
//          <OU>Terms of use at www.verisign.com/rpa (c)00</OU>
//          <OU rDNAttribute="true">IT Operations</OU>
//          <O>Barnesandnoble.com</O>
//          <L>New York</L>
//          <S>New York</S>
//          <C>US</C>
//          <RDN oid="1.2.3.4" type="string">name</RDN>
//          <RDN rDNAttribute="true" oid="1.2.1.3" type="encoded">0500</RDN>
//          <RDN oid="1.2.1.4" type="encoded">020135</RDN>
//          <RDN oid="1.2.2.5.3" type="octet">01FF7F</RDN>
//      Where:
//          Any XML markup characters are escaped:
//             L'&'   - L"&amp;"
//             L'<'   - L"&lt;"
//             L'>'   - L"&gt;"
//             L'\''  - L"&apos;"
//             L'\"'  - L"&quot;"
//          Will escape characters > 0x7F via chararacter references,
//          L"&#xXXXX;"
//
//          CERT_NAME_STR_REVERSE_FLAG and CERT_NAME_STR_CRLF_FLAG can be set.
//          The following quoting, semicolon and plus semantics aren't
//          applicable. The "+" is replaced with rDNAttribute="true".
//
//
//  We quote the RDN value if it contains leading or trailing whitespace
//  or one of the following characters: ",", "+", "=", """, "\n",  "<", ">",
//  "#" or ";". The quoting character is ". If the the RDN Value contains
//  a " it is double quoted (""). For example:
//      OU="  Microsoft", CN="Joe ""Cool""" + T="Programmer, Manager"
//
//  CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to replace
//  the ", " separator with a "; " separator.
//
//  CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to replace
//  the ", " separator with a "\r\n" separator.
//
//  CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to replace the
//  " + " separator with a single space, " ".
//
//  CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit
//  the above quoting.
//
//  CERT_NAME_STR_REVERSE_FLAG can be or'ed into dwStrType to reverse the
//  order of the RDNs before converting to the string.
//
//  By default, CERT_RDN_T61_STRING encoded values are initially decoded
//  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
//  CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG can be or'ed into dwStrType to
//  skip the initial attempt to decode as UTF8.
//
//  Returns the number of characters converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertNameToStrA(
    __in DWORD dwCertEncodingType,
    __in PCERT_NAME_BLOB pName,
    __in DWORD dwStrType,
    __out_ecount_part_opt(csz, return) LPSTR psz,
    __in DWORD csz
    );
//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertNameToStrW(
    __in DWORD dwCertEncodingType,
    __in PCERT_NAME_BLOB pName,
    __in DWORD dwStrType,
    __out_ecount_part_opt(csz, return) LPWSTR psz,
    __in DWORD csz
    );
#ifdef UNICODE
#define CertNameToStr  CertNameToStrW
#else
#define CertNameToStr  CertNameToStrA
#endif // !UNICODE

// certenrolld_begin -- CERT_NAME_STR_*_FLAG
//+-------------------------------------------------------------------------
//  Certificate name string types
//--------------------------------------------------------------------------
#define CERT_SIMPLE_NAME_STR        1
#define CERT_OID_NAME_STR           2
#define CERT_X500_NAME_STR          3
#define CERT_XML_NAME_STR           4

//+-------------------------------------------------------------------------
//  Certificate name string type flags OR'ed with the above types
//--------------------------------------------------------------------------
#define CERT_NAME_STR_SEMICOLON_FLAG    0x40000000
#define CERT_NAME_STR_NO_PLUS_FLAG      0x20000000
#define CERT_NAME_STR_NO_QUOTING_FLAG   0x10000000
#define CERT_NAME_STR_CRLF_FLAG         0x08000000
#define CERT_NAME_STR_COMMA_FLAG        0x04000000
#define CERT_NAME_STR_REVERSE_FLAG      0x02000000
#define CERT_NAME_STR_FORWARD_FLAG      0x01000000

#define CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG     0x00010000
#define CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG   0x00020000
#define CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG  0x00040000
#define CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG   0x00080000
#define CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG 0x00100000
// certenrolld_end


//+-------------------------------------------------------------------------
//  Convert the null terminated X500 string to an encoded certificate name.
//
//  The input string is expected to be formatted the same as the output
//  from the above CertNameToStr API.
//
//  The CERT_SIMPLE_NAME_STR type and CERT_XML_NAME_STR aren't supported.
//  Otherwise, when dwStrType
//  is set to 0, CERT_OID_NAME_STR or CERT_X500_NAME_STR, allow either a
//  case insensitive X500 key (CN=), case insensitive "OID." prefixed
//  object identifier (OID.1.2.3.4.5.6=) or an object identifier (1.2.3.4=).
//
//  If no flags are OR'ed into dwStrType, then, allow "," or ";" as RDN
//  separators and "+" as the multiple RDN value separator. Quoting is
//  supported. A quote may be included in a quoted value by double quoting,
//  for example (CN="Joe ""Cool"""). A value starting with a "#" is treated
//  as ascii hex and converted to a CERT_RDN_OCTET_STRING. Embedded whitespace
//  is skipped (1.2.3 = # AB CD 01  is the same as 1.2.3=#ABCD01).
//
//  Whitespace surrounding the keys, object identifers and values is removed.
//
//  CERT_NAME_STR_COMMA_FLAG can be or'ed into dwStrType to only allow the
//  "," as the RDN separator.
//
//  CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to only allow the
//  ";" as the RDN separator.
//
//  CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to only allow
//  "\r" or "\n" as the RDN separator.
//
//  CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to ignore "+"
//  as a separator and not allow multiple values per RDN.
//
//  CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit
//  quoting.
//
//  CERT_NAME_STR_REVERSE_FLAG can be or'ed into dwStrType to reverse the
//  order of the RDNs after converting from the string and before encoding.
//
//  CERT_NAME_STR_FORWARD_FLAG can be or'ed into dwStrType to defeat setting
//  CERT_NAME_STR_REVERSE_FLAG, if reverse order becomes the default.
//
//  CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG can be or'ed into dwStrType to
//  to select the CERT_RDN_T61_STRING encoded value type instead of
//  CERT_RDN_UNICODE_STRING if all the UNICODE characters are <= 0xFF.
//
//  CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG can be or'ed into dwStrType to
//  to select the CERT_RDN_UTF8_STRING encoded value type instead of
//  CERT_RDN_UNICODE_STRING.
//
//  CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG can be or'ed into dwStrType
//  to force the CERT_RDN_UTF8_STRING encoded value type instead of
//  allowing CERT_RDN_PRINTABLE_STRING for DirectoryString types.
//  Applies to the X500 Keys below which allow "Printable, Unicode".
//  Also, enables CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG.
//
//  CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG can be or'ed into dwStrType to
//  defeat setting CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG, if forcing UTF-8
//  becomes the default.
//
//  Support the following X500 Keys:
//
//  Key         Object Identifier               RDN Value Type(s)
//  ---         -----------------               -----------------
//  CN          szOID_COMMON_NAME               Printable, Unicode
//  L           szOID_LOCALITY_NAME             Printable, Unicode
//  O           szOID_ORGANIZATION_NAME         Printable, Unicode
//  OU          szOID_ORGANIZATIONAL_UNIT_NAME  Printable, Unicode
//  E           szOID_RSA_emailAddr             Only IA5
//  Email       szOID_RSA_emailAddr             Only IA5
//  C           szOID_COUNTRY_NAME              Only Printable
//  S           szOID_STATE_OR_PROVINCE_NAME    Printable, Unicode
//  ST          szOID_STATE_OR_PROVINCE_NAME    Printable, Unicode
//  STREET      szOID_STREET_ADDRESS            Printable, Unicode
//  T           szOID_TITLE                     Printable, Unicode
//  Title       szOID_TITLE                     Printable, Unicode
//  G           szOID_GIVEN_NAME                Printable, Unicode
//  GN          szOID_GIVEN_NAME                Printable, Unicode
//  GivenName   szOID_GIVEN_NAME                Printable, Unicode
//  I           szOID_INITIALS                  Printable, Unicode
//  Initials    szOID_INITIALS                  Printable, Unicode
//  SN          szOID_SUR_NAME                  Printable, Unicode
//  DC          szOID_DOMAIN_COMPONENT          IA5, UTF8
//  SERIALNUMBER szOID_DEVICE_SERIAL_NUMBER     Only Printable
//
//  Note, T61 is selected instead of Unicode if
//  CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG is set and all the unicode
//  characters are <= 0xFF.
//
//  Note, UTF8 is selected instead of Unicode if
//  CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG is set.
//
//  Returns TRUE if successfully parsed the input string and encoded
//  the name.
//
//  If the input string is detected to be invalid, *ppszError is updated
//  to point to the beginning of the invalid character sequence. Otherwise,
//  *ppszError is set to NULL. *ppszError is updated with a non-NULL pointer
//  for the following errors:
//      CRYPT_E_INVALID_X500_STRING
//      CRYPT_E_INVALID_NUMERIC_STRING
//      CRYPT_E_INVALID_PRINTABLE_STRING
//      CRYPT_E_INVALID_IA5_STRING
//
//  ppszError can be set to NULL if not interested in getting a pointer
//  to the invalid character sequence.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertStrToNameA(
    __in DWORD dwCertEncodingType,
    __in LPCSTR pszX500,
    __in DWORD dwStrType,
    __reserved void *pvReserved,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded,
    __deref_opt_out_opt LPCSTR *ppszError
    );
//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertStrToNameW(
    __in DWORD dwCertEncodingType,
    __in LPCWSTR pszX500,
    __in DWORD dwStrType,
    __reserved void *pvReserved,
    __out_bcount_part_opt(*pcbEncoded, *pcbEncoded) BYTE *pbEncoded,
    __inout DWORD *pcbEncoded,
    __deref_opt_out_opt LPCWSTR *ppszError
    );
#ifdef UNICODE
#define CertStrToName  CertStrToNameW
#else
#define CertStrToName  CertStrToNameA
#endif // !UNICODE


//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  character string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//
//  By default, CERT_RDN_T61_STRING encoded values are initially decoded
//  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
//  CERT_NAME_DISABLE_IE4_UTF8_FLAG can be set in dwFlags to
//  skip the initial attempt to decode as UTF8.
//
//  The name string is formatted according to the dwType:
//    CERT_NAME_EMAIL_TYPE
//      If the certificate has a Subject Alternative Name extension (for
//      issuer, Issuer Alternative Name), searches for first rfc822Name choice.
//      If the rfc822Name choice isn't found in the extension, searches the
//      Subject Name field for the Email OID, "1.2.840.113549.1.9.1".
//      If the rfc822Name or Email OID is found, returns the string. Otherwise,
//      returns an empty string (returned character count is 1).
//    CERT_NAME_DNS_TYPE
//      If the certificate has a Subject Alternative Name extension (for
//      issuer, Issuer Alternative Name), searches for first DNSName choice.
//      If the DNSName choice isn't found in the extension, searches the
//      Subject Name field for the CN OID, "2.5.4.3".
//      If the DNSName or CN OID is found, returns the string. Otherwise,
//      returns an empty string.
//    CERT_NAME_URL_TYPE
//      If the certificate has a Subject Alternative Name extension (for
//      issuer, Issuer Alternative Name), searches for first URL choice.
//      If the URL choice is found, returns the string. Otherwise,
//      returns an empty string.
//    CERT_NAME_UPN_TYPE
//      If the certificate has a Subject Alternative Name extension,
//      searches the OtherName choices looking for a
//      pszObjId == szOID_NT_PRINCIPAL_NAME, "1.3.6.1.4.1.311.20.2.3".
//      If the UPN OID is found, the blob is decoded as a
//      X509_UNICODE_ANY_STRING and the decoded string is returned.
//      Otherwise, returns an empty string.
//    CERT_NAME_RDN_TYPE
//      Converts the Subject Name blob by calling CertNameToStr. pvTypePara
//      points to a DWORD containing the dwStrType passed to CertNameToStr.
//      If the Subject Name field is empty and the certificate has a
//      Subject Alternative Name extension, searches for and converts
//      the first directoryName choice.
//    CERT_NAME_ATTR_TYPE
//      pvTypePara points to the Object Identifier specifying the name attribute
//      to be returned. For example, to get the CN,
//      pvTypePara = szOID_COMMON_NAME ("2.5.4.3"). Searches, the Subject Name
//      field for the attribute.
//      If the Subject Name field is empty and the certificate has a
//      Subject Alternative Name extension, checks for
//      the first directoryName choice and searches it.
//
//      Note, searches the RDNs in reverse order.
//
//    CERT_NAME_SIMPLE_DISPLAY_TYPE
//      Iterates through the following list of name attributes and searches
//      the Subject Name and then the Subject Alternative Name extension
//      for the first occurrence of:
//          szOID_COMMON_NAME ("2.5.4.3")
//          szOID_ORGANIZATIONAL_UNIT_NAME ("2.5.4.11")
//          szOID_ORGANIZATION_NAME ("2.5.4.10")
//          szOID_RSA_emailAddr ("1.2.840.113549.1.9.1")
//
//      If none of the above attributes is found, then, searches the
//      Subject Alternative Name extension for a rfc822Name choice.
//
//      If still no match, then, returns the first attribute.
//
//      Note, like CERT_NAME_ATTR_TYPE, searches the RDNs in reverse order.
//
//    CERT_NAME_FRIENDLY_DISPLAY_TYPE
//      First checks if the certificate has a CERT_FRIENDLY_NAME_PROP_ID
//      property. If it does, then, this property is returned. Otherwise,
//      returns the above CERT_NAME_SIMPLE_DISPLAY_TYPE.
//
//  Returns the number of characters converted including the terminating null
//  character. If pwszNameString is NULL or cchNameString is 0, returns the
//  required size of the destination string (including the terminating null
//  char). If the specified name type isn't found. returns an empty string
//  with a returned character count of 1.
//
//  If pwszNameString != NULL && cwszNameString != 0, returned pwszNameString
//  is always NULL terminated.
//
//  Note: cchNameString includes the NULL char.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertGetNameStringA(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwType,
    __in DWORD dwFlags,
    __in_opt void *pvTypePara,
    __out_ecount_part_opt(cchNameString, return) LPSTR pszNameString,
    __in DWORD cchNameString
    );
//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
WINCRYPT32API
DWORD
WINAPI
CertGetNameStringW(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwType,
    __in DWORD dwFlags,
    __in_opt void *pvTypePara,
    __out_ecount_part_opt(cchNameString, return) LPWSTR pszNameString,
    __in DWORD cchNameString
    );
#ifdef UNICODE
#define CertGetNameString  CertGetNameStringW
#else
#define CertGetNameString  CertGetNameStringA
#endif // !UNICODE

//+-------------------------------------------------------------------------
//  Certificate name types
//--------------------------------------------------------------------------
#define CERT_NAME_EMAIL_TYPE            1
#define CERT_NAME_RDN_TYPE              2
#define CERT_NAME_ATTR_TYPE             3
#define CERT_NAME_SIMPLE_DISPLAY_TYPE   4
#define CERT_NAME_FRIENDLY_DISPLAY_TYPE 5
#define CERT_NAME_DNS_TYPE              6
#define CERT_NAME_URL_TYPE              7
#define CERT_NAME_UPN_TYPE              8

//+-------------------------------------------------------------------------
//  Certificate name flags
//--------------------------------------------------------------------------
#define CERT_NAME_ISSUER_FLAG           0x1
#define CERT_NAME_DISABLE_IE4_UTF8_FLAG 0x00010000


//+=========================================================================
//  Simplified Cryptographic Message Data Structures and APIs
//==========================================================================


//+-------------------------------------------------------------------------
//              Conventions for the *pb and *pcb output parameters:
//
//              Upon entry to the function:
//                  if pcb is OPTIONAL && pcb == NULL, then,
//                      No output is returned
//                  else if pb == NULL && pcb != NULL, then,
//                      Length only determination. No length error is
//                      returned.
//                  otherwise where (pb != NULL && pcb != NULL && *pcb != 0)
//                      Output is returned. If *pcb isn't big enough a
//                      length error is returned. In all cases *pcb is updated
//                      with the actual length needed/returned.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Type definitions of the parameters used for doing the cryptographic
//  operations.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Callback to get and verify the signer's certificate.
//
//  Passed the CertId of the signer (its Issuer and SerialNumber) and a
//  handle to its cryptographic signed message's cert store.
//
//  For CRYPT_E_NO_SIGNER, called with pSignerId == NULL.
//
//  For a valid signer certificate, returns a pointer to a read only
//  CERT_CONTEXT. The returned CERT_CONTEXT is either obtained from a
//  cert store or was created via CertCreateCertificateContext. For either case,
//  its freed via CertFreeCertificateContext.
//
//  If a valid certificate isn't found, this callback returns NULL with
//  LastError set via SetLastError().
//
//  The NULL implementation tries to get the Signer certificate from the
//  message cert store. It doesn't verify the certificate.
//
//  Note, if the KEYID choice was selected for a CMS SignerId, then, the
//  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
//  single Attribute whose OID is szOID_KEYID_RDN, value type is
//  CERT_RDN_OCTET_STRING and value is the KEYID. When the
//  CertGetSubjectCertificateFromStore and
//  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
//  special KEYID Issuer and SerialNumber, they do a KEYID match.
//--------------------------------------------------------------------------
typedef PCCERT_CONTEXT (WINAPI *PFN_CRYPT_GET_SIGNER_CERTIFICATE)(
    __inout_opt void *pvGetArg,
    __in DWORD dwCertEncodingType,
    __in PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields have been updated
    __in HCERTSTORE hMsgCertStore
    );

//+-------------------------------------------------------------------------
//  The CRYPT_SIGN_MESSAGE_PARA are used for signing messages using the
//  specified signing certificate context.
//
//  Either the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID must
//  be set for each rgpSigningCert[]. Either one specifies the private
//  signature key to use.
//
//  If any certificates and/or CRLs are to be included in the signed message,
//  then, the MsgCert and MsgCrl parameters need to be updated. If the
//  rgpSigningCerts are to be included, then, they must also be in the
//  rgpMsgCert array.
//
//  cbSize must be set to the sizeof(CRYPT_SIGN_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//
//  pvHashAuxInfo currently isn't used and must be set to NULL.
//
//  dwFlags normally is set to 0. However, if the encoded output
//  is to be a CMSG_SIGNED inner content of an outer cryptographic message,
//  such as a CMSG_ENVELOPED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG
//  should be set. If not set, then it would be encoded as an inner content
//  type of CMSG_DATA.
//
//  dwInnerContentType is normally set to 0. It needs to be set if the
//  ToBeSigned input is the encoded output of another cryptographic
//  message, such as, an CMSG_ENVELOPED. When set, it's one of the cryptographic
//  message types, for example, CMSG_ENVELOPED.
//
//  If the inner content of a nested cryptographic message is data (CMSG_DATA
//  the default), then, neither dwFlags or dwInnerContentType need to be set.
//
//  For CMS messages, CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG may be
//  set to encapsulate nonData inner content within an OCTET STRING.
//
//  For CMS messages, CRYPT_MESSAGE_KEYID_SIGNER_FLAG may be set to identify
//  signers by their Key Identifier and not their Issuer and Serial Number.
//
//  The CRYPT_MESSAGE_SILENT_KEYSET_FLAG can be set to suppress any UI by the
//  CSP. See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  If HashEncryptionAlgorithm is present and not NULL its used instead of
//  the SigningCert's PublicKeyInfo.Algorithm.
//
//  Note, for RSA, the hash encryption algorithm is normally the same as
//  the public key algorithm. For DSA, the hash encryption algorithm is
//  normally a DSS signature algorithm.
//
//  pvHashEncryptionAuxInfo currently isn't used and must be set to NULL if
//  present in the data structure.
//--------------------------------------------------------------------------
typedef struct _CRYPT_SIGN_MESSAGE_PARA {
    DWORD                       cbSize;
    DWORD                       dwMsgEncodingType;
    PCCERT_CONTEXT              pSigningCert;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    void                        *pvHashAuxInfo;
    DWORD                       cMsgCert;
    PCCERT_CONTEXT              *rgpMsgCert;
    DWORD                       cMsgCrl;
    PCCRL_CONTEXT               *rgpMsgCrl;
    DWORD                       cAuthAttr;
    PCRYPT_ATTRIBUTE            rgAuthAttr;
    DWORD                       cUnauthAttr;
    PCRYPT_ATTRIBUTE            rgUnauthAttr;
    DWORD                       dwFlags;
    DWORD                       dwInnerContentType;

#ifdef CRYPT_SIGN_MESSAGE_PARA_HAS_CMS_FIELDS
    // This is also referred to as the SignatureAlgorithm
    CRYPT_ALGORITHM_IDENTIFIER  HashEncryptionAlgorithm;
    void                        *pvHashEncryptionAuxInfo;
#endif
} CRYPT_SIGN_MESSAGE_PARA, *PCRYPT_SIGN_MESSAGE_PARA;

#define CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG         0x00000001

// When set, nonData type inner content is encapsulated within an
// OCTET STRING
#define CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG 0x00000002

// When set, signers are identified by their Key Identifier and not
// their Issuer and Serial Number.
#define CRYPT_MESSAGE_KEYID_SIGNER_FLAG             0x00000004

// When set, suppresses any UI by the CSP.
// See CryptAcquireContext's CRYPT_SILENT flag for more details.
#define CRYPT_MESSAGE_SILENT_KEYSET_FLAG            0x00000040

//+-------------------------------------------------------------------------
//  The CRYPT_VERIFY_MESSAGE_PARA are used to verify signed messages.
//
//  hCryptProv is used to do hashing and signature verification.
//
//  The dwCertEncodingType specifies the encoding type of the certificates
//  and/or CRLs in the message.
//
//  pfnGetSignerCertificate is called to get and verify the message signer's
//  certificate.
//
//  cbSize must be set to the sizeof(CRYPT_VERIFY_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//--------------------------------------------------------------------------
typedef struct _CRYPT_VERIFY_MESSAGE_PARA {
    DWORD                               cbSize;
    DWORD                               dwMsgAndCertEncodingType;
    HCRYPTPROV_LEGACY                   hCryptProv;
    PFN_CRYPT_GET_SIGNER_CERTIFICATE    pfnGetSignerCertificate;
    void                                *pvGetArg;
} CRYPT_VERIFY_MESSAGE_PARA, *PCRYPT_VERIFY_MESSAGE_PARA;

//+-------------------------------------------------------------------------
//  The CRYPT_ENCRYPT_MESSAGE_PARA are used for encrypting messages.
//
//  hCryptProv is used to do content encryption, recipient key
//  encryption, and recipient key export. Its private key
//  isn't used.
//
//  Currently, pvEncryptionAuxInfo is only defined for RC2 or RC4 encryption
//  algorithms. Otherwise, its not used and must be set to NULL.
//  See CMSG_RC2_AUX_INFO for the RC2 encryption algorithms.
//  See CMSG_RC4_AUX_INFO for the RC4 encryption algorithms.
//
//  To enable SP3 compatible encryption, pvEncryptionAuxInfo should point to
//  a CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
//
//  cbSize must be set to the sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//
//  dwFlags normally is set to 0. However, if the encoded output
//  is to be a CMSG_ENVELOPED inner content of an outer cryptographic message,
//  such as a CMSG_SIGNED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG
//  should be set. If not set, then it would be encoded as an inner content
//  type of CMSG_DATA.
//
//  dwInnerContentType is normally set to 0. It needs to be set if the
//  ToBeEncrypted input is the encoded output of another cryptographic
//  message, such as, an CMSG_SIGNED. When set, it's one of the cryptographic
//  message types, for example, CMSG_SIGNED.
//
//  If the inner content of a nested cryptographic message is data (CMSG_DATA
//  the default), then, neither dwFlags or dwInnerContentType need to be set.
//
//  For CMS messages, CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG may be
//  set to encapsulate nonData inner content within an OCTET STRING before
//  encrypting.
//
//  For CMS messages, CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG may be set to identify
//  recipients by their Key Identifier and not their Issuer and Serial Number.
//--------------------------------------------------------------------------
typedef struct _CRYPT_ENCRYPT_MESSAGE_PARA {
    DWORD                       cbSize;
    DWORD                       dwMsgEncodingType;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    void                        *pvEncryptionAuxInfo;
    DWORD                       dwFlags;
    DWORD                       dwInnerContentType;
} CRYPT_ENCRYPT_MESSAGE_PARA, *PCRYPT_ENCRYPT_MESSAGE_PARA;

// When set, recipients are identified by their Key Identifier and not
// their Issuer and Serial Number.
#define CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG          0x4

//+-------------------------------------------------------------------------
//  The CRYPT_DECRYPT_MESSAGE_PARA are used for decrypting messages.
//
//  The CertContext to use for decrypting a message is obtained from one
//  of the specified cert stores. An encrypted message can have one or
//  more recipients. The recipients are identified by their CertId (Issuer
//  and SerialNumber). The cert stores are searched to find the CertContext
//  corresponding to the CertId.
//
//  For CMS, the recipients may also be identified by their KeyId.
//  CMS also allows Key Agreement (Diffie Hellman) in addition to
//  Key Transport (RSA) recipients.
//
//  Only CertContexts in the store with either
//  the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID set
//  can be used. Either property specifies the private exchange key to use.
//
//  cbSize must be set to the sizeof(CRYPT_DECRYPT_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//--------------------------------------------------------------------------
typedef struct _CRYPT_DECRYPT_MESSAGE_PARA {
    DWORD                   cbSize;
    DWORD                   dwMsgAndCertEncodingType;
    DWORD                   cCertStore;
    HCERTSTORE              *rghCertStore;

#ifdef CRYPT_DECRYPT_MESSAGE_PARA_HAS_EXTRA_FIELDS
// The above defined, CRYPT_MESSAGE_SILENT_KEYSET_FLAG, can be set to
// suppress UI by the CSP.  See CryptAcquireContext's CRYPT_SILENT
// flag for more details.

    DWORD                   dwFlags;
#endif

} CRYPT_DECRYPT_MESSAGE_PARA, *PCRYPT_DECRYPT_MESSAGE_PARA;

//+-------------------------------------------------------------------------
//  The CRYPT_HASH_MESSAGE_PARA are used for hashing or unhashing
//  messages.
//
//  hCryptProv is used to compute the hash.
//
//  pvHashAuxInfo currently isn't used and must be set to NULL.
//
//  cbSize must be set to the sizeof(CRYPT_HASH_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//--------------------------------------------------------------------------
typedef struct _CRYPT_HASH_MESSAGE_PARA {
    DWORD                       cbSize;
    DWORD                       dwMsgEncodingType;
    HCRYPTPROV_LEGACY           hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    void                        *pvHashAuxInfo;
} CRYPT_HASH_MESSAGE_PARA, *PCRYPT_HASH_MESSAGE_PARA;


//+-------------------------------------------------------------------------
//  The CRYPT_KEY_SIGN_MESSAGE_PARA are used for signing messages until a
//  certificate has been created for the signature key.
//
//  pvHashAuxInfo currently isn't used and must be set to NULL.
//
//  If PubKeyAlgorithm isn't set, defaults to szOID_RSA_RSA.
//
//  cbSize must be set to the sizeof(CRYPT_KEY_SIGN_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//--------------------------------------------------------------------------
typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA {
    DWORD                       cbSize;
    DWORD                       dwMsgAndCertEncodingType;

    // NCryptIsKeyHandle() is called to determine the union choice.
    union {
        HCRYPTPROV                  hCryptProv;
        NCRYPT_KEY_HANDLE           hNCryptKey;
    };

    // not applicable for hNCryptKey choice
    DWORD                       dwKeySpec;

    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    void                        *pvHashAuxInfo;
    // This is also referred to as the SignatureAlgorithm
    CRYPT_ALGORITHM_IDENTIFIER  PubKeyAlgorithm;
} CRYPT_KEY_SIGN_MESSAGE_PARA, *PCRYPT_KEY_SIGN_MESSAGE_PARA;

//+-------------------------------------------------------------------------
//  The CRYPT_KEY_VERIFY_MESSAGE_PARA are used to verify signed messages without
//  a certificate for the signer.
//
//  Normally used until a certificate has been created for the key.
//
//  hCryptProv is used to do hashing and signature verification.
//
//  cbSize must be set to the sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA) or else
//  LastError will be updated with E_INVALIDARG.
//--------------------------------------------------------------------------
typedef struct _CRYPT_KEY_VERIFY_MESSAGE_PARA {
    DWORD                   cbSize;
    DWORD                   dwMsgEncodingType;
    HCRYPTPROV_LEGACY       hCryptProv;
} CRYPT_KEY_VERIFY_MESSAGE_PARA, *PCRYPT_KEY_VERIFY_MESSAGE_PARA;


//+-------------------------------------------------------------------------
//  Sign the message.
//
//  If fDetachedSignature is TRUE, the "to be signed" content isn't included
//  in the encoded signed blob.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSignMessage(
    __in PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    __in BOOL fDetachedSignature,
    __in DWORD cToBeSigned,
    __in_ecount_opt(cToBeSigned) const BYTE *rgpbToBeSigned[],
    __in_ecount(cToBeSigned) DWORD rgcbToBeSigned[],
    __out_bcount_part_opt(*pcbSignedBlob, *pcbSignedBlob) BYTE *pbSignedBlob,
    __inout DWORD *pcbSignedBlob
    );

//+-------------------------------------------------------------------------
//  Verify a signed message.
//
//  If pbDecoded == NULL, then, *pcbDecoded is implicitly set to 0 on input.
//  For *pcbDecoded == 0 && ppSignerCert == NULL on input, the signer isn't
//  verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  pVerifyPara's pfnGetSignerCertificate is called to get the signer's
//  certificate.
//
//  For a verified signer and message, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  pcbDecoded can be NULL, indicating the caller isn't interested in getting
//  the decoded content. Furthermore, if the message doesn't contain any
//  content or signers, then, pcbDecoded must be set to NULL, to allow the
//  pVerifyPara->pfnGetCertificate to be called. Normally, this would be
//  the case when the signed message contains only certficates and CRLs.
//  If pcbDecoded is NULL and the message doesn't have the indicated signer,
//  pfnGetCertificate is called with pSignerId set to NULL.
//
//  If the message doesn't contain any signers || dwSignerIndex > message's
//  SignerCount, then, an error is returned with LastError set to
//  CRYPT_E_NO_SIGNER. Also, for CRYPT_E_NO_SIGNER, pfnGetSignerCertificate
//  is still called with pSignerId set to NULL.
//
//  Note, an alternative way to get the certificates and CRLs from a
//  signed message is to call CryptGetMessageCertificates.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptVerifyMessageSignature(
    __in PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    __in DWORD dwSignerIndex,
    __in_bcount(cbSignedBlob) const BYTE *pbSignedBlob,
    __in DWORD cbSignedBlob,
    __out_bcount_part_opt(*pcbDecoded, *pcbDecoded) BYTE *pbDecoded,
    __inout_opt DWORD *pcbDecoded,
    __deref_opt_out_opt PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Returns the count of signers in the signed message. For no signers, returns
//  0. For an error returns -1 with LastError updated accordingly.
//--------------------------------------------------------------------------
WINCRYPT32API
LONG
WINAPI
CryptGetMessageSignerCount(
    __in DWORD dwMsgEncodingType,
    __in_bcount(cbSignedBlob) const BYTE *pbSignedBlob,
    __in DWORD cbSignedBlob
    );

//+-------------------------------------------------------------------------
//  Returns the cert store containing the message's certs and CRLs.
//  For an error, returns NULL with LastError updated.
//--------------------------------------------------------------------------
WINCRYPT32API
HCERTSTORE
WINAPI
CryptGetMessageCertificates(
    __in DWORD dwMsgAndCertEncodingType,
    __in_opt HCRYPTPROV_LEGACY hCryptProv,           // passed to CertOpenStore
    __in DWORD dwFlags,                   // passed to CertOpenStore
    __in_bcount(cbSignedBlob) const BYTE *pbSignedBlob,
    __in DWORD cbSignedBlob
    );

//+-------------------------------------------------------------------------
//  Verify a signed message containing detached signature(s).
//  The "to be signed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageSignature.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptVerifyDetachedMessageSignature(
    __in PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    __in DWORD dwSignerIndex,
    __in_bcount(cbDetachedSignBlob) const BYTE *pbDetachedSignBlob,
    __in DWORD cbDetachedSignBlob,
    __in DWORD cToBeSigned,
    __in_ecount(cToBeSigned) const BYTE *rgpbToBeSigned[],
    __in_ecount(cToBeSigned) DWORD rgcbToBeSigned[],
    __deref_opt_out_opt PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Encrypts the message for the recipient(s).
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptEncryptMessage(
    __in PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    __in DWORD cRecipientCert,
    __in_ecount(cRecipientCert) PCCERT_CONTEXT rgpRecipientCert[],
    __in_bcount_opt(cbToBeEncrypted) const BYTE *pbToBeEncrypted,
    __in DWORD cbToBeEncrypted,
    __out_bcount_part_opt(*pcbEncryptedBlob, *pcbEncryptedBlob) BYTE *pbEncryptedBlob,
    __inout DWORD *pcbEncryptedBlob
    );

//+-------------------------------------------------------------------------
//  Decrypts the message.
//
//  If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input.
//  For *pcbDecrypted == 0 && ppXchgCert == NULL on input, the message isn't
//  decrypted.
//
//  For a successfully decrypted message, *ppXchgCert is updated
//  with the CertContext used to decrypt. It must be freed by calling
//  CertStoreFreeCert. Otherwise, *ppXchgCert is set to NULL.
//
//  ppXchgCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext used to decrypt.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptDecryptMessage(
    __in PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    __in_bcount(cbEncryptedBlob) const BYTE *pbEncryptedBlob,
    __in DWORD cbEncryptedBlob,
    __out_bcount_part_opt(*pcbDecrypted, *pcbDecrypted) BYTE *pbDecrypted,
    __inout_opt DWORD *pcbDecrypted,
    __deref_opt_out_opt PCCERT_CONTEXT *ppXchgCert
    );

//+-------------------------------------------------------------------------
//  Sign the message and encrypt for the recipient(s). Does a CryptSignMessage
//  followed with a CryptEncryptMessage.
//
//  Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED
//  inside of an CMSG_ENVELOPED.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSignAndEncryptMessage(
    __in PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    __in PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    __in DWORD cRecipientCert,
    __in_ecount(cRecipientCert) PCCERT_CONTEXT rgpRecipientCert[],
    __in_bcount(cbToBeSignedAndEncrypted) const BYTE *pbToBeSignedAndEncrypted,
    __in DWORD cbToBeSignedAndEncrypted,
    __out_bcount_part_opt(*pcbSignedAndEncryptedBlob, *pcbSignedAndEncryptedBlob) BYTE *pbSignedAndEncryptedBlob,
    __inout DWORD *pcbSignedAndEncryptedBlob
    );

//+-------------------------------------------------------------------------
//  Decrypts the message and verifies the signer. Does a CryptDecryptMessage
//  followed with a CryptVerifyMessageSignature.
//
//  If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input.
//  For *pcbDecrypted == 0 && ppSignerCert == NULL on input, the signer isn't
//  verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  The pVerifyPara's VerifySignerPolicy is called to verify the signer's
//  certificate.
//
//  For a successfully decrypted and verified message, *ppXchgCert and
//  *ppSignerCert are updated. They must be freed by calling
//  CertStoreFreeCert. Otherwise, they are set to NULL.
//
//  ppXchgCert and/or ppSignerCert can be NULL, indicating the
//  caller isn't interested in getting the CertContext.
//
//  Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED
//  inside of an CMSG_ENVELOPED.
//
//  The message always needs to be decrypted to allow access to the
//  signed message. Therefore, if ppXchgCert != NULL, its always updated.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptDecryptAndVerifyMessageSignature(
    __in PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    __in PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    __in DWORD dwSignerIndex,
    __in_bcount(cbEncryptedBlob) const BYTE *pbEncryptedBlob,
    __in DWORD cbEncryptedBlob,
    __out_bcount_part_opt(*pcbDecrypted, *pcbDecrypted) BYTE *pbDecrypted,
    __inout_opt DWORD *pcbDecrypted,
    __deref_opt_out_opt PCCERT_CONTEXT *ppXchgCert,
    __deref_opt_out_opt PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Decodes a cryptographic message which may be one of the following types:
//    CMSG_DATA
//    CMSG_SIGNED
//    CMSG_ENVELOPED
//    CMSG_SIGNED_AND_ENVELOPED
//    CMSG_HASHED
//
//  dwMsgTypeFlags specifies the set of allowable messages. For example, to
//  decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to:
//      CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG.
//
//  dwProvInnerContentType is only applicable when processing nested
//  crytographic messages. When processing an outer crytographic message
//  it must be set to 0. When decoding a nested cryptographic message
//  its the dwInnerContentType returned by a previous CryptDecodeMessage
//  of the outer message. The InnerContentType can be any of the CMSG types,
//  for example, CMSG_DATA, CMSG_SIGNED, ...
//
//  The optional *pdwMsgType is updated with the type of message.
//
//  The optional *pdwInnerContentType is updated with the type of the inner
//  message. Unless there is cryptographic message nesting, CMSG_DATA
//  is returned.
//
//  For CMSG_DATA: returns decoded content.
//  For CMSG_SIGNED: same as CryptVerifyMessageSignature.
//  For CMSG_ENVELOPED: same as CryptDecryptMessage.
//  For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus
//      CryptVerifyMessageSignature.
//  For CMSG_HASHED: verifies the hash and returns decoded content.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptDecodeMessage(
    __in DWORD dwMsgTypeFlags,
    __in_opt PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    __in_opt PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    __in DWORD dwSignerIndex,
    __in_bcount(cbEncodedBlob) const BYTE *pbEncodedBlob,
    __in DWORD cbEncodedBlob,
    __in DWORD dwPrevInnerContentType,
    __out_opt DWORD *pdwMsgType,
    __out_opt DWORD *pdwInnerContentType,
    __out_bcount_part_opt(*pcbDecoded, *pcbDecoded) BYTE *pbDecoded,
    __inout_opt DWORD *pcbDecoded,
    __deref_opt_out_opt PCCERT_CONTEXT *ppXchgCert,
    __deref_opt_out_opt PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Hash the message.
//
//  If fDetachedHash is TRUE, only the ComputedHash is encoded in the
//  pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash
//  are encoded.
//
//  pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller
//  isn't interested in getting the output.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptHashMessage(
    __in PCRYPT_HASH_MESSAGE_PARA pHashPara,
    __in BOOL fDetachedHash,
    __in DWORD cToBeHashed,
    __in_ecount(cToBeHashed) const BYTE *rgpbToBeHashed[],
    __in_ecount(cToBeHashed) DWORD rgcbToBeHashed[],
    __out_bcount_part_opt(*pcbHashedBlob, *pcbHashedBlob) BYTE *pbHashedBlob,
    __inout_opt DWORD *pcbHashedBlob,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout_opt DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Verify a hashed message.
//
//  pcbToBeHashed or pcbComputedHash can be NULL,
//  indicating the caller isn't interested in getting the output.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptVerifyMessageHash(
    __in PCRYPT_HASH_MESSAGE_PARA pHashPara,
    __in_bcount(cbHashedBlob) BYTE *pbHashedBlob,
    __in DWORD cbHashedBlob,
    __out_bcount_part_opt(*pcbToBeHashed, *pcbToBeHashed) BYTE *pbToBeHashed,
    __inout_opt DWORD *pcbToBeHashed,
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout_opt DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Verify a hashed message containing a detached hash.
//  The "to be hashed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageHash.
//
//  pcbComputedHash can be NULL, indicating the caller isn't interested
//  in getting the output.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptVerifyDetachedMessageHash(
    __in PCRYPT_HASH_MESSAGE_PARA pHashPara,
    __in_bcount(cbDetachedHashBlob) BYTE *pbDetachedHashBlob,
    __in DWORD cbDetachedHashBlob,
    __in DWORD cToBeHashed,
    __in_ecount(cToBeHashed) const BYTE *rgpbToBeHashed[],
    __in_ecount(cToBeHashed) DWORD rgcbToBeHashed[],
    __out_bcount_part_opt(*pcbComputedHash, *pcbComputedHash) BYTE *pbComputedHash,
    __inout_opt DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Sign the message using the provider's private key specified in the
//  parameters. A dummy SignerId is created and stored in the message.
//
//  Normally used until a certificate has been created for the key.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSignMessageWithKey(
    __in PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara,
    __in_bcount(cbToBeSigned) const BYTE *pbToBeSigned,
    __in DWORD cbToBeSigned,
    __out_bcount_part_opt(*pcbSignedBlob, *pcbSignedBlob) BYTE *pbSignedBlob,
    __inout DWORD *pcbSignedBlob
    );

//+-------------------------------------------------------------------------
//  Verify a signed message using the specified public key info.
//
//  Normally called by a CA until it has created a certificate for the
//  key.
//
//  pPublicKeyInfo contains the public key to use to verify the signed
//  message. If NULL, the signature isn't verified (for instance, the decoded
//  content may contain the PublicKeyInfo).
//
//  pcbDecoded can be NULL, indicating the caller isn't interested
//  in getting the decoded content.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptVerifyMessageSignatureWithKey(
    __in PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara,
    __in_opt PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    __in_bcount(cbSignedBlob) const BYTE *pbSignedBlob,
    __in DWORD cbSignedBlob,
    __out_bcount_part_opt(*pcbDecoded, *pcbDecoded) BYTE *pbDecoded,
    __inout_opt DWORD *pcbDecoded
    );


//+=========================================================================
//  System Certificate Store Data Structures and APIs
//==========================================================================


//+-------------------------------------------------------------------------
//  Get a system certificate store based on a subsystem protocol.
//
//  Current examples of subsystems protocols are:
//      "MY"    Cert Store hold certs with associated Private Keys
//      "CA"    Certifying Authority certs
//      "ROOT"  Root Certs
//      "SPC"   Software publisher certs
//
//
//  If hProv is NULL the default provider "1" is opened for you.
//  When the store is closed the provider is release. Otherwise
//  if hProv is not NULL, no provider is created or released.
//
//  The returned Cert Store can be searched for an appropriate Cert
//  using the Cert Store API's (see certstor.h)
//
//  When done, the cert store should be closed using CertStoreClose
//--------------------------------------------------------------------------


WINCRYPT32API
HCERTSTORE
WINAPI
CertOpenSystemStoreA(
    __in_opt HCRYPTPROV_LEGACY      hProv,
    __in LPCSTR            szSubsystemProtocol
    );

WINCRYPT32API
HCERTSTORE
WINAPI
CertOpenSystemStoreW(
    __in_opt HCRYPTPROV_LEGACY      hProv,
    __in LPCWSTR            szSubsystemProtocol
    );

#ifdef UNICODE
#define CertOpenSystemStore  CertOpenSystemStoreW
#else
#define CertOpenSystemStore  CertOpenSystemStoreA
#endif // !UNICODE

WINCRYPT32API
BOOL
WINAPI
CertAddEncodedCertificateToSystemStoreA(
    __in LPCSTR            szCertStoreName,
    __in_bcount(cbCertEncoded) const BYTE *    pbCertEncoded,
    __in DWORD           cbCertEncoded
    );
WINCRYPT32API
BOOL
WINAPI
CertAddEncodedCertificateToSystemStoreW(
    __in LPCWSTR            szCertStoreName,
    __in_bcount(cbCertEncoded) const BYTE *    pbCertEncoded,
    __in DWORD           cbCertEncoded
    );
#ifdef UNICODE
#define CertAddEncodedCertificateToSystemStore  CertAddEncodedCertificateToSystemStoreW
#else
#define CertAddEncodedCertificateToSystemStore  CertAddEncodedCertificateToSystemStoreA
#endif // !UNICODE


//+-------------------------------------------------------------------------
//  Find all certificate chains tying the given issuer name to any certificate
//  that the current user has a private key for.
//
//  If no certificate chain is found, FALSE is returned with LastError set
//  to CRYPT_E_NOT_FOUND and the counts zeroed.
//
//  IE 3.0 ASSUMPTION:
//   The client certificates are in the "My" system store. The issuer
//   cerificates may be in the "Root", "CA" or "My" system stores.
//--------------------------------------------------------------------------
typedef struct _CERT_CHAIN {
    DWORD                   cCerts;     // number of certs in chain
    PCERT_BLOB              certs;      // pointer to array of cert chain blobs
                                        // representing the certs
    CRYPT_KEY_PROV_INFO     keyLocatorInfo; // key locator for cert
} CERT_CHAIN, *PCERT_CHAIN;


// WINCRYPT32API    This is not exported by crypt32, it is exported by softpub
HRESULT
WINAPI
FindCertsByIssuer(
    __out_bcount_part_opt(*pcbCertChains, *pcbCertChains) PCERT_CHAIN pCertChains,
    __inout DWORD *pcbCertChains,
    __out DWORD *pcCertChains,        // count of certificates chains returned
    __in_bcount_opt(cbEncodedIssuerName) BYTE* pbEncodedIssuerName,   // DER encoded issuer name
    __in DWORD cbEncodedIssuerName,   // count in bytes of encoded issuer name
    __in_opt LPCWSTR pwszPurpose,     // "ClientAuth" or "CodeSigning"
    __in DWORD dwKeySpec              // only return signers supporting this
                                      // keyspec
    );

//-------------------------------------------------------------------------
//
//  CryptQueryObject takes a CERT_BLOB or a file name and returns the
//  information about the content in the blob or in the file.
//
//  Parameters:
//  INPUT   dwObjectType:
//                       Indicate the type of the object.  Should be one of the
//                       following:
//                          CERT_QUERY_OBJECT_FILE
//                          CERT_QUERY_OBJECT_BLOB
//
//  INPUT   pvObject:
//                        If dwObjectType == CERT_QUERY_OBJECT_FILE, it is a
//                        LPWSTR, that is, the pointer to a wchar file name
//                        if dwObjectType == CERT_QUERY_OBJECT_BLOB, it is a
//                        PCERT_BLOB, that is, a pointer to a CERT_BLOB
//
//  INPUT   dwExpectedContentTypeFlags:
//                        Indicate the expected contenet type.
//                        Can be one of the following:
//                              CERT_QUERY_CONTENT_FLAG_ALL  (the content can be any type)
//                              CERT_QUERY_CONTENT_FLAG_CERT
//                              CERT_QUERY_CONTENT_FLAG_CTL
//                              CERT_QUERY_CONTENT_FLAG_CRL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_FLAG_PKCS10
//                              CERT_QUERY_CONTENT_FLAG_PFX
//                              CERT_QUERY_CONTENT_FLAG_CERT_PAIR
//                              CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD
//
//  INPUT   dwExpectedFormatTypeFlags:
//                        Indicate the expected format type.
//                        Can be one of the following:
//                              CERT_QUERY_FORMAT_FLAG_ALL (the content can be any format)
//                              CERT_QUERY_FORMAT_FLAG_BINARY
//                              CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED
//
//
//  INPUT   dwFlags
//                        Reserved flag.  Should always set to 0
//
//  OUTPUT  pdwMsgAndCertEncodingType
//                        Optional output.  If NULL != pdwMsgAndCertEncodingType,
//                        it contains the encoding type of the content as any
//                        combination of the following:
//                              X509_ASN_ENCODING
//                              PKCS_7_ASN_ENCODING
//
//  OUTPUT  pdwContentType
//                        Optional output.  If NULL!=pdwContentType, it contains
//                        the content type as one of the the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_PKCS10
//                              CERT_QUERY_CONTENT_PFX
//                              CERT_QUERY_CONTENT_CERT_PAIR
//                              CERT_QUERY_CONTENT_PFX_AND_LOAD
//
//  OUTPUT  pdwFormatType
//                        Optional output.  If NULL !=pdwFormatType, it
//                        contains the format type of the content as one of the
//                        following:
//                              CERT_QUERY_FORMAT_BINARY
//                              CERT_QUERY_FORMAT_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED
//
//
//  OUTPUT  phCertStore
//                        Optional output.  If NULL !=phStore,
//                        it contains a cert store that includes all of certificates,
//                        CRL, and CTL in the object if the object content type is
//                        one of the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_CERT_PAIR
//
//                       Caller should free *phCertStore via CertCloseStore.
//
//
//  OUTPUT  phMsg        Optional output.  If NULL != phMsg,
//                        it contains a handle to a opened message if
//                        the content type is one of the following:
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//
//                       Caller should free *phMsg via CryptMsgClose.
//
//  OUTPUT pContext     Optional output.  If NULL != pContext,
//                      it contains either a PCCERT_CONTEXT or PCCRL_CONTEXT,
//                      or PCCTL_CONTEXT based on the content type.
//
//                      If the content type is CERT_QUERY_CONTENT_CERT or
//                      CERT_QUERY_CONTENT_SERIALIZED_CERT, it is a PCCERT_CONTEXT;
//                      Caller should free the pContext via CertFreeCertificateContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CRL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CRL, it is a PCCRL_CONTEXT;
//                      Caller should free the pContext via CertFreeCRLContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CTL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CTL, it is a PCCTL_CONTEXT;
//                      Caller should free the pContext via CertFreeCTLContext.
//
//  If the *pbObject is of type CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX, CryptQueryObject
//  will not return anything in *phCertstore, *phMsg, or *ppvContext.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptQueryObject(
    __in DWORD                    dwObjectType,
    __in const void               *pvObject,
    __in DWORD                    dwExpectedContentTypeFlags,
    __in DWORD                    dwExpectedFormatTypeFlags,
    __in DWORD                    dwFlags,
    __out_opt DWORD               *pdwMsgAndCertEncodingType,
    __out_opt DWORD               *pdwContentType,
    __out_opt DWORD               *pdwFormatType,
    __out_opt HCERTSTORE          *phCertStore,
    __out_opt HCRYPTMSG           *phMsg,
    __deref_opt_out_opt const void **ppvContext
    );


//-------------------------------------------------------------------------
//dwObjectType for CryptQueryObject
//-------------------------------------------------------------------------
#define     CERT_QUERY_OBJECT_FILE         0x00000001
#define     CERT_QUERY_OBJECT_BLOB         0x00000002

//-------------------------------------------------------------------------
//dwContentType for CryptQueryObject
//-------------------------------------------------------------------------
//encoded single certificate
#define     CERT_QUERY_CONTENT_CERT                 1
//encoded single CTL
#define     CERT_QUERY_CONTENT_CTL                  2
//encoded single CRL
#define     CERT_QUERY_CONTENT_CRL                  3
//serialized store
#define     CERT_QUERY_CONTENT_SERIALIZED_STORE     4
//serialized single certificate
#define     CERT_QUERY_CONTENT_SERIALIZED_CERT      5
//serialized single CTL
#define     CERT_QUERY_CONTENT_SERIALIZED_CTL       6
//serialized single CRL
#define     CERT_QUERY_CONTENT_SERIALIZED_CRL       7
//a PKCS#7 signed message
#define     CERT_QUERY_CONTENT_PKCS7_SIGNED         8
//a PKCS#7 message, such as enveloped message.  But it is not a signed message,
#define     CERT_QUERY_CONTENT_PKCS7_UNSIGNED       9
//a PKCS7 signed message embedded in a file
#define     CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED   10
//an encoded PKCS#10
#define     CERT_QUERY_CONTENT_PKCS10               11
//an encoded PFX BLOB
#define     CERT_QUERY_CONTENT_PFX                  12
//an encoded CertificatePair (contains forward and/or reverse cross certs)
#define     CERT_QUERY_CONTENT_CERT_PAIR            13
//an encoded PFX BLOB, which was loaded to phCertStore
#define     CERT_QUERY_CONTENT_PFX_AND_LOAD         14


//-------------------------------------------------------------------------
//dwExpectedConentTypeFlags for CryptQueryObject
//-------------------------------------------------------------------------

//encoded single certificate
#define     CERT_QUERY_CONTENT_FLAG_CERT   \
                ( 1 << CERT_QUERY_CONTENT_CERT)

//encoded single CTL
#define     CERT_QUERY_CONTENT_FLAG_CTL   \
                ( 1 << CERT_QUERY_CONTENT_CTL)

//encoded single CRL
#define     CERT_QUERY_CONTENT_FLAG_CRL   \
                ( 1 << CERT_QUERY_CONTENT_CRL)

//serialized store
#define     CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE   \
                ( 1 << CERT_QUERY_CONTENT_SERIALIZED_STORE)

//serialized single certificate
#define     CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT   \
                ( 1 << CERT_QUERY_CONTENT_SERIALIZED_CERT)

//serialized single CTL
#define     CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL   \
                ( 1 << CERT_QUERY_CONTENT_SERIALIZED_CTL)

//serialized single CRL
#define     CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL   \
                ( 1 << CERT_QUERY_CONTENT_SERIALIZED_CRL)

//an encoded PKCS#7 signed message
#define     CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED   \
                ( 1 << CERT_QUERY_CONTENT_PKCS7_SIGNED)

//an encoded PKCS#7 message.  But it is not a signed message
#define     CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED   \
                ( 1 << CERT_QUERY_CONTENT_PKCS7_UNSIGNED)

//the content includes an embedded PKCS7 signed message
#define     CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED  \
                ( 1 << CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED)

//an encoded PKCS#10
#define     CERT_QUERY_CONTENT_FLAG_PKCS10   \
                ( 1 << CERT_QUERY_CONTENT_PKCS10)

//an encoded PFX BLOB
#define     CERT_QUERY_CONTENT_FLAG_PFX      \
                ( 1 << CERT_QUERY_CONTENT_PFX)

//an encoded CertificatePair (contains forward and/or reverse cross certs)
#define     CERT_QUERY_CONTENT_FLAG_CERT_PAIR   \
                ( 1 << CERT_QUERY_CONTENT_CERT_PAIR)

//an encoded PFX BLOB, and we do want to load it (not included in
//CERT_QUERY_CONTENT_FLAG_ALL)
#define     CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD    \
                ( 1 << CERT_QUERY_CONTENT_PFX_AND_LOAD)

//content can be any type
#define     CERT_QUERY_CONTENT_FLAG_ALL                         \
              ( CERT_QUERY_CONTENT_FLAG_CERT |                  \
                CERT_QUERY_CONTENT_FLAG_CTL  |                  \
                CERT_QUERY_CONTENT_FLAG_CRL  |                  \
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |      \
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT  |      \
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL   |      \
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL   |      \
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED     |      \
                CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED   |      \
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED |    \
                CERT_QUERY_CONTENT_FLAG_PKCS10                     |    \
                CERT_QUERY_CONTENT_FLAG_PFX                |    \
                CERT_QUERY_CONTENT_FLAG_CERT_PAIR )


//-------------------------------------------------------------------------
//dwFormatType for CryptQueryObject
//-------------------------------------------------------------------------
//the content is in binary format
#define     CERT_QUERY_FORMAT_BINARY                1

//the content is base64 encoded
#define     CERT_QUERY_FORMAT_BASE64_ENCODED        2

//the content is ascii hex encoded with "{ASN}" prefix
#define     CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED 3
//-------------------------------------------------------------------------
//dwExpectedFormatTypeFlags for CryptQueryObject
//-------------------------------------------------------------------------
//the content is in binary format
#define     CERT_QUERY_FORMAT_FLAG_BINARY         \
                ( 1 << CERT_QUERY_FORMAT_BINARY)

//the content is base64 encoded
#define     CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED \
                ( 1 << CERT_QUERY_FORMAT_BASE64_ENCODED)

//the content is ascii hex encoded with "{ASN}" prefix
#define     CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED \
                ( 1 << CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED)

//the content can be of any format
#define     CERT_QUERY_FORMAT_FLAG_ALL              \
          ( CERT_QUERY_FORMAT_FLAG_BINARY   |       \
            CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED | \
            CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED )



//
// Crypt32 Memory Management Routines.  All Crypt32 API which return allocated
// buffers will do so via CryptMemAlloc, CryptMemRealloc.  Clients can free
// those buffers using CryptMemFree.  Also included is CryptMemSize
//

WINCRYPT32API
LPVOID
WINAPI
CryptMemAlloc (
    __in ULONG cbSize
    );

WINCRYPT32API
LPVOID
WINAPI
CryptMemRealloc (
    __in_opt LPVOID pv,
    __in ULONG cbSize
    );

WINCRYPT32API
VOID
WINAPI
CryptMemFree (
    __in_opt LPVOID pv
    );

//
// Crypt32 Asynchronous Parameter Management Routines.  All Crypt32 API which
// expose asynchronous mode operation use a Crypt32 Async Handle to pass
// around information about the operation e.g. callback routines.  The
// following API are used for manipulation of the async handle
//

// Following functions were never used. If called, will fail with LastError
// set to ERROR_CALL_NOT_IMPLEMENTED.

typedef HANDLE HCRYPTASYNC, *PHCRYPTASYNC;

typedef VOID (WINAPI *PFN_CRYPT_ASYNC_PARAM_FREE_FUNC) (
    __in LPSTR pszParamOid,
    __in LPVOID pvParam
    );

WINCRYPT32API
BOOL
WINAPI
CryptCreateAsyncHandle (
    __in DWORD dwFlags,
    __out PHCRYPTASYNC phAsync
    );

WINCRYPT32API
BOOL
WINAPI
CryptSetAsyncParam (
    __in HCRYPTASYNC hAsync,
    __in LPSTR pszParamOid,
    __in_opt LPVOID pvParam,
    __callback PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
    );

WINCRYPT32API
BOOL
WINAPI
CryptGetAsyncParam (
    __in HCRYPTASYNC hAsync,
    __in LPSTR pszParamOid,
    __deref_opt_out_opt LPVOID* ppvParam,
    __deref_opt_out_opt __callback  PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
    );

WINCRYPT32API
BOOL
WINAPI
CryptCloseAsyncHandle (
    __in_opt HCRYPTASYNC hAsync
    );

//
// Crypt32 Remote Object Retrieval Routines.  This API allows retrieval of
// remote PKI objects where the location is given by an URL.  The remote
// object retrieval manager exposes two provider models.  One is the "Scheme
// Provider" model which allows for installable protocol providers as defined
// by the URL scheme e.g. ldap, http, ftp.  The scheme provider entry point is
// the same as the CryptRetrieveObjectByUrl however the *ppvObject returned
// is ALWAYS a counted array of encoded bits (one per object retrieved).  The
// second provider model is the "Context Provider" model which allows for
// installable creators of CAPI2 context handles (objects) based on the
// retrieved encoded bits.  These are dispatched based on the object OID given
// in the call to CryptRetrieveObjectByUrl.
//

typedef struct _CRYPT_BLOB_ARRAY {
    DWORD            cBlob;
    PCRYPT_DATA_BLOB rgBlob;
} CRYPT_BLOB_ARRAY, *PCRYPT_BLOB_ARRAY;

typedef struct _CRYPT_CREDENTIALS {
    DWORD  cbSize;
    LPCSTR pszCredentialsOid;
    LPVOID pvCredentials;
} CRYPT_CREDENTIALS, *PCRYPT_CREDENTIALS;

#define CREDENTIAL_OID_PASSWORD_CREDENTIALS_A ((LPCSTR)1)
#define CREDENTIAL_OID_PASSWORD_CREDENTIALS_W ((LPCSTR)2)

#ifdef UNICODE
#define CREDENTIAL_OID_PASSWORD_CREDENTIALS CREDENTIAL_OID_PASSWORD_CREDENTIALS_W
#else
#define CREDENTIAL_OID_PASSWORD_CREDENTIALS CREDENTIAL_OID_PASSWORD_CREDENTIALS_A
#endif //UNICODE

typedef struct _CRYPT_PASSWORD_CREDENTIALSA {
    DWORD   cbSize;
    LPSTR   pszUsername;
    LPSTR   pszPassword;
} CRYPT_PASSWORD_CREDENTIALSA, *PCRYPT_PASSWORD_CREDENTIALSA;
typedef struct _CRYPT_PASSWORD_CREDENTIALSW {
    DWORD   cbSize;
    LPWSTR  pszUsername;
    LPWSTR  pszPassword;
} CRYPT_PASSWORD_CREDENTIALSW, *PCRYPT_PASSWORD_CREDENTIALSW;
#ifdef UNICODE
typedef CRYPT_PASSWORD_CREDENTIALSW CRYPT_PASSWORD_CREDENTIALS;
typedef PCRYPT_PASSWORD_CREDENTIALSW PCRYPT_PASSWORD_CREDENTIALS;
#else
typedef CRYPT_PASSWORD_CREDENTIALSA CRYPT_PASSWORD_CREDENTIALS;
typedef PCRYPT_PASSWORD_CREDENTIALSA PCRYPT_PASSWORD_CREDENTIALS;
#endif // UNICODE

//
// Scheme Provider Signatures
//

// The following is obsolete and has been replaced with the following
// definition
#define SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC "SchemeDllRetrieveEncodedObject"

// 2-8-02 Server 2003 changed to use UNICODE Url strings instead of multibyte
#define SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC "SchemeDllRetrieveEncodedObjectW"

typedef VOID (WINAPI *PFN_FREE_ENCODED_OBJECT_FUNC) (
    __in_opt LPCSTR pszObjectOid,
    __inout PCRYPT_BLOB_ARRAY pObject,
    __inout_opt LPVOID pvFreeContext
    );

//
// SchemeDllRetrieveEncodedObject was replaced in Server 2003 with
// the following. (Changed to use UNICODE Url Strings.)
//

//
// SchemeDllRetrieveEncodedObjectW has the following signature:
//
// __success(return == TRUE)
// BOOL WINAPI SchemeDllRetrieveEncodedObjectW (
//                   __in LPCWSTR pwszUrl,
//                   __in_opt LPCSTR pszObjectOid,
//                   __in DWORD dwRetrievalFlags,
//                   __in DWORD dwTimeout,                // milliseconds
//                   __out PCRYPT_BLOB_ARRAY pObject,
//                   __deref_out __callback PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
//                   __deref_out_opt LPVOID* ppvFreeContext,
//                   __in_opt HCRYPTASYNC hAsyncRetrieve,
//                   __in_opt PCRYPT_CREDENTIALS pCredentials,
//                   __inout_opt PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
//                   )
//

//
// Context Provider Signatures
//

#define CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC "ContextDllCreateObjectContext"

#define CONTEXT_OID_CERTIFICATE ((LPCSTR)1)
#define CONTEXT_OID_CRL         ((LPCSTR)2)
#define CONTEXT_OID_CTL         ((LPCSTR)3)
#define CONTEXT_OID_PKCS7       ((LPCSTR)4)
#define CONTEXT_OID_CAPI2_ANY   ((LPCSTR)5)
#define CONTEXT_OID_OCSP_RESP   ((LPCSTR)6)

//
// ContextDllCreateObjectContext has the following signature:
//
// __success(return == TRUE)
// BOOL WINAPI ContextDllCreateObjectContext (
//                    __in_opt LPCSTR pszObjectOid,
//                    __in DWORD dwRetrievalFlags,
//                    __in PCRYPT_BLOB_ARRAY pObject,
//                    __deref_out LPVOID* ppvContext
//                    )
//

//
// Remote Object Retrieval API
//

//
// Retrieval flags
//

#define CRYPT_RETRIEVE_MULTIPLE_OBJECTS         0x00000001
#define CRYPT_CACHE_ONLY_RETRIEVAL              0x00000002
#define CRYPT_WIRE_ONLY_RETRIEVAL               0x00000004
#define CRYPT_DONT_CACHE_RESULT                 0x00000008
#define CRYPT_ASYNC_RETRIEVAL                   0x00000010
#define CRYPT_STICKY_CACHE_RETRIEVAL            0x00001000
#define CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL    0x00002000
#define CRYPT_OFFLINE_CHECK_RETRIEVAL           0x00004000

// When the following flag is set, the following 2 NULL terminated ascii
// strings are inserted at the beginning of each returned blob:
//  "%d\0%s\0", dwEntryIndex, pszAttribute
//
//  The first dwEntryIndex is 0, "0\0".
//
// When set, pszObjectOid must be NULL, so that a PCRYPT_BLOB_ARRAY is returned.
#define CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE       0x00008000

// Set this flag to digitally sign all of the ldap traffic to and from a
// Windows 2000 LDAP server using the Kerberos authentication protocol.
// This feature provides integrity required by some applications.
#define CRYPT_LDAP_SIGN_RETRIEVAL               0x00010000

// Set this flag to inhibit automatic authentication handling. See the
// wininet flag, INTERNET_FLAG_NO_AUTH, for more details.
#define CRYPT_NO_AUTH_RETRIEVAL                 0x00020000

// Performs an A-Record only DNS lookup on the supplied host string.
// This prevents bogus DNS queries from being generated when resolving host
// names. Use this flag whenever passing a hostname as opposed to a
// domain name for the hostname parameter.
//
// See LDAP_OPT_AREC_EXCLUSIVE defined in winldap.h for more details.
#define CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL     0x00040000

// Apply AIA URL restrictions, such as, validate retrieved content before
// writing to cache.
#define CRYPT_AIA_RETRIEVAL                     0x00080000

// For HTTP: use POST instead of the default GET
//
// The POST additional binary data and header strings are appended to
// the host name and path URL as follows:
//  + L'/'<Optional url escaped and base64 encoded additional data>
//  + L'?'<Optional additional headers>
//
// Here's an example of an OCSP POST URL:
//  http://ocsp.openvalidation.org/MEIwQDA%2BMDwwOjAJBgUrDgMCGgUABBQdKNE
//      wjytjKBQADcgM61jfflNpyQQUv1NDgnjQnsOA5RtnygUA37lIg6UCA
//      QI%3D?Content-Type: application/ocsp-request
//
//
// When this flag is set, CryptRetrieveObjectByUrl, searches for the
// last L'/' and L'?' POST marker characters in the URL string.
// These are removed from the URL before it is passed to the WinHttp
// APIs. The L'?' string is passed as the AdditionHeaders to
// WinHttpSendRequest. The L'/' string is url unescaped (%xx converted
// to appropriate character) and base64 decoded into binary. This
// decoded binary is passed as the additional data to WinHttpSendRequest.
#define CRYPT_HTTP_POST_RETRIEVAL               0x00100000

// When this flag is set we won't attempt to bypass any potential proxy caches.
// If a proxy cache wasn't explicitly bypassed, fProxyCacheRetrieval will be
// set in pAuxInfo. Only applicable to http URL retrievals.
#define CRYPT_PROXY_CACHE_RETRIEVAL             0x00200000

// When this flag is set, for a conditional retrieval returning not modified,
// TRUE is returned and *ppvObject is set to NULL. For a nonNULL pAuxInfo,
// dwHttpStatusCode is set to winhttp.h's HTTP_STATUS_NOT_MODIFIED. Otherwise,
// *ppvObject is updated for a successful retrieval. Only applicable to
// http URL retrievals.
#define CRYPT_NOT_MODIFIED_RETRIEVAL            0x00400000

//
// Data verification retrieval flags
//
// CRYPT_VERIFY_CONTEXT_SIGNATURE is used to get signature verification
// on the context created.  In this case pszObjectOid must be non-NULL and
// pvVerify points to the signer certificate context
//
// CRYPT_VERIFY_DATA_HASH is used to get verification of the blob data
// retrieved by the protocol.  The pvVerify points to an URL_DATA_HASH
// structure (TBD)
//

#define CRYPT_VERIFY_CONTEXT_SIGNATURE  0x00000020
#define CRYPT_VERIFY_DATA_HASH          0x00000040

//
// Time Valid Object flags
//

#define CRYPT_KEEP_TIME_VALID               0x00000080
#define CRYPT_DONT_VERIFY_SIGNATURE         0x00000100
#define CRYPT_DONT_CHECK_TIME_VALIDITY      0x00000200

// The default checks if ftNextUpdate >= ftValidFor. Set this flag to
// check if ftThisUpdate >= ftValidFor.
#define CRYPT_CHECK_FRESHNESS_TIME_VALIDITY 0x00000400

#define CRYPT_ACCUMULATIVE_TIMEOUT          0x00000800

// Set this flag to only use OCSP AIA URLs.
#define CRYPT_OCSP_ONLY_RETRIEVAL           0x01000000


//
// Cryptnet URL Cache Pre-Fetch Info
//
typedef struct _CRYPTNET_URL_CACHE_PRE_FETCH_INFO {
    DWORD           cbSize;
    DWORD           dwObjectType;

    // Possible errors:
    //  S_OK                - Pending
    //  ERROR_MEDIA_OFFLINE - CRL pre-fetch disabled due to OCSP offline.
    //  ERROR_FILE_OFFLINE  - Unchanged pre-fetch content
    //  ERROR_INVALID_DATA  - Invalid pre-fetch content
    //  Other errors        - Unable to retrieve pre-fetch content
    DWORD           dwError;
    DWORD           dwReserved;

    FILETIME        ThisUpdateTime;
    FILETIME        NextUpdateTime;
    FILETIME        PublishTime;    // May be zero
} CRYPTNET_URL_CACHE_PRE_FETCH_INFO, *PCRYPTNET_URL_CACHE_PRE_FETCH_INFO;

// Pre-fetch ObjectTypes
#define CRYPTNET_URL_CACHE_PRE_FETCH_NONE           0
#define CRYPTNET_URL_CACHE_PRE_FETCH_BLOB           1
#define CRYPTNET_URL_CACHE_PRE_FETCH_CRL            2
#define CRYPTNET_URL_CACHE_PRE_FETCH_OCSP           3
#define CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB   5



//
// Cryptnet URL Cache Flush Info
//
typedef struct _CRYPTNET_URL_CACHE_FLUSH_INFO {
    DWORD           cbSize;
    // If pre-fetching is enabled, following is ignored
    //
    // 0          - use default flush exempt seconds (2 weeks)
    // 0xFFFFFFFF - disable flushing
    DWORD           dwExemptSeconds;

    // Time the object expires. The above dwExemptSeconds is added to
    // to determine the flush time. The LastSyncTime is used if
    // after this time.
    FILETIME        ExpireTime;
} CRYPTNET_URL_CACHE_FLUSH_INFO, *PCRYPTNET_URL_CACHE_FLUSH_INFO;

#define CRYPTNET_URL_CACHE_DEFAULT_FLUSH                0
#define CRYPTNET_URL_CACHE_DISABLE_FLUSH                0xFFFFFFFF


//
// Cryptnet URL Cache Response Info
//
typedef struct _CRYPTNET_URL_CACHE_RESPONSE_INFO {
    DWORD           cbSize;
    WORD            wResponseType;
    WORD            wResponseFlags;

    // The following are zero if not present
    FILETIME        LastModifiedTime;
    DWORD           dwMaxAge;
    LPCWSTR         pwszETag;
    DWORD           dwProxyId;
} CRYPTNET_URL_CACHE_RESPONSE_INFO, *PCRYPTNET_URL_CACHE_RESPONSE_INFO;


// ResponseTypes
#define CRYPTNET_URL_CACHE_RESPONSE_NONE            0
#define CRYPTNET_URL_CACHE_RESPONSE_HTTP            1

// ResponseFlags
#define CRYPTNET_URL_CACHE_RESPONSE_VALIDATED       0x8000

//
// CryptRetrieveObjectByUrl Auxilliary Info
//
//
// All unused fields in this data structure must be zeroed. More fields
// could be added in a future release.
//
typedef struct _CRYPT_RETRIEVE_AUX_INFO {
    DWORD                               cbSize;
    FILETIME                            *pLastSyncTime;

    // 0 => implies no limit
    DWORD                               dwMaxUrlRetrievalByteCount;

    // To get any PreFetchInfo, set the following pointer to a
    // CRYPTNET_URL_CACHE_PRE_FETCH_INFO structure with its cbSize set
    // upon input. For no PreFetchInfo, except for cbSize, the data
    // structure is zeroed upon return.
    PCRYPTNET_URL_CACHE_PRE_FETCH_INFO  pPreFetchInfo;

    // To get any FlushInfo, set the following pointer to a
    // CRYPTNET_URL_CACHE_FLUSH_INFO structure with its cbSize set
    // upon input. For no FlushInfo, except for cbSize, the data structure
    // is zeroed upon return.
    PCRYPTNET_URL_CACHE_FLUSH_INFO      pFlushInfo;

    // To get any ResponseInfo, set the following pointer to the address
    // of a PCRYPTNET_URL_CACHE_RESPONSE_INFO pointer updated with
    // the allocated structure. For no ResponseInfo, *ppResponseInfo is set
    // to NULL. Otherwise, *ppResponseInfo must be free via CryptMemFree().
    PCRYPTNET_URL_CACHE_RESPONSE_INFO   *ppResponseInfo;

    // If nonNULL, the specified prefix string is prepended to the
    // cached filename.
    LPWSTR                              pwszCacheFileNamePrefix;

    // If nonNULL, any cached information before this time is considered
    // time invalid. For CRYPT_CACHE_ONLY_RETRIEVAL, if there is a
    // cached entry before this time, LastError is set to ERROR_INVALID_TIME.
    // Also used to set max-age for http retrievals.
    LPFILETIME                          pftCacheResync;

    // The following flag is set upon return if CRYPT_PROXY_CACHE_RETRIEVAL
    // was set in dwRetrievalFlags and the proxy cache wasn't explicitly
    // bypassed for the retrieval. This flag won't be explicitly cleared.
    // This flag will only be set for http URL retrievals.
    BOOL                                fProxyCacheRetrieval;

    // This value is only updated upon return for a nonSuccessful status code
    // returned in a HTTP response header. This value won't be explicitly
    // cleared. This value will only be updated for http or https URL
    // retrievals.
    //
    // If CRYPT_NOT_MODIFIED_RETRIEVAL was set in dwFlags, set to winhttp.h's
    // HTTP_STATUS_NOT_MODIFIED if the retrieval returned not modified. In
    // this case TRUE is returned with *ppvObject set to NULL.
    DWORD                               dwHttpStatusCode;
} CRYPT_RETRIEVE_AUX_INFO, *PCRYPT_RETRIEVE_AUX_INFO;


WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptRetrieveObjectByUrlA (
    __in LPCSTR pszUrl,
    __in_opt LPCSTR pszObjectOid,
    __in DWORD dwRetrievalFlags,
    __in DWORD dwTimeout,                     // milliseconds
    __deref_out LPVOID* ppvObject,
    __in_opt HCRYPTASYNC hAsyncRetrieve,
    __in_opt PCRYPT_CREDENTIALS pCredentials,
    __in_opt LPVOID pvVerify,
    __inout_opt PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptRetrieveObjectByUrlW (
    __in LPCWSTR pszUrl,
    __in_opt LPCSTR pszObjectOid,
    __in DWORD dwRetrievalFlags,
    __in DWORD dwTimeout,                     // milliseconds
    __deref_out LPVOID* ppvObject,
    __in_opt HCRYPTASYNC hAsyncRetrieve,
    __in_opt PCRYPT_CREDENTIALS pCredentials,
    __in_opt LPVOID pvVerify,
    __inout_opt PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );
#ifdef UNICODE
#define CryptRetrieveObjectByUrl  CryptRetrieveObjectByUrlW
#else
#define CryptRetrieveObjectByUrl  CryptRetrieveObjectByUrlA
#endif // !UNICODE


//
// Call back function to cancel object retrieval
//
// The function can be installed on a per thread basis.
// If CryptInstallCancelRetrieval is called for multiple times, only the most recent
// installation will be kept.
//
// This is only effective for http, https, gopher, and ftp protocol.
// It is ignored by the rest of the protocols.


typedef BOOL (WINAPI *PFN_CRYPT_CANCEL_RETRIEVAL)(
    __in DWORD dwFlags,
    __inout_opt void  *pvArg
    );


//
// PFN_CRYPT_CANCEL_RETRIEVAL
//
// This function should return FALSE when the object retrieval should be continued
// and return TRUE when the object retrieval should be cancelled.
//

WINCRYPT32API
BOOL
WINAPI
CryptInstallCancelRetrieval(
    __callback PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel,
    __in_opt const void *pvArg,
    __in DWORD dwFlags,
    __reserved void *pvReserved
);


WINCRYPT32API
BOOL
WINAPI
CryptUninstallCancelRetrieval(
        __in DWORD dwFlags,
        __reserved void *pvReserved
        );


WINCRYPT32API
BOOL
WINAPI
CryptCancelAsyncRetrieval (
    __in_opt HCRYPTASYNC hAsyncRetrieval
    );

//
// Remote Object Async Retrieval parameters
//

//
// A client that wants to be notified of asynchronous object retrieval
// completion sets this parameter on the async handle
//

#define CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION ((LPCSTR)1)

typedef VOID (WINAPI *PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC) (
    __inout_opt LPVOID pvCompletion,
    __in DWORD dwCompletionCode,
    __in LPCSTR pszUrl,
    __in_opt LPSTR pszObjectOid,
    __in LPVOID pvObject
    );

typedef struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION {
    __callback PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC pfnCompletion;
    __inout_opt LPVOID pvCompletion;
} CRYPT_ASYNC_RETRIEVAL_COMPLETION, *PCRYPT_ASYNC_RETRIEVAL_COMPLETION;

//
// This function is set on the async handle by a scheme provider that
// supports asynchronous retrieval
//

#define CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL ((LPCSTR)2)

typedef BOOL (WINAPI *PFN_CANCEL_ASYNC_RETRIEVAL_FUNC) (
    __in_opt HCRYPTASYNC hAsyncRetrieve
    );

//
// Get the locator for a CAPI object
//

#define CRYPT_GET_URL_FROM_PROPERTY         0x00000001
#define CRYPT_GET_URL_FROM_EXTENSION        0x00000002
#define CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE 0x00000004
#define CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE   0x00000008

typedef struct _CRYPT_URL_ARRAY {
    DWORD   cUrl;
    LPWSTR* rgwszUrl;
} CRYPT_URL_ARRAY, *PCRYPT_URL_ARRAY;

typedef struct _CRYPT_URL_INFO {
    DWORD   cbSize;

    // Seconds between syncs
    DWORD   dwSyncDeltaTime;

    // Returned URLs may be grouped. For instance, groups of cross cert
    // distribution points. Each distribution point may have multiple
    // URLs, (LDAP and HTTP scheme).
    DWORD   cGroup;
    DWORD   *rgcGroupEntry;
} CRYPT_URL_INFO, *PCRYPT_URL_INFO;

WINCRYPT32API
BOOL
WINAPI
CryptGetObjectUrl (
    __in LPCSTR pszUrlOid,
    __in LPVOID pvPara,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbUrlArray, *pcbUrlArray) PCRYPT_URL_ARRAY pUrlArray,
    __inout DWORD* pcbUrlArray,
    __out_bcount_part_opt(*pcbUrlInfo, *pcbUrlInfo) PCRYPT_URL_INFO pUrlInfo,
    __inout_opt DWORD* pcbUrlInfo,
    __reserved LPVOID pvReserved
    );

#define URL_OID_GET_OBJECT_URL_FUNC "UrlDllGetObjectUrl"

//
// UrlDllGetObjectUrl has the same signature as CryptGetObjectUrl
//

//
// URL_OID_CERTIFICATE_ISSUER
//
// pvPara == PCCERT_CONTEXT, certificate whose issuer's URL is being requested
//
// This will be retrieved from the authority info access extension or property
// on the certificate
//
// URL_OID_CERTIFICATE_CRL_DIST_POINT
//
// pvPara == PCCERT_CONTEXT, certificate whose CRL distribution point is being
// requested
//
// This will be retrieved from the CRL distribution point extension or property
// on the certificate
//
// URL_OID_CTL_ISSUER
//
// pvPara == PCCTL_CONTEXT, Signer Index, CTL whose issuer's URL (identified
// by the signer index) is being requested
//
// This will be retrieved from an authority info access attribute method encoded
// in each signer info in the PKCS7 (CTL)
//
// URL_OID_CTL_NEXT_UPDATE
//
// pvPara == PCCTL_CONTEXT, Signer Index, CTL whose next update URL is being
// requested and an optional signer index in case we need to check signer
// info attributes
//
// This will be retrieved from an authority info access CTL extension, property,
// or signer info attribute method
//
// URL_OID_CRL_ISSUER
//
// pvPara == PCCRL_CONTEXT, CRL whose issuer's URL is being requested
//
// This will be retrieved from a property on the CRL which has been inherited
// from the subject cert (either from the subject cert issuer or the subject
// cert distribution point extension).  It will be encoded as an authority
// info access extension method.
//
// URL_OID_CERTIFICATE_FRESHEST_CRL
//
// pvPara == PCCERT_CONTEXT, certificate whose freshest CRL distribution point
// is being requested
//
// This will be retrieved from the freshest CRL extension or property
// on the certificate
//
// URL_OID_CRL_FRESHEST_CRL
//
// pvPara == PCCERT_CRL_CONTEXT_PAIR, certificate's base CRL whose
// freshest CRL distribution point is being requested
//
// This will be retrieved from the freshest CRL extension or property
// on the CRL
//
// URL_OID_CROSS_CERT_DIST_POINT
//
// pvPara == PCCERT_CONTEXT, certificate whose cross certificate distribution
// point is being requested
//
// This will be retrieved from the cross certificate distribution point
// extension or property on the certificate
//
// URL_OID_CERTIFICATE_OCSP
//
// pvPara == PCCERT_CONTEXT, certificate whose OCSP URL is being requested
//
// This will be retrieved from the authority info access extension or property
// on the certificate
//
// URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT
//
// pvPara == PCCERT_CONTEXT, certificate whose OCSP URL and
// CRL distribution point are being requested
//
// This will be retrieved from the authority info access and
// CRL distribution point extension or property on the certificate.
// If any OCSP URLs are present, they will be first with each URL prefixed
// with L"ocsp:". The L"ocsp:" prefix should be removed before using.
//
// URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP
//
// Same as URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT, except,
// the CRL URLs will be first
//
// URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS
//
// pvPara == PCCERT_CONTEXT, certificate whose cross certificates
// are being requested
//
// This will be retrieved from the Authority Info Access
// extension or property on the certificate. Only access methods
// matching szOID_PKIX_CA_REPOSITORY will be returned.

#define URL_OID_CERTIFICATE_ISSUER         ((LPCSTR)1)
#define URL_OID_CERTIFICATE_CRL_DIST_POINT ((LPCSTR)2)
#define URL_OID_CTL_ISSUER                 ((LPCSTR)3)
#define URL_OID_CTL_NEXT_UPDATE            ((LPCSTR)4)
#define URL_OID_CRL_ISSUER                 ((LPCSTR)5)
#define URL_OID_CERTIFICATE_FRESHEST_CRL   ((LPCSTR)6)
#define URL_OID_CRL_FRESHEST_CRL           ((LPCSTR)7)
#define URL_OID_CROSS_CERT_DIST_POINT      ((LPCSTR)8)
#define URL_OID_CERTIFICATE_OCSP           ((LPCSTR)9)
#define URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT ((LPCSTR)10)
#define URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP ((LPCSTR)11)
#define URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS ((LPCSTR)12)

typedef struct _CERT_CRL_CONTEXT_PAIR {
    PCCERT_CONTEXT          pCertContext;
    PCCRL_CONTEXT           pCrlContext;
} CERT_CRL_CONTEXT_PAIR, *PCERT_CRL_CONTEXT_PAIR;
typedef const CERT_CRL_CONTEXT_PAIR *PCCERT_CRL_CONTEXT_PAIR;

//
// Get a time valid CAPI2 object
//

//+-------------------------------------------------------------------------
//  The following optional Extra Info may be passed to
//  CryptGetTimeValidObject().
//
//  All unused fields in this data structure must be zeroed. More fields
//  could be added in a future release.
//--------------------------------------------------------------------------
typedef struct _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO {
    DWORD                       cbSize;

    // If > 0, check that the CRL's number is >=
    int                         iDeltaCrlIndicator;

    // If nonNULL, any cached information before this time is considered
    // time invalid and forces a wire retrieval.
    LPFILETIME                  pftCacheResync;

    // If nonNull, returns the cache's LastSyncTime
    LPFILETIME                  pLastSyncTime;

    // If nonNull, returns the internal MaxAge expiration time
    // for the object. If the object doesn't have a MaxAge expiration, set
    // to zero.
    LPFILETIME                  pMaxAgeTime;
} CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO,
    *PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;

WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CryptGetTimeValidObject (
    __in LPCSTR pszTimeValidOid,
    __in LPVOID pvPara,
    __in PCCERT_CONTEXT pIssuer,
    __in_opt LPFILETIME pftValidFor,
    __in DWORD dwFlags,
    __in DWORD dwTimeout,                         // milliseconds
    __deref_opt_out LPVOID* ppvObject,
    __in_opt PCRYPT_CREDENTIALS pCredentials,
    __inout_opt PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo
    );

#define TIME_VALID_OID_GET_OBJECT_FUNC "TimeValidDllGetObject"

//
// TimeValidDllGetObject has the same signature as CryptGetTimeValidObject
//

//
// TIME_VALID_OID_GET_CTL
//
// pvPara == PCCTL_CONTEXT, the current CTL
//
// TIME_VALID_OID_GET_CRL
//
// pvPara == PCCRL_CONTEXT, the current CRL
//
// TIME_VALID_OID_GET_CRL_FROM_CERT
//
// pvPara == PCCERT_CONTEXT, the subject cert
//
// TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT
//
// pvPara == PCCERT_CONTEXT, the subject cert
//
// TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL
//
// pvPara == PCCERT_CRL_CONTEXT_PAIR, the subject cert and its base CRL
//

#define TIME_VALID_OID_GET_CTL           ((LPCSTR)1)
#define TIME_VALID_OID_GET_CRL           ((LPCSTR)2)
#define TIME_VALID_OID_GET_CRL_FROM_CERT ((LPCSTR)3)

#define TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT   ((LPCSTR)4)
#define TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL    ((LPCSTR)5)

WINCRYPT32API
BOOL
WINAPI
CryptFlushTimeValidObject (
     __in LPCSTR pszFlushTimeValidOid,
     __in LPVOID pvPara,
     __in PCCERT_CONTEXT pIssuer,
     __in DWORD dwFlags,
     __reserved LPVOID pvReserved
     );

#define TIME_VALID_OID_FLUSH_OBJECT_FUNC "TimeValidDllFlushObject"

//
// TimeValidDllFlushObject has the same signature as CryptFlushTimeValidObject
//

//
// TIME_VALID_OID_FLUSH_CTL
//
// pvPara == PCCTL_CONTEXT, the CTL to flush
//
// TIME_VALID_OID_FLUSH_CRL
//
// pvPara == PCCRL_CONTEXT, the CRL to flush
//
// TIME_VALID_OID_FLUSH_CRL_FROM_CERT
//
// pvPara == PCCERT_CONTEXT, the subject cert's CRL to flush
//
// TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT
//
// pvPara == PCCERT_CONTEXT, the subject cert's freshest CRL to flush
//
// TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL
//
// pvPara == PCCERT_CRL_CONTEXT_PAIR, the subject cert and its base CRL's
// freshest CRL to flush
//

#define TIME_VALID_OID_FLUSH_CTL           ((LPCSTR)1)
#define TIME_VALID_OID_FLUSH_CRL           ((LPCSTR)2)
#define TIME_VALID_OID_FLUSH_CRL_FROM_CERT ((LPCSTR)3)

#define TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT ((LPCSTR)4)
#define TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL  ((LPCSTR)5)

//-------------------------------------------------------------------------
// Data Protection APIs
//-------------------------------------------------------------------------

//
// Data protection APIs enable applications to easily secure data.
//
// The base provider provides protection based on the users' logon
// credentials. The data secured with these APIs follow the same
// roaming characteristics as HKCU -- if HKCU roams, the data
// protected by the base provider may roam as well. This makes
// the API ideal for the munging of data stored in the registry.
//

//
// Prompt struct -- what to tell users about the access
//
typedef struct  _CRYPTPROTECT_PROMPTSTRUCT
{
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
} CRYPTPROTECT_PROMPTSTRUCT, *PCRYPTPROTECT_PROMPTSTRUCT;


//
// base provider action
//
#define CRYPTPROTECT_DEFAULT_PROVIDER   { 0xdf9d8cd0, 0x1501, 0x11d1, {0x8c, 0x7a, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb} }

//
// CryptProtect PromptStruct dwPromtFlags
//
//
// prompt on unprotect
#define CRYPTPROTECT_PROMPT_ON_UNPROTECT     0x1  // 1<<0
//
// prompt on protect
#define CRYPTPROTECT_PROMPT_ON_PROTECT       0x2  // 1<<1
#define CRYPTPROTECT_PROMPT_RESERVED         0x04 // reserved, do not use.

//
// default to strong variant UI protection (user supplied password currently).
#define CRYPTPROTECT_PROMPT_STRONG           0x08 // 1<<3

//
// require strong variant UI protection (user supplied password currently).
#define CRYPTPROTECT_PROMPT_REQUIRE_STRONG   0x10 // 1<<4

//
// CryptProtectData and CryptUnprotectData dwFlags
//
// for remote-access situations where ui is not an option
// if UI was specified on protect or unprotect operation, the call
// will fail and GetLastError() will indicate ERROR_PASSWORD_RESTRICTION
#define CRYPTPROTECT_UI_FORBIDDEN        0x1

//
// per machine protected data -- any user on machine where CryptProtectData
// took place may CryptUnprotectData
#define CRYPTPROTECT_LOCAL_MACHINE       0x4

//
// force credential synchronize during CryptProtectData()
// Synchronize is only operation that occurs during this operation
#define CRYPTPROTECT_CRED_SYNC           0x8

//
// Generate an Audit on protect and unprotect operations
//
#define CRYPTPROTECT_AUDIT              0x10

//
// Protect data with a non-recoverable key
//
#define CRYPTPROTECT_NO_RECOVERY        0x20


//
// Verify the protection of a protected blob
//
#define CRYPTPROTECT_VERIFY_PROTECTION  0x40

//
// Regenerate the local machine protection
//
#define CRYPTPROTECT_CRED_REGENERATE    0x80

#ifdef UNDER_CE

//
// Only allow decryption from system (trusted) processes (Windows CE).
// This flag is deprecated. Using CRYPTPROTECT_PRIVATE instead 
//
#define CRYPTPROTECT_SYSTEM                 0x20000000

//
// Only allow decryption from processes in allowed chamber (Windows CE).
//
#define CRYPTPROTECT_PRIVATE                0x40000000
#endif

// flags reserved for system use
#define CRYPTPROTECT_FIRST_RESERVED_FLAGVAL    0x0FFFFFFF
#define CRYPTPROTECT_LAST_RESERVED_FLAGVAL     0xFFFFFFFF

//
// flags specific to base provider
//


WINCRYPT32API
BOOL
WINAPI
CryptProtectData(
    __in              const DATA_BLOB*              pDataIn,
    __in_opt          LPCWSTR                       szDataDescr,
    __in_opt          const DATA_BLOB*              pOptionalEntropy,
    __reserved        PVOID                         pvReserved,
    __in_opt          CRYPTPROTECT_PROMPTSTRUCT*    pPromptStruct,
                      DWORD                         dwFlags,
    __out             DATA_BLOB*                    pDataOut            // out encr blob
    );

WINCRYPT32API
BOOL
WINAPI
CryptUnprotectData(
    __in                const DATA_BLOB*            pDataIn,             // in encr blob
    __deref_opt_out_opt LPWSTR*                     ppszDataDescr,       // out
    __in_opt            const DATA_BLOB*            pOptionalEntropy,
    __reserved          PVOID                       pvReserved,
    __in_opt            CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
                        DWORD                       dwFlags,
    __out               DATA_BLOB*                  pDataOut
    );

WINCRYPT32API
BOOL
WINAPI
CryptUpdateProtectedState(
    __in_opt        PSID            pOldSid,
    __in_opt        LPCWSTR         pwszOldPassword,
    __in            DWORD           dwFlags,
    __out_opt       DWORD           *pdwSuccessCount,
    __out_opt       DWORD           *pdwFailureCount);


//
// The buffer length passed into CryptProtectMemory and CryptUnprotectMemory
// must be a multiple of this length (or zero).
//

#define CRYPTPROTECTMEMORY_BLOCK_SIZE           16


//
// CryptProtectMemory/CryptUnprotectMemory dwFlags
//

//
// Encrypt/Decrypt within current process context.
//

#define CRYPTPROTECTMEMORY_SAME_PROCESS         0x00

//
// Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls CryptUnprotectMemory.
//

#define CRYPTPROTECTMEMORY_CROSS_PROCESS        0x01

//
// Encrypt/Decrypt across callers with same LogonId.
// eg: encrypted buffer passed across LPC to another process which calls CryptUnprotectMemory whilst impersonating.
//

#define CRYPTPROTECTMEMORY_SAME_LOGON           0x02


WINCRYPT32API
BOOL
WINAPI
CryptProtectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to encrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags
    );

WINCRYPT32API
BOOL
WINAPI
CryptUnprotectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to decrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags
    );



//+=========================================================================
//  Helper functions to build certificates
//==========================================================================

//+-------------------------------------------------------------------------
//
// Builds a self-signed certificate and returns a PCCERT_CONTEXT representing
// the certificate. A hProv may be specified to build the cert context.
//
// pSubjectIssuerBlob is the DN for the certifcate. If an alternate subject
// name is desired it must be specified as an extension in the pExtensions
// parameter. pSubjectIssuerBlob can NOT be NULL, so minimually an empty DN
// must be specified.
//
// By default:
// pKeyProvInfo - The CSP is queried for the KeyProvInfo parameters. Only the Provider,
// Provider Type and Container is queried. Many CSPs don't support these
// queries and will cause a failure. In such cases the pKeyProvInfo
// must be specified (RSA BASE works fine).
//
// pSignatureAlgorithm - will default to SHA1RSA
// pStartTime will default to the current time
// pEndTime will default to 1 year
// pEntensions will be empty.
//
// The returned PCCERT_CONTEXT will reference the private keys by setting the
// CERT_KEY_PROV_INFO_PROP_ID. However, if this property is not desired specify the
// CERT_CREATE_SELFSIGN_NO_KEY_INFO in dwFlags.
//
// If the cert being built is only a dummy placeholder cert for speed it may not
// need to be signed. Signing of the cert is skipped if CERT_CREATE_SELFSIGN_NO_SIGN
// is specified in dwFlags.
//
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertCreateSelfSignCertificate(
    __in_opt  HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    __in      PCERT_NAME_BLOB             pSubjectIssuerBlob,
    __in      DWORD                       dwFlags,
    __in_opt  PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    __in_opt  PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    __in_opt  LPSYSTEMTIME                 pStartTime,
    __in_opt  LPSYSTEMTIME                 pEndTime,
    __in_opt  PCERT_EXTENSIONS            pExtensions
    );

#define CERT_CREATE_SELFSIGN_NO_SIGN    1
#define CERT_CREATE_SELFSIGN_NO_KEY_INFO 2

//+=========================================================================
//  Key Identifier Property Data Structures and APIs
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the property for the specified Key Identifier.
//
//  The Key Identifier is the SHA1 hash of the encoded CERT_PUBLIC_KEY_INFO.
//  The Key Identifier for a certificate can be obtained by getting the
//  certificate's CERT_KEY_IDENTIFIER_PROP_ID. The
//  CryptCreateKeyIdentifierFromCSP API can be called to create the Key
//  Identifier from a CSP Public Key Blob.
//
//  A Key Identifier can have the same properties as a certificate context.
//  CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO
//  structure. Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData will exceed the size of the structure.
//
//  If CRYPT_KEYID_ALLOC_FLAG is set, then, *pvData is updated with a
//  pointer to allocated memory. LocalFree() must be called to free the
//  allocated memory.
//
//  By default, searches the CurrentUser's list of Key Identifiers.
//  CRYPT_KEYID_MACHINE_FLAG can be set to search the LocalMachine's list
//  of Key Identifiers. When CRYPT_KEYID_MACHINE_FLAG is set, pwszComputerName
//  can also be set to specify the name of a remote computer to be searched
//  instead of the local machine.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptGetKeyIdentifierProperty(
    __in const CRYPT_HASH_BLOB *pKeyIdentifier,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt LPCWSTR pwszComputerName,
    __reserved void *pvReserved,
    __out_bcount_part_opt(*pcbData, *pcbData) void *pvData,
    __inout DWORD *pcbData
    );

// When the following flag is set, searches the LocalMachine instead of the
// CurrentUser. This flag is applicable to all the KeyIdentifierProperty APIs.
#define CRYPT_KEYID_MACHINE_FLAG        0x00000020

// When the following flag is set, *pvData is updated with a pointer to
// allocated memory. LocalFree() must be called to free the allocated memory.
#define CRYPT_KEYID_ALLOC_FLAG          0x00008000


//+-------------------------------------------------------------------------
//  Set the property for the specified Key Identifier.
//
//  For CERT_KEY_PROV_INFO_PROP_ID pvData points to the
//  CRYPT_KEY_PROV_INFO data structure. For all other properties, pvData
//  points to a CRYPT_DATA_BLOB.
//
//  Setting pvData == NULL, deletes the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to set the property for a LocalMachine
//  Key Identifier. Set pwszComputerName, to select a remote computer.
//
//  If CRYPT_KEYID_DELETE_FLAG is set, the Key Identifier and all its
//  properties is deleted.
//
//  If CRYPT_KEYID_SET_NEW_FLAG is set, the set fails if the property already
//  exists. For an existing property, FALSE is returned with LastError set to
//  CRYPT_E_EXISTS.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptSetKeyIdentifierProperty(
    __in const CRYPT_HASH_BLOB *pKeyIdentifier,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt LPCWSTR pwszComputerName,
    __reserved void *pvReserved,
    __in_opt const void *pvData
    );

// When the following flag is set, the Key Identifier and all its properties
// are deleted.
#define CRYPT_KEYID_DELETE_FLAG         0x00000010

// When the following flag is set, the set fails if the property already
// exists.
#define CRYPT_KEYID_SET_NEW_FLAG        0x00002000


//+-------------------------------------------------------------------------
//  For CERT_KEY_PROV_INFO_PROP_ID, rgppvData[] points to a
//  CRYPT_KEY_PROV_INFO.
//
//  Return FALSE to stop the enumeration.
//--------------------------------------------------------------------------
typedef BOOL (WINAPI *PFN_CRYPT_ENUM_KEYID_PROP)(
    __in const CRYPT_HASH_BLOB *pKeyIdentifier,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __inout_opt void *pvArg,
    __in DWORD cProp,
    __in_ecount(cProp) DWORD *rgdwPropId,
    __in_ecount(cProp) void **rgpvData,
    __in_ecount(cProp) DWORD *rgcbData
    );

//+-------------------------------------------------------------------------
//  Enumerate the Key Identifiers.
//
//  If pKeyIdentifier is NULL, enumerates all Key Identifers. Otherwise,
//  calls the callback for the specified KeyIdentifier. If dwPropId is
//  0, calls the callback with all the properties. Otherwise, only calls
//  the callback with the specified property (cProp = 1).
//  Furthermore, when dwPropId is specified, skips KeyIdentifiers not
//  having the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to enumerate the LocalMachine
//  Key Identifiers. Set pwszComputerName, to enumerate Key Identifiers on
//  a remote computer.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptEnumKeyIdentifierProperties(
    __in_opt const CRYPT_HASH_BLOB *pKeyIdentifier,
    __in DWORD dwPropId,
    __in DWORD dwFlags,
    __in_opt LPCWSTR pwszComputerName,
    __reserved void *pvReserved,
    __inout_opt void *pvArg,
    __callback PFN_CRYPT_ENUM_KEYID_PROP pfnEnum
    );

//+-------------------------------------------------------------------------
//  Create a KeyIdentifier from the CSP Public Key Blob.
//
//  Converts the CSP PUBLICKEYSTRUC into a X.509 CERT_PUBLIC_KEY_INFO and
//  encodes. The encoded CERT_PUBLIC_KEY_INFO is SHA1 hashed to obtain
//  the Key Identifier.
//
//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CryptCreateKeyIdentifierFromCSP(
    __in DWORD dwCertEncodingType,
    __in_opt LPCSTR pszPubKeyOID,
    __in_bcount(cbPubKeyStruc) const PUBLICKEYSTRUC *pPubKeyStruc,
    __in DWORD cbPubKeyStruc,
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __out_bcount_part_opt(*pcbHash, *pcbHash) BYTE *pbHash,
    __inout DWORD *pcbHash
    );


//+=========================================================================
//  Certificate Chaining Infrastructure
//==========================================================================

#define CERT_CHAIN_CONFIG_REGPATH \
    L"Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config"

// The following is a REG_BINARY. It contains the cache resync FILETIME.
// Any cached information before this time is considered time invalid
// and forces a wire retrieval. By default this is disabled.

#define CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME    \
    L"ChainCacheResyncFiletime"

// The following are REG_DWORD's. These configuration parameters are used
// to disable different chain building semantics enabled by default. Set
// the appropriate registry value to nonzero to disable.

#define CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME  \
    L"DisableMandatoryBasicConstraints"
// By default the BasicConstraints extension must be present with CA enabled
// for non-Root intermediate CA certificates.

#define CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME  \
    L"DisableCANameConstraints"
// By default the NameConstraints extension is applied to the intermediate
// CA certificates in addition to the end entity certificate.

#define CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME  \
    L"DisableUnsupportedCriticalExtensions"
// By default any unsupported extension marked critical sets the following
// dwErrorStatus bit: CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT.

// The following are REG_DWORD's. These configuration parameters are used
// to restrict Authority Info Access (AIA) URL retrieval.

#define CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME             \
    L"MaxAIAUrlCountInCert"
#define CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT                5

#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME \
    L"MaxAIAUrlRetrievalCountPerChain"
#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT    10

#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME      \
    L"MaxAIAUrlRetrievalByteCount"
#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT         100000

#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME      \
    L"MaxAIAUrlRetrievalCertCount"
#define CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT         10

// The following is a REG_DWORD. If the OCSP response NextUpdate is zero,
// this value is added to the ThisUpdate to get a nonzero NextUpdate.
#define CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME                 \
    L"OcspValiditySeconds"
// 12 hours
#define CERT_CHAIN_OCSP_VALIDITY_SECONDS_DEFAULT    (12 * 60 * 60)


// The following are REG_DWORD's. These configuration parameters are
// used by the following APIs to get a non-blocking, time valid OCSP
// response for a server certificate chain:
//   CertOpenServerOcspResponse
//   CertAddRefServerOcspResponse
//   CertCloseServerOcspResponse
//   CertGetServerOcspResponseContext
//   CertAddRefServerOcspResponseContext
//   CertFreeServerOcspResponseContext

// This is the minimum validity of the server OCSP response to be
// returned by CertGetServerOcspResponseContext(). Since this OCSP
// response will be returned to the client, it must be sufficiently long
// so that the client will treat it as being time valid.
#define CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME \
    L"SrvOcspRespMinValiditySeconds"
// 10 minutes
#define CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_DEFAULT \
    (10 * 60)

// This is the maximum number of milliseconds for each server OCSP response
// pre-fetch wire URL retrieval.
#define CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME \
    L"SrvOcspRespUrlRetrievalTimeoutMilliseconds"
// 15 seconds
#define CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT \
    (15 * 1000)

// This is the maximum number of seconds to do a server OCSP response
// pre-fetch retrieval before the OCSP response's NextUpdate. The
// server OCSP response pre-fetch thread will wait until CurrentTime >=
// NextUpdate - MaxBeforeNextUpdateSeconds before doing the next retrieval.
#define CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME \
    L"SrvOcspRespMaxBeforeNextUpdateSeconds"
// 4 hours
#define CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT \
    (4 * 60 * 60)

// This is the minimum number of seconds to do a server OCSP response
// pre-fetch retrieval before the OCSP response's NextUpdate.
// If CurrentTime >= NextUpdate - MinBeforeNextUpdateSeconds, will wait until
// after NextUpdate + MinAfterNextUpdateSeconds.
#define CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME \
    L"SrvOcspRespMinBeforeNextUpdateSeconds"
// 2 minutes
#define CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT \
    (2 * 60)

// This is the minimum number of seconds to do a server OCSP response
// pre-fetch retrieval after the OCSP response's NextUpdate when
// (NextUpdate - MinBeforeNextUpdateSeconds) < CurrentTime < NextUpdate.
#define CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME\
    L"SrvOcspRespMinAfterNextUpdateSeconds"
// 1 minute
#define CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_DEFAULT \
    (1 * 60)


// The following are REG_DWORD's. These configuration parameters are used
// in the ordering of the revocation retrieval URLs.


// When the number of cached OCSP URLs associated with the same CDP extension
// equal or exceed this number, the OCSP AIA URLs aren't used.
#define CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME \
    L"CryptnetMaxCachedOcspPerCrlCount"
#define CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT \
    500

// The above registry value can be set to this value, to disable OCSP
// when a CDP extension is present. Note, a registry value of 0, uses the
// above default value.
#define CRYPTNET_OCSP_AFTER_CRL_DISABLE \
    0xFFFFFFFF

// The following are REG_DWORD's. These configuration parameters are
// used by the Cryptnet Url Cache Service (CUCS).

// The following parameter is used as the default flush exempt seconds
#define CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME \
    L"CryptnetDefaultFlushExemptSeconds"

// 4 Weeks : 28 days * 24 hours * 60 minutes * 60 seconds
#define CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_DEFAULT \
    (28 * 24 * 60 * 60)

// Following 2 parameters are used to set the lower and upper limit
// on the max-age retrievals done before the Publish and NextUpdate times.
#define CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchMinMaxAgeSeconds"
// 1 hour
#define CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_DEFAULT \
    (1 * 60 * 60)

#define CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchMaxMaxAgeSeconds"
// 2 Weeks : 14 days * 24 hours * 60 minutes * 60 seconds
#define CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_DEFAULT \
    (14 * 24 * 60 * 60)

// Following 3 parameters are used to calculate the PreFetch start before
// the NextUpdate
//
// Where PreFetchStartTime = PublishTime +
//                              PublishPeriod / AfterPublishPreFetchDivisor
//       PreFetchEndTime = NextUpdate -
//                              PublishPeriod / BeforeNextUpdatePreFetchDivisor
//
//       PreFetchPeriod = PreFetchEndTime - PreFetchStartTime
//
//       if (PreFetchPeriod < MinBeforeNextUpdatePreFetchPeriodSeconds)
//          - No PreFetch is done before NextUpdate
//       else
//          - PreFetch starts are randomized over this period

// The start of the PreFetch period is delayed after the start of the
// Publish period by dividing the PublishPeriod (NextUpdate - PublishTime)
// by this integer divisor.
#define CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME \
    L"CryptnetPreFetchAfterPublishPreFetchDivisor"
// 10, where 12 hours / 10 = 72 minutes or 1.2 hours / 10 = 7.2 minutes
#define CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT \
    10

// The finish of the PreFetch period occurs before NextUpdate
// by dividing the PublishPeriod (NextUpdate - PublishTime)
// by this integer divisor.
#define CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME \
    L"CryptnetPreFetchBeforeNextUpdatePreFetchDivisor"
// 20, where 12 hours / 20 = 36 minutes or 1.2 hours / 10 = 3.6 minutes
#define CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT \
    20

// The PreFetch period must exceed this minimum duration in seconds
// to do a PreFetch before NextUpdate
#define CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds"
// 1 hour
//
// For the default OCSP period of 12 hours using above defaults,
// PreFetchPeriod = 72 minutes - 7.2 minutes - 3.6 mintes = 61.2 minutes
#define CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT \
    (1 * 60 * 60)

// Following 4 parameters are used to calculate the PreFetch start after
// the NextUpdate
//
// ValidityPeriod = NextUpdate - ThisUpdate
//
// PreFetchPeriod = ValidityPeriod / AfterNextUpdatePreFetchDivisor
//
// Where PreFetchPeriod is decreased to MaxAfterNextUpdatePreFetchPeriodSeconds
// or increased to MinAfterNextUpdatePreFetchPeriodSeconds;
//
// PreFetchStartTime = NextUpdate
// PreFetchEndTime = PreFetchStartTime + PreFetchPeriod
//
// PreFetch starts are randomized over the above PreFetchPeriod
//
// If CurrentTime > RandomPreFetchStartTime, then, the
// AfterCurrentTimePreFetchPeriodSeconds is randomized and added to
// CurrentTime for the RandomPreFetchStartTime

// The PreFetch period after NextUpdate is initially calculated by
// dividing the ValidityPeriod (NextUpdate - ThisUpdate) by this integer
// divisor.
#define CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME \
    L"CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor"
// 10, where 1 week / 10 = 16.8 hours
#define CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT \
    10

// If necessary, the above PreFetch period will be decreased
// to this maximum duration in seconds.
#define CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds"
// 4 hours
#define CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT \
    (4 * 60 * 60)

// If necessary, the above PreFetch period will be increased
// to this minimum duration in seconds.
#define CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds"
// 30 minutes
#define CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT \
    (30 * 60)

// If the CurrentTime is after the above randomized start time, the following
// parameter will be randomized and added to the CurrentTime.
#define CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds"
// 30 minutes
#define CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_DEFAULT \
    (30 * 60)


// Following parameter specifies the minimum time period between sending
// trigger URL cache PreFetch LRPC messages to cryptsvc after doing online
// revocation enabled chain builds.
#define CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchTriggerPeriodSeconds"
// 10 minutes
#define CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_DEFAULT \
    (10 * 60)

// The above registry value can be set to this value, to disable the
// sending of trigger URL cache PreFetch LRPC messages. Note, a registry
// value of 0, uses the above default value.
#define CRYPTNET_PRE_FETCH_TRIGGER_DISABLE \
    0xFFFFFFFF

// Following parameter specifies the delay time to wait to scan the
// URL cache directory after receiving a trigger LRPC message request.
#define CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchScanAfterTriggerDelaySeconds"
// 30 seconds
#define CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT \
    30

// Following parameter specifies the maximum amount of time to wait for any
// PreFetch retrieval to complete
#define CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME \
    L"CryptnetPreFetchRetrievalTimeoutSeconds"
// 5 minutes
#define CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_DEFAULT \
    (5 * 60)

//+-------------------------------------------------------------------------
// The following configuration parameters are store in HKLM group policy
//--------------------------------------------------------------------------

#define CERT_GROUP_POLICY_CHAIN_CONFIG_REGPATH \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\ChainEngine\\Config"

// In Longhorn, the following have been moved from the above HKLM
// configuration parameters:

// The following are REG_DWORD's. These configuration parameters are used
// to override the default URL timeouts in chain building

// This is the default URL timeout in milliseconds
#define CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME    \
    L"ChainUrlRetrievalTimeoutMilliseconds"
// 15 seconds
#define CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT       \
    (15 * 1000)

// This is the default revocation accumulative URL timeout in milliseconds
// The first revocation URL retrieval uses half of this timeout
#define CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME \
    L"ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds"
// 20 seconds
#define CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT \
    (20 * 1000)


// Note, will allow the machine setting to be used if this value isn't
// defined.


// By default AIA OCSP URLs are before CDP CRL URLs. When the number of cached
// OCSP URLs associated with the same CDP extension equal or exceed this
// number, the CRL URLs are placed before the OCSP URLs.
#define CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME \
    L"CryptnetCachedOcspSwitchToCrlCount"
#define CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT \
    50

// The above registry value can be set to this value, to always place
// the CRL URLs before the OCSP URLs. Note, a registry value of 0, uses the
// above default value.
#define CRYPTNET_CRL_BEFORE_OCSP_ENABLE \
    0xFFFFFFFF


// Support for the following was removed in Longhorn. Changed to use
// the following OPTIONS flags in HKLM Group Policy
#define CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME             \
    L"DisableAIAUrlRetrieval"
// By default AIA Url Retrieval is enabled. Set this registry value to nonzero
// to disable


// This is the name of the REG_DWORD for chain engine Options
#define CERT_CHAIN_OPTIONS_VALUE_NAME \
    L"Options"
// Disable AIA URL retrieval when this bit is set in the Options
#define CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL                 0x2


#define CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME \
    L"CrossCertDownloadIntervalHours"
// 7 days
#define CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_DEFAULT       (24 * 7)

// When not defined or zero, the CRL validity isn't extended
#define CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME \
    L"CRLValidityExtensionPeriod"
// 12 hour
#define CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT            12


//
// The chain engine defines the store namespace and cache partitioning for
// the Certificate Chaining infrastructure.  A default chain engine
// is defined for the process which uses all default system stores e.g.
// Root, CA, Trust, for chain building and caching.  If an application
// wishes to define its own store namespace or have its own partitioned
// cache then it can create its own chain engine.  It is advisable to create
// a chain engine at application startup and use it throughout the lifetime
// of the application in order to get optimal caching behavior
//

typedef HANDLE HCERTCHAINENGINE;

#define HCCE_CURRENT_USER  ((HCERTCHAINENGINE)NULL)
#define HCCE_LOCAL_MACHINE ((HCERTCHAINENGINE)0x1)

//
// Create a certificate chain engine.
//

//
// Configuration parameters for the certificate chain engine
//
//      hRestrictedRoot - restrict the root store (must be a subset of "Root")
//
//      hRestrictedTrust - restrict the store for CTLs
//
//      hRestrictedOther - restrict the store for certs and CRLs
//
//      cAdditionalStore, rghAdditionalStore - additional stores
//
//      NOTE: The algorithm used to define the stores for the engine is as
//            follows:
//
//            hRoot = hRestrictedRoot or System Store "Root"
//
//            hTrust = hRestrictedTrust or hWorld (defined later)
//
//            hOther = hRestrictedOther or (hRestrictedTrust == NULL) ? hWorld :
//                     hRestrictedTrust + hWorld
//
//            hWorld = hRoot + "CA" + "My" + "Trust" + rghAdditionalStore
//
//      dwFlags  - flags
//
//          CERT_CHAIN_CACHE_END_CERT - information will be cached on
//                                      the end cert as well as the other
//                                      certs in the chain
//
//          CERT_CHAIN_THREAD_STORE_SYNC - use separate thread for store syncs
//                                         and related cache updates
//
//          CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL - don't hit the wire to get
//                                                URL based objects
//
//      dwUrlRetrievalTimeout - timeout for wire based URL object retrievals
//                              (milliseconds)
//

#define CERT_CHAIN_CACHE_END_CERT           0x00000001
#define CERT_CHAIN_THREAD_STORE_SYNC        0x00000002
#define CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL 0x00000004
#define CERT_CHAIN_USE_LOCAL_MACHINE_STORE  0x00000008
#define CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE 0x00000010
#define CERT_CHAIN_ENABLE_SHARE_STORE       0x00000020

typedef struct _CERT_CHAIN_ENGINE_CONFIG {

    DWORD       cbSize;
    HCERTSTORE  hRestrictedRoot;
    HCERTSTORE  hRestrictedTrust;
    HCERTSTORE  hRestrictedOther;
    DWORD       cAdditionalStore;
    HCERTSTORE* rghAdditionalStore;
    DWORD       dwFlags;
    DWORD       dwUrlRetrievalTimeout;      // milliseconds
    DWORD       MaximumCachedCertificates;
    DWORD       CycleDetectionModulus;

} CERT_CHAIN_ENGINE_CONFIG, *PCERT_CHAIN_ENGINE_CONFIG;

WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertCreateCertificateChainEngine (
    __in PCERT_CHAIN_ENGINE_CONFIG pConfig,
    __out HCERTCHAINENGINE* phChainEngine
    );

//
// Free a certificate trust engine
//

WINCRYPT32API
VOID
WINAPI
CertFreeCertificateChainEngine (
    __in_opt HCERTCHAINENGINE hChainEngine
    );

//
// Resync the certificate chain engine.  This resync's the stores backing
// the engine and updates the engine caches.
//

WINCRYPT32API
BOOL
WINAPI
CertResyncCertificateChainEngine (
    __in_opt HCERTCHAINENGINE hChainEngine
    );

//
// When an application requests a certificate chain, the data structure
// returned is in the form of a CERT_CHAIN_CONTEXT.  This contains
// an array of CERT_SIMPLE_CHAIN where each simple chain goes from
// an end cert to a self signed cert and the chain context connects simple
// chains via trust lists.  Each simple chain contains the chain of
// certificates, summary trust information about the chain and trust information
// about each certificate element in the chain.
//

//
// Trust status bits
//

typedef struct _CERT_TRUST_STATUS {

    DWORD dwErrorStatus;
    DWORD dwInfoStatus;

} CERT_TRUST_STATUS, *PCERT_TRUST_STATUS;

//
// The following are error status bits
//

// These can be applied to certificates and chains

#define CERT_TRUST_NO_ERROR                             0x00000000
#define CERT_TRUST_IS_NOT_TIME_VALID                    0x00000001
#define CERT_TRUST_IS_NOT_TIME_NESTED                   0x00000002
#define CERT_TRUST_IS_REVOKED                           0x00000004
#define CERT_TRUST_IS_NOT_SIGNATURE_VALID               0x00000008
#define CERT_TRUST_IS_NOT_VALID_FOR_USAGE               0x00000010
#define CERT_TRUST_IS_UNTRUSTED_ROOT                    0x00000020
#define CERT_TRUST_REVOCATION_STATUS_UNKNOWN            0x00000040
#define CERT_TRUST_IS_CYCLIC                            0x00000080

#define CERT_TRUST_INVALID_EXTENSION                    0x00000100
#define CERT_TRUST_INVALID_POLICY_CONSTRAINTS           0x00000200
#define CERT_TRUST_INVALID_BASIC_CONSTRAINTS            0x00000400
#define CERT_TRUST_INVALID_NAME_CONSTRAINTS             0x00000800
#define CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT    0x00001000

// In LH, this error will never be set.
#define CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT      0x00002000

#define CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT    0x00004000
#define CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT         0x00008000

#define CERT_TRUST_IS_OFFLINE_REVOCATION                0x01000000
#define CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY             0x02000000
#define CERT_TRUST_IS_EXPLICIT_DISTRUST                 0x04000000
#define CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT       0x08000000


// These can be applied to chains only

#define CERT_TRUST_IS_PARTIAL_CHAIN                     0x00010000
#define CERT_TRUST_CTL_IS_NOT_TIME_VALID                0x00020000
#define CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID           0x00040000
#define CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE           0x00080000

//
// The following are info status bits
//

// These can be applied to certificates only

#define CERT_TRUST_HAS_EXACT_MATCH_ISSUER               0x00000001
#define CERT_TRUST_HAS_KEY_MATCH_ISSUER                 0x00000002
#define CERT_TRUST_HAS_NAME_MATCH_ISSUER                0x00000004
#define CERT_TRUST_IS_SELF_SIGNED                       0x00000008

// These can be applied to certificates and chains

#define CERT_TRUST_HAS_PREFERRED_ISSUER                 0x00000100
#define CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY            0x00000200
#define CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS           0x00000400
#define CERT_TRUST_IS_PEER_TRUSTED                      0x00000800
#define CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED            0x00001000

// These can be applied to chains only

#define CERT_TRUST_IS_COMPLEX_CHAIN                     0x00010000


//
// Each certificate context in a simple chain has a corresponding chain element
// in the simple chain context
//
// dwErrorStatus has CERT_TRUST_IS_REVOKED, pRevocationInfo set
// dwErrorStatus has CERT_TRUST_REVOCATION_STATUS_UNKNOWN, pRevocationInfo set

//
//         Note that the post processing revocation supported in the first
//         version only sets cbSize and dwRevocationResult.  Everything else
//         is NULL
//

//
// Revocation Information
//

typedef struct _CERT_REVOCATION_INFO {

    DWORD                       cbSize;
    DWORD                       dwRevocationResult;
    LPCSTR                      pszRevocationOid;
    LPVOID                      pvOidSpecificInfo;

    // fHasFreshnessTime is only set if we are able to retrieve revocation
    // information. For a CRL its CurrentTime - ThisUpdate.
    BOOL                        fHasFreshnessTime;
    DWORD                       dwFreshnessTime;    // seconds

    // NonNULL for CRL base revocation checking
    PCERT_REVOCATION_CRL_INFO   pCrlInfo;

} CERT_REVOCATION_INFO, *PCERT_REVOCATION_INFO;

//
// Trust List Information
//

typedef struct _CERT_TRUST_LIST_INFO {

    DWORD         cbSize;
    PCTL_ENTRY    pCtlEntry;
    PCCTL_CONTEXT pCtlContext;

} CERT_TRUST_LIST_INFO, *PCERT_TRUST_LIST_INFO;

//
// Chain Element
//

typedef struct _CERT_CHAIN_ELEMENT {

    DWORD                 cbSize;
    PCCERT_CONTEXT        pCertContext;
    CERT_TRUST_STATUS     TrustStatus;
    PCERT_REVOCATION_INFO pRevocationInfo;

    PCERT_ENHKEY_USAGE    pIssuanceUsage;       // If NULL, any
    PCERT_ENHKEY_USAGE    pApplicationUsage;    // If NULL, any

    LPCWSTR               pwszExtendedErrorInfo;    // If NULL, none
} CERT_CHAIN_ELEMENT, *PCERT_CHAIN_ELEMENT;

//
// The simple chain is an array of chain elements and a summary trust status
// for the chain
//
// rgpElements[0] is the end certificate chain element
//
// rgpElements[cElement-1] is the self-signed "root" certificate chain element
//

typedef struct _CERT_SIMPLE_CHAIN {

    DWORD                 cbSize;
    CERT_TRUST_STATUS     TrustStatus;
    DWORD                 cElement;
    PCERT_CHAIN_ELEMENT*  rgpElement;
    PCERT_TRUST_LIST_INFO pTrustListInfo;

    // fHasRevocationFreshnessTime is only set if we are able to retrieve
    // revocation information for all elements checked for revocation.
    // For a CRL its CurrentTime - ThisUpdate.
    //
    // dwRevocationFreshnessTime is the largest time across all elements
    // checked.
    BOOL                   fHasRevocationFreshnessTime;
    DWORD                  dwRevocationFreshnessTime;    // seconds

} CERT_SIMPLE_CHAIN, *PCERT_SIMPLE_CHAIN;

//
// And the chain context contains an array of simple chains and summary trust
// status for all the connected simple chains
//
// rgpChains[0] is the end certificate simple chain
//
// rgpChains[cChain-1] is the final (possibly trust list signer) chain which
// ends in a certificate which is contained in the root store
//

typedef struct _CERT_CHAIN_CONTEXT CERT_CHAIN_CONTEXT, *PCERT_CHAIN_CONTEXT;
typedef const CERT_CHAIN_CONTEXT *PCCERT_CHAIN_CONTEXT;

struct _CERT_CHAIN_CONTEXT {
    DWORD                   cbSize;
    CERT_TRUST_STATUS       TrustStatus;
    DWORD                   cChain;
    PCERT_SIMPLE_CHAIN*     rgpChain;

    // Following is returned when CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS
    // is set in dwFlags
    DWORD                   cLowerQualityChainContext;
    PCCERT_CHAIN_CONTEXT*   rgpLowerQualityChainContext;

    // fHasRevocationFreshnessTime is only set if we are able to retrieve
    // revocation information for all elements checked for revocation.
    // For a CRL its CurrentTime - ThisUpdate.
    //
    // dwRevocationFreshnessTime is the largest time across all elements
    // checked.
    BOOL                    fHasRevocationFreshnessTime;
    DWORD                   dwRevocationFreshnessTime;    // seconds

    // Flags passed when created via CertGetCertificateChain
    DWORD                   dwCreateFlags;

    // Following is updated with unique Id when the chain context is logged.
    GUID                    ChainId;
};


//
// When building a chain, the there are various parameters used for finding
// issuing certificates and trust lists.  They are identified in the
// following structure
//

// Default usage match type is AND with value zero
#define USAGE_MATCH_TYPE_AND 0x00000000
#define USAGE_MATCH_TYPE_OR  0x00000001

typedef struct _CERT_USAGE_MATCH {

    DWORD             dwType;
    CERT_ENHKEY_USAGE Usage;

} CERT_USAGE_MATCH, *PCERT_USAGE_MATCH;

typedef struct _CTL_USAGE_MATCH {

    DWORD     dwType;
    CTL_USAGE Usage;

} CTL_USAGE_MATCH, *PCTL_USAGE_MATCH;

typedef struct _CERT_CHAIN_PARA {

    DWORD            cbSize;
    CERT_USAGE_MATCH RequestedUsage;

#ifdef CERT_CHAIN_PARA_HAS_EXTRA_FIELDS

    // Note, if you #define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS, then, you
    // must zero all unused fields in this data structure.
    // More fields could be added in a future release.

    CERT_USAGE_MATCH RequestedIssuancePolicy;
    DWORD            dwUrlRetrievalTimeout;     // milliseconds
    BOOL             fCheckRevocationFreshnessTime;
    DWORD            dwRevocationFreshnessTime; // seconds

    // If nonNULL, any cached information before this time is considered
    // time invalid and forces a wire retrieval. When set overrides
    // the registry configuration CacheResync time.
    LPFILETIME                  pftCacheResync;

#endif

} CERT_CHAIN_PARA, *PCERT_CHAIN_PARA;

//
// The following API is used for retrieving certificate chains
//
// Parameters:
//
//      hChainEngine     - the chain engine (namespace and cache) to use, NULL
//                         mean use the default chain engine
//
//      pCertContext     - the context we are retrieving the chain for, it
//                         will be the zero index element in the chain
//
//      pTime            - the point in time that we want the chain validated
//                         for.  Note that the time does not affect trust list,
//                         revocation, or root store checking.  NULL means use
//                         the current system time
//
//      hAdditionalStore - additional store to use when looking up objects
//
//      pChainPara       - parameters for chain building
//
//      dwFlags          - flags such as should revocation checking be done
//                         on the chain?
//
//      pvReserved       - reserved parameter, must be NULL
//
//      ppChainContext   - chain context returned
//

// CERT_CHAIN_CACHE_END_CERT can be used here as well
// Revocation flags are in the high nibble
#define CERT_CHAIN_REVOCATION_CHECK_END_CERT           0x10000000
#define CERT_CHAIN_REVOCATION_CHECK_CHAIN              0x20000000
#define CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x40000000
#define CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY         0x80000000

// By default, the dwUrlRetrievalTimeout in pChainPara is the timeout used
// for each revocation URL wire retrieval. When the following flag is set,
// dwUrlRetrievalTimeout is the accumulative timeout across all
// revocation URL wire retrievals.
#define CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT     0x08000000


// First pass determines highest quality based upon:
//  - Chain signature valid (higest quality bit of this set)
//  - Complete chain
//  - Trusted root          (lowestest quality bit of this set)
// By default, second pass only considers paths >= highest first pass quality
#define CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING  0x00000040

#define CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS    0x00000080

#define CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE    0x00000100


// When this flag is set, pTime will be used as the timestamp time.
// pTime will be used to determine if the end certificate was valid at this
// time. Revocation checking will be relative to pTime.
// In addition, current time will also be used
// to determine if the certificate is still time valid. All remaining
// CA and root certificates will be checked using current time and not pTime.
//
// This flag was added 4/5/01 in WXP.
#define CERT_CHAIN_TIMESTAMP_TIME                   0x00000200


// When this flag is set, "My" certificates having a private key or end
// entity certificates in the "TrustedPeople" store are trusted without
// doing any chain building. Neither the CERT_TRUST_IS_PARTIAL_CHAIN or
// CERT_TRUST_IS_UNTRUSTED_ROOT dwErrorStatus bits will be set for
// such certificates.
//
// This flag was added 6/9/03 in LH.
#define CERT_CHAIN_ENABLE_PEER_TRUST                0x00000400

// When this flag is set, "My" certificates aren't considered for
// PEER_TRUST.
//
// This flag was added 11/12/04 in LH.
//
// On 8-05-05 changed to never consider "My" certificates for PEER_TRUST.
#define CERT_CHAIN_DISABLE_MY_PEER_TRUST            0x00000800

WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertGetCertificateChain (
    __in_opt HCERTCHAINENGINE hChainEngine,
    __in PCCERT_CONTEXT pCertContext,
    __in_opt LPFILETIME pTime,
    __in_opt HCERTSTORE hAdditionalStore,
    __in PCERT_CHAIN_PARA pChainPara,
    __in DWORD dwFlags,
    __reserved LPVOID pvReserved,
    __out PCCERT_CHAIN_CONTEXT* ppChainContext
    );

//
// Free a certificate chain
//

WINCRYPT32API
VOID
WINAPI
CertFreeCertificateChain (
    __in PCCERT_CHAIN_CONTEXT pChainContext
    );

//
// Duplicate (add a reference to) a certificate chain
//

WINCRYPT32API
PCCERT_CHAIN_CONTEXT
WINAPI
CertDuplicateCertificateChain (
    __in PCCERT_CHAIN_CONTEXT pChainContext
    );

//
// Specific Revocation Type OID and structure definitions
//

//
// CRL Revocation OID
//

#define REVOCATION_OID_CRL_REVOCATION ((LPCSTR)1)

//
// For the CRL revocation OID the pvRevocationPara is NULL
//

//
// CRL Revocation Info
//

typedef struct _CRL_REVOCATION_INFO {

    PCRL_ENTRY           pCrlEntry;
    PCCRL_CONTEXT        pCrlContext;
    PCCERT_CHAIN_CONTEXT pCrlIssuerChain;

} CRL_REVOCATION_INFO, *PCRL_REVOCATION_INFO;

//+-------------------------------------------------------------------------
//  Find the first or next certificate chain context in the store.
//
//  The chain context is found according to the dwFindFlags, dwFindType and
//  its pvFindPara. See below for a list of the find types and its parameters.
//
//  If the first or next chain context isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CHAIN_CONTEXT is returned.
//  CERT_CHAIN_CONTEXT must be freed by calling CertFreeCertificateChain
//  or is freed when passed as the
//  pPrevChainContext on a subsequent call. CertDuplicateCertificateChain
//  can be called to make a duplicate.
//
//  pPrevChainContext MUST BE NULL on the first
//  call to find the chain context. To find the next chain context, the
//  pPrevChainContext is set to the CERT_CHAIN_CONTEXT returned by a previous
//  call.
//
//  NOTE: a NON-NULL pPrevChainContext is always CertFreeCertificateChain'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_CHAIN_CONTEXT
WINAPI
CertFindChainInStore(
    __in HCERTSTORE hCertStore,
    __in DWORD dwCertEncodingType,
    __in DWORD dwFindFlags,
    __in DWORD dwFindType,
    __in_opt const void *pvFindPara,
    __in_opt PCCERT_CHAIN_CONTEXT pPrevChainContext
    );

#define CERT_CHAIN_FIND_BY_ISSUER       1


//+-------------------------------------------------------------------------
//  CERT_CHAIN_FIND_BY_ISSUER
//
//  Find a certificate chain having a private key for the end certificate and
//  matching one of the given issuer names. A matching dwKeySpec and
//  enhanced key usage can also be specified. Additionally a callback can
//  be provided for even more caller provided filtering before building the
//  chain.
//
//  By default, only the issuers in the first simple chain are compared
//  for a name match. CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG can
//  be set in dwFindFlags to match issuers in all the simple chains.
//
//  CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG can be set in dwFindFlags to
//  not check if the end certificate has a private key.
//
//  CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG can be set in dwFindFlags
//  to compare the public key in the end certificate with the crypto
//  provider's public key. The dwAcquirePrivateKeyFlags can be set
//  in CERT_CHAIN_FIND_BY_ISSUER_PARA to enable caching of the private key's
//  HKEY returned by the CSP.
//
//  If dwCertEncodingType == 0, defaults to X509_ASN_ENCODING for the
//  array of encoded issuer names.
//
//  By default, the hCertStore passed to CertFindChainInStore, is passed
//  as an additional store to CertGetCertificateChain.
//  CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG can be set in dwFindFlags
//  to improve performance by only searching the cached system stores
//  (root, my, ca, trust) to find the issuer certificates. If you are doing
//  a find in the "my" system store, than, this flag should be set to
//  improve performance.
//
//  Setting CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG in dwFindFlags
//  restricts CertGetCertificateChain to search the Local Machine
//  cached system stores instead of the Current User's.
//
//  Setting CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG in dwFindFlags
//  restricts CertGetCertificateChain to only search the URL cache
//  and not hit the wire.
//--------------------------------------------------------------------------

// Returns FALSE to skip this certificate. Otherwise, returns TRUE to
// build a chain for this certificate.
typedef BOOL (WINAPI *PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK)(
    __in PCCERT_CONTEXT pCert,
    __inout_opt void *pvFindArg
    );

typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
    DWORD                                   cbSize;

    // If pszUsageIdentifier == NULL, matches any usage.
    LPCSTR                                  pszUsageIdentifier;

    // If dwKeySpec == 0, matches any KeySpec
    DWORD                                   dwKeySpec;

    // When CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG is set in dwFindFlags,
    // CryptAcquireCertificatePrivateKey is called to do the public key
    // comparison. The following flags can be set to enable caching
    // of the acquired private key or suppress CSP UI. See the API for more
    // details on these flags.
    DWORD                                   dwAcquirePrivateKeyFlags;

    // Pointer to an array of X509, ASN.1 encoded issuer name blobs. If
    // cIssuer == 0, matches any issuer
    DWORD                                   cIssuer;
    CERT_NAME_BLOB                          *rgIssuer;

    // If NULL or Callback returns TRUE, builds the chain for the end
    // certificate having a private key with the specified KeySpec and
    // enhanced key usage.
    PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
    void                                    *pvFindArg;

#ifdef CERT_CHAIN_FIND_BY_ISSUER_PARA_HAS_EXTRA_FIELDS
    // Note, if you #define CERT_CHAIN_FIND_BY_ISSUER_PARA_HAS_EXTRA_FIELDS,
    // then, you must zero all unused fields in this data structure.
    // More fields could be added in a future release.

    // If the following pointers are nonNull, returns the index of the
    // matching issuer certificate, which is at:
    // pChainContext->
    //      rgpChain[*pdwIssuerChainIndex]->rgpElement[*pdwIssuerElementIndex].
    //
    // The issuer name blob is compared against the Issuer field in the
    // certificate. The *pdwIssuerElementIndex is set to the index of this
    // subject certificate + 1. Therefore, its possible for a partial chain or
    // a self signed certificate matching the name blob, where
    // *pdwIssuerElementIndex points past the last certificate in the chain.
    //
    // Note, not updated if the above cIssuer == 0.
    DWORD                                   *pdwIssuerChainIndex;
    DWORD                                   *pdwIssuerElementIndex;
#endif
} CERT_CHAIN_FIND_ISSUER_PARA, *PCERT_CHAIN_FIND_ISSUER_PARA,
    CERT_CHAIN_FIND_BY_ISSUER_PARA, *PCERT_CHAIN_FIND_BY_ISSUER_PARA;

// The following dwFindFlags can be set for CERT_CHAIN_FIND_BY_ISSUER

// If set, compares the public key in the end certificate with the crypto
// provider's public key. This comparison is the last check made on the
// build chain.
#define CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG          0x0001

// If not set, only checks the first simple chain for an issuer name match.
// When set, also checks second and subsequent simple chains.
#define CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG        0x0002

// If set, CertGetCertificateChain only searches the URL cache and
// doesn't hit the wire.
#define CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG       0x0004

// If set, CertGetCertificateChain only opens the Local Machine
// certificate stores instead of the Current User's.
#define CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG        0x0008

// If set, no check is made to see if the end certificate has a private
// key associated with it.
#define CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG               0x4000


// By default, the hCertStore passed to CertFindChainInStore, is passed
// as the additional store to CertGetCertificateChain. This flag can be
// set to improve performance by only searching the cached system stores
// (root, my, ca, trust) to find the issuer certificates. If not set, then,
// the hCertStore is always searched in addition to the cached system
// stores.
#define CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG           0x8000



//+=========================================================================
//  Certificate Chain Policy Data Structures and APIs
//==========================================================================
typedef struct _CERT_CHAIN_POLICY_PARA {
    DWORD                   cbSize;
    DWORD                   dwFlags;
    void                    *pvExtraPolicyPara;     // pszPolicyOID specific
} CERT_CHAIN_POLICY_PARA, *PCERT_CHAIN_POLICY_PARA;

// If both lChainIndex and lElementIndex are set to -1, the dwError applies
// to the whole chain context. If only lElementIndex is set to -1, the
// dwError applies to the lChainIndex'ed chain. Otherwise, the dwError applies
// to the certificate element at
// pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
typedef struct _CERT_CHAIN_POLICY_STATUS {
    DWORD                   cbSize;
    DWORD                   dwError;
    LONG                    lChainIndex;
    LONG                    lElementIndex;
    void                    *pvExtraPolicyStatus;   // pszPolicyOID specific
} CERT_CHAIN_POLICY_STATUS, *PCERT_CHAIN_POLICY_STATUS;

// Common chain policy flags
#define CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG                0x00000001
#define CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG            0x00000002
#define CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG               0x00000004
#define CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG     0x00000008

#define CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS ( \
    CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG                | \
    CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG            | \
    CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG                 \
    )


#define CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG                     0x00000010
#define CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG                   0x00000020
#define CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG                  0x00000040
#define CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG                0x00000080

#define CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG               0x00000100
#define CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG        0x00000200
#define CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG                0x00000400
#define CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG              0x00000800

#define CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS ( \
    CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG         | \
    CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG  | \
    CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG          | \
    CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG          \
    )

#define CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG                       0x00008000
#define CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG                       0x00004000

#define CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG    0x00002000
#define CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG                    0x00001000


//+-------------------------------------------------------------------------
//  Verify that the certificate chain satisfies the specified policy
//  requirements. If we were able to verify the chain policy, TRUE is returned
//  and the dwError field of the pPolicyStatus is updated. A dwError of 0
//  (ERROR_SUCCESS, S_OK) indicates the chain satisfies the specified policy.
//
//  If dwError applies to the entire chain context, both lChainIndex and
//  lElementIndex are set to -1. If dwError applies to a simple chain,
//  lElementIndex is set to -1 and lChainIndex is set to the index of the
//  first offending chain having the error. If dwError applies to a
//  certificate element, lChainIndex and lElementIndex are updated to
//  index the first offending certificate having the error, where, the
//  the certificate element is at:
//      pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
//
//  The dwFlags in pPolicyPara can be set to change the default policy checking
//  behaviour. In addition, policy specific parameters can be passed in
//  the pvExtraPolicyPara field of pPolicyPara.
//
//  In addition to returning dwError, in pPolicyStatus, policy OID specific
//  extra status may be returned via pvExtraPolicyStatus.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    __in LPCSTR pszPolicyOID,
    __in PCCERT_CHAIN_CONTEXT pChainContext,
    __in PCERT_CHAIN_POLICY_PARA pPolicyPara,
    __inout PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

// Predefined OID Function Names
#define CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC  \
    "CertDllVerifyCertificateChainPolicy"

// CertDllVerifyCertificateChainPolicy has same function signature as
// CertVerifyCertificateChainPolicy.

//+-------------------------------------------------------------------------
//  Predefined verify chain policies
//--------------------------------------------------------------------------
#define CERT_CHAIN_POLICY_BASE              ((LPCSTR) 1)
#define CERT_CHAIN_POLICY_AUTHENTICODE      ((LPCSTR) 2)
#define CERT_CHAIN_POLICY_AUTHENTICODE_TS   ((LPCSTR) 3)
#define CERT_CHAIN_POLICY_SSL               ((LPCSTR) 4)
#define CERT_CHAIN_POLICY_BASIC_CONSTRAINTS ((LPCSTR) 5)
#define CERT_CHAIN_POLICY_NT_AUTH           ((LPCSTR) 6)
#define CERT_CHAIN_POLICY_MICROSOFT_ROOT    ((LPCSTR) 7)

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_BASE
//
//  Implements the base chain policy verification checks. dwFlags can
//  be set in pPolicyPara to alter the default policy checking behaviour.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_AUTHENTICODE
//
//  Implements the Authenticode chain policy verification checks.
//
//  pvExtraPolicyPara may optionally be set to point to the following
//  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA.
//
//  pvExtraPolicyStatus may optionally be set to point to the following
//  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS.
//--------------------------------------------------------------------------

// dwRegPolicySettings are defined in wintrust.h
typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
    DWORD               cbSize;
    DWORD               dwRegPolicySettings;
    PCMSG_SIGNER_INFO   pSignerInfo;                // optional
} AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
    *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;

typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS {
    DWORD               cbSize;
    BOOL                fCommercial;        // obtained from signer statement
} AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS,
    *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_AUTHENTICODE_TS
//
//  Implements the Authenticode Time Stamp chain policy verification checks.
//
//  pvExtraPolicyPara may optionally be set to point to the following
//  AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA.
//
//  pvExtraPolicyStatus isn't used and must be set to NULL.
//--------------------------------------------------------------------------

// dwRegPolicySettings are defined in wintrust.h
typedef struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA {
    DWORD               cbSize;
    DWORD               dwRegPolicySettings;
    BOOL                fCommercial;
} AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA,
    *PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;


//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_SSL
//
//  Implements the SSL client/server chain policy verification checks.
//
//  pvExtraPolicyPara may optionally be set to point to the following
//  SSL_EXTRA_CERT_CHAIN_POLICY_PARA data structure
//--------------------------------------------------------------------------

// fdwChecks flags are defined in wininet.h
typedef struct _HTTPSPolicyCallbackData
{
    union {
        DWORD           cbStruct;       // sizeof(HTTPSPolicyCallbackData);
        DWORD           cbSize;         // sizeof(HTTPSPolicyCallbackData);
    };

    DWORD           dwAuthType;
#                       define      AUTHTYPE_CLIENT         1
#                       define      AUTHTYPE_SERVER         2

    DWORD           fdwChecks;

    WCHAR           *pwszServerName; // used to check against CN=xxxx

} HTTPSPolicyCallbackData, *PHTTPSPolicyCallbackData,
    SSL_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA;

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_BASIC_CONSTRAINTS
//
//  Implements the basic constraints chain policy.
//
//  Iterates through all the certificates in the chain checking for either
//  a szOID_BASIC_CONSTRAINTS or a szOID_BASIC_CONSTRAINTS2 extension. If
//  neither extension is present, the certificate is assumed to have
//  valid policy. Otherwise, for the first certificate element, checks if
//  it matches the expected CA_FLAG or END_ENTITY_FLAG specified in
//  pPolicyPara->dwFlags. If neither or both flags are set, then, the first
//  element can be either a CA or END_ENTITY. All other elements must be
//  a CA. If the PathLenConstraint is present in the extension, its
//  checked.
//
//  The first elements in the remaining simple chains (ie, the certificate
//  used to sign the CTL) are checked to be an END_ENTITY.
//
//  If this verification fails, dwError will be set to
//  TRUST_E_BASIC_CONSTRAINTS.
//--------------------------------------------------------------------------

#define BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG         0x80000000
#define BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG 0x40000000

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_NT_AUTH
//
//  Implements the NT Authentication chain policy.
//
//  The NT Authentication chain policy consists of 3 distinct chain
//  verifications in the following order:
//      [1] CERT_CHAIN_POLICY_BASE - Implements the base chain policy
//          verification checks. The LOWORD of dwFlags can be set in
//          pPolicyPara to alter the default policy checking behaviour. See
//          CERT_CHAIN_POLICY_BASE for more details.
//
//      [2] CERT_CHAIN_POLICY_BASIC_CONSTRAINTS - Implements the basic
//          constraints chain policy. The HIWORD of dwFlags can be set
//          to specify if the first element must be either a CA or END_ENTITY.
//          See CERT_CHAIN_POLICY_BASIC_CONSTRAINTS for more details.
//
//      [3] Checks if the second element in the chain, the CA that issued
//          the end certificate, is a trusted CA for NT
//          Authentication. A CA is considered to be trusted if it exists in
//          the "NTAuth" system registry store found in the
//          CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location.
//          If this verification fails, whereby the CA isn't trusted,
//          dwError is set to CERT_E_UNTRUSTEDCA.
//
//          If CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG is set
//          in the "Flags" value of the HKLM policy "ProtectedRoots" subkey
//          defined by CERT_PROT_ROOT_FLAGS_REGPATH, then,
//          if the above check fails, checks if the chain
//          has CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS set in dwInfoStatus. This
//          will only be set if there was a valid name constraint for all
//          name spaces including UPN. If the chain doesn't have this info
//          status set, dwError is set to CERT_E_UNTRUSTEDCA.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_CHAIN_POLICY_MICROSOFT_ROOT
//
//  Checks if the last element of the first simple chain contains a
//  Microsoft root public key. If it doesn't contain a Microsoft root
//  public key, dwError is set to CERT_E_UNTRUSTEDROOT.
//
//  pPolicyPara is optional. However,
//  MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG can be set in
//  the dwFlags in pPolicyPara to also check for the Microsoft Test Roots.
//
//  pvExtraPolicyPara and pvExtraPolicyStatus aren't used and must be set
//  to NULL.
//--------------------------------------------------------------------------
#define MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG 0x00010000



//+-------------------------------------------------------------------------
// convert formatted string to binary
// If cchString is 0, then pszString is NULL terminated and
// cchString is obtained via strlen() + 1.
// dwFlags defines string format
// if pbBinary is NULL, *pcbBinary returns the size of required memory
// *pdwSkip returns the character count of skipped strings, optional
// *pdwFlags returns the actual format used in the conversion, optional
//--------------------------------------------------------------------------
WINCRYPT32STRINGAPI
BOOL
WINAPI
CryptStringToBinaryA(
    __in_ecount(cchString) LPCSTR pszString,
    __in DWORD cchString,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbBinary, *pcbBinary) BYTE *pbBinary,
    __inout DWORD  *pcbBinary,
    __out_opt DWORD *pdwSkip,
    __out_opt DWORD *pdwFlags
    );
//+-------------------------------------------------------------------------
// convert formatted string to binary
// If cchString is 0, then pszString is NULL terminated and
// cchString is obtained via strlen() + 1.
// dwFlags defines string format
// if pbBinary is NULL, *pcbBinary returns the size of required memory
// *pdwSkip returns the character count of skipped strings, optional
// *pdwFlags returns the actual format used in the conversion, optional
//--------------------------------------------------------------------------
WINCRYPT32STRINGAPI
BOOL
WINAPI
CryptStringToBinaryW(
    __in_ecount(cchString) LPCWSTR pszString,
    __in DWORD cchString,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*pcbBinary, *pcbBinary) BYTE *pbBinary,
    __inout DWORD  *pcbBinary,
    __out_opt DWORD *pdwSkip,
    __out_opt DWORD *pdwFlags
    );
#ifdef UNICODE
#define CryptStringToBinary  CryptStringToBinaryW
#else
#define CryptStringToBinary  CryptStringToBinaryA
#endif // !UNICODE

//+-------------------------------------------------------------------------
// convert binary to formatted string
// dwFlags defines string format
// if pszString is NULL, *pcchString returns size in characters
// including null-terminator
//--------------------------------------------------------------------------
WINCRYPT32STRINGAPI
BOOL
WINAPI
CryptBinaryToStringA(
    __in_bcount(cbBinary) CONST BYTE *pbBinary,
    __in DWORD cbBinary,
    __in DWORD dwFlags,
    __out_ecount_part_opt(*pcchString, *pcchString) LPSTR pszString,
    __inout DWORD *pcchString
    );
//+-------------------------------------------------------------------------
// convert binary to formatted string
// dwFlags defines string format
// if pszString is NULL, *pcchString returns size in characters
// including null-terminator
//--------------------------------------------------------------------------
WINCRYPT32STRINGAPI
BOOL
WINAPI
CryptBinaryToStringW(
    __in_bcount(cbBinary) CONST BYTE *pbBinary,
    __in DWORD cbBinary,
    __in DWORD dwFlags,
    __out_ecount_part_opt(*pcchString, *pcchString) LPWSTR pszString,
    __inout DWORD *pcchString
    );
#ifdef UNICODE
#define CryptBinaryToString  CryptBinaryToStringW
#else
#define CryptBinaryToString  CryptBinaryToStringA
#endif // !UNICODE

// dwFlags has the following defines
// certenrolld_begin -- CRYPT_STRING_*
#define CRYPT_STRING_BASE64HEADER           0x00000000
#define CRYPT_STRING_BASE64                 0x00000001
#define CRYPT_STRING_BINARY                 0x00000002
#define CRYPT_STRING_BASE64REQUESTHEADER    0x00000003
#define CRYPT_STRING_HEX                    0x00000004
#define CRYPT_STRING_HEXASCII               0x00000005
#define CRYPT_STRING_BASE64_ANY             0x00000006
#define CRYPT_STRING_ANY                    0x00000007
#define CRYPT_STRING_HEX_ANY                0x00000008
#define CRYPT_STRING_BASE64X509CRLHEADER    0x00000009
#define CRYPT_STRING_HEXADDR                0x0000000a
#define CRYPT_STRING_HEXASCIIADDR           0x0000000b
#define CRYPT_STRING_HEXRAW                 0x0000000c

#define CRYPT_STRING_NOCRLF                 0x40000000
#define CRYPT_STRING_NOCR                   0x80000000
// certenrolld_end

// CryptBinaryToString uses the following flags
// CRYPT_STRING_BASE64HEADER - base64 format with certificate begin
//                             and end headers
// CRYPT_STRING_BASE64 - only base64 without headers
// CRYPT_STRING_BINARY - pure binary copy
// CRYPT_STRING_BASE64REQUESTHEADER - base64 format with request begin
//                                    and end headers
// CRYPT_STRING_BASE64X509CRLHEADER - base64 format with x509 crl begin
//                                    and end headers
// CRYPT_STRING_HEX - only hex format
// CRYPT_STRING_HEXASCII - hex format with ascii char display
// CRYPT_STRING_HEXADDR - hex format with address display
// CRYPT_STRING_HEXASCIIADDR - hex format with ascii char and address display
//
// CryptBinaryToString accepts CRYPT_STRING_NOCR or'd into one of the above.
// When set, line breaks contain only LF, instead of CR-LF pairs.

// CryptStringToBinary uses the following flags
// CRYPT_STRING_BASE64_ANY tries the following, in order:
//    CRYPT_STRING_BASE64HEADER
//    CRYPT_STRING_BASE64
// CRYPT_STRING_ANY tries the following, in order:
//    CRYPT_STRING_BASE64_ANY
//    CRYPT_STRING_BINARY -- should always succeed
// CRYPT_STRING_HEX_ANY tries the following, in order:
//    CRYPT_STRING_HEXADDR
//    CRYPT_STRING_HEXASCIIADDR
//    CRYPT_STRING_HEXASCII
//    CRYPT_STRING_HEX


//+=========================================================================
//  PFX (PKCS #12) function definitions and types
//==========================================================================

//+-------------------------------------------------------------------------
//  PKCS#12 OIDs
//--------------------------------------------------------------------------

#define szOID_PKCS_12_PbeIds                        "1.2.840.113549.1.12.1"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC4       "1.2.840.113549.1.12.1.1"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC4        "1.2.840.113549.1.12.1.2"
#define szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES   "1.2.840.113549.1.12.1.3"
#define szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES   "1.2.840.113549.1.12.1.4"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC2       "1.2.840.113549.1.12.1.5"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC2        "1.2.840.113549.1.12.1.6"


//+-------------------------------------------------------------------------
//  PBE parameters as defined in PKCS#12 as pkcs-12PbeParams.
//
//  NOTE that the salt bytes will immediately follow this structure.
//  we avoid using pointers in this structure for easy of passing
//  it into NCryptExportKey() as a NCryptBuffer (may be sent via RPC
//  to the key isolation process).
//--------------------------------------------------------------------------
typedef struct _CRYPT_PKCS12_PBE_PARAMS
{
    int                 iIterations;        /* iteration count              */
    ULONG               cbSalt;             /* byte size of the salt        */
}
CRYPT_PKCS12_PBE_PARAMS;

//+-------------------------------------------------------------------------
//      PFXImportCertStore
//
//  Import the PFX blob and return a store containing certificates
//
//  If the password parameter is incorrect or any other problems decoding
//  the PFX blob are encountered, the function will return NULL and the
//      error code can be found from GetLastError().
//
//  The dwFlags parameter may be set to the following:
//  CRYPT_EXPORTABLE - specify that any imported keys should be marked as
//                     exportable (see documentation on CryptImportKey)
//  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
//  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
//                        the local machine and not the current user.
//  CRYPT_USER_KEYSET - used to force the private key to be stored in the
//                      the current user and not the local machine, even if
//                      the pfx blob specifies that it should go into local
//                      machine.
//  PKCS12_INCLUDE_EXTENDED_PROPERTIES - used to import all extended
//                     properties that were saved with CertExportCertStore()
//                     using the same flag.
//--------------------------------------------------------------------------
WINCRYPT32API
HCERTSTORE
WINAPI
PFXImportCertStore(
    __in CRYPT_DATA_BLOB* pPFX,
    __in LPCWSTR szPassword,
    __in DWORD   dwFlags);

// dwFlags definitions for PFXImportCertStore
//#define CRYPT_EXPORTABLE          0x00000001  // CryptImportKey dwFlags
//#define CRYPT_USER_PROTECTED      0x00000002  // CryptImportKey dwFlags
//#define CRYPT_MACHINE_KEYSET      0x00000020  // CryptAcquireContext dwFlags
//#define PKCS12_INCLUDE_EXTENDED_PROPERTIES 0x10
#define CRYPT_USER_KEYSET           0x00001000
#define PKCS12_PREFER_CNG_KSP       0x00000100  // prefer using CNG KSP
#define PKCS12_ALWAYS_CNG_KSP       0x00000200  // always use CNG KSP
#define PKCS12_ALLOW_OVERWRITE_KEY  0x00004000  // allow overwrite existing key
#define PKCS12_NO_PERSIST_KEY       0x00008000  // key will not be persisted
#define PKCS12_IMPORT_RESERVED_MASK 0xffff0000


//+-------------------------------------------------------------------------
//      PFXIsPFXBlob
//
//  This function will try to decode the outer layer of the blob as a pfx
//  blob, and if that works it will return TRUE, it will return FALSE otherwise
//
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
PFXIsPFXBlob(
    __in CRYPT_DATA_BLOB* pPFX);



//+-------------------------------------------------------------------------
//      PFXVerifyPassword
//
//  This function will attempt to decode the outer layer of the blob as a pfx
//  blob and decrypt with the given password. No data from the blob will be
//  imported.
//
//  Return value is TRUE if password appears correct, FALSE otherwise.
//
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
PFXVerifyPassword(
    __in CRYPT_DATA_BLOB* pPFX,
    __in LPCWSTR szPassword,
    __in DWORD dwFlags);


//+-------------------------------------------------------------------------
//      PFXExportCertStoreEx
//
//  Export the certificates and private keys referenced in the passed-in store
//
//  This API encodes the blob under a stronger algorithm. The resulting
//  PKCS12 blobs are incompatible with the earlier PFXExportCertStore API.
//
//  The value passed in the password parameter will be used to encrypt and
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can
//  be found from GetLastError().
//
//  The dwFlags parameter may be set to any combination of
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//      PKCS12_INCLUDE_EXTENDED_PROPERTIES
//
//  The encoded PFX blob is returned in *pPFX. If pPFX->pbData is NULL upon
//  input, this is a length only calculation, whereby, pPFX->cbData is updated
//  with the number of bytes required for the encoded blob. Otherwise,
//  the memory pointed to by pPFX->pbData is updated with the encoded bytes
//  and pPFX->cbData is updated with the encoded byte length.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
PFXExportCertStoreEx(
    __in HCERTSTORE hStore,
    __inout CRYPT_DATA_BLOB* pPFX,
    __in LPCWSTR szPassword,
    __reserved void* pvReserved,
    __in DWORD dwFlags);


// dwFlags definitions for PFXExportCertStoreEx
#define REPORT_NO_PRIVATE_KEY                   0x0001
#define REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY   0x0002
#define EXPORT_PRIVATE_KEYS                     0x0004
#define PKCS12_INCLUDE_EXTENDED_PROPERTIES      0x0010
#define PKCS12_EXPORT_RESERVED_MASK             0xffff0000


//+-------------------------------------------------------------------------
//      PFXExportCertStore
//
//  Export the certificates and private keys referenced in the passed-in store
//
//  This is an old API kept for compatibility with IE4 clients. New applications
//  should call the above PfxExportCertStoreEx for enhanced security.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
PFXExportCertStore(
    __in HCERTSTORE hStore,
    __inout CRYPT_DATA_BLOB* pPFX,
    __in LPCWSTR szPassword,
    __in DWORD dwFlags);


//+=========================================================================
//  APIs to get a non-blocking, time valid OCSP response for
//  a server certificate chain.
//
//  Normally, this OCSP response will be included along with the server
//  certificate in a message returned to the client. As a result only the
//  server should need to contact the OCSP responser for its certificate.
//==========================================================================

//+-------------------------------------------------------------------------
//  Server OCSP response handle.
//--------------------------------------------------------------------------
typedef VOID *HCERT_SERVER_OCSP_RESPONSE;

//+-------------------------------------------------------------------------
//  Open a handle to an OCSP response associated with a server certificate
//  chain. If the end certificate doesn't have an OCSP AIA URL, NULL is
//  returned with LastError set to CRYPT_E_NOT_IN_REVOCATION_DATABASE. NULL
//  will also be returned if unable to allocate memory or create system
//  objects.
//
//  This API will try to retrieve an initial OCSP response before returning.
//  This API will block during the retrieval. If unable to successfully
//  retrieve the first OCSP response, a non-NULL handle will still be returned
//  if not one of the error cases mentioned above.
//
//  A background thread is created that will pre-fetch time valid
//  OCSP responses.
//
//  The input chain context will be AddRef'ed and not freed until
//  the returned handle is closed.
//
//  CertCloseServerOcspResponse() must be called to close the returned
//  handle.
//
//  dwFlags and pvReserved aren't currently used and must be set to 0
//  and NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
HCERT_SERVER_OCSP_RESPONSE
WINAPI
CertOpenServerOcspResponse(
    __in PCCERT_CHAIN_CONTEXT pChainContext,
    __in DWORD dwFlags,
    __reserved LPVOID pvReserved
    );

//+-------------------------------------------------------------------------
//  AddRef a HCERT_SERVER_OCSP_RESPONSE returned by
//  CertOpenServerOcspResponse(). Each Open and AddRef requires a
//  corresponding CertCloseServerOcspResponse().
//--------------------------------------------------------------------------
WINCRYPT32API
VOID
WINAPI
CertAddRefServerOcspResponse(
    __in_opt HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse
    );

//+-------------------------------------------------------------------------
//  Close the handle returned by CertOpenServerOcspResponse() or AddRef'ed
//  by CertAddRefServerOcspResponse().
//
//  dwFlags isn't currently used and must be set to 0.
//--------------------------------------------------------------------------
WINCRYPT32API
VOID
WINAPI
CertCloseServerOcspResponse(
    __in_opt HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse,
    __in DWORD dwFlags
    );


//+-------------------------------------------------------------------------
//  Server OCSP response context.
//--------------------------------------------------------------------------
typedef struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT
    CERT_SERVER_OCSP_RESPONSE_CONTEXT,
    *PCERT_SERVER_OCSP_RESPONSE_CONTEXT;
typedef const CERT_SERVER_OCSP_RESPONSE_CONTEXT
    *PCCERT_SERVER_OCSP_RESPONSE_CONTEXT;

struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT {
    DWORD       cbSize;
    BYTE        *pbEncodedOcspResponse;
    DWORD       cbEncodedOcspResponse;
};

//+-------------------------------------------------------------------------
//  Get a time valid OCSP response context for the handle created for
//  the server certificate chain.
//
//  This API won't block to retrieve the OCSP response. It will return
//  the current pre-fetched OCSP response. If a time valid OCSP response
//  isn't available, NULL will be returned with LAST_ERROR set to
//  CRYPT_E_REVOCATION_OFFLINE.
//
//  CertFreeServerOcspResponseContext() must be called to free the
//  returned OCSP response context.
//--------------------------------------------------------------------------
WINCRYPT32API
PCCERT_SERVER_OCSP_RESPONSE_CONTEXT
WINAPI
CertGetServerOcspResponseContext(
    __in HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse,
    __in DWORD dwFlags,
    __reserved LPVOID pvReserved
    );

//+-------------------------------------------------------------------------
//  AddRef a PCCERT_SERVER_OCSP_RESPONSE_CONTEXT returned by
//  CertGetServerOcspResponseContext(). Each Get and AddRef requires a
//  corresponding CertFreeServerOcspResponseContext().
//--------------------------------------------------------------------------
WINCRYPT32API
VOID
WINAPI
CertAddRefServerOcspResponseContext(
    __in_opt PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext
    );

//+-------------------------------------------------------------------------
//  Free the OCSP response context returned by
//  CertGetServerOcspResponseContext().
//--------------------------------------------------------------------------
WINCRYPT32API
VOID
WINAPI
CertFreeServerOcspResponseContext(
    __in_opt PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext
    );


//+-------------------------------------------------------------------------
//  Helper function to do URL retrieval of logo or biometric information
//  specified in either the szOID_LOGOTYPE_EXT or szOID_BIOMETRIC_EXT
//  certificate extension.
//
//  Only the first hashed URL matching lpszLogoOrBiometricType is used
//  to do the URL retrieval. Only direct logotypes are supported.
//  The bytes at the first URL are retrieved via
//  CryptRetrieveObjectByUrlW and hashed. The computed hash is compared
//  against the hash in the certificate.  For success, ppbData, pcbData
//  and optionally ppwszMimeType are updated with
//  CryptMemAlloc'ed memory which must be freed by calling CryptMemFree().
//  For failure, *ppbData, *pcbData and optionally *ppwszMimeType are
//  zero'ed.
//
//  For failure, the following errors may be set in LastError:
//      E_INVALIDARG - invalid lpszLogoOrBiometricType, not one of the
//          acceptable predefined types.
//      CRYPT_E_NOT_FOUND - certificate doesn't have the
//          szOID_LOGOTYPE_EXT or szOID_BIOMETRIC_EXT extension or a matching
//          lpszLogoOrBiometricType wasn't found with a non-empty
//          hashed URL.
//      ERROR_NOT_SUPPORTED - matched the unsupported indirect logotype
//      NTE_BAD_ALGID - unknown hash algorithm OID
//      ERROR_INVALID_DATA - no bytes were retrieved at the specified URL
//          in the certificate extension
//      CRYPT_E_HASH_VALUE - the computed hash doesn't match the hash
//          in the certificate
//  CertRetrieveLogoOrBiometricInfo calls the following functions which
//  will set LastError for failure:
//      CryptDecodeObjectEx(szOID_LOGOTYPE_EXT or szOID_BIOMETRIC_EXT)
//      CryptRetrieveObjectByUrlW
//      CryptHashCertificate
//      CryptMemAlloc
//
//  lpszLogoOrBiometricType is one of the predefined logotype or biometric
//  types, an other logotype OID or a biometric OID.
//
//  dwRetrievalFlags - see CryptRetrieveObjectByUrlW
//  dwTimeout - see CryptRetrieveObjectByUrlW
//
//  dwFlags - reserved, must be set to 0
//  pvReserved - reserved, must be set to NULL
//
//  *ppwszMimeType is always NULL for the biometric types. For success,
//  the caller must always check if non-NULL before dereferencing.
//--------------------------------------------------------------------------
WINCRYPT32API
__success(return == TRUE)
BOOL
WINAPI
CertRetrieveLogoOrBiometricInfo(
    __in PCCERT_CONTEXT pCertContext,
    __in LPCSTR lpszLogoOrBiometricType,
    __in DWORD dwRetrievalFlags,
    __in DWORD dwTimeout,                             // milliseconds
    __in DWORD dwFlags,
    __reserved void *pvReserved,
    __deref_out_bcount_opt(*pcbData) BYTE **ppbData,  // CryptMemFree()
    __out DWORD *pcbData,
    __deref_opt_out_opt LPWSTR *ppwszMimeType         // CryptMemFree()
    );


// Predefined Logotypes
#define CERT_RETRIEVE_ISSUER_LOGO                       ((LPCSTR) 1)
#define CERT_RETRIEVE_SUBJECT_LOGO                      ((LPCSTR) 2)
#define CERT_RETRIEVE_COMMUNITY_LOGO                    ((LPCSTR) 3)

// Predefined Biometric types
#define CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE    ((LPCSTR) 1000)

#define CERT_RETRIEVE_BIOMETRIC_PICTURE_TYPE            \
    (CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE + CERT_BIOMETRIC_PICTURE_TYPE)
#define CERT_RETRIEVE_BIOMETRIC_SIGNATURE_TYPE          \
    (CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE + CERT_BIOMETRIC_SIGNATURE_TYPE)



#endif //!defined(_DDK_DRIVER_)

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __WINCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\windbase_edb.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// @CESYSGEN IF SQLCOMPACT_MODULES_EDB

#define EDB_MOUNT_FLAG 0x80000000

#ifndef INOUT
#define INOUT
#endif
//-------------------------------------------------------------------------
// property flags
//
#define DB_PROP_NOTNULL                         (0x00000001)
#define DB_PROP_COMPRESSED                      (0x00000002)

//--------------------------------------------------------------------------

// Option Ids
//
#define DBOPT_SESSION_MAX_CHANGES              (0x01)
#define DBOPT_SESSION_LOCK_TIMEOUT             (0x02)

//--------------------------------------------------------------------------
// New tracking types
//
#define DB_TRACK_INSERT                         0x00000001 
#define DB_TRACK_UPDATE                         0x00000002
#define DB_TRACK_DELETE                         0x00000003

// tracking modes
//
#define DB_TRACK_LEVEL                          0x0000007C //1111100
#define DB_TRACK_LEVEL_RECORD                   0x00000004
#define DB_TRACK_LEVEL_PROPINCLUSIVE            0x00000008
#define DB_TRACK_LEVEL_PROPEXCLUSIVE            0x00000010
#define DB_TRACK_LEVEL_PROPVALCHANGE            0x00000020

// row identifier for tracking
//
#define DB_TRACK_ROWIDENTITY                    0x00000003 // 000011
#define DB_TRACK_ROWIDENTITY_PK                 0x00000001 

// sync session flags
//
#define DB_SYNCSESSION_COMPLETE                 0x00000000
#define DB_SYNCSESSION_PARTIAL                  0x00000001
#define DB_SYNCSESSION_FAILED                   0x00000002

#define DB_SYNCSESSION_TRACKSERVER              0x00000000
#define DB_SYNCSESSION_NOTRACK                  0x00000001
#define DB_SYNCSESSION_OVERRRIDELOCALCHANGES    0x00000002

//--------------------------------------------------------------------------
// tracking generations: CEDBGEN
//
typedef ULONGLONG   CEDBGEN;

//--------------------------------------------------------------------------
// default generation values
//
#define CEDBGEN_DEFAULT                         0xFFFFFFFFFFFFFFFF


//--------------------------------------------------------------------------
// CECHANGEINFO
//
typedef struct _CECHANGEINFO {
    DWORD               dwChangeType;
    SYSTEMTIME         stLastModified;    
    CEDBGEN             genLastModified;
} CECHANGEINFO, *PCECHANGEINFO;

//--------------------------------------------------------------------------
// CEDBISOLATIONLEVEL
//
typedef int CEDBISOLATIONLEVEL;

#define CEDB_ISOLEVEL_DEFAULT            1
#define CEDB_ISOLEVEL_READCOMMITTED      1
#define CEDB_ISOLEVEL_REPEATABLEREAD     2
#define CEDB_ISOLEVEL_SERIALIZABLE       3
#define CEDB_ISOLEVEL_LAST   CEDB_ISOLEVEL_SERIALIZABLE

//--------------------------------------------------------------------------
// Limits - apply to various volume options
//
#define CEDB_CB_MIN_BUFFER_POOL         0x00040000
#define CEDB_CB_MAX_BUFFER_POOL         0x0FFFF000
#define CEDB_AUTO_SHRINK_OFF            0x0
#define CEDB_AUTO_SHRINK_THRESHOLD_MAX  100
#define CEDB_FLUSH_INTERVAL_MIN         1
#define CEDB_FLUSH_INTERVAL_MAX         1000
#define CEDB_C_MIN_MAX_NOTIFY_CHANGES   0
#define CEDB_C_MAX_MAX_NOTIFY_CHANGES   0xFFFFFFFF


//--------------------------------------------------------------------------
// CCH_MAX_PASSWORD
//
#if !defined(CCH_MAX_PASSWORD)
#define CCH_MAX_PASSWORD             40
#endif


//--------------------------------------------------------------------------
// CEVOLUMEOPTIONS
//
// wVersion         -   Structure version
// cbBufferPool     -   Count of bytes in the buffer pool
// dwAutoShrinkPercent- Percent free used to kick off autoshrink
// dwFlushInterval  -   Interval between two flushes
// cMaxNotifyChanges-   Max number of notifications on a database to track
// dwDefaultTimeout -   Interval in milliseconds to 
//                      wait on an unavailable lock
// wszPassword      -   Volume password
// dwFlags          -   Contains a bitflag that specifies which of the
//                      fields contain valid data (see above for values)
// cMaxSize         -   Contains the maximum database size for the database in MB
//

#define CEVOLUMEOPTIONS_VERSION 1
#define CEVOLUMEOPTIONS_VERSIONEX 2

typedef struct _CEVOLUMEOPTIONS {
    WORD                wVersion;    
    DWORD               cbBufferPool;
    DWORD               dwAutoShrinkPercent;
    DWORD               dwFlushInterval;
    DWORD               cMaxNotifyChanges;
    DWORD               dwDefaultTimeout;
    WCHAR               wszPassword[CCH_MAX_PASSWORD + 1];
    DWORD               dwFlags;
    DWORD               cMaxSize;
} CEVOLUMEOPTIONS, *PCEVOLUMEOPTIONS;

//-------------------------------------------------------------------------
// Flags for CeMountDBVolEx
//-------------------------------------------------------------------------
// Used to overwrite the default buffer pool size
//
#define CEDB_BUFFERPOOL         0x00000001

// Used to overwrite the default auto shrink percent.
//
#define CEDB_AUTOSHRINKPERCENT  0x00000002

// Used to overwrite the default flush interval.
//
#define CEDB_FLUSHINTERVAL      0x00000004

// Used to overwrite the default maximum number of 
// individual notifications changes to track.
//
#define CEDB_MAXNOTIFYCHANGES   0x00000008

// Used to overwrite the default lock time out.
//
#define CEDB_DEFAULTTIMEOUT     0x00000010

// Used to indicate that the password field contains a password
//
#define CEDB_PASSWORD           0x00000020

// Used to overwrite the max pages value
//
#define CEDB_MAXSIZE           0x00000040

//-------------------------------------------------------------------------
// CEPROPSPEC
//
// wVersion - Structure version
// propid   - Property id
// dwFlags  - Combination of the following:
//              DB_PROP_NOTNULL     - the column does not accept nulls
//              DB_PROP_COMPRESSED  - the column should be compressed 
//                                    (valid for long values only)
// pwszPropName - The readable name of the property
// cchPropName  - The user will fill this field with the number of 
//              wide characters available in pwszPropName.
//
#define CEPROPSPEC_VERSION 1
typedef struct _CEPROPSPEC {
   WORD     wVersion;
   CEPROPID propid;
   DWORD    dwFlags;
   LPWSTR   pwszPropName;
   DWORD    cchPropName;
} CEPROPSPEC, *PCEPROPSPEC;


//--------------------------------------------------------------------------
// New functions
//
CEOID CeCreateDatabaseWithProps( 
    IN PCEGUID pGuid, 
    IN CEDBASEINFOEX* pInfo,
    IN DWORD cProps,
    IN CEPROPSPEC* prgProps);

BOOL CeAddDatabaseProps(
    IN PCEGUID pGuid, 
    IN CEOID oidDb,
    IN DWORD cProps,    
    IN CEPROPSPEC* prgProps);

BOOL CeGetDatabaseProps(
    IN HANDLE hHandle,
    INOUT WORD* pcPropId,
    IN CEPROPID* prgPropId,
    OUT CEPROPSPEC* prgProps);

BOOL CeRemoveDatabaseProps(
    IN PCEGUID pGuid, 
    IN CEOID oidDb,
    IN DWORD cPropID,
    IN CEPROPID* prgPropID);


BOOL CeMountDBVolEx( 
    INOUT PCEGUID pGuid,
    IN LPWSTR pwszDBVol,
    IN CEVOLUMEOPTIONS* pOptions,
    IN DWORD dwFlags);


// Session API's
HANDLE CeCreateSession(
    IN CEGUID* pGuid);

BOOL CeSetSessionOption(
    IN HANDLE hSession,
    IN ULONG ulOptionId,
    IN DWORD dwValue);

HANDLE CeGetDatabaseSession(
    IN HANDLE hDatabase);

BOOL CeBeginTransaction(
    IN HANDLE hSession,
    IN CEDBISOLATIONLEVEL isoLevel);

BOOL CeEndTransaction(
    IN HANDLE hSession,
    IN BOOL fCommit);

HANDLE CeOpenDatabaseInSession( 
    IN HANDLE hSession,
    IN PCEGUID pGuid, 
    IN PCEOID poid,
    IN LPWSTR pwszName, 
    IN SORTORDERSPECEX* pSort,
    IN DWORD dwFlags,
    IN CENOTIFYREQUEST* pRequest);


// Stream API's    

HANDLE CeOpenStream(
    IN HANDLE hDatabase,
    IN CEPROPID propid,
    IN DWORD dwMode);

BOOL CeStreamRead(
    IN HANDLE hStream,
    OUT BYTE* prgbBuffer,
    IN DWORD cbRead,
    OUT DWORD* pcbRead);

BOOL CeStreamWrite(
    IN HANDLE hStream,
    IN BYTE* prgbBuffer,
    IN DWORD cbWrite,
    OUT DWORD* pcbWritten);

BOOL CeStreamSaveChanges(
    IN HANDLE hStream);

BOOL CeStreamSeek(
    IN HANDLE hStream,
    IN DWORD cbMove,
    IN DWORD dwOrigin,
    OUT DWORD* pcbNewOffset);

BOOL CeStreamSetSize(
    IN HANDLE hStream,
    IN DWORD cbSize);


//-----------------------------------------------------------------------
// Tracking functions
//
BOOL CeAddSyncPartner(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  LPCWSTR     pwszFriendlyName,
    IN  LPCWSTR     pwszFullName  );
         
BOOL CeRemoveSyncPartner(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid );

BOOL CeTrackDatabase(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  CEOID       oidDB,
    IN  DWORD       dwTrackingFlags );

BOOL CeRemoveDatabaseTracking(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  CEOID       oidDB );
    
BOOL CeTrackProperty(
    IN  PCEGUID     pVolGuid,
    IN  CEOID       oidDB,
    IN  CEPROPID    propid,
    IN  BOOL        fAddToScheme );

BOOL CeBeginSyncSession(
    IN  HANDLE      hSession,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  CEDBGEN     genFrom,
    IN  CEDBGEN     genTo,
    IN  DWORD       dwFlags,
    OUT CEDBGEN*    pGenCur );
    
BOOL CeEndSyncSession(
    IN  HANDLE      hSession,
    IN  DWORD       dwOutcome );

BOOL CeGetChangedRecordCnt(
    IN  HANDLE      hSession,
    IN  CEOID       oidDB,
    OUT DWORD*      pdwCnt );

HANDLE CeGetChangedRecords(
    IN  HANDLE      hSession,
    IN  CEOID       oidDB,
    IN  DWORD       dwChangeType  );

CEOID CeFindNextChangedRecord(
    IN  HANDLE      hChangeEnum );

BOOL CeGetPropChangeInfo(
    IN  HANDLE          hChangeEnum,
    IN  CEOID           oidChangedRecord,
    IN  CEPROPID        propid,
    OUT BOOL*           pfPropChanged );

BOOL CeGetRecordChangeInfo(
    IN  HANDLE           hChangeEnum,
    IN  CEOID            oidChangedRecord,
    OUT CECHANGEINFO* pInfo );

BOOL CeMarkRecord(
    IN  HANDLE          hChangeEnum,
    IN  CEOID           oidChangedRecord,
    IN  BOOL            fChanged );

BOOL CeAttachCustomTrackingData(
    IN  HANDLE          hDB,
    IN  CEOID           oidChangedRecord,
    IN  BYTE*           rgbData,
    IN  DWORD           ccb );
    
BOOL CeGetCustomTrackingData(
    IN      HANDLE          hChangeEnum,
    IN      CEOID           oidChangedRecord,
    INOUT   BYTE*           rgbData,
    INOUT   DWORD*          pccb );

BOOL CePurgeTrackingData(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  SYSTEMTIME* pstThreshold );

BOOL CePurgeTrackingGenerations(
    IN  PCEGUID     pVolGuid,
    IN  PCEGUID     pSyncPartnerGuid,
    IN  CEDBGEN     genThreshold);

//--------------------------------------------------------------------------
//

// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\windef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/****************************************************************************
*                                                                           *
* windef.h -- Basic Windows Type Definitions                                *
*                                                                           *
*                                                                           *
****************************************************************************/

#pragma once

#ifndef _WINDEF_
#define _WINDEF_

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

// Win32 defines _WIN32 automatically,
// but Macintosh doesn't, so if we are using
// Win32 Functions, we must do it here

#ifdef _MAC
#ifndef _WIN32
#define _WIN32
#endif
#endif //_MAC

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINVER
#define WINVER 0x0500
#endif /* WINVER */

/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */

#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

#ifndef MAX_PATH
#define MAX_PATH          260
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#undef far
#undef near
#undef pascal

#define far
#define near
#if (!defined(_MAC)) && ((_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED))
#define pascal __stdcall
#else
#define pascal
#endif

#if defined(DOSWIN32) || defined(_MAC)
#define cdecl _cdecl
#ifndef CDECL
#define CDECL _cdecl
#endif
#else
#define cdecl
#ifndef CDECL
#define CDECL
#endif
#endif
#ifndef _WIN32_WCE_EMULATION
#ifdef UNDER_CE
#define __stdcall __cdecl	// Note this doesn't match the desktop definition
#define _stdcall __cdecl	// Note this doesn't match the desktop definition
#endif
#endif

#ifdef _MAC
#define CALLBACK    PASCAL
#define WINAPI      CDECL
#define WINAPIV     CDECL
#define APIENTRY    WINAPI
#define APIPRIVATE  CDECL
#ifdef _68K_
#define PASCAL      __pascal
#else
#define PASCAL
#endif
#elif (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define CALLBACK    __stdcall
#define WINAPI      __stdcall
#define WINAPIV     __cdecl
#define APIENTRY    WINAPI
#define APIPRIVATE  __stdcall
#define PASCAL      __stdcall
#else
#define CALLBACK
#define WINAPI
#define WINAPIV
#define APIENTRY    WINAPI
#define APIPRIVATE
#define PASCAL      pascal
#endif

#undef FAR
#undef  NEAR
#define FAR                 far
#define NEAR                near
#ifndef CONST
#define CONST               const
#endif

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL near           *PBOOL;
typedef BOOL far            *LPBOOL;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef short far           *LPSHORT;
typedef void far            *LPVOID;
typedef CONST void far      *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;

#ifndef NT_INCLUDED
#include <winnt.h>
#endif /* NT_INCLUDED */

#include <specstrings.h>

/* Types use for passing & returning polymorphic values */
typedef UINT_PTR            WPARAM;
typedef LONG_PTR            LPARAM;
typedef LONG_PTR            LRESULT;

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))


#ifndef WIN_INTERNAL
DECLARE_HANDLE            (HWND);
DECLARE_HANDLE            (HHOOK);
#ifdef WINABLE
DECLARE_HANDLE            (HEVENT);
#endif
#endif

typedef WORD                ATOM;

typedef HANDLE NEAR         *SPHANDLE;
typedef HANDLE FAR          *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;
#ifndef _MAC
#ifdef _WIN64
typedef INT_PTR (FAR WINAPI *FARPROC)();
typedef INT_PTR (NEAR WINAPI *NEARPROC)();
typedef INT_PTR (WINAPI *PROC)();
#else
typedef int (FAR WINAPI *FARPROC)();
typedef int (NEAR WINAPI *NEARPROC)();
typedef int (WINAPI *PROC)();
#endif  // _WIN64
#else
typedef int (CALLBACK *FARPROC)();
typedef int (CALLBACK *NEARPROC)();
typedef int (CALLBACK *PROC)();
#endif

#if !defined(_MAC) || !defined(GDI_INTERNAL)
#ifdef STRICT
typedef void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif
#endif

DECLARE_HANDLE(HKEY);
typedef HKEY *PHKEY;

#if !defined(_MAC) || !defined(WIN_INTERNAL)
DECLARE_HANDLE(HACCEL);
#endif
#if !defined(_MAC) || !defined(GDI_INTERNAL)
DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HBRUSH);
#endif
#if(WINVER >= 0x0400)
DECLARE_HANDLE(HCOLORSPACE);
#endif /* WINVER >= 0x0400 */
#if !defined(_MAC) || !defined(GDI_INTERNAL)
DECLARE_HANDLE(HDC);
#endif
DECLARE_HANDLE(HGLRC);          // OpenGL
DECLARE_HANDLE(HDESK);
DECLARE_HANDLE(HENHMETAFILE);
#if !defined(_MAC) || !defined(GDI_INTERNAL)
DECLARE_HANDLE(HFONT);
#endif
DECLARE_HANDLE(HICON);
#if !defined(_MAC) || !defined(WIN_INTERNAL)
DECLARE_HANDLE(HMENU);
#endif
DECLARE_HANDLE(HMETAFILE);
DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */
#if !defined(_MAC) || !defined(GDI_INTERNAL)
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HPEN);
#endif
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HRSRC);
DECLARE_HANDLE(HSTR);
DECLARE_HANDLE(HTASK);
DECLARE_HANDLE(HWINSTA);
DECLARE_HANDLE(HKL);

#if(WINVER >= 0x0500)
#ifndef _MAC
DECLARE_HANDLE(HMONITOR);
DECLARE_HANDLE(HWINEVENTHOOK);
#endif
#endif /* WINVER >= 0x0500 */

#ifndef _MAC
typedef int HFILE;
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */
#else
typedef short HFILE;
DECLARE_HANDLE(HCURSOR);    /* HICONs & HCURSORs are not polymorphic */
#endif

typedef DWORD   COLORREF;
typedef DWORD   *LPCOLORREF;

#define HFILE_ERROR ((HFILE)-1)

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;

typedef const RECT FAR* LPCRECT;

typedef struct _RECTL       /* rcl */
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL FAR* LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;

typedef struct _POINTL      /* ptl  */
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{
#ifndef _MAC
    SHORT   x;
    SHORT   y;
#else
    SHORT   y;
    SHORT   x;
#endif
} POINTS, *PPOINTS, *LPPOINTS;

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18

#define OEM_CERTIFY_TRUST 2
#define OEM_CERTIFY_RUN 1
#define OEM_CERTIFY_FALSE 0

#ifdef __cplusplus
}
#endif

#endif /* _WINDEF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\windns.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Module Name:

    windns.h

Abstract:

    Domain Name System (DNS)

    DNS definitions and DNS API.


Revision History:

--*/


#ifndef _WINDNS_INCLUDED_
#define _WINDNS_INCLUDED_


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Define QWORD -- not yet defined globally 
//

typedef unsigned __int64 QWORD;

//
//  DNS public types
//

typedef LONG    DNS_STATUS, *PDNS_STATUS;

//
//  IP Address
//

typedef DWORD   IP4_ADDRESS, *PIP4_ADDRESS;

#define SIZEOF_IP4_ADDRESS                  (4)
#define IP4_ADDRESS_STRING_LENGTH           (15)
#define IP4_ADDRESS_STRING_BUFFER_LENGTH    (16)


//
//  IP Address Array type
//

typedef struct  _IP4_ARRAY
{
    DWORD           AddrCount;
#ifdef MIDL_PASS
    [size_is( AddrCount )]  IP4_ADDRESS  AddrArray[];
#else
    IP4_ADDRESS     AddrArray[1];
#endif
}
IP4_ARRAY, *PIP4_ARRAY;


//
//  IPv6 Address
//

#ifdef MIDL_PASS
typedef struct
{
#ifdef _WIN64
    QWORD       IP6Qword[2];
#else
    DWORD       IP6Dword[4];
#endif
}
IP6_ADDRESS, *PIP6_ADDRESS;
#else
typedef union
{
#ifdef _WIN64
    QWORD       IP6Qword[2];
#endif
    DWORD       IP6Dword[4];
    WORD        IP6Word[8];
    BYTE        IP6Byte[16];
#ifdef  IN6_ADDR
    IN6_ADDR    In6;
#endif
}
IP6_ADDRESS, *PIP6_ADDRESS;
#endif

//  Backward compatibility

typedef IP6_ADDRESS  DNS_IP6_ADDRESS, *PDNS_IP6_ADDRESS;

//
//  IP6 string max is 45 bytes
//      - 6 WORDs in colon+hex (5 chars)
//      - last DWORD as IP4 (15 chars)
//  

#undef  IP6_ADDRESS_STRING_LENGTH
#define IP6_ADDRESS_STRING_LENGTH           (47)
#define IP6_ADDRESS_STRING_BUFFER_LENGTH    (48)

//  backcompat
#define IPV6_ADDRESS_STRING_LENGTH      IP6_ADDRESS_STRING_LENGTH


//
//  Inline byte flipping -- can be done in registers
//

#define INLINE_WORD_FLIP(out, in)   \
        {                           \
            WORD _in = (in);        \
            (out) = (_in << 8) | (_in >> 8);  \
        }
#define INLINE_HTONS(out, in)   INLINE_WORD_FLIP(out, in)
#define INLINE_NTOHS(out, in)   INLINE_WORD_FLIP(out, in)

#define INLINE_DWORD_FLIP(out, in)  \
        {                           \
            DWORD _in = (in);       \
            (out) = ((_in << 8) & 0x00ff0000) | \
                    (_in << 24)               | \
                    ((_in >> 8) & 0x0000ff00) | \
                    (_in >> 24);                \
        }
#define INLINE_NTOHL(out, in) INLINE_DWORD_FLIP(out, in)
#define INLINE_HTONL(out, in) INLINE_DWORD_FLIP(out, in)


//
//  Inline byte flip and write to packet (unaligned)
//

#define INLINE_WRITE_FLIPPED_WORD( pout, in ) \
            INLINE_WORD_FLIP( *((UNALIGNED WORD *)(pout)), in )

#define INLINE_WRITE_FLIPPED_DWORD( pout, in ) \
            INLINE_DWORD_FLIP( *((UNALIGNED DWORD *)(pout)), in )




//
//  Basic DNS definitions
//

//
//  DNS port for both UDP and TCP is 53.
//

#define DNS_PORT_HOST_ORDER     (0x0035)    // port 53
#define DNS_PORT_NET_ORDER      (0x3500)

//
//  DNS UDP packets no more than 512 bytes
//

#define DNS_RFC_MAX_UDP_PACKET_LENGTH   (512)


//
//  DNS Names limited to 255, 63 in any one label
//

#define DNS_MAX_NAME_LENGTH             (255)
#define DNS_MAX_LABEL_LENGTH            (63)

#define DNS_MAX_NAME_BUFFER_LENGTH      (256)
#define DNS_MAX_LABEL_BUFFER_LENGTH     (64)

//
//  Reverse lookup domain names
//

#define DNS_IP4_REVERSE_DOMAIN_STRING ("in-addr.arpa.")

#define DNS_MAX_IP4_REVERSE_NAME_LENGTH \
            (IP_ADDRESS_STRING_LENGTH+1+sizeof(DNS_IP4_REVERSE_DOMAIN_STRING))

#define DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH \
            (DNS_MAX_IP4_REVERSE_NAME_LENGTH + 1)


#define DNS_IP6_REVERSE_DOMAIN_STRING ("ip6.int.")

#define DNS_MAX_IP6_REVERSE_NAME_LENGTH \
            (64+sizeof(DNS_IP6_REVERSE_DOMAIN_STRING))

#define DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH \
            (DNS_MAX_IP6_REVERSE_NAME_LENGTH + 1)

//  Combined

#define DNS_MAX_REVERSE_NAME_LENGTH \
        DNS_MAX_IP6_REVERSE_NAME_LENGTH \

#define DNS_MAX_REVERSE_NAME_BUFFER_LENGTH \
        DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH


//
//  DNS Text string limited by size representable
//      in a single byte length field

#define DNS_MAX_TEXT_STRING_LENGTH  (255)




//
//  DNS On-The-Wire Structures
//

#pragma pack(1)

//
//  DNS Message Header
//

typedef struct _DNS_HEADER
{
    WORD    Xid;

    BYTE    RecursionDesired : 1;
    BYTE    Truncation : 1;
    BYTE    Authoritative : 1;
    BYTE    Opcode : 4;
    BYTE    IsResponse : 1;

    BYTE    ResponseCode : 4;
    BYTE    Reserved : 3;
    BYTE    RecursionAvailable : 1;

    WORD    QuestionCount;
    WORD    AnswerCount;
    WORD    NameServerCount;
    WORD    AdditionalCount;
}
DNS_HEADER, *PDNS_HEADER;


//
//  Flags as WORD
//

#define DNS_HEADER_FLAGS(pHead)     ( *((PWORD)(pHead)+1) )


//
//  Byte flip DNS header to\from host order.
//
//  Note that this does NOT flip flags, as definition above defines
//  flags as individual bytes for direct access to net byte order.
//

#define DNS_BYTE_FLIP_HEADER_COUNTS(pHeader)       \
        {                                   \
            PDNS_HEADER _head = (pHeader);  \
            INLINE_HTONS(_head->Xid,            _head->Xid             ); \
            INLINE_HTONS(_head->QuestionCount,  _head->QuestionCount   ); \
            INLINE_HTONS(_head->AnswerCount,    _head->AnswerCount     ); \
            INLINE_HTONS(_head->NameServerCount,_head->NameServerCount ); \
            INLINE_HTONS(_head->AdditionalCount,_head->AdditionalCount ); \
        }

//
//  Question name follows header
//

#define DNS_OFFSET_TO_QUESTION_NAME     sizeof(DNS_HEADER)

//
//  Question immediately follows header so compressed question name
//      0xC000 | sizeof(DNS_HEADER)

#define DNS_COMPRESSED_QUESTION_NAME  (0xC00C)


//
//  Packet extraction macros
//

#define DNS_QUESTION_NAME_FROM_HEADER( _pHeader_ ) \
            ( (PCHAR)( (PDNS_HEADER)(_pHeader_) + 1 ) )

#define DNS_ANSWER_FROM_QUESTION( _pQuestion_ ) \
            ( (PCHAR)( (PDNS_QUESTION)(_pQuestion_) + 1 ) )


//
//  DNS Question
//

typedef struct _DNS_WIRE_QUESTION
{
    //  Preceded by question name

    WORD    QuestionType;
    WORD    QuestionClass;
}
DNS_WIRE_QUESTION, *PDNS_WIRE_QUESTION;


//
//  DNS Resource Record
//

typedef struct _DNS_WIRE_RECORD
{
    //  Preceded by record owner name

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    DataLength;

    //  Followed by record data
}
DNS_WIRE_RECORD, *PDNS_WIRE_RECORD;

#pragma pack()


//
//  DNS Query Types
//

#define DNS_OPCODE_QUERY            0   // Query
#define DNS_OPCODE_IQUERY           1   // Obsolete: IP to name
#define DNS_OPCODE_SERVER_STATUS    2   // Obsolete: DNS ping
#define DNS_OPCODE_UNKNOWN          3   // Unknown
#define DNS_OPCODE_NOTIFY           4   // Notify
#define DNS_OPCODE_UPDATE           5   // Dynamic Update

//
//  DNS response codes.
//
//  Sent in the "ResponseCode" field of a DNS_HEADER.
//

#define DNS_RCODE_NOERROR       0
#define DNS_RCODE_FORMERR       1       // Format error
#define DNS_RCODE_SERVFAIL      2       // Server failure
#define DNS_RCODE_NXDOMAIN      3       // Name error
#define DNS_RCODE_NOTIMPL       4       // Not implemented
#define DNS_RCODE_REFUSED       5       // Refused
#define DNS_RCODE_YXDOMAIN      6       // Domain name should not exist
#define DNS_RCODE_YXRRSET       7       // RR set should not exist
#define DNS_RCODE_NXRRSET       8       // RR set does not exist
#define DNS_RCODE_NOTAUTH       9       // Not authoritative for zone
#define DNS_RCODE_NOTZONE       10      // Name is not zone
#define DNS_RCODE_MAX           15

//
//  Extended RCODEs
//

#define DNS_RCODE_BADVERS       16      // Bad EDNS version
#define DNS_RCODE_BADSIG        16      // Bad signature
#define DNS_RCODE_BADKEY        17      // Bad key
#define DNS_RCODE_BADTIME       18      // Bad timestamp

//
//  Mappings to friendly names
//

#define DNS_RCODE_NO_ERROR          DNS_RCODE_NOERROR
#define DNS_RCODE_FORMAT_ERROR      DNS_RCODE_FORMERR
#define DNS_RCODE_SERVER_FAILURE    DNS_RCODE_SERVFAIL
#define DNS_RCODE_NAME_ERROR        DNS_RCODE_NXDOMAIN
#define DNS_RCODE_NOT_IMPLEMENTED   DNS_RCODE_NOTIMPL


//
//  DNS Classes
//
//  Classes are on the wire as WORDs.
//
//  _CLASS_ defines in host order.
//  _RCLASS_ defines in net byte order.
//
//  Generally we'll avoid byte flip and test class in net byte order.
//

#define DNS_CLASS_INTERNET  0x0001      //  1
#define DNS_CLASS_CSNET     0x0002      //  2
#define DNS_CLASS_CHAOS     0x0003      //  3
#define DNS_CLASS_HESIOD    0x0004      //  4
#define DNS_CLASS_NONE      0x00fe      //  254
#define DNS_CLASS_ALL       0x00ff      //  255
#define DNS_CLASS_ANY       0x00ff      //  255

#define DNS_RCLASS_INTERNET 0x0100      //  1
#define DNS_RCLASS_CSNET    0x0200      //  2
#define DNS_RCLASS_CHAOS    0x0300      //  3
#define DNS_RCLASS_HESIOD   0x0400      //  4
#define DNS_RCLASS_NONE     0xfe00      //  254
#define DNS_RCLASS_ALL      0xff00      //  255
#define DNS_RCLASS_ANY      0xff00      //  255



//
//  DNS Record Types
//
//  _TYPE_ defines are in host byte order.
//  _RTYPE_ defines are in net byte order.
//
//  Generally always deal with types in host byte order as we index
//  resource record functions by type.
//

#define DNS_TYPE_ZERO       0x0000

//  RFC 1034/1035
#define DNS_TYPE_A          0x0001      //  1
#define DNS_TYPE_NS         0x0002      //  2
#define DNS_TYPE_MD         0x0003      //  3
#define DNS_TYPE_MF         0x0004      //  4
#define DNS_TYPE_CNAME      0x0005      //  5
#define DNS_TYPE_SOA        0x0006      //  6
#define DNS_TYPE_MB         0x0007      //  7
#define DNS_TYPE_MG         0x0008      //  8
#define DNS_TYPE_MR         0x0009      //  9
#define DNS_TYPE_NULL       0x000a      //  10
#define DNS_TYPE_WKS        0x000b      //  11
#define DNS_TYPE_PTR        0x000c      //  12
#define DNS_TYPE_HINFO      0x000d      //  13
#define DNS_TYPE_MINFO      0x000e      //  14
#define DNS_TYPE_MX         0x000f      //  15
#define DNS_TYPE_TEXT       0x0010      //  16

//  RFC 1183
#define DNS_TYPE_RP         0x0011      //  17
#define DNS_TYPE_AFSDB      0x0012      //  18
#define DNS_TYPE_X25        0x0013      //  19
#define DNS_TYPE_ISDN       0x0014      //  20
#define DNS_TYPE_RT         0x0015      //  21

//  RFC 1348
#define DNS_TYPE_NSAP       0x0016      //  22
#define DNS_TYPE_NSAPPTR    0x0017      //  23

//  RFC 2065    (DNS security)
#define DNS_TYPE_SIG        0x0018      //  24
#define DNS_TYPE_KEY        0x0019      //  25

//  RFC 1664    (X.400 mail)
#define DNS_TYPE_PX         0x001a      //  26

//  RFC 1712    (Geographic position)
#define DNS_TYPE_GPOS       0x001b      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_TYPE_AAAA       0x001c      //  28

//  RFC 1876    (Geographic location)
#define DNS_TYPE_LOC        0x001d      //  29

//  RFC 2065    (Secure negative response)
#define DNS_TYPE_NXT        0x001e      //  30

//  Patton      (Endpoint Identifier)
#define DNS_TYPE_EID        0x001f      //  31

//  Patton      (Nimrod Locator)
#define DNS_TYPE_NIMLOC     0x0020      //  32

//  RFC 2052    (Service location)
#define DNS_TYPE_SRV        0x0021      //  33

//  ATM Standard something-or-another (ATM Address)
#define DNS_TYPE_ATMA       0x0022      //  34

//  RFC 2168    (Naming Authority Pointer)
#define DNS_TYPE_NAPTR      0x0023      //  35

//  RFC 2230    (Key Exchanger)
#define DNS_TYPE_KX         0x0024      //  36

//  RFC 2538    (CERT)
#define DNS_TYPE_CERT       0x0025      //  37

//  A6 Draft    (A6)
#define DNS_TYPE_A6         0x0026      //  38

//  DNAME Draft (DNAME)
#define DNS_TYPE_DNAME      0x0027      //  39

//  Eastlake    (Kitchen Sink)
#define DNS_TYPE_SINK       0x0028      //  40

//  RFC 2671    (EDNS OPT)
#define DNS_TYPE_OPT        0x0029      //  41

//
//  IANA Reserved
//

#define DNS_TYPE_UINFO      0x0064      //  100
#define DNS_TYPE_UID        0x0065      //  101
#define DNS_TYPE_GID        0x0066      //  102
#define DNS_TYPE_UNSPEC     0x0067      //  103

//
//  Query only types (1035, 1995)
//      - Crawford      (ADDRS)
//      - TKEY draft    (TKEY)
//      - TSIG draft    (TSIG)
//      - RFC 1995      (IXFR)
//      - RFC 1035      (AXFR up)
//

#define DNS_TYPE_ADDRS      0x00f8      //  248
#define DNS_TYPE_TKEY       0x00f9      //  249
#define DNS_TYPE_TSIG       0x00fa      //  250
#define DNS_TYPE_IXFR       0x00fb      //  251
#define DNS_TYPE_AXFR       0x00fc      //  252
#define DNS_TYPE_MAILB      0x00fd      //  253
#define DNS_TYPE_MAILA      0x00fe      //  254
#define DNS_TYPE_ALL        0x00ff      //  255
#define DNS_TYPE_ANY        0x00ff      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//

#define DNS_TYPE_WINS       0xff01      //  64K - 255
#define DNS_TYPE_WINSR      0xff02      //  64K - 254
#define DNS_TYPE_NBSTAT     (DNS_TYPE_WINSR)


//
//  DNS Record Types -- Net Byte Order
//

#define DNS_RTYPE_A         0x0100      //  1
#define DNS_RTYPE_NS        0x0200      //  2
#define DNS_RTYPE_MD        0x0300      //  3
#define DNS_RTYPE_MF        0x0400      //  4
#define DNS_RTYPE_CNAME     0x0500      //  5
#define DNS_RTYPE_SOA       0x0600      //  6
#define DNS_RTYPE_MB        0x0700      //  7
#define DNS_RTYPE_MG        0x0800      //  8
#define DNS_RTYPE_MR        0x0900      //  9
#define DNS_RTYPE_NULL      0x0a00      //  10
#define DNS_RTYPE_WKS       0x0b00      //  11
#define DNS_RTYPE_PTR       0x0c00      //  12
#define DNS_RTYPE_HINFO     0x0d00      //  13
#define DNS_RTYPE_MINFO     0x0e00      //  14
#define DNS_RTYPE_MX        0x0f00      //  15
#define DNS_RTYPE_TEXT      0x1000      //  16
#define DNS_RTYPE_RP        0x1100      //  17
#define DNS_RTYPE_AFSDB     0x1200      //  18
#define DNS_RTYPE_X25       0x1300      //  19
#define DNS_RTYPE_ISDN      0x1400      //  20
#define DNS_RTYPE_RT        0x1500      //  21
#define DNS_RTYPE_NSAP      0x1600      //  22
#define DNS_RTYPE_NSAPPTR   0x1700      //  23
#define DNS_RTYPE_SIG       0x1800      //  24
#define DNS_RTYPE_KEY       0x1900      //  25
#define DNS_RTYPE_PX        0x1a00      //  26
#define DNS_RTYPE_GPOS      0x1b00      //  27
#define DNS_RTYPE_AAAA      0x1c00      //  28
#define DNS_RTYPE_LOC       0x1d00      //  29
#define DNS_RTYPE_NXT       0x1e00      //  30
#define DNS_RTYPE_EID       0x1f00      //  31
#define DNS_RTYPE_NIMLOC    0x2000      //  32
#define DNS_RTYPE_SRV       0x2100      //  33
#define DNS_RTYPE_ATMA      0x2200      //  34
#define DNS_RTYPE_NAPTR     0x2300      //  35
#define DNS_RTYPE_KX        0x2400      //  36
#define DNS_RTYPE_CERT      0x2500      //  37
#define DNS_RTYPE_A6        0x2600      //  38
#define DNS_RTYPE_DNAME     0x2700      //  39
#define DNS_RTYPE_SINK      0x2800      //  40
#define DNS_RTYPE_OPT       0x2900      //  41

//
//  IANA Reserved
//

#define DNS_RTYPE_UINFO     0x6400      //  100
#define DNS_RTYPE_UID       0x6500      //  101
#define DNS_RTYPE_GID       0x6600      //  102
#define DNS_RTYPE_UNSPEC    0x6700      //  103

//
//  Query only types
//

#define DNS_RTYPE_TKEY      0xf900      //  249
#define DNS_RTYPE_TSIG      0xfa00      //  250
#define DNS_RTYPE_IXFR      0xfb00      //  251
#define DNS_RTYPE_AXFR      0xfc00      //  252
#define DNS_RTYPE_MAILB     0xfd00      //  253
#define DNS_RTYPE_MAILA     0xfe00      //  254
#define DNS_RTYPE_ALL       0xff00      //  255
#define DNS_RTYPE_ANY       0xff00      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//

#define DNS_RTYPE_WINS      0x01ff      //  64K - 255
#define DNS_RTYPE_WINSR     0x02ff      //  64K - 254




//
//  Record type specific definitions
//

//
//  ATMA (ATM address type) formats
//
//  Define these directly for any environment (ex NT4)
//  without winsock2 ATM support (ws2atm.h)
//

#ifndef  ATMA_E164
#define DNS_ATMA_FORMAT_E164            1
#define DNS_ATMA_FORMAT_AESA            2
#define DNS_ATMA_MAX_ADDR_LENGTH        (20)
#else
#define DNS_ATMA_FORMAT_E164            ATM_E164
#define DNS_ATMA_FORMAT_AESA            ATM_AESA
#define DNS_ATMA_MAX_ADDR_LENGTH        ATM_ADDR_SIZE
#endif

#define DNS_ATMA_AESA_ADDR_LENGTH       (20)
#define DNS_ATMA_MAX_RECORD_LENGTH      (DNS_ATMA_MAX_ADDR_LENGTH+1)


//
//  DNSSEC defs
//

//  DNSSEC algorithms

#define DNSSEC_ALGORITHM_RSAMD5     1
#define DNSSEC_ALGORITHM_NULL       253
#define DNSSEC_ALGORITHM_PRIVATE    254

//  DNSSEC KEY protocol table

#define DNSSEC_PROTOCOL_NONE        0
#define DNSSEC_PROTOCOL_TLS         1
#define DNSSEC_PROTOCOL_EMAIL       2
#define DNSSEC_PROTOCOL_DNSSEC      3
#define DNSSEC_PROTOCOL_IPSEC       4

//  DNSSEC KEY flag field

#define DNSSEC_KEY_FLAG_NOAUTH          0x0001
#define DNSSEC_KEY_FLAG_NOCONF          0x0002
#define DNSSEC_KEY_FLAG_FLAG2           0x0004
#define DNSSEC_KEY_FLAG_EXTEND          0x0008
#define DNSSEC_KEY_FLAG_
#define DNSSEC_KEY_FLAG_FLAG4           0x0010
#define DNSSEC_KEY_FLAG_FLAG5           0x0020

// bits 6,7 are name type

#define DNSSEC_KEY_FLAG_USER            0x0000
#define DNSSEC_KEY_FLAG_ZONE            0x0040
#define DNSSEC_KEY_FLAG_HOST            0x0080
#define DNSSEC_KEY_FLAG_NTPE3           0x00c0

// bits 8-11 are reserved for future use

#define DNSSEC_KEY_FLAG_FLAG8           0x0100
#define DNSSEC_KEY_FLAG_FLAG9           0x0200
#define DNSSEC_KEY_FLAG_FLAG10          0x0400
#define DNSSEC_KEY_FLAG_FLAG11          0x0800

// bits 12-15 are sig field

#define DNSSEC_KEY_FLAG_SIG0            0x0000
#define DNSSEC_KEY_FLAG_SIG1            0x1000
#define DNSSEC_KEY_FLAG_SIG2            0x2000
#define DNSSEC_KEY_FLAG_SIG3            0x3000
#define DNSSEC_KEY_FLAG_SIG4            0x4000
#define DNSSEC_KEY_FLAG_SIG5            0x5000
#define DNSSEC_KEY_FLAG_SIG6            0x6000
#define DNSSEC_KEY_FLAG_SIG7            0x7000
#define DNSSEC_KEY_FLAG_SIG8            0x8000
#define DNSSEC_KEY_FLAG_SIG9            0x9000
#define DNSSEC_KEY_FLAG_SIG10           0xa000
#define DNSSEC_KEY_FLAG_SIG11           0xb000
#define DNSSEC_KEY_FLAG_SIG12           0xc000
#define DNSSEC_KEY_FLAG_SIG13           0xd000
#define DNSSEC_KEY_FLAG_SIG14           0xe000
#define DNSSEC_KEY_FLAG_SIG15           0xf000


//
//  TKEY modes
//

#define DNS_TKEY_MODE_SERVER_ASSIGN         1
#define DNS_TKEY_MODE_DIFFIE_HELLMAN        2
#define DNS_TKEY_MODE_GSS                   3
#define DNS_TKEY_MODE_RESOLVER_ASSIGN       4

//
//  WINS + NBSTAT flag field
//

#define DNS_WINS_FLAG_SCOPE     (0x80000000)
#define DNS_WINS_FLAG_LOCAL     (0x00010000)


//
//  Helpful checks
//

#define IS_WORD_ALIGNED(p)      ( !((UINT_PTR)(p) & (UINT_PTR)1) )
#define IS_DWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)3) )
#define IS_QWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)7) )




//
//  DNS config API
//

//
//  Types of DNS configuration info
//

typedef enum
{
    //  In Win2K
    DnsConfigPrimaryDomainName_W,
    DnsConfigPrimaryDomainName_A,
    DnsConfigPrimaryDomainName_UTF8,

    //  Not available yet
    DnsConfigAdapterDomainName_W,
    DnsConfigAdapterDomainName_A,
    DnsConfigAdapterDomainName_UTF8,

    //  In Win2K
    DnsConfigDnsServerList,

    //  Not available yet
    DnsConfigSearchList,
    DnsConfigAdapterInfo,

    //  In Win2K
    DnsConfigPrimaryHostNameRegistrationEnabled,
    DnsConfigAdapterHostNameRegistrationEnabled,
    DnsConfigAddressRegistrationMaxCount,

    //  In WindowsXP
    DnsConfigHostName_W,
    DnsConfigHostName_A,
    DnsConfigHostName_UTF8,
    DnsConfigFullHostName_W,
    DnsConfigFullHostName_A,
    DnsConfigFullHostName_UTF8
}
DNS_CONFIG_TYPE;

//
//  Config API flags
//

//
//  Causes config info to be allocated with LocalAlloc()
//

#define DNS_CONFIG_FLAG_ALLOC   (0x00000001)


DNS_STATUS
WINAPI
DnsQueryConfig(
    IN      DNS_CONFIG_TYPE     Config,
    IN      DWORD               Flag,
    IN      PWSTR               pwsAdapterName,
    IN      PVOID               pReserved,
    OUT     PVOID               pBuffer,
    IN OUT  PDWORD              pBufferLength
    );



//
//  DNS resource record structure
//

//
//  Record data for specific types
//

typedef struct
{
    IP4_ADDRESS     IpAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    LPTSTR          pNameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    LPTSTR          pNamePrimaryServer;
    LPTSTR          pNameAdministrator;
    DWORD           dwSerialNo;
    DWORD           dwRefresh;
    DWORD           dwRetry;
    DWORD           dwExpire;
    DWORD           dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    LPTSTR          pNameMailbox;
    LPTSTR          pNameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    LPTSTR          pNameExchange;
    WORD            wPreference;
    WORD            Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD           dwStringCount;
#ifdef MIDL_PASS
    [size_is(dwStringCount)] LPTSTR pStringArray[];
#else
    LPTSTR          pStringArray[1];
#endif
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    DWORD           dwByteCount;
#ifdef MIDL_PASS
    [size_is(dwByteCount)] BYTE Data[];
#else
    BYTE            Data[1];
#endif
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP4_ADDRESS     IpAddress;
    UCHAR           chProtocol;
    BYTE            BitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    DNS_IP6_ADDRESS Ip6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    LPTSTR          pNameSigner;
    WORD            wTypeCovered;
    BYTE            chAlgorithm;
    BYTE            chLabelCount;
    DWORD           dwOriginalTtl;
    DWORD           dwExpiration;
    DWORD           dwTimeSigned;
    WORD            wKeyTag;
    WORD            Pad;            // keep byte field aligned
    BYTE            Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD            wFlags;
    BYTE            chProtocol;
    BYTE            chAlgorithm;
    BYTE            Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    WORD            wVersion;
    WORD            wSize;
    WORD            wHorPrec;
    WORD            wVerPrec;
    DWORD           dwLatitude;
    DWORD           dwLongitude;
    DWORD           dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    LPTSTR          pNameNext;
    WORD            wNumTypes;
    WORD            wTypes[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    LPTSTR          pNameTarget;
    WORD            wPriority;
    WORD            wWeight;
    WORD            wPort;
    WORD            Pad;            // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    BYTE            AddressType;
    BYTE            Address[ DNS_ATMA_MAX_ADDR_LENGTH ];

    //  E164 -- Null terminated string of less than
    //      DNS_ATMA_MAX_ADDR_LENGTH
    //
    //  For NSAP (AESA) BCD encoding of exactly
    //      DNS_ATMA_AESA_ADDR_LENGTH
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;

typedef struct
{
    LPTSTR          pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pKey;
    PBYTE           pOtherData;
    DWORD           dwCreateTime;
    DWORD           dwExpireTime;
    WORD            wMode;
    WORD            wError;
    WORD            wKeyLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    LPTSTR          pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pSignature;
    PBYTE           pOtherData;
    LONGLONG        i64CreateTime;
    WORD            wFudgeTime;
    WORD            wOriginalXid;
    WORD            wError;
    WORD            wSigLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD           dwMappingFlag;
    DWORD           dwLookupTimeout;
    DWORD           dwCacheTimeout;
    DWORD           cWinsServerCount;
    IP4_ADDRESS     WinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD           dwMappingFlag;
    DWORD           dwLookupTimeout;
    DWORD           dwCacheTimeout;
    LPTSTR          pNameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (FIELD_OFFSET(DNS_TXT_DATA, pStringArray) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_NULL_DATA, Data) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_WKS_DATA, BitMask) + (ByteCount))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (FIELD_OFFSET(DNS_WINS_DATA, WinsServers) + ((IpCount) * sizeof(IP4_ADDRESS)))


//
//  Record flags
//

typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;
    DWORD   Unused      : 3;

    DWORD   Reserved    : 24;
}
DNS_RECORD_FLAGS;


//
//  Wire Record Sections
//
//  Useable both in record flags "Section" and as index into
//  wire message header section counts.
//

typedef enum _DnsSection
{
    DnsSectionQuestion,
    DnsSectionAnswer,
    DnsSectionAuthority,
    DnsSectionAddtional,
}
DNS_SECTION;

//  Update message section names

#define DnsSectionZone      DnsSectionQuestion
#define DnsSectionPrereq    DnsSectionAnswer
#define DnsSectionUpdate    DnsSectionAuthority


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)


//
//  Record \ RR set structure
//
//  Note:  The dwReserved flag serves to insure that the substructures
//  start on 64-bit boundaries.  Do NOT pack this structure, as the
//  substructures may contain pointers or int64 values which are
//  properly aligned unpacked.
//

#ifdef MIDL_PASS

#define PDNS_RECORD     PVOID

#else

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    LPTSTR              pName;
    WORD                wType;
    WORD                wDataLength; // Not referenced for DNS record types
                                     // defined above.
    union
    {
        DWORD               DW;     // flags as DWORD
        DNS_RECORD_FLAGS    S;      // flags as structure

    } Flags;

    DWORD               dwTtl;
    DWORD               dwReserved;

    //  Record Data

    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_KEY_DATA    KEY, Key;
        DNS_SIG_DATA    SIG, Sig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_NXT_DATA    NXT, Nxt;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
}
DNS_RECORD, *PDNS_RECORD;

//
//  Header or fixed size of DNS_RECORD
//

#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE

#endif  // PRIVATE_DNS_RECORD



//
//  Resource record set building
//
//  pFirst points to first record in list.
//  pLast points to last record in list.
//

typedef struct _DnsRRSet
{
    PDNS_RECORD     pFirstRR;
    PDNS_RECORD     pLastRR;
}
DNS_RRSET, *PDNS_RRSET;


//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the pFirst ptr as a DNS_RECORD.  (It is a DNS_RECORD with
//  only a pNext field, but that's the only part we use.)
//
//  Then when the first record is added to the list, the pNext field of
//  this dummy record (which corresponds to pFirst's value) is set to
//  point at the first record.  So pFirst then properly points at the
//  first record.
//
//  (This works only because pNext is the first field in a
//  DNS_RECORD structure and hence casting a PDNS_RECORD ptr to
//  PDNS_RECORD* and dereferencing yields its pNext field)
//
//  Use TERMINATE when have built RR set by grabbing records out of
//  existing set.   This makes sure that at the end, the last RR is
//  properly NULL terminated.
//

#define DNS_RRSET_INIT( rrset )                 \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pFirstRR = NULL;           \
            _prrset->pLastRR = (PDNS_RECORD) &_prrset->pFirstRR; \
        }

#define DNS_RRSET_ADD( rrset, pnewRR )          \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            PDNS_RECORD _prrnew = (pnewRR);     \
            _prrset->pLastRR->pNext = _prrnew;  \
            _prrset->pLastRR = _prrnew;         \
        }

#define DNS_RRSET_TERMINATE( rrset )            \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pLastRR->pNext = NULL;     \
        }


//
//  Record set manipulation
//

//
//  Record Copy
//  Record copy functions also do conversion between character sets.
//
//  Note, it might be advisable to directly expose non-Ex copy
//  functions _W, _A for record and set, to avoid exposing the
//  conversion enum.
//

typedef enum _DNS_CHARSET
{
    DnsCharSetUnknown,
    DnsCharSetUnicode,
    DnsCharSetUtf8,
    DnsCharSetAnsi,
}
DNS_CHARSET;


PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#ifdef UNICODE
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#else
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#endif


//
//  Record Compare
//
//  Note:  these routines only compare records of the SAME character set.
//  (ANSI, unicode or UTF8).  Furthermore the routines assume the character
//  set is indicated within the record.  If compare of user created, rather
//  than DNS API created record lists is desired, then caller should use
//  DnsRecordCopy API and compare copies.
//

BOOL
WINAPI
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    );

//
//  Detach next record set from record list
//

PDNS_RECORD
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD     pRecordList
    );

//
//  Free record list
//
//  Only supported free is deep free of entire record list with LocalFree().
//  This correctly frees record list returned by DnsQuery() or DnsRecordSetCopy()
//

typedef enum
{
    DnsFreeFlat = 0,
    DnsFreeRecordList
}
DNS_FREE_TYPE;

#define DnsFreeRecordListDeep   DnsFreeRecordList


VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    );

VOID
WINAPI
DnsFree(
    IN OUT  PVOID           pData,
    IN      DNS_FREE_TYPE   FreeType
    );



//
//  DNS Query API
//

//
//  Options for DnsQuery
//

#define DNS_QUERY_STANDARD                  0x00000000
#define DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE 0x00000001
#define DNS_QUERY_USE_TCP_ONLY              0x00000002
#define DNS_QUERY_NO_RECURSION              0x00000004
#define DNS_QUERY_BYPASS_CACHE              0x00000008

#define DNS_QUERY_NO_WIRE_QUERY             0x00000010
#define DNS_QUERY_NO_LOCAL_NAME             0x00000020
#define DNS_QUERY_NO_HOSTS_FILE             0x00000040
#define DNS_QUERY_NO_NETBT                  0x00000080

#define DNS_QUERY_WIRE_ONLY                 0x00000100
#define DNS_QUERY_RETURN_MESSAGE            0x00000200

#define DNS_QUERY_TREAT_AS_FQDN             0x00001000
#define DNS_QUERY_DONT_RESET_TTL_VALUES     0x00100000
#define DNS_QUERY_RESERVED                  0xff000000



//  Backward compatibility with Win2K
//  Do not use

#define DNS_QUERY_CACHE_ONLY                DNS_QUERY_NO_WIRE_QUERY



DNS_STATUS
WINAPI
DnsQuery_A(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    );

DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    );

DNS_STATUS
WINAPI
DnsQuery_W(
    IN      PCWSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    );

#ifdef UNICODE
#define DnsQuery DnsQuery_W
#else
#define DnsQuery DnsQuery_A
#endif




//
//  DNS Update API
//
//      DnsAcquireContextHandle
//      DnsReleaseContextHandle
//      DnsModifyRecordsInSet
//      DnsReplaceRecordSet
//

//
//  Update flags
//

#define DNS_UPDATE_SECURITY_USE_DEFAULT     0x00000000
#define DNS_UPDATE_SECURITY_OFF             0x00000010
#define DNS_UPDATE_SECURITY_ON              0x00000020
#define DNS_UPDATE_SECURITY_ONLY            0x00000100
#define DNS_UPDATE_CACHE_SECURITY_CONTEXT   0x00000200
#define DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT  0x00000400
#define DNS_UPDATE_FORCE_SECURITY_NEGO      0x00000800
#define DNS_UPDATE_TRY_ALL_MASTER_SERVERS   0x00001000
#define DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS  0x00002000
#define DNS_UPDATE_RESERVED                 0xffff0000


//
//  Note:  pCredentials paramater is currently respectively
//  PSEC_WINNT_AUTH_IDENTITY_W or PSEC_WINNT_AUTH_IDENTITY_A.
//  Using PVOID to obviate the need for including rpcdce.h
//  in order to include this file and to leave open the
//  possibility of alternative credential specifications in
//  the future.
//

DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    IN      DWORD           CredentialFlags,
    IN      PVOID           pCredentials,       OPTIONAL
    //IN      PSEC_WINNT_AUTH_IDENTITY_W  pCredentials,
    OUT     PHANDLE         pContextHandle
    );

DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    IN      DWORD           CredentialFlags,
    IN      PVOID           pCredentials,       OPTIONAL
    //IN      PSEC_WINNT_AUTH_IDENTITY_A  pCredentials,
    OUT     PHANDLE         pContextHandle
    );

#ifdef UNICODE
#define DnsAcquireContextHandle DnsAcquireContextHandle_W
#else
#define DnsAcquireContextHandle DnsAcquireContextHandle_A
#endif


VOID
WINAPI
DnsReleaseContextHandle(
    IN      HANDLE          hContext
    );

//
//  Dynamic Update API
//

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_W(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_A(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_UTF8(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

#ifdef UNICODE
#define DnsModifyRecordsInSet  DnsModifyRecordsInSet_W
#else
#define DnsModifyRecordsInSet  DnsModifyRecordsInSet_A
#endif


DNS_STATUS
WINAPI
DnsReplaceRecordSetW(
    IN      PDNS_RECORD     pNewSet,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSetA(
    IN      PDNS_RECORD     pNewSet,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSetUTF8(
    IN      PDNS_RECORD     pNewSet,
    IN      DWORD           Options,
    IN      HANDLE          hContext,       OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    );

#ifdef UNICODE
#define DnsReplaceRecordSet  DnsReplaceRecordSetW
#else
#define DnsReplaceRecordSet  DnsReplaceRecordSetA
#endif



//
//  DNS name validation
//

typedef enum _DNS_NAME_FORMAT
{
    DnsNameDomain,
    DnsNameDomainLabel,
    DnsNameHostnameFull,
    DnsNameHostnameLabel,
    DnsNameWildcard,
    DnsNameSrvRecord
}
DNS_NAME_FORMAT;


DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

#ifdef UNICODE
#define DnsValidateName(p,f)    DnsValidateName_W( (p), (f) )
#else
#define DnsValidateName(p,f)    DnsValidateName_A( (p), (f) )
#endif


//
//  DNS name comparison
//

BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR           pName1,
    IN      LPSTR           pName2
    );

BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    );

#ifdef UNICODE
#define DnsNameCompare(n1,n2)   DnsNameCompare_W( (n1),(n2) )
#else
#define DnsNameCompare(n1,n2)   DnsNameCompare_A( (n1),(n2) )
#endif



//
//  DNS message "roll-your-own" routines
//

typedef struct _DNS_MESSAGE_BUFFER
{
    DNS_HEADER  MessageHead;
    CHAR        MessageBody[1];
}
DNS_MESSAGE_BUFFER, *PDNS_MESSAGE_BUFFER;

BOOL
WINAPI
DnsWriteQuestionToBuffer_W(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  LPDWORD             pdwBufferSize,
    IN      LPWSTR              pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    );

BOOL WINAPI
DnsWriteQuestionToBuffer_UTF8(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  LPDWORD             pdwBufferSize,
    IN      LPSTR               pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    );

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_W(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    OUT     PDNS_RECORD *       ppRecord
    );

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_UTF8(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    OUT     PDNS_RECORD *       ppRecord
    );

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _WINDNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\windbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/**


 Module: windbase.h

 Purpose: Master include file for WINCE Database APIs

**/

// @doc OBJSTORE
/*
@topic Windows CE Object Store |
    The Windows CE object store has 3 parts - a registry API, a file system API and a database API. 
    <nl>The standard Win32 API's supported by the registry are:
    <nl>RegCloseKey 
    <nl>RegCreateKeyEx
    <nl>RegDeleteKey
    <nl>RegDeleteValue
    <nl>RegEnumValue
    <nl>RegEnumKeyEx
    <nl>RegOpenKeyEx
    <nl>RegQueryInfoKey
    <nl>RegQueryValueEx
    <nl>RegSetValueEx

    The standard Win32 API's supported by the filesytem are:
    <nl>CreateDirectory
    <nl>RemoveDirectory
    <nl>MoveFile
    <nl>CopyFile
    <nl>DeleteFile
    <nl>GetFileAttributes
    <nl>FindFirstFile
    <nl>CreateFileW
    <nl>ReadFile
    <nl>WriteFile
    <nl>GetFileSize
    <nl>SetFilePointer
    <nl>GetFileInformationByHandle
    <nl>FlushFileBuffers
    <nl>GetFileTime
    <nl>SetFileTime
    <nl>SetEndOfFile
    <nl>FindClose
    <nl>FindNextFile

    In addition, the following additional filesystem call is available:
    <nl>CreateContainer

    The various functions and data structures are described in this
    document.
*/

#pragma once

#ifndef __WINDBASE__
#define __WINDBASE__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


// @CESYSGEN IF CE_MODULES_FILESYS

/*
@type CEOID | Unique identifier for all WINCE objects
@comm Every WINCE object can be efficiently referred to by its OID. OID's are unique
      in the system and are not reused 
*/
typedef DWORD CEOID;
typedef CEOID *PCEOID;

typedef struct  _CEGUID {
    DWORD Data1;
    DWORD Data2;
    DWORD Data3;
    DWORD Data4;
} CEGUID, *PCEGUID;


#ifndef WM_DBNOTIFICATION
#define WM_DBNOTIFICATION 0x03FD
#else
ERRFALSE(WM_DBNOTIFICATION == 0x03FD);
#endif

#define CEDB_EXNOTIFICATION 0x00000001
typedef struct _CENOTIFYREQUEST {
    DWORD dwSize;   // must be set to the structure size
    HWND  hwnd;     // window handle for notifications to be posted
    DWORD dwFlags;
    HANDLE hHeap;   // heap from which to allocate EX-NOTIFICATIONS
    DWORD  dwParam;
} CENOTIFYREQUEST, *PCENOTIFYREQUEST;


typedef struct _CENOTIFICATION {
    DWORD dwSize;
    DWORD dwParam;
    UINT  uType;
    CEGUID guid;
    CEOID  oid;
    CEOID  oidParent;
} CENOTIFICATION, *PCENOTIFICATION;

// @CESYSGEN IF FILESYS_FSMAIN

// @struct CEFILEINFO | Contains information about a file object    
typedef struct _CEFILEINFO {
    DWORD    dwAttributes;         //@field File attributes
    CEOID    oidParent;            //@field CEOID of parent directory
    WCHAR    szFileName[MAX_PATH]; //@field Full path name of the file
    FILETIME ftLastChanged;        //@field Time stamp of last change
    DWORD    dwLength;             //@field Length of file
} CEFILEINFO, *PCEFILEINFO;

//@struct CEDIRINFO | Contains information about a directory object    
typedef struct _CEDIRINFO {
    DWORD dwAttributes;        //@field Directory attributes
    CEOID oidParent;           //@field CEOID of parent directory
    WCHAR szDirName[MAX_PATH]; //@field Full path name of the directory
} CEDIRINFO, *PCEDIRINFO;

/*
@msg DB_CEOID_CREATED | Msg sent on creation of new oid
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_CREATED            (WM_USER + 0x1)
/*
@msg DB_CEOID_DATABASE_DELETED | Msg sent on deletion of database
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_DATABASE_DELETED   (WM_USER + 0x2)
/*
@msg DB_CEOID_RECORD_DELETED | Msg sent on deletion of record
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_RECORD_DELETED     (WM_USER + 0x3)
/*
@msg DB_CEOID_FILE_DELETED | Msg sent on deletion of file
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_FILE_DELETED       (WM_USER + 0x4)
/*
@msg DB_CEOID_DIRECTORY_DELETED | Msg sent on deletion of directory
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_DIRECTORY_DELETED  (WM_USER + 0x5)
/*
@msg DB_CEOID_CHANGED | Msg sent on item modification
@comm WParam == CEOID modified
      LParam == CEOID's parent CEOID
@xref <f CeRegisterReplNotification>      
*/
#define DB_CEOID_CHANGED            (WM_USER + 0x6)

//--------------------------------------------------------------------------
// New for EDB
#ifdef EDB
#define DB_NOTIFY_VOLUME_CHANGED               (WM_USER+0x8)
#define DB_NOTIFY_RECORD_CREATED               (DB_CEOID_CREATED)
#define DB_NOTIFY_RECORD_CHANGED               (DB_CEOID_CHANGED)
#define DB_NOTIFY_RECORD_DELETED               (DB_CEOID_RECORD_DELETED)
#endif

// flags for CeGetReplChangeMask
#define REPL_CHANGE_WILLCLEAR   0x00000001

typedef struct STORE_INFORMATION {
    DWORD dwStoreSize;
    DWORD dwFreeSize;
} STORE_INFORMATION, *LPSTORE_INFORMATION;

BOOL GetStoreInformation (LPSTORE_INFORMATION lpsi);

// @CESYSGEN ENDIF

// @CESYSGEN IF FILESYS_FSDBASE

/*
@type CEPROPID | PropID's for WINCE properties
@comm PropID's on the WINCE match PropID's used by Mapi1. The top 2 bytes are an ID
     and the low 2 bytes are the type. For a list of supported types look at the tags
     supported in <t CEVALUNION>. We reserve one bit (0x4000) in the type as the 
     flag <b CEPROPVAL_NULL> as a special flag. It denotes that a property was not 
     found in a Read call, or that the property should be deleted in a write call.
*/
typedef DWORD CEPROPID;
typedef CEPROPID *PCEPROPID;
#define TypeFromPropID(propid) LOWORD(propid)

//@struct CERECORDINFO | Contains information about a record object    
typedef struct _CERECORDINFO {
    CEOID  oidParent;          //@field CEOID of parent database
} CERECORDINFO, *PCERECORDINFO;

#define CEDB_SORT_DESCENDING        0x00000001
#define CEDB_SORT_CASEINSENSITIVE   0x00000002
#define CEDB_SORT_UNKNOWNFIRST      0x00000004
#define CEDB_SORT_GENERICORDER      0x00000008  // internally used for generic ordering
#define CEDB_SORT_IGNORENONSPACE    0x00000010
#define CEDB_SORT_IGNORESYMBOLS     0x00000020
#define CEDB_SORT_IGNOREKANATYPE    0x00000040
#define CEDB_SORT_IGNOREWIDTH       0x00000080
#define CEDB_SORT_STRINGSORT        0x00000100
#define CEDB_SORT_UNIQUE            0x00000200
#define CEDB_SORT_NONNULL           0x00000400

 //--------------------------------------------------------------------------
// New for EDB
#ifdef EDB
// New CEDB_SORT_xxx flags
//
#define CEDB_SORT_NO_POSITIONAL     (0x00000800)
#define CEDB_SORT_PRIMARYKEY        ((0x00001000) | CEDB_SORT_UNIQUE)
#endif

// High nibble of flags reserved
//@struct SORTORDERSPEC | Specifies details about a sort order in a database
//@comm Note that we only support simple sorts on a primary key. Records with the same key value
//      will be sorted in arbitrary order.
typedef struct _SORTORDERSPEC {
    CEPROPID  propid;   //@field PropID to be sorted on.
    DWORD     dwFlags;  //@field Any combination of the following
                        //@flag CEDB_SORT_DESCENDING | Sort in descending order. Default is ascending.
                        //@flag CEDB_SORT_CASEINSENSITIVE | Only valid for strings.
                        //@flag CEDB_SORT_UNKNOWNFIRST | Puts records which do 
                        // not contain this property before all the other records.
                        // Default is to put them last.
                        //@flag CEDB_SORT_IGNORENONSPACE | Only valid for strings.
                        // This flag only has an effect for the locales in which 
                        // accented characters are sorted in a second pass from
                        // main characters.
                        //@flag CEDB_SORT_IGNORESYMBOLS | Only valid for strings.
                        //@flag CEDB_SORT_IGNOREKANATYPE | Only valid for strings.
                        // Do not differentiate between Hiragana and Katakana characters.
                        //@flag CEDB_SORT_IGNOREWIDTH | Only valid for strings.
                        // Do not differentiate between a single-byte character 
                        // and the same character as a double-byte character.
                        //@flag CEDB_SORT_UNIQUE | Require the property to be
                        // unique across all records in the database.
                        //@flag CEDB_SORT_NONNULL | Require the property to be
                        // present in all records.
} SORTORDERSPEC, *PSORTORDERSPEC;

#define __CEDB_MAXSORTPROP  3
#define __EDB_MAXSORTPROP   16

#ifndef EDB
#define CEDB_MAXSORTPROP    __CEDB_MAXSORTPROP 
#else
#define CEDB_MAXSORTPROP    __EDB_MAXSORTPROP 
#endif

#define __CEDB_SORTORDERSPECEX_VERSION  1
#define __EDB_SORTORDERSPECEX_VERSION   2

#ifndef EDB
#define SORTORDERSPECEX_VERSION         __CEDB_SORTORDERSPECEX_VERSION
#else
#define SORTORDERSPECEX_VERSION         __EDB_SORTORDERSPECEX_VERSION
#endif

//@struct __CEDB_SORTORDERSPECEX | Specifies details about a sort order in a database
//@comm Supports a hierarchy of sorts.
typedef struct __CEDB_SORTORDERSPECEX {
    WORD      wVersion;    //@field Version of this structure.
    WORD      wNumProps;   //@field Number of properties in this sort order.
                           // Must not be more than CEDB_MAXSORTPROP.
    WORD      wKeyFlags;   //@field Flags that correspond to the sort key.
                           // Any combination of the following:
                           //@flag CEDB_SORT_UNIQUE | Require the key to be
                           // unique across all records in the database.
    WORD      wReserved;   //Padding for DWORD alignment
    CEPROPID  rgPropID[__CEDB_MAXSORTPROP]; //@field Array of PropIDs to be sorted
                           // on, in order of importance.
    DWORD     rgdwFlags[__CEDB_MAXSORTPROP]; //@field Flags that correspond to the sort PropIDs
                           // Any combination of the following:
                           //@flag CEDB_SORT_DESCENDING | Sort in descending order. Default is ascending
                           //@flag CEDB_SORT_CASEINSENSITIVE | Only valid for strings.
                           //@flag CEDB_SORT_UNKNOWNFIRST | Puts records which do 
                           // not contain this property before all the other records.
                           // Default is to put them last.
                           //@flag CEDB_SORT_IGNORENONSPACE | Only valid for strings.
                           // This flag only has an effect for the locales in which 
                           // accented characters are sorted in a second pass from
                           // main characters.
                           //@flag CEDB_SORT_IGNORESYMBOLS | Only valid for strings.
                           //@flag CEDB_SORT_IGNOREKANATYPE | Only valid for strings.
                           // Do not differentiate between Hiragana and Katakana characters.
                           //@flag CEDB_SORT_IGNOREWIDTH | Only valid for strings.
                           // Do not differentiate between a single-byte character 
                           // and the same character as a double-byte character.
                           //@flag CEDB_SORT_NONNULL | Require the property to be
                           // present in all records.
} __CEDB_SORTORDERSPECEX;

//@struct __EDB_SORTORDERSPECEX | Specifies details about a sort order in a database
//@comm Supports a hierarchy of sorts.
typedef struct __EDB_SORTORDERSPECEX {
    WORD      wVersion;    //@field Version of this structure.
    WORD      wNumProps;   //@field Number of properties in this sort order.
                           // Must not be more than CEDB_MAXSORTPROP.
    WORD      wKeyFlags;   //@field Flags that correspond to the sort key.
                           // Any combination of the following:
                           //@flag CEDB_SORT_UNIQUE | Require the key to be
                           // unique across all records in the database.
    WORD      wReserved;   //Padding for DWORD alignment
    CEPROPID  rgPropID[__EDB_MAXSORTPROP]; //@field Array of PropIDs to be sorted
                           // on, in order of importance.
    DWORD     rgdwFlags[__EDB_MAXSORTPROP]; //@field Flags that correspond to the sort PropIDs
                           // Any combination of the following:
                           //@flag CEDB_SORT_DESCENDING | Sort in descending order. Default is ascending
                           //@flag CEDB_SORT_CASEINSENSITIVE | Only valid for strings.
                           //@flag CEDB_SORT_UNKNOWNFIRST | Puts records which do 
                           // not contain this property before all the other records.
                           // Default is to put them last.
                           //@flag CEDB_SORT_IGNORENONSPACE | Only valid for strings.
                           // This flag only has an effect for the locales in which 
                           // accented characters are sorted in a second pass from
                           // main characters.
                           //@flag CEDB_SORT_IGNORESYMBOLS | Only valid for strings.
                           //@flag CEDB_SORT_IGNOREKANATYPE | Only valid for strings.
                           // Do not differentiate between Hiragana and Katakana characters.
                           //@flag CEDB_SORT_IGNOREWIDTH | Only valid for strings.
                           // Do not differentiate between a single-byte character 
                           // and the same character as a double-byte character.
                           //@flag CEDB_SORT_NONNULL | Require the property to be
                           // present in all records.
} __EDB_SORTORDERSPECEX;

#ifndef EDB
// Default to the CEDB version of the SORTORDERSPECEX structure.
typedef __CEDB_SORTORDERSPECEX SORTORDERSPECEX, *PSORTORDERSPECEX;
#else
// Default to the EDB version of the SORTORDERSPECEX structure.
typedef __EDB_SORTORDERSPECEX SORTORDERSPECEX, *PSORTORDERSPECEX;
#endif // EDB

// NOTENOTE someday this should become a separate CE-only error code
#define ERROR_DBPROP_NOT_FOUND  ERROR_ACCESS_DENIED
#define ERROR_REPEATED_KEY      ERROR_ALREADY_EXISTS

#define __CEDB_MAXDBASENAMELEN  32
#define __EDB_MAXDBASENAMELEN   128

#ifndef EDB
#define CEDB_MAXDBASENAMELEN    __CEDB_MAXDBASENAMELEN 
#else
#define CEDB_MAXDBASENAMELEN    __EDB_MAXDBASENAMELEN
#endif

#define __CEDB_MAXSORTORDER 4
#define __EDB_MAXSORTORDER  32

#ifndef EDB
#define CEDB_MAXSORTORDER   __CEDB_MAXSORTORDER 
#else
#define CEDB_MAXSORTORDER   __EDB_MAXSORTORDER 
#endif

// values for validity mask flags
#define CEDB_VALIDNAME     0x0001
#define CEDB_VALIDTYPE     0x0002
#define CEDB_VALIDSORTSPEC 0x0004
#define CEDB_VALIDMODTIME  0x0008
#define CEDB_VALIDDBFLAGS  0x0010
#define CEDB_VALIDCREATE   (CEDB_VALIDNAME | CEDB_VALIDTYPE | CEDB_VALIDSORTSPEC | CEDB_VALIDDBFLAGS)

// values for dbflags
#define CEDB_NOCOMPRESS    0x00010000
#define CEDB_SYSTEMDB      0x00020000


// @struct __CEDB_CEDBASEINFO | Contains information about a database object    
typedef struct __CEDB_CEDBASEINFO {
    DWORD    dwFlags;           //@field Indicates which fields are valid. Possible values are:
                                //  @flag CEDB_VALIDNAME | The name field is valid and should be used
                                //  @flag CEDB_VALIDTYPE | The type field is valid and should be used
                                //  @flag CEDB_VALIDSORTSPEC | The sortspecs are valid and should be used
    WCHAR    szDbaseName[__CEDB_MAXDBASENAMELEN]; //@field Name of Database. Max CEDB_MAXDBASENAMELEN characters.
    DWORD    dwDbaseType;       //@field A type ID for this database
    WORD     wNumRecords;       //@field Number of records in the database
    WORD     wNumSortOrder;     //@field Number of sort orders active in the database
                                // Maximum is CEDB_MAXSORTORDER.
    DWORD    dwSize;            //@field Size in bytes that this database is using
    FILETIME ftLastModified;    //@field Last time this database was modified
    SORTORDERSPEC rgSortSpecs[__CEDB_MAXSORTORDER];  //@field Actual sort order descriptions. 
                                // Only first wNumSortOrder of this array are valid.
} __CEDB_CEDBASEINFO;

// @struct __EDB_CEDBASEINFO | Contains information about a database object    
typedef struct __EDB_CEDBASEINFO {
    DWORD    dwFlags;           //@field Indicates which fields are valid. Possible values are:
                                //  @flag CEDB_VALIDNAME | The name field is valid and should be used
                                //  @flag CEDB_VALIDTYPE | The type field is valid and should be used
                                //  @flag CEDB_VALIDSORTSPEC | The sortspecs are valid and should be used
    WCHAR    szDbaseName[__EDB_MAXDBASENAMELEN]; //@field Name of Database. Max CEDB_MAXDBASENAMELEN characters.
    DWORD    dwDbaseType;       //@field A type ID for this database
    WORD     wNumRecords;       //@field Number of records in the database
    WORD     wNumSortOrder;     //@field Number of sort orders active in the database
                                // Maximum is CEDB_MAXSORTORDER.
    DWORD    dwSize;            //@field Size in bytes that this database is using
    FILETIME ftLastModified;    //@field Last time this database was modified
    SORTORDERSPEC rgSortSpecs[__EDB_MAXSORTORDER];  //@field Actual sort order descriptions. 
                                // Only first wNumSortOrder of this array are valid.
} __EDB_CEDBASEINFO;

#ifndef EDB
// Default to the CEDB version of the CEDBASEINFO structure.
typedef __CEDB_CEDBASEINFO CEDBASEINFO, *PCEDBASEINFO;
#else
// Default to the EDB version of the CEDBASEINFO structure.
typedef __EDB_CEDBASEINFO CEDBASEINFO, *PCEDBASEINFO;
#endif 

#define __CEDB_CEDBASEINFOEX_VERSION    1
#define __EDB_CEDBASEINFOEX_VERSION     2

#ifndef EDB
#define CEDBASEINFOEX_VERSION           __CEDB_CEDBASEINFOEX_VERSION 
#else
#define CEDBASEINFOEX_VERSION           __EDB_CEDBASEINFOEX_VERSION
#endif
// @struct __CEDB_CEDBASEINFOEX | Contains extended information about a database object    
typedef struct __CEDB_CEDBASEINFOEX {
    WORD     wVersion;          //@field Version of this structure
    WORD     wNumSortOrder;     //@field Number of sort orders active in the database
                                // Maximum is CEDB_MAXSORTORDER.
    DWORD    dwFlags;           //@field Indicates which fields are valid. Possible values are:
                                //  @flag CEDB_VALIDNAME | The name field is valid and should be used
                                //  @flag CEDB_VALIDTYPE | The type field is valid and should be used
                                //  @flag CEDB_VALIDSORTSPEC | The sortspecs are valid and should be used
    WCHAR    szDbaseName[__CEDB_MAXDBASENAMELEN]; //@field Name of Database. Max CEDB_MAXDBASENAMELEN characters.
    DWORD    dwDbaseType;       //@field A type ID for this database
    DWORD    dwNumRecords;      //@field Number of records in the database
    DWORD    dwSize;            //@field Size in bytes that this database is using
    FILETIME ftLastModified;    //@field Last time this database was modified
    SORTORDERSPECEX rgSortSpecs[__CEDB_MAXSORTORDER];  //@field Actual sort order descriptions. 
                                // Only first wNumSortOrder of this array are valid.
} __CEDB_CEDBASEINFOEX;

// @struct __EDB_DBASEINFOEX | Contains extended information about a database object    
typedef struct __EDB_CEDBASEINFOEX {
    WORD     wVersion;          //@field Version of this structure
    WORD     wNumSortOrder;     //@field Number of sort orders active in the database
                                // Maximum is CEDB_MAXSORTORDER.
    DWORD    dwFlags;           //@field Indicates which fields are valid. Possible values are:
                                //  @flag CEDB_VALIDNAME | The name field is valid and should be used
                                //  @flag CEDB_VALIDTYPE | The type field is valid and should be used
                                //  @flag CEDB_VALIDSORTSPEC | The sortspecs are valid and should be used
    WCHAR    szDbaseName[__EDB_MAXDBASENAMELEN]; //@field Name of Database. Max CEDB_MAXDBASENAMELEN characters.
    DWORD    dwDbaseType;       //@field A type ID for this database
    DWORD    dwNumRecords;      //@field Number of records in the database
    DWORD    dwSize;            //@field Size in bytes that this database is using
    FILETIME ftLastModified;    //@field Last time this database was modified
    SORTORDERSPECEX rgSortSpecs[__EDB_MAXSORTORDER];  //@field Actual sort order descriptions. 
                                // Only first wNumSortOrder of this array are valid.
} __EDB_CEDBASEINFOEX;

#ifndef EDB
// Default to the CEDB version of the CEDBASEINFOEX structure.
typedef __CEDB_CEDBASEINFOEX CEDBASEINFOEX, *PCEDBASEINFOEX;
#else
// Default to the EDB version of the CEDBASEINFOEX structure.
typedef __EDB_CEDBASEINFOEX CEDBASEINFOEX, *PCEDBASEINFOEX;
#endif

#define __CEDB_BY_HANDLE_DB_INFORMATION_VERSION 1
#define __EDB_BY_HANDLE_DB_INFORMATION_VERSION  2

#ifndef EDB
#define BY_HANDLE_DB_INFORMATION_VERSION        __CEDB_BY_HANDLE_DB_INFORMATION_VERSION 
#else
#define BY_HANDLE_DB_INFORMATION_VERSION        __EDB_BY_HANDLE_DB_INFORMATION_VERSION 
#endif

// @struct __CEDB_BY_HANDLE_DB_INFORMATION | Contains extended information about an open database
typedef struct __CEDB_BY_HANDLE_DB_INFORMATION {
    WORD     wVersion;          //@field Version of this structure
    WORD     wReserved;         //Padding for DWORD alignment
    CEGUID   guidVol;           //@field GUID of parent volume
    CEOID    oidDbase;          //@field OID of database
    __CEDB_CEDBASEINFOEX infDatabase;  //@field Extended database information
} __CEDB_BY_HANDLE_DB_INFORMATION;

// @struct __EDB_BY_HANDLE_DB_INFORMATION | Contains extended information about an open database
typedef struct __EDB_BY_HANDLE_DB_INFORMATION {
    WORD     wVersion;          //@field Version of this structure
    WORD     wReserved;         //Padding for DWORD alignment
    CEGUID   guidVol;           //@field GUID of parent volume
    CEOID    oidDbase;          //@field OID of database
    __EDB_CEDBASEINFOEX infDatabase;  //@field Extended database information
} __EDB_BY_HANDLE_DB_INFORMATION;

#ifndef EDB
// Default to the CEDB version of the BY_HANDLE_DB_INFORMATION structure.
typedef __CEDB_BY_HANDLE_DB_INFORMATION BY_HANDLE_DB_INFORMATION, *LPBY_HANDLE_DB_INFORMATION;
#else
// Default to the EDB version of the BY_HANDLE_DB_INFORMATION structure.
typedef __EDB_BY_HANDLE_DB_INFORMATION BY_HANDLE_DB_INFORMATION, *LPBY_HANDLE_DB_INFORMATION;
#endif

// flags for open database - use low word
#define CEDB_AUTOINCREMENT          0x00000001

// added for dynamic column support
#ifdef EDB
#define EDB_USE_CEDB_WRITE_SEMANTICS    0x00000002
#endif

#define CEDB_SEEK_CEOID             0x00000001
#define CEDB_SEEK_BEGINNING         0x00000002
#define CEDB_SEEK_END               0x00000004
#define CEDB_SEEK_CURRENT           0x00000008
#define CEDB_SEEK_VALUESMALLER      0x00000010
#define CEDB_SEEK_VALUEFIRSTEQUAL   0x00000020
#define CEDB_SEEK_VALUEGREATER      0x00000040
#define CEDB_SEEK_VALUENEXTEQUAL    0x00000080

//--------------------------------------------------------------------------
// New for EDB
#ifdef EDB
//--------------------------------------------------------------------------
// Prefix search type
// 
#define CEDB_SEEK_PREFIX                        0x00000100

//--------------------------------------------------------------------------
// New seek types
//
#define CEDB_SEEK_VALUEGREATEROREQUAL           0x00000200
#define CEDB_SEEK_VALUESMALLEROREQUAL           0x00000400
#endif


typedef struct _CEBLOB {
    DWORD           dwCount;
    LPBYTE          lpb;
} CEBLOB, *PCEBLOB;


#define CEVT_I2                2
#define CEVT_UI2            18
#define CEVT_I4                3
#define CEVT_UI4            19
#define CEVT_FILETIME   64
#define CEVT_LPWSTR     31
#define CEVT_BLOB           65
#define CEVT_BOOL           11
#define CEVT_R8                 5

//--------------------------------------------------------------------------
// New for EDB
#ifdef EDB
//--------------------------------------------------------------------------
// CEVT_STREAM
//
#define CEVT_STREAM                 (100)

//--------------------------------------------------------------------------
// CEVT_RECID
//
#define CEVT_RECID                  (101)

//--------------------------------------------------------------------------
// CEVT_AUTO_I4
//
#define CEVT_AUTO_I4                (102)

//--------------------------------------------------------------------------
// CEVT_AUTO_I8
//
#define CEVT_AUTO_I8                (103)
#endif


// @union CEVALUNION | value types for a property
typedef union _CEVALUNION {
    short           iVal;     //@field CEVT_I2
    USHORT          uiVal;    //@field CEVT_UI2
    long            lVal;     //@field CEVT_I4
    ULONG           ulVal;    //@field CEVT_UI4
                              //@field CEVT_AUTO_I4_
    FILETIME        filetime; //@field CEVT_FILETIME 
    LPWSTR          lpwstr;   //@field CEVT_LPWSTR - Ptr to null terminated string
    CEBLOB          blob;     //@field CEVT_BLOB - DWORD count, and Ptr to bytes
                              //@field CEVT_AUTO_I8
                              //@field CEVT_RECID
                              //@field CEVT_STREAM
    BOOL            boolVal;  //@field CEVT_BOOL
    double          dblVal;   //@field CEVT_R8
} CEVALUNION, *PCEVALUNION;
 
// @struct CEPROPVAL | Contains a property value
// Don't define flags in low byte or high nibble
#define CEDB_PROPNOTFOUND 0x0100
#define CEDB_PROPDELETE   0x0200
typedef struct _CEPROPVAL {
    CEPROPID   propid;    //@field PropID of the value.
    WORD       wLenData;  //@field Private field - can be garbage on entry
    WORD       wFlags;    //@field Special flags for this property. Possible flags
                          //@flag CEDB_PROPNOTFOUND | Set by <f CeReadRecordProps> if property not found
                          //@flag CEDB_PROPDELETE | If passed to <f CeWriteRecordProps> it causes 
                          // this property to be deleted
    CEVALUNION val;       //@field Actual value for simple types, ptr for strings/blobs                        
} CEPROPVAL, *PCEPROPVAL;

// Max record length defines
// zero is a valid length so we cant have full 4196
#define CEDB_MAXDATABLOCKSIZE 4092
#define __CEDB_MAXPROPDATASIZE  ((CEDB_MAXDATABLOCKSIZE*16)-1)
#define __EDB_MAXPROPDATASIZE   (8*1024)

#ifndef EDB
#define CEDB_MAXPROPDATASIZE  __CEDB_MAXPROPDATASIZE
#else
#define CEDB_MAXPROPDATASIZE  __EDB_MAXPROPDATASIZE
#endif

// max record size is bound only by the max logging space we want to consume
// this is not explicitly checked for - if you read too much data and cause the log
// page to overflow the call will fail.
#define __CEDB_MAXRECORDSIZE (128*1024)
#define __EDB_MAXRECORDSIZE  (8*1024)

#ifndef EDB
#define CEDB_MAXRECORDSIZE __CEDB_MAXRECORDSIZE
#else
#define CEDB_MAXRECORDSIZE __EDB_MAXRECORDSIZE
#endif

// Max number of records allowed in a single database.
#define __CEDB_MAXNUMRECORDS 0xFFFF
// NOTE: EDB has no real record count limit, but define a value for completeness.
#define __EDB_MAXNUMRECORDS  MAXLONG

#ifndef EDB
#define CEDB_MAXNUMRECORDS __CEDB_MAXNUMRECORDS
#else
#define CEDB_MAXNUMRECORDS __EDB_MAXNUMRECORDS
#endif

// flags for ReadRecord
#define CEDB_ALLOWREALLOC  0x00000001

// flags for CeMountDBVol  (Must not collide with file open flags like CREATE_NEW)
#define CEDB_NOBACKGROUNDFLUSH  0x00010000

#define CREATE_SYSTEMGUID(pguid)  (memset((pguid), 0, sizeof(CEGUID)))
#define CREATE_INVALIDGUID(pguid) (memset((pguid), -1, sizeof(CEGUID)))
#ifdef EDB
#define CREATE_INVALIDEDBGUID(pguid)  \
        do {memset((pguid), 0, sizeof(CEGUID)); *((LPBYTE)(pguid)) = 0xff ; } while(0)
#endif

#define CHECK_SYSTEMGUID(pguid)   ! ((pguid)->Data1 | (pguid)->Data2 | (pguid)->Data3 | (pguid)->Data4)
#define CHECK_INVALIDGUID(pguid)  !~((pguid)->Data1 & (pguid)->Data2 & (pguid)->Data3 & (pguid)->Data4)

// Obsolete database APIs for backward compatibility (CEDB only)
HANDLE CeFindFirstDatabase (DWORD dwClassID);
CEOID CeFindNextDatabase (HANDLE hEnum);
CEOID CeCreateDatabase (LPWSTR lpszname, DWORD dwClassID, WORD wNumSortOrder,
                        SORTORDERSPEC *rgSortSpecs);
CEOID CeCreateDatabaseEx (PCEGUID pguid, CEDBASEINFO *pInfo);
BOOL CeSetDatabaseInfo (CEOID oidDbase, CEDBASEINFO *pNewInfo);
BOOL CeSetDatabaseInfoEx (PCEGUID pguid, CEOID oidDbase, CEDBASEINFO *pNewInfo);
HANDLE CeOpenDatabase (PCEOID poid, LPWSTR lpszName, CEPROPID propid,
                       DWORD dwFlags, HWND hwndNotify);
HANDLE CeOpenDatabaseEx (PCEGUID pguid, PCEOID poid, LPWSTR lpszName,
                         CEPROPID propid, DWORD dwFlags, CENOTIFYREQUEST *pReq);
BOOL CeDeleteDatabase (CEOID oid);
CEOID CeReadRecordProps (HANDLE hDbase, DWORD dwFlags, LPWORD lpcPropID,
                         CEPROPID *rgPropID, LPBYTE *lplpBuffer,
                         LPDWORD lpcbBuffer);
CEOID CeSeekDatabase (HANDLE hDatabase, DWORD dwSeekType, DWORD dwValue,
                      LPDWORD lpdwIndex);

// Current database API set
BOOL CeGetDBInformationByHandle (HANDLE hDbase, LPBY_HANDLE_DB_INFORMATION lpDBInfo);
HANDLE CeFindFirstDatabaseEx (PCEGUID pguid, DWORD dwClassID);
CEOID CeFindNextDatabaseEx (HANDLE hEnum, PCEGUID pguid);
CEOID CeCreateDatabaseEx2 (PCEGUID pguid, CEDBASEINFOEX *pInfo);
BOOL CeSetDatabaseInfoEx2 (PCEGUID pguid, CEOID oidDbase, CEDBASEINFOEX *pNewInfo);
HANDLE CeOpenDatabaseEx2 (PCEGUID pguid, PCEOID poid, LPWSTR lpszName,
                          SORTORDERSPECEX* pSort, DWORD dwFlags,
                          CENOTIFYREQUEST *pReq);
BOOL CeDeleteDatabaseEx (PCEGUID pguid, CEOID oid);
CEOID CeSeekDatabaseEx (HANDLE hDatabase, DWORD dwSeekType, DWORD dwValue,
                        WORD wNumVals, LPDWORD lpdwIndex);
BOOL CeDeleteRecord (HANDLE hDatabase, CEOID oidRecord);
CEOID CeReadRecordPropsEx (HANDLE hDbase, DWORD dwFlags, LPWORD lpcPropID,
                           CEPROPID *rgPropID, LPBYTE *lplpBuffer, 
                           LPDWORD lpcbBuffer, HANDLE hHeap);
CEOID CeWriteRecordProps (HANDLE hDbase, CEOID oidRecord, WORD cPropID,
                          __out_ecount(cPropID) CEPROPVAL *rgPropVal);

BOOL CeMountDBVol(PCEGUID pguid, LPWSTR lpszVol, DWORD dwFlags);
BOOL CeUnmountDBVol(PCEGUID pguid);
BOOL CeFlushDBVol(PCEGUID pguid);
BOOL CeEnumDBVolumes(PCEGUID pguid, LPWSTR lpBuf, DWORD dwSize);
BOOL CeFreeNotification(PCENOTIFYREQUEST pRequest, PCENOTIFICATION pNotify);
VOID CeChangeDatabaseLCID(PCEGUID pguid, DWORD LCID);

// @CESYSGEN ENDIF


// @CESYSGEN IF FILESYS_FSMAIN

/*
@struct CEOIDINFO | Contains information about a WINCE object
@field WORD | wObjType | Type of object
   @flag   OBJTYPE_INVALID   | There was no valid object with this CEOID
   @flag   OBJTYPE_FILE      | The object is a file
   @flag   OBJTYPE_DIRECTORY | The object is a directory
   @flag   OBJTYPE_DATABASE  | The object is a database
   @flag   OBJTYPE_RECORD    | The object is a record inside a database
@field <lt>SeeBelow<gt> | <lt>CEOIDINFOUNIONref<gt> | Note: The remaining members form a union
@field CEFILEINFO   | infFile      | Valid for file objects
@field CEDIRINFO    | infDirectory | Valid for directory objects
@field CEDBASEINFO  | infDatabase  | Valid for database objects
@field CERECORDINFO | infRecord    | Valid for record objects
@xref   <t CEFILEINFO>  <t CEDIRINFO> <t CEDBASEINFO>  <t CERECORDINFO>
*/
#define OBJTYPE_INVALID       0
#define OBJTYPE_FILE             1
#define OBJTYPE_DIRECTORY   2
#define OBJTYPE_DATABASE    3
#define OBJTYPE_RECORD        4
#define OBJTYPE_EDB         5

typedef struct __CEDB_CEOIDINFO {
    WORD  wObjType;     //Type of object
            //        OBJTYPE_INVALID   | There was no valid object with this CEOID
            //        OBJTYPE_FILE      | The object is a file
            //        OBJTYPE_DIRECTORY | The object is a directory
            //        OBJTYPE_DATABASE  | The object is a database
            //        OBJTYPE_RECORD    | The object is a record inside a database
    WORD   wPad;        // dword alignment            
    union {             //This is a union 
        CEFILEINFO  infFile;           //Valid for file objects
        CEDIRINFO   infDirectory;      //Valid for directory objects
// @CESYSGEN IF FILESYS_FSDBASE
        __CEDB_CEDBASEINFO infDatabase;       //Valid for database objects
        CERECORDINFO infRecord;        //Valid for record objects
// @CESYSGEN ENDIF
    };
} __CEDB_CEOIDINFO;

typedef struct __EDB_CEOIDINFO {
    WORD  wObjType;     //Type of object
            //        OBJTYPE_INVALID   | There was no valid object with this CEOID
            //        OBJTYPE_FILE      | The object is a file
            //        OBJTYPE_DIRECTORY | The object is a directory
            //        OBJTYPE_DATABASE  | The object is a database
            //        OBJTYPE_RECORD    | The object is a record inside a database
    WORD   wPad;        // dword alignment            
    union {             //This is a union 
        CEFILEINFO  infFile;           //Valid for file objects
        CEDIRINFO   infDirectory;      //Valid for directory objects
// @CESYSGEN IF FILESYS_FSDBASE
        __EDB_CEDBASEINFO infDatabase;       //Valid for database objects
        CERECORDINFO infRecord;        //Valid for record objects
// @CESYSGEN ENDIF
    };
} __EDB_CEOIDINFO;

#ifndef EDB
// Use the CEDB version of the CEOIDINFO structure.
typedef __CEDB_CEOIDINFO CEOIDINFO, *PCEOIDINFO;
#else
// Use the EDB version of the CEOIDINFO structure.
typedef __EDB_CEOIDINFO CEOIDINFO, *PCEOIDINFO;
#endif

#define __CEDB_CEOIDINFOEX_VERSION  1
#define __EDB_CEOIDINFOEX_VERSION   2

#ifndef EDB
#define CEOIDINFOEX_VERSION         __CEDB_CEOIDINFOEX_VERSION
#else
#define CEOIDINFOEX_VERSION         __EDB_CEOIDINFOEX_VERSION
#endif
/*
@struct __CEDB_CEOIDINFOEX | Contains extended information about a WINCE object
@field WORD | wObjType | Type of object
   @flag   OBJTYPE_INVALID   | There was no valid object with this CEOID
   @flag   OBJTYPE_FILE      | The object is a file
   @flag   OBJTYPE_DIRECTORY | The object is a directory
   @flag   OBJTYPE_DATABASE  | The object is a database
   @flag   OBJTYPE_RECORD    | The object is a record inside a database
@field <lt>SeeBelow<gt> | <lt>CEOIDINFOUNIONref<gt> | Note: The remaining members form a union
@field CEFILEINFO   | infFile      | Valid for file objects
@field CEDIRINFO    | infDirectory | Valid for directory objects
@field CEDBASEINFO  | infDatabase  | Valid for database objects
@field CERECORDINFO | infRecord    | Valid for record objects
@xref   <t CEFILEINFO>  <t CEDIRINFO> <t CEDBASEINFO>  <t CERECORDINFO>
*/
typedef struct __CEDB_CEOIDINFOEX {
    WORD  wVersion;    //@field Version of this structure
    WORD  wObjType;    //@field Type of object
                //@flag OBJTYPE_INVALID   | There was no valid object with this CEOID
                //@flag OBJTYPE_FILE      | The object is a file
                //@flag OBJTYPE_DIRECTORY | The object is a directory
                //@flag OBJTYPE_DATABASE  | The object is a database
                //@flag OBJTYPE_RECORD    | The object is a record inside a database
    union {
        CEFILEINFO    infFile;       // Valid for file objects
        CEDIRINFO     infDirectory;  // Valid for directory objects
// @CESYSGEN IF FILESYS_FSDBASE
        __CEDB_CEDBASEINFOEX infDatabase;   // Valid for database objects
        CERECORDINFO  infRecord;     // Valid for record objects
// @CESYSGEN ENDIF
    };
} __CEDB_CEOIDINFOEX;

/*
@struct CEOIDINFOEX | Contains extended information about a WINCE object
@field WORD | wObjType | Type of object
   @flag   OBJTYPE_INVALID   | There was no valid object with this CEOID
   @flag   OBJTYPE_FILE      | The object is a file
   @flag   OBJTYPE_DIRECTORY | The object is a directory
   @flag   OBJTYPE_DATABASE  | The object is a database
   @flag   OBJTYPE_RECORD    | The object is a record inside a database
@field <lt>SeeBelow<gt> | <lt>CEOIDINFOUNIONref<gt> | Note: The remaining members form a union
@field CEFILEINFO   | infFile      | Valid for file objects
@field CEDIRINFO    | infDirectory | Valid for directory objects
@field CEDBASEINFO  | infDatabase  | Valid for database objects
@field CERECORDINFO | infRecord    | Valid for record objects
@xref   <t CEFILEINFO>  <t CEDIRINFO> <t CEDBASEINFO>  <t CERECORDINFO>
*/
typedef struct __EDB_CEOIDINFOEX {
    WORD  wVersion;    //@field Version of this structure
    WORD  wObjType;    //@field Type of object
                //@flag OBJTYPE_INVALID   | There was no valid object with this CEOID
                //@flag OBJTYPE_FILE      | The object is a file
                //@flag OBJTYPE_DIRECTORY | The object is a directory
                //@flag OBJTYPE_DATABASE  | The object is a database
                //@flag OBJTYPE_RECORD    | The object is a record inside a database
    union {
        CEFILEINFO    infFile;       // Valid for file objects
        CEDIRINFO     infDirectory;  // Valid for directory objects
// @CESYSGEN IF FILESYS_FSDBASE
        __EDB_CEDBASEINFOEX infDatabase;   // Valid for database objects
        CERECORDINFO  infRecord;     // Valid for record objects
// @CESYSGEN ENDIF
    };
} __EDB_CEOIDINFOEX;

#ifndef EDB
// Use the CEDB version of the CEOIDINFOEX structure.
typedef __CEDB_CEOIDINFOEX CEOIDINFOEX, *PCEOIDINFOEX;
#else
// Use the EDB version of the CEOIDINFOEX structure.
typedef __EDB_CEOIDINFOEX CEOIDINFOEX, *PCEOIDINFOEX;
#endif

// Functions
BOOL CeOidGetInfoEx2 (PCEGUID pguid, CEOID oid, CEOIDINFOEX *oidInfo);
BOOL CeOidGetInfoEx (PCEGUID pguid, CEOID oid, CEOIDINFO *oidInfo);
BOOL CeOidGetInfo (CEOID oid, CEOIDINFO *oidInfo);

#ifdef EDB
#include <windbase_edb.h>
#endif // EDB

#ifdef WIN32_PLATFORM_WFSP
// Show this warning only for Windows Mobile projects.
#ifndef EDB
#pragma warning(error:4995)
// CEDB is deprecated and will no longer work in future versions of Windows Mobile.  
// It is strongly recommended that you #define EDB which will enable you to use EDB instead.
// To create a program that will not work on future versions, remove the following line: 
#pragma deprecated(CeCreateDatabase,CeCreateDatabaseEx,CeOpenDatabase,CeOpenDatabaseEx,CeOpenDatabaseEx2,CeMountDBVol)
#endif // !EDB
#endif // WIN32_PLATFORM_WFSP


// @CESYSGEN ENDIF

#ifdef WINCEOEM
#include <pwindbas.h>   // internal defines 
#ifdef WINCEMACRO
#include <mwindbas.h>
#endif
#endif

// @CESYSGEN ENDIF

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\windot11.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

    Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    windot11.h

Abstract:

    Definitions for native 802.11 miniport driver specifications.

--*/

#pragma once

#ifndef __WINDOT11_H__
#define __WINDOT11_H__

#ifndef _NTDDNDIS_
#include <ntddndis.h>
#endif

#include <WlanTypes.h>

// These are needed for wlanapi.h for pre-longhorn targets
#ifdef __midl
    typedef struct _DOT11_MAC_ADDRESS {
        UCHAR ucDot11MacAddress[6];
    } DOT11_MAC_ADDRESS, * PDOT11_MAC_ADDRESS;
#else
    typedef UCHAR DOT11_MAC_ADDRESS[6];
    typedef DOT11_MAC_ADDRESS * PDOT11_MAC_ADDRESS;
#endif

// A list of DOT11_MAC_ADDRESS
typedef struct DOT11_BSSID_LIST {
    #define DOT11_BSSID_LIST_REVISION_1  1
    NDIS_OBJECT_HEADER Header;
    ULONG uNumOfEntries;
    ULONG uTotalNumOfEntries;
#ifdef __midl
    [unique, size_is(uTotalNumOfEntries)] DOT11_MAC_ADDRESS BSSIDs[*];
#else
    DOT11_MAC_ADDRESS BSSIDs[1];
#endif
} DOT11_BSSID_LIST, * PDOT11_BSSID_LIST;

#ifdef __midl
// use 4-byte enum
typedef [v1_enum] enum _DOT11_PHY_TYPE {
#else
typedef enum _DOT11_PHY_TYPE {
#endif
    dot11_phy_type_unknown = 0,
    dot11_phy_type_any = dot11_phy_type_unknown,
    dot11_phy_type_fhss = 1,
    dot11_phy_type_dsss = 2,
    dot11_phy_type_irbaseband = 3,
    dot11_phy_type_ofdm = 4,
    dot11_phy_type_hrdsss = 5,
    dot11_phy_type_erp = 6,
    dot11_phy_type_ht = 7,
    dot11_phy_type_IHV_start = 0x80000000,
    dot11_phy_type_IHV_end = 0xffffffff
} DOT11_PHY_TYPE, * PDOT11_PHY_TYPE;

#define DOT11_RATE_SET_MAX_LENGTH               126 // 126 bytes
typedef struct _DOT11_RATE_SET {
    ULONG uRateSetLength;
    __field_ecount_part(DOT11_RATE_SET_MAX_LENGTH, uRateSetLength) UCHAR ucRateSet[DOT11_RATE_SET_MAX_LENGTH];
} DOT11_RATE_SET, * PDOT11_RATE_SET;

typedef UCHAR DOT11_COUNTRY_OR_REGION_STRING[3];
typedef DOT11_COUNTRY_OR_REGION_STRING * PDOT11_COUNTRY_OR_REGION_STRING;


// ntddndis.h: new Flags for OID_GEN_CURRENT_PACKET_FILTER
#define NDIS_PACKET_TYPE_MEDIA_SPECIFIC_MASK        (0x0fff0000U)
    // Mask for media specific packet filters

#define NDIS_PACKET_TYPE_802_11_DIRECTED_DATA       NDIS_PACKET_TYPE_DIRECTED

#define NDIS_PACKET_TYPE_802_11_BROADCAST_DATA      NDIS_PACKET_TYPE_BROADCAST

#define NDIS_PACKET_TYPE_802_11_MULTICAST_DATA      NDIS_PACKET_TYPE_MULTICAST

#define NDIS_PACKET_TYPE_802_11_ALL_MULTICAST_DATA  NDIS_PACKET_TYPE_ALL_MULTICAST

#define NDIS_PACKET_TYPE_802_11_PROMISCUOUS_DATA    NDIS_PACKET_TYPE_PROMISCUOUS

#define NDIS_PACKET_TYPE_802_11_RAW_DATA            (0x00010000U)
    // Raw 802.11 data packets (MPDU)

#define NDIS_PACKET_TYPE_802_11_DIRECTED_MGMT       (0x00020000U)
    // Directed management packet

#define NDIS_PACKET_TYPE_802_11_BROADCAST_MGMT      (0x00040000U)
    // Broadcast management packet

#define NDIS_PACKET_TYPE_802_11_MULTICAST_MGMT      (0x00080000U)
    // Multicast management packet

#define NDIS_PACKET_TYPE_802_11_ALL_MULTICAST_MGMT  (0x00100000U)
    // All-multicast management packet

#define NDIS_PACKET_TYPE_802_11_PROMISCUOUS_MGMT    (0x00200000U)
    // Promiscuous management packet

#define NDIS_PACKET_TYPE_802_11_RAW_MGMT            (0x00400000U)
    // Raw management packet

#define NDIS_PACKET_TYPE_802_11_DIRECTED_CTRL       (0x00800000U)
    // Directed CTRL packet

#define NDIS_PACKET_TYPE_802_11_BROADCAST_CTRL      (0x01000000U)
    // Broadcast CTRL packet

#define NDIS_PACKET_TYPE_802_11_PROMISCUOUS_CTRL    (0x02000000U)
    // Promiscuous CTRL packet

#define NDIS_PACKET_TYPE_ALL_802_11_FILTERS         \
    (NDIS_PACKET_TYPE_DIRECTED |                    \
     NDIS_PACKET_TYPE_MULTICAST |                   \
     NDIS_PACKET_TYPE_ALL_MULTICAST |               \
     NDIS_PACKET_TYPE_BROADCAST |                   \
     NDIS_PACKET_TYPE_PROMISCUOUS |                 \
     NDIS_PACKET_TYPE_802_11_RAW_DATA |             \
     NDIS_PACKET_TYPE_802_11_DIRECTED_MGMT |        \
     NDIS_PACKET_TYPE_802_11_BROADCAST_MGMT |       \
     NDIS_PACKET_TYPE_802_11_MULTICAST_MGMT |       \
     NDIS_PACKET_TYPE_802_11_ALL_MULTICAST_MGMT |   \
     NDIS_PACKET_TYPE_802_11_PROMISCUOUS_MGMT |     \
     NDIS_PACKET_TYPE_802_11_RAW_MGMT |             \
     NDIS_PACKET_TYPE_802_11_DIRECTED_CTRL |        \
     NDIS_PACKET_TYPE_802_11_BROADCAST_CTRL |       \
     NDIS_PACKET_TYPE_802_11_PROMISCUOUS_CTRL)


//
// Max size of an 802.11 PDU, including the MAC header, frame body and FCS.
//
#define DOT11_MAX_PDU_SIZE                          2346

//
// Min size of an 802.11 PDU, including the MAC header, frame body and FCS.
//
#define DOT11_MIN_PDU_SIZE                          (256)

#define DOT11_MAX_NUM_DEFAULT_KEY                   4

// Macros for defining native 802.11 OIDs
#define OID_DOT11_NDIS_START                        0x0D010300

#define NWF_MANDATORY_OID       (0x01U)
#define NWF_OPTIONAL_OID        (0x02U)

#define NWF_OPERATIONAL_OID     (0x01U)
#define NWF_STATISTICS_OID      (0x02U) 

#define NWF_DEFINE_OID(Seq,o,m)     ((0x0E000000U) | ((o) << 16) | ((m) << 8) | (Seq))

//
// Offload Capability OIDs
//

#define OID_DOT11_OFFLOAD_CAPABILITY                (OID_DOT11_NDIS_START + 0)
    // Capability flags
    #define DOT11_HW_WEP_SUPPORTED_TX               0x00000001
    #define DOT11_HW_WEP_SUPPORTED_RX               0x00000002
    #define DOT11_HW_FRAGMENTATION_SUPPORTED        0x00000004
    #define DOT11_HW_DEFRAGMENTATION_SUPPORTED      0x00000008
    #define DOT11_HW_MSDU_AUTH_SUPPORTED_TX         0x00000010
    #define DOT11_HW_MSDU_AUTH_SUPPORTED_RX         0x00000020
    // WEP Algorithm flags
    #define DOT11_CONF_ALGO_WEP_RC4                 0x00000001  // WEP RC4
    #define DOT11_CONF_ALGO_TKIP                    0x00000002 
    // Integrity Algorithm flags
    #define DOT11_AUTH_ALGO_MICHAEL                 0x00000001  // Michael
    typedef struct _DOT11_OFFLOAD_CAPABILITY {
        ULONG uReserved;
        ULONG uFlags;
        ULONG uSupportedWEPAlgorithms;
        ULONG uNumOfReplayWindows;
        ULONG uMaxWEPKeyMappingLength;
        ULONG uSupportedAuthAlgorithms;
        ULONG uMaxAuthKeyMappingLength;
    } DOT11_OFFLOAD_CAPABILITY, * PDOT11_OFFLOAD_CAPABILITY;

#define OID_DOT11_CURRENT_OFFLOAD_CAPABILITY        (OID_DOT11_NDIS_START + 1)
    typedef struct _DOT11_CURRENT_OFFLOAD_CAPABILITY {
        ULONG uReserved;
        ULONG uFlags;
    } DOT11_CURRENT_OFFLOAD_CAPABILITY, * PDOT11_CURRENT_OFFLOAD_CAPABILITY;


//
// WEP Offload
//

#define OID_DOT11_WEP_OFFLOAD                       (OID_DOT11_NDIS_START + 2)
    typedef enum _DOT11_OFFLOAD_TYPE {
        dot11_offload_type_wep = 1,
        dot11_offload_type_auth = 2
    } DOT11_OFFLOAD_TYPE, * PDOT11_OFFLOAD_TYPE;
    typedef struct _DOT11_IV48_COUNTER {
        ULONG uIV32Counter;
        USHORT usIV16Counter;
    } DOT11_IV48_COUNTER, * PDOT11_IV48_COUNTER;
    typedef struct _DOT11_WEP_OFFLOAD {
        ULONG uReserved;
        HANDLE hOffloadContext;
        HANDLE hOffload;
        DOT11_OFFLOAD_TYPE dot11OffloadType;
        ULONG dwAlgorithm;
        BOOLEAN bRowIsOutbound;
        BOOLEAN bUseDefault;
        ULONG uFlags;
        UCHAR ucMacAddress[6];
        ULONG uNumOfRWsOnPeer;
        ULONG uNumOfRWsOnMe;
        DOT11_IV48_COUNTER dot11IV48Counters[16];
        USHORT usDot11RWBitMaps[16];
        USHORT usKeyLength;
        UCHAR ucKey[1];             // Must be the last field.
    } DOT11_WEP_OFFLOAD, * PDOT11_WEP_OFFLOAD;

#define OID_DOT11_WEP_UPLOAD                        (OID_DOT11_NDIS_START + 3)
    typedef struct _DOT11_WEP_UPLOAD {
        ULONG uReserved;
        DOT11_OFFLOAD_TYPE dot11OffloadType;
        HANDLE hOffload;
        ULONG uNumOfRWsUsed;
        DOT11_IV48_COUNTER dot11IV48Counters[16];
        USHORT usDot11RWBitMaps[16];
    } DOT11_WEP_UPLOAD, * PDOT11_WEP_UPLOAD;

#define OID_DOT11_DEFAULT_WEP_OFFLOAD               (OID_DOT11_NDIS_START + 4)
    typedef enum _DOT11_KEY_DIRECTION {
        dot11_key_direction_both = 1,
        dot11_key_direction_inbound = 2,
        dot11_key_direction_outbound = 3
    } DOT11_KEY_DIRECTION, * PDOT11_KEY_DIRECTION;
    typedef struct _DOT11_DEFAULT_WEP_OFFLOAD {
        ULONG uReserved;
        HANDLE hOffloadContext;
        HANDLE hOffload;
        ULONG  dwIndex;
        DOT11_OFFLOAD_TYPE dot11OffloadType;
        ULONG dwAlgorithm;
        ULONG uFlags;
        DOT11_KEY_DIRECTION dot11KeyDirection;
        UCHAR ucMacAddress[6];
        ULONG uNumOfRWsOnMe;
        DOT11_IV48_COUNTER dot11IV48Counters[16];
        USHORT usDot11RWBitMaps[16];
        USHORT usKeyLength;
        UCHAR ucKey[1];             // Must be the last field.
    } DOT11_DEFAULT_WEP_OFFLOAD, * PDOT11_DEFAULT_WEP_OFFLOAD;

#define OID_DOT11_DEFAULT_WEP_UPLOAD                (OID_DOT11_NDIS_START + 5)
    typedef struct _DOT11_DEFAULT_WEP_UPLOAD {
        ULONG uReserved;
        DOT11_OFFLOAD_TYPE dot11OffloadType;
        HANDLE hOffload;
        ULONG uNumOfRWsUsed;
        DOT11_IV48_COUNTER dot11IV48Counters[16];
        USHORT usDot11RWBitMaps[16];
    } DOT11_DEFAULT_WEP_UPLOAD, * PDOT11_DEFAULT_WEP_UPLOAD;

//
// Fragmentation/Defragmentation Offload
//

#define OID_DOT11_MPDU_MAX_LENGTH                   (OID_DOT11_NDIS_START + 6)
    // ULONG (in bytes)

//
// 802.11 Configuration OIDs
//

//
// OIDs for Mandatory Functions
//

#define OID_DOT11_OPERATION_MODE_CAPABILITY         (OID_DOT11_NDIS_START + 7)
    #define DOT11_OPERATION_MODE_UNKNOWN            0x00000000
    #define DOT11_OPERATION_MODE_STATION            0x00000001
    #define DOT11_OPERATION_MODE_AP                 0x00000002
    #define DOT11_OPERATION_MODE_EXTENSIBLE_STATION 0x00000004
    #define DOT11_OPERATION_MODE_NETWORK_MONITOR    0x80000000
    typedef struct _DOT11_OPERATION_MODE_CAPABILITY {
        ULONG uReserved;
        ULONG uMajorVersion;
        ULONG uMinorVersion;
        ULONG uNumOfTXBuffers;
        ULONG uNumOfRXBuffers;
        ULONG uOpModeCapability;
    } DOT11_OPERATION_MODE_CAPABILITY, * PDOT11_OPERATION_MODE_CAPABILITY;

#define OID_DOT11_CURRENT_OPERATION_MODE            (OID_DOT11_NDIS_START + 8)
    typedef struct _DOT11_CURRENT_OPERATION_MODE {
        ULONG uReserved;
        ULONG uCurrentOpMode;
    } DOT11_CURRENT_OPERATION_MODE, * PDOT11_CURRENT_OPERATION_MODE;

#define OID_DOT11_CURRENT_PACKET_FILTER             (OID_DOT11_NDIS_START + 9)
    #define DOT11_PACKET_TYPE_DIRECTED_CTRL         0x00000001
    // Indicate all 802.11 unicast control packets.
    #define DOT11_PACKET_TYPE_DIRECTED_MGMT         0x00000002
    // Indicate all 802.11 unicast management packets.
    #define DOT11_PACKET_TYPE_DIRECTED_DATA         0x00000004
    // Indicate all 802.11 unicast data packets.
    #define DOT11_PACKET_TYPE_MULTICAST_CTRL        0x00000008
    // Indicate all 802.11 multicast control packets.
    #define DOT11_PACKET_TYPE_MULTICAST_MGMT        0x00000010
    // Indicate all 802.11 multicast management packets.
    #define DOT11_PACKET_TYPE_MULTICAST_DATA        0x00000020
    // Indicate all 802.11 multicast data packets.
    #define DOT11_PACKET_TYPE_BROADCAST_CTRL        0x00000040
    // Indicate all 802.11 broadcast control packets.
    #define DOT11_PACKET_TYPE_BROADCAST_MGMT        0x00000080
    // Indicate all 802.11 broadcast management packets.
    #define DOT11_PACKET_TYPE_BROADCAST_DATA        0x00000100
    // Indicate all 802.11 broadcast data packets.
    #define DOT11_PACKET_TYPE_PROMISCUOUS_CTRL      0x00000200
    // Move into promiscuous mode and indicate all 802.11 control packets.
    #define DOT11_PACKET_TYPE_PROMISCUOUS_MGMT      0x00000400
    // Move into promiscuous mode and indicate all 802.11 control packets.
    #define DOT11_PACKET_TYPE_PROMISCUOUS_DATA      0x00000800
    // Move into promiscuous mode and indicate all 802.11 control packets.
    #define DOT11_PACKET_TYPE_ALL_MULTICAST_CTRL    0x00001000
    // Indicate all 802.11 multicast control packets.
    #define DOT11_PACKET_TYPE_ALL_MULTICAST_MGMT    0x00002000
    // Indicate all 802.11 multicast management packets.
    #define DOT11_PACKET_TYPE_ALL_MULTICAST_DATA    0x00004000
    // Indicate all 802.11 multicast data packets.
    #define DOT11_PACKET_TYPE_RESERVED  (~(             \
                DOT11_PACKET_TYPE_DIRECTED_CTRL |       \
                DOT11_PACKET_TYPE_DIRECTED_MGMT |       \
                DOT11_PACKET_TYPE_DIRECTED_DATA |       \
                DOT11_PACKET_TYPE_MULTICAST_CTRL |      \
                DOT11_PACKET_TYPE_MULTICAST_MGMT |      \
                DOT11_PACKET_TYPE_MULTICAST_DATA |      \
                DOT11_PACKET_TYPE_BROADCAST_CTRL |      \
                DOT11_PACKET_TYPE_BROADCAST_MGMT |      \
                DOT11_PACKET_TYPE_BROADCAST_DATA |      \
                DOT11_PACKET_TYPE_PROMISCUOUS_CTRL |    \
                DOT11_PACKET_TYPE_PROMISCUOUS_MGMT |    \
                DOT11_PACKET_TYPE_PROMISCUOUS_DATA |    \
                DOT11_PACKET_TYPE_ALL_MULTICAST_CTRL |  \
                DOT11_PACKET_TYPE_ALL_MULTICAST_MGMT |  \
                DOT11_PACKET_TYPE_ALL_MULTICAST_DATA |  \
                0                                       \
                ))
    // All the reserved bits

#define OID_DOT11_ATIM_WINDOW                       (OID_DOT11_NDIS_START + 10)
    // ULONG (in TUs)

#define OID_DOT11_SCAN_REQUEST                      (OID_DOT11_NDIS_START + 11)

    typedef enum _DOT11_SCAN_TYPE {
        dot11_scan_type_active = 1,
        dot11_scan_type_passive = 2,
        dot11_scan_type_auto = 3,
        dot11_scan_type_forced = 0x80000000
    } DOT11_SCAN_TYPE, * PDOT11_SCAN_TYPE;
    typedef struct _DOT11_SCAN_REQUEST {
        DOT11_BSS_TYPE dot11BSSType;
        DOT11_MAC_ADDRESS dot11BSSID;
        DOT11_SSID dot11SSID;
        DOT11_SCAN_TYPE dot11ScanType;
        BOOLEAN bRestrictedScan;
        BOOLEAN bUseRequestIE;
        ULONG uRequestIDsOffset;
        ULONG uNumOfRequestIDs;
        ULONG uPhyTypesOffset;
        ULONG uNumOfPhyTypes;
        ULONG uIEsOffset;
        ULONG uIEsLength;
        UCHAR ucBuffer[1];
    } DOT11_SCAN_REQUEST, * PDOT11_SCAN_REQUEST;

    // V2 SCAN REQUEST
    typedef enum _CH_DESCRIPTION_TYPE {
        ch_description_type_logical = 1,
        ch_description_type_center_frequency = 2,
        ch_description_type_phy_specific
    } CH_DESCRIPTION_TYPE, * PCH_DESCRIPTION_TYPE;
    typedef struct _DOT11_PHY_TYPE_INFO {
        DOT11_PHY_TYPE dot11PhyType;
        BOOLEAN bUseParameters;
        ULONG uProbeDelay;
        ULONG uMinChannelTime;
        ULONG uMaxChannelTime;
        CH_DESCRIPTION_TYPE ChDescriptionType;
        ULONG uChannelListSize;
        UCHAR ucChannelListBuffer[1];
    } DOT11_PHY_TYPE_INFO, * PDOT11_PHY_TYPE_INFO;

    typedef struct _DOT11_SCAN_REQUEST_V2 {
        DOT11_BSS_TYPE dot11BSSType;
        DOT11_MAC_ADDRESS dot11BSSID;
        DOT11_SCAN_TYPE dot11ScanType;
        BOOLEAN bRestrictedScan;
        ULONG udot11SSIDsOffset;
        ULONG uNumOfdot11SSIDs;
        BOOLEAN bUseRequestIE;
        ULONG uRequestIDsOffset;
        ULONG uNumOfRequestIDs;
        ULONG uPhyTypeInfosOffset;
        ULONG uNumOfPhyTypeInfos;
        ULONG uIEsOffset;
        ULONG uIEsLength;
        UCHAR ucBuffer[1];
    } DOT11_SCAN_REQUEST_V2, * PDOT11_SCAN_REQUEST_V2;

#define OID_DOT11_CURRENT_PHY_TYPE                  (OID_DOT11_NDIS_START + 12)
    typedef struct DOT11_PHY_TYPE_LIST {
        #define DOT11_PHY_TYPE_LIST_REVISION_1          1
        NDIS_OBJECT_HEADER Header;
        ULONG uNumOfEntries;
        ULONG uTotalNumOfEntries;
        DOT11_PHY_TYPE dot11PhyType[1];
    } DOT11_PHY_TYPE_LIST, * PDOT11_PHY_TYPE_LIST;

#define OID_DOT11_JOIN_REQUEST                      (OID_DOT11_NDIS_START + 13)

    // Capability Information Flags - Exactly maps to the bit positions
    // in the Capability Information field of the beacon and probe response frames.
    #define DOT11_CAPABILITY_INFO_ESS               0x0001
    #define DOT11_CAPABILITY_INFO_IBSS              0x0002
    #define DOT11_CAPABILITY_INFO_CF_POLLABLE       0x0004
    #define DOT11_CAPABILITY_INFO_CF_POLL_REQ       0x0008
    #define DOT11_CAPABILITY_INFO_PRIVACY           0x0010
    #define DOT11_CAPABILITY_SHORT_PREAMBLE         0x0020
    #define DOT11_CAPABILITY_PBCC                   0x0040
    #define DOT11_CAPABILITY_CHANNEL_AGILITY        0x0080
    #define DOT11_CAPABILITY_SHORT_SLOT_TIME        0x0400
    #define DOT11_CAPABILITY_DSSSOFDM               0x2000

    typedef struct _DOT11_BSS_DESCRIPTION {
        ULONG uReserved;                        // Passed-in as 0 and must be ignored for now.
        DOT11_MAC_ADDRESS dot11BSSID;
        DOT11_BSS_TYPE dot11BSSType;
        USHORT usBeaconPeriod;
        ULONGLONG ullTimestamp;
        USHORT usCapabilityInformation;
        ULONG uBufferLength;
#ifdef __midl
        [unique, size_is(uBufferLength)] UCHAR ucBuffer[*];
#else
        UCHAR ucBuffer[1];              // Must be the last field.
#endif
    } DOT11_BSS_DESCRIPTION, * PDOT11_BSS_DESCRIPTION;
    typedef struct _DOT11_JOIN_REQUEST {
        ULONG uJoinFailureTimeout;
        DOT11_RATE_SET OperationalRateSet;
        ULONG uChCenterFrequency;
        DOT11_BSS_DESCRIPTION dot11BSSDescription;  // Must be the last field.
    } DOT11_JOIN_REQUEST, * PDOT11_JOIN_REQUEST;

#define OID_DOT11_START_REQUEST                     (OID_DOT11_NDIS_START + 14)
    typedef struct _DOT11_START_REQUEST {
        ULONG uStartFailureTimeout;
        DOT11_RATE_SET OperationalRateSet;
        ULONG uChCenterFrequency;
        DOT11_BSS_DESCRIPTION dot11BSSDescription;  // Must be the last field.
    } DOT11_START_REQUEST, * PDOT11_START_REQUEST;

#define OID_DOT11_UPDATE_IE                         (OID_DOT11_NDIS_START + 15)
typedef enum _DOT11_UPDATE_IE_OP {
    dot11_update_ie_op_create_replace = 1,
    dot11_update_ie_op_delete = 2,
} DOT11_UPDATE_IE_OP, * PDOT11_UPDATE_IE_OP;

typedef struct _DOT11_UPDATE_IE {
    DOT11_UPDATE_IE_OP dot11UpdateIEOp;
    ULONG uBufferLength;
    UCHAR ucBuffer[1];          // Must be the last field.
} DOT11_UPDATE_IE, * PDOT11_UPDATE_IE;

#define OID_DOT11_RESET_REQUEST                     (OID_DOT11_NDIS_START + 16)
    typedef enum _DOT11_RESET_TYPE {
        dot11_reset_type_phy = 1,
        dot11_reset_type_mac = 2,
        dot11_reset_type_phy_and_mac = 3
    } DOT11_RESET_TYPE, * PDOT11_RESET_TYPE;
    typedef struct _DOT11_RESET_REQUEST {
        DOT11_RESET_TYPE dot11ResetType;
        DOT11_MAC_ADDRESS dot11MacAddress;
        BOOLEAN bSetDefaultMIB;
    } DOT11_RESET_REQUEST, * PDOT11_RESET_REQUEST;

#define OID_DOT11_NIC_POWER_STATE                   (OID_DOT11_NDIS_START + 17)
    // BOOL

//
// OIDs for Optional Functions
//

#define OID_DOT11_OPTIONAL_CAPABILITY               (OID_DOT11_NDIS_START + 18)
    typedef struct _DOT11_OPTIONAL_CAPABILITY {
        ULONG uReserved;
        BOOLEAN bDot11PCF;
        BOOLEAN bDot11PCFMPDUTransferToPC;
        BOOLEAN bStrictlyOrderedServiceClass;
    } DOT11_OPTIONAL_CAPABILITY, * PDOT11_OPTIONAL_CAPABILITY;

#define OID_DOT11_CURRENT_OPTIONAL_CAPABILITY       (OID_DOT11_NDIS_START + 19)
    typedef struct _DOT11_CURRENT_OPTIONAL_CAPABILITY {
        ULONG uReserved;
        BOOLEAN bDot11CFPollable;
        BOOLEAN bDot11PCF;
        BOOLEAN bDot11PCFMPDUTransferToPC;
        BOOLEAN bStrictlyOrderedServiceClass;
    } DOT11_CURRENT_OPTIONAL_CAPABILITY, * PDOT11_CURRENT_OPTIONAL_CAPABILITY;

//
// 802.11 MIB OIDs
//

//
// OIDs for dot11StationConfigEntry
//

#define OID_DOT11_STATION_ID                        (OID_DOT11_NDIS_START + 20)
    // DOT11_MAC_ADDRESS

#define OID_DOT11_MEDIUM_OCCUPANCY_LIMIT            (OID_DOT11_NDIS_START + 21)
    // ULONG (in TUs)

#define OID_DOT11_CF_POLLABLE                       (OID_DOT11_NDIS_START + 22)
    // BOOL

#define OID_DOT11_CFP_PERIOD                        (OID_DOT11_NDIS_START + 23)
    // ULONG (in DTIM intervals)

#define OID_DOT11_CFP_MAX_DURATION                  (OID_DOT11_NDIS_START + 24)
    // ULONG (in TUs)

#define OID_DOT11_POWER_MGMT_MODE                   (OID_DOT11_NDIS_START + 25)
    typedef enum _DOT11_POWER_MODE {
        dot11_power_mode_unknown = 0,
        dot11_power_mode_active = 1,
        dot11_power_mode_powersave = 2
    } DOT11_POWER_MODE, * PDOT11_POWER_MODE;
    #define DOT11_POWER_SAVE_LEVEL_MAX_PSP      1
    // Maximum power save polling.
    #define DOT11_POWER_SAVE_LEVEL_FAST_PSP     2
    // Fast power save polling.
    typedef struct _DOT11_POWER_MGMT_MODE {
        DOT11_POWER_MODE dot11PowerMode;
        ULONG uPowerSaveLevel;
        USHORT usListenInterval;
        USHORT usAID;
        BOOLEAN bReceiveDTIMs;
    } DOT11_POWER_MGMT_MODE, * PDOT11_POWER_MGMT_MODE;

#define OID_DOT11_OPERATIONAL_RATE_SET              (OID_DOT11_NDIS_START + 26)
    // DOT11_RATE_SET

#define OID_DOT11_BEACON_PERIOD                     (OID_DOT11_NDIS_START + 27)
    // ULONG (in TUs)

#define OID_DOT11_DTIM_PERIOD                       (OID_DOT11_NDIS_START + 28)
    // ULONG (in beacon intervals)

//
// OIDs for Dot11PrivacyEntry
//

#define OID_DOT11_WEP_ICV_ERROR_COUNT               (OID_DOT11_NDIS_START + 29)
    // ULONG

//
// OIDs for dot11OperationEntry
//

#define OID_DOT11_MAC_ADDRESS                       (OID_DOT11_NDIS_START + 30)
    // DOT11_MAC_ADDRESS

#define OID_DOT11_RTS_THRESHOLD                     (OID_DOT11_NDIS_START + 31)
    // ULONG (in number of octets)

#define OID_DOT11_SHORT_RETRY_LIMIT                 (OID_DOT11_NDIS_START + 32)
    // ULONG

#define OID_DOT11_LONG_RETRY_LIMIT                  (OID_DOT11_NDIS_START + 33)
    // ULONG

#define OID_DOT11_FRAGMENTATION_THRESHOLD           (OID_DOT11_NDIS_START + 34)
    // ULONG (in number of octets)

#define OID_DOT11_MAX_TRANSMIT_MSDU_LIFETIME        (OID_DOT11_NDIS_START + 35)
    // ULONG (in TUs)

#define OID_DOT11_MAX_RECEIVE_LIFETIME              (OID_DOT11_NDIS_START + 36)
    // ULONG (in TUs)

//
// OIDs for dot11CountersEntry
//

#define OID_DOT11_COUNTERS_ENTRY                    (OID_DOT11_NDIS_START + 37)
    typedef struct _DOT11_COUNTERS_ENTRY {
        ULONG uTransmittedFragmentCount;
        ULONG uMulticastTransmittedFrameCount;
        ULONG uFailedCount;
        ULONG uRetryCount;
        ULONG uMultipleRetryCount;
        ULONG uFrameDuplicateCount;
        ULONG uRTSSuccessCount;
        ULONG uRTSFailureCount;
        ULONG uACKFailureCount;
        ULONG uReceivedFragmentCount;
        ULONG uMulticastReceivedFrameCount;
        ULONG uFCSErrorCount;
        ULONG uTransmittedFrameCount;
    } DOT11_COUNTERS_ENTRY, * PDOT11_COUNTERS_ENTRY;

//
// OIDs for dot11PhyOperationEntry
//

#define OID_DOT11_SUPPORTED_PHY_TYPES               (OID_DOT11_NDIS_START + 38)
    typedef struct _DOT11_SUPPORTED_PHY_TYPES {
        ULONG uNumOfEntries;
        ULONG uTotalNumOfEntries;
        DOT11_PHY_TYPE dot11PHYType[1];
    } DOT11_SUPPORTED_PHY_TYPES, * PDOT11_SUPPORTED_PHY_TYPES;

#define OID_DOT11_CURRENT_REG_DOMAIN                (OID_DOT11_NDIS_START + 39)
    #define DOT11_REG_DOMAIN_OTHER                  0x00000000
    #define DOT11_REG_DOMAIN_FCC                    0x00000010
    #define DOT11_REG_DOMAIN_DOC                    0x00000020
    #define DOT11_REG_DOMAIN_ETSI                   0x00000030
    #define DOT11_REG_DOMAIN_SPAIN                  0x00000031
    #define DOT11_REG_DOMAIN_FRANCE                 0x00000032
    #define DOT11_REG_DOMAIN_MKK                    0x00000040
    // ULONG

#define OID_DOT11_TEMP_TYPE                         (OID_DOT11_NDIS_START + 40)
    typedef enum _DOT11_TEMP_TYPE {
        dot11_temp_type_unknown = 0,
        dot11_temp_type_1 = 1,
        dot11_temp_type_2 = 2
    } DOT11_TEMP_TYPE, * PDOT11_TEMP_TYPE;

//
// OIDs for dot11PhyAntennaEntry
//

#define OID_DOT11_CURRENT_TX_ANTENNA                (OID_DOT11_NDIS_START + 41)
    // ULONG

#define OID_DOT11_DIVERSITY_SUPPORT                 (OID_DOT11_NDIS_START + 42)
    typedef enum _DOT11_DIVERSITY_SUPPORT {
        dot11_diversity_support_unknown = 0,
        dot11_diversity_support_fixedlist = 1,
        dot11_diversity_support_notsupported = 2,
        dot11_diversity_support_dynamic = 3
    } DOT11_DIVERSITY_SUPPORT, * PDOT11_DIVERSITY_SUPPORT;

#define OID_DOT11_CURRENT_RX_ANTENNA                (OID_DOT11_NDIS_START + 43)
    // ULONG

//
// OIDs for dot11PhyTxPowerEntry
//

#define OID_DOT11_SUPPORTED_POWER_LEVELS            (OID_DOT11_NDIS_START + 44)
    typedef struct _DOT11_SUPPORTED_POWER_LEVELS {
        ULONG uNumOfSupportedPowerLevels;
        __field_ecount_part(8, uNumOfSupportedPowerLevels) ULONG uTxPowerLevelValues[8];
    } DOT11_SUPPORTED_POWER_LEVELS, * PDOT11_SUPPORTED_POWER_LEVELS;

#define OID_DOT11_CURRENT_TX_POWER_LEVEL            (OID_DOT11_NDIS_START + 45)
    // ULONG

//
// OIDs for dot11PhyFHSSEntry
//

#define OID_DOT11_HOP_TIME                          (OID_DOT11_NDIS_START + 46)
    // ULONG (in microseconds)

#define OID_DOT11_CURRENT_CHANNEL_NUMBER            (OID_DOT11_NDIS_START + 47)
    // ULONG

#define OID_DOT11_MAX_DWELL_TIME                    (OID_DOT11_NDIS_START + 48)
    // ULONG (in TUs)

#define OID_DOT11_CURRENT_DWELL_TIME                (OID_DOT11_NDIS_START + 49)
    // ULONG (in TUs)

#define OID_DOT11_CURRENT_SET                       (OID_DOT11_NDIS_START + 50)
    // ULONG

#define OID_DOT11_CURRENT_PATTERN                   (OID_DOT11_NDIS_START + 51)
    // ULONG

#define OID_DOT11_CURRENT_INDEX                     (OID_DOT11_NDIS_START + 52)
    // ULONG

//
// OIDs for dot11PhyDSSSEntry
//

#define OID_DOT11_CURRENT_CHANNEL                   (OID_DOT11_NDIS_START + 53)
    // ULONG

#define OID_DOT11_CCA_MODE_SUPPORTED                (OID_DOT11_NDIS_START + 54)
    #define DOT11_CCA_MODE_ED_ONLY                  0x00000001
    #define DOT11_CCA_MODE_CS_ONLY                  0x00000002
    #define DOT11_CCA_MODE_ED_and_CS                0x00000004
    #define DOT11_CCA_MODE_CS_WITH_TIMER            0x00000008
    #define DOT11_CCA_MODE_HRCS_AND_ED              0x00000010

    // ULONG

#define OID_DOT11_CURRENT_CCA_MODE                  (OID_DOT11_NDIS_START + 55)
    // ULONG

#define OID_DOT11_ED_THRESHOLD                      (OID_DOT11_NDIS_START + 56)
    // LONG (in "dBm"s)

//
// OIDs for dot11PhyIREntry
//

#define OID_DOT11_CCA_WATCHDOG_TIMER_MAX            (OID_DOT11_NDIS_START + 57)
    // ULONG (in nanoseconds)

#define OID_DOT11_CCA_WATCHDOG_COUNT_MAX            (OID_DOT11_NDIS_START + 58)
    // ULONG

#define OID_DOT11_CCA_WATCHDOG_TIMER_MIN            (OID_DOT11_NDIS_START + 59)
    // ULONG (in nanoseconds)

#define OID_DOT11_CCA_WATCHDOG_COUNT_MIN            (OID_DOT11_NDIS_START + 60)
    // ULONG

//
// OIDs for dot11RegDomainsSupportEntry
//

#define OID_DOT11_REG_DOMAINS_SUPPORT_VALUE         (OID_DOT11_NDIS_START + 61)
    typedef struct _DOT11_REG_DOMAIN_VALUE {
        ULONG uRegDomainsSupportIndex;
        ULONG uRegDomainsSupportValue;
    } DOT11_REG_DOMAIN_VALUE, * PDOT11_REG_DOMAIN_VALUE;
    typedef struct _DOT11_REG_DOMAINS_SUPPORT_VALUE {
        ULONG uNumOfEntries;
        ULONG uTotalNumOfEntries;
        DOT11_REG_DOMAIN_VALUE dot11RegDomainValue[1];
    } DOT11_REG_DOMAINS_SUPPORT_VALUE, * PDOT11_REG_DOMAINS_SUPPORT_VALUE;

//
// OIDs for dot11AntennaListEntry
//

#define OID_DOT11_SUPPORTED_TX_ANTENNA              (OID_DOT11_NDIS_START + 62)
    typedef struct _DOT11_SUPPORTED_ANTENNA {
        ULONG uAntennaListIndex;                    // Between 1 and 255.
        BOOLEAN bSupportedAntenna;
    } DOT11_SUPPORTED_ANTENNA, * PDOT11_SUPPORTED_ANTENNA;
    typedef struct _DOT11_SUPPORTED_ANTENNA_LIST {
        ULONG uNumOfEntries;
        ULONG uTotalNumOfEntries;
        DOT11_SUPPORTED_ANTENNA dot11SupportedAntenna[1];
    } DOT11_SUPPORTED_ANTENNA_LIST, * PDOT11_SUPPORTED_ANTENNA_LIST;

#define OID_DOT11_SUPPORTED_RX_ANTENNA              (OID_DOT11_NDIS_START + 63)
    // DOT11_SUPPORTED_ANTENNA_LIST

#define OID_DOT11_DIVERSITY_SELECTION_RX            (OID_DOT11_NDIS_START + 64)
    typedef struct _DOT11_DIVERSITY_SELECTION_RX {
        ULONG uAntennaListIndex;                    // Between 1 and 255.
        BOOLEAN bDiversitySelectionRX;
    } DOT11_DIVERSITY_SELECTION_RX, * PDOT11_DIVERSITY_SELECTION_RX;
    typedef struct _DOT11_DIVERSITY_SELECTION_RX_LIST {
        ULONG uNumOfEntries;
        ULONG uTotalNumOfEntries;
        DOT11_DIVERSITY_SELECTION_RX dot11DiversitySelectionRx[1];
    } DOT11_DIVERSITY_SELECTION_RX_LIST, * PDOT11_DIVERSITY_SELECTION_RX_LIST;

//
// OIDs for dot11SupportedDataRatesTxEntry and dot11SupportedDataRatesRxEntry
//

#define OID_DOT11_SUPPORTED_DATA_RATES_VALUE        (OID_DOT11_NDIS_START + 65)
    #define MAX_NUM_SUPPORTED_RATES                 8       // 8 d