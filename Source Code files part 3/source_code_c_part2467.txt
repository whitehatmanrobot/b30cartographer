f(SUCCEEDED(hr))
        {
            hr = StopBuffer(apBuffers[i], 0, (5000 * i) + 10000);
        }
    }

    for(i = 0; (i < NUMELEMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        if(apBuffers[i])
        {
            hr = WaitBuffer(apBuffers[i], FALSE);

            RELEASE(apBuffers[i]);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestAllVoices
 *
 *  Description:
 *      Creates all voices.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestAllVoices"

HRESULT
TestAllVoices
(
    void
)
{
    static const DWORD          dwBufferSize    = 4096;
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[256]  = { NULL };
    DSCAPS                      dsc;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;
	DWORD						index;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize			= sizeof(dsbd);
    dsbd.lpwfxFormat	= &wfx;

    wfx.wFormatTag		= WAVE_FORMAT_PCM;
    wfx.nChannels		=  1;
    wfx.nSamplesPerSec	= dwBufferSize / 2;
    wfx.wBitsPerSample	= 16;
    wfx.nBlockAlign		= 1 * 16 / 8;
    wfx.nAvgBytesPerSec	= dwBufferSize / 2 * wfx.nBlockAlign;
    wfx.cbSize			= 0;

    hr = MALLOC(pvBufferData, BYTE, dwBufferSize);

    if(SUCCEEDED(hr))
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);

    if(SUCCEEDED(hr))
        hr = GetDirectSoundCaps(&dsc);

	// 2D voices
    for(index=0, i=0; (i < dsc.dwFree2DBuffers) && SUCCEEDED(hr); i++, ++index)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[index]));

        if(SUCCEEDED(hr))
            hr = ValidateResult(apBuffers[index]->SetBufferData(pvBufferData, dwBufferSize));

        if(SUCCEEDED(hr))
            hr = PlayBuffer(apBuffers[index], TRUE);
    }

	// 3D voices
    dsbd.dwFlags |= DSBCAPS_CTRL3D;
    for(i=0; (i < dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++, ++index)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[index]));

        if(SUCCEEDED(hr))
            hr = ValidateResult(apBuffers[index]->SetBufferData(pvBufferData, dwBufferSize));

        if(SUCCEEDED(hr))
            hr = PlayBuffer(apBuffers[index], TRUE);
    }

    if(SUCCEEDED(hr))
        Sleep(5000);

    for(i = 0; i < NUMELEMS(apBuffers); i++)
    {
        RELEASE(apBuffers[i]);
    }

    FREE(pvBufferData);

    return hr;
}


/****************************************************************************
 *
 *  TestStop
 *
 *  Description:
 *      Tests stopping and restarting a buffer.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStop"

HRESULT
TestStop
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwPlay;
    DWORD                   dwWrite;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(!dwPlay);
        ASSERT(!dwWrite);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("initial play:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2000);

        hr = ValidateResult(pBuffer->SetCurrentPosition(dwDuration / 2 / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign));
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("manual setposition:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, 10000, FALSE, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2500);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("forced stop:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("second play:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("natural stop:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DbgPrint("third play:  play %lu write %lu duration %lu\n", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFrequency
 *
 *  Description:
 *      Tests changing the frequency.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestFrequency"

HRESULT
TestFrequency
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwDelay
)
{
    static const DWORD      adwFrequencies[]    = { 0, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000, 96000 };
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    DWORD                   dwFrequency;
    HRESULT                 hr;

    hr = CreateStdBuffer(dwFlags, CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        PlayBuffer(pBuffer, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        for(dwFrequency = 0; (dwFrequency < NUMELEMS(adwFrequencies)) && SUCCEEDED(hr); dwFrequency++)
        {
            DbgPrint("Frequency %lu\n", adwFrequencies[dwFrequency]);

            hr = ValidateResult(pBuffer->SetFrequency(adwFrequencies[dwFrequency]));

            if(SUCCEEDED(hr))
            {
                Sleep(dwDelay);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDiscontinuity
 *
 *  Description:
 *      Tests allowing the stream to starve by calling Discontinuity.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDiscontinuity"

HRESULT
TestDiscontinuity
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    BOOL                    fStarve
)
{
    LPCWAVEFORMATEX         pwfxFormat          = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    DWORD                   dwPacketsThisTime   = 0;
    DWORD                   dwDuration;
    DWORD                   dwPacketCount;
    XMEDIAPACKET            xmb;
    HRESULT                 hr;
    DWORD                   i, z;

    //
    // Create the stream

    hr = CreateStdStream(dwFlags, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvDataBuffer, &dwDuration, &dwPacketCount);

    //
    // Enter the stream loop
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmb, sizeof(xmb));
        
        xmb.pvBuffer = pvDataBuffer;
        xmb.dwMaxSize = dwPacketSize;

        while(dwPacketCount)
        {
            dwPacketsThisTime = ((dwPacketsThisTime + 1) % 2) + 1;

            for(z = 0; (z < dwPacketsThisTime) && dwPacketCount && SUCCEEDED(hr); z++)
            {
                DirectSoundDoWork();
            
                if(!--dwPacketCount)
                {
                    xmb.dwMaxSize = dwDuration;
                }                
            
                hr = ValidateResult(pStream->Process(&xmb, NULL));

                xmb.pvBuffer = (LPBYTE)xmb.pvBuffer + xmb.dwMaxSize;
            
                dwDuration -= xmb.dwMaxSize;
            }

            if(SUCCEEDED(hr) && !fStarve)
            {
                hr = ValidateResult(pStream->Discontinuity());
            }

            if(SUCCEEDED(hr))
            {
                Sleep((dwPacketSize * dwPacketsThisTime * 2) / (pwfxFormat->nAvgBytesPerSec / 1000));
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDeferredCommandRelease
 *
 *  Description:
 *      Tests whether deferred commands automatically get released when the
 *      buffer is.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDeferredCommandRelease"

HRESULT
TestDeferredCommandRelease
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(WAVE_FORMAT_PCM, 32000, 16, 2), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestHeadroom
 *
 *  Description:
 *      Tests headroom.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestHeadroom"

HRESULT
TestHeadroom
(
    void
)
{
    static const DWORD      dwSleep         = 2000;
    LPDIRECTSOUND           pDirectSound    = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr;
    int                     i;

    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
    {
        hr = CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, TRUE);
    }

    for(i = DSBHEADROOM_MAX; SUCCEEDED(hr) && (i >= DSBHEADROOM_MIN); i -= 1000)
    {
        DbgPrint("%lu voice headroom\n", i);

        hr = ValidateResult(pBuffer->SetHeadroom(i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    for(i = DSHEADROOM_MIN; SUCCEEDED(hr) && (i <= DSHEADROOM_MAX); i++)
    {
        DbgPrint("%lu mixbin headroom\n", i);

        hr = ValidateResult(pDirectSound->SetMixBinHeadroom(DSMIXBIN_FRONT_LEFT, i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    RELEASE(pBuffer);
    RELEASE(pDirectSound);

    return hr;
}


/****************************************************************************
 *
 *  TestI3DL2Listener
 *
 *  Description:
 *      Tests I3DL2 listener.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestI3DL2Listener"

HRESULT
TestI3DL2Listener
(
    void
)
{
    static const struct
    {
        LPCSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { "Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { "Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { "PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { "Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { "Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { "LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { "StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { "Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { "ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { "Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { "Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { "Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { "CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { "Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { "StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { "Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { "Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { "City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { "Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { "Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { "Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { "ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { "SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { "UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
    };

	DSMIXBINVOLUMEPAIR				mixBinVolumePairs[7];
	DSMIXBINS						mixBins;
    static const DWORD              dwDelay         = 10000;
    LPDIRECTSOUND                   pDirectSound    = NULL;
    LPDIRECTSOUNDBUFFER             pBuffer         = NULL;
    HRESULT                         hr;
    DWORD                           i;

	mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
	mixBinVolumePairs[0].lVolume	= 0;
	mixBinVolumePairs[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
	mixBinVolumePairs[1].lVolume	= 0;
	mixBinVolumePairs[2].dwMixBin	= DSMIXBIN_FRONT_CENTER;
	mixBinVolumePairs[2].lVolume	= 0;
	mixBinVolumePairs[3].dwMixBin	= DSMIXBIN_LOW_FREQUENCY;
	mixBinVolumePairs[3].lVolume	= 0;
	mixBinVolumePairs[4].dwMixBin	= DSMIXBIN_BACK_LEFT;
	mixBinVolumePairs[4].lVolume	= 0;
	mixBinVolumePairs[5].dwMixBin	= DSMIXBIN_BACK_RIGHT;
	mixBinVolumePairs[5].lVolume	= 0;
	mixBinVolumePairs[6].dwMixBin	= DSMIXBIN_I3DL2;
	mixBinVolumePairs[6].lVolume	= 0;
	mixBins.dwMixBinCount			= 7;
	mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
	
    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
    {
        hr = CreateBufferFromFile("t:\\media\\audio\\pcm\\CleanGuitarArpeggios.wav", 0, &mixBins, NULL, &pBuffer);
    }

    for(i = 0; SUCCEEDED(hr) && (i < NUMELEMS(Environments)); i++)
    {
        DbgPrint("%s\n", Environments[i].pszName);

        hr = ValidateResult(pDirectSound->SetI3DL2Listener(&Environments[i].Properties, DS3D_IMMEDIATE));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, TRUE);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDelay);
        }
    }

    RELEASE(pBuffer);
    RELEASE(pDirectSound);

    return hr;
}


/****************************************************************************
 *
 *  TestMultiChannel
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel"

HRESULT
TestMultiChannel
(
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxSrc             = CreateFormat(WAVE_FORMAT_PCM, dwSampleRate, dwBitsPerSample, dwChannelCount);
    XFileMediaObject *      pWaveFile           = NULL;
    LPVOID                  pvSrcData           = NULL;
    LPVOID                  pvDstData           = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    WAVEFORMATEX            wfxDst;
    DWORD                   dwSrcDataSize;
    DWORD                   dwDstDataSize;
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = 0;
    dsbd.lpwfxFormat = &wfxDst;
    
    //
    // Load the source wave file
    //

    hr = LoadStdWaveFile(pwfxSrc, &pWaveFile);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pWaveFile->GetLength(&dwSrcDataSize));
    }

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvSrcData, BYTE, dwSrcDataSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = ReadXMO(pWaveFile, pvSrcData, dwSrcDataSize, &dwSrcDataSize);
    }

    //
    // Enter the multichannel test loop
    //

    if(SUCCEEDED(hr))
    {
        for(wfxDst.nChannels = pwfxSrc->nChannels + 1; wfxDst.nChannels <= 6; wfxDst.nChannels++)
        {
            if(wfxDst.nChannels % pwfxSrc->nChannels)
            {
                continue;
            }

            if(wfxDst.nChannels % 2)
            {
                continue;
            }

            //
            // Convert to multichannel
            //

            DbgPrint("Converting from %lu channel to %lu channel\n", pwfxSrc->nChannels, wfxDst.nChannels);
            
            hr = MakeMultiChannel(pwfxSrc, &wfxDst, pvSrcData, dwSrcDataSize, &pvDstData, &dwDstDataSize);

            //
            // Create the buffer, making sure to keep it to 2047 SGEs
            //
            
            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
            }

            if(SUCCEEDED(hr))
            {
                hr = ClampBufferSize(&dwDstDataSize,wfxDst.nBlockAlign);
            }

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(pBuffer->SetBufferData(pvDstData, dwDstDataSize));
            }

            //
            // Start playback
            //

            if(SUCCEEDED(hr))
            {
                hr = PlayBufferToCompletion(pBuffer);
            }

            //
            // Clean up
            //

            RELEASE(pBuffer);
	        FREE(pvDstData);
        }
    }

    //
    // Clean up
    //

    RELEASE(pWaveFile);
    FREE(pvSrcData);

    return hr;
}


/****************************************************************************
 *
 *  TestReleaseEnvelope
 *
 *  Description:
 *      Tests the hardware release envelope.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestReleaseEnvelope"

HRESULT
TestReleaseEnvelope
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    DSENVELOPEDESC          dsed;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsed, sizeof(dsed));

        dsed.dwEG = DSEG_MULTI;
        dsed.dwMode = DSEG_MODE_DISABLE;
        dsed.dwRelease = 1000;
        
        hr = ValidateResult(pBuffer->SetEG(&dsed));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, TRUE));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 0, FALSE, TRUE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  CompareVolume
 *
 *  Description:
 *      Compares comparable 2D and 3D buffer volume.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CompareVolume"

HRESULT
CompareVolume
(
    FLOAT                   flDistance,
	DWORD					dwNumTimes
)
{
    static const LONG       lExtra  = -600;
    const LONG              lVolume = (LONG)(-2000.0f * log10f(flDistance)) + lExtra;
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    BOOL                    f3d     = FALSE;
    HRESULT                 hr      = DS_OK;
	DWORD					dwCount = 0;
	DSMIXBINVOLUMEPAIR		mixBinVolumePair[2];
	DSMIXBINS				mixBins;

	mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
	mixBinVolumePair[0].lVolume		= 0;
	mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
	mixBinVolumePair[1].lVolume		= 0;
	mixBins.dwMixBinCount			= 2;
	mixBins.lpMixBinVolumePairs		= mixBinVolumePair;

    while(SUCCEEDED(hr) && dwCount < dwNumTimes)
    {
        DbgPrint(f3d ? "3D\n" : "2D\n");
        
        hr = ValidateResult(CreateToneBuffer(f3d ? DSBCAPS_CTRL3D : 0, 8000, 16, 1, 500, 0, f3d ? NULL : &mixBins, &pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetHeadroom(0));
        }

        if(SUCCEEDED(hr))
        {
            if(f3d)
            {
                hr = ValidateResult(pBuffer->SetPosition(0, 0, flDistance, DS3D_IMMEDIATE));
            }
            else
            {
                hr = ValidateResult(pBuffer->SetVolume(lVolume));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(PlayBuffer(pBuffer, TRUE));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(StopBuffer(pBuffer, 0, 2000, FALSE, TRUE));
        }

        RELEASE(pBuffer);

        f3d = !f3d;

		dwCount++;
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayToneBuffer
 *
 *  Description:
 *      Plays a simple sine-wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: length of time to play the buffer, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayToneBuffer"

HRESULT
PlayToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels,
    DWORD                   dwToneFrequency,
    DWORD                   dwTime
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(dwFlags, dwSamplesPerSec, dwBitsPerSample, dwChannels, dwToneFrequency, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, TRUE));
    }

    if(SUCCEEDED(hr) && (INFINITE != dwTime))
    {
        hr = ValidateResult(StopBuffer(pBuffer, 0, dwTime));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestNaturalStop
 *
 *  Description:
 *      Tests playing a buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: iterations.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNaturalStop"

HRESULT
TestNaturalStop
(
    DWORD                   dwIterations
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 400, 400, 0, &pBuffer));

    while(SUCCEEDED(hr))
    {
        if(INFINITE != dwIterations)
        {
            if(!dwIterations--)
            {
                break;
            }
        }
    
        hr = ValidateResult(PlayBuffer(pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFlush
 *
 *  Description:
 *      Tests flushing a stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestFlush"

HRESULT
TestFlush
(
    void
)
{
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    DWORD                   dwPacketSize        = 0x1000;
    LPVOID                  pvAudioData         = NULL;
    DWORD                   dwAudioDataSize     = NULL;
    DWORD                   dwPacketCount       = 0;
    LPDWORD                 padwStatus          = NULL;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwStatus = padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);
        hr = ValidateResult(pStream->Flush());
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && 
			   (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                if(padwStatus[i] == XMEDIAPACKET_STATUS_PENDING)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_PENDING\n", i);
				else if(padwStatus[i] == XMEDIAPACKET_STATUS_FAILURE)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_FAILURE\n", i);
				else
					DbgPrint("Packet %lu status: %x\n", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}

//------------------------------------------------------------------------------
//	TestFlushEx1
//------------------------------------------------------------------------------
#undef DPF_FNAME
#define DPF_FNAME "TestFlushEx"
HRESULT
TestFlushEx1(void)
/*++

Routine Description:

	Tests the FlushEx method on streams: DSSTREAMFLUSHEX_ASYNC

Arguments:

	None

Return Value:

	HRESULT: COM result code

--*/
{
    const LPCWAVEFORMATEX	pwfxFormat		= CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM		pStream			= NULL;
    DWORD					dwPacketSize	= 0x1000;
    LPVOID					pvAudioData		= NULL;
    DWORD					dwAudioDataSize	= NULL;
    DWORD					dwPacketCount	= 0;
    LPDWORD					padwStatus		= NULL;
    XMEDIAPACKET			xmp;
    HRESULT					hr;
    DWORD					i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL,
										NULL, NULL, &pStream, &pvAudioData, 
										&dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer	= pvAudioData;
        xmp.dwMaxSize	= dwPacketSize;
        xmp.pdwStatus	= padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * 
												   (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);
        hr = ValidateResult(pStream->FlushEx(0, DSSTREAMFLUSHEX_ASYNC));
		if(SUCCEEDED(hr))
		{
			do
			{
				DirectSoundDoWork();
				hr = ValidateResult(pStream->GetStatus(&i));
				Sleep(20);
			}
			while(SUCCEEDED(hr) && (i == DSSTREAMSTATUS_PLAYING));
		}
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && 
			   (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                if(padwStatus[i] == XMEDIAPACKET_STATUS_PENDING)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_PENDING\n", i);
				else if(padwStatus[i] == XMEDIAPACKET_STATUS_FAILURE)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_FAILURE\n", i);
				else
					DbgPrint("Packet %lu status: %x\n", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}

//------------------------------------------------------------------------------
//	TestFlushEx2
//------------------------------------------------------------------------------
#undef DPF_FNAME
#define DPF_FNAME "TestFlushEx"
HRESULT
TestFlushEx2(void)
/*++

Routine Description:

	Tests the FlushEx method on streams

Arguments:

	None

Return Value:

	HRESULT: COM result code

--*/
{
    const LPCWAVEFORMATEX	pwfxFormat		= CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM		pStream			= NULL;
    DWORD					dwPacketSize	= 0x1000;
    LPVOID					pvAudioData		= NULL;
    DWORD					dwAudioDataSize	= NULL;
    DWORD					dwPacketCount	= 0;
    LPDWORD					padwStatus		= NULL;
    XMEDIAPACKET			xmp;
    HRESULT					hr;
    DWORD					i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL,
										NULL, NULL, &pStream, &pvAudioData, 
										&dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer	= pvAudioData;
        xmp.dwMaxSize	= dwPacketSize;
        xmp.pdwStatus	= padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * 
												   (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);

        hr = ValidateResult(pStream->FlushEx(0, DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE));
		if(SUCCEEDED(hr))
		{
			do
			{
				DirectSoundDoWork();
				hr = pStream->GetStatus(&i);
				Sleep(20);
			}
			while(SUCCEEDED(hr) && (i == DSSTREAMSTATUS_PLAYING));
		}
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && 
			   (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                if(padwStatus[i] == XMEDIAPACKET_STATUS_PENDING)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_PENDING\n", i);
				else if(padwStatus[i] == XMEDIAPACKET_STATUS_FAILURE)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_FAILURE\n", i);
				else
					DbgPrint("Packet %lu status: %x\n", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}

//------------------------------------------------------------------------------
//	TestFlushEx3
//------------------------------------------------------------------------------
#undef DPF_FNAME
#define DPF_FNAME "TestFlushEx"
HRESULT
TestFlushEx3(void)
/*++

Routine Description:

	Tests the FlushEx method on streams

Arguments:

	None

Return Value:

	HRESULT: COM result code

--*/
{
    const LPCWAVEFORMATEX	pwfxFormat		= CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM		pStream			= NULL;
    DWORD					dwPacketSize	= 0x1000;
    LPVOID					pvAudioData		= NULL;
    DWORD					dwAudioDataSize	= NULL;
    DWORD					dwPacketCount	= 0;
    LPDWORD					padwStatus		= NULL;
    XMEDIAPACKET			xmp;
    HRESULT					hr;
    DWORD					i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL,
										NULL, NULL, &pStream, &pvAudioData, 
										&dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer	= pvAudioData;
        xmp.dwMaxSize	= dwPacketSize;
        xmp.pdwStatus	= padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * 
												   (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);

        hr = ValidateResult(pStream->FlushEx(0, DSSTREAMFLUSHEX_IMMEDIATE));
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && 
			   (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                if(padwStatus[i] == XMEDIAPACKET_STATUS_PENDING)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_PENDING\n", i);
				else if(padwStatus[i] == XMEDIAPACKET_STATUS_FAILURE)
	                DbgPrint("Packet %lu status: XMEDIAPACKET_STATUS_FAILURE\n", i);
				else
					DbgPrint("Packet %lu status: %x\n", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}

//------------------------------------------------------------------------------
//	TestFlushEx
//------------------------------------------------------------------------------
#undef DPF_FNAME
#define DPF_FNAME "TestFlushEx"
HRESULT
TestFlushEx(void)
/*++

Routine Description:

	Tests the FlushEx method on streams

Arguments:

	None

Return Value:

	HRESULT: COM result code

--*/
{
	HRESULT	hr1;
	HRESULT	hr2;
	HRESULT	hr3;

	hr1 = ValidateResult(TestFlushEx1());
	hr2 = ValidateResult(TestFlushEx2());
	hr3 = ValidateResult(TestFlushEx3());

	if(FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
		return E_FAIL;
    return S_OK;
}

/****************************************************************************
 *
 *  TestPitch
 *
 *  Description:
 *      Tests pitch.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestPitch"

HRESULT
TestPitch
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
)
{
    static const LONG       alPitch[]   = { DSBPITCH_MIN, 0, DSBPITCH_MAX };
    const LPCWAVEFORMATEX   pwfxFormat  = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannels);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdBuffer(dwFlags, pwfxFormat, 0, NULL, &pBuffer, NULL));

    if(SUCCEEDED(hr))
    {
        for(i = 0; (i < NUMELEMS(alPitch)) && SUCCEEDED(hr); i++)
        {
            DbgPrint("Pitch %d\n", alPitch[i]);
            
            hr = ValidateResult(pBuffer->SetPitch(alPitch[i]));

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(PlayBuffer(pBuffer, TRUE));
            }

            if(SUCCEEDED(hr))
            {
                Sleep(2000);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  StressPlayStop
 *
 *  Description:
 *      Stresses calling Play and Stop.
 *
 *  Arguments:
 *      DWORD [in]: time to test, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "StressPlayStop"

HRESULT
StressPlayStop
(
    DWORD                   dwTestLength
)
{
    LPDIRECTSOUNDBUFFER     apSourceBuffers[256]    = { NULL };
    LPDIRECTSOUNDBUFFER     pDestBuffer             = NULL;
    DWORD                   dwPlayCount             = 0;
    DWORD                   dwStopCount             = 0;
    DWORD                   dwNaturalStopCount      = 0;
    DWORD                   dwSubmixCount           = 0;
    DWORD                   dwLoopCount             = 0;
    DWORD                   dwSourceCount;
    DWORD                   dwStartTime;
    DWORD                   dwCurrentTime;
    DSCAPS                  dsc;
    DSBUFFERDESC            dsbd;
    DWORD                   dwStatus;
    HRESULT                 hr;
    DWORD                   i;
	DWORD					index;
	BOOL					b2DBuffer[256];

    //
    // Create the submix buffer
    //

    ZeroMemory(&dsbd, sizeof(dsbd));
    
    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_MIXIN;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pDestBuffer));

    //
    // Create source buffers
    //
    
    if(SUCCEEDED(hr))
        hr = GetDirectSoundCaps(&dsc);

    if(SUCCEEDED(hr))
    {
		dwSourceCount = dsc.dwFree2DBuffers + dsc.dwFree3DBuffers;

		// 2D buffers
        for(index=0, i = 0; (i < dsc.dwFree2DBuffers) && SUCCEEDED(hr); i++, ++index)
		{
            hr = ValidateResult(CreateToneBuffer(0, 32000, 16, 1, 500, 0, 0, &apSourceBuffers[index]));
			b2DBuffer[index] = TRUE;
		}

		// 3D buffers
        for(i = 0; (i < dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++, ++index)
		{
            hr = ValidateResult(CreateToneBuffer(DSBCAPS_CTRL3D, 32000, 16, 1, 500, 0, 0, &apSourceBuffers[index]));
			b2DBuffer[index] = FALSE;
		}
    }

    //
    // Save the current time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    //

    while(SUCCEEDED(hr))
    {
        //
        // Check the current time
        //
        
        if(!((dwCurrentTime = GetTickCount()) % 2000))
        {
            DbgPrint("%lu plays (%lu submixing, %lu looping), %lu natural stops, %lu forced\n", dwPlayCount, dwSubmixCount, dwLoopCount, dwStopCount, dwNaturalStopCount);

            dwPlayCount = 0;
            dwStopCount = 0;
            dwNaturalStopCount = 0;
            dwSubmixCount = 0;
            dwLoopCount = 0;

            if(INFINITE != dwTestLength)
            {
                if(dwCurrentTime >= dwStartTime + dwTestLength)
                {
                    break;
                }
            }
        }

        //
        // Pick a random buffer
        //

        i = rand() % dwSourceCount;

        hr = ValidateResult(apSourceBuffers[i]->GetStatus(&dwStatus));

        //
        // Should we play or stop?
        //

        if(SUCCEEDED(hr))
        {
            if(rand() % 2)
            {
                dwPlayCount++;
            
                //
                // Submix or not?
                //
            
                if(!(dwStatus & DSBSTATUS_PLAYING))
                {
                    if(b2DBuffer[i] && (rand() % 2))
                    {
                        dwSubmixCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(pDestBuffer));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(NULL));
                    }
                }

                //
                // Loop or not?
                //

                if(SUCCEEDED(hr)) 
                {
                    if(rand() % 2)
                    {
                        dwLoopCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, DSBPLAY_LOOPING));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, 0));
                    }
                }
            }
            else
            {
                //
                // Still playing?
                //
            
                if(dwStatus & DSBSTATUS_PLAYING)
                {
                    dwStopCount++;

                    hr = ValidateResult(apSourceBuffers[i]->Stop());
                }
                else
                {
                    dwNaturalStopCount++;
                }
            }
        }
    }

    for(i = 0; i < dwSourceCount; i++)
    {
        RELEASE(apSourceBuffers[i]);
    }

    RELEASE(pDestBuffer);

    return hr;
}    


/****************************************************************************
 *
 *  FindFrequencyRange
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FindFrequencyRange"

HRESULT
FindFrequencyRange
(
    void
)
{
    LONG	lPitch;
    DWORD	i;
    HRESULT	hr	= DS_OK;

	for(i=DSBFREQUENCY_MIN; i<=DSBFREQUENCY_MAX; ++i)
	{
		lPitch = XAudioCalculatePitch(i);
		if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
		{
			DbgPrint("Out of range Pitch: %ld, Frequency: %lu\n", lPitch, i);
			hr = E_FAIL;
		}
	}

    return DS_OK;
}


/****************************************************************************
 *
 *  TestTimeStampedPackets
 *
 *  Description:
 *      Tests stream packets with a timestamp.
 *
 *  Arguments:
 *      DWORD [in]: delay between packets, in milliseconds.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestTimeStampedPackets"

HRESULT
TestTimeStampedPackets
(
    DWORD                   dwDelay
)
{
    static const DWORD      dwPacketCount                   = 2;
    const LPCWAVEFORMATEX   pwfxFormat                      = CreateFormat(WAVE_FORMAT_PCM, 8000, 16, 1);
    const DWORD             dwBufferSize                    = pwfxFormat->nAvgBytesPerSec * 4;
    LPVOID                  pvPacketData                    = NULL;
    LPDIRECTSOUNDSTREAM     pStream                         = NULL;
    DWORD                   adwStatus[dwPacketCount];
    REFERENCE_TIME          rtPacketLength;
    REFERENCE_TIME          artTimeStamps[dwPacketCount];
    DSSTREAMDESC            dssd;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    ZeroMemory(&dssd, sizeof(dssd));

    dssd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
    dssd.dwMaxAttachedPackets = dwPacketCount;

    hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvPacketData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvPacketData, dwBufferSize, pwfxFormat->nSamplesPerSec, pwfxFormat->wBitsPerSample, pwfxFormat->nChannels, 500);

        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvPacketData;
        xmp.dwMaxSize = dwBufferSize;

        rtPacketLength = ((REFERENCE_TIME)dwBufferSize * 10000000i64) / (REFERENCE_TIME)pwfxFormat->nAvgBytesPerSec;
        rtPacketLength += (REFERENCE_TIME)dwDelay * 10000i64;
        
        for(i = 0; (i < dwPacketCount) && SUCCEEDED(hr); i++)
        {
            artTimeStamps[i] = -(rtPacketLength * i);

            xmp.pdwStatus = &adwStatus[i];
            xmp.prtTimestamp = &artTimeStamps[i];

            hr = ValidateResult(pStream->Process(&xmp, NULL));
        }
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            while(XMEDIAPACKET_STATUS_PENDING == adwStatus[i])
            {
                DirectSoundDoWork();
            }
        }
    }

    RELEASE(pStream);
    FREE(pvPacketData);

    return hr;
}

/****************************************************************************
 *
 *  DsoundDRT_StartTest
 *
 *  Description:
 *      The Harness Entry into the DsoundDRT tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DsoundDRT_StartTest( HANDLE LogHandle )
{
    HRESULT			hr              = S_OK;
    LPDIRECTSOUND	pDirectSound    = NULL;
	MEDIAFILEDESC	media[] = 
	{
		{"dsp/dsstdfx.bin", "t:\\media\\dspcode", COPY_IF_NEWER },
		{"wav/CleanGuitarArpeggios.wav", "t:\\media\\audio\\pcm", COPY_IF_NOT_EXIST },
		{"wav/(\\d+)k(\\d+)b[m s].wav", "t:\\media\\audio\\pcm", COPY_IF_NOT_EXIST },
		{"wav/adpcm/(\\d+)k(\\d+)b[m s].wav", "t:\\media\\audio\\adpcm", COPY_IF_NOT_EXIST },
		{NULL, NULL, 0}
	};
	// Load media
	hr = LoadMedia(media);

//"t:\\media\\audio\\ac3\\dd-broadway.wav"

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

	// Disable the busy wait warning 
	g_fDirectSoundDisableBusyWaitWarning = TRUE;

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	// Ensure that no previous DSound's are still running
	hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));
	while(pDirectSound->Release());
	
    //
    // Test DsoundDRT in the mannor it was meant to be called
    //

    DirectSoundUseFullHRTF();

    //
    // Create the DirectSound object
    //
	
    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    //
    // Load the default effects image
    //

	DbgPrint("*****LoadEffectsImage(pDirectSound, \"t:\\media\\dspcode\\dsstdfx.bin\" )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "LoadEffectImage" );
	EXECUTE( LoadEffectsImage(pDirectSound, "t:\\media\\dspcode\\dsstdfx.bin" ) );

	DbgPrint("*****PlayOneShotBuffer( 0, WAVE_FORMAT_PCM, 48000, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "PlayOneShotBuffer PCM" );
	EXECUTE( PlayOneShotBuffer( 0, WAVE_FORMAT_PCM, 48000, 16, 1 ) );

	DbgPrint("*****PlayOneShotStream( 0, WAVE_FORMAT_PCM, 48000, 16, 1, 0x4000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "PlayOneShotStream PCM" );
	EXECUTE( PlayOneShotStream( 0, WAVE_FORMAT_PCM, 48000, 16, 1, 0x4000 ) );


	DbgPrint("*****PlayOneShotStream( 0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "PlayOneShotStream ADPCM" );
	EXECUTE( PlayOneShotStream( 0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000 ) );

	DbgPrint("*****PlayToneBuffer( 0, 8000, 8, 1, 400, 2000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "PlayToneBuffer" );
	EXECUTE( PlayToneBuffer( 0, 8000, 8, 1, 400, 2000 ) );

	DbgPrint("*****Test3d( 0.0f, 0.0f, 5.0f, 5.0f, -72.0f, 200 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "Test3D" );
	EXECUTE( Test3d( 0.0f, 0.0f, 5.0f, 5.0f, -72.0f, 200 ) );

	DbgPrint("*****TestMultipleBuffers( WAVE_FORMAT_PCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestMultipleBuffers PCM" );
	EXECUTE( TestMultipleBuffers( WAVE_FORMAT_PCM ) );

	DbgPrint("*****TestMultipleBuffers( WAVE_FORMAT_XBOX_ADPCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestMultipleBuffers ADPCM" );
	EXECUTE( TestMultipleBuffers( WAVE_FORMAT_XBOX_ADPCM ) );

	DbgPrint("*****TestMultipleStreams( WAVE_FORMAT_PCM, 0x4000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestMultipleStreams PCM" );
	EXECUTE( TestMultipleStreams( WAVE_FORMAT_PCM, 0x4000 ) );

	DbgPrint("*****TestMultipleStreams( WAVE_FORMAT_XBOX_ADPCM, 0x4000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestMultipleStreams ADPCM" );
	EXECUTE( TestMultipleStreams( WAVE_FORMAT_XBOX_ADPCM, 0x4000 ) );

	DbgPrint("*****TestSequentialBuffers( WAVE_FORMAT_PCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSequentialBuffers PCM" );
	EXECUTE( TestSequentialBuffers( WAVE_FORMAT_PCM ) );

	DbgPrint("*****TestSequentialBuffers( WAVE_FORMAT_XBOX_ADPCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSequentialBuffers ADPCM" );
	EXECUTE( TestSequentialBuffers( WAVE_FORMAT_XBOX_ADPCM ) );

	DbgPrint("*****TestNotifies( WAVE_FORMAT_PCM, 22050, 16, 1, 20, FALSE )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestNotifies PCM" );
	EXECUTE( TestNotifies( WAVE_FORMAT_PCM, 22050, 16, 1, 20, FALSE ) );

	DbgPrint("*****TestNotifies( WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 20, FALSE )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestNotifies ADPCM" );
	EXECUTE( TestNotifies( WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 20, FALSE ) );

	DbgPrint("*****TestLoopRegion( WAVE_FORMAT_PCM, 48000, 16, 2, 0.5f, 1.0f )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestLoopRegion PCM" );
	EXECUTE( TestLoopRegion( WAVE_FORMAT_PCM, 48000, 16, 2, 0.5f, 1.0f ) );

	DbgPrint("*****TestLoopRegion( WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 2, 0.5f, 1.0f )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestLoopRegion ADPCM" );
	EXECUTE( TestLoopRegion( WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 2, 0.5f, 1.0f ) );

	DbgPrint("*****TestSubMix( TRUE, WAVE_FORMAT_PCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSubMix PCM" );
	EXECUTE( TestSubMix( TRUE, WAVE_FORMAT_PCM ) );

	DbgPrint("*****TestSubMix( TRUE, WAVE_FORMAT_XBOX_ADPCM )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSubMix ADPCM" );
	EXECUTE( TestSubMix( TRUE, WAVE_FORMAT_XBOX_ADPCM ) );

	DbgPrint("*****TestDLS( WAVE_FORMAT_PCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestDLS PCM" );
	EXECUTE( TestDLS( WAVE_FORMAT_PCM, 44100, 16, 1 ) );

	DbgPrint("*****TestDLS( WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestDLS ADPCM" );
	EXECUTE( TestDLS( WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 ) );

	DbgPrint("*****TestSurroundEncoder( WAVE_FORMAT_PCM, 44100, 16 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSurroundEncoder PCM" );
	EXECUTE( TestSurroundEncoder( WAVE_FORMAT_PCM, 44100, 16 ) );

	DbgPrint("*****TestSurroundEncoder( WAVE_FORMAT_XBOX_ADPCM, 44100, 16 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSurroundEncoder ADPCM" );
	EXECUTE( TestSurroundEncoder( WAVE_FORMAT_XBOX_ADPCM, 44100, 16 ) );

	DbgPrint("*****TestSgeSharing()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestSGESharing" );
	EXECUTE( TestSgeSharing() );

	DbgPrint("*****TestAllVoices()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestAllVoices" );
	EXECUTE( TestAllVoices() );

	DbgPrint("*****TestStop( WAVE_FORMAT_PCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestStop PCM" );
	EXECUTE( TestStop( WAVE_FORMAT_PCM, 44100, 16, 1 ) );

	DbgPrint("*****TestStop( WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestStop ADPCM" );
	EXECUTE( TestStop( WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 ) );

	DbgPrint("*****TestFrequency( DSBCAPS_CTRL3D, WAVE_FORMAT_PCM, 22050, 16, 1, 5000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestFrequency PCM" );
	EXECUTE( TestFrequency( DSBCAPS_CTRL3D, WAVE_FORMAT_PCM, 22050, 16, 1, 5000 ) );

	DbgPrint("*****TestFrequency( DSBCAPS_CTRL3D, WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 5000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestFrequency ADPCM" );
	EXECUTE( TestFrequency( DSBCAPS_CTRL3D, WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 5000 ) );

	DbgPrint("*****TestDiscontinuity( 0, WAVE_FORMAT_PCM, 22050, 16, 1, 0x4000, TRUE )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestDiscontinuity PCM" );
	EXECUTE( TestDiscontinuity( 0, WAVE_FORMAT_PCM, 22050, 16, 1, 0x4000, TRUE ) );

	DbgPrint("*****TestDiscontinuity( 0, WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 0x4000, TRUE )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestDiscontinuity ADPCM" );
	EXECUTE( TestDiscontinuity( 0, WAVE_FORMAT_XBOX_ADPCM, 22050, 16, 1, 0x4000, TRUE ) );

	DbgPrint("*****TestDeferredCommandRelease()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestDeferredCommandRelease" );
	EXECUTE( TestDeferredCommandRelease() );

	DbgPrint("*****TestHeadroom()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestHeadRoom" );
	EXECUTE( TestHeadroom() );

	DbgPrint("*****TestI3DL2Listener()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestI3DL3Listener" );
	EXECUTE( TestI3DL2Listener() );

	DbgPrint("*****TestMultiChannel( 44100, 8, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestMultipleChannel" );
	EXECUTE( TestMultiChannel( 44100, 8, 1 ) );

	DbgPrint("*****StressPlayStop( 2000 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "StressPlayStop" );
	EXECUTE( StressPlayStop( 2000 ) );

	DbgPrint("*****TestReleaseEnvelope()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "ReleaseEnvelope" );
	EXECUTE( TestReleaseEnvelope() );

	DbgPrint("*****CompareVolume( 2.0f, 10 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "CompareVolume" );
	EXECUTE( CompareVolume( 2.0f, 10 ) );

	DbgPrint("*****TestNaturalStop( 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestNaturalStop" );
	EXECUTE( TestNaturalStop( 1 ) );

	DbgPrint("*****TestFlush()*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestFlush" );
	EXECUTE( TestFlush() );

	DbgPrint("*****TestFlushEx()*****\n");
	SETLOG( LogHandle, "robheit", "MCPX", "DsoundDRT", "TestFlushEx" );
	EXECUTE( TestFlushEx() );

	DbgPrint("*****TestPitch( 0, WAVE_FORMAT_PCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestPitch PCM" );
	EXECUTE( TestPitch( 0, WAVE_FORMAT_PCM, 44100, 16, 1 ) );

	DbgPrint("*****TestPitch( 0, WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestPitch ADPCM" );
	EXECUTE( TestPitch( 0, WAVE_FORMAT_XBOX_ADPCM, 44100, 16, 1 ) );

	DbgPrint("*****FindFrequencyRange(  )*****\n");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "FindFrequcnyRange" );
	EXECUTE( FindFrequencyRange(  ) );

	// Time Stamped Packets no longer supported
//	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "TestTimeStampedPackets" );
//	EXECUTE( TestTimeStampedPackets( 5000 ) );

    //
    // Release the DirectSound object before AC97 tests start
    //

    RELEASE( pDirectSound );

	//
	// Test the Ac97
	//

	DbgPrint("*****TestAc97Xmo( DSAC97_CHANNEL_ANALOG, DSAC97_MODE_PCM )*****");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "ac97 analog" );
    EXECUTE( TestAc97Xmo( DSAC97_CHANNEL_ANALOG, DSAC97_MODE_PCM ) );

	DbgPrint("*****TestAc97Xmo( DSAC97_CHANNEL_DIGITAL, DSAC97_MODE_PCM )*****");
	SETLOG( LogHandle, "danrose", "MCPX", "DsoundDRT", "ac97 digital" );
    EXECUTE( TestAc97Xmo( DSAC97_CHANNEL_DIGITAL, DSAC97_MODE_PCM ) );


}

/****************************************************************************
 *
 *  DsoundDRT_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DsoundDRT_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    DsoundDRT_StartTest( NULL );
    DsoundDRT_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DsoundDRT )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DsoundDRT )
    EXPORT_TABLE_ENTRY( "StartTest", DsoundDRT_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DsoundDRT_EndTest )
END_EXPORT_TABLE( DsoundDRT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\DsoundDRT\DsoundDRT.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DsoundDRT.h
 *  Content:    DsoundDRT utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/20/01    danrose Created to test Xbox DsoundDRT
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include "util.h"

HRESULT TestAc97Xmo( DWORD dwChannel, DWORD dwMode );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\timetest\timetest.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    timetest.c

Abstract:

    test XBox time related APIs

Author:

    John Daly (johndaly) 10-May-2000

Environment:

    X-Box

Notes:

timetest - test these API's
        CompareFileTime
        FileTimeToLocalFileTime
        FileTimeToSystemTime
        GetLocalTime
        GetSystemTime
        GetSystemTimeAsFileTime
        GetTickCount
        GetTimeZoneInformation
        LocalFileTimeToFileTime
        Sleep
        SleepEx

Revision History:

    10-May-2000     johndaly
    created

Current Status:

    on hold until they sort out the timezone issue, the floor
    will fall out on me if they yank some of the OS stuff, 
    already they may pull timezone support, that will make re-writing
    this stuff a pain

--*/

//
// includes
//

#include "timetest.h"

VOID
WINAPI
test_FileTimeToLocalFileTime(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test the FileTimeToLocalFileTime() API
    test the LocalFileTimeToFileTime() API
    test the SystemTimeToFileTime() API
    test the FileTimeToSystemTime() API
    
Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

Notes:

    This is basically a self-referntial integrity test mixed 
    with an alternate calculation of the same value.  if 
    everything comes out ok, PASS
    PS this code sucks, but it sucked worse trying to debug it when I had macros doing all the work
    
--*/
{
    TIME_ZONE_INFORMATION SaveTimeZoneInfo = {0};   // current system timezone
    SYSTEMTIME SaveCSystemTime = {0};   // current system time
    
    TIME_ZONE_INFORMATION TimeZoneInfo = {0};
    SYSTEMTIME TestSystemTime[3] = {0};   // current system time
    
    SYSTEMTIME xTestSystemTime1 = {0};   // test system time
    SYSTEMTIME xTestSystemTime2 = {0};   // test system time
    FILETIME TestFileTime = {0};   // test file time
    FILETIME TestFileTime1 = {0};   // test file time

    ULARGE_INTEGER tmpULFileTime = {0};
    ULARGE_INTEGER ULFileTime = {0};
        
    FILETIME tmpFileTime = {0};
    FILETIME LocalFileTime = {0};

    int x = 0;
    int y = 0;

    //
    // positive test cases (probably overkill... the function is simple)
    // code review shows this function only returns TRUE, and does 
    // no parameter validation
    //

    xSetFunctionName( LogHandle, "FileTimeToLocalFileTime" );
    xStartVariation( LogHandle, "goodparam1" );
    
    //
    // a simple test (this code will not change much or at all from NT)
    // for last year, this year, 10 years from now
    // at UTC 00:00.0000000, 00:00.0000001, 12:00.0000000, 23:59.9999999
    // rotate through all the time zones, and see
    // if we got a result that makes sense
    //
    
    //
    // save
    //

    GetTimeZoneInformation(&SaveTimeZoneInfo);
    GetSystemTime(&SaveCSystemTime);
    
    //
    // I need to make this adjustment?
    //
    //
    //if (bUsingDST) {
    //    SaveCSystemTime.DaylightBias += 60;
    //}
    
    // current
    GetSystemTime(&TestSystemTime[0]);
    
    // 1 year ago
    GetSystemTime(&TestSystemTime[1]);
    SystemTimeToFileTime(&TestSystemTime[1], &tmpFileTime);
    ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
    ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
    ULFileTime.QuadPart -= YEAR_TIME;
    tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
    tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
    FileTimeToSystemTime(&tmpFileTime, &TestSystemTime[1]);

    // 10 years from now
    GetSystemTime(&TestSystemTime[2]);
    SystemTimeToFileTime(&TestSystemTime[2], &tmpFileTime);
    ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
    ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
    ULFileTime.QuadPart += 10*YEAR_TIME;
    tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
    tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
    FileTimeToSystemTime(&tmpFileTime, &TestSystemTime[2]);
    
    //
    // Current time, set the bias to 0, we play with the bias during the test loop
    //

    GetTimeZoneInformation(&TimeZoneInfo);
    TimeZoneInfo.Bias = 0;
    XapipSetTimeZoneInformation(&TimeZoneInfo);  // put us in UTC - bias is now gone
    
    //
    // make system times tstX (can be fake)
    //  - set UTC time
    //  - set time zone
    //  - set case - offsets from 00:00.0000000
    // 
    // SystemTimeToFileTime( IN xTestSystemTime1, OUT TestFileTime) // UTC
    // FileTimeToSystemTime(IN TestFileTime, OUT xTestSystemTime2 ) // UTC
    // assert (xTestSystemTime == xTestSystemTime2)
    //
    // SystemTimeToFileTime(&xTestSystemTime1, &TestFileTime); 
    // FileTimeToSystemTime(&TestFileTime, &xTestSystemTime2); 
    // assert (cmpLocalFileTime == LocalFileTime)
    //
    // y[0] = current, y[1] = 1 year ago, y[2] = 10 years from now
    //

    for (y = 0; y < 3; y++) {
        while(x < 24) {
    
            //
            // set system time / time zone
            //
    
            TimeZoneInfo.Bias += (x * 60);
            XapipSetTimeZoneInformation(&TimeZoneInfo);
    
            //
            // convert various times / check them
            //
    
            memcpy(&xTestSystemTime1, &TestSystemTime[y], sizeof(SYSTEMTIME));
            
            //
            // at UTC 00:00.0000000
            //
    
            SystemTimeToFileTime(&xTestSystemTime1, &TestFileTime);
            FileTimeToSystemTime(&TestFileTime, &xTestSystemTime2);
            xLog(LogHandle,
                 (0 == memcmp(&xTestSystemTime1, &xTestSystemTime2, sizeof(SYSTEMTIME))) ? 
                 XLL_PASS : XLL_FAIL, "sys - UTC 00:00.0000000");

            FileTimeToLocalFileTime(&TestFileTime, &LocalFileTime);
            LocalFileTimeToFileTime(&LocalFileTime, &TestFileTime1);
            xLog(LogHandle,
                 (0 == memcmp(&TestFileTime, &TestFileTime1, sizeof(FILETIME))) ? 
                 XLL_PASS : XLL_FAIL, "file - UTC 00:00.0000000");
            
            //
            // at UTC 00:00.0000001
            //

            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart += TIME_0001;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);
            
            SystemTimeToFileTime(&xTestSystemTime1, &TestFileTime);
            FileTimeToSystemTime(&TestFileTime, &xTestSystemTime2);
            xLog(LogHandle,
                 (0 == memcmp(&xTestSystemTime1, &xTestSystemTime2, sizeof(SYSTEMTIME))) ? 
                 XLL_PASS : XLL_FAIL, "sys - UTC 00:00.0000001");
            
            FileTimeToLocalFileTime(&TestFileTime, &LocalFileTime);
            LocalFileTimeToFileTime(&LocalFileTime, &TestFileTime1);
            xLog(LogHandle,
                 (0 == memcmp(&TestFileTime, &TestFileTime1, sizeof(FILETIME))) ? 
                 XLL_PASS : XLL_FAIL, "file - UTC 00:00.0000001");
            
            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart -= TIME_0001;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);
    
            //
            // at UTC 12:00.0000000
            //

            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart += TIME_1200;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);
            
            SystemTimeToFileTime(&xTestSystemTime1, &TestFileTime);
            FileTimeToSystemTime(&TestFileTime, &xTestSystemTime2);
            xLog(LogHandle,
                 (0 == memcmp(&xTestSystemTime1, &xTestSystemTime2, sizeof(SYSTEMTIME))) ? 
                 XLL_PASS : XLL_FAIL, "sys - UTC 12:00.0000000");
            
            FileTimeToLocalFileTime(&TestFileTime, &LocalFileTime);
            LocalFileTimeToFileTime(&LocalFileTime, &TestFileTime1);
            xLog(LogHandle,
                 (0 == memcmp(&TestFileTime, &TestFileTime1, sizeof(FILETIME))) ? 
                 XLL_PASS : XLL_FAIL, "file - UTC 12:00.0000000");
            
            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart -= TIME_1200;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);
    
            //
            // at UTC 23:59.9999999
            //
    
            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart += TIME_2359;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);
            
            SystemTimeToFileTime(&xTestSystemTime1, &TestFileTime);
            FileTimeToSystemTime(&TestFileTime, &xTestSystemTime2);
            xLog(LogHandle,
                 (0 == memcmp(&xTestSystemTime1, &xTestSystemTime2, sizeof(SYSTEMTIME))) ? 
                 XLL_PASS : XLL_FAIL, "sys - UTC 23:59.9999999");
            
            FileTimeToLocalFileTime(&TestFileTime, &LocalFileTime);
            LocalFileTimeToFileTime(&LocalFileTime, &TestFileTime1);
            xLog(LogHandle,
                 (0 == memcmp(&TestFileTime, &TestFileTime1, sizeof(FILETIME))) ? 
                 XLL_PASS : XLL_FAIL, "file - UTC 23:59.9999999");
            
            SystemTimeToFileTime(&xTestSystemTime1, &tmpFileTime);
            ULFileTime.LowPart = tmpFileTime.dwLowDateTime;
            ULFileTime.HighPart = tmpFileTime.dwHighDateTime;
            ULFileTime.QuadPart -= TIME_2359;
            tmpFileTime.dwLowDateTime = ULFileTime.LowPart;
            tmpFileTime.dwHighDateTime = ULFileTime.HighPart;
            FileTimeToSystemTime(&tmpFileTime, &xTestSystemTime1);

            x++;
        }

        //
        // restore
        //
    
        XapiSetLocalTime(&SaveCSystemTime);
        XapipSetTimeZoneInformation(&SaveTimeZoneInfo);
        x = 0;
    }
    
    XapipSetTimeZoneInformation(&SaveTimeZoneInfo);
    
    xEndVariation( LogHandle );

    return;
}

VOID
WINAPI
test_GetTickCount(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test the GetTickCount() API

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

--*/
{
    //
    // positive test cases
    // just use a very simple test
    //
    
    DWORD dwTickCount1;
    DWORD dwTickCount2;
    DWORD dwTickCount;

    xSetFunctionName( LogHandle, "GetTickCount" );
    xStartVariation( LogHandle, "goodparam1" );
    
    dwTickCount1 = GetTickCount();
    Sleep(1000);
    dwTickCount2 = GetTickCount();
    dwTickCount = dwTickCount2 - dwTickCount1;

    if ((dwTickCount < 1100) || (dwTickCount > 900)) {
        xLog(LogHandle, XLL_PASS, "GetTickCount within 10%% tolerance");
    } else {
        xLog(LogHandle,
             XLL_FAIL, 
             "GetTickCount outside 10% tolerance, expected 1000ms, got:%dms", 
             dwTickCount);
    }

    xEndVariation( LogHandle );

    return;
}

#define THREADNUM 50

struct RESULTSARRAY {
        SYSTEMTIME start;
        SYSTEMTIME finish;
}ResultsArray[THREADNUM] = {0};

VOID
WINAPI
test_Sleep(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test the Sleep() API

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

--*/
{
    DWORD ThreadID;
    FILETIME FileTimeStart;
    FILETIME FileTimeFinish;
    ULARGE_INTEGER ulFileTimeStart;
    ULARGE_INTEGER ulFileTimeFinish;
    ULONGLONG ulExpectedTime;
    ULONGLONG ulExpectedTimeStart;
    ULONGLONG ulExpectedTimeFinish;
    
    HANDLE threads[50] = {0};
    int x = 0;

    //
    // positive test cases
    //
    
    xSetFunctionName( LogHandle, "Sleep" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // create 50 threads, each sleeps a multiple of 2000 milliseconds, 0 - 100
    // waits for threads to all complete, then checks results
    //

    for ( x = 0; x < THREADNUM ; x++ ) {
        threads[x] = CreateThread(NULL,
                     4096,
                     (LPTHREAD_START_ROUTINE)SleepTestThread,
                     (LPVOID)(x),
                     0,
                     &ThreadID);
    }

    WaitForMultipleObjects(THREADNUM, 
                           &threads[0],
                           TRUE,
                           200 * 1000);

    for ( x = 0; x < THREADNUM ; x++ ) {
        CloseHandle(threads[x]);
    }

    //
    // check results
    // iterate through the times, make sure the waits were within 10% 
    // (is this an appropriate tolerance?) of the expected sleep time
    //

    for ( x = 0; x < THREADNUM ; x++ ) {
        
        SystemTimeToFileTime(&ResultsArray[x].start, &FileTimeStart);
        SystemTimeToFileTime(&ResultsArray[x].finish, &FileTimeFinish);
        ulFileTimeStart.LowPart = FileTimeStart.dwLowDateTime;  
        ulFileTimeStart.HighPart = FileTimeStart.dwHighDateTime;
        ulFileTimeFinish.LowPart = FileTimeFinish.dwLowDateTime;  
        ulFileTimeFinish.HighPart = FileTimeFinish.dwHighDateTime;
        ulFileTimeFinish.QuadPart -= ulFileTimeStart.QuadPart;

        if (0 == x) {
            
            //
            // ok, how long should sleeping 0 take...
            //

            xLog(LogHandle, XLL_PASS, "sleep(0) call took:%I64u ", ulFileTimeFinish.QuadPart);
            continue;

        } else {

            ulExpectedTime = (x * 2) * 10000000;
            ulExpectedTimeFinish = (ulExpectedTime + ulExpectedTime/10);
            ulExpectedTimeStart = (ulExpectedTime - ulExpectedTime/10);

        }

        xLog(LogHandle,
            ((ulFileTimeFinish.QuadPart < ulExpectedTimeFinish) && 
             (ulFileTimeFinish.QuadPart > ulExpectedTimeStart))
            ? XLL_PASS : XLL_FAIL, "thread sequence #:%d", x);

    }
    
    xEndVariation( LogHandle );

}

DWORD
WINAPI
SleepTestThread(
    LPVOID lpParameter
    )
/*++

Routine Description:

    test test thread for the SleepEx() API test

Arguments:

    lpParameter - thread sequence number to access the thread data RESULTSARRAY array

Return Value:

    None

--*/
{
    GetSystemTime(&ResultsArray[(int)lpParameter].start);
    Sleep((DWORD)lpParameter * 2000);
    GetSystemTime(&ResultsArray[(int)lpParameter].finish);
    return(0);
}

typedef struct _SLEEPEXTESTTHREADPARAMS {
    DWORD dwMilliseconds;  // time-out interval
    BOOL bAlertable;
    DWORD threadnum;
    HANDLE IoCompletionPortHandle;
    DWORD dwErrorCode;                // completion code
    DWORD dwNumberOfBytesTransfered;  // number of bytes transferred
    DWORD NumberOfBytes;     
    ULONG CompletionKey;  // file completion key
    BOOL CompletionStatusRetVal;
} SLEEPEXTESTTHREADPARAMS, *LPSLEEPEXTESTTHREADPARAMS;

SLEEPEXTESTTHREADPARAMS ThreadParams[THREADNUM] = {0};

VOID
WINAPI
test_SleepEx(
            HANDLE LogHandle
            )
/*++

Routine Description:

    test the SleepEx() API

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

--*/ 
{

    //
    // positive test cases
    //

    //
    // Scenario #1
    // plain-old sleeping...
    // we can re-write this to call the test_sleep function with changed pointers
    // to cut down on the code, maybe later
    //
    {
        DWORD ThreadID;
        FILETIME FileTimeStart;
        FILETIME FileTimeFinish;
        ULARGE_INTEGER ulFileTimeStart;
        ULARGE_INTEGER ulFileTimeFinish;
        ULONGLONG ulExpectedTime;
        ULONGLONG ulExpectedTimeStart;
        ULONGLONG ulExpectedTimeFinish;
        DWORD ExitCode;

        HANDLE threads[50] = {0};
        int x = 0;

        xSetFunctionName( LogHandle, "SleepEx" );
        xStartVariation( LogHandle, "Variation#1" );

        //
        // create 50 threads, each sleeps a multiple of 2000 milliseconds, 0 - 100
        // waits for threads to all complete, then checks results
        //

        ZeroMemory(&ResultsArray[0], THREADNUM * (sizeof (struct RESULTSARRAY)));

        for ( x = 0; x < THREADNUM ; x++ ) {
            ThreadParams[x].bAlertable = FALSE;
            ThreadParams[x].dwMilliseconds = 2000 * x;
            ThreadParams[x].threadnum = x;

            threads[x] = CreateThread(NULL,
                                      65536,
                                      (LPTHREAD_START_ROUTINE)SleepExTestThread,
                                      (LPVOID)&ThreadParams[x],
                                      0,
                                      &ThreadID);
        }

        WaitForMultipleObjects(THREADNUM, 
                               &threads[0],
                               TRUE,
                               200 * 1000);

        //
        // check exit codes, close handles
        //

        for ( x = 0; x < THREADNUM ; x++ ) {
            GetExitCodeThread(threads[x], &ExitCode);
            if (0 != ExitCode) {
                xLog(LogHandle, 
                     XLL_FAIL, 
                     "Non-0 exit code detected in SleepEx: code:%d Handle:%d", 
                     ExitCode, 
                     threads[x]);
            }
            CloseHandle(threads[x]);
        }

        //
        // check results
        // iterate through the times, make sure the waits were within 10% 
        // (is this an appropriate tolerance?) of the expected sleep time
        //

        for ( x = 0; x < THREADNUM ; x++ ) {

            SystemTimeToFileTime(&ResultsArray[x].start, &FileTimeStart);
            SystemTimeToFileTime(&ResultsArray[x].finish, &FileTimeFinish);
            ulFileTimeStart.LowPart = FileTimeStart.dwLowDateTime;  
            ulFileTimeStart.HighPart = FileTimeStart.dwHighDateTime;
            ulFileTimeFinish.LowPart = FileTimeFinish.dwLowDateTime;  
            ulFileTimeFinish.HighPart = FileTimeFinish.dwHighDateTime;
            ulFileTimeFinish.QuadPart -= ulFileTimeStart.QuadPart;

            if (0 == x) {

                //
                // ok, how long should sleeping 0 take...
                //

                xLog(LogHandle, XLL_PASS, "sleep(0) call took:%I64u ", ulFileTimeFinish.QuadPart);
                continue;

            } else {

                ulExpectedTime = (x * 2) * 10000000;
                ulExpectedTimeFinish = (ulExpectedTime + ulExpectedTime/10);
                ulExpectedTimeStart = (ulExpectedTime - ulExpectedTime/10);

            }

            xLog(LogHandle,
                 ((ulFileTimeFinish.QuadPart < ulExpectedTimeFinish) && 
                  (ulFileTimeFinish.QuadPart > ulExpectedTimeStart))
                 ? XLL_PASS : XLL_FAIL, "thread sequence #:%d", x);

        }

        xEndVariation( LogHandle );
    }
    //
    // Scenario #2
    // IO completion scenario
    // 
    // 1.) loop:
    // 2.) start a file operation that takes increasingly long
    // 3.) SleepEx it for 5 seconds
    // 4.) check to see that the sleep terminates when the IO completes, 
    //     and that the sleep finishes when the IO takes too long
    // 5.) check return value of sleepex
    // 6.) do it again
    //
    {
        HANDLE hTestFile = 0;
        LPVOID pBuffer = 0;
        OVERLAPPED ReadOverlapped = {0};
        OVERLAPPED WriteOverlapped = {0};
        int x, y;
        DWORD RetVal;
        DWORD BytesWritten;
        WCHAR buffer[200] = {0};

        xSetFunctionName( LogHandle, "SleepEx" );
        xStartVariation( LogHandle, "Variation#2" );

        //
        // Create the file we use for the test
        //

        hTestFile = CreateFile("z:\\testfile",
                               GENERIC_READ | GENERIC_WRITE | STANDARD_RIGHTS_ALL,
                               FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_WRITE_THROUGH,
                               NULL);

        if (INVALID_HANDLE_VALUE == hTestFile) {
            xLog(LogHandle, XLL_BLOCK, "file Creation error #:%d", GetLastError());
            goto s2_end;
        }

        for (x = 1; x <= 50; x++) {

            DWORD dwBytesWritten;

            pBuffer = VirtualAlloc(NULL, x * 512 * 1024, MEM_COMMIT, PAGE_READWRITE);
            if (0 == pBuffer) {
                xLog(LogHandle, XLL_BLOCK, "memory allocation failure: %d", x * 512 * 1024);
                goto s2_end;
            }

            //
            // do a file operation
            //

            if (0 == WriteFile(hTestFile,
                               pBuffer,
                               x * 512 * 1024,
                               &dwBytesWritten,
                               &WriteOverlapped)) {
                xLog(LogHandle, XLL_FAIL, "file write error #:%d", GetLastError());
            }


#ifdef DBG
            swprintf(buffer, L"GetLastError = %u\n", GetLastError());
            OutputDebugString(buffer);
            if (GetOverlappedResult(hTestFile, &WriteOverlapped, &BytesWritten, TRUE))
                OutputDebugString(L"GetOverlappedResult(hTestFile, &WriteOverlapped, ...) = TRUE\n");
#endif

            if (0 == ReadFileEx(hTestFile,
                                pBuffer,
                                x * 512 * 1024,
                                &ReadOverlapped,
                                TestFileIOCompletionRoutine)) {
                xLog(LogHandle, XLL_FAIL, "file read error #:%d", GetLastError());
            }

#ifdef DBG
            swprintf(buffer, L"GetLastError = %u\n", GetLastError());
            OutputDebugString(buffer);
            if (GetOverlappedResult(hTestFile, &ReadOverlapped, &BytesWritten, TRUE))
                OutputDebugString(L"GetOverlappedResult(hTestFile, &ReadOverlapped, ...) = TRUE\n");
#endif

            //
            // sleep, get return value
            //

            //if (FALSE == HasOverlappedIoCompleted(&ReadOverlapped) || 
            //    FALSE == HasOverlappedIoCompleted(&WriteOverlapped)) {
            RetVal = SleepEx(10000, TRUE);
            if (WAIT_IO_COMPLETION == RetVal) {
                xLog(LogHandle, XLL_PASS, "SleepEx IO completion occured");
            } else if (0 == RetVal) {
                xLog(LogHandle, XLL_PASS, "SleepEx finished");
            } else {
                xLog(LogHandle, XLL_FAIL, "Unexpected SleepEx return value: %d", RetVal);
            }
            //} else {
            //    xLog(LogHandle, XLL_PASS, "Overlapped IO completed");
            //    }

            if (0 == VirtualFree(pBuffer, 0, MEM_RELEASE)) {
                xLog(LogHandle, XLL_BLOCK, "memory free failure: %d", x * 512 * 1024);
                goto s2_end;
            }
            pBuffer = 0;
        }
        s2_end:
        //
        // clean up
        //

#ifdef DBG
        if (GetOverlappedResult(hTestFile, &WriteOverlapped, &BytesWritten, TRUE))
            OutputDebugString(L"GetOverlappedResult(hTestFile, &WriteOverlapped, ...) = TRUE\n");
        if (GetOverlappedResult(hTestFile, &ReadOverlapped, &BytesWritten, TRUE))
            OutputDebugString(L"GetOverlappedResult(hTestFile, &ReadOverlapped, ...) = TRUE\n");
#endif

        //if (CancelIo(hTestFile))
        //    OutputDebugString(L"CancelIO = TRUE\n");

        if (hTestFile) {
            CloseHandle(hTestFile);
        }

        if (pBuffer) {
            VirtualFree(pBuffer, 0, MEM_RELEASE);
        }

        xEndVariation( LogHandle );
    }
    //
    // Scenario #3
    // APC queued to thread
    // make sure to do one with an INFINITE delay
    // 1.) create thread 
    // 2.) SleepEx it
    // 3.) throw APCs at it
    // 4.) make sure it wakes and processes
    // 5.) check return value of sleepex
    //
    //

    {
        HANDLE threads[THREADNUM] = {0};
        DWORD x;
        DWORD ThreadRetVal;
        DWORD LastError = 0;
        FILETIME FileTimeStart;
        FILETIME FileTimeFinish;
        ULARGE_INTEGER ulFileTimeStart;
        ULARGE_INTEGER ulFileTimeFinish;
        ULONGLONG ulExpectedTime;
        ULONGLONG ulExpectedTimeStart;
        ULONGLONG ulExpectedTimeFinish;
        DWORD RetVal;

        xSetFunctionName( LogHandle, "SleepEx" );
        xStartVariation( LogHandle, "Variation#3" );

        //
        // Create the threads
        //
        ZeroMemory(&ResultsArray[0], THREADNUM * (sizeof (struct RESULTSARRAY)));

        for (x = 0; x < THREADNUM; x++) {

            ThreadParams[x].bAlertable = TRUE;
            ThreadParams[x].dwMilliseconds = 60000;    // one minute
            ThreadParams[x].IoCompletionPortHandle = 0;
            ThreadParams[x].threadnum = x;
            ThreadParams[x].dwErrorCode = FALSE;
            ThreadParams[x].dwNumberOfBytesTransfered = 0;
            ThreadParams[x].NumberOfBytes = 0;
            ThreadParams[x].CompletionKey = 0;
            ThreadParams[x].CompletionStatusRetVal = 0;
            
            //
            // create the thread that will have the sleepex and io completion port
            // that will get touched by the posted completion status
            //

            threads[x] = CreateThread(NULL,
                                      65536,
                                      (LPTHREAD_START_ROUTINE)SleepExTestThread,
                                      (LPVOID)&ThreadParams[x],
                                      0,
                                      &ThreadID);
        }

        //
        // make sure they all started and have completion ports
        //

        for (x = 0; x < THREADNUM; x++) {
            if (0 == ResultsArray[x].start.wYear) {
                Sleep(0);   // yield a little
                x = 0;      // and start again
            }
        }

        //
        // post the statuses
        //

        for (x = 0; x < THREADNUM; x++) {

            //
            // wait a while, then post (we end up posting to a thread 1 time / second)
            //

            Sleep(1000);
            RetVal = QueueUserAPC((PAPCFUNC)TestAPCProc,
                                  threads[x],
                                  (ULONG_PTR)x);

            if (0 == RetVal) {
                LastError = GetLastError();
            }
        }

        //
        // check the results
        //

        WaitForMultipleObjects(THREADNUM, 
                               &threads[0],
                               TRUE,
                               200 * 1000);

        for (x = 0; x < THREADNUM; x++) {

            //
            // get time from the test thread
            //

            SystemTimeToFileTime(&ResultsArray[x].start, &FileTimeStart);
            SystemTimeToFileTime(&ResultsArray[x].finish, &FileTimeFinish);
            ulFileTimeStart.LowPart = FileTimeStart.dwLowDateTime;  
            ulFileTimeStart.HighPart = FileTimeStart.dwHighDateTime;
            ulFileTimeFinish.LowPart = FileTimeFinish.dwLowDateTime;  
            ulFileTimeFinish.HighPart = FileTimeFinish.dwHighDateTime;
            ulFileTimeFinish.QuadPart -= ulFileTimeStart.QuadPart;

            if (0 == x) {

                //
                // ok, how long should sleeping 0 take...
                //

                xLog(LogHandle, XLL_PASS, "sleep(0) call took:%I64u ", ulFileTimeFinish.QuadPart);
                continue;

            } else {

                ulExpectedTime = (x + 1) * 10000000;
                ulExpectedTimeFinish = (ulExpectedTime + ulExpectedTime/10);
                ulExpectedTimeStart = (ulExpectedTime - ulExpectedTime/10);
            }

            GetExitCodeThread(threads[x], &ThreadRetVal);
            CloseHandle(threads[x]);

            xLog(LogHandle,
                 ((ulFileTimeFinish.QuadPart < ulExpectedTimeFinish) && 
                  (ulFileTimeFinish.QuadPart > ulExpectedTimeStart) && 
                  WAIT_IO_COMPLETION == ThreadRetVal && 
                  ThreadParams[x].dwErrorCode)
                 ? XLL_PASS : XLL_FAIL, "thread sequence #:%d retval:%d", x, ThreadRetVal);
        }

        xEndVariation( LogHandle );
    }


    //
    // negative test cases
    //

//    xSetFunctionName( LogHandle, "SleepEx" );
//    xStartVariation( LogHandle, "badparam1" );
//
//    
//   
//    xLog(LogHandle,
//         FileHandle == INVALID_HANDLE_VALUE ? XLL_FAIL : XLL_PASS,
//         "... (LastError=%d)",
//         GetLastError()
//         );

    return;
}

VOID 
CALLBACK 
TestAPCProc(
  ULONG_PTR dwParam
)
/*++

Routine Description:

    test APCProc for the SleepEx() API test

Arguments:

    dwParam

Return Value:

    None

--*/
{
    
#ifdef DBG
    WCHAR dbgbuffer[100];
    swprintf(dbgbuffer, L"TestAPCProc hit: %u\n", dwParam);
    OutputDebugString(dbgbuffer);
#endif
    ThreadParams[dwParam].dwErrorCode = TRUE;
    return;
}

VOID
CALLBACK 
TestFileIOCompletionRoutine(
  DWORD dwErrorCode,
  DWORD dwNumberOfBytesTransfered,
  LPOVERLAPPED lpOverlapped
)
/*++

Routine Description:

    test TestFileIOCompletionRoutine for the SleepEx() API test

Arguments:

    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped

Return Value:

    None

--*/
{
#ifdef DBG
    WCHAR dbgbuffer[200];

    swprintf(dbgbuffer, 
             L"TestFileIOCompletionRoutine hit:\n\tErrorCode: %d\n\tdwNumberOfBytesTransfered %d\n", 
             dwErrorCode,
             dwNumberOfBytesTransfered);
    OutputDebugString(dbgbuffer);
#endif    
    return;
}

DWORD
WINAPI
SleepExTestThread(
    LPVOID lpParameter
    )
/*++

Routine Description:

    test thread for the SleepEx() API test

Arguments:

    lpParameter - pointer to struct SLEEPEXTESTTHREADPARAMS

Return Value:

    None

--*/
{
    LPSLEEPEXTESTTHREADPARAMS param;
    DWORD RetVal;
    
    param = (LPSLEEPEXTESTTHREADPARAMS)lpParameter;

    if(FALSE == param->bAlertable){

        GetSystemTime(&ResultsArray[param->threadnum].start);
        RetVal = SleepEx(param->dwMilliseconds, param->bAlertable);
        GetSystemTime(&ResultsArray[param->threadnum].finish);

    } else {
        
        //
        // APC case
        //
        
        GetSystemTime(&ResultsArray[param->threadnum].start);
        RetVal = SleepEx(param->dwMilliseconds, param->bAlertable);
        GetSystemTime(&ResultsArray[param->threadnum].finish);
        
    }
    ExitThread(RetVal);
    return(RetVal); // make compiler happy
}

VOID
WINAPI
TimeTestStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    LONG ID;

    OutputDebugString( TEXT("timetest: StartTest is called\n") );

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample.dll]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    // 

    ID = InterlockedIncrement( &ThreadID );

    xSetComponent( LogHandle, "kernel", "timetest" );

    //
    // call the tests
    //

    // this exposes some timezone problems I need to look at later
    //    test_GetTimeZoneInformationSimpleCase(LogHandle);
    
    test_CompareFileTime(LogHandle);
    test_FileTimeToLocalFileTime(LogHandle);
    test_GetTickCount(LogHandle);
    test_Sleep(LogHandle);
    test_SleepEx(LogHandle);
    test_GetTimeZoneInformation(LogHandle);

    return;

}

VOID
WINAPI
TimeTestEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    ThreadID = 0;
    OutputDebugString( TEXT("timetest: EndTest is called\n") );
}

VOID
WINAPI
test_CompareFileTime(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test the CompareFileTime() API

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

--*/
{
    FILETIME Time1 = {0,0};
    FILETIME Time2 = {0,0};
    
    //
    // positive test cases
    //
    
    xSetFunctionName( LogHandle, "CompareFileTime" );
    xStartVariation( LogHandle, "goodparam1" );
    
    //
    // time1 > time2
    //

    Time1.dwLowDateTime  = 1;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 1;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = MAX_DWORD;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = MAX_DWORD - 1;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = MAX_DWORD;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = MAX_DWORD - 1;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = MAX_DWORD;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = MAX_DWORD - 1;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 1 ? XLL_PASS : XLL_FAIL,
         "time1 > time2");

    //
    // time1 == time2
    //

    Time1.dwLowDateTime  = 1;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 1;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 1;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 1;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = MAX_DWORD;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = MAX_DWORD;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");
    
    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = MAX_DWORD;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = MAX_DWORD;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == 0 ? XLL_PASS : XLL_FAIL,
         "time1 == time2");
    
    //
    // time1 < time2
    //

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 1;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = 1;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = MAX_DWORD;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = MAX_DWORD - 1;
    Time1.dwHighDateTime = 0;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = 0;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = 0;
    Time1.dwHighDateTime = MAX_DWORD - 1;
    Time2.dwLowDateTime  = 0;
    Time2.dwHighDateTime = MAX_DWORD;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");

    Time1.dwLowDateTime  = MAX_DWORD;
    Time1.dwHighDateTime = MAX_DWORD - 1;
    Time2.dwLowDateTime  = MAX_DWORD;
    Time2.dwHighDateTime = MAX_DWORD;
    xLog(LogHandle,
         CompareFileTime( &Time1, &Time2 ) == -1 ? XLL_PASS : XLL_FAIL,
         "time1 < time2");


    xEndVariation( LogHandle );

    return;
}


VOID
WINAPI
test_GetTimeZoneInformationSimpleCase(
    HANDLE LogHandle
    )
/*++

Routine Description:

    document some strange things I found while writting test_GetTimeZoneInformation()

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

Notes:
    


--*/

{
    #undef YEARS
    #define YEARS 1
    #define START_YEAR 2002

    // time that timzone switch happen - I only tested this value, no guarentees my 
    // code works with others, though it should
    #define ROLL_HOUR 12    

    SYSTEMTIME CompareSTDdate[YEARS] = {0};
    SYSTEMTIME CompareDSTdate[YEARS] = {0};

    SYSTEMTIME SaveLocalTime = {0}, SaveSystemTime = {0};
    SYSTEMTIME TestLocalTime = {0}, TestSystemTime = {0};
    TIME_ZONE_INFORMATION SaveTimeZoneInformation = {0};
    TIME_ZONE_INFORMATION SetTestTimeZoneInformation = {0}, GetTestTimeZoneInformation = {0};

    int DSTFlag = 0;
    int TimeZone = 0;
    int YearOffset = 0;
    BOOL bUsingDST = XapipUseDaylightSavingTime();
    ULONG type, size;
    DWORD flags;
    BOOL bRetVal;
    DWORD dwRetVal;
    DWORD dwLastError;
    WCHAR wbuffer[250] = {0};
    LONG TotalBias = 0;
    LONG DayAdjust = 0;
    LONG HourAdjust = 0;

    //
    // initialize non-variable test data
    //

    SetTestTimeZoneInformation.StandardDate.wYear         = 0; 
    SetTestTimeZoneInformation.StandardDate.wMonth        = 3; 
    SetTestTimeZoneInformation.StandardDate.wDayOfWeek    = 0;  // 0-6, 0 == Sunday 
    SetTestTimeZoneInformation.StandardDate.wDay          = 1;  // which instance of day in month, 1-5
    SetTestTimeZoneInformation.StandardDate.wHour         = ROLL_HOUR; 
    SetTestTimeZoneInformation.StandardDate.wMinute       = 0; 
    SetTestTimeZoneInformation.StandardDate.wSecond       = 0; 
    SetTestTimeZoneInformation.StandardDate.wMilliseconds = 0;

    SetTestTimeZoneInformation.DaylightDate.wYear         = 0;
    SetTestTimeZoneInformation.DaylightDate.wMonth        = 10; 
    SetTestTimeZoneInformation.DaylightDate.wDayOfWeek    = 3;  // 0-6, 0 == Sunday                    
    SetTestTimeZoneInformation.DaylightDate.wDay          = 4;  // which instance of day in month, 1-5 
    SetTestTimeZoneInformation.DaylightDate.wHour         = ROLL_HOUR; 
    SetTestTimeZoneInformation.DaylightDate.wMinute       = 0; 
    SetTestTimeZoneInformation.DaylightDate.wSecond       = 0; 
    SetTestTimeZoneInformation.DaylightDate.wMilliseconds = 0;

    //
    // initialize compare data
    //

    //CompareSTDdate[0];  // 2002
    CompareSTDdate[0].wYear         = START_YEAR + 0;
    CompareSTDdate[0].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[0].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[0].wDay          = 3;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[0].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[0].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[0].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[0].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[0];  // 2002
    CompareDSTdate[0].wYear         = START_YEAR + 0;
    CompareDSTdate[0].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[0].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[0].wDay          = 23;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[0].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[0].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[0].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[0].wMilliseconds = 0;    // ignore!


    xSetFunctionName( LogHandle, "GetTimeZoneInformation" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // save surrent timezone
    // save current time
    //

    if (0xffffffff == GetTimeZoneInformation( &SaveTimeZoneInformation )) {
        xLog(LogHandle,
             XLL_BLOCK,
             "GetTimeZoneInformation failed! aborting test");
        xEndVariation( LogHandle );
        return;
    }

    GetLocalTime( &SaveLocalTime );
    GetSystemTime( &SaveSystemTime );

    //
    // for (DST enabled / DST disabled)
    // DSTFlag == 0 = disabled
    // DSTFlag == 1 = enabled
    // 

    DSTFlag = 1;

    if (ERROR_SUCCESS == XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size)) {
        if (DSTFlag) {
            flags &= ~XC_MISC_FLAG_DONT_USE_DST;
        } else {
            flags |= XC_MISC_FLAG_DONT_USE_DST;
        }

        XSetValue(XC_MISC_FLAGS, REG_DWORD, &flags, sizeof(flags));

    } else {
        xLog(LogHandle,
             XLL_BLOCK,
             "XQueryValue failed! aborting test!");
        xEndVariation( LogHandle );
        return;
    }

    //
    // set and check timezone info
    //
    TimeZone = 8;

    SetTestTimeZoneInformation.Bias = 60 * TimeZone;   // added to UTC to get current time
    swprintf(SetTestTimeZoneInformation.StandardName, L"STDTestTZName%d", TimeZone);
    SetTestTimeZoneInformation.StandardBias = 0;        // base time, no bias in most cases
    swprintf(SetTestTimeZoneInformation.DaylightName, L"DSTTestTZName%d", TimeZone);
    SetTestTimeZoneInformation.DaylightBias = -60;      // subtract 60 minutes

    bRetVal = XapipSetTimeZoneInformation(&SetTestTimeZoneInformation);
    dwLastError = GetLastError();
    if (!NT_SUCCESS(bRetVal)) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapipSetTimeZoneInformation failed. GetLastError %lu",
             dwLastError);
    } else {
        xLog(LogHandle,
             XLL_PASS,
             "XapipSetTimeZoneInformation succeeded:StandardName=%S : DaylightName=%S", 
             SetTestTimeZoneInformation.StandardName, 
             SetTestTimeZoneInformation.DaylightName);
    }

    //
    // make sure GetTimeZoneInformation() works OK
    //

    dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
    dwLastError = GetLastError();
    if (TIME_ZONE_ID_INVALID == dwRetVal) {
        xLog(LogHandle,
             XLL_FAIL,
             "GetTimeZoneInformation returned TIME_ZONE_ID_UNKNOWN. GetLastError %lu",
             dwLastError);
    } else {
        xLog(LogHandle,
             XLL_PASS,
             "GetTimeZoneInformation succeeded");
    }


    //
    // set / get / check 
    // for (this year, next year ... in 5 years)
    // yes, this is overkill, but cycles are free
    // 

    YearOffset = 0;

    //
    // for (each side of DST, and across boundary)
    // DST has a start date and an end date (April 1, October 28)
    // in the US, it starts at 2AM, it starts at other times in other parts of the world
    // the cases we'll hit:
    //
    // set time 1 second before it begins - check time (this is also the pre-switch test)
    // check GetTimeZoneInformation()
    // sleep 2 seconds
    // check time, make sure it has moved forward - check time (this is also the post-switch test)
    //
    // set time 1 second before it ends - check time (this is also the pre-switch test)
    // check GetTimeZoneInformation()
    // sleep 2 seconds
    // check time, make sure it has moved back - check time (this is also the post-switch test)
    //
    // if it is not enabled (DSTFlag == 0), make sure it has not moved
    // if it is enabled (DSTFlag == 1), make sure it not moved
    //

    //
    // go from DST -> Standard
    // get us 1 second before Standard date starts
    //

    TestLocalTime.wYear         = CompareSTDdate[YearOffset].wYear;
    TestLocalTime.wMonth        = CompareSTDdate[YearOffset].wMonth;
    TestLocalTime.wDay          = CompareSTDdate[YearOffset].wDay;
    TestLocalTime.wHour         = SetTestTimeZoneInformation.StandardDate.wHour - 1;
    TestLocalTime.wMinute       = 59;
    TestLocalTime.wSecond       = 59;
    TestLocalTime.wMilliseconds = 0;

    //
    // set the local time, sleep 2 seconds
    // we are now in DST
    // we set local time 2 times since there is a known problem in XBox with 
    //

    if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapiSetLocalTime failed setting test time info (DST->Standard)!");
    } else {
        xLog(LogHandle,
             XLL_PASS,
             "XapiSetLocalTime set test time info (DST->Standard)");
    }

    //
    // check the timezone information
    //

    dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
    dwLastError = GetLastError();

    switch (dwRetVal) {
        case TIME_ZONE_ID_INVALID:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (DST->Standard). GetLastError %lu",
                 dwLastError);
            break;

            // what should happen if there is no DST enabled?
        case TIME_ZONE_ID_UNKNOWN:
            if (DSTFlag == 0) { // no DST
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==0)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (DST->Standard:DSTFlag==1)");
            }
            break;

        case TIME_ZONE_ID_DAYLIGHT:
            if (DSTFlag == 1) { // DST enabled
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==1)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (DST->Standard:DSTFlag==0)");
            }
            break;

        default:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation - wrong result - default case hit (DST->Standard)! GetLastError %lu : dwRetVal = %lu", 
                 dwLastError, dwRetVal);
            break;
    }

    //
    // roll over
    //

    Sleep(2000);

    //
    // get the local time, we have crossed the line from DST to Standard
    // we are now in Standard
    //

    GetLocalTime(&TestLocalTime);
    GetSystemTime(&TestSystemTime);

    //
    // check the timezone information
    //

    dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
    dwLastError = GetLastError();
    switch (dwRetVal) {
        case TIME_ZONE_ID_INVALID:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (DST->Standard). GetLastError %lu",
                 dwLastError);
            break;

            // what should happen if there is no DST enabled?
        case TIME_ZONE_ID_UNKNOWN:
            if (DSTFlag == 0) { // no DST
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==0)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (DST->Standard:DSTFlag==1)");
            }
            break;

        case TIME_ZONE_ID_STANDARD:
            if (DSTFlag == 1) { // DST enabled
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==1)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (DST->Standard:DSTFlag==0)");
            }
            break;

        default:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation - wrong result - default case hit! (DST->Standard)  GetLastError %lu : dwRetVal = %lu", 
                 dwLastError, dwRetVal);
            break;
    }

    if (DSTFlag == 0) {

        //
        // should be 2 seconds forward, no bias
        //

        if ((TestLocalTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
            (TestLocalTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
            (TestLocalTime.wDay    == CompareSTDdate[YearOffset].wDay) &&
            (TestLocalTime.wHour   == CompareSTDdate[YearOffset].wHour) &&
            (TestLocalTime.wMinute == 0) &&
            (TestLocalTime.wSecond == 1)) {
            xLog(LogHandle,
                 XLL_PASS,
                 "TestLocalTime correct (DST->Standard:DSTFlag==0)");
        } else {
            xLog(LogHandle,
                 XLL_FAIL,
                 "TestLocalTime incorrect (DST->Standard:DSTFlag==0)");
            DumpSystemTime(TestLocalTime, L"TestLocalTime");
            DumpTimeZone(SetTestTimeZoneInformation);
        }

    } else {

        //
        // should be 2 seconds forward, DST bias applied (standard to DST - fall back!)
        //

        if ((TestLocalTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
            (TestLocalTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
            (TestLocalTime.wDay    == CompareSTDdate[YearOffset].wDay) &&
            ((TestLocalTime.wHour  == CompareSTDdate[YearOffset].wHour) + (SetTestTimeZoneInformation.DaylightBias / 60)) &&
            (TestLocalTime.wMinute == 0) &&
            (TestLocalTime.wSecond == 1)) {
            xLog(LogHandle,
                 XLL_PASS,
                 "TestLocalTime correct (DST->Standard:DSTFlag==1)");
        } else {
            xLog(LogHandle,
                 XLL_FAIL,
                 "TestLocalTime incorrect (DST->Standard:DSTFlag==1)");
            DumpSystemTime(TestLocalTime, L"TestLocalTime");
            DumpTimeZone(SetTestTimeZoneInformation);
        }
    }

    //
    // check the system time, we have crossed the line - system time should not change
    // rollover check - as we go to different timezones, the bias will roll us over
    // in this case, we apply the daylight bias
    //

    DayAdjust = 0;
    HourAdjust = TotalBias = (SetTestTimeZoneInformation.Bias + (DSTFlag ? (SetTestTimeZoneInformation.DaylightBias) : 0)) / 60;
    if (ROLL_HOUR + TotalBias > 23) {
        DayAdjust = 1;
        HourAdjust = TotalBias - 24;
    } else if (ROLL_HOUR + TotalBias < 0) {
        DayAdjust = -1;
        HourAdjust = 24 + TotalBias;
    }

    if ((TestSystemTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
        (TestSystemTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
        // adjust when bias rolls over
        (TestSystemTime.wDay    == CompareSTDdate[YearOffset].wDay + DayAdjust) &&
        // adjust when bias rolls over
        (TestSystemTime.wHour   == CompareSTDdate[YearOffset].wHour + HourAdjust) &&
        (TestSystemTime.wMinute == 0) &&
        (TestSystemTime.wSecond == 1)) {
        xLog(LogHandle,
             XLL_PASS,
             "TestSystemTime correct (DST->Standard)");
    } else {
        xLog(LogHandle,
             XLL_FAIL,
             "TestSystemTime incorrect (DST->Standard)");
        DumpSystemTime(TestSystemTime, L"TestSystemTime");
        DumpTimeZone(SetTestTimeZoneInformation);
    }

    //*************************************************************
    // now try Standard -> DST
    //*************************************************************

    //
    // get us 1 second before DST starts
    //

    TestLocalTime.wYear      = CompareDSTdate[YearOffset].wYear; 
    TestLocalTime.wMonth     = CompareDSTdate[YearOffset].wMonth;
    TestLocalTime.wDay       = CompareDSTdate[YearOffset].wDay;  
    TestLocalTime.wHour      = SetTestTimeZoneInformation.DaylightDate.wHour - 1;
    TestLocalTime.wMinute    = 59;
    TestLocalTime.wSecond    = 59;
    TestLocalTime.wMilliseconds = 0;

    //
    // set the local time, sleep 2 seconds
    // we are now in Standard time
    //

    if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapiSetLocalTime failed setting test time info (Standard->DST)!");
    } else {
        xLog(LogHandle,
             XLL_PASS,
             "XapiSetLocalTime set test time info (Standard->DST)");
    }

    //
    // check the timezone information
    //

    dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
    dwLastError = GetLastError();

    switch (dwRetVal) {
        case TIME_ZONE_ID_INVALID:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (Standard->DST). GetLastError %lu",
                 dwLastError);
            break;

            // what should happen if there is no DST enabled?
        case TIME_ZONE_ID_UNKNOWN:
            if (DSTFlag == 0) { // no DST
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==0)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (Standard->DST:DSTFlag==1)");
            }
            break;

        case TIME_ZONE_ID_STANDARD:
            if (DSTFlag == 1) { // DST enabled
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==1)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (Standard->DST:DSTFlag==0)");
            }
            break;

        default:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation - wrong result - default case hit (Standard->DST)!  GetLastError %lu : dwRetVal = %lu", 
                 dwLastError, dwRetVal);
            break;
    }

    //
    // roll over
    //

    Sleep(2000);

    //
    // get the local time, we have crossed the line from Standard to DST
    // we are now in DST
    //

    GetLocalTime(&TestLocalTime);
    GetSystemTime(&TestSystemTime);

    //
    // check the timezone information
    //

    dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
    dwLastError = GetLastError();
    switch (dwRetVal) {
        case TIME_ZONE_ID_INVALID:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (Standard->DST). GetLastError %lu",
                 dwLastError);
            break;

            // what should happen if there is no DST enabled?
        case TIME_ZONE_ID_UNKNOWN:
            if (DSTFlag == 0) { // no DST
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==0)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (Standard->DST:DSTFlag==1)");
            }
            break;

        case TIME_ZONE_ID_DAYLIGHT:
            if (DSTFlag == 1) { // DST enabled
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==1)");
            } else {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (Standard->DST:DSTFlag==0)");
            }
            break;

        default:
            xLog(LogHandle,
                 XLL_FAIL,
                 "GetTimeZoneInformation - wrong result - default case hit! (Standard->DST).  GetLastError %lu : dwRetVal = %lu", 
                 dwLastError, dwRetVal);
            break;
    }

    if (DSTFlag == 0) {

        //
        // should be 2 seconds forward, no bias
        //

        if ((TestLocalTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
            (TestLocalTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
            (TestLocalTime.wDay    == CompareDSTdate[YearOffset].wDay) &&
            (TestLocalTime.wHour   == CompareDSTdate[YearOffset].wHour) &&
            (TestLocalTime.wMinute == 0) &&
            (TestLocalTime.wSecond == 1)) {
            xLog(LogHandle,
                 XLL_PASS,
                 "TestLocalTime correct (Standard->DST:DSTFlag==0)");
        } else {
            xLog(LogHandle,
                 XLL_FAIL,
                 "TestLocalTime incorrect (Standard->DST:DSTFlag==0)");
            DumpSystemTime(TestLocalTime, L"TestLocalTime");
            DumpTimeZone(SetTestTimeZoneInformation);
        }

    } else {

        //
        // should be 2 seconds forward, DST bias applied (standard to DST - spring forward!)
        //

        if ((TestLocalTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
            (TestLocalTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
            (TestLocalTime.wDay    == CompareDSTdate[YearOffset].wDay) &&
            ((TestLocalTime.wHour  == CompareDSTdate[YearOffset].wHour) + (SetTestTimeZoneInformation.DaylightBias / 60)) &&
            (TestLocalTime.wMinute == 0) &&
            (TestLocalTime.wSecond == 1)) {
            xLog(LogHandle,
                 XLL_PASS,
                 "TestLocalTime correct (Standard->DST:DSTFlag==1)");
        } else {
            xLog(LogHandle,
                 XLL_FAIL,
                 "TestLocalTime incorrect (Standard->DST:DSTFlag==1)");
            DumpSystemTime(TestLocalTime, L"TestLocalTime");
            DumpTimeZone(SetTestTimeZoneInformation);
        }
    }

    //
    // check the system time, we have crossed the line - system time should not change
    // rollover check - as we go to different timezones, the bias will roll us over
    //

    DayAdjust = 0;
    HourAdjust = TotalBias = SetTestTimeZoneInformation.Bias / 60;
    if (ROLL_HOUR + TotalBias > 23) {
        DayAdjust = 1;
        HourAdjust = TotalBias - 24;
    } else if (ROLL_HOUR + TotalBias < 0) {
        DayAdjust = -1;
        HourAdjust = 24 + TotalBias;
    }


    if ((TestSystemTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
        (TestSystemTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
        // adjust when bias rolls over
        (TestSystemTime.wDay    == CompareDSTdate[YearOffset].wDay + DayAdjust) &&
        // adjust when bias rolls over
        (TestSystemTime.wHour   == CompareDSTdate[YearOffset].wHour + HourAdjust) &&
        (TestSystemTime.wMinute == 0) &&
        (TestSystemTime.wSecond == 1)) {
        xLog(LogHandle,
             XLL_PASS,
             "TestSystemTime correct (Standard->DST)");
    } else {
        xLog(LogHandle,
             XLL_FAIL,
             "TestSystemTime incorrect (Standard->DST)");
        DumpSystemTime(TestSystemTime, L"TestSystemTime");
        DumpTimeZone(SetTestTimeZoneInformation);
    }

    //
    // restore surrent timezone
    // restore current time
    //

    if (ERROR_SUCCESS == XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size)) {
        if (bUsingDST) {
            flags &= ~XC_MISC_FLAG_DONT_USE_DST;
        } else {
            flags |= XC_MISC_FLAG_DONT_USE_DST;
        }

        XSetValue(XC_MISC_FLAGS, REG_DWORD, &flags, sizeof(flags));
    }

    if (!NT_SUCCESS(XapipSetTimeZoneInformation( &SaveTimeZoneInformation ))) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapipSetTimeZoneInformation failed restoring saved time zone info!");
        DumpSystemTime(SaveTimeZoneInformation.DaylightDate, L"SaveTimeZoneInformation.DaylightDate:" );
        DumpSystemTime(SaveTimeZoneInformation.StandardDate, L"SaveTimeZoneInformation.StandardDate:" );
    }

    if (FALSE == XapiSetLocalTime( &SaveLocalTime )) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapiSetLocalTime failed restoring saved time info!");
    }

    xEndVariation( LogHandle );
    return;
}

VOID
WINAPI
test_GetTimeZoneInformation(
    HANDLE LogHandle
    )
/*++

Routine Description:

    test the GetTimeZoneInformation() API

Arguments:

    LogHandle - Handle used to call logging APIs

Return Value:

    None

Notes:
    
    save surrent timezone
    save current time
    for (DST enabled / DST disabled)
        set / get /check 
            for (each time zone(0(GMT)-23))
                XapipSetTimeZoneInformation()
                GetTimeZoneInformation()
                    set / get / check 
                        for (each side of DST, and at boundary)
                            for (this year, next year, in 5 years)
                            XapiSetLocalTime()
                            GetLocalTime()
                            GetSystemTime()
    restore surrent timezone
    restore current time

    this needs to be ported to NT and compared

--*/ 
{
    #undef YEARS
    #define YEARS 5
    #define START_YEAR 2002

    // time that timzone switch happen - I only tested this value, no guarentees my 
    // code works with others, though it should
    #define ROLL_HOUR 12    

    SYSTEMTIME CompareSTDdate[YEARS] = {0};
    SYSTEMTIME CompareDSTdate[YEARS] = {0};

    SYSTEMTIME SaveLocalTime = {0}, SaveSystemTime = {0};
    SYSTEMTIME TestLocalTime = {0}, TestSystemTime = {0};
    TIME_ZONE_INFORMATION SaveTimeZoneInformation = {0};
    TIME_ZONE_INFORMATION SetTestTimeZoneInformation = {0}, GetTestTimeZoneInformation = {0};

    int DSTFlag = 0;
    int TimeZone = 0;
    int YearOffset = 0;
    BOOL bUsingDST = XapipUseDaylightSavingTime();
    ULONG type, size;
    DWORD flags;
    BOOL bRetVal;
    DWORD dwRetVal;
    DWORD dwLastError;
    WCHAR wbuffer[250] = {0};
    LONG TotalBias = 0;
    LONG DayAdjust = 0;
    LONG HourAdjust = 0;

    //
    // initialize non-variable test data
    //

    SetTestTimeZoneInformation.StandardDate.wYear         = 0; 
    SetTestTimeZoneInformation.StandardDate.wMonth        = 3; 
    SetTestTimeZoneInformation.StandardDate.wDayOfWeek    = 0;  // 0-6, 0 == Sunday 
    SetTestTimeZoneInformation.StandardDate.wDay          = 1;  // which instance of day in month, 1-5
    SetTestTimeZoneInformation.StandardDate.wHour         = ROLL_HOUR; 
    SetTestTimeZoneInformation.StandardDate.wMinute       = 0; 
    SetTestTimeZoneInformation.StandardDate.wSecond       = 0; 
    SetTestTimeZoneInformation.StandardDate.wMilliseconds = 0;

    SetTestTimeZoneInformation.DaylightDate.wYear         = 0;
    SetTestTimeZoneInformation.DaylightDate.wMonth        = 10; 
    SetTestTimeZoneInformation.DaylightDate.wDayOfWeek    = 3;  // 0-6, 0 == Sunday                    
    SetTestTimeZoneInformation.DaylightDate.wDay          = 4;  // which instance of day in month, 1-5 
    SetTestTimeZoneInformation.DaylightDate.wHour         = ROLL_HOUR; 
    SetTestTimeZoneInformation.DaylightDate.wMinute       = 0; 
    SetTestTimeZoneInformation.DaylightDate.wSecond       = 0; 
    SetTestTimeZoneInformation.DaylightDate.wMilliseconds = 0;

    //
    // initialize compare data
    //

    //CompareSTDdate[0];  // 2002
    CompareSTDdate[0].wYear         = START_YEAR + 0;
    CompareSTDdate[0].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[0].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[0].wDay          = 3;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[0].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[0].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[0].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[0].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[0];  // 2002
    CompareDSTdate[0].wYear         = START_YEAR + 0;
    CompareDSTdate[0].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[0].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[0].wDay          = 23;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[0].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[0].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[0].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[0].wMilliseconds = 0;    // ignore!

    //CompareSTDdate[1];  // 2003
    CompareSTDdate[1].wYear         = START_YEAR + 1;
    CompareSTDdate[1].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[1].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[1].wDay          = 2;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[1].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[1].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[1].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[1].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[1];  // 2003
    CompareDSTdate[1].wYear         = START_YEAR + 1;
    CompareDSTdate[1].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[1].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[1].wDay          = 22;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[1].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[1].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[1].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[1].wMilliseconds = 0;    // ignore!

    //CompareSTDdate[2];  // 2004
    CompareSTDdate[2].wYear         = START_YEAR + 2;
    CompareSTDdate[2].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[2].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[2].wDay          = 7;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[2].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[2].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[2].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[2].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[2];  // 2004
    CompareDSTdate[2].wYear         = START_YEAR + 2;
    CompareDSTdate[2].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[2].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[2].wDay          = 27;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[2].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[2].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[2].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[2].wMilliseconds = 0;    // ignore!

    //CompareSTDdate[3];  // 2005
    CompareSTDdate[3].wYear         = START_YEAR + 3;
    CompareSTDdate[3].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[3].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[3].wDay          = 6;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[3].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[3].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[3].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[3].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[3];  // 2005
    CompareDSTdate[3].wYear         = START_YEAR + 3;
    CompareDSTdate[3].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[3].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[3].wDay          = 26;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[3].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[3].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[3].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[3].wMilliseconds = 0;    // ignore!

    //CompareSTDdate[4];  // 2006
    CompareSTDdate[4].wYear         = START_YEAR + 4;
    CompareSTDdate[4].wMonth        = SetTestTimeZoneInformation.StandardDate.wMonth;
    CompareSTDdate[4].wDayOfWeek    = 0;    // we don't compare this
    CompareSTDdate[4].wDay          = 5;    // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareSTDdate[4].wHour         = SetTestTimeZoneInformation.StandardDate.wHour;    // this is adjusted in the test
    CompareSTDdate[4].wMinute       = 0;    // this is adjusted in the test
    CompareSTDdate[4].wSecond       = 0;    // this is adjusted in the test
    CompareSTDdate[4].wMilliseconds = 0;    // ignore!
    //CompareDSTdate[4];  // 2006
    CompareDSTdate[4].wYear         = START_YEAR + 4;
    CompareDSTdate[4].wMonth        = SetTestTimeZoneInformation.DaylightDate.wMonth;
    CompareDSTdate[4].wDayOfWeek    = 0;    // we don't compare this
    CompareDSTdate[4].wDay          = 25;   // real day of month, as opposed to the scheme used by Get/SetTimeZoneInformation
    CompareDSTdate[4].wHour         = SetTestTimeZoneInformation.DaylightDate.wHour;    // this is adjusted in the test
    CompareDSTdate[4].wMinute       = 0;    // this is adjusted in the test
    CompareDSTdate[4].wSecond       = 0;    // this is adjusted in the test
    CompareDSTdate[4].wMilliseconds = 0;    // ignore!


    xSetFunctionName( LogHandle, "GetTimeZoneInformation" );
    xStartVariation( LogHandle, "goodparam1" );

    //
    // save surrent timezone
    // save current time
    //

    if (0xffffffff == GetTimeZoneInformation( &SaveTimeZoneInformation )) {
        xLog(LogHandle,
             XLL_BLOCK,
             "GetTimeZoneInformation failed! aborting test");
        xEndVariation( LogHandle );
        return;
    }

    GetLocalTime( &SaveLocalTime );
    GetSystemTime( &SaveSystemTime );

    //
    // for (DST enabled / DST disabled)
    // DSTFlag == 0 = disabled
    // DSTFlag == 1 = enabled
    // 

    for (DSTFlag = 0; DSTFlag < 2; DSTFlag++) {

        if (ERROR_SUCCESS == XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size)) {
            if (DSTFlag) {
                flags &= ~XC_MISC_FLAG_DONT_USE_DST;
            } else {
                flags |= XC_MISC_FLAG_DONT_USE_DST;
            }

            XSetValue(XC_MISC_FLAGS, REG_DWORD, &flags, sizeof(flags));

        } else {
            xLog(LogHandle,
                 XLL_BLOCK,
                 "XQueryValue failed! aborting test!");
            xEndVariation( LogHandle );
            return;
        }

        //
        // for (each time zone(0(GMT)-23))
        // TimeZone = 0 = GMT/UTC
        // 0-23 gets you around the world
        //

        for (TimeZone = -13; TimeZone <= 13; TimeZone++) {

            //
            // hack part1 - there were some problems with going through the year loop
            // they seemed to have to do with getting the time info all synced up
            // if we do the folloing steps, it works
            // there is a similar hack in the dash, but their hack is nicer than mine
            //*****************************************************************
            // go from DST -> Standard
            // get us 3 hours before Standard date starts
            //

            TestLocalTime.wYear         = CompareSTDdate[0].wYear;
            TestLocalTime.wMonth        = CompareSTDdate[0].wMonth;
            TestLocalTime.wDay          = CompareSTDdate[0].wDay;
            TestLocalTime.wHour         = SetTestTimeZoneInformation.StandardDate.wHour - 3;
            TestLocalTime.wMinute       = 0;
            TestLocalTime.wSecond       = 0;
            TestLocalTime.wMilliseconds = 0;

            if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
                xLog(LogHandle,
                     XLL_FAIL,
                     "hack2:part1:XapiSetLocalTime failed setting test time info (DST->Standard)!");
            } else {
                xLog(LogHandle,
                     XLL_PASS,
                     "hack2:part1:XapiSetLocalTime set test time info (DST->Standard)");
            }

            //
            // end hack part 1
            //*****************************************************************
            //

            //
            // set and check timezone info
            //

            SetTestTimeZoneInformation.Bias = 60 * TimeZone;   // added to UTC to get current Local time
            swprintf(SetTestTimeZoneInformation.StandardName, L"STDTestTZName%d", TimeZone);
            SetTestTimeZoneInformation.StandardBias = 0;        // base time, no bias in most cases
            swprintf(SetTestTimeZoneInformation.DaylightName, L"DSTTestTZName%d", TimeZone);
            SetTestTimeZoneInformation.DaylightBias = -60;      // subtract 60 minutes for the typical DST case

            bRetVal = XapipSetTimeZoneInformation(&SetTestTimeZoneInformation);
            dwLastError = GetLastError();
            if (!NT_SUCCESS(bRetVal)) {
                xLog(LogHandle,
                     XLL_FAIL,
                     "XapipSetTimeZoneInformation failed. GetLastError %lu",
                     dwLastError);
            } else {
                xLog(LogHandle,
                     XLL_PASS,
                     "XapipSetTimeZoneInformation succeeded:StandardName=%S : DaylightName=%S", 
                     SetTestTimeZoneInformation.StandardName, 
                     SetTestTimeZoneInformation.DaylightName);
            }

            //
            // make sure GetTimeZoneInformation() works OK
            //

            dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
            dwLastError = GetLastError();
            if (TIME_ZONE_ID_INVALID == dwRetVal) {
                xLog(LogHandle,
                     XLL_FAIL,
                     "GetTimeZoneInformation returned TIME_ZONE_ID_UNKNOWN. GetLastError %lu",
                     dwLastError);
            } else {
                xLog(LogHandle,
                     XLL_PASS,
                     "GetTimeZoneInformation succeeded");
            }

            //
            // hack part 2
            // after setting the timezone, the folowing calls seem to normalize things
            //*****************************************************************
            // set time again
            // get us 1 second before Standard date starts
            //

            if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
                xLog(LogHandle,
                     XLL_FAIL,
                     "hack2:part2:XapiSetLocalTime failed setting test time info (DST->Standard)!");
            } else {
                xLog(LogHandle,
                     XLL_PASS,
                     "hack2:part2:XapiSetLocalTime set test time info (DST->Standard)");
            }
            dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
            GetLocalTime(&TestLocalTime);
            GetSystemTime(&TestSystemTime);

            //
            // end hack part 2
            //*****************************************************************
            //

            //
            // set / get / check 
            // for (this year, next year ... in 5 years)
            // yes, this is overkill, but cycles are free
            // 

            for (YearOffset = 0; YearOffset < 5; YearOffset++) {

                //
                // for (each side of DST, and across boundary)
                // DST has a start date and an end date (April 1, October 28)
                // in the US, it starts at 2AM, it starts at other times in other parts of the world
                // the cases we'll hit:
                //
                // set time 1 second before it begins - check time (this is also the pre-switch test)
                // check GetTimeZoneInformation()
                // sleep 2 seconds
                // check time, make sure it has moved forward - check time (this is also the post-switch test)
                //
                // set time 1 second before it ends - check time (this is also the pre-switch test)
                // check GetTimeZoneInformation()
                // sleep 2 seconds
                // check time, make sure it has moved back - check time (this is also the post-switch test)
                //
                // if it is not enabled (DSTFlag == 0), make sure it has not moved
                // if it is enabled (DSTFlag == 1), make sure it not moved
                //

                //
                // go from DST -> Standard
                // get us 1 second before Standard date starts
                //

                TestLocalTime.wYear         = CompareSTDdate[YearOffset].wYear;
                TestLocalTime.wMonth        = CompareSTDdate[YearOffset].wMonth;
                TestLocalTime.wDay          = CompareSTDdate[YearOffset].wDay;
                TestLocalTime.wHour         = SetTestTimeZoneInformation.StandardDate.wHour - 1;
                TestLocalTime.wMinute       = 59;
                TestLocalTime.wSecond       = 59;
                TestLocalTime.wMilliseconds = 0;

                //
                // set the local time, sleep 2 seconds
                // we are now in DST
                // we set local time 2 times since there is a known problem in XBox with 
                //

                if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
                    xLog(LogHandle,
                         XLL_FAIL,
                         "XapiSetLocalTime failed setting test time info (DST->Standard)!");
                } else {
                    xLog(LogHandle,
                         XLL_PASS,
                         "XapiSetLocalTime set test time info (DST->Standard)");
                }

                //
                // check the timezone information
                //

                dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
                dwLastError = GetLastError();

                switch (dwRetVal) {
                    case TIME_ZONE_ID_INVALID:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (DST->Standard). GetLastError %lu",
                             dwLastError);
                        break;

                        // what should happen if there is no DST enabled?
                    case TIME_ZONE_ID_UNKNOWN:
                        if (DSTFlag == 0) { // no DST
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==0)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (DST->Standard:DSTFlag==1)");
                        }
                        break;

                    case TIME_ZONE_ID_DAYLIGHT:
                        if (DSTFlag == 1) { // DST enabled
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==1)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (DST->Standard:DSTFlag==0)");
                        }
                        break;

                    default:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation - wrong result - default case hit (DST->Standard)! GetLastError %lu : dwRetVal = %lu", 
                             dwLastError, dwRetVal);
                        break;
                }

                //
                // roll over
                //

                Sleep(2000);

                //
                // get the local time, we have crossed the line from DST to Standard
                // we are now in Standard
                //

                GetLocalTime(&TestLocalTime);
                GetSystemTime(&TestSystemTime);

                //
                // check the timezone information
                //

                dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
                dwLastError = GetLastError();
                switch (dwRetVal) {
                    case TIME_ZONE_ID_INVALID:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (DST->Standard). GetLastError %lu",
                             dwLastError);
                        break;

                        // what should happen if there is no DST enabled?
                    case TIME_ZONE_ID_UNKNOWN:
                        if (DSTFlag == 0) { // no DST
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==0)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (DST->Standard:DSTFlag==1)");
                        }
                        break;

                    case TIME_ZONE_ID_STANDARD:
                        if (DSTFlag == 1) { // DST enabled
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (DST->Standard:DSTFlag==1)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (DST->Standard:DSTFlag==0)");
                        }
                        break;

                    default:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation - wrong result - default case hit! (DST->Standard)  GetLastError %lu : dwRetVal = %lu", 
                             dwLastError, dwRetVal);
                        break;
                }

                if (DSTFlag == 0) {

                    //
                    // should be 2 seconds forward, no bias
                    //

                    if ((TestLocalTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
                        (TestLocalTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
                        (TestLocalTime.wDay    == CompareSTDdate[YearOffset].wDay) &&
                        (TestLocalTime.wHour   == CompareSTDdate[YearOffset].wHour) &&
                        (TestLocalTime.wMinute == 0) &&
                        (TestLocalTime.wSecond == 1)) {
                        xLog(LogHandle,
                             XLL_PASS,
                             "TestLocalTime correct (DST->Standard:DSTFlag==0)");
                    } else {
                        xLog(LogHandle,
                             XLL_FAIL,
                             "TestLocalTime incorrect (DST->Standard:DSTFlag==0)");
                        DumpSystemTime(TestLocalTime, L"TestLocalTime");
                        DumpTimeZone(SetTestTimeZoneInformation);
                    }

                } else {

                    //
                    // should be 2 seconds forward, DST bias applied (standard to DST - fall back!)
                    //

                    if ((TestLocalTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
                        (TestLocalTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
                        (TestLocalTime.wDay    == CompareSTDdate[YearOffset].wDay) &&
                        ((TestLocalTime.wHour  == CompareSTDdate[YearOffset].wHour) + (SetTestTimeZoneInformation.DaylightBias / 60)) &&
                        (TestLocalTime.wMinute == 0) &&
                        (TestLocalTime.wSecond == 1)) {
                        xLog(LogHandle,
                             XLL_PASS,
                             "TestLocalTime correct (DST->Standard:DSTFlag==1)");
                    } else {
                        xLog(LogHandle,
                             XLL_FAIL,
                             "TestLocalTime incorrect (DST->Standard:DSTFlag==1)");
                        DumpSystemTime(TestLocalTime, L"TestLocalTime");
                        DumpTimeZone(SetTestTimeZoneInformation);
                    }
                }

                //
                // check the system time, we have crossed the line - system time should not change
                // rollover check - as we go to different timezones, the bias will roll us over
                // in this case, we apply the daylight bias
                //

                DayAdjust = 0;
                HourAdjust = TotalBias = (SetTestTimeZoneInformation.Bias + (DSTFlag ? (SetTestTimeZoneInformation.DaylightBias) : 0)) / 60;
                if (ROLL_HOUR + TotalBias > 23) {
                    DayAdjust = 1;
                    HourAdjust = TotalBias - 24;
                } else if (ROLL_HOUR + TotalBias < 0) {
                    DayAdjust = -1;
                    HourAdjust = 24 + TotalBias;
                }

                if ((TestSystemTime.wYear   == CompareSTDdate[YearOffset].wYear) &&
                    (TestSystemTime.wMonth  == CompareSTDdate[YearOffset].wMonth) &&
                    // adjust when bias rolls over
                    (TestSystemTime.wDay    == CompareSTDdate[YearOffset].wDay + DayAdjust) &&
                    // adjust when bias rolls over
                    (TestSystemTime.wHour   == CompareSTDdate[YearOffset].wHour + HourAdjust) &&
                    (TestSystemTime.wMinute == 0) &&
                    (TestSystemTime.wSecond == 1)) {
                    xLog(LogHandle,
                         XLL_PASS,
                         "TestSystemTime correct (DST->Standard)");
                } else {
                    xLog(LogHandle,
                         XLL_FAIL,
                         "TestSystemTime incorrect (DST->Standard)");
                    DumpSystemTime(TestSystemTime, L"TestSystemTime");
                    DumpTimeZone(SetTestTimeZoneInformation);
                }

                //*************************************************************
                // now try Standard -> DST
                //*************************************************************

                //
                // get us 1 second before DST starts
                //

                TestLocalTime.wYear      = CompareDSTdate[YearOffset].wYear; 
                TestLocalTime.wMonth     = CompareDSTdate[YearOffset].wMonth;
                TestLocalTime.wDay       = CompareDSTdate[YearOffset].wDay;  
                TestLocalTime.wHour      = SetTestTimeZoneInformation.DaylightDate.wHour - 1;
                TestLocalTime.wMinute    = 59;
                TestLocalTime.wSecond    = 59;
                TestLocalTime.wMilliseconds = 0;

                //
                // set the local time, sleep 2 seconds
                // we are now in Standard time
                //

                if (FALSE == XapiSetLocalTime(&TestLocalTime)) {
                    xLog(LogHandle,
                         XLL_FAIL,
                         "XapiSetLocalTime failed setting test time info (Standard->DST)!");
                } else {
                    xLog(LogHandle,
                         XLL_PASS,
                         "XapiSetLocalTime set test time info (Standard->DST)");
                }

                //
                // check the timezone information
                //

                dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
                dwLastError = GetLastError();

                switch (dwRetVal) {
                    case TIME_ZONE_ID_INVALID:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (Standard->DST). GetLastError %lu",
                             dwLastError);
                        break;

                        // what should happen if there is no DST enabled?
                    case TIME_ZONE_ID_UNKNOWN:
                        if (DSTFlag == 0) { // no DST
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==0)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (Standard->DST:DSTFlag==1)");
                        }
                        break;

                    case TIME_ZONE_ID_STANDARD:
                        if (DSTFlag == 1) { // DST enabled
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==1)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (Standard->DST:DSTFlag==0)");
                        }
                        break;

                    default:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation - wrong result - default case hit (Standard->DST)!  GetLastError %lu : dwRetVal = %lu", 
                             dwLastError, dwRetVal);
                        break;
                }

                //
                // roll over
                //

                Sleep(2000);

                //
                // get the local time, we have crossed the line from Standard to DST
                // we are now in DST
                //

                GetLocalTime(&TestLocalTime);
                GetSystemTime(&TestSystemTime);

                //
                // check the timezone information
                //

                dwRetVal = GetTimeZoneInformation(&GetTestTimeZoneInformation);
                dwLastError = GetLastError();
                switch (dwRetVal) {
                    case TIME_ZONE_ID_INVALID:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation returned TIME_ZONE_ID_INVALID (Standard->DST). GetLastError %lu",
                             dwLastError);
                        break;

                        // what should happen if there is no DST enabled?
                    case TIME_ZONE_ID_UNKNOWN:
                        if (DSTFlag == 0) { // no DST
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==0)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_STANDARD in this case (Standard->DST:DSTFlag==1)");
                        }
                        break;

                    case TIME_ZONE_ID_DAYLIGHT:
                        if (DSTFlag == 1) { // DST enabled
                            xLog(LogHandle,
                                 XLL_PASS,
                                 "GetTimeZoneInformation succeeded (Standard->DST:DSTFlag==1)");
                        } else {
                            xLog(LogHandle,
                                 XLL_FAIL,
                                 "GetTimeZoneInformation - wrong result - expected TIME_ZONE_ID_UNKNOWN in this case (Standard->DST:DSTFlag==0)");
                        }
                        break;

                    default:
                        xLog(LogHandle,
                             XLL_FAIL,
                             "GetTimeZoneInformation - wrong result - default case hit! (Standard->DST).  GetLastError %lu : dwRetVal = %lu", 
                             dwLastError, dwRetVal);
                        break;
                }

                if (DSTFlag == 0) {

                    //
                    // should be 2 seconds forward, no bias
                    //

                    if ((TestLocalTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
                        (TestLocalTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
                        (TestLocalTime.wDay    == CompareDSTdate[YearOffset].wDay) &&
                        (TestLocalTime.wHour   == CompareDSTdate[YearOffset].wHour) &&
                        (TestLocalTime.wMinute == 0) &&
                        (TestLocalTime.wSecond == 1)) {
                        xLog(LogHandle,
                             XLL_PASS,
                             "TestLocalTime correct (Standard->DST:DSTFlag==0)");
                    } else {
                        xLog(LogHandle,
                             XLL_FAIL,
                             "TestLocalTime incorrect (Standard->DST:DSTFlag==0)");
                        DumpSystemTime(TestLocalTime, L"TestLocalTime");
                        DumpTimeZone(SetTestTimeZoneInformation);
                    }

                } else {

                    //
                    // should be 2 seconds forward, DST bias applied (standard to DST - spring forward!)
                    //

                    if ((TestLocalTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
                        (TestLocalTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
                        (TestLocalTime.wDay    == CompareDSTdate[YearOffset].wDay) &&
                        ((TestLocalTime.wHour  == CompareDSTdate[YearOffset].wHour) + (SetTestTimeZoneInformation.DaylightBias / 60)) &&
                        (TestLocalTime.wMinute == 0) &&
                        (TestLocalTime.wSecond == 1)) {
                        xLog(LogHandle,
                             XLL_PASS,
                             "TestLocalTime correct (Standard->DST:DSTFlag==1)");
                    } else {
                        xLog(LogHandle,
                             XLL_FAIL,
                             "TestLocalTime incorrect (Standard->DST:DSTFlag==1)");
                        DumpSystemTime(TestLocalTime, L"TestLocalTime");
                        DumpTimeZone(SetTestTimeZoneInformation);
                    }
                }

                //
                // check the system time, we have crossed the line - system time should not change
                // rollover check - as we go to different timezones, the bias will roll us over
                //

                DayAdjust = 0;
                HourAdjust = TotalBias = SetTestTimeZoneInformation.Bias / 60;
                if (ROLL_HOUR + TotalBias > 23) {
                    DayAdjust = 1;
                    HourAdjust = TotalBias - 24;
                } else if (ROLL_HOUR + TotalBias < 0) {
                    DayAdjust = -1;
                    HourAdjust = 24 + TotalBias;
                }


                if ((TestSystemTime.wYear   == CompareDSTdate[YearOffset].wYear) &&
                    (TestSystemTime.wMonth  == CompareDSTdate[YearOffset].wMonth) &&
                    // adjust when bias rolls over
                    (TestSystemTime.wDay    == CompareDSTdate[YearOffset].wDay + DayAdjust) &&
                    // adjust when bias rolls over
                    (TestSystemTime.wHour   == CompareDSTdate[YearOffset].wHour + HourAdjust) &&
                    (TestSystemTime.wMinute == 0) &&
                    (TestSystemTime.wSecond == 1)) {
                    xLog(LogHandle,
                         XLL_PASS,
                         "TestSystemTime correct (Standard->DST)");
                } else {
                    xLog(LogHandle,
                         XLL_FAIL,
                         "TestSystemTime incorrect (Standard->DST)");
                    DumpSystemTime(TestSystemTime, L"TestSystemTime");
                    DumpTimeZone(SetTestTimeZoneInformation);
                }

            }
        }
    }

    //
    // other interesting cases
    // GetTimeZoneInformation()
    // returns TIME_ZONE_ID_UNKNOWN The system cannot determine the current time zone. 
    // This error is also returned if you call the SetTimeZoneInformation function and 
    // supply the bias values but no transition dates.  
    //
    // check to make sure correct day of week shows up in GetLocalTime() GetSystemTime()
    //

    //
    // restore surrent timezone
    // restore current time
    //

    if (ERROR_SUCCESS == XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size)) {
        if (bUsingDST) {
            flags &= ~XC_MISC_FLAG_DONT_USE_DST;
        } else {
            flags |= XC_MISC_FLAG_DONT_USE_DST;
        }

        XSetValue(XC_MISC_FLAGS, REG_DWORD, &flags, sizeof(flags));
    }

    if (!NT_SUCCESS(XapipSetTimeZoneInformation( &SaveTimeZoneInformation ))) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapipSetTimeZoneInformation failed restoring saved time zone info!");
        DumpSystemTime(SaveTimeZoneInformation.DaylightDate, L"SaveTimeZoneInformation.DaylightDate:" );
        DumpSystemTime(SaveTimeZoneInformation.StandardDate, L"SaveTimeZoneInformation.StandardDate:" );
    }

    if (FALSE == XapiSetLocalTime( &SaveLocalTime )) {
        xLog(LogHandle,
             XLL_FAIL,
             "XapiSetLocalTime failed restoring saved time info!");
    }

    xEndVariation( LogHandle );
    return;
}

BOOL
WINAPI
EqualTime(
    HANDLE LogHandle,
    LPSYSTEMTIME pst1, 
    LPSYSTEMTIME pst2
    )
/*++

Routine Description:

    This function receives addresses of two LPSYSTEMTIME structures.
    It returns TRUE if the times are equal else it returns FALSE.

Arguments:

    LogHandle - Handle used to call logging APIs
    LPSYSTEMTIME pst1
    LPSYSTEMTIME pst2
    
Return Value:

    None

Notes:
    
    Stolen mostly from RATS akrnutil.c

--*/ 
{
    if ( pst1->wYear == pst2->wYear     &&
         pst1->wMinute == pst2->wMinute &&
         pst1->wMonth == pst2->wMonth    &&
         pst1->wDay == pst2->wDay        &&
         pst1->wHour == pst2->wHour     ) {
        xLog(LogHandle,
             XLL_PASS,
             "EqualTime: The times are as expected.");
        return (TRUE);
    }

    xLog(LogHandle,
         XLL_FAIL,
         "EqualTime(pst1): wYear %u wMonth %u Hour %u Minute %u DayOfWeek %u wDay %u",
         pst1->wYear, pst1->wMonth,
         pst1->wHour, pst1->wMinute,
         pst1->wDayOfWeek, pst1->wDay);

    xLog(LogHandle,
         XLL_FAIL,
         "EqualTime(pst2): wYear %u wMonth %u Hour %u Minute %u DayOfWeek %u wDay %u",
         pst2->wYear, pst2->wMonth,
         pst2->wHour, pst2->wMinute,
         pst2->wDayOfWeek, pst2->wDay);

    return (FALSE);
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( timetest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( timetest )
    EXPORT_TABLE_ENTRY( "StartTest", TimeTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", TimeTestEndTest )
END_EXPORT_TABLE( timetest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\DsoundDRT\util.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       util.cpp
 *  Content:    DirectSound utility functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "util.h"

/****************************************************************************
 *
 *  __MALLOC
 *
 *  Description:
 *      Allocates memory (duh).
 *
 *  Arguments:
 *      DWORD [in]: number of bytes to allocate.
 *
 *  Returns:  
 *      LPVOID: base pointer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__MALLOC"

LPVOID
__MALLOC
(
    DWORD                   dwSize
)
{

#ifdef ALLOC_ALIGNED

    static const DWORD      dwAlignment     = PAGE_SIZE;

#else // ALLOC_ALIGNED

    static const DWORD      dwAlignment     = 4;

#endif // ALLOC_ALIGNED

#ifdef ALLOC_NOCACHE

    static const DWORD      dwFlags         = PAGE_READWRITE | PAGE_NOCACHE;

#else // ALLOC_NOCACHE

    static const DWORD      dwFlags         = PAGE_READWRITE;

#endif // ALLOC_NOCACHE

#ifdef ALLOC_CONTIGUOUS

 //   return MmAllocateContiguousMemoryEx(dwSize, 0, 0xFFFFFFFF, dwAlignment, dwFlags);
	return XPhysicalAlloc( dwSize, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );

#else // ALLOC_CONTIGUOUS

    DWORD                   dwAllocSize     = dwSize;
    DWORD                   dwOffset;
    LPVOID                  pvBuffer;
    DWORD                   dwOldProtect;
    BOOL                    fProtect;

#ifdef ALLOC_GUARD_PAGE

    dwAllocSize += (PAGE_SIZE * 2) - 1;

#ifndef ALLOC_ALIGNED

    dwAllocSize += sizeof(DWORD);

#endif // ALLOC_ALIGNED

    dwAllocSize /= PAGE_SIZE;
    dwAllocSize *= PAGE_SIZE;

#endif // ALLOC_GUARD_PAGE

    if(pvBuffer = VirtualAlloc(NULL, dwAllocSize, MEM_COMMIT, dwFlags))
    {

#ifdef ALLOC_GUARD_PAGE

        fProtect = VirtualProtect((LPBYTE)pvBuffer + dwAllocSize - PAGE_SIZE, PAGE_SIZE, PAGE_NOACCESS, &dwOldProtect);
        ASSERT(fProtect);

#ifndef ALLOC_ALIGNED

        dwOffset = dwAllocSize - dwSize - PAGE_SIZE;

        pvBuffer = (LPBYTE)pvBuffer + dwOffset;

        *((LPDWORD)pvBuffer - 1) = dwOffset;

#endif // ALLOC_ALIGNED

#endif // ALLOC_GUARD_PAGE

    }

    return pvBuffer;

#endif // ALLOC_CONTIGUOUS

}


/****************************************************************************
 *
 *  __FREE
 *
 *  Description:
 *      Frees memory allocated with __MALLOC.
 *
 *  Arguments:
 *      LPVOID * [in/out]: base pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__FREE"

void
__FREE
(
    LPVOID *                ppvBuffer
)
{

    LPVOID                  pvBuffer    = *ppvBuffer;
    DWORD                   dwOffset;

    *ppvBuffer = NULL;

    if(pvBuffer)
    {

#ifdef ALLOC_CONTIGUOUS

//        MmFreeContiguousMemory(pvBuffer);
		XPhysicalFree( pvBuffer );

#else // ALLOC_CONTIGUOUS

#if defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)

        dwOffset = 0;

#else // defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)

        dwOffset = *((LPDWORD)pvBuffer - 1);

#endif // defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)
    
        VirtualFree((LPBYTE)pvBuffer - dwOffset, 0, MEM_RELEASE);

#endif // ALLOC_CONTIGUOUS

    }
}


/****************************************************************************
 *
 *  ReadXMO
 *
 *  Description:
 *      Reads data from an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ReadXMO"

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Read from the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwRead;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    SAFECLOSEHANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  WriteXMO
 *
 *  Description:
 *      Writes data to an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount written.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WriteXMO"

HRESULT
WriteXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwWritten
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Write to the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwWritten;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(&xmp, NULL));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    SAFECLOSEHANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  TransformXMO
 *
 *  Description:
 *      Passes data through a transform XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPCVOID [in]: source buffer.
 *      DWORD [in]: source buffer size.
 *      LPDWORD [out]: amount read.
 *      LPVOID [in]: destination buffer.
 *      DWORD [in]: destination buffer size.
 *      LPDWORD [out]: amount written.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TransformXMO"

HRESULT
TransformXMO
(
    XMediaObject *          pMediaObject,
    LPCVOID                 pvSource,
    DWORD                   dwSourceSize,
    LPDWORD                 pdwRead,
    LPVOID                  pvDest,
    DWORD                   dwDestSize,
    LPDWORD                 pdwWritten
)
{
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmpInput;
    XMEDIAPACKET            xmpOutput;
    HRESULT                 hr;

#ifdef TRANSFORMXMO_SINGLEBLOCK

    DWORD                   dwTotalRead     = 0;
    DWORD                   dwTotalWritten  = 0;
    DWORD                   dwRead;
    DWORD                   dwWritten;

#endif // TRANSFORMXMO_SINGLEBLOCK

    //
    // Verify that the XMO is synchronous
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    if(SUCCEEDED(hr))
    {
		ASSERT(!(xmi.dwFlags & (XMO_STREAMF_INPUT_ASYNC | XMO_STREAMF_OUTPUT_ASYNC)));
    }

    //
    // Call the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmpInput, sizeof(xmpInput));
        ZeroMemory(&xmpOutput, sizeof(xmpOutput));

#ifdef TRANSFORMXMO_SINGLEBLOCK

        while(SUCCEEDED(hr) && (dwTotalRead < dwSourceSize) && (dwTotalWritten < dwDestSize))
        {
            xmpInput.pvBuffer = (LPBYTE)pvSource + dwTotalRead;
            xmpInput.dwMaxSize = min(xmi.dwInputSize, dwSourceSize - dwTotalRead);
            xmpInput.pdwCompletedSize = &dwRead;

            xmpOutput.pvBuffer = (LPBYTE)pvDest + dwTotalWritten;
            xmpOutput.dwMaxSize = min(xmi.dwOutputSize, dwDestSize - dwTotalWritten);
            xmpOutput.pdwCompletedSize = &dwWritten;

#else // TRANSFORMXMO_SINGLEBLOCK

            xmpInput.pvBuffer = (LPVOID)pvSource;
            xmpInput.dwMaxSize = dwSourceSize,
            xmpInput.pdwCompletedSize = pdwRead;

            xmpOutput.pvBuffer = pvDest;
            xmpOutput.dwMaxSize = dwDestSize,
            xmpOutput.pdwCompletedSize = pdwWritten;

#endif // TRANSFORMXMO_SINGLEBLOCK

            hr = ValidateResult(pMediaObject->Process(&xmpInput, &xmpOutput));

#ifdef TRANSFORMXMO_SINGLEBLOCK

            dwTotalRead += dwRead;
            dwTotalWritten += dwWritten;
        }

#endif // TRANSFORMXMO_SINGLEBLOCK

    }

#ifdef TRANSFORMXMO_SINGLEBLOCK

    if(SUCCEEDED(hr) && pdwRead)
    {
        *pdwRead = dwTotalRead;
    }

    if(SUCCEEDED(hr) && pdwWritten)
    {
        *pdwWritten = dwTotalWritten;
    }

#endif // TRANSFORMXMO_SINGLEBLOCK

    return hr;
}


/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads a wave file into an XMO object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX [out]: wave file format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadWaveFile"

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    DbgPrint("Loading %s\n", pszFileName);

    return ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, 
													 ppMediaObject));
}


/****************************************************************************
 *
 *  GetStdWaveFile
 *
 *  Description:
 *      Gets a standard wave file path.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *      LPSTR [out]: file path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetStdWaveFile"

void
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPSTR                   pszFileName
)
{
    static const LPCSTR     pszParent       = "t:\\media\\audio\\";
    static const LPCSTR     pszPcm          = "pcm\\";
    static const LPCSTR     pszAdpcm        = "adpcm\\";
    static const LPCSTR     pszFileTemplate = "%uk%ub%ls.wav";
    static const LPCSTR     pszMono         = "m";
    static const LPCSTR     pszStereo       = "s";

    strcpy(pszFileName, pszParent);

    switch(pwfxFormat->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            strcat(pszFileName, pszPcm);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            strcat(pszFileName, pszAdpcm);
            break;

        default:
            ASSERT(!"Unsupported format");
            break;
    }

    sprintf(pszFileName + strlen(pszFileName), pszFileTemplate, pwfxFormat->nSamplesPerSec / 1000, pwfxFormat->wBitsPerSample, (1 == pwfxFormat->nChannels) ? pszMono : pszStereo);
}


/****************************************************************************
 *
 *  GetStdWaveFile
 *
 *  Description:
 *      Gets a standard wave file path.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      LPSTR: file path.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetStdWaveFile"

LPCSTR
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat
)
{
    static CHAR             szFileName[MAX_PATH];

    GetStdWaveFile(pwfxFormat, szFileName);

    return szFileName;
}


/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads a standard wave file into an XMO object.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadWaveFile"

HRESULT
LoadStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    return LoadWaveFile(GetStdWaveFile(pwfxFormat), NULL, ppMediaObject);
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a DirectSound buffer from a file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: output mixbin mask.
 *      DWORD [in]: submix output buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *      LPCWAVEFORMATEX [out]: buffer format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateBufferFromFile"

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPDSMIXBINS				pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes, 
    LPCWAVEFORMATEX *       ppwfxFormat
)
{
    LPXFILEMEDIAOBJECT      pWaveFile       = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    LPCWAVEFORMATEX         pwfxFormat;
    DWORD                   dwBufferBytes;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    HRESULT                 hr;
	WIN32_FIND_DATA			findData;
	HANDLE					hFind;
	DWORD					dwFreeSGEs;

	// Max valid buffer size
	hr = GetFreeSGEs(&dwFreeSGEs);

	// Get the file size
	if(SUCCEEDED(hr))
	{
		// Determine the file size
		hFind = FindFirstFile(pszFile, &findData);
		hr = (hFind == INVALID_HANDLE_VALUE) ? E_FAIL : S_OK;
	}

	// Is the buffer too large to load?
	if(SUCCEEDED(hr))
	{
		FindClose(hFind);
		if((findData.nFileSizeHigh > 0) || 
		   (findData.nFileSizeLow > (dwFreeSGEs * 4096)))
		{
			hr = E_FAIL;
		}
	}
	
    //
    // Open the wave file
    //

	if(SUCCEEDED(hr))
		hr = ValidateResult(LoadWaveFile(pszFile, &pwfxFormat, &pWaveFile));

    if(SUCCEEDED(hr) && ppwfxFormat)
    {
        *ppwfxFormat = pwfxFormat;
    }

    //
    // Get the file size.  If it's longer than the size passed to us, trim
    // it down.
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pWaveFile->GetLength(&dwBufferBytes));
    }

    if(SUCCEEDED(hr))
    {
        hr = ClampBufferSize(&dwBufferBytes,pwfxFormat->nBlockAlign);
    }

    if(SUCCEEDED(hr) && pdwBufferBytes)
    {
        if(!*pdwBufferBytes || (*pdwBufferBytes > dwBufferBytes))
        {
            *pdwBufferBytes = dwBufferBytes;
        }
        else
        {
            dwBufferBytes = *pdwBufferBytes;
			dwBufferBytes -= dwBufferBytes % pwfxFormat->nBlockAlign;
        }
    }

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = dwFlags;
        dsbd.dwBufferBytes = dwBufferBytes;
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
        dsbd.lpMixBins = pMixBins;
        
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    //
    // Read wave data into the buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, dwBufferBytes, &pvLock, &dsbd.dwBufferBytes, NULL, NULL, 0));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(ReadXMO(pWaveFile, pvLock, dwBufferBytes, &dsbd.dwBufferBytes));
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(dsbd.dwBufferBytes == dwBufferBytes);

        hr = ValidateResult(pBuffer->Unlock(pvLock, dwBufferBytes, NULL, 0));
    }

    //
    // Set the output buffer
    //

    if(SUCCEEDED(hr) && pOutputBuffer)
    {
        hr = ValidateResult(pBuffer->SetOutputBuffer(pOutputBuffer));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        ASSERT(ppBuffer);

        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  CreateStdBuffer
 *
 *  Description:
 *      Creates a sound buffer from one of the standard wave files.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      DWORD [in]: output mixbin mask.
 *      DWORD [in]: submix output buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdBuffer"

HRESULT
CreateStdBuffer
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat, 
    LPDSMIXBINS				pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes
)
{
    return ValidateResult(CreateBufferFromFile(GetStdWaveFile(pwfxFormat), 
											   dwFlags, pMixBins, pOutputBuffer, 
											   ppBuffer, pdwBufferBytes, NULL));
}


/****************************************************************************
 *
 *  WaitBuffer
 *
 *  Description:
 *      Waits for a buffer's status to change.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      BOOL [in]: TRUE to wait for the buffer to start playing, FALSE to
 *                 wait for it to stop.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaitBuffer"

HRESULT
WaitBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fPlaying
)
{
    const DWORD             dwStatusMask    = DSBSTATUS_PLAYING;
    const DWORD             dwWaitStatus    = fPlaying ? DSBSTATUS_PLAYING : 0;
    DWORD                   dwStatus;
    HRESULT                 hr;

    while(TRUE)
    {
        hr = ValidateResult(pBuffer->GetStatus(&dwStatus));

        if(FAILED(hr))
        {
            break;
        }

        if((dwStatus & dwStatusMask) == dwWaitStatus)
        {
            DbgPrint("Buffer %s", fPlaying ? "playing\n" : "stopped\n");
            break;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  PlayBuffer
 *
 *  Description:
 *      Plays a sound buffer.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      BOOL [in]: TRUE to loop.
 *      DWORD [in]: delay, in milliseconds.
 *      BOOL [in]: TRUE to wait for buffer to start playing.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayBuffer"

HRESULT
PlayBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fLoop,
    DWORD                   dwDelay,
    BOOL                    fWait
)
{
    REFERENCE_TIME          rtTimeStamp = -(LONGLONG)dwDelay * 10000;
    HRESULT                 hr;

    if(dwDelay)
    {
        DbgPrint("Playing buffer (delayed %lu ms)\n", dwDelay);
    }
    else
    {
        DbgPrint("Playing buffer\n");
        fWait = FALSE;
    }

    hr = ValidateResult(pBuffer->PlayEx(rtTimeStamp, fLoop ? DSBPLAY_LOOPING : 0));

    if(SUCCEEDED(hr) && fWait)
    {
        hr = WaitBuffer(pBuffer, TRUE);
    }

    return hr;
}


/****************************************************************************
 *
 *  PlayBufferToCompletion
 *
 *  Description:
 *      Plays a sound buffer to completion.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      DWORD [in]: delay, in milliseconds.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayBufferToCompletion"

HRESULT
PlayBufferToCompletion
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fLoop,
    DWORD                   dwDelay
)
{
    HRESULT                 hr;

    hr = PlayBuffer(pBuffer, fLoop, dwDelay, TRUE);

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    return hr;
}


/****************************************************************************
 *
 *  StopBuffer
 *
 *  Description:
 *      Stops a sound buffer.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      DWORD [in]: flags.
 *      DWORD [in]: delay, in milliseconds.
 *      BOOL [in]: TRUE to reset cursor position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "StopBuffer"

HRESULT
StopBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags,
    DWORD                   dwDelay,
    BOOL                    fReset,
    BOOL                    fWait
)
{
    REFERENCE_TIME          rtTimeStamp = -(LONGLONG)dwDelay * 10000;
    HRESULT                 hr;

    if(fReset)
    {
        fWait = TRUE;
    }

    if(dwDelay)
    {
        DbgPrint("Stopping buffer (delayed %lu ms)\n", dwDelay);
    }
    else
    {
        DbgPrint("Stopping buffer\n");
    }

    hr = ValidateResult(pBuffer->StopEx(rtTimeStamp, dwFlags));

    if(SUCCEEDED(hr) && fWait)
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    if(SUCCEEDED(hr) && fReset)
    {
        DbgPrint("Resetting cursor position\n");
        
        hr = ValidateResult(pBuffer->SetCurrentPosition(0));
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStreamFromFile
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      LPFNXMEDIAOBJECTCALLBACK [in]: stream callback function.
 *      LPVOID [in]: stream callback context.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPDWORD [out]: audio data buffer size, in bytes.
 *      LPDWORD [in/out]: packet count.
 *      LPCWAVEFORMATEX [out]: stream format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStreamFromFile"

HRESULT
CreateStreamFromFile
(
    LPCSTR                      pszFile, 
    DWORD                       dwFlags, 
    LPDSMIXBINS					pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount,
    LPCWAVEFORMATEX *           ppwfxFormat
)
{
    LPXFILEMEDIAOBJECT          pWaveFile       = NULL;
    LPDIRECTSOUNDSTREAM         pStream         = NULL;
    LPVOID                      pvAudioData     = NULL;
    LPCWAVEFORMATEX             pwfxFormat;
    DWORD                       dwDuration;
    DWORD                       dwPacketCount;
    DSSTREAMDESC                dssd;
    HRESULT                     hr;

    //
    // Open the wave file
    //

    hr = ValidateResult(LoadWaveFile(pszFile, &pwfxFormat, &pWaveFile));

    if(SUCCEEDED(hr) && ppwfxFormat)
    {
        *ppwfxFormat = pwfxFormat;
    }

    //
    // Block-align the packet size
    //

    if(SUCCEEDED(hr))
    {
        *pdwPacketSize /= pwfxFormat->nBlockAlign;
        *pdwPacketSize *= pwfxFormat->nBlockAlign;
    }

    //
    // Get the file size
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pWaveFile->GetLength(&dwDuration));
    }

    //
    // Allocate a buffer for the wave data
    //

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvAudioData, BYTE, dwDuration);
    }

    //
    // Read wave data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(ReadXMO(pWaveFile, pvAudioData, dwDuration, &dwDuration));
    }

    //
    // Calculate the number of packets required
    //

    if(SUCCEEDED(hr))
    {
        dwPacketCount = dwDuration / *pdwPacketSize;
    }

    if(SUCCEEDED(hr) && pdwPacketCount)
    {
        if(!*pdwPacketCount || (*pdwPacketCount > dwPacketCount))
        {
            *pdwPacketCount = dwPacketCount;
        }
        else
        {
            dwPacketCount = *pdwPacketCount;
        }
    }

    //
    // Create the stream
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.dwFlags = dwFlags;
        dssd.dwMaxAttachedPackets = dwPacketCount;
        dssd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
        dssd.lpfnCallback = pfnCallback;
        dssd.lpvContext = pvContext;
        dssd.lpMixBins = pMixBins;

        hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));
    }

    //
    // Set the output buffer
    //

    if(SUCCEEDED(hr) && pOutputBuffer)
    {
        hr = ValidateResult(pStream->SetOutputBuffer(pOutputBuffer));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
        *ppvAudioData = pvAudioData;
        *pdwAudioDataSize = dwDuration;
    }
    else
    {
        RELEASE(pStream);
        FREE(pvAudioData);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStdStream
 *
 *  Description:
 *      Creates a DirectSound stream based on a standard wave file.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      LPCWAVEFORMATEX [in]: stream format.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      LPFNXMEDIAOBJECTCALLBACK [in]: stream callback function.
 *      LPVOID [in]: stream callback context.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPDWORD [out]: audio data buffer size, in bytes.
 *      LPDWORD [in/out]: packet count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdStream"

HRESULT
CreateStdStream
(
    DWORD                       dwFlags, 
    LPCWAVEFORMATEX             pwfxFormat,
    LPDSMIXBINS					pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
)
{
    return ValidateResult(CreateStreamFromFile(GetStdWaveFile(pwfxFormat), dwFlags, pMixBins, pdwPacketSize, pfnCallback, pvContext, pOutputBuffer, ppStream, ppvAudioData, pdwAudioDataSize, pdwPacketCount));
}


/****************************************************************************
 *
 *  CreateQueuedStreamFromFile
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file and submits
 *      data to it.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      HANDLE [in]: completion event for the last packet.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPCWAVEFORMATEX [out]: stream format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateQueuedStreamFromFile"

HRESULT
CreateQueuedStreamFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPDSMIXBINS				pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData,
    LPCWAVEFORMATEX *       ppwfxFormat
)
{
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    LPVOID                  pvAudioData     = NULL;
    DWORD                   dwAudioDataSize = 0;
    DWORD                   dwPacketCount   = 0;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Create the stream
    //

    hr = ValidateResult(CreateStreamFromFile(pszFile, dwFlags, pMixBins, pdwPacketSize, NULL, NULL, pOutputBuffer, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount, ppwfxFormat));

    //
    // Pause the stream
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PauseStream(pStream));
    }

    //
    // Submit all packets
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = *pdwPacketSize;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount - 1); i++)
        {
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        xmp.dwMaxSize = dwAudioDataSize - (*pdwPacketSize * (dwPacketCount - 1));
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pStream->Process(&xmp, NULL));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Discontinuity());
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
        *ppvAudioData = pvAudioData;
    }
    else
    {
        RELEASE(pStream);
        FREE(pvAudioData);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStdQueuedStream
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file and submits
 *      data to it.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      LPCWAVEFORMATEX [in]: stream format.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      HANDLE [in]: completion event for the last packet.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdQueuedStream"

HRESULT
CreateStdQueuedStream
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat,
    LPDSMIXBINS				pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
)
{
    return CreateQueuedStreamFromFile(GetStdWaveFile(pwfxFormat), dwFlags, pMixBins, pdwPacketSize, hCompletionEvent, pOutputBuffer, ppStream, ppvAudioData);
}


/****************************************************************************
 *
 *  ResubmitPacketCallback
 *
 *  Description:
 *      Stream callback function that automatically resubmits the completed
 *      packet.
 *
 *  Arguments:
 *      LPVOID [in]: stream context.
 *      LPVOID [in]: packet context.
 *      DWORD [in]: packet status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "ResubmitPacketCallback"

void CALLBACK
ResubmitPacketCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
)
{
    LPXMEDIAOBJECT *        ppStream    = (LPXMEDIAOBJECT *)pvStreamContext;
    LPXMEDIAPACKET          pPacket     = (LPXMEDIAPACKET)pvPacketContext;
    
    if(XMEDIAPACKET_STATUS_SUCCESS == dwStatus)
    {
        (*ppStream)->Process(pPacket, NULL);
    }
}


/****************************************************************************
 *
 *  GenerateTone
 *
 *  Description:
 *      Generates a PCM sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone"

void
GenerateTone
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwBitsPerSample,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
)
{
    switch(dwBitsPerSample)
    {
        case 8:
            GenerateTone8(pvBuffer, dwBufferBytes, dwPlaybackFrequency, dwChannelCount, dwToneFrequency);
            break;

        case 16:
            GenerateTone16(pvBuffer, dwBufferBytes, dwPlaybackFrequency, dwChannelCount, dwToneFrequency);
            break;

        default:
            ASSERT(!"Unexpected bit resolution");
            break;
    }            
}


/****************************************************************************
 *
 *  GenerateTone8
 *
 *  Description:
 *      Generates an 8-bit sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone8"

void
GenerateTone8
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
)
{
    static const double         dbScale     = 255.0;
    static const unsigned char  bHalfScale  = 128;
    const double                dbPhase     = 2.0 * D3DX_PI / (double)dwPlaybackFrequency;
    const double                dbFactor    = dbPhase * (double)dwToneFrequency;
    unsigned char *             pbBuffer    = (unsigned char *)pvBuffer;
    unsigned char               bSample;
    DWORD                       i, z;

    for(i = 0; i < dwBufferBytes / dwChannelCount; i++)
    {
        bSample = (unsigned char)(sin((double)i * dbFactor) * dbScale) + bHalfScale;

        for(z = 0; z < dwChannelCount; z++)
        {
            *pbBuffer++ = bSample;
        }
    }
}


/****************************************************************************
 *
 *  GenerateTone16
 *
 *  Description:
 *      Generates a 16-bit sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: channel count.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone16"

void
GenerateTone16
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferBytes,
    DWORD                   dwPlaybackFrequency,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency
)
{
    static const double     dbScale     = 32767.0;
    const double            dbPhase     = 2.0 * D3DX_PI / (double)dwPlaybackFrequency;
    const double            dbFactor    = dbPhase * (double)dwToneFrequency;
    short *                 pnBuffer    = (short *)pvBuffer;
    short                   nSample;
    DWORD                   i, z;

    for(i = 0; i < dwBufferBytes / (2 * dwChannelCount); i++)
    {
        nSample = (short)(sin((double)i * dbFactor) * dbScale);

        for(z = 0; z < dwChannelCount; z++)
        {
            *pnBuffer++ = nSample;
        }
    }
}


/****************************************************************************
 *
 *  GenerateNoise
 *
 *  Description:
 *      Generates white noise.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateNoise"

void
GenerateNoise
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize
)
{
    DWORD                   i;

    for(i = 0; i < dwBufferSize; i++)
    {
        *(((LPBYTE)pvBuffer) + i) = (BYTE)(rand() % 0xFF);
    }
}


/****************************************************************************
 *
 *  MakeMultiChannel
 *
 *  Description:
 *      Converts a mono or stereo PCM sound file to multichannel.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source format.
 *      LPWAVEFORMATEX [out]: destination format.  Only nChannels needs to
 *                            be filled in.
 *      LPCVOID [in]: source data.
 *      DWORD [in]: source data size, in bytes.
 *      LPVOID * [out]: destination data.
 *      LPDWORD [out]: destinatin data size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MakeMultiChannel"

HRESULT
MakeMultiChannel
(
    LPCWAVEFORMATEX         pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPCVOID                 pvSrcData,
    DWORD                   dwSrcDataSize,
    LPVOID *                ppvDstData,
    LPDWORD                 pdwDstDataSize
)
{
    LPVOID                  pvDstData;
    DWORD                   dwDstDataSize;
    DWORD                   dwMultiplier;
    DWORD                   dwSampleCount;
    HRESULT                 hr;
    DWORD                   a, b;

    ASSERT(WAVE_FORMAT_PCM == pwfxSrc->wFormatTag);
    ASSERT(!(pwfxDst->nChannels % pwfxSrc->nChannels));
    
    XAudioCreatePcmFormat(pwfxDst->nChannels, pwfxSrc->nSamplesPerSec, pwfxSrc->wBitsPerSample, pwfxDst);

    dwMultiplier = pwfxDst->nChannels / pwfxSrc->nChannels;
    dwSampleCount = dwSrcDataSize / pwfxSrc->nBlockAlign;
    dwDstDataSize = dwSampleCount * pwfxDst->nBlockAlign;

    hr = MALLOC(pvDstData, BYTE, dwDstDataSize);

    if(SUCCEEDED(hr))
    {
        *ppvDstData = pvDstData;
        *pdwDstDataSize = dwDstDataSize;

        while(dwSampleCount--)
        {
            for(a = 0; a < dwMultiplier; a++)
            {
                for(b = 0; b < pwfxSrc->nChannels; b++)
                {
                    if(8 == pwfxSrc->wBitsPerSample)
                    {
                        *(unsigned char *)pvDstData = *(const unsigned char *)pvSrcData;
                        pvDstData = (unsigned char *)pvDstData + 1;
                    }
                    else
                    {
                        *(short *)pvDstData = *(const short *)pvSrcData;
                        pvDstData = (short *)pvDstData + 1;
                    }
                }
            }

            pvSrcData = (LPBYTE)pvSrcData + pwfxSrc->nBlockAlign;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  PauseStream
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      LPDIRECTSOUNDSTREAM [in]: stream.
 *      BOOL [in]: TRUE to pause, FALSE to resume.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PauseStream"

HRESULT
PauseStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPause
)
{
    HRESULT                 hr;

    if(fPause)
    {
        DbgPrint("Pausing stream\n");
    }
    else
    {
        DbgPrint("Resuming paused stream\n");
    }

    hr = ValidateResult(pStream->Pause(fPause));

    return hr;
}


/****************************************************************************
 *
 *  CreateFormat
 *
 *  Description:
 *      Creates a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      LPCWAVEFORMATEX: format data.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateFormat"

LPCWAVEFORMATEX
CreateFormat
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
)
{
    static UNIWAVEFORMAT    wfx;
    
    switch(dwFormatTag)
    {
        case WAVE_FORMAT_PCM:
            XAudioCreatePcmFormat((WORD)dwChannels, dwSamplesPerSec, (WORD)dwBitsPerSample, &wfx.wfx);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            XAudioCreateAdpcmFormat((WORD)dwChannels, dwSamplesPerSec, &wfx.wfAdpcm);
            break;

        default:
            ASSERT(!"Unexpected format tag");
            break;
    }

    return &wfx.wfx;
}


/****************************************************************************
 *
 *  GetFreeSGEs
 *
 *  Description:
 *      Gets the count of free buffer SGEs.
 *
 *  Arguments:
 *      LPDWORD [out]: SGE count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetFreeSGEs"

HRESULT
GetFreeSGEs
(
    LPDWORD                 pdwFreeSGEs
)
{
    DSCAPS                  dsc;
    HRESULT                 hr;
    
    hr = ValidateResult(GetDirectSoundCaps(&dsc));

    if(SUCCEEDED(hr))
    {
        *pdwFreeSGEs = dsc.dwFreeBufferSGEs-1;
    }

    return hr;
}


/****************************************************************************
 *
 *  ClampBufferSize
 *
 *  Description:
 *      Clamps a buffer size so that it will fit in the available SGEs.
 *
 *  Arguments:
 *      LPDWORD [in/out]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ClampBufferSize"

HRESULT
ClampBufferSize
(
    LPDWORD                 pdwBufferBytes,
	DWORD					dwBlockAlign
)
{

#ifdef ALLOC_CONTIGUOUS

    static const DWORD      dwSGESlop           = 0;

#else ALLOC_CONTIGUOUS

    static const DWORD      dwSGESlop           = 1;

#endif // ALLOC_CONTIGUOUS

    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferBytes;
    HRESULT                 hr;
    
    hr = ValidateResult(GetFreeSGEs(&dwFreeSGEs));

    if(SUCCEEDED(hr) && (dwFreeSGEs <= dwSGESlop))
    {
        DbgPrint("Out of SGEs\n");
        hr = DSERR_OUTOFMEMORY;
    }
        
    if(SUCCEEDED(hr))
    {
        dwMaxBufferBytes = (dwFreeSGEs - dwSGESlop) * 4096;
		dwMaxBufferBytes -= dwMaxBufferBytes % dwBlockAlign;

        if(*pdwBufferBytes > dwMaxBufferBytes)
        {
            DbgPrint("Clamping buffer size from %lu to %lu\n", *pdwBufferBytes, dwMaxBufferBytes);
            *pdwBufferBytes = dwMaxBufferBytes;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  LoadEffectsImage
 *
 *  Description:
 *      Loads the default effects image.
 *
 *  Arguments:
 *      LPDIRECTSOUND [in]: DirectSound object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadEffectsImage"

HRESULT
LoadEffectsImage
(
    LPDIRECTSOUND           pDirectSound,
    LPCSTR                  pszImageFile
)
{
    LPVOID                  pvImageData     = NULL;
    HRESULT                 hr              = DS_OK;
    HANDLE                  hImageFile;
    DWORD                   dwImageSize;
    DSEFFECTIMAGELOC        EffectLoc;

    if(INVALID_HANDLE_VALUE == (hImageFile = CreateFile(pszImageFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)))
    {
        DbgPrint("Can't find image file\n");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        dwImageSize = GetFileSize(hImageFile, NULL);

        hr = MALLOC(pvImageData, BYTE, dwImageSize);
    }

    if(SUCCEEDED(hr))
    {
        if(!ReadFile(hImageFile, pvImageData, dwImageSize, &dwImageSize, NULL))
        {
            DbgPrint("Can't read image file\n");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
      //  EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
      //  EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;
		EffectLoc.dwI3DL2ReverbIndex = 0;
		EffectLoc.dwCrosstalkIndex = 0;
        
        hr = ValidateResult(pDirectSound->DownloadEffectsImage(pvImageData, dwImageSize, &EffectLoc, NULL));
    }

    SAFECLOSEHANDLE(hImageFile);
    FREE(pvImageData);

    return hr;
}


/****************************************************************************
 *
 *  GetDirectSoundCaps
 *
 *  Description:
 *      Gets DirectSound capabilities.
 *
 *  Arguments:
 *      LPDSCAPS [out]: caps.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetDirectSoundCaps"

HRESULT
GetDirectSoundCaps
(
    LPDSCAPS                pdsc
)
{
    LPDIRECTSOUND           pDirectSound    = NULL;
    HRESULT                 hr;

    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
        hr = ValidateResult(pDirectSound->GetCaps(pdsc));

    RELEASE(pDirectSound);

    return hr;
}


/****************************************************************************
 *
 *  CreateToneBuffer
 *
 *  Description:
 *      Creates a simple sine-wave tone buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: buffer size in bytes, or 0 for default.
 *      DWORD [in]: buffer mixbin assignments.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateToneBuffer"

HRESULT
CreateToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwBufferBytes,
    LPDSMIXBINS				pMixBins,
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    const LPCWAVEFORMATEX   pwfxFormat      = CreateFormat(WAVE_FORMAT_PCM, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLock;
    HRESULT                 hr;

    ASSERT(!(dwSamplesPerSec % dwToneFrequency));

    //
    // Create the buffer
    //

    if(!dwBufferBytes)
    {
        dwBufferBytes = (dwSamplesPerSec / dwToneFrequency) * pwfxFormat->nBlockAlign;
    }

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
    dsbd.dwBufferBytes = dwBufferBytes;
    dsbd.lpMixBins = pMixBins;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));

    //
    // Write the audio data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, dwBufferBytes, &pvLock, &dwLock, NULL, NULL, 0));
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvLock, dwLock, dwSamplesPerSec, dwBitsPerSample, dwChannelCount, dwToneFrequency);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Unlock(pvLock, dwLock, NULL, 0));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateImpulseBuffer
 *
 *  Description:
 *      Creates a simple sine-wave impulse buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: lead-in length, in seconds.
 *      DWORD [in]: rolloff length, in seconds.
 *      DWORD [in]: buffer mixbin assignments.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateImpulseBuffer"

HRESULT
CreateImpulseBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwLeadIn,
    DWORD                   dwRollOff,
    LPDSMIXBINS				pMixBins,
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    const LPCWAVEFORMATEX   pwfxFormat      = CreateFormat(WAVE_FORMAT_PCM, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DWORD                   dwImpulseLength;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLock;
    HRESULT                 hr;

    ASSERT(!(dwSamplesPerSec % dwToneFrequency));
    ASSERT(!((dwSamplesPerSec / dwToneFrequency) % 2));

    //
    // Convert the lead-in, rolloff and impulse length to bytes
    //

    dwLeadIn *= pwfxFormat->nAvgBytesPerSec;
    dwRollOff *= pwfxFormat->nAvgBytesPerSec;
    dwImpulseLength = (dwSamplesPerSec / dwToneFrequency / 2) * pwfxFormat->nBlockAlign;

    //
    // Create the buffer
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
    dsbd.dwBufferBytes = dwLeadIn + dwImpulseLength + dwRollOff;
    dsbd.lpMixBins = pMixBins;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));

    //
    // Write the audio data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(dwLeadIn, dwImpulseLength, &pvLock, &dwLock, NULL, NULL, 0));
        // hr = ValidateResult(pBuffer->Lock(0, dsbd.dwBufferBytes, &pvLock, &dwLock, NULL, NULL, 0));
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvLock, dwLock, dwSamplesPerSec, dwBitsPerSample, dwChannelCount, dwToneFrequency);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Unlock(pvLock, dwLock, NULL, 0));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSound\DirectSoundCreate\DirectSoundCreate.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreate.h
 *  Content:    DirectSoundCreate utility exports
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/11/01    danrose Created to test DirectSoundCreate
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>

HRESULT DirectSoundCreate( LPDIRECTSOUND* ppDirectSound );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\DsoundDRT\util.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       util.h
 *  Content:    DirectSound utility functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __UTIL_H__
#define __UTIL_H__

#include <xtl.h>
#include <macros.h>
#include <xdbg.h>
#include <stdio.h>

#define ALLOC_CONTIGUOUS

//
// Data structures
//

typedef union {
    WAVEFORMATEX        wfx;
    XBOXADPCMWAVEFORMAT wfAdpcm;
} UNIWAVEFORMAT;

//
// Return code validation
//

__inline HRESULT ValidateResult(HRESULT hr)
{
    if(FAILED(hr))
    {
 //       __asm int 3;
    }

    return hr;
}

__inline HRESULT ValidatePtr(LPVOID pv)
{
    if(!pv)
    {
//        __asm int 3;
    }

    return pv ? DS_OK : DSERR_OUTOFMEMORY;
}

//
// Memory management
//

LPVOID __MALLOC(DWORD dwSize);
VOID __FREE(LPVOID *ppv);

#define MALLOC(p, type, count) \
    ValidatePtr((p) = (type *)__MALLOC(sizeof(type) * (count)))

#define FREE(p) \
    __FREE((LPVOID *)&(p))

#ifdef __cplusplus

//
// XMO helpers
//

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
);

HRESULT
WriteXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwWritten
);

HRESULT
TransformXMO
(
    XMediaObject *          pMediaObject,
    LPCVOID                 pvSource,
    DWORD                   dwSourceSize,
    LPDWORD                 pdwRead,
    LPVOID                  pvDest,
    DWORD                   dwDestSize,
    LPDWORD                 pdwWritten
);

//
// Wave files
//

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
);

void
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPSTR                   pszFileName
);

LPCSTR
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat
);

HRESULT
LoadStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject **     ppMediaObject
);

//
// Buffer creation
//

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPDSMIXBINS             pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes  = NULL, 
    LPCWAVEFORMATEX *       ppwfxFormat     = NULL
);

HRESULT
CreateStdBuffer
(
	DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat, 
    LPDSMIXBINS				pMixBins,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer        = NULL, 
    LPDWORD                 pdwBufferBytes  = NULL
);

HRESULT
CreateToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwBufferBytes,
    LPDSMIXBINS				pMixBins,
    LPDIRECTSOUNDBUFFER *   ppBuffer
);

HRESULT
CreateImpulseBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPeriodDivisor,
    DWORD                   dwLeadIn,
    DWORD                   dwRollOff,
    LPDSMIXBINS				pMixBins,
    LPDIRECTSOUNDBUFFER *   ppBuffer
);

//
// Buffer utilities
//

HRESULT
WaitBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fPlaying
);

HRESULT
PlayBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fLoop       = FALSE,
    DWORD                   dwDelay     = 0,
    BOOL                    fWait       = FALSE
);

HRESULT
PlayBufferToCompletion
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fLoop       = FALSE,
    DWORD                   dwDelay     = 0
);

HRESULT
StopBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags     = 0,
    DWORD                   dwDelay     = 0,
    BOOL                    fReset      = FALSE,
    BOOL                    fWait       = FALSE
);

HRESULT
GetFreeSGEs
(
    LPDWORD                 pdwFreeSGEs
);

HRESULT
ClampBufferSize
(
    LPDWORD                 pdwBufferBytes,
	DWORD					dwBlockAlign
);

//
// Stream creation
//

HRESULT
CreateStreamFromFile
(
    LPCSTR                      pszFile, 
    DWORD                       dwFlags, 
    LPDSMIXBINS					pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount,
    LPCWAVEFORMATEX *           ppwfxFormat             = NULL
);

HRESULT
CreateStdStream
(
    DWORD                       dwFlags, 
    LPCWAVEFORMATEX             pwfxFormat,
    LPDSMIXBINS					pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
);

HRESULT
CreateQueuedStreamFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
	LPDSMIXBINS				pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData,
    LPCWAVEFORMATEX *       ppwfxFormat             = NULL
);

HRESULT
CreateStdQueuedStream
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat,
    LPDSMIXBINS				pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
);

//
// Stream utilties
//

HRESULT
PauseStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPause  = TRUE
);

void CALLBACK
ResubmitPacketCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
);

//
// Generic helpers
//

void
GenerateTone
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwBitsPerSample,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateTone8
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateTone16
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateNoise
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize
);

HRESULT
MakeMultiChannel
(
    LPCWAVEFORMATEX         pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPCVOID                 pvSrcData,
    DWORD                   dwSrcDataSize,
    LPVOID *                ppvDstData,
    LPDWORD                 pdwDstDataSize
);

LPCWAVEFORMATEX
CreateFormat
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
);

HRESULT
LoadEffectsImage
(
    LPDIRECTSOUND           pDirectSound,
    LPCSTR                  pszImageFile
);

HRESULT
GetDirectSoundCaps
(
    LPDSCAPS                pdsc
);

#endif // __cplusplus

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSoundBuffer\DirectSoundCreateBuffer\DirectSoundCreateBuffer.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreateBuffer.cpp
 *  Content:    DirectSoundCreateBuffer tests
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/11/01    danrose Created to test Xbox DirectSoundCreateBuffer
 *	10/12/01	robheit	Modified MaxBuffersPCMTest to use only 252 buffers
 *	01/02/02	robheit	Modified all tests to query the device for number
 *						of free voices instead of using hard coded values.
 *
 ****************************************************************************/

#include "DirectSoundCreateBuffer.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  CalculateXboxAdpcmAlignment
 *
 *  Description:
 *      calculates the proper ADPCM alignment
 *
 *  Arguments:
 *      nChannels - the number of channels
 *      nSamplesPerBlock - the number of samples per block
 *
 *  Returns:  
 *      the calculated alignment
 *
 ****************************************************************************/

WORD CalculateXboxAdpcmAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock
)
{
    const WORD              nEncodedSampleBits  = nChannels * 4;
    const WORD              nHeaderBytes        = nChannels * 4;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer
 *
 *  Description:
 *      Create and Return a DirectSoundBuffer Interface Pointer
 *
 *  Arguments:
 *      ppDirectSoundBuffer - a double pointer to a DSBuffer Interface
 *      pWfx - a pointer to WAVEFORMATEX, can be NULL
 *		pDsbd - a pointer to a DSBUFFERDESC, can be NULL
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer( LPDIRECTSOUNDBUFFER* ppBuffer, LPWAVEFORMATEX pWfx, LPDSBUFFERDESC pDsbd )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER pBuffer			= NULL;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;

	//
	// check the incoming pointers
	//

	CHECKPTR( ppBuffer );

	//
	// Zero out the DSound buffer description
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;

	//
	// Set the Waveformat of the DSBUFFERDESC to my wfx or the passed in wfx
	//

	dsbd.lpwfxFormat = NULL == pWfx ? &wfx : pWfx;

	//
	// call DirectSoundCreateBuffer
	//

	CHECKRUN( DirectSoundCreateBuffer( NULL == pDsbd ? &dsbd : pDsbd, ppBuffer ) );

	//
	// return the Hresult
	//

	return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_ParameterTest
 *
 *  Description:
 *      Validate different parameter combinations for  DirectSoundCreateBuffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_ParameterTest( void )
{
	HRESULT				hr					= S_OK;
	LPDIRECTSOUNDBUFFER pBuffer				= NULL;
	DSBUFFERDESC		dsbd                = { 0 };
	XBOXADPCMWAVEFORMAT	wfx;

	//
	// Create a test matrix of DSBUFFERDESC sub components
	//

	DWORD				adwSize[]			= { sizeof( DSBUFFERDESC ) };
	DWORD				adwFlags[]			= { 0,
												DSBCAPS_CTRL3D, 
												DSBCAPS_CTRLFREQUENCY,
												DSBCAPS_CTRLVOLUME,
												DSBCAPS_CTRLPOSITIONNOTIFY,
												DSBCAPS_MIXIN,
												DSBCAPS_LOCDEFER,
												DSBCAPS_FXIN };
	DWORD				adwMixBins[]		= { 0,
												DSMIXBIN_FRONT_LEFT,
												DSMIXBIN_FRONT_RIGHT,        
												DSMIXBIN_FRONT_CENTER,     
												DSMIXBIN_LOW_FREQUENCY,
												DSMIXBIN_BACK_LEFT,        
												DSMIXBIN_BACK_RIGHT,      
												DSMIXBIN_XTLK_FRONT_LEFT,   
												DSMIXBIN_XTLK_FRONT_RIGHT,
												DSMIXBIN_XTLK_BACK_LEFT,   
												DSMIXBIN_XTLK_BACK_RIGHT, 
												DSMIXBIN_I3DL2,     
												DSMIXBIN_FXSEND_0,
												DSMIXBIN_FXSEND_1,
												DSMIXBIN_FXSEND_2,
												DSMIXBIN_FXSEND_3,
												DSMIXBIN_FXSEND_4,
												DSMIXBIN_FXSEND_5,
												DSMIXBIN_FXSEND_6,
												DSMIXBIN_FXSEND_7,
												DSMIXBIN_FXSEND_8,
												DSMIXBIN_FXSEND_9,
												DSMIXBIN_FXSEND_10,
												DSMIXBIN_FXSEND_11,
												DSMIXBIN_FXSEND_12,
												DSMIXBIN_FXSEND_13,
												DSMIXBIN_FXSEND_14,
												DSMIXBIN_FXSEND_15,
												DSMIXBIN_FXSEND_16,
												DSMIXBIN_FXSEND_17,
												DSMIXBIN_FXSEND_18,
												DSMIXBIN_FXSEND_19 };
	DWORD				adwSecs[]			= { 1, 2 };
												
	//
	// Create a test matrix of WAVEFORMATEX sub components
	//

    WORD				awFormatTag[]		= { WAVE_FORMAT_PCM,
												WAVE_FORMAT_XBOX_ADPCM };             
    WORD				anChannels[]		= { 1, 
												2 }; 
	DWORD				anSamplesPerSec[]   = { 8000, 
												11025,
												16000,
												22050,
												32000,
												44100,
												48000 };
	WORD				awBitsPerSample[]	= { 8,
												16 };
             

	
	//
	// Cycle through each param, try to create a DirectSoundBuffer
	//

	for ( DWORD a = 0; a < NUMELEMS( adwSize ); a++ )
	{
		for ( DWORD b = 0; b < NUMELEMS( adwFlags ); b++ )
		{
			for ( DWORD c = 0; c < NUMELEMS( anSamplesPerSec ); c++ )
			{
				for ( DWORD d = 0; d < NUMELEMS( adwMixBins ); d++ )
				{
					for ( DWORD e = 0; e < NUMELEMS( awFormatTag ); e++ )
					{
						for ( DWORD f = 0; f < NUMELEMS( anChannels ); f++ )
						{
							for ( DWORD g = 0; g < NUMELEMS( adwSecs ); g++ )
							{
								for ( DWORD h = 0; h < NUMELEMS( awBitsPerSample ); h++ )
								{	
									//
									// fill in wfx
									//

									wfx.wfx.wFormatTag = awFormatTag[e];                                      
									wfx.wfx.nSamplesPerSec = anSamplesPerSec[c];  

									//
									// special case out certain values
									//

									//
									// 3d buffers must be mono
									//

								    if ( ( adwFlags[b] & DSBCAPS_CTRL3D ) )
									{
										wfx.wfx.nChannels = 1;
									}
									else
									{
										wfx.wfx.nChannels = anChannels[f];
									}

									//
									// ADPCM buffers have set following data
									//

									if ( WAVE_FORMAT_XBOX_ADPCM == wfx.wfx.wFormatTag )
									{
										wfx.wfx.cbSize = 2;
										wfx.wfx.wBitsPerSample = 4;
										wfx.wSamplesPerBlock = 64;
										wfx.wfx.nBlockAlign = CalculateXboxAdpcmAlignment( wfx.wfx.nChannels, wfx.wSamplesPerBlock );
									}  
									else
									{
										wfx.wfx.cbSize = 0;
										wfx.wfx.wBitsPerSample = awBitsPerSample[h];
										wfx.wSamplesPerBlock = 0;
										wfx.wfx.nBlockAlign = wfx.wfx.nChannels * wfx.wfx.wBitsPerSample / 8;
									}

									//
									// Finish filling in WFX
									//

									wfx.wfx.nAvgBytesPerSec = wfx.wfx.nSamplesPerSec * wfx.wfx.nBlockAlign;    
								

									//
									// fill in DSBD
									//

									dsbd.dwSize = adwSize[a];
									dsbd.dwFlags = adwFlags[b];
									
									//
									// update the dsbd for special cases
									//

									//
									// mixin buffers do not have buffers or formats
									//

									if ( dsbd.dwFlags & DSBCAPS_MIXIN ) 
									{
										dsbd.lpwfxFormat = NULL;
										dsbd.dwBufferBytes = 0;
									}
									else
									{
										dsbd.lpwfxFormat = (LPWAVEFORMATEX) &wfx;
										dsbd.dwBufferBytes = wfx.wfx.nAvgBytesPerSec * adwSecs[g];
									}

									//
									// make sure to enable 3d if necessary
									//

									if ( DSBCAPS_CTRL3D == adwFlags[b] )
									{
										if ( rand() % 2 )
										{
											DirectSoundUseFullHRTF();
										}
										else
										{
											DirectSoundUseLightHRTF();
										}
									}

									//
									// actualy make the call
									//

								    EXECUTE( DirectSoundCreateBuffer( &pBuffer, NULL, &dsbd ) );
								    RELEASE( pBuffer );
								}
							}
						}
					}
				}
			}
		}
	}

	//
	// Release the buffer
	//

	RELEASE( pBuffer );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_BasicTest
 *
 *  Description:
 *      Basic Test for DirectSoundCreateBuffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_BasicTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER pBuffer			= NULL;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nSamplesPerSec = 48000;

	//
	// Set the Waveformat of the DSBUFFERDESC to my wfx
	//

	dsbd.lpwfxFormat = &wfx;

	//
	// Call DirectSoundCreateBuffer and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateBuffer( &dsbd, &pBuffer ) );
	CHECKALLOC( pBuffer );

	//
	// Destroy the DirectSoundBuffer
	//

	RELEASE( pBuffer );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_BasicADPCMTest
 *
 *  Description:
 *      Basic Test for DirectSoundCreateBuffer init using ADPCM
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_BasicADPCMTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER pBuffer			= NULL;
	DSBUFFERDESC		dsbd;
	XBOXADPCMWAVEFORMAT	wfx;

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( XBOXADPCMWAVEFORMAT ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
	wfx.wfx.nChannels = 1;
	wfx.wfx.wBitsPerSample = 4;
	wfx.wfx.nBlockAlign = 36;
	wfx.wfx.cbSize = 2;
	wfx.wfx.nSamplesPerSec = 48000;
	wfx.wSamplesPerBlock = 64;

	//
	// Set the Waveformat of the DSBUFFERDESC to my wfx
	//

	dsbd.lpwfxFormat = (LPWAVEFORMATEX) &wfx;

	//
	// Call DirectSoundCreateBuffer and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateBuffer( &dsbd, &pBuffer ) );
	CHECKALLOC( pBuffer );

	//
	// Destroy the DirectSoundBuffer
	//

	RELEASE( pBuffer );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_OutOfMemoryTest
 *
 *  Description:
 *      Out of memory Test for DirectSoundCreateBuffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_OutOfMemoryTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER pBuffer			= NULL;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;

	//
	// Memory variables
	//

    LPBYTE              pData           = NULL;
	DWORD				i				= 0;
	DWORD				dwPageSize      = 0x1000;
    MEMORYSTATUS        memStatus;

	//
	// Zero out the Memory Status Structure
	//

    ZeroMemory( &memStatus, sizeof( MEMORYSTATUS ) );

	//
	// Get the Memory available on the Xbox
	//

    GlobalMemoryStatus( &memStatus );

	//
	// Keep trying to allocate available memory. If the allocation
	// fails, subtract 4K bytes (1 page) of memory and try again
	//

	do {

		pData = new BYTE[ memStatus.dwAvailPhys - dwPageSize * i++ ];
	
	} while ( NULL == pData );

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;

	//
	// Set the Waveformat ofthe DSBUFFERDESC to my wfx
	//

	dsbd.lpwfxFormat = &wfx;

	//
	// Call DirectSoundCreateBuffer and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateBuffer( &dsbd, &pBuffer ) );
	
	//
	// If the large allocation was successful, the DsoundBuffer pointer
	// was null, and The call to DirectSoundCreate returned
	// the correct error code, then set hr to S_OK
	//

	if ( E_OUTOFMEMORY == hr && NULL == pBuffer && NULL != pData )
	{
		hr = S_OK;
	} else {
		hr = E_FAIL;
	}

	//
	// Destroy the DirectSoundBuffer, clena up memory
	//

	delete [] pData;
	RELEASE( pBuffer );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_NullDSBDTest
 *
 *  Description:
 *      Test DirectSoundCreateBuffer with a null DSBD
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_NullDSBDTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER pBuffer			= NULL;

	//
	// Call DirectSoundCreateBuffer and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateBuffer( NULL, &pBuffer ) );
	CHECKALLOC( pBuffer );

	//
	// Destroy the DirectSoundBuffer
	//

	RELEASE( pBuffer );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_NullBufferTest
 *
 *  Description:
 *      Test DirectSoundCreateBuffer with a null Buffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_NullBufferTest( void )
{
    HRESULT             hr              = S_OK;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;

	//
	// Set the Waveformat ofthe DSBUFFERDESC to my wfx
	//

	dsbd.lpwfxFormat = &wfx;
	//
	// Call DirectSoundCreateBuffer and check return code
	//

	CHECKRUN( DirectSoundCreateBuffer( &dsbd, NULL ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_MaxBuffersPCMTest
 *
 *  Description:
 *      Test DirectSoundCreateBuffer and make sure the max number of PCM
 *      buffers can be created
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_MaxBuffersPCMTest( void )
{
    HRESULT             hr              = S_OK;
	DWORD				i				= 0;
	LPDIRECTSOUND8		pDSound			= NULL;
	LPDIRECTSOUNDBUFFER apBuffers[256];
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	DSCAPS				dsCaps;

	// zero out the structs
	ZeroMemory( &apBuffers, sizeof( apBuffers ) );
	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	// setup the WaveFormatEx
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
    wfx.nChannels		= 1;  
    wfx.nSamplesPerSec	= 16000;     
    wfx.nBlockAlign		= 1;   
    wfx.wBitsPerSample	= 8;   
    wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize			= 0;

	// Setup the DSBufferDesc
	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.lpwfxFormat = &wfx;

	// Determine the max number of buffers available
	DirectSoundCreate(NULL, &pDSound, NULL);
	pDSound->GetCaps(&dsCaps);

	// Create the Max number of PCM buffers
	for ( i = 0; SUCCEEDED( hr ) && i < dsCaps.dwFree2DBuffers; ++i)
	{
		CHECKRUN( DirectSoundCreateBuffer( &dsbd, &apBuffers[i] ) );
		CHECKALLOC( apBuffers[i] );
	}

	// Release all the buffers
	for ( i = 0; i < dsCaps.dwFree2DBuffers; i++ )
	{
		RELEASE( apBuffers[i] );
	}

	// Release the DSound object
	pDSound->Release();

    // Return the Hresult
    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_ThreadFunction
 *
 *  Description:
 *      thread function for multiple thread test
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		0 on failure
 *      a pointer cast to a DWORD representing the Dsound Buffer Interface
 *
 ****************************************************************************/

DWORD WINAPI DirectSoundCreateBuffer_ThreadFunction( LPVOID lpParameter )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDBUFFER	pBuffer			= NULL;
	DWORD				dwRet			= 0;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;  
    wfx.nSamplesPerSec = 32000;     
    wfx.nBlockAlign = 1;   
    wfx.wBitsPerSample = 8;   
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize = 0;

	//
	// Set up the DSBUFFERDESC
	//

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.lpwfxFormat = &wfx;

	//
	// Call DirectSoundCreateBuffer and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateBuffer( &dsbd, &pBuffer ) );	

	//
	// Cast the pointer value
	//

	dwRet = (DWORD) pBuffer;

	//
	// Release the IDirectSoundBuffer pointer
	// 

    RELEASE( pBuffer );

	//
	// return the pBuffer pointer value
	//

	return dwRet;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_MaxBuffersPCMThreadedTest
 *
 *  Description:
 *      Test DirectSoundCreateBuffer and make sure the max number of PCM
 *      buffers can be created on multiple threads
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateBuffer_MaxBuffersPCMThreadedTest( void )
{
    HRESULT             hr              = S_OK;
	DWORD				i				= 0;
	DWORD				dwWait			= 0;
	DWORD				adwRetVals[256];
	HANDLE				ahThreads[256];
	LPDIRECTSOUND8		pDSound			= NULL;
	DSCAPS				dsCaps;
	DWORD				nCount;

	// Determine the max free buffers
	DirectSoundCreate(NULL, &pDSound, NULL);
	pDSound->GetCaps(&dsCaps);

	//
	// Zero out the thread array and the ret vals
	//

	ZeroMemory( &ahThreads, sizeof( ahThreads ) );
	ZeroMemory( &adwRetVals, sizeof( adwRetVals ) );

	//
	// cycle through the thread array, and create new threads
	// error out as appropriate
	//

	for ( i = 0; i < dsCaps.dwFree2DBuffers && SUCCEEDED( hr ); i++ )
	{
		ahThreads[i] = CreateThread( NULL, 0, &DirectSoundCreateBuffer_ThreadFunction, NULL, 0, NULL );

		if ( NULL == ahThreads[i] )
			hr = E_OUTOFMEMORY;
	}

	//
	// Wait on the threads to finish, check return code
	//

	for(i=0; i<dsCaps.dwFree2DBuffers && SUCCEEDED(hr); i += nCount)
	{
		nCount = MAXIMUM_WAIT_OBJECTS;
		if(nCount > (dsCaps.dwFree2DBuffers - i))
			nCount = (dsCaps.dwFree2DBuffers - i);
		dwWait = WaitForMultipleObjects(nCount, ahThreads + i, TRUE, INFINITE);

		if ( WAIT_FAILED == dwWait )
			hr = E_FAIL;
	}

	//
	// Get the return values from the threads
	//

	for ( i = 0; i < dsCaps.dwFree2DBuffers && SUCCEEDED( hr ); i++ )
	{
		if ( ! GetExitCodeThread( ahThreads[i], adwRetVals + i ) )
			hr = E_FAIL;
	}

	//
	// Check the values and make sure they are equal and no zero
	//

	for ( i = 0; i < dsCaps.dwFree2DBuffers && SUCCEEDED( hr ); i++ )
	{
		FAIL_ON_CONDITION( adwRetVals[i] == 0 );
	}

	//
	// close each thread handle
	//

	for ( i = 0; i < dsCaps.dwFree2DBuffers; i++ )
	{
		if ( NULL != ahThreads[i] )
			CloseHandle( ahThreads[i] );
	}

	//
	// Return the Hresult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_StartTest
 *
 *  Description:
 *		The Harness Entry into the DirectSoundCreateBuffer tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreateBuffer_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

	//
	// Test DirectSoundCreateBuffer in an out of memory situation
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "OutOfMemory" );
    EXECUTE( DirectSoundCreateBuffer_OutOfMemoryTest() );

	//
	// Test DirectSoundCreateBuffer with a NULL DSBD
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "NullDSBD" );
    EXECUTE( DirectSoundCreateBuffer_NullDSBDTest() );

	//
	// Test DirectSoundCreateBuffer with a NULL DirectSoundBuffer
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "NullBuffer" );
    EXECUTE( DirectSoundCreateBuffer_NullBufferTest() );

	//
	// Test DirectSoundCreateBuffer using all combinations of valid parameters 
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "Parameter" );
	EXECUTE( DirectSoundCreateBuffer_ParameterTest() );

#endif // CODE_COVERAGE

    //
    // Test DirectSoundCreateBuffer in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "Basic" );
    EXECUTE( DirectSoundCreateBuffer_BasicTest() );

	//
	// Test DirectSoundCreateBuffer using basic ADPCM
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "BasicADPCM" );
    EXECUTE( DirectSoundCreateBuffer_BasicADPCMTest() );

	//
	// Test DirectSoundCreateBuffer using the max number of PCM buffers
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "MaxBuffersPCM" );
    EXECUTE( DirectSoundCreateBuffer_MaxBuffersPCMTest() );

	//
	// Test DirectSoundCreateBuffer using the max number of PCM buffers on multiple threads
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "MaxBuffersPCMThreaded" );
    EXECUTE( DirectSoundCreateBuffer_MaxBuffersPCMThreadedTest() );

	
}

/****************************************************************************
 *
 *  DirectSoundCreateBuffer_EndTest
 *
 *  Description:
 *		The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreateBuffer_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    DirectSoundCreateBuffer_StartTest( NULL );
    DirectSoundCreateBuffer_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DirectSoundCreateBuffer )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DirectSoundCreateBuffer )
    EXPORT_TABLE_ENTRY( "StartTest", DirectSoundCreateBuffer_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DirectSoundCreateBuffer_EndTest )
END_EXPORT_TABLE( DirectSoundCreateBuffer )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSoundBuffer\DirectSoundCreateBuffer\DirectSoundCreateBuffer.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreateBuffer.h
 *  Content:    DirectSoundCreateBuffer utility exports
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/11/01    danrose Created to test DirectSoundCreateBuffer
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>

HRESULT DirectSoundCreateBuffer( LPDIRECTSOUNDBUFFER* ppBuffer, LPWAVEFORMATEX pWfx = NULL, LPDSBUFFERDESC pDsbd = NULL );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSoundStream\DirectSoundCreateStream\DirectSoundCreateStream.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreateStream.h
 *  Content:    DirectSoundCreateStream utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/ 9/01    danrose Created to test Xbox DirectSoundCreateStream
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSound\DirectSoundCreate\DirectSoundCreate.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreate.cpp
 *  Content:    DirectSoundCreate tests
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/01    danrose Created to test Xbox DirectSoundCreate
 *
 ****************************************************************************/

#include "DirectSoundCreate.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Create and return a DirectSound Interface pointer
 *
 *  Arguments:
 *      ppDirectSound - a double pointer to the DirectSound Interface
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate( LPDIRECTSOUND* ppDirectSound )
{
	HRESULT				hr				= S_OK;

	//
	// check the inputted param
	//

	CHECKPTR( ppDirectSound );

	//
	// Call DirectSoundCreate
	//

	CHECKRUN( DirectSoundCreate( NULL, ppDirectSound, NULL ) );

	return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_BasicTest
 *
 *  Description:
 *      Create and Destroy an IDirectSound using DirectSoundCreate
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_BasicTest( void )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;

	//
	// Call DirectSoundCreate, check the return code
	// And the returned pointer
	//

    CHECKRUN( DirectSoundCreate( NULL, &pDSound, NULL ) );
    CHECKALLOC( pDSound );

	//
	// Release the IDirectSound pointer
	// 

    RELEASE( pDSound );

	//
	// Return the Hresult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_MultipleTest
 *
 *  Description:
 *      Create and Destroy an IDirectSound using DirectSoundCreate
 *      multiple times and verify that the interface pointer values
 *      returned are Identical
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_MultipleTest( void )
{
    HRESULT             hr              = S_OK;
    DWORD               i               = 0;
    LPDIRECTSOUND       apDSound[2];

	//
	// Zero out the Array of IDirectSound pointers
	//

    ZeroMemory( &apDSound, sizeof( apDSound ) );

	//
	// Cycle through all the DSound pointers and Call DirectSoundCreate
	// on them and verify the return code and Allocation
	//

    for ( i = 0; i < 2; i++ )
    {
        CHECKRUN( DirectSoundCreate( NULL, &apDSound[i], NULL ) );
        CHECKALLOC( apDSound[i] );
    }

	//
	// Verify that the interface pointers are the same
	//

    FAIL_ON_CONDITION( apDSound[0] != apDSound[1] );

	//
	// cycle through the pointers and release them
	//

    for ( i = 0; i < 2; i++ )
    {
        RELEASE( apDSound[i] );
    }

	// return the HResult 

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_OutOfMemoryTest
 *
 *  Description:
 *		Test DirectSoundCreate in Low memory situation
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_OutOfMemoryTest( void )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;
    LPBYTE              pData           = NULL;
	DWORD				i				= 0;
	DWORD				dwPageSize      = 0x1000;
    MEMORYSTATUS        memStatus;

	//
	// Zero out the Memory Status Structure
	//

    ZeroMemory( &memStatus, sizeof( MEMORYSTATUS ) );

	//
	// Get the Memory available on the Xbox
	//

    GlobalMemoryStatus( &memStatus );

	//
	// Keep trying to allocate available memory. If the allocation
	// fails, subtract 4K bytes (1 page) of memory and try again
	//

	do {

		pData = new BYTE[ memStatus.dwAvailPhys - dwPageSize * i++ ];
	
	} while ( NULL == pData );

	//
	// At this point No memory is left for Dsound. This call
	// should fail with hr = E_OUTOFMEMORY
	//

    CHECKRUN( DirectSoundCreate( NULL, &pDSound, NULL ) );

	//
	// If the large allocation was successful, the Dsound pointer
	// was null, and The call to DirectSoundCreate returned
	// the correct error code, then set hr to S_OK
	//

	if ( E_OUTOFMEMORY == hr && NULL == pDSound && NULL != pData )
	{
		hr = S_OK;
	} else {
		hr = E_FAIL;
	}

	//
	// Clean up the allocated memory and release DSound
	//

    delete [] pData;
    RELEASE( pDSound );

	//
	// return the HResult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_GuidNullTest
 *
 *  Description:
 *		Call DirectSoundCreate with a guid pointer that is valid but whose
 *		underlying GUID is GUID_NULL
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_GuidNullTest( void )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;
	GUID				guidId;

	//
	// Zero out the guid ID to make it GUID_NULL
	//

	ZeroMemory( &guidId, sizeof( GUID ) );

	//
	// Call DirectSoundCreate with the LPGUID, check the return hr
	// and check to make sure the DirectSound Pointer was allocated
	//

    CHECKRUN( DirectSoundCreate( &guidId, &pDSound, NULL ) );
    CHECKALLOC( pDSound );

	//
	// release Dsound
	//

    RELEASE( pDSound );

	//
	// Return the HResult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_NotGuidNullTest
 *
 *  Description:
 *		Call DirectSoundCreate with a GUID that is not GUID_NULL
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_NotGuidNullTest( void )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;
	GUID				guidId			= { 0x00000000, 
											0x0000, 
											0x0000, 
											{ 0x00, 
											  0x0, 
											  0x0, 
											  0x00, 
											  0x0, 
											  0x00, 
											  0x00, 
											  0x01 } };

	//
	// Call DirectSoundCreate with guidId, whose value is not GUID_NULL
	// check the return code and make sure the dsound  interface was allocated

    CHECKRUN( DirectSoundCreate( &guidId, &pDSound, NULL ) );
    CHECKALLOC( pDSound );

	//
	// Release DSound
	//

    RELEASE( pDSound );

	//
	// Return the HResult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_NonNullPunkTest
 *
 *  Description:
 *      Create and Destroy an IDirectSound using DirectSoundCreate and
 *      a non null punk
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_NonNullPunkTest( void )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;
	LPUNKNOWN			pUnk			= (LPUNKNOWN) 0xDeadBeef;

	//
	// Call DirectSoundCreate, check the return code
	// And the returned pointer
	//

    CHECKRUN( DirectSoundCreate( NULL, &pDSound, pUnk ) );
    CHECKALLOC( pDSound );

	//
	// Release the IDirectSound pointer
	// 

    RELEASE( pDSound );

	//
	// Return the Hresult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_NullDirectSoundPointerTest
 *
 *  Description:
 *      Call DirectSoundCreate with a Null DirectSound Pointer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_NullDirectSoundPointerTest( void )
{
    HRESULT             hr              = S_OK;

	//
	// Call DirectSoundCreate, check the return code
	//

    CHECKRUN( DirectSoundCreate( NULL, NULL, NULL ) );

	//
	// Return the Hresult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_ThreadFunction
 *
 *  Description:
 *      thread function for multiple thread test
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		0 on failure
 *      a pointer cast to a DWORD representing the Dsound Interface
 *
 ****************************************************************************/

DWORD WINAPI DirectSoundCreate_ThreadFunction( LPVOID lpParameter )
{
    HRESULT             hr              = S_OK;
    LPDIRECTSOUND       pDSound         = NULL;
	DWORD				dwRet			= 0;

	//
	// Call DirectSoundCreate, check the return code
	//

    CHECKRUN( DirectSoundCreate( NULL, &pDSound, NULL ) );

	//
	// Cast the pointer value
	//

	dwRet = (DWORD) pDSound;

	//
	// Release the IDirectSound pointer
	// 

    RELEASE( pDSound );

	//
	// return the pDSound pointer value
	//

	return dwRet;
}

/****************************************************************************
 *
 *  DirectSoundCreate_MultipleThreadsTest
 *
 *  Description:
 *      Call DirectSoundCreate on multiple threads
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreate_MultipleThreadsTest( void )
{
    HRESULT             hr              = S_OK;
	DWORD				i				= 0;
	DWORD				dwWait			= 0;
	DWORD				adwRetVals[2];
	HANDLE				ahThreads[2];
    LPDIRECTSOUND       pDSound         = NULL;

	//
	// Zero out the thread array and the ret vals
	//

	ZeroMemory( &ahThreads, sizeof( ahThreads ) );
	ZeroMemory( &adwRetVals, sizeof( adwRetVals ) );

	//
	// Call DirectSoundCreate, check the return code
	//

    CHECKRUN( DirectSoundCreate( NULL, &pDSound, NULL ) );
	CHECKALLOC( pDSound );

	//
	// cycle through the thread array, and create new threads
	// error out as appropriate
	//

	for ( i = 0; i < 2 && SUCCEEDED( hr ); i++ )
	{
		ahThreads[i] = CreateThread( NULL, 0, &DirectSoundCreate_ThreadFunction, NULL, 0, NULL );

		if ( NULL == ahThreads[i] )
			hr = E_OUTOFMEMORY;
	}

	//
	// Wait on the threads to finish, check return code
	//

	if ( SUCCEEDED( hr ) )
	{
		dwWait = WaitForMultipleObjects( 2, ahThreads, TRUE, INFINITE );

		if ( WAIT_FAILED == dwWait )
			hr = E_OUTOFMEMORY;
	}

	//
	// Get the return values from the threads
	//

	for ( i = 0; i < 2 && SUCCEEDED( hr ); i++ )
	{
		if ( ! GetExitCodeThread( ahThreads[i], adwRetVals + i ) )
			hr = E_FAIL;
	}

	//
	// Check the 2 values and make sure they are equal and no zero
	//

	FAIL_ON_CONDITION( adwRetVals[0] == 0 );
	FAIL_ON_CONDITION( adwRetVals[1] == 0 );
    FAIL_ON_CONDITION( adwRetVals[0] != adwRetVals[1] );

	//
	// close each thread handle
	//

	for ( i = 0; i < 2; i++ )
	{
		if ( NULL != ahThreads[i] )
			CloseHandle( ahThreads[i] );
	}

	//
	// Release the Dsound object
	//

	RELEASE( pDSound );

	//
	// Return the Hresult
	//

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreate_StartTest
 *
 *  Description:
 *		The Harness Entry into the DirectSoundCreate tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreate_StartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;

	//
	// the following tests will Assert (by design) in debug builds
	// to turn these tests on (they are off by default) define
	// CODE_COVERAGE when this file is compiled
	//

#ifdef CODE_COVERAGE

	//
	// Test DirectSoundCreate in out of memory situation. this test MUST
	// Be run first based on the mechanism that DirectSound uses to allocate
	// itself on the xbox.
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "OutOfMemory" );
    EXECUTE( DirectSoundCreate_OutOfMemoryTest() );

	//
	// Test DirectSoundCreate with GUID_NULL
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "GuidNull" );
    EXECUTE( DirectSoundCreate_GuidNullTest() );

	//
	// Test DirectSoundCreate with a GUID that is not GUID_NULL
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "NotGuidNull" );
    EXECUTE( DirectSoundCreate_NotGuidNullTest() );

	//
	// Test DirectSoundCreate with a non null LPUNKNOWN
	// 

	SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "NonNullPunk" );
	EXECUTE( DirectSoundCreate_NonNullPunkTest() );

	//
	// Test DirectSoundCreate with a null Direct Sound Pointer
	//

	SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "NullDirectSoundPointer" );
	EXECUTE( DirectSoundCreate_NullDirectSoundPointerTest() );

#endif // CODE_COVERAGE

	//
	// Test DirectSoundCreate in the mannor it was meant to be called
	//

	SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "Basic" );
	EXECUTE( DirectSoundCreate_BasicTest() );

	//
	// Test DirectSoundCreate to make sure that multiple calls result
	// in the same returned IDirectSound pointer
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "Multiple" );
    EXECUTE( DirectSoundCreate_MultipleTest() );

	//
	// Test DirectSoundCreate to make sure that multiple calls on
	// different threads result in the same returned IDirectSound pointer
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreate", "MultipleThreads" );
    EXECUTE( DirectSoundCreate_MultipleThreadsTest() );
}

/****************************************************************************
 *
 *  DirectSoundCreate_EndTest
 *
 *  Description:
 *		The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreate_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *		the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
	DirectSoundCreate_StartTest( NULL );
	DirectSoundCreate_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DirectSoundCreate )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DirectSoundCreate )
    EXPORT_TABLE_ENTRY( "StartTest", DirectSoundCreate_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DirectSoundCreate_EndTest )
END_EXPORT_TABLE( DirectSoundCreate )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\globals.h ===
#include <xtl.h>
#include <xdbg.h>
#include <dmusici.h>
#include <dsound.h>
#include <DSSTDFX.h>
#include <macros.h>
#include <medialoader.h>
#include <stdio.h>

#define TERMINATE NULL,NULL,NULL

HRESULT MyFactory(REFCLSID clsid,
                  LPUNKNOWN pUnkOuter,
                  REFIID iid,
                  LPVOID *ppvInterface);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\IDirectSoundStream\DirectSoundCreateStream\DirectSoundCreateStream.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DirectSoundCreateStream.cpp
 *  Content:    DirectSoundCreateStream tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/ 9/01    danrose Created to test Xbox DirectSoundCreateStream
 *
 ****************************************************************************/

#include "DirectSoundCreateStream.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  DirectSoundCreateStream_BasicTest
 *
 *  Description:
 *      Basic Test for DirectSoundCreateStream
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateStream_BasicTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDSTREAM pStream			= NULL;
	DSSTREAMDESC		dssd;
	WAVEFORMATEX		wfx;

	//
	// Zero out the stream desc and the WAVEFORMATEX
	//

	ZeroMemory( &dssd, sizeof( DSSTREAMDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the wave format
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nSamplesPerSec = 48000;

	//
	// Fill in the DSSTREAMDESC
	//

	dssd.dwMaxAttachedPackets = 1;   
	dssd.lpwfxFormat = &wfx;     

	//
	// Call DirectSoundCreateStream and check return code and pointer
	//

	CHECKRUN( DirectSoundCreateStream( &dssd, &pStream ) );
	CHECKALLOC( pStream );

	//
	// Release the Stream
	//

	RELEASE( pStream );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateStream_NullDSSDTest
 *
 *  Description:
 *      Test DirectSoundCreateStream with a null DSSD
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateStream_NullDSSDTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDSTREAM pStream			= NULL;

	//
	// Call DirectSoundCreateStream and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateStream( NULL, &pStream ) );
	CHECKALLOC( pStream );

	//
	// Destroy the DirectSoundStream
	//

	RELEASE( pStream );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateStream_NullStreamTest
 *
 *  Description:
 *      Test DirectSoundCreateStream with a null Stream
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateStream_NullStreamTest( void )
{
    HRESULT             hr              = S_OK;
	DSSTREAMDESC		dssd;
	WAVEFORMATEX		wfx;

	//
	// Zero out the DSound stream description and the WaveFormatEx
	//

	ZeroMemory( &dssd, sizeof( DSSTREAMDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;

	//
	// Set the Waveformat ofthe DSSTREAMDESC to my wfx
	//

	dssd.lpwfxFormat = &wfx;
	//
	// Call DirectSoundCreateStream and check return code
	//

	CHECKRUN( DirectSoundCreateStream( &dssd, NULL ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateStream_BasicADPCMTest
 *
 *  Description:
 *      Basic Test for DirectSoundCreateStream init using ADPCM
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT DirectSoundCreateStream_BasicADPCMTest( void )
{
    HRESULT             hr              = S_OK;
	LPDIRECTSOUNDSTREAM pStream			= NULL;
	DSSTREAMDESC		dssd;
	XBOXADPCMWAVEFORMAT	wfx;

	//
	// Zero out the DSound buffer description and the WaveFormatEx
	//

	ZeroMemory( &dssd, sizeof( DSSTREAMDESC ) );
	ZeroMemory( &wfx, sizeof( XBOXADPCMWAVEFORMAT ) );

	//
	// Fill in the WaveFormatEx
	//

	wfx.wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
	wfx.wfx.nChannels = 1;
	wfx.wfx.wBitsPerSample = 4;
	wfx.wfx.nBlockAlign = 36;
	wfx.wfx.cbSize = 2;
	wfx.wfx.nSamplesPerSec = 48000;
	wfx.wSamplesPerBlock = 64;

	//
	// Set the Waveformat of the DSSTREAMDESC to my wfx
	//

	dssd.dwMaxAttachedPackets = 1; 
	dssd.lpwfxFormat = (LPWAVEFORMATEX) &wfx;

	//
	// Call DirectSoundCreateStream and check return code and
	// resultant pointer
	//

	CHECKRUN( DirectSoundCreateStream( &dssd, &pStream ) );
	CHECKALLOC( pStream );

	//
	// Destroy the DirectSoundStream
	//

	RELEASE( pStream );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  DirectSoundCreateStream_StartTest
 *
 *  Description:
 *      The Harness Entry into the DirectSoundCreateStream tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreateStream_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

	//
	// Test DirectSoundCreateStream with a NULL DSSD
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateStream", "NullDSSD" );
    EXECUTE( DirectSoundCreateStream_NullDSSDTest() );

	//
	// Test DirectSoundCreateStream with a NULL DirectSoundStream
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateStream", "NullStream" );
    EXECUTE( DirectSoundCreateStream_NullStreamTest() );

#endif // CODE_COVERAGE

    //
    // Test DirectSoundCreateStream in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateStream", "Basic" );
    EXECUTE( DirectSoundCreateStream_BasicTest() );

	//
	// Test DirectSoundCreateStream using basic ADPCM
	//

    SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateStream", "BasicADPCM" );
    EXECUTE( DirectSoundCreateStream_BasicADPCMTest() );

	//
	// Test DirectSoundCreateStream using the max number of PCM buffers
	//

 //   SETLOG( LogHandle, "danrose", "MCPX", "DirectSoundCreateBuffer", "MaxBuffersPCM" );
 //   EXECUTE( DirectSoundCreateBuffer_MaxBuffersPCMTest() );

}

/****************************************************************************
 *
 *  DirectSoundCreateStream_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI DirectSoundCreateStream_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    DirectSoundCreateStream_StartTest( NULL );
    DirectSoundCreateStream_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DirectSoundCreateStream )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DirectSoundCreateStream )
    EXPORT_TABLE_ENTRY( "StartTest", DirectSoundCreateStream_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DirectSoundCreateStream_EndTest )
END_EXPORT_TABLE( DirectSoundCreateStream )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\Helpers.h ===
#pragma once

HRESULT ChopPath(const char *p_szFullString, LPSTR p_szPathOut, LPSTR p_szFileOut);
LPCSTR PathFindFileName(LPCSTR pPath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\Helpers.cpp ===
#include "..\globals.h"

/**********************************************************************
**********************************************************************/
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}

/********************************************************************************
********************************************************************************/
HRESULT ChopPath(const char *p_szFullString, LPSTR p_szPathOut, LPSTR p_szFileOut)
{
HRESULT hr = S_OK;
LPCSTR szFile = NULL;
DWORD dwLength;
CHAR szPathOut[MAX_PATH] = {0};
CHAR szFileOut[MAX_PATH] = {0};

ASSERT(p_szPathOut || p_szFileOut);
ASSERT(p_szFullString);

if (SUCCEEDED(hr))
{
    if (!p_szFullString)
    {
        hr = E_POINTER;
    }
}

//Parse out the file name.
if (SUCCEEDED(hr))
{
    //If the name ends in a '/' or a '\\' then there is no file name.
    if ('/' == p_szFullString[strlen(p_szFullString) - 1] ||
        '\\' == p_szFullString[strlen(p_szFullString) - 1] )
    {
        szFile = &p_szFullString[strlen(p_szFullString)];
    }
    else
    {    
        szFile = (LPSTR)PathFindFileName(p_szFullString);
    }

    //Should never happen.
    ASSERT(szFile);

    //Store the file name.
    strcpy(szFileOut, szFile);
}

if (SUCCEEDED(hr))
{
    //Store the path name.
    dwLength = strlen(p_szFullString) - strlen(szFile);
    strncpy(szPathOut, p_szFullString, dwLength);
    szPathOut[dwLength] = NULL;
}

//Regardless of whether the test passed, set these out-parameters.
if (p_szPathOut)
    strcpy(p_szPathOut, szPathOut);
if (p_szFileOut)
    strcpy(p_szFileOut, szFileOut);

return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\sources.inc ===
TARGETNAME=AATest_$(NAME)
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=xboxapp
LINK_DSSTDFX=1
USE_STL=1
XE_FLAGS=/TESTID:0xA7049955 /INITFLAGS:3 /TESTNAME:$(TARGETNAME)
USE_LIBCMT=1
SYNCHRONIZE_DRAIN=1


INCLUDES =         \
                   $(BASEDIR)\private\inc;                    \
                   $(BASEDIR)\private\test\inc;               \
                   $(BASEDIR)\private\test\multimedia\inc;    \
                   $(SDK_INC_PATH);                           

TESTLIBS=$(BASEDIR)\private\test\lib\$(TARGET_DIRECTORY)

TARGETLIBS= \
           $(SDK_LIB_PATH)\dsound$(D).lib \
           $(SDK_LIB_PATH)\dmusic$(D).lib \
           $(TESTLIBS)\medialoader.lib    \
           $(LIBRARY_PATH)\xnet$(D).lib \
           $(TESTLIBS)\xtestlib.lib \


C_DEFINES=$(C_DEFINES) -DAPPNAME=\"$(NAME)\"

NTTARGETFILE0 = $(O)\CREATEINSTANCE.CPP obj\i386\FILELIST.TXT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

Environment:

    Xbox

Revision History:
    
    Person      Date        Change      
    ------      ----        ------
    DANHAFF     11/29/01    Created

--*/

#include "..\globals.h"
#include "..\helpers.h"

//This is currently determined by the content in FILELIST.CPP, but hopefully we
//  can soon get it from the app's name.
extern char *g_szAppName;

LPSTR g_szContentDir                = "T:\\AudAnalyze\\Content\\";
CHAR  g_szContentList[MAX_PATH]     = {0};
LPSTR g_szFileListDir               = "DMusic/AudAnalyze/FileLists/";
CHAR  g_szFileList[MAX_PATH]        = {0};

IDirectMusicLoader      *g_pLoader  = NULL;
IDirectSound            *g_pDSound  = NULL;
IDirectMusicAudioPath   *g_pPath    = NULL;
IDirectMusicPerformance *g_pPerf    = NULL;

#include "obj\i386\createinstance.cpp"


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT InitializeDSound(void)
{
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    CHECKRUN(DirectSoundCreate( NULL, &g_pDSound, NULL ));
    CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));
    CHECK(DirectSoundUseLightHRTF());
    return hr;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT InitializeDMusic(void)
{
    HRESULT hr = S_OK;
    
    //Create objects.
    //CHECKRUN(DirectMusicInitializeFixedSizeHeaps(30 * 1024 * 1024, 2 * 1024 * 1024, MyFactory));
    IDirectMusicHeap *pNorm = NULL;
    IDirectMusicHeap *pPhys = NULL;

    CHECKRUN(DirectMusicCreateDefaultHeap(&pNorm));
    CHECKRUN(DirectMusicCreateDefaultPhysicalHeap(&pPhys));
    CHECKRUN(DirectMusicInitializeEx(pNorm, pPhys, MyFactory));
    CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&g_pLoader));       
    CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&g_pPerf));       

    //Initialize objects.
    CHECKRUN(g_pPerf->InitAudioX(0, 128, 128, 0));
    CHECKRUN(g_pPerf->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, 128, &g_pPath));
    CHECKRUN(g_pPerf->SetDefaultAudioPath(g_pPath));
    return hr;

};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT InitializeOther(void)
{
    HRESULT hr = S_OK;

    return hr;
};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT GetFileList(MEDIAFILEDESC **ppMediaFileDesc)
{
    HRESULT hr = S_OK;
    MEDIAFILEDESC *pMediaFileDesc = NULL;

        //First get the file list.  We know where it is.        
        {
            MEDIAFILEDESC MediaFileDesc[2] = {0};
            sprintf(g_szFileList,   "%s%s.txt", g_szFileListDir, APPNAME);
            sprintf(g_szContentList,"%s%s.txt", g_szContentDir, APPNAME);
            MediaFileDesc[0].lpszFromPath       = g_szFileList;
            MediaFileDesc[0].lpszToPath         = g_szContentDir;
            MediaFileDesc[0].dwFlags            = COPY_IF_NEWER;
        
            //Copy the file down.
            CHECKRUN(LoadMedia(MediaFileDesc))
        }
        
        //Parse the file.
        if (SUCCEEDED(hr))
        {
            CHAR szLineOText [MAX_PATH] = {0};
            CHAR szSrcFile   [MAX_PATH] = {0};
            CHAR szDstSubPath[MAX_PATH] = {0};
            CHAR szDstPath   [MAX_PATH] = {0};
            BOOL bJustCounting;
            DWORD dwLines = 0;
            DWORD dwCurrent = 0;


            for (LONG bJustCounting=1; bJustCounting>=0; bJustCounting--)
            {
                FILE *fyle = fopen(g_szContentList, "rt");
                CHECKALLOC(fyle);                
                
                if (!bJustCounting)
                {
                    pMediaFileDesc = new MEDIAFILEDESC[dwLines + 1];
                    CHECKALLOC(pMediaFileDesc);
                    CHECK     (ZeroMemory(pMediaFileDesc, sizeof(MEDIAFILEDESC) * (dwLines + 1)));
                }

                while (fgets(szLineOText, MAX_PATH - 1, fyle) && SUCCEEDED(hr))
                {
                    //Bail if it's a comment.
                    if (szLineOText[0] == ';')
                        continue;

                    //Bail if we didn't get two items.
                    DWORD dwScanned = sscanf(szLineOText, "%[^,], %[^\n]",szSrcFile,szDstSubPath);
                    if (2 != dwScanned)
                        continue;

                    //Either count the lines or fill in the respective Media
                    if (bJustCounting)
                    {
                        dwLines++;
                    }
                    else
                    {
                        sprintf(szDstPath, "T:\\%s", szDstSubPath);


                        //Copy this into the destination path and replace '\' with '/'
                        pMediaFileDesc[dwCurrent].lpszFromPath   = new CHAR[strlen(szSrcFile)+1];
                        strcpy(pMediaFileDesc[dwCurrent].lpszFromPath,szSrcFile);                        
                        for (LPSTR szTemp = pMediaFileDesc[dwCurrent].lpszFromPath; *szTemp; szTemp++)
                        {
                            if (*szTemp == '\\')
                                *szTemp = '/';
                                
                        }


                        pMediaFileDesc[dwCurrent].lpszToPath     = new CHAR[strlen(szDstPath)+1];
                        strcpy(pMediaFileDesc[dwCurrent].lpszToPath,szDstPath);
                        pMediaFileDesc[dwCurrent].dwFlags        = COPY_IF_NEWER;
                        dwCurrent++;

                    }


                }

                //Close the file (reset it).
                if (fyle)
                {
                    fclose(fyle);
                    fyle = NULL;
                }
            }
        }

    *ppMediaFileDesc = pMediaFileDesc;
    return hr;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT LoadAndPlaySegments(MEDIAFILEDESC *pMediaFileDesc, DWORD dwTimeLimit)
{
//Run through the list, get the local segment names, and play them.
HRESULT hr = S_OK;
DWORD i = 0;
IDirectMusicSegment *pSegment   = NULL;
IDirectMusicScript  *pScript    = NULL;


for (i=0; pMediaFileDesc[i].lpszFromPath && pMediaFileDesc[i].lpszToPath; i++)
{
    CHAR szFilePath     [MAX_PATH] = {0};
    CHAR szFileName     [MAX_PATH] = {0};

    
    strcpy(szFileName, PathFindFileName(pMediaFileDesc[i].lpszFromPath));
    sprintf(szFilePath, "%s%s", pMediaFileDesc[i].lpszToPath, szFileName);
    _strlwr(szFilePath);

    if (strstr(szFileName, ".sgt") || strstr(szFileName, ".wav"))
    {
    
        CHECKRUN(g_pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, pMediaFileDesc[i].lpszToPath, FALSE));
        CHECKRUN(g_pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFileName, (void **)&pSegment));
        CHECKRUN(g_pPerf->PlaySegmentEx(pSegment, 0, 0, 0, 0, 0, 0, g_pPath));
        CHECK   (Sleep(dwTimeLimit));
        CHECKRUN(g_pPerf->StopEx(0, 0, 0));
        RELEASE(pSegment);
    }
    else if (strstr(szFileName, ".spt"))
    {
        CHECKRUN(g_pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, pMediaFileDesc[i].lpszToPath, FALSE));
        CHECKRUN(g_pLoader->LoadObjectFromFile(CLSID_DirectMusicScript, IID_IDirectMusicScript, szFileName, (void **)&pScript));
        CHECKRUN(pScript->Init(g_pPerf, NULL));

        //BUGBUG: Take this out.

        CHECKRUN(pScript->CallRoutine("Routine511c0", NULL));
        Sleep(5000);
        CHECKRUN(pScript->CallRoutine("Routine511c1", NULL));
        Sleep(5000);
        CHECKRUN(pScript->CallRoutine("Routine511c2", NULL));
        RELEASE(pScript);

    }

    if (FAILED(hr))
    {
        DbgPrint("Error on %s", szFileName);
        hr = S_OK;
    }

}
return hr;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT FreeFileList(MEDIAFILEDESC **ppMediaFileDesc)
{
    delete [](*ppMediaFileDesc);
    *ppMediaFileDesc = NULL;
    return S_OK;
}






//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
int __cdecl main()
{
    HRESULT hr = S_OK;
    MEDIAFILEDESC *pMediaFileDesc = NULL;

    CHECKRUN(InitializeDSound());
    CHECKRUN(InitializeDMusic());
    CHECKRUN(InitializeOther());
    CHECKRUN(GetFileList(&pMediaFileDesc));
    CHECKRUN(LoadMedia(pMediaFileDesc));    
    CHECKRUN(LoadAndPlaySegments(pMediaFileDesc, 15000));
    CHECKRUN(FreeFileList(&pMediaFileDesc));
    DbgPrint("App has finished");
    while (1);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\All\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze /q $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media
    time /t

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\All\FileList.cpp ===
//Note: This is the only thing that should be in this file.  A build-time process will also extract the name of the list from this file using
//quotation marks, so DON'T USE ANY QUOTATION MARKS OTHER THAN THE ONES WRAPPING THE FILE NAME!!!  Thank you and good night.
//char *g_szFileList = "\\DMusic\\AudAnalyze\\FileLists\\All.txt";
char *g_szAppName  = "All";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\BVT\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze /q $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\None\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\ScriptEmbedding\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze /q $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\ScriptVB\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze /q $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\AATest\Wav\makefile.inc ===
$(O)\CREATEINSTANCE.CPP: $(O)\FILELIST.TXT
    echo Analyzing content to produce CreateInstance.cpp
    $(_NT386TREE)\idw\AudAnalyze /q $(O)\FilesToAnalyze.txt $(O)\CreateInstance.cpp

$(O)\FILELIST.TXT: 
    copy \\xdb01\stresscontent\DMusic\AudAnalyze\FileLists\$(NAME).txt $(O)\FileList.txt    
    rd /q /s media
    mkdir Media

    REM Create the file list for AudAnalyze.exe
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do echo Media\%b%~nxa>>$(O)\FilesToAnalyze.txt

    REM Make all the destination directories.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do mkdir Media\%b

    REM Copy down the files.
    for /F "eol=; tokens=1,2 delims=," %a in ($(O)\filelist.txt) do copy "\\xdb01\StressContent\%a" Media\%b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath2.hpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows

// History:
//  03/11/2000  danhaff     created.
//  05/04/2000 - danhaff - split into separate file.
//===========================================================================
#pragma once
 
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ADPCM_Standard.cpp ===
/********************************************************************************
	FILE:
		ADPCM_Standard.cpp

	PURPOSE:
		Test Playback of ADPCM content.

	BY:
		DANHAFF
********************************************************************************/
#include "globals.h"


/********************************************************************************
********************************************************************************/
    //{"ADPCM_OneShot_11_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_11_1"},

HRESULT ADPCM_TestWaveSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused, DWORD dwBaseName)
{
    HRESULT hr = S_OK;
    LPSTR szBaseName = (LPSTR)dwBaseName;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CtIDirectMusicSegment   *ptSegment = NULL;
    CICMusic *pMusic;
    CHAR szFrom[MAX_PATH]   = {0};
    CHAR szTo[MAX_PATH]     = {0};
    CHAR szLoad[MAX_PATH]     = {0};
    MEDIAFILEDESC MediaFileDescs[] = {szFrom, szTo, COPY_IF_NEWER, TERMINATE};
    
    for (int i=0; i<2 && SUCCEEDED(hr); i++)
    {
        sprintf(szFrom, "WAV/%s_%s.wav", i ? "ADPCM" : "PCM", dwBaseName);
        sprintf(szTo,   "T:\\WAV\\");
        sprintf(szLoad, "T:\\WAV\\%s_%s.wav", i ? "ADPCM" : "PCM", dwBaseName);
        CHECKRUN(LoadMedia(&MediaFileDescs[0]));
        ALLOCATEANDCHECK(pMusic, CICMusic);
        CHECKRUN(pMusic->Init(ptPerf8, szLoad, DMUS_APATH_SHARED_STEREOPLUSREVERB));
        CHECKRUN(pMusic->GetInterface(&ptSegment));
        CHECKRUN(pMusic->GetInterface(&ptPath));
        ptPerf8->StopEx(0, 0, 0);
        CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 5000, szTo));
        CHECKRUN(ptSegment->SetRepeats(0));
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,0,0,ptPath));
        CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, szTo));
        CHECKRUN(WaitForSegmentStop(ptPerf8, ptSegment, NULL, 11000, TRUE));
        ptPerf8->StopEx(0, 0, 0);
        SAFE_RELEASE(ptPath);
        SAFE_RELEASE(ptSegment);    
        delete pMusic;
        pMusic = NULL;
    }

    return hr;
};




/********************************************************************************
********************************************************************************/
HRESULT ADPCM_TestMusicSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwSegmentName)
{
    HRESULT hr = S_OK;
    LPSTR szSegmentName= (LPSTR)dwSegmentName;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CtIDirectMusicSegment   *ptSegment = NULL;
    CICMusic *pMusic = NULL;
    CHAR szTo[MAX_PATH]     = {0};
    CHAR szLoad[MAX_PATH]     = {0};
    
    sprintf(szTo,   "T:\\DMTest1\\Perf8\\PlaySeg\\ADPCM\\");
    sprintf(szLoad,   "T:\\DMTest1\\Perf8\\PlaySeg\\ADPCM\\%s",szSegmentName);
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Perf8/PlaySeg/ADPCM/", szTo));    
    ALLOCATEANDCHECK(pMusic, CICMusic);
    CHECKRUN(pMusic->Init(ptPerf8, szLoad, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(pMusic->GetInterface(&ptSegment));
    CHECKRUN(pMusic->GetInterface(&ptPath));
    CHECKRUN(InsertToolTrace(ptPath));
    CHECKRUN(ptSegment->SetRepeats(0));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,0,0,ptPath));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, szTo));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 21000, szTo));
    if (ptPath)
        RemoveToolTrace(ptPath);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);    
    delete pMusic;
    pMusic = NULL;

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath1.hpp ===
#pragma once
 
#include "globals.h"
#include "Help_Definitions.h"
#include "cicmusicx.h"

/********************************************************************************
********************************************************************************/
template <class T>
HRESULT tmplGetObjectInPath(CtIDirectMusicPerformance8 *ptPerf8,                          
                          DWORD dwPathType,
                          DWORD dwStage,
                          GUID *pguidObject,
                          GUID *pguidInterface,
                          T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				    = S_OK;
    void                        *pVoid              = NULL;    
    IUnknown                    *pUnknown           = NULL;
    IDirectSoundBuffer          *pDSB               = NULL;
    T                           *ptTestInterface    = NULL;
    CICMusic                    *pMusic             = NULL;   
    DWORD                        dwBuffer           = 0;

    
    ALLOCATEANDCHECK(pMusic, CICMusic);
    CHECKRUN(pMusic->Init(ptPerf8, g_TestParams.szDefaultMedia, dwPathType));
    CHECKRUN(pMusic->GetInterface(&ptTestInterface));
    dwBuffer = 0;
    
    // Get the object out of the audio path.
    CHECKRUN(ptTestInterface->GetObjectInPath(
            IgnorePChannel(dwStage),   
            dwStage,           
            dwBuffer,          
            *pguidObject,    
            0,               //dwIndex
            *pguidInterface, 
            (void **)&pVoid));

    //Wait a sec, to catch any mixer problems.
    CHECKRUN(Wait(1000));

  
    //TODO: Call the last method on each interface.  This test sucks, write another one.


    //Verify it's the correct type by QI'ing
    if (dwStage == DMUS_PATH_BUFFER)
    {
        CHECK((pDSB = (IDirectSoundBuffer *)pVoid));
    }
    else
    {
        CHECK((pUnknown = (IUnknown *)pVoid));
    }

    SAFE_RELEASE(pUnknown);
    SAFE_RELEASE(pDSB);
    SAFE_RELEASE(ptTestInterface);
    SAFEDELETE(pMusic);
	return hr;
}	



/********************************************************************************
********************************************************************************/
template <class T>
HRESULT tmplTraverseStandard(CtIDirectMusicPerformance8 *ptPerf8,
                          DWORD dwStandardPath,
                          PATH_DEFINITION *pDefinition,
                          T* pDoNotUseDoNotRemove = NULL)
{

    CICMusic Music;
    T *ptInterface = NULL;
    HRESULT hr = S_OK;

    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwStandardPath));
    CHECKRUN(Music.GetInterface(&ptInterface));
    CHECKRUN(VerifyPathData(pDefinition, ptInterface));

    SAFE_RELEASE(ptInterface);
    return hr;

}



/********************************************************************************
********************************************************************************/
template <class T>
HRESULT tmplGetBuffer(CtIDirectMusicPerformance8 *ptPerf8,
                     DWORD dwStandardPath,
                     T* pDoNotUseDoNotRemove = NULL)
{

    CICMusic Music;
    T *ptInterface = NULL;
    HRESULT hr = S_OK;
    IDirectSoundBuffer *pBuffer = NULL;
    DWORD dwStatus = 0;

    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwStandardPath));
    Log(FYILOGLEVEL, "Playing music normal for 3 seconds");
    CHECKRUN(Wait(3000));
    CHECKRUN(Music.GetInterface(&ptInterface));
    CHECKRUN(ptInterface->GetObjectInPath(DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, 0, GUID_All_Objects, 0, GUID_NULL, (void **)&pBuffer));
    Log(FYILOGLEVEL, "Setting volume to -1000 on AudioPath buffer for 3 seconds");
    CHECKRUN(pBuffer->SetVolume(-1000));
    CHECKRUN(Wait(3000));
    Log(FYILOGLEVEL, "Setting frequency to 50000 on audioPath buffer for 3 seconds");
    CHECKRUN(pBuffer->SetVolume(0));
    CHECKRUN(pBuffer->SetFrequency(50000));
    CHECKRUN(Wait(3000));

    Log(FYILOGLEVEL, "Calling other random APIs on buffer");
    CHECKRUN(pBuffer->SetPosition(0, 0, 0, DS3D_IMMEDIATE));
    CHECKRUN(pBuffer->SetVelocity(0, 0, 0, DS3D_IMMEDIATE));


    SAFE_RELEASE(pBuffer);
    SAFE_RELEASE(ptInterface);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_Activate.cpp ===
#include "globals.h"
#include "cicmusicx.h"



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT AudioPath_Activate_BVT(CtIDirectMusicPerformance8 *ptPerf8  , DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath     = NULL;


    //Load default segment.
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment8));

    //Create an inactive audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,16,FALSE,&ptPath));

    //Activate(TRUE) on inactive path.
    CHECKRUN(ptPath->Activate(TRUE));

    //Try to play a segment on it; verify you hear sound.
    CHECKRUN(ptPerf8->PlaySegmentEx( 
        ptSegment8, 
        0,
        NULL,
        0, 
        0,
        NULL,
        NULL,
        ptPath));
    Log(FYILOGLEVEL, "Playing segment on active path, should hear sound for 3 seconds.");
    CHECKRUN(Wait(3000));

    //CLEANUP

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    return hr;

};


/********************************************************************************
Go from INACTIVE->INACTIVE, INACTIVE->ACTIVE, ACTIVE->ACTIVE, ACTIVE->INACTIVE
********************************************************************************/
HRESULT AudioPath_Activate_Valid_OnAndOff(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath     = NULL;

    //Load default segment.
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment8));

    //Create an inactive audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,16,FALSE,&ptPath));

    //Activate(FALSE) on inactive path.
    CHECKRUN(ptPath->Activate(FALSE));
    Log(FYILOGLEVEL, "Calling Activate(FALSE) on inactive path, should hear no sound for 3 seconds.");
    CHECKRUN(Wait(3000));

    //Activate(TRUE) on inactive path.
    CHECKRUN(ptPath->Activate(TRUE));
    Log(FYILOGLEVEL, "Calling Activate(TRUE) on inactive path, should hear no sound for 3 seconds.");
    CHECKRUN(Wait(3000));

    //Try to play a segment on it; verify you don't hear any sound.
    CHECKRUN(ptPerf8->PlaySegmentEx( 
        ptSegment8, 
        0,
        NULL,
        0, 
        0,
        NULL,
        NULL,
        ptPath));
    Log(FYILOGLEVEL, "Playing segment on active path, should hear sound for 3 seconds.");
    CHECKRUN(Wait(3000));


    //Activate(TRUE) on active path.
    CHECKRUN(ptPath->Activate(TRUE));
    Log(FYILOGLEVEL, "Calling Activate(TRUE) on active path, should hear sound for 3 seconds.");
    CHECKRUN(Wait(3000));

    //Activate(FALSE) on active path.
    CHECKRUN(ptPath->Activate(FALSE));
    Log(FYILOGLEVEL, "Calling Activate(FALSE) on active path, should hear no sound for 3 seconds.");
    CHECKRUN(Wait(3000));

    //Activate(TRUE) on deactivated path.
    CHECKRUN(ptPath->Activate(TRUE));
    Log(FYILOGLEVEL, "Calling Activate(TRUE) on deactivated path, no sound expected.");
    CHECKRUN(Wait(3000));

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    return hr;
};





/********************************************************************************
Create 999 Inactive paths, then activate them one at a time.
********************************************************************************/
HRESULT AudioPath_Activate_Valid_Many(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwPathType, DWORD dwCount)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath[1000]     = {NULL};
DWORD i=0;

    //Load default segment.
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment8));

    //Create dwCount inactive paths.
    for (i=0; i<dwCount; i++)
    {
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPathType,16,FALSE,&ptPath[i]));
        if (SUCCEEDED(hr))
            Log(MAXLOGLEVEL, "Created path %d", i);
        else
            Log(ABORTLOGLEVEL, "Failed to create audiopath #%d (0-based)", i);
    }

    for (i=0; i<dwCount+1 && SUCCEEDED(hr); i++)
    {   
        if(i < dwCount) {
            //Activate(TRUE) on inactive path.
            CHECKRUN(ptPath[i]->Activate(TRUE));
            Log(MAXLOGLEVEL, "Activated path %d", i);

            //Try to play a segment on it; verify you don't hear any sound.
            CHECKRUN(ptPerf8->PlaySegmentEx( 
                ptSegment8, 
                0,
                NULL,
                0, 
                0,
                NULL,
                NULL,
                ptPath[i]));
        }

        //Deactivate.
        if (i>0)
        {
            CHECKRUN(ptPath[i-1]->Activate(FALSE));
            Log(MAXLOGLEVEL, "Deactivated path %d", i-1);            
        }
    };

    //Stop everything.
    ptPerf8->StopEx(0, 0, 0);

    SAFE_RELEASE(ptSegment8);
    for (i=0; i<dwCount; i++)
    {
        SAFE_RELEASE(ptPath[i]);
    }

    Sleep(5000);
    return hr;
};






/********************************************************************************
Creates two paths of one type.  If it's a shared path, then activate should deactivate
both paths.  If it's not, then activate(FALSE) should only deactivate one path.
********************************************************************************/
HRESULT AudioPath_Activate_Valid_Sharing(CtIDirectMusicPerformance8 *ptPerf8, DWORD bShared, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8[2] = {NULL};
CtIDirectMusicAudioPath *ptPath[2]     = {NULL};
LPSTR szSegment[2] = {"t:\\DMTest1\\test.sgt", "t:\\DMTest1\\test2.sgt"};
int i=0;
DWORD dwPathType= bShared ? DMUS_APATH_SHARED_STEREOPLUSREVERB : DMUS_APATH_DYNAMIC_MONO;

MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };

    CHECKRUN(LoadMedia(MediaFileDesc));

    //Load default segment.
    for (i=0; i<2; i++)
    {
        CHECKRUN(dmthLoadSegment(szSegment[i], &ptSegment8[i]));
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPathType,32,TRUE,&ptPath[i]));

        //Try to play a segment on it; verify you don't hear any sound.
        CHECKRUN(ptPerf8->PlaySegmentEx( 
            ptSegment8[i], 
            0,
            NULL,
            i ? DMUS_SEGF_SECONDARY : 0, 
            0,
            NULL,
            NULL,
            ptPath[i]));

    };

    //Play both segments for a couple seconds.
    Log(FYILOGLEVEL, "You should hear both segments playing simultaneously for 3 seconds");
    CHECKRUN(Wait(3000));


    //Now call Activate FALSE on one of the paths.
    CHECKRUN(ptPath[1]->Activate(FALSE));

    Log(FYILOGLEVEL, "Calling activate(FALSE) on a %s path.", bShared ? "shared" : "dynamic");
    Log(FYILOGLEVEL, "You should hear %s segment(s) playing for 3 seconds", bShared ? "both" : "one");
    CHECKRUN(Wait(3000));

    //Stop everything.
    CHECKRUN(ptPerf8->StopEx(0,0,0));


    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment8[i]);
        SAFE_RELEASE(ptPath[i]);
    }

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath2.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "AudioPath_GetObjectInPath2.hpp"


HRESULT AudioPath_GetObjectInPath_TraverseStandard(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwStandardPath, PATH_DEFINITION pDef);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_GetObjectInPath (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function AudioPath_GetObjectInPath())");
    DMTEST_EXECUTE(AudioPath_GetObjectInPath_TraverseStandard(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB,  g_DefaultPathStereoPlusReverb));
    DMTEST_EXECUTE(AudioPath_GetObjectInPath_TraverseStandard(ptPerf8, DMUS_APATH_SHARED_STEREO,            g_DefaultPathStereo));
    DMTEST_EXECUTE(AudioPath_GetObjectInPath_TraverseStandard(ptPerf8, DMUS_APATH_DYNAMIC_MONO,             g_DefaultPathMono));
    DMTEST_EXECUTE(AudioPath_GetObjectInPath_TraverseStandard(ptPerf8, DMUS_APATH_DYNAMIC_3D,               g_DefaultPath3D));
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath_DSBTest.cpp ===
#include "globals.h"
#include "Help_Buffer3D.h"
#include "AudioPath_GetObjectInPath_DSBTestFunc.h"

#define INTERFACE_NAME CtIDirectMusicAudioPath


/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT HelpInitBUFFER3D(CtIDirectMusicPerformance *ptPerf8, CICMusic &Music, DWORD dwPath, DWORD dwBuffer, BUFFER3D *pSound, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
T *ptInterface  = NULL;
IDirectSoundBuffer *pBuffer = NULL;
LPSTR szAudioPathConfig = NULL;

    if (!pSound)
    {
        Log(ABORTLOGLEVEL, "Test app error: pSoundis NULL!!!");
        hr = E_FAIL;
    }


    //Create the audiopath.
    if (!IsValidAudioPath(dwPath))
    {
        CHECK(szAudioPathConfig = (LPSTR)dwPath);
        CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, szAudioPathConfig));
    }
    else
    {
        CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwPath));
    }

    CHECKRUN(Music.GetInterface(&ptInterface));
    CHECKRUN(ptInterface->GetObjectInPath(DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, dwBuffer, GUID_NULL, 0, GUID_NULL, (void **)&pBuffer));
    CHECKRUN(pSound->Init(vDefault, pBuffer));
    SAFE_RELEASE(ptInterface);
    return hr;

};



/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetAllParameters(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetAllParameters(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetConeAngles(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetConeAngles(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetConeOrientation_BoundaryCases(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetConeOrientation_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetConeOrientation_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetConeOutsideVolume(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetConeOutsideVolume(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetMaxDistance_BoundaryCases(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetMaxDistance_InsideSource(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetMinDistance_BoundaryCases(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetMinDistance_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetMinDistance_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetMode(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetMode(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetPosition_BoundaryCases(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetPosition_BoundaryCases(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetPosition_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetPosition_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetVelocity(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetVelocity(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
/*
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_INFINITY_Bug(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_INFINITY_Bug(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}
*/
/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetFrequency_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetFrequency_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetFrequency_Range(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetFrequency_Range(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetVolume_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetVolume_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetVolume_Range(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetVolume_Range(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}

/****************************************************************************************************
****************************************************************************************************/
/*
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetChannelVolume_Channel_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetChannelVolume_Channel_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}
*/
/****************************************************************************************************
****************************************************************************************************/
/*
template <class T>
HRESULT Template_GetObjectInPath_3DBuf_SetChannelVolume_Mask_Listening(CtIDirectMusicPerformance* ptPerf8, DWORD dwPath, DWORD dwBuffer, T* pDoNotUseDoNotRemove = NULL)
{
HRESULT hr = S_OK;
CICMusic Music;
BUFFER3D Sound;
CHECKRUN(HelpInitBUFFER3D(ptPerf8, Music, dwPath, dwBuffer, &Sound, pDoNotUseDoNotRemove));
CHECKRUN(DMTest_Buf_SetChannelVolume_Mask_Listening(&Sound, TESTAPPLY_IMMEDIATE, vDefault));
return hr;
}
*/

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetAllParameters(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetAllParameters(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeAngles(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetConeAngles(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetConeOrientation_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOutsideVolume(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetConeOutsideVolume(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetMinDistance_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetMinDistance_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetMode(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetMode(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetPosition_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetPosition_BoundaryCases(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetPosition_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetPosition_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetVelocity(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetVelocity(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
/*
HRESULT AudioPath_GetObjectInPath_3DBuf_INFINITY_Bug(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_INFINITY_Bug(ptPerf8, dwPath, dwBuffer, ptUseless);
}
*/

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetFrequency_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetFrequency_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetFrequency_Range(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetFrequency_Range(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetVolume_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetVolume_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
HRESULT AudioPath_GetObjectInPath_3DBuf_SetVolume_Range(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetVolume_Range(ptPerf8, dwPath, dwBuffer, ptUseless);
}

/****************************************************************************************************
****************************************************************************************************/
/*
HRESULT AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Channel_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetChannelVolume_Channel_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}
*/

/****************************************************************************************************
****************************************************************************************************/
/*
HRESULT AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Mask_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer)
{
    INTERFACE_NAME *ptUseless = NULL;
    return Template_GetObjectInPath_3DBuf_SetChannelVolume_Mask_Listening(ptPerf8, dwPath, dwBuffer, ptUseless);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath_DSBTestFunc.cpp ===
#include "globals.h"
#include "audiopath_getobjectinpath_DSBTestFunc.h"

/********************************************************************************
Orient a cone away from the listener, then expand the angles to encompass the 
listener.  Try SetAllParameters with dwApply on/off and see whether it changes.
********************************************************************************/
HRESULT DMTest_Buf_SetAllParameters(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DS3DBUFFER ds3db;
char *pStrings[] = {"Using DS3D_IMMEDATE", "Using DS3D_DEFERRED, then CommitDeferredSettings", "Using DS3D_DEFERRED but not CommitDeferredSettings - change shouldn't occur"};
DWORD dwWait = 4000;

ZeroMemory(&ds3db, sizeof(ds3db));


Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetAllParameters:  eTestApply = %s", String(eTestApply));

//Set up our 3DBuffer so that the parameters are such that you shouldn't hear any sound.
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 0;
ds3db.dwMode                    = DS3DMODE_NORMAL;  //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = FLT_BIG;
ds3db.flMaxDistance             = FLT_BIG;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = make_D3DVECTOR(0, 0, 1);  //away
ds3db.vPosition                 = make_D3DVECTOR(FLT_BIG, FLT_BIG, FLT_BIG);
ds3db.vVelocity                 = make_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;

//Play sound, shouldn't hear anything.  Use Immediate mode to set these parameters so they'll always be set.
CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));
Log(FYILOGLEVEL, "Sound is a meter ahead of you and facing away without outside volume minimum:  You should hear nothing for %d ms", dwWait);
CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
Wait(dwWait);

//Set up our 3DBuffer so that the parameters are such that you shouldn't hear any sound.
ds3db.dwInsideConeAngle         = DS3D_DEFAULTCONEANGLE;
ds3db.dwOutsideConeAngle        = DS3D_DEFAULTCONEANGLE;
ds3db.dwMode                    = DS3DMODE_NORMAL;  //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MAX;
ds3db.vConeOrientation          = make_D3DVECTOR(0, 0, -1);  //toward
ds3db.vPosition                 = make_D3DVECTOR(0, 0, 0);
ds3db.vVelocity                 = make_D3DVECTOR(0, 0, 0);


//Now that everything is set to pretty much default, we should hear normal sound.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));
Log(FYILOGLEVEL, "Calling SetAllParameters with default parameters: You should hear sound at full volume for %d ms.", dwWait);
ds3db.lConeOutsideVolume = DSBVOLUME_MAX;
CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
Wait(dwWait);
return hr;
}



/********************************************************************************
Rotates between several sets of cone angles and asks user to verify the
correct sound came out.
Fails on software due to 2431; hopefully will succeed on hardware.
********************************************************************************/
HRESULT DMTest_Buf_SetConeAngles(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl ;
BOOL bPlaying = FALSE;
DWORD dwVolumes[2]          = {DSBVOLUME_MIN, DSBVOLUME_MAX};
DWORD dwAngle;
float fAngle;
D3DVECTOR vLisPos = {0};

struct TESTCASE
{
DWORD dwInsideConeAngle;
DWORD dwOutsideConeAngle;
char *szBehavior;
};


DWORD dwTestCase = 0;

TESTCASE TestCase[] = 
{
{0,     0,  "No sound should be heard"},
{360,   360,"Should should be heard continuously"},
{0,     360,"Sound should slowly fade to maximum"},
{180,   360,"Sound should fade to maximum for time=x and remain there for time=x."},
{0,     180,"Sound should be silent for time=x and fade in over time=x"},
{1,     359, "Sound should slowly fade to maximum"},
};

ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));


//Preset our starting buffer and listener positions.
//Position source at 0, 0, 0.  Point the cone forward.
ds3db.dwInsideConeAngle         = TestCase[dwTestCase].dwInsideConeAngle;           //N/A to be adjusted in loop
ds3db.dwOutsideConeAngle        = TestCase[dwTestCase].dwInsideConeAngle;           //N/A to be adjusted in loop 
ds3db.dwMode                    = DS3DMODE_NORMAL;
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = make_D3DVECTOR(0, 0, 1);
ds3db.vPosition                 = make_D3DVECTOR(0, 0, 0);
ds3db.vVelocity                 = make_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;


//Set up the 3D Listener at 0, 0, -1, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = make_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = make_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = make_D3DVECTOR(0, 0, -1);        //behind the source at (0, 0, 0);
ds3dl.vVelocity                 = make_D3DVECTOR(0, 0, 0);         //will be derivatives of positioning functions cos and sin.



Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetConeAngles: eTestApply = %s", String(eTestApply));


for (dwTestCase = 0; dwTestCase < NUMELEMS(TestCase); dwTestCase++)
{
    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set those source parameters.
    ds3db.dwInsideConeAngle         = TestCase[dwTestCase].dwInsideConeAngle;
    ds3db.dwOutsideConeAngle        = TestCase[dwTestCase].dwInsideConeAngle;
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Set up our coneangles as per the test case.
    CHECKRUN(pSound->DSB_SetConeAngles(TestCase[dwTestCase].dwInsideConeAngle, TestCase[dwTestCase].dwOutsideConeAngle));
    
    //Print what is supposed to happen.
    Log(FYILOGLEVEL, "Moving listener from behind source (270) to in front of source (90)");
    Log(FYILOGLEVEL, "ConeAngles are (%3d,%3d) %s", TestCase[dwTestCase].dwInsideConeAngle, TestCase[dwTestCase].dwOutsideConeAngle, TestCase[dwTestCase].szBehavior);
    Log(FYILOGLEVEL, "---------------------------------------------------");
        
    //Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
    bPlaying = FALSE;
    for (dwAngle = 270; dwAngle >= 90  && SUCCEEDED(hr); dwAngle--)
    {
        fAngle = float(((float)dwAngle) * PI / 180.0f);
        vLisPos.x = (float)cos(fAngle);
        vLisPos.z = (float)sin(fAngle);

        CHECKRUN(pSound->DS_SetPosition(vLisPos.x, vLisPos.y, vLisPos.z));
        Wait(5000 / 180);                  //want to spend 5s; going through loop 180 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            Log(FYILOGLEVEL, "Listener relative to source: %3d degrees.  %2d percent finished w/sweep", dwAngle, (270 - dwAngle) * 100 / 180);

    }

    CHECKRUN(pSound->DSB_Stop());
}

;
return hr;
}








/********************************************************************************
So we want to test the following vectors with negative numbers.
a) testing 1, FLT_BIG, and FLT_SMALL.
b) testing negative numbers.

Example bunch -0- test cases.

{FLT_BIG, 0      , 0      },
{0      , FLT_BIG, 0      },
{0      , 0      , FLT_BIG},
{FLT_BIG, FLT_BIG, 0      },
{FLT_BIG, 0      , FLT_BIG},
{0      , FLT_BIG, FLT_BIG},
{FLT_BIG, FLT_BIG, FLT_BIG},

********************************************************************************/
HRESULT DMTest_Buf_SetConeOrientation_BoundaryCases(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DWORD dwIterator = 0;


//A couple random positions to test with.
D3DVECTOR vBufPos[] = {{43, -28, 90}, {.2f, -.7f, 2.2f}};
D3DVECTOR vLisPos[] = {{234, 22, 4},  {-2, -.02f , 1.8f}};
DWORD dwBufPos, dwLisPos;

//Test values.
FLOAT fTestValues[8] = {1, FLT_BIG, FLT_BIG, FLT_SMALL, -1, -FLT_BIG, -FLT_BIG, -FLT_SMALL};
DWORD dwTestValue = 0;

D3DVECTOR v = {0};



    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetConeOrientation_BoundaryCases: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.

    for (dwBufPos = 0; dwBufPos > NUMELEMS(vBufPos)  && SUCCEEDED(hr); dwBufPos++)
    {
        CHECKRUN(pSound->DSB_SetPosition(vBufPos[dwBufPos].x, vBufPos[dwBufPos].y, vBufPos[dwBufPos].z));
        for (dwLisPos = 0; dwLisPos > NUMELEMS(vLisPos); dwLisPos++)
        {
            CHECKRUN(pSound->DS_SetPosition(vLisPos[dwBufPos].x, vLisPos[dwBufPos].y, vLisPos[dwBufPos].z));
            for (dwTestValue = 0; dwTestValue < NUMELEMS(fTestValues); dwTestValue++)
            {
                for (dwIterator = 0; dwIterator < 8; dwIterator ++)
                {
                    v.x = dwIterator & (1 << 0) ? fTestValues[dwTestValue] : 0;
                    v.y = dwIterator & (1 << 1) ? fTestValues[dwTestValue] : 0;
                    v.z = dwIterator & (1 << 2) ? fTestValues[dwTestValue] : 0;

                    CHECKRUN(pSound->DSB_SetConeOrientation(v.x, v.y, v.z));
                    Wait(10);
                }
            }
        }
    }

    Log(FYILOGLEVEL, "Stopping Sound");

    ;
    return hr;
};



/********************************************************************************
Spins the buffer cone around and asks user to verify that the volume is attenuated 
properly.

This will fail on software any case where the sound is between the coneangles due to
bug 2431.  Hopefully it will succeed on hardware.
********************************************************************************/
HRESULT DMTest_Buf_SetConeOrientation_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl;
BOOL bPlaying = FALSE;
DWORD dwVolumes[2]          = {DSBVOLUME_MIN, DSBVOLUME_MAX};
DWORD dwAngle;
float fAngle;
D3DVECTOR vLisPos = {0};


DWORD dwTestCase = 0;
ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));


//Preset our starting buffer and listener positions.
//Position source at 0, 0, 1.  Point the cone backward toward the listener (0, 0, -1).
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 360;
ds3db.dwMode                    = DS3DMODE_NORMAL;                              //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = make_D3DVECTOR(0, 0, -1);        //Looking back toward the listener
ds3db.vPosition                 = make_D3DVECTOR(0, 0, 1);
ds3db.vVelocity                 = make_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;

//Set up the 3D Listener at 0, 0, 0, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = make_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = make_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = make_D3DVECTOR(0, 0, 0);         //at origin, behind the source.
ds3dl.vVelocity                 = make_D3DVECTOR(0, 0, 0);         //will be derivatives of positioning functions cos and sin.


    //Init
        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetConeOrientation_Listening: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set starting parameters.
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Print what is supposed to happen.
    Log(FYILOGLEVEL, "Cone will start pointing toward the user, and rotate 360 degrees (away and then back toward the user)");
    Log(FYILOGLEVEL, "  The sound should fade out and then in over a period of 5 seconds.");
        
    //Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
    bPlaying = FALSE;
    for (dwAngle = 0; dwAngle <=360  && SUCCEEDED(hr); dwAngle++)
    {        
        //make zero be facing backwards.
        fAngle = float(((float)dwAngle + 270) * PI / 180.0f);
        vLisPos.x = (float)cos(fAngle);
        vLisPos.z = (float)sin(fAngle);

        CHECKRUN(pSound->DSB_SetConeOrientation(vLisPos.x, vLisPos.y, vLisPos.z));
        Wait(5000 / 360);                  //want to spend 5s; going through loop 360 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            Log(FYILOGLEVEL, "Listener angle (0 = pointing at source): %3d degrees.  %2d percent finished w/sweep", dwAngle, dwAngle * 100 / 360);

    }

    CHECKRUN(pSound->DSB_Stop());

    ;
    return hr;
}




/********************************************************************************
Fails on software due to 2431; hopefully will succeed on hardware.
********************************************************************************/
HRESULT DMTest_Buf_SetConeOutsideVolume(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl;
BOOL bPlaying = FALSE;
LONG lOutsideVolume = 0;

ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));

//Preset our starting buffer and listener positions.
//Position source at 0, 0, 1.  Point the cone away from the listener (0, 0, 1).
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 359;
ds3db.dwMode                    = DS3DMODE_NORMAL;
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = make_D3DVECTOR(0, 0, 1);        //Facing away from the listener.
ds3db.vPosition                 = make_D3DVECTOR(0, 0, 1);
ds3db.vVelocity                 = make_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;

//Set up the 3D Listener at 0, 0, 0, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = make_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = make_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = make_D3DVECTOR(0, 0, 0);         //at origin, behind the source.
ds3dl.vVelocity                 = make_D3DVECTOR(0, 0, 0);         //would be derivatives of positioning functions cos and sin, if we adjusted this.


        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetConeOutsideVolume: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set starting parameters.
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));
    bPlaying = FALSE;
    LONG lIncValue = 1000;
    DWORD dwTime     = 10000;
    Log(FYILOGLEVEL, "Listener is on outside of sound cone.  Will increase outside volume from -10000 (silence) to 0 (max) over %d seconds", dwTime / 1000);
    for (lOutsideVolume = DSBVOLUME_MIN; lOutsideVolume <= DSBVOLUME_MAX  && SUCCEEDED(hr); lOutsideVolume+=lIncValue)    {        

        CHECKRUN(pSound->DSB_SetConeOutsideVolume(lOutsideVolume));
        if (lOutsideVolume % lIncValue == 0)
            Log(FYILOGLEVEL, "Outside Volume is %5d", lOutsideVolume);
        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        Wait(dwTime / ((DSBVOLUME_MAX - DSBVOLUME_MIN) / lIncValue));
    }

    CHECKRUN(pSound->DSB_Stop());

    ;
    return hr;
}





/********************************************************************************
We set a sound source 50m away.  Then we move MaxDistance from 2 to 100m.
When this value hits 50 the sound should turn on.  However, it turns on 
immediately due to

2478	incrementing IDirectBUFFER3DBuffer::SetMaxDistance will incorrectly enable far-away sound.

This should be fixed when we replace the software with hardware.
********************************************************************************/
HRESULT DMTest_Buf_SetMaxDistance_InsideSource(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
BOOL bPlaying = FALSE;
DWORD dwMaxDistance = 0;

        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetMaxDistance_InsideSource: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MinDistance to 1m.
    CHECKRUN(pSound->DSB_SetMinDistance(1));

    //Set the source 50m away, to the right.
    CHECKRUN(pSound->DSB_SetPosition(50, 0, 0));
  
    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    bPlaying = FALSE;
    DWORD dwIncValue = 1;        //this MUST be 1 for loop to work.
    DWORD dwTime     = 5000;
    Log(FYILOGLEVEL, "Moving MaxDistance from 2m to 100m over %d seconds - should hear sound continuously", dwTime / 1000);
    for (dwMaxDistance = 2; dwMaxDistance <=100  && SUCCEEDED(hr); dwMaxDistance += dwIncValue)
        {        
        CHECKRUN(pSound->DSB_SetMaxDistance((FLOAT)dwMaxDistance));
        CHECKRUN(pSound->DSB_SetMinDistance((FLOAT)dwMaxDistance - 1));
        if (dwMaxDistance % 10 == 0)
            Log(FYILOGLEVEL, "Max Distance is %5d", dwMaxDistance);
        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        Wait(dwTime / (100 / dwIncValue));
    }

    CHECKRUN(pSound->DSB_Stop());
    ;
    return hr;
}


/********************************************************************************
Try the ugly boundary cases for SetMaxDistance.
********************************************************************************/
HRESULT DMTest_Buf_SetMaxDistance_BoundaryCases(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DWORD dwMaxDistance = 0;
FLOAT fTestValues[] = {FLT_SMALL, 1, FLT_BIG, FLT_BIG};



        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetMaxDistance_BoundaryCases: eTestApply = %s", String(eTestApply));
    Log(FYILOGLEVEL, "Setting source at -1, 0, 0 (left of you), trying extreme values for SetMaxDistance");

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MinDistance to the lowest possible number.
    CHECKRUN(pSound->DSB_SetMinDistance(FLT_SMALL));

    //Set the source close, to the left of ya.
    CHECKRUN(pSound->DSB_SetPosition(-11, 0, 0));
  
    //Play
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Iterate through test values.
    for (DWORD i=0; i<NUMELEMS(fTestValues) && SUCCEEDED(hr); i++)
    {
        Log(FYILOGLEVEL, "Trying MaxDistance = %g", fTestValues[i]);
        CHECKRUN(pSound->DSB_SetMaxDistance(fTestValues[i]));
        Wait(1000);
    }

    CHECKRUN(pSound->DSB_Stop());
    ;
    return hr;
}







/********************************************************************************
Try the ugly boundary cases for SetMaxDistance.
********************************************************************************/
HRESULT DMTest_Buf_SetMinDistance_BoundaryCases(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
FLOAT fTestValues[] = {FLT_SMALL, 1, 2, 4, 8, 16, FLT_BIG};
DS3DLISTENER ds3dl;
char *szStrings[] = {"Silence", "sound at 1/16 volume", "sound at 1/8 volume", "sound at 1/4 volume", "sound at 1/2 volume", "sound at full volume", "sound at full volume"};



    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetMinDistance_BoundaryCases: eTestApply = %s", String(eTestApply));
    Log(FYILOGLEVEL, "Setting source at -16, 0, 0 (left of you), trying extreme values for SetMinDistance");

    //Set up the 3D Listener at 0, 0, 0, pointing forward too.
    ZeroMemory(&ds3dl, sizeof(ds3dl));
    ds3dl.dwSize                    = sizeof(ds3dl);
    ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
    ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
    ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
    ds3dl.vOrientFront              = make_D3DVECTOR(0, 0, 1);         //facing forward.
    ds3dl.vOrientTop                = make_D3DVECTOR(0, 1, 0);         //right side up
    ds3dl.vPosition                 = make_D3DVECTOR(0, 0, 0);         //at origin, behind the source.
    ds3dl.vVelocity                 = make_D3DVECTOR(0, 0, 0);         //would be derivatives of positioning functions cos and sin, if we adjusted this.


    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MaxDistance to FLT_BIG.
    CHECKRUN(pSound->DSB_SetMaxDistance(FLT_BIG));

    //Set the source close, 16m to the left of ya.
    CHECKRUN(pSound->DSB_SetPosition(-16, 0, 0));
  
    //Play
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Iterate through test values.
    for (DWORD i=0; i<NUMELEMS(fTestValues)  && SUCCEEDED(hr); i++)
    {
        Log(FYILOGLEVEL, "Trying MinDistance = %g for 4 seconds.  You should hear %s", fTestValues[i], szStrings[i]);
        CHECKRUN(pSound->DSB_SetMinDistance(fTestValues[i]));
        Wait(4000);
    }

    CHECKRUN(pSound->DSB_Stop());
    ;
    return hr;
}




/********************************************************************************
We set the source at some point, then move MinDistance from 1/100 of that distance
to that distance.  The volume should increase from almost nothing to maximum.
********************************************************************************/
HRESULT DMTest_Buf_SetMinDistance_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
FLOAT fTestValues[] = {0.001f, 100.f, FLT_BIG};
FLOAT fMinDistance = 0.0;
DWORD i,j;
DWORD dwInc;
FLOAT fCurrentValue;
FLOAT fIncValue;
BOOL  bPlaying = FALSE;


        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetMinDistance_Listening: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MaxDistance to MAX, so we don't worry about it.
    CHECKRUN(pSound->DSB_SetMaxDistance(FLT_BIG));

    //100 increments.
    dwInc = 100;

    //for each loop, set source at x, then move MinDistance from 0->x.  The sound should smoothly increase over this period.
    for (i=0; i<NUMELEMS(fTestValues) && SUCCEEDED(hr); i++)
    {
        fIncValue = fTestValues[i] / (FLOAT)dwInc;
        fCurrentValue = 0.f;        
        CHECKRUN(pSound->DSB_SetPosition(fTestValues[i], 0, 0));
        Log(FYILOGLEVEL, "Setting source at           %8g, 0, 0.", fTestValues[i]);
        Log(FYILOGLEVEL, "inc'ing MinDistance from 0->%8g.  Sound should increase from silence->maximum.", fTestValues[i], fTestValues[i]);
        for (j = 0; j<=dwInc && SUCCEEDED(hr); j++)
        {
            if (j % 10 == 0)
                Log(FYILOGLEVEL, "MinDistance = %8g, %2.0f percent done", fCurrentValue, fCurrentValue / fTestValues[i] * 100);
            
            
            //Due to rounding errors, this value may exceed its target on the last iteration.  If this happens, clamp it and
            //  verify that it actually happened on the last iteration.
            fCurrentValue+=fIncValue;
            if (fCurrentValue > FLT_BIG)
            {
                fCurrentValue = FLT_BIG;
                if (j!=dwInc)
                {
                    Log(ABORTLOGLEVEL, "DMTest_Buf_SetMinDistance_Listening Test Error: Had to clamp our test value on iteration %d/%d", j, dwInc);
                    hr = E_FAIL;
                }

            }

            CHECKRUN(pSound->DSB_SetMinDistance(fCurrentValue));

            //Play the source if we haven't started already.  
            if (!bPlaying)
            {
                CHECKRUN(pSound->DSB_SetCurrentPosition(0));
                CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
                bPlaying = TRUE;
            }

            Wait(50);
        }
    }

    CHECKRUN(pSound->DSB_Stop());
    ;
    return hr;
}






/********************************************************************************
This does not use the wrapper class, since the wrapper state determines what
"mode" is used and whether CommitDeferredSettings is called or not.

This test sets a source to our right, then moves the listener across it in
the 3 different modes.  In each mode, the user should hear something different
as described in the pszStrings array below.
********************************************************************************/
HRESULT DMTest_Buf_SetMode(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr= S_OK;
LPDIRECTSOUND       pDS  = NULL;
LPDIRECTSOUNDBUFFER pDSB = NULL;
DWORD dwModes[] = {DS3DMODE_NORMAL,
                 DS3DMODE_HEADRELATIVE,
                 DS3DMODE_DISABLE};

char *pszStrings[] =
                 {"DS3DMODE_NORMAL:       Sound will move from right to left",
                  "DS3DMODE_HEADRELATIVE: Sound will come from the right.",
                  "DS3DMODE_DISABLE:      Sound will come from the center"};

DWORD i = 0;
LONG  j = 0;
DWORD dwTotalTime = 5000;

DWORD dwActualApply = 0;
BOOL bCommit = FALSE;
BOOL bPlaying = FALSE;

    CHECKRUN(pSound->GetDirectSound(&pDS));
    CHECKRUN(pSound->GetDirectSoundBuffer(&pDSB));

    //This is a special case where we're actually testing the mode, and not wrapping it. 
    //  We can't use the wrapper class for this one.
    //Decide the process by which to test this.
    switch (eTestApply)
    {
        case TESTAPPLY_IMMEDIATE:
            dwActualApply = DS3D_IMMEDIATE;
            bCommit = FALSE;
            Log(FYILOGLEVEL, "-->Calling DMTest_Buf_SetMode with TESTAPPLY_IMMEDIATE");
            break;
        case TESTAPPLY_DEFERRED_UPDATE:
            dwActualApply = DS3D_DEFERRED;
            bCommit = TRUE;
            Log(FYILOGLEVEL, "-->Calling DMTest_Buf_SetMode with TESTAPPLY_DEFERRED_UPDATE");
            break;
        case TESTAPPLY_DEFERRED_NOUPDATE:
            dwActualApply = DS3D_DEFERRED;
            bCommit = FALSE;
            Log(FYILOGLEVEL, "-->Calling DMTest_Buf_SetMode with TESTAPPLY_DEFERRED_NOUPDATE");
            break;
        default:
           Log(FYILOGLEVEL, "Error!!!  invalid value passed to DMTest_Buf_SetMode");
           break;
            
    }

    //Source to our right.
    CHECKRUN(pDSB->SetPosition(10, 0, 0, DS3D_IMMEDIATE));
    
    //Move the listener across the sound.
    for (i=0; i<NUMELEMS(dwModes); i++)
    {
        Log(FYILOGLEVEL, pszStrings[i]);
        if (TESTAPPLY_DEFERRED_NOUPDATE == eTestApply)
           Log(FYILOGLEVEL, "not calling CommitDeferredSettings - aforementioned change should not apply!!");
        
        //here we either commit or not.
        CHECKRUN(pDSB->SetMode(dwModes[i], dwActualApply));

        bPlaying = FALSE;
        for (j = 0; j<=20 && SUCCEEDED(hr); j++)
        {
            CHECKRUN(pDS->SetPosition((FLOAT)j, 0, 0, dwActualApply));
            if (bCommit)
            {
                CHECKRUN(pDS->CommitDeferredSettings());
            }

            if (!bPlaying)
            {
                //CHECKRUN(pDSB->Play(0, 0, DSBPLAY_LOOPING));
                bPlaying = TRUE;
            }
            Wait(dwTotalTime / 20);
        }

        //CHECKRUN(pDSB->Stop());

    }


    //Release buffers
    RELEASE(pDSB);
    RELEASE(pDS);

    return hr;
};



/********************************************************************************
So we want to test the following vectors with negative numbers.
a) testing 1, FLT_BIG, and FLT_SMALL.
b) testing negative numbers.

Example bunch -0- test cases.

{FLT_BIG, 0      , 0      },
{0      , FLT_BIG, 0      },
{0      , 0      , FLT_BIG},
{FLT_BIG, FLT_BIG, 0      },
{FLT_BIG, 0      , FLT_BIG},
{0      , FLT_BIG, FLT_BIG},
{FLT_BIG, FLT_BIG, FLT_BIG},

********************************************************************************/
HRESULT DMTest_Buf_SetPosition_BoundaryCases(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DWORD dwIterator = 0;

//Test values.
//FLOAT fTestValues[] = {1, 10, 100, FLT_BIG, FLT_BIG, FLT_SMALL, -1, -10, -100, -FLT_BIG, -FLT_BIG, -FLT_SMALL};
FLOAT fTestValues[] = {1, 10, 100, FLT_BIG, FLT_SMALL, -1, -10, -100, -FLT_BIG, -FLT_SMALL};
DWORD dwTestValue = 0;

D3DVECTOR v = {0};
D3DVECTOR vBufPos = {0};



        Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetPosition_BoundaryCases: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.
    for (dwTestValue = 0; dwTestValue < NUMELEMS(fTestValues)  && SUCCEEDED(hr); dwTestValue++)
    {
        for (dwIterator = 0; dwIterator < 8; dwIterator ++)
        {
            vBufPos.x = dwIterator & (1 << 0) ? fTestValues[dwTestValue] : 0;
            vBufPos.y = dwIterator & (1 << 1) ? fTestValues[dwTestValue] : 0;
            vBufPos.z = dwIterator & (1 << 2) ? fTestValues[dwTestValue] : 0;

            CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));
            Log(FYILOGLEVEL, "SetPosition(%g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
            Wait(100);
        }
    }

    Log(FYILOGLEVEL, "Stopping Sound");
    ;
    return hr;
};





/********************************************************************************
Rotates the buffer around the listener about each axis.
********************************************************************************/
HRESULT DMTest_Buf_SetPosition_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
BOOL bPlaying = FALSE;
DWORD dwAngle;
float fAngle;
D3DVECTOR vBufPos = {0};
DWORD dwAxis = 0;  //x=0, y=1, z=2.
FLOAT fPosition[2]; //this will be x,y, x,z, or y,z depending on dwAxis.
char *pszAxes[] = {"x", "y", "z"};
DWORD i = 0;

Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetPosition_Listening: eTestApply = %s", String(eTestApply));

//Make subsequent changes behave according to the specifications of the calling function.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
bPlaying = FALSE;
for (dwAxis = 0; dwAxis < 3  && SUCCEEDED(hr); dwAxis++)
{

    Log(FYILOGLEVEL, "Rotating source 360 degrees around %s axis", pszAxes[dwAxis]);
    for (dwAngle = 0; dwAngle <= 360; dwAngle++)
    {
        fAngle = float(((float)dwAngle) * PI / 180.0f);
        fPosition[0] = (float)cos(fAngle);
        fPosition[1] = (float)sin(fAngle);

        //Fill the position vector according to axis.
        for (i = 0; i<2; i++)
        {
            switch ((dwAxis + 1 + i) %3)
            {
                case 0: 
                    vBufPos.x = fPosition[i];
                    break;
                case 1: 
                    vBufPos.y = fPosition[i];
                    break;
                case 2: 
                    vBufPos.z = fPosition[i];
                    break;
                default:
                    Log(FYILOGLEVEL, "Test Error, see danhaff!!!!");
                    break;

            }
        }

        //Set this position.
        CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));
        Wait(5000 / 360);                  //want to spend 5s; going through loop 180 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            Log(FYILOGLEVEL, "Pos: %-8g, %-8g, %-8g.  Listener relative to source: %3d degrees.  %2d percent finished w/sweep", vBufPos.x, vBufPos.y, vBufPos.z, dwAngle, dwAngle * 100 / 360);

    }
}

CHECKRUN(pSound->DSB_Stop());
;
return hr;
}




/********************************************************************************
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
HRESULT DMTest_Buf_SetVelocity(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
BOOL bPlaying = FALSE;
DWORD dwVelocity = 0;
D3DVECTOR vBufPos = {0};
D3DVECTOR vBufVel = {0};
DWORD dwAxis = 0;  //x=0, y=1, z=2.
FLOAT fPosition[2]; //this will be x,y, x,z, or y,z depending on dwAxis.
char *pszAxes[] = {"x", "y", "z"};
DWORD i = 0;
FLOAT fTestVelocity = 375.f; //speed of sound, in m/s
FLOAT fTestVal = 0.f;

Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVelocity: eTestApply = %s", String(eTestApply));

//Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
bPlaying = FALSE;
for (dwAxis = 0; dwAxis < 3  && SUCCEEDED(hr); dwAxis++)
{

    Log(FYILOGLEVEL, "Testing doppler along %s axis", pszAxes[dwAxis]);

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set the position at 1 along the designated axis.
    vBufPos = make_D3DVECTOR(0, 0, 0);
    CHECK(DMSetComponent(&vBufPos, dwAxis, 1));
    Log(FYILOGLEVEL, "Setting position to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound.
    Log(FYILOGLEVEL, "Here is the default pitch of the sound for 2 seconds.");
    CHECKRUN(pSound->DSB_SetCurrentPosition(0));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    Wait(2000);

    //Fill the vector components not matching test axis - pitch shouldn't change since vel is perpendicular.
    for (i = 0; i<2 && SUCCEEDED(hr); i++)
    {
        Log(FYILOGLEVEL, "Setting %s component of velocity vector to %g for 3s -> expect NO CHANGE in pitch of sound!!", pszAxes[(dwAxis + 1 + i) %3], -fTestVelocity);
        vBufVel = make_D3DVECTOR(0, 0, 0);
        CHECK(DMSetComponent(&vBufVel, (dwAxis + 1 + i) %3, -fTestVelocity));
        CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
        Wait(3000);
    }

   
    //Verify doppler works along test axis.
    if (SUCCEEDED(hr))
    {
        Log(FYILOGLEVEL, "Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
        vBufVel = make_D3DVECTOR(0, 0, 0);
        CHECK(DMSetComponent(&vBufVel, dwAxis, -fTestVelocity));
        CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
        Wait(3000);
    }

    
    FLOAT fDopplerFactor[] = {1, 2};
    for (i=0; i<NUMELEMS(fDopplerFactor) && SUCCEEDED(hr); i++)
    {    
        //Set doppler factor.
        Log(FYILOGLEVEL, "Setting Doppler Factor to %g", fDopplerFactor[i]);
        CHECKRUN(pSound->DS_SetDopplerFactor(fDopplerFactor[i]));

        //Increase doppler along test axis, verify increase in pitch.
        vBufVel = make_D3DVECTOR(0, 0, 0);
        Log(FYILOGLEVEL, "Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
        for (fTestVal = 0; fTestVal>=-fTestVelocity; fTestVal--)
        {
            CHECK(DMSetComponent(&vBufVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
            Wait(5);
        }

        //Decrease doppler.
        vBufVel = make_D3DVECTOR(0, 0, 0);
        Log(FYILOGLEVEL, "Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to decrease", pszAxes[dwAxis], fTestVelocity);
        for (fTestVal = 0; fTestVal<=fTestVelocity; fTestVal++)
        {
            CHECK(DMSetComponent(&vBufVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
            Wait(5);
        }
    }

    CHECKRUN(pSound->DS_SetDopplerFactor(1));

    //Set doppler to max.
    vBufVel = make_D3DVECTOR(0, 0, 0);
    Log(FYILOGLEVEL, "Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be high", pszAxes[dwAxis], -FLT_BIG);
    CHECK(DMSetComponent(&vBufVel, dwAxis, -FLT_BIG));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    Wait(3000);

    //Set doppler to min.
    vBufVel = make_D3DVECTOR(0, 0, 0);
    Log(FYILOGLEVEL, "Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be low", pszAxes[dwAxis], FLT_BIG);
    CHECK(DMSetComponent(&vBufVel, dwAxis, FLT_BIG));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    Wait(3000);

}//end for dwAxis = 1 to 3.

CHECKRUN(pSound->DSB_Stop());
;
return hr;
}



/********************************************************************************
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
/*
HRESULT DMTest_INFINITY_Bug(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
D3DVECTOR vBufPos = {0};
D3DVECTOR vBufVel = {0};

Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVelocity: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Set doppler to min infinity.
    vBufVel = make_D3DVECTOR(INFINITY, 0, 0);
    Log(FYILOGLEVEL, "Setting velocity to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));


    //Set the position at 1 along the designated axis.
    vBufPos = make_D3DVECTOR(0, 1, 0);
    Log(FYILOGLEVEL, "Setting position to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));


CHECKRUN(pSound->DSB_Stop());
return hr;
}
*/



/********************************************************************************
********************************************************************************/
HRESULT DMTest_Buf_SetFrequency_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
//Test values.
DWORD dwTestValues[] = {DSBFREQUENCY_MIN, 24000, 48000,  96000, DSBFREQUENCY_MAX, DSBFREQUENCY_ORIGINAL};
DWORD dwTestValue = 0;

    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetFrequency_Listening");

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  
    for (dwTestValue = 0; dwTestValue < NUMELEMS(dwTestValues)  && SUCCEEDED(hr); dwTestValue++)
    {
            CHECKRUN(pSound->DSB_SetFrequency(dwTestValues[dwTestValue]));
            Log(FYILOGLEVEL, "SetFrequency(%d)", dwTestValues[dwTestValue]);
            Wait(1000);
    }

    Log(FYILOGLEVEL, "Stopping Sound");
    CHECKRUN(pSound->DSB_SetFrequency(DSBFREQUENCY_ORIGINAL));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT DMTest_Buf_SetFrequency_Range(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DWORD dwTestValue = 0;

    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetFrequency_Range");

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.
    for (dwTestValue = DSBFREQUENCY_MIN; dwTestValue < DSBFREQUENCY_MAX && SUCCEEDED(hr); dwTestValue++)
    {
        CHECKRUN(pSound->DSB_SetFrequency(dwTestValue));
        if (dwTestValue % 10000 == 0)
        {
            Log(FYILOGLEVEL, "SetFrequency(%d)", dwTestValue);
        }
    }

    Log(FYILOGLEVEL, "Stopping Sound");
    CHECKRUN(pSound->DSB_SetFrequency(DSBFREQUENCY_ORIGINAL));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT DMTest_Buf_SetVolume_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
//Test values.
DWORD dwTestValues[] = {0, -500, -1000, -2000, -5000, -10000};
DWORD dwTestValue = 0;

    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVolume_Listening");

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  
    for (dwTestValue = 0; dwTestValue < NUMELEMS(dwTestValues)  && SUCCEEDED(hr); dwTestValue++)
    {
            CHECKRUN(pSound->DSB_SetVolume(dwTestValues[dwTestValue]));
            Log(FYILOGLEVEL, "SetVolume(%d)", dwTestValues[dwTestValue]);
            Wait(1000);
    }

    Log(FYILOGLEVEL, "Stopping Sound");
    CHECKRUN(pSound->DSB_SetVolume(0));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT DMTest_Buf_SetVolume_Range(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DWORD dwTestValue = 0;

    Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVolume_Range");

    //Play the sound!!
    Log(FYILOGLEVEL, "Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.
    for (dwTestValue = DSBVOLUME_MIN; dwTestValue < DSBVOLUME_MAX && SUCCEEDED(hr); dwTestValue++)
    {
        CHECKRUN(pSound->DSB_SetVolume(dwTestValue));
        if (dwTestValue % 1000 == 0)
        {
            Log(FYILOGLEVEL, "SetVolume(%d)", dwTestValue);
        }
    }

    Log(FYILOGLEVEL, "Stopping Sound");
    CHECKRUN(pSound->DSB_SetVolume(0));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};



/********************************************************************************
********************************************************************************/
/*

#define NUMCHANNELS 6
LPSTR szChannel[NUMCHANNELS] = {"Front Left", "Front Right", "Front Center", "Low Freq", "Back Left", "Back Right"};


static void SetAllVolumes(LPDSCHANNELVOLUME pdscv, LONG lVolume)
{
    DWORD i = 0;
    ZeroMemory(pdscv, sizeof(DSCHANNELVOLUME));
    pdscv->dwChannelMask = 0x3F;     //All 6 channels.
    for (i=0; i<NUMCHANNELS; i++)
        pdscv->alVolume[i] = lVolume;
};


HRESULT DMTest_Buf_SetChannelVolume_Channel_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DSCHANNELVOLUME dscv = {0};
DWORD i = 0;
DWORD j = 0;

    CHECK   (Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVolume_Listening"));

    //Play the sound!!
    CHECK   (Log(FYILOGLEVEL, "Playing Sound"));
    CHECK   (SetAllVolumes(&dscv, -10000));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    CHECKRUN(pSound->DSB_SetChannelVolume(&dscv));

    //Try all these values.  
    for (i = 0; i < NUMCHANNELS  && SUCCEEDED(hr); i++)
    {
        for (j = 0; j < NUMCHANNELS && SUCCEEDED(hr); j++)
        {
            CHECK  (SetAllVolumes(&dscv, -10000));
            CHECK  (dscv.alVolume[i] = 0);
            CHECK  (dscv.alVolume[j] = 0);
            CHECKRUN(pSound->DSB_SetChannelVolume(&dscv));
            if (i!=j)
            {
                CHECK(Log(FYILOGLEVEL, "Turned on channels %s and %s only", szChannel[i], szChannel[j]));
            }
            else
            {
                CHECK(Log(FYILOGLEVEL, "Turned on %s channel only", szChannel[i]));
            }
            CHECKRUN(Wait(3000));
        }
    }

    CHECK   (Log(FYILOGLEVEL, "Stopping Sound"));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};



HRESULT DMTest_Buf_SetChannelVolume_Mask_Listening(BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative)
{
HRESULT hr = S_OK;
DSCHANNELVOLUME dscv = {0};
DWORD i = 0;
DWORD j = 0;

    CHECK   (Log(FYILOGLEVEL, "\n----- DMTest_Buf_SetVolume_Listening"));

    //Play the sound!!
    CHECK   (Log(FYILOGLEVEL, "Playing Sound"));
    CHECK   (SetAllVolumes(&dscv, -10000));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    CHECKRUN(pSound->DSB_SetChannelVolume(&dscv));

    //Try all these values.  
    for (i = 0; i < NUMCHANNELS  && SUCCEEDED(hr); i++)
    {
        for (j = 0; j < NUMCHANNELS && SUCCEEDED(hr); j++)
        {
            CHECK   (SetAllVolumes(&dscv, 0));
            CHECK   (dscv.dwChannelMask  = 1 << i);
            CHECK   (dscv.dwChannelMask |= 1 << j);
            CHECKRUN(pSound->DSB_SetChannelVolume(&dscv));
            if (i!=j)
            {
                CHECK(Log(FYILOGLEVEL, "Turned on channels %s and %s only", szChannel[i], szChannel[j]));
            }
            else
            {
                CHECK(Log(FYILOGLEVEL, "Turned on %s channel only", szChannel[i]));
            }

            CHECKRUN(Wait(3000));
        }
    }

    CHECK   (Log(FYILOGLEVEL, "Stopping Sound"));
    CHECKRUN(pSound->DSB_Stop());
    return hr;
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath1.cpp ===
#include "globals.h"
#include "AudioPath_GetObjectInPath1.hpp"

#define INTERFACE_NAME CtIDirectMusicAudioPath

HRESULT AudioPath_GetObjectInPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
HRESULT AudioPath_GetObjectInPath_Valid_GetAll(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
HRESULT AudioPath_GetObjectInPath_Valid_Traverse(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
HRESULT AudioPath_GetObjectInPath_Valid_SimplyGetBuffer(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function AudioPath_GetObjectInPath())");
    DMTEST_EXECUTE(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_PERFORMANCE, (GUID *)&CLSID_DirectMusicPerformance, (GUID *)&IID_IDirectMusicPerformance8));                                             
    DMTEST_EXECUTE(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, DMUS_APATH_SHARED_STEREO,           DMUS_PATH_PERFORMANCE, (GUID *)&CLSID_DirectMusicPerformance, (GUID *)&IID_IDirectMusicPerformance8));                                             
    DMTEST_EXECUTE(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    DMTEST_EXECUTE(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, DMUS_APATH_DYNAMIC_MONO,            DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    return hr;
};




/********************************************************************************
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_Valid_Traverse(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPathType, DWORD dwPathDefinition)
{
    HRESULT hr = S_OK;
    PATH_DEFINITION *pPathDefinition = (PATH_DEFINITION *)dwPathDefinition;
    DMTEST_EXECUTE(tmplTraverseStandard<INTERFACE_NAME>(ptPerf8, dwPathType,  pPathDefinition));
    return hr;
};





/********************************************************************************
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_Valid_GetAll(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    DWORD dwPerfPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_APATH_DYNAMIC_3D, DMUS_APATH_DYNAMIC_MONO, DMUS_APATH_SHARED_STEREO};
    GUID *Perf_CLSIDs[] = 
    {
        (GUID *)&CLSID_DirectMusicPerformance,
        (GUID *)&GUID_All_Objects,
        (GUID *)&GUID_NULL,
    };
    GUID *Perf_IIDs[] = 
    {
        (GUID *)&IID_IDirectMusicPerformance,
        (GUID *)&IID_IUnknown,
    };

    DWORD dwBufPaths[] = {DMUS_APATH_DYNAMIC_3D, DMUS_APATH_DYNAMIC_MONO};
    GUID *Buf_CLSIDs[] = 
    {
        (GUID *)&GUID_All_Objects,
        (GUID *)&GUID_NULL,
    };
    GUID *Buf_IIDs[] = 
    {
        (GUID *)&GUID_NULL,
    };

    DWORD i,j,k;
    //Make sure you can get a performance from all the paths with all GUIDs and all IIDs possible.
    for (i=0; i<AMOUNT(dwPerfPaths); i++)
    {
        for (j=0; j<AMOUNT(Perf_CLSIDs); j++)
        {
            for (k=0; k<AMOUNT(Perf_IIDs); k++)
            {
                CHECKRUN(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, dwPerfPaths[i], DMUS_PATH_PERFORMANCE, Perf_CLSIDs[j], Perf_IIDs[k]));                                             

                if (FAILED(hr))
                {
                    Log(ABORTLOGLEVEL, "Couldn't obtain %s, %s from DMUS_PATH_PERFORMANCE on %s", tdmXlatGUID(*Perf_CLSIDs[j]), tdmXlatGUID(*Perf_IIDs[k]), dmthXlatDMUS_APATH(dwPerfPaths[i]));
                    return hr;
                }
                else
                {
                    Log(FYILOGLEVEL, "Obtained %s, %s from DMUS_PATH_PERFORMANCE on %s", tdmXlatGUID(*Perf_CLSIDs[j]), tdmXlatGUID(*Perf_IIDs[k]), dmthXlatDMUS_APATH(dwPerfPaths[i]));
                }


            }
        }
    }


    //Make sure you can get a buffer from all the paths with all GUIDs and all IIDs possible.
    for (i=0; i<AMOUNT(dwBufPaths); i++)
    {
        for (j=0; j<AMOUNT(Buf_CLSIDs); j++)
        {
            for (k=0; k<AMOUNT(Buf_IIDs); k++)
            {
                CHECKRUN(tmplGetObjectInPath<INTERFACE_NAME>(ptPerf8, dwBufPaths[i], DMUS_PATH_BUFFER, Buf_CLSIDs[j], Buf_IIDs[k]));                                             
                if (FAILED(hr))
                {
                    Log(ABORTLOGLEVEL, "Couldn't obtain %s, %s from DMUS_PATH_BUFFER on %s", tdmXlatGUID(*Buf_CLSIDs[j]), tdmXlatGUID(*Buf_IIDs[k]), dmthXlatDMUS_APATH(dwBufPaths[i]));
                    return hr;
                }
                else
                {
                    Log(ABORTLOGLEVEL, "Obtained %s, %s from DMUS_PATH_BUFFER on %s", tdmXlatGUID(*Buf_CLSIDs[j]), tdmXlatGUID(*Buf_IIDs[k]), dmthXlatDMUS_APATH(dwBufPaths[i]));
                }
            }
        }
    }


    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_Valid_SimplyGetBuffer(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;    
    DMTEST_EXECUTE(tmplGetBuffer<INTERFACE_NAME>(ptPerf8, DMUS_APATH_DYNAMIC_3D));
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_SetPitch.hpp ===
#pragma once
 
#include "globals.h"


/********************************************************************************
IDirectMusicAudioPath::SetPitch()

HISTORY:
    Updated     04/05/00      danhaff - created.
********************************************************************************/
template <class T>
HRESULT tmplSetPitch_BVT_Direct(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2, T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    T   *ptInterface= NULL;
    long                        lValues[] = {-0x2000, -100, -1, 0, 1, 100, 0x1FFF};
    DWORD                       i = 0;


    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_DYNAMIC_MONO));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptInterface));

    for (i=0; i<AMOUNT(lValues) && hr==S_OK; i++)
    {
        Log(FYILOGLEVEL, "Calling SetPitch(%d), playing for 2 seconds", lValues[i]);
        CHECKRUN(ptInterface->SetPitch(lValues[i], 0));
	    CHECKRUN(Wait(2000));
    }

   SAFE_RELEASE(ptInterface);
   return hr;
    
};




/********************************************************************************
IDirectMusicAudioPath::SetVolume()

HISTORY:
    Updated     04/05/00      danhaff - created.

//Ramp from 
********************************************************************************/
#define DSBPITCH_MIN -0x2000
#define DSBPITCH_MAX  0x1FFF


struct PITCHRAMP
{
LONG lFrom;
LONG lTo;
DWORD dwTime;
};


template <class T>
HRESULT tmplSetPitch_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwRange, T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    T     *ptInterface          = NULL;
    DWORD                       i = 0, j=0;
    LONG lRange = (LONG)dwRange;

    LONG lValue[3]    = {0};    
    lValue[0] = -lRange < DSBPITCH_MIN ? DSBPITCH_MIN : -lRange;
    lValue[2] =  lRange > DSBPITCH_MAX ? DSBPITCH_MAX : lRange;

    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_DYNAMIC_MONO));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptInterface));

    
    for (i=0; i<AMOUNT(lValue) && SUCCEEDED(hr); i++)
        for (j=0; j<AMOUNT(lValue) && SUCCEEDED(hr); j++)
        {
            Log(FYILOGLEVEL, "Test %d/%d", i * AMOUNT(lValue) + j, AMOUNT(lValue) * AMOUNT(lValue));
            Log(FYILOGLEVEL, "Playing at lPitch=%d for 2 seconds, ramping from %d -> %d over %ums for 5 seconds, playing at %d for 5 seconds.",
                              lValue[i],
                              lValue[i],
                              lValue[j],
                              dwTime,
                              lValue[j]
                              );



            //Setting initial Pitch.
            CHECKRUN(ptInterface->SetPitch(lValue[i], 0));
            Log(FYILOGLEVEL, "SetPitch(%d, IMMEDIATE), waiting 2s", lValue[i]);
	        Wait (2000);

            //Setting Pitch curve.
            CHECKRUN(ptInterface->SetPitch(lValue[j], dwTime));
            Log(FYILOGLEVEL, "SetPitch(%d, %u), waiting 5s during ramp", lValue[j], dwTime);
	        Wait (5000);

            //Setting final Pitch.
            CHECKRUN(ptInterface->SetPitch(lValue[j], 0));
            Log(FYILOGLEVEL, "SetPitch(%d, IMMEDIATE), waiting 5s", lValue[j]);
	        Wait (5000);
        }

    SAFE_RELEASE(ptInterface);
    return hr;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath_DSBTestFunc.h ===
#pragma once
#include "help_buffer3D.h"

using namespace DMBUFFER;


//3D Mixin Tests
HRESULT DMTest_Buf_SetAllParameters                       (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetConeAngles                          (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetConeOrientation_BoundaryCases       (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetConeOrientation_Listening           (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetConeOutsideVolume                   (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetMaxDistance_BoundaryCases           (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetMaxDistance_InsideSource            (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetMinDistance_BoundaryCases           (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetMinDistance_Listening               (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetMode                                (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetPosition_BoundaryCases              (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetPosition_Listening                  (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetVelocity                            (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
//HRESULT DMTest_INFINITY_Bug                               (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);

//2D Mixin Tests
HRESULT DMTest_Buf_SetFrequency_Listening                 (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetFrequency_Range                     (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetVolume_Listening                    (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetVolume_Range                        (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetChannelVolume_Channel_Listening     (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
HRESULT DMTest_Buf_SetChannelVolume_Mask_Listening        (BUFFER3D *pSound, TestApplies eTestApply, D3DVECTOR vRelative);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath_Invalid.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "AudioPath_GetObjectInPath_Invalid.hpp"


//Called functions.
HRESULT AudioPath_GetObjectInPath_NULLppvObject(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwStage);
HRESULT AudioPath_GetObjectInPath_InvalidScenarios(CtIDirectMusicPerformance8 *ptPerf8, LPSTR szAudPath, LPSTR szSegment, DWORD dwStage, GUID *pCLSID, GUID *pIID, DWORD dwBuffer, DWORD dwIndex);


/*******************************************************************************
Main test function for AudioPath::GetObjectInPath
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_Invalid(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{

HRESULT hr = S_OK;
#define TEST AudioPath_GetObjectInPath_InvalidScenarios

    // ************
    //GUID and IIDs
    // ************
        //---------Performance Scenarios-------------
         //null IIDs                                                    
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_PERFORMANCE,   (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_PERFORMANCE,   (GUID *)&GUID_NULL,        (GUID *)&GUID_NULL,0, 0));

        //invalid CLSIDs
//        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_PERFORMANCE,   (GUID *)&CLSID_DirectMusicSegment,  (GUID *)&IID_IUnknown, 0, 0));

        //invalid IIDs
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia,  DMUS_PATH_PERFORMANCE,  (GUID *)&GUID_All_Objects,               (GUID *)&IID_IDirectMusicSegment,         0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia,  DMUS_PATH_PERFORMANCE,  (GUID *)&GUID_All_Objects,               (GUID *)&GUID_Random,                     0, 0));
    
        //---------Buffer Scenarios-------------
        //NULL GUIDs
        
        //BUGBUG: Works anyway.  Should it?
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_NULL,          (GUID *)&GUID_NULL, 0, 0 ));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects,   (GUID *)&GUID_NULL, 0, 0 ));

        //Invalid IIDs
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&GUID_Random,     0, 0    ));



        //DMTEST_EXECUTE(TEST(ptPerf8, "GUIDs_MixinDMOsA.aud", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IDirectSoundFXChorus, 0, 0    )));


        //---------Buffer DMO Scenarios -------------
//        //NULL GUIDs
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_NULL,         (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_NULL,         (GUID *)&GUID_NULL,                      0, 0},
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_CHORUS,         (GUID *)&GUID_NULL,      0, 0},
//
//        //Invalid CLSIDs
//        //IID (Chorus) matches index (0) but CLSID is wrong (Compressor).
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_COMPRESSOR,  (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//        //IID (Chorus) matches index (0) but CLSID is wrong (Random).
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_Random,                    (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//
//
//        //Invalid IIDs
//        //CLSID (Distortion) matches index (2) but IID is wrong (Chorus).
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_DISTORTION,  (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//
//        //IID (echo) matches index (2) but GUID is wrong (Random).
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_Random,                    (GUID *)&IID_IDirectSoundFXDistortion,   0, 0},
//
//        //IID is soundbuffer
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_DISTORTION,  (GUID *)&IID_IDirectSoundBuffer,         0, 0},
//
//        //Invalid index... (doesn't really belong here but oh well).
//        //IID matches CLSID but neither of the match the index.
//        {L"GUIDs_SinkinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_CHORUS,      (GUID *)&IID_IDirectSoundFXChorus,       0, 1},
//        
//
//        //---------Mixin Buffer Scenarios -------------
//        
//        //NULL GUIDs
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_NULL,                 (GUID *)&GUID_NULL,                  0, 0},
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_All_Objects,          (GUID *)&GUID_NULL,                  0, 0},
//
//        //Invalid IIDs
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_All_Objects,          (GUID *)&IID_IDirectSoundNotify,     0, 0},
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_All_Objects,          (GUID *)&IID_IPersist,               0, 0},
//
//        //wrong stage for this, otherwise this would work.
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_All_Objects,          (GUID *)&IID_IDirectSoundFXFlanger,  0, 0},
//
//        //Invalid combos (invalid cuz we're not asking for DMOs)
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_FLANGER, (GUID *)&IID_IDirectSoundFXFlanger, 0, 0},
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_GARGLE,  (GUID *)&IID_IDirectSoundFXGargle,  0, 0},
//
//        //Shouldn't be able to get 3D interface from a MIXIN buffer.
//        {L"GUIDs_MixinDMOsB.aud", L"Test.mid", (GUID *)&GUID_All_Objects,          (GUID *)&IID_IDirectSound3DBuffer,   0, 0},
//        
//
//    
//        //---------Mixin Buffer DMO Scenarios -------------
//
//        //NULL GUIDs
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_NULL,         (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_NULL,         (GUID *)&GUID_NULL,                      0, 0},
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_CHORUS,         (GUID *)&GUID_NULL,      0, 0},
//
//        //Invalid CLSIDs
//        //IID (Chorus) matches index (0) but CLSID is wrong (Distortion).
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_DISTORTION,  (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//        //IID (Chorus) matches index (0) but CLSID is wrong (Random).
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_Random,                    (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//
//
//        //Invalid IIDs
//        //CLSID (echo) matches index (0) but IID is wrong (Chorus).
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_DISTORTION,  (GUID *)&IID_IDirectSoundFXChorus,       0, 0},
//
//        //IID (echo) matches index (1) but CLSID is wrong (Random).
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_Random,                    (GUID *)&IID_IDirectSoundFXCompressor,   0, 0},
//
//        //IID is soundbuffer
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_COMPRESSOR,  (GUID *)&IID_IDirectSoundBuffer,         0, 0},
//
//        //Invalid index... (doesn't really belong here but oh well).
//        //IID matches CLSID but neither of the match the index.
//        {L"GUIDs_MixinDMOsA.aud", L"Test.mid", (GUID *)&GUID_DSFX_STANDARD_CHORUS,      (GUID *)&IID_IDirectSoundFXChorus,       0, 1},
//    
//
//
    // ***************
    // Invalid dwStage 
    // ***************
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 0, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 1, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 2, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 4, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 5, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 8, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, 0xFFFFFFFF, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown,0, 0));

    // ****************
    //  TODO: Add more tests when we get DMOs.
    // Invalid dwBuffer    
    // ****************

        //Buffers 0 and 1 should work on this path; two shouldn't.
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 2, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREOPLUSREVERB", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 0xFFFFFFFF, 0));

        //Buffer1 shouldn't work on these paths.
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREO", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 1, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_DYNAMIC_MONO", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 1, 0));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_DYNAMIC_3D", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 1, 0));


    // ****************
    // Invalid dwIndex
    // ****************
        //Index 1 shouldn't work on anything.
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_SHARED_STEREO", g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 0, 1));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_DYNAMIC_MONO",   g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 0, 0xFFFFFFFF));
        DMTEST_EXECUTE(TEST(ptPerf8, "DMUS_APATH_DYNAMIC_3D",     g_TestParams.szDefaultMedia, DMUS_PATH_BUFFER, (GUID *)&GUID_All_Objects, (GUID *)&IID_IUnknown, 0, 1));


    // ************
    //ppvObject 
    // ************
        //---------NULL ppvObject Scenarios -------------
        //DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_SEGMENT)); //Not for AudioPath
        //DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_AUDIOPATH));
        DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_PERFORMANCE));
        DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_BUFFER));
        //DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_BUFFER_DMO));
        //DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_MIXIN_BUFFER));
        //DMTEST_EXECUTE(AudioPath_GetObjectInPath_NULLppvObject(ptPerf8, DMUS_PATH_MIXIN_BUFFER_DMO));

    return hr;

};


/********************************************************************************
IDirectMusicAudioPath::GetObjectInPath()

HISTORY:
    Created 07/31/00      danhaff
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_InvalidScenarios(CtIDirectMusicPerformance8 *ptPerf8, LPSTR szAudPath, LPSTR szSegment, DWORD dwStage, GUID *pCLSID, GUID *pIID, DWORD dwBuffer, DWORD dwIndex)
{
    return templInvalidScenarios<CtIDirectMusicAudioPath>(ptPerf8, szAudPath, szSegment, dwStage, pCLSID, pIID, dwBuffer, dwIndex);
};


/********************************************************************************
tdmapthiNULLppvObject

HISTORY:
    Created 08/03/00      danhaff
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_NULLppvObject(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwStage)
{
    return templNULLppvObject<CtIDirectMusicAudioPath>(ptPerf8, dwStage);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_SetVolume.hpp ===
#pragma once
 
#include "globals.h"
#include "Help_Definitions.h"

/********************************************************************************
IDirectMusicAudioPath::SetVolume()

HISTORY:
    Updated     04/05/00      danhaff - created.
********************************************************************************/
template <class T>
HRESULT tmplSetVolume_Direct(CtIDirectMusicPerformance8* ptPerf8, T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    T     *ptInterface     = NULL;
    LONG                        lValues[] = {DSBVOLUME_MIN, DSBVOLUME_MAX, -1, -1000, -5000, -9999};
    DWORD                       i = 0;

    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_DYNAMIC_MONO));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptInterface));

    //MIN
    for (i=0; i<AMOUNT(lValues) && hr==S_OK; i++)
    {
        Log(FYILOGLEVEL, "Calling SetVolume(%d), playing for 2 seconds", lValues[i]);
        CHECKRUN(ptInterface->SetVolume(lValues[i], 0));
	    Wait (2000);
    }

   SAFE_RELEASE(ptInterface);
   return hr;
    
};




/********************************************************************************
IDirectMusicAudioPath::SetVolume()

HISTORY:
    Updated     04/05/00      danhaff - created.

//Ramp from 
********************************************************************************/
struct VOLUMERAMP
{
LONG lVolFrom;
LONG lVolTo;
DWORD dwTime;
};

template <class T>
HRESULT tmplSetVolume_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwAudioPath, T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    T     *ptInterface          = NULL;
    DWORD                       i = 0, j=0;


    LONG lValue[2]    = {DSBVOLUME_MIN, DSBVOLUME_MAX};

    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwAudioPath));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptInterface));

    
    for (i=0; i<2 && SUCCEEDED(hr); i++)
        for (j=0; j<2 && SUCCEEDED(hr); j++)
        {
            Log(FYILOGLEVEL, "Test %d/4", i * 2 + j);
            Log(FYILOGLEVEL, "Playing at %d for 2 seconds, ramping from %d -> %d over %ums for 5 seconds, playing at %d for 5 seconds.",
                              lValue[i],
                              lValue[i],
                              lValue[j],
                              dwTime,
                              lValue[j]
                              );



            //Setting initial volume.
            CHECKRUN(ptInterface->SetVolume(lValue[i], 0));
            Log(FYILOGLEVEL, "SetVolume(%d, IMMEDIATE), waiting 2s", lValue[i]);
	        Wait (2000);

            //Setting volume curve.
            CHECKRUN(ptInterface->SetVolume(lValue[j], dwTime));
            Log(FYILOGLEVEL, "SetVolume(%d, %u), waiting 5s during ramp", lValue[j], dwTime);
	        Wait (5000);

            //Setting final volume.
            CHECKRUN(ptInterface->SetVolume(lValue[j], 0));
            Log(FYILOGLEVEL, "SetVolume(%d, IMMEDIATE), waiting 5s", lValue[j]);
	        Wait (5000);
        }

    SAFE_RELEASE(ptInterface);
    return hr;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_SetVolume.cpp ===
/********************************************************************************
FILE:
    AudioPath_SetVolume.cpp

PURPOSE:
    Contains AudioPath test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "AudioPath_SetVolume.hpp"


#define INTERFACE_NAME CtIDirectMusicAudioPath

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT AudioPath_SetVolume_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return tmplSetVolume_Direct<INTERFACE_NAME>(ptPerf8);
};



/********************************************************************************
Valid test function.
*******************************************************************************/
HRESULT AudioPath_SetVolume_Valid_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwAudioPath)
{
    return tmplSetVolume_Ramp<INTERFACE_NAME>(ptPerf8, dwTime, dwAudioPath);
};



/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
HRESULT AudioPath_SetVolume_Valid_Ind(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD bShared)
{

HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath[2]          = {NULL};
CtIDirectMusicSegment8              *ptSegment8[2]      = {NULL};
CHAR *szFileName[2]               = {0};
DWORD i = 0;
DWORD dwScenario = 0; 
DWORD dwAudioPath = 0;

if (bShared)
    dwAudioPath = DMUS_APATH_SHARED_STEREOPLUSREVERB;
else
    dwAudioPath = DMUS_APATH_DYNAMIC_MONO;
    

//Load media.
MEDIAFILEDESC MediaFileDesc[]=
{
{"SGT/test.sgt",              "T:\\DMTest1",          COPY_IF_NEWER},
{"SGT/test2.sgt",             "T:\\DMTest1",          COPY_IF_NEWER},
{"DLS/Main1.DLS",             "T:\\DMTest1",          COPY_IF_NEWER},
{"WAV/Streaming10s.wav",      "T:\\WAV",    COPY_IF_NEWER},
{"WAV/PCM_ST_11_1.wav",       "T:\\WAV",    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));


if (!bWave)
{
    szFileName[0] = "T:\\DMTest1\\Test.sgt";
    szFileName[1] = "T:\\DMTest1\\Test2.sgt";
}
else
{
    szFileName[0] = "T:\\WAV\\Streaming10s.wav";
    szFileName[1] = "T:\\WAV\\PCM_ST_11_1.wav";
}


//Load up 1 or 2 segments.
for (i=0; i<2 && SUCCEEDED(hr); i++)
{
    //Load up media file.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(dwAudioPath,64,TRUE,&ptPath[i]));
    CHECKRUN(dmthLoadSegment(szFileName[i], &ptSegment8[i]));
}


//Play our segments for 3 seconds.
CHECKRUN(Log(FYILOGLEVEL, "Playing both segments for 3 seconds."));
for (i=0; i<2 && SUCCEEDED(hr); i++)
{


    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8[i],
                                0,
                                0,
                                i ? DMUS_SEGF_SECONDARY : 0,
                                __int64(0),
                                NULL,
                                0,
                                ptPath[i]));

    CHECKRUN(Log(FYILOGLEVEL, " Playing %s as %s segment.", szFileName[i], i ? "secondary " : "primary "));
}

//Path1: Playing
//Path2: Playing
CHECKRUN(Log(FYILOGLEVEL, " " ));
CHECKRUN(Log(FYILOGLEVEL, " Both segments should be audible."));
CHECKRUN(Wait(3000));

//Path1: Silent
//Path2: Playing
CHECKRUN(Log(FYILOGLEVEL, " " ));
CHECKRUN(Log(FYILOGLEVEL, " Silencing volume on audiopath 1"));
CHECKRUN(Log(FYILOGLEVEL, " Expected: "));
CHECKRUN(Log(FYILOGLEVEL, "    Path1: Silent" ));
CHECKRUN(Log(FYILOGLEVEL, "    Path2: Audible" ));
CHECKRUN(ptPath[0]->SetVolume(-10000, 0));
CHECKRUN(Wait(3000));


ptPerf8->StopEx(0, 0, 0);
CHECKRUN(Log(FYILOGLEVEL, "  Music should stop." ));
CHECKRUN(Log(FYILOGLEVEL, " " ));
CHECKRUN(Wait(1000));
//Release all items that might have been allocated.
for (i=0; i<2; i++)
{
    SAFE_RELEASE(ptSegment8[i]);
    SAFE_RELEASE(ptPath[i]);
}

return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_SetVolume_Invalid.cpp ===
/********************************************************************************
FILE:
    AUDIOPATH8.cpp

PURPOSE:
    Contains AudioPath test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_SetVolume_Invalid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{

    HRESULT hr = S_OK;
    CICMusic Music;
    CtIDirectMusicAudioPath *ptPath = NULL;

    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_DYNAMIC_MONO));

    CHECKRUN(Music.GetInterface(&ptPath));

    CHECKRUN(ptPath->SetVolume(-10001, 0));
    Log(FYILOGLEVEL, "Should have int3'd");

    CHECKRUN(ptPath->SetVolume(1, 0));
    Log(FYILOGLEVEL, "Should have int3'd");

    SAFE_RELEASE(ptPath);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_SetPitch.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
FILE:
    AudioPath_SetPitch.cpp

PURPOSE:
    Contains AudioPath test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "AudioPath_SetPitch.hpp"


#define INTERFACE_NAME CtIDirectMusicAudioPath

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT AudioPath_SetPitch_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function AudioPath_SetPitch()");
    DMTEST_EXECUTE(tmplSetPitch_BVT_Direct<INTERFACE_NAME>(ptPerf8, 0, 0));
    return hr;
};



/********************************************************************************
Valid test function.
*******************************************************************************/
HRESULT AudioPath_SetPitch_Valid_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwRange)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function AudioPath_SetPitch())");
    DMTEST_EXECUTE(tmplSetPitch_Ramp<INTERFACE_NAME>(ptPerf8, dwTime, dwRange));
    return hr;
};


/********************************************************************************
*******************************************************************************/
HRESULT AudioPath_SetPitch_Valid_Immediate(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
//CHAR *szSegmentName = "T:\\DMTest1\\wav\\GuitarStream1.wav";
CHAR *szSegmentName = "T:\\WAV\\Streaming10s.wav";
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;

MEDIAFILEDESC MediaFileDesc[] = {
                                {"WAV/Streaming10s.wav", "T:\\WAV",    COPY_IF_NEWER},
                                {TERMINATE}
                                };


    CHECKRUN(LoadMedia(MediaFileDesc));

    //Load
    CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment));
//    CHECKRUN(ptSegment->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_MONO, 16, TRUE, &ptPath));
    
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,NULL,0,ptPath));    
    Log(FYILOGLEVEL, "Playing %s for 1 second", PathFindFileName(szSegmentName));
    Wait(1000);
    Log(FYILOGLEVEL, "Calling SetPitch(-4800, 0), then playing for 2 more seconds");
    CHECKRUN(ptPath->SetPitch(-4800, 0));
    Wait(2000);
    Log(FYILOGLEVEL, "Calling SetPitch(0, 0), then playing for 15 more seconds.  You should hear me count to 10, then stop.");
    CHECKRUN(ptPath->SetPitch(0, 0));
    Wait(15000);

    //Stop the segment.
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    
    //Release everything.
    SAFE_RELEASE(ptSegment);        
    SAFE_RELEASE(ptPath);


return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\AudioPath_GetObjectInPath_Invalid.hpp ===
#pragma once 
#include "globals.h"
//#include "Utils.hpp"


/********************************************************************************
templNULLppvObject

HISTORY:
    Created 08/03/00      danhaff
********************************************************************************/
template <class T>
DWORD templNULLppvObject(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwStage, T* pDoNotUseDoNotRemove = NULL)
{
    HRESULT                     hr              = S_OK;
    CICMusic                    Music;
//    CtIDirectMusicTool     *    ptTool = NULL;
    IUnknown *pUnk      = NULL;
    T* ptInterface = NULL;

    //Init
//    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, "AllStages.aud"));  //TODO: Put this back in!!!
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));  
    CHECKRUN(Music.GetInterface(&ptInterface));
    //CHECKRUN(hr = PutToolInGraphIfNeeded(ptInterface,dwStage,&ptTool,NULL,NULL));

    //First try this and verify we actually get the interface.
    CHECKRUN(ptInterface->GetObjectInPath(IgnorePChannel(dwStage),
                                          dwStage,
                                          0,
                                          GUID_All_Objects,
                                          0,
                                          IID_IUnknown,
                                          (void **)&pUnk
                                          ));

    //Release it
    SAFE_RELEASE(pUnk);

    //Should ASSERT on debug.
    CHECKRUN(ptInterface->GetObjectInPath(IgnorePChannel(dwStage),
                                      dwStage,
                                      0,
                                      GUID_All_Objects,
                                      0,
                                      IID_IUnknown,
                                      NULL
                                      ));

    SAFE_RELEASE(ptInterface);
//    SAFE_RELEASE(ptTool);

    return hr;
};







/********************************************************************************
PURPOSE:
    Verify that passing dwBuffer != 0 for any stage where the buffer doesn't matter,
    results in failures.
********************************************************************************/
/*
template <class T>
HRESULT templBufferNotUsed(CtIDirectMusicPerformance8 *ptPerf8,  
                         DWORD dwStage, 
                         GUID *pCLSID,
                         GUID *pIID,
                         T* pDoNotUseDoNotRemove = NULL)
{
    HRESULT                     hr                  = S_OK;
    CICMusic                    Music;
    T*                          ptInterface         = NULL;
    DWORD                       dwStageIndex        = 0;

    IUnknown                   * pUnk               = NULL;
//    CtIDirectMusicTool         * ptTool             = NULL;
    


    //Start the music playing.
    CHECKRUN(Music.Init(L"test.mid", DMUS_APATH_SHARED_STEREOPLUSREVERB));
    //Get the AudioPath or SegmentState interface.
    CHECKRUN(Music.GetInterface(&ptInterface));
    //CHECKRUN(PutToolInGraphIfNeeded(ptInterface, pStage->dwStage, &ptTool, NULL, NULL));


    //Verify that you can get this object from the path with dwBuffer = 0
    CHECKRUN(ptInterface->GetObjectInPath(IgnorePChannel(pStage->dwStage),   
                                      pStage->dwStage,    
                                      0,                 //dwbuffer= 0
                                      *pStage->pCLSID,    //no CLSID
                                      0,                 //dwIndex = 0
                                      *pStage->pIID,
                                      (void **)&pUnk));
    SAFE_RELEASE(pUnk);
        
    CHECKRUN(ptInterface->GetObjectInPath(IgnorePChannel(pStage->dwStage),   
                                      pStage->dwStage,    
                                      dwBuffer,         //dwbuffer=1
                                      *pStage->pCLSID,  //no CLSID
                                      0,                 //dwIndex = 0
                                      *pStage->pIID,
                                      (void **)&pUnk))


    SAFE_RELEASE(pUnk);
    SAFE_RELEASE(ptInterface);
    return hr;
};

*/



/********************************************************************************
PURPOSE:
    Goes through all the scenarios specified in the Scenarios array and verifies
    they assert
********************************************************************************/
template <class T>
DWORD templInvalidScenarios(CtIDirectMusicPerformance8 *ptPerf8,
                            LPSTR szAudPath,
                            LPSTR szSegment,
                            DWORD dwStage,
                            GUID *pCLSID,
                            GUID *pIID,
                            DWORD dwBuffer,
                            DWORD dwIndex,
                            T* pDoNotUseDoNotRemove = NULL)
{

    HRESULT                         hr                  = S_OK;
    DWORD                           i                   = 0;
//    BOOL                            bSameFilesAsLastTime = FALSE;
//    DWORD                           dwTotalScenarios = 0;
//    WCHAR *                         wszPreviousPath     = L"NULL String";
//    WCHAR *                         wszPreviousSeg      = L"NULL String";
    DWORD                           dwStandardPathType = NULL;


    

    CICMusic                        Music;
    T *                             ptInterface         = NULL;
    IUnknown *                      pUnk                = NULL;
//    CEchoTool               *       pCEchoTool          = NULL;
//    IDirectMusicTool        *       pTool[3]            = {NULL};

    BOOL bFound = FALSE;

    
    //Go check to see if we're creating a standard path type.  If not, dwStandardPathType==FALSE.
    struct PAIR
    {
        LPSTR szString;
        DWORD dwStandardPathType;       
    };
    PAIR Pair[] = { "DMUS_APATH_SHARED_STEREOPLUSREVERB", DMUS_APATH_SHARED_STEREOPLUSREVERB,
                    "DMUS_APATH_DYNAMIC_MONO", DMUS_APATH_DYNAMIC_MONO,
//                    "DMUS_APATH_DYNAMIC_STEREO", DMUS_APATH_DYNAMIC_STEREO,
                    "DMUS_APATH_DYNAMIC_3D", DMUS_APATH_DYNAMIC_3D};
    dwStandardPathType = 0;
    for (i=0; i<AMOUNT(Pair); i++)
    {
        if (strcmp(Pair[i].szString, szAudPath)==0)
        {
            dwStandardPathType = Pair[i].dwStandardPathType;
            break;
        }
    }


    //Create 3 tools and have them just sitting around for our pleasure if we need them.    
    //  We'll delete them at the end of the function.  Other than that, we don't mess
    //  with creating destroying them during the test.

//     for (i=0; i<3; i++)
//     {
//         pCEchoTool = new CEchoTool;
//         if (NULL == pCEchoTool)
//         {
//             fnsLog(ABORTLOGLEVEL,"**** ABORT:  new CEchoTool returned NULL");
//             goto TEST_END;
//         }
// 
//         pCEchoTool->SetDelay(i);
// 
//         //Put this into the correct place.
//         pTool[i] = (IDirectMusicTool *)pCEchoTool;
//         pCEchoTool = NULL;
//     }
//     
// 
// 

    //Determine whether we must Initialize the music class again (this takes time).
//     if (i==0)
//         bSameFilesAsLastTime = FALSE;
//     else if (wcscmp(Scenarios[i].wszPathName, wszPreviousPath) || wcscmp(Scenarios[i].wszSegName, wszPreviousSeg))
//         bSameFilesAsLastTime = FALSE;
//     else
//         bSameFilesAsLastTime = TRUE;    
    //If this scenario needs a different audiopath, then load up the new one.  Otherwise we'll stick with the
//     //  same one.
// 
//     if (!bSameFilesAsLastTime)
//     {
//         //Release the stuff we allocated before.  Music.Shutdown isn't necessary but good form
//         //  to call it.
//         SAFE_RELEASE(ptInterface);
//         Music.Shutdown();
 
 
 
     if (dwStandardPathType)
     {
        CHECKRUN(Music.Init(ptPerf8, szSegment, dwStandardPathType));
    }
    else
    {
        CHECKRUN(Music.Init(ptPerf8, szSegment, szAudPath));
    }
        


    CHECKRUN(Music.GetInterface(&ptInterface));

    //Add EchoTools to all three ToolGraphs (two if we're the audiopath).  Note - this happens
    //  to every instance of CICMusic, even if the test isn't stressing toolgraphs.
//    if (!bAudioPath)
//    {
//        CHECKRUN(AddToolToGraph(ptInterface, DMUS_PATH_SEGMENT_TOOL, pTool[0], NULL, NULL));
//    }
//    CHECKRUN(AddToolToGraph(ptInterface, DMUS_PATH_AUDIOPATH_TOOL, pTool[1], NULL, NULL));
//    CHECKRUN(AddToolToGraph(ptInterface, DMUS_PATH_PERFORMANCE_TOOL, pTool[2], NULL, NULL));


    //Save the file's name.
//    szPreviousPath = szAudPath;
//    szPreviousSeg  = szSegment;

    CHECKRUN(ptInterface->GetObjectInPath(
                                      IgnorePChannel(dwStage),
                                      dwStage,
                                      dwBuffer,
                                      *pCLSID,
                                      dwIndex,
                                      *pIID,
                                      (void **)&pUnk));

    //Should assert here!!!
    // };

     
    //Release this pointer we picked up.
    SAFE_RELEASE(pUnk);    
    SAFE_RELEASE(ptInterface);
    SAFE_RELEASE(pUnk);
// 
//   for (i=0; i<AMOUNT(pTool); i++)
//   {
//       SAFE_RELEASE(pTool[i]);
//   }
// 
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\CICMusicX.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       CICMusic.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// CICMusic.cpp
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//
// Functions:
//
//
//  History:
//      03/09/2000 - danhaff/ruswoods - created
//      03/27/2000 - danhaff - Made Init call UnInit first, fixed bugs
//      08/29/2000 - danhaff - Removed instances of DYNAMIC_APATH_ENV3D
//
/////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "cicmusicx.h"


//--------------------------------------------------------------------------;
// Description: <nl>
// Constructor for CICMusic
//
//
// Parameters: <nl>
//   hWnd: hWnd of our window.
//
// Notes:
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
CICMusic::CICMusic(void)
:
m_ptLoader8 (NULL),
m_ptPerformance8 (NULL),
m_ptUnkAudioPathConfig (NULL),
m_ptAudioPath (NULL),
m_ptAudioPathEnv (NULL),
m_ptSegment8(NULL),
m_ptSegmentState8(NULL)
{
    //What are you looking at?
};


//--------------------------------------------------------------------------;
// Description: <nl>
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init
(
CtIDirectMusicPerformance8 *ptPerf8,
LPCSTR szSegment,
DWORD dwDefaultPathType,
DWORD dwPChannelCount)
{
    HRESULT hr = E_FAIL;

    __try
    {
        //Copy our performance in.
        if (!ptPerf8)
            __leave;
        m_ptPerformance8 = ptPerf8;
            
        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;
        
        //Now perform our initialization.
        hr = PrivateInitialize(szSegment, NULL, dwDefaultPathType, /*dwUseAPathEnv,*/ dwPChannelCount);
        if (S_OK != hr)
            __leave;
    }
    __finally
    {
    }

    return hr;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init(
CtIDirectMusicPerformance8 *ptPerf8,
LPCSTR szSegment,
LPCSTR szConfig)
{
    HRESULT hr;
    __try
    {
        //Copy our performance in.
        if (!ptPerf8)
            __leave;
        m_ptPerformance8 = ptPerf8;

        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;

        //Now perform our initialization.
        hr = PrivateInitialize(szSegment,              //Specified segment.
                               szConfig,               //Specified AP config file.
                               NULL,                    //Don't use a standard path type.
                               0);                      //pChannels don't matter cuz we're using file.
        if (S_OK != hr)
            __leave;

    }
    __finally
    {
    }
    return hr;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//   Shutdowns the class, just like the destructor.  I added this
//   because sometimes you want to shut it down early.
//
// Notes:
//
// History: <nl>
//      03/27/2000 - danhaff - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Shutdown(void)
{
    HRESULT hr;
    hr = PrivateUninitialize();
    return hr;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Destructor for CICMusic
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
CICMusic::~CICMusic ()
{
    PrivateUninitialize();
}



//--------------------------------------------------------------------------;
// Description: <nl>
// Initialization function for CICMusic, called by both constructors.
//
//
// Parameters: <nl>
//
// Notes:
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateInitialize(
LPCSTR szSegment,
LPCSTR szConfig,
DWORD dwDefaultPathType,
DWORD dwPChannelCount
)
{
HRESULT hr=S_OK;
IDirectMusicPerformance8 *pPerformance8 = NULL;
char szConfigPath [MAX_PATH]          = {0};
char szConfigFile [MAX_PATH]         = {0};
char szSegmentPath[MAX_PATH]         = {0};
char szSegmentFile[MAX_PATH]        = {0};


    __try
    {
        //Verify that one of the correct types of standardpaths was passed, if any.
        if (dwDefaultPathType != 0 &&
            !IsValidAudioPath(dwDefaultPathType)
            )
        {
            Log(ABORTLOGLEVEL, "**** TEST APP ERROR:  Someone passed an invalid value for dwDefaultPathType!!");
            hr = E_FAIL;
            __leave;
        }

        if (!m_ptPerformance8)
        {
            Log(ABORTLOGLEVEL, "**** TEST APP ERROR:  Calling CICMusic::PrivateInitialize without a valid m_ptPerformance8!!");
            hr = E_FAIL;
            __leave;
        }

        //Create a new Loader8.
        hr = dmthCreateLoader(IID_IDirectMusicLoader8, &m_ptLoader8);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL, "**** ERROR: CICMusic: dmthCreateLoader returned (%s == %08Xh)",
                    tdmXlatHRESULT(hr), hr);
            __leave;
        }

        //Parse out the path and the file.
        hr = ChopPath(szSegment, szSegmentPath, szSegmentFile);
        if (hr != S_OK)
        {
            Log(ABORTLOGLEVEL, "**** ERROR parsing full path to Segment file: %s", szSegment);
            __leave;
        }
        
        //Keep all info, we don't want GM.DLS to be unfound.
        hr = m_ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, (LPSTR)szSegmentPath, FALSE);
        if (FAILED(hr))
        {
            Log(ABORTLOGLEVEL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetSearchDirectory(%s) failed!!", szSegmentPath);
            __leave;
        }
        if (hr != S_OK)
        {
            Log(ABORTLOGLEVEL, "**** WARNING: CICMusic: SetSearchDirectory(%s) returned %s (%08X)", szSegmentPath, tdmXlatHRESULT(hr), hr);
        }

        //If we pass in an audiopath config file, make that the default path, otherwise choose
        //  and standard default path.  This decision was made by which constructor to use.
        if (szConfig)
        {

            //Parse out the Path and file.
            hr = ChopPath(szConfig, szConfigPath, szConfigFile);
            if (hr != S_OK)
            {
                Log(ABORTLOGLEVEL, "**** ERROR parsing full path to config file: %s", szConfig);
                __leave;
            }

            //Stack this on top the other info.
            hr = m_ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, szConfigPath, FALSE);
            if (FAILED(hr))
            {
                Log(ABORTLOGLEVEL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetSearchDirectory(%s) failed!!", szConfigPath);
                __leave;
            }
            if (hr != S_OK)
            {
                Log(ABORTLOGLEVEL, "**** WARNING: CICMusic: SetSearchDirectory(%s) returned %s (%08X)", szConfigPath, tdmXlatHRESULT(hr), hr);
            }


            //Load up the audiopath config.
            //There is no actual interface for this; we use the IUnknown interface
            //  for this object.
            hr = m_ptLoader8->LoadObjectFromFile(CLSID_DirectMusicAudioPathConfig,
                                                 CTIID_IUnknown,
                                                 (LPSTR)szConfigFile,
                                                 (void **)&m_ptUnkAudioPathConfig);
            if (S_OK != hr)
            {
                Log(ABORTLOGLEVEL,
                TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load audiopath config %s!! (%s == %08Xh)"),
                PathFindFileName((LPSTR)szConfigFile),
                tdmXlatHRESULT(hr), hr);
                __leave;
            }

            //Make that audiopath config into a real audiopath
            hr = m_ptPerformance8->CreateAudioPath(m_ptUnkAudioPathConfig, TRUE, &m_ptAudioPath);
            if (S_OK != hr)
            {
                Log(ABORTLOGLEVEL,
                TEXT("**** ABORT:  CICMusic: Perf8->CreateAudioPath failed from loaded config file %s!! (%s == %08Xh)"),
                szConfig, tdmXlatHRESULT(hr), hr);
                __leave;
            }

        }
        else
        {
            //Call CreateStandardAudioPath.
            hr = m_ptPerformance8->CreateStandardAudioPath(dwDefaultPathType, dwPChannelCount, TRUE, &m_ptAudioPath);
            if (S_OK != hr)
            {
                Log(ABORTLOGLEVEL,
                TEXT("**** ABORT:  CICMusic: Perf8->CreateStandardAudioPath returned (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
                __leave;
            }            
        }

/*
        //Set the audiopath we created as the default.
        hr = m_ptPerformance8->SetDefaultAudioPath(m_ptAudioPath);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: Perf8->SetDefaultAudioPath failed from file %s!! (%s == %08Xh)"),
            szConfig, tdmXlatHRESULT(hr), hr);
            __leave;
        }

*/

        // Load the segment.
        hr = m_ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment,
                                        CTIID_IDirectMusicSegment8,
                                        (LPSTR)szSegmentFile,
                                        (void **)&m_ptSegment8);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load segment %s!! (%s == %08Xh)"),
            PathFindFileName((LPSTR)szSegmentFile),
            tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Tell the segment to repeat forever.
        hr = m_ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: IDirectMusicSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE) returned (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Get the real Performance8 ptr from the performance, so we can pass it to SetParam.
        hr = m_ptPerformance8->GetRealObjPtr(&pPerformance8);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: CtIDirectMusicPerformance8->GetRealObjPtr returned (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
                __leave;
        }


        //Play the segment on the default audio path, and get the segment state.
        hr = m_ptPerformance8->PlaySegmentEx((CtIUnknown *)m_ptSegment8,
                                            NULL,                   //no segment id, this isn't a song
                                            NULL,                   //no transition to compose
                                            NULL,                   //no DMUS_SEGF flags
                                            (__int64)0,             //time to start playback (right away)
                                            &m_ptSegmentState8,     //returned segment state
                                            NULL,                   //no segstate to replace
                                            (CtIUnknown *)m_ptAudioPath);                  //play on default audiopath.
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: IDirectMusicPerformance8->PlaySegmentEx returned (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
                __leave;
        }

        hr = ExpectSegmentStart(m_ptPerformance8, m_ptSegment8, NULL, 5000, NULL, FALSE);
        if (S_OK != hr)
        {
            Log(ABORTLOGLEVEL,
            TEXT("**** ABORT:  CICMusic: ExpectSegmentStart on %s returned (%s == %08Xh)"),
            PathFindFileName((LPSTR)szSegmentFile),
            tdmXlatHRESULT(hr), hr);
            hr = E_FAIL;
                __leave;
        }

    }
    __finally
    {
        //Release the only thing we allocated locally during this function.
        SAFE_RELEASE(pPerformance8);

        //If init failed, release all members.
        if (S_OK != hr)
            PrivateUninitialize();
    }

return hr;
};






//--------------------------------------------------------------------------;
// Description: <nl>
//  Frees up everything in the object.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateUninitialize(void)
{
    //Might as well have the return value somewhere.
    HRESULT hr = S_OK;

    //Stop Everything.
    if (m_ptPerformance8)
    {
        hr = m_ptPerformance8->StopEx(NULL, __int64(0), NULL);  //Uncomment this to repro bug 2967
    }

    //Release all the interfaces we've stashed, except the performance which must be Closed down and
    //  released last.
    SAFE_RELEASE (m_ptSegmentState8);
    SAFE_RELEASE (m_ptSegment8);
    SAFE_RELEASE (m_ptAudioPath);
    SAFE_RELEASE (m_ptAudioPathEnv);
    SAFE_RELEASE (m_ptUnkAudioPathConfig);
    SAFE_RELEASE (m_ptLoader8);


    return hr;
};



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetLoader8
//
// Parameters: <nl>
//      pptLoader8: contains address of pointer to contain wrapped IDirectMusicLoader8.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicLoader8** pptDirectMusicLoader8)
{
    if (pptDirectMusicLoader8 && m_ptLoader8)
    {
        *pptDirectMusicLoader8 = m_ptLoader8;
        m_ptLoader8->AddRef();
        return S_OK;
    }
    else if (!pptDirectMusicLoader8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Gets the performance object, which must be created upon initialization.
//
// Parameters: <nl>
//      pptPerformance8: contains address of pointer to contain wrapped IDirectMusicPerformance8.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicPerformance8 **pptPerformance8 )
{
    if (pptPerformance8 && m_ptPerformance8)
    {
        *pptPerformance8 = m_ptPerformance8;
        m_ptPerformance8->AddRef();
        return S_OK;
    }
    else if (!pptPerformance8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;

};




//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped IDirectMusicAudioPath.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicAudioPath** pptAudioPath)
{
    if (pptAudioPath && m_ptAudioPath)
    {
        *pptAudioPath= m_ptAudioPath;
        m_ptAudioPath->AddRef();
        return S_OK;
    }
    else if (!pptAudioPath)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPathConfig
//
// Parameters: <nl>
//      pptUnkAudioPathConfig: contains address of pointer to contain wrapped IDirectMusicAudioPathConfig.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIUnknown ** pptUnkAudioPathConfig)
{
    if (pptUnkAudioPathConfig && m_ptUnkAudioPathConfig)
    {
        *pptUnkAudioPathConfig= m_ptUnkAudioPathConfig;
        m_ptUnkAudioPathConfig->AddRef();
        return S_OK;
    }
    else if (!pptUnkAudioPathConfig)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegment8
//
// Parameters: <nl>
//      pptSegment8: contains address of pointer to contain wrapped IDirectMusicSegment8.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicSegment8** pptSegment8)
{
    if (pptSegment8 && m_ptSegment8)
    {
        *pptSegment8 = m_ptSegment8;
        m_ptSegment8->AddRef();
        return S_OK;
    }
    else if (!pptSegment8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegmentState8
//
// Parameters: <nl>
//      pptSegmentState8: contains address of pointer to contain wrapped IDirectMusicSegmentState8.
//
// History: <nl>
//      03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicSegmentState8** pptSegmentState8)
{
    if (pptSegmentState8 && m_ptSegmentState8)
    {
        *pptSegmentState8 = m_ptSegmentState8;
        m_ptSegmentState8->AddRef();
        return S_OK;
    }
    else if (!pptSegmentState8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetEnvironmentPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped
//      IDirectMusicAudioPath.
//
// History: <nl>
//      05/06/2000 - danhaff - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetAudioPathEnv(CtIDirectMusicAudioPath **pptAudioPathEnv)
{
    if (pptAudioPathEnv && m_ptAudioPathEnv)
    {
        *pptAudioPathEnv = m_ptAudioPathEnv;
        m_ptAudioPathEnv->AddRef();
        return S_OK;
    }
    else if (!pptAudioPathEnv)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\FakeStuff.h ===
/******************************************************************************************
Used to ease porting tests from Windows.


******************************************************************************************/

#pragma once




#define fnsIncrementIndent LogIncrementIndent
#define fnsDecrementIndent LogDecrementIndent

#define FNS_PASS                        0x00000000
#define FNS_FAIL                        0x00000001
#define FNS_ABORTED                     0x00000002
#define FNS_PENDING                     0x00000003
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\DMTEST1.cpp ===
/********************************************************************************
FILE: DMTEST1.CPP

PURPOSE:    
    Contains the "main code segment" for DANROSE's set of DMusic tests
    from which all the subfunctions (individual test cases) are called.  
********************************************************************************/

#include "globals.h"
#include "help_dowork.h"
#include "help_Definitions.h"
#include "help_suitelist.h"
#include "help_testcases.h"

TESTPARAMS g_TestParams = {0};

/********************************************************************************
Main code segment for the dmusic tests.
********************************************************************************/
VOID WINAPI DMTest1StartTest(HANDLE LogHandle)
{
    HRESULT hr = S_OK;
    SUITELIST *pSuiteList = NULL;
    DWORD dwPassed = 0;
    DWORD dwFailed = 0;

    //Set the log handle.
    //TODO: Remedy this; it's crappy design!!!
    g_hLog = LogHandle;

    //Initialize our network.
	// initialize the Xbox Secure Network Library (SNL).

	if ( 0 == XNetAddRef())
	{
		Log(ABORTLOGLEVEL, "[DMTEST1] Error: Unable to initialize Xbox SNL (error %d)\n", GetLastError() );
		hr = E_FAIL;
	}

    //Make sure nobody screwed up the static test array with dupes, tests with invalid types, etc.
    CHECKRUN(SanityCheckTestCases());

    //Run all of the test suites.
    ALLOCATEANDCHECK(pSuiteList, SUITELIST);
    CHECKRUN(pSuiteList->Load(g_szAppName, g_TestCases, g_dwNumTestCases));
    CHECKRUN(pSuiteList->CheckSuites());
    CHECKRUN(pSuiteList->RunSuites(&dwPassed, &dwFailed));
    SAFEDELETE(pSuiteList);


    //Free network.
    XNetRelease();

    //Either bail out (if we're in a suite with other tests) or loop forever (we want to view test results).
    EndTestRun();    
    
}





/********************************************************************************
Placeholder fuunction - does nothing.
********************************************************************************/
VOID WINAPI DMTest1EndTest( VOID )
{
}


/********************************************************************************
Export function pointers of StartTest and EndTest
********************************************************************************/
//lint -e10
//lint -e129
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DMTest1 )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DMTest1 )
    EXPORT_TABLE_ENTRY( "StartTest", DMTest1StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DMTest1EndTest )
END_EXPORT_TABLE( DMTest1 )
//lint +e10
//lint +e129
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\CICMusicX.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       CICMusic.h
//
//--------------------------------------------------------------------------

//===========================================================================
//	CICMusic.h
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//	History:
//		03/09/2000 - danhaff/ruswoods - created
//      04/25/2000 - danhaff - added another Init() to specify whether we
//                             create an APATH_SHARED_ENV before
//                             creating the user-specified path.
//===========================================================================

#pragma once

#define GF_AUDIOPATH        1
#define GF_SEGMENT8         2
#define GF_SEGMENTSTATE8    4

#include "dmth.h"


class CICMusic
{

protected:
    CtIDirectMusicLoader8           *m_ptLoader8;
    CtIDirectMusicPerformance8      *m_ptPerformance8;
    CtIUnknown                      *m_ptUnkAudioPathConfig;
    CtIDirectMusicAudioPath         *m_ptAudioPath;
    CtIDirectMusicAudioPath         *m_ptAudioPathEnv;
    CtIDirectMusicSegment8          *m_ptSegment8;
    CtIDirectMusicSegmentState8     *m_ptSegmentState8;

public :
    // *************************************************************
    CICMusic(void);

    // *************************************************************
	~CICMusic(void);

    // *************************************************************
	HRESULT Init      (CtIDirectMusicPerformance8 *ptPerf8,
                       LPCSTR szSegment,
                      DWORD dwDefaultPathType,
                      DWORD dwPChannelCount = 128);

    // *************************************************************
    HRESULT Init      (CtIDirectMusicPerformance8 *ptPerf8,
                       LPCSTR szSegment,
                      LPCSTR szConfig);

    // *************************************************************
    HRESULT Shutdown(void);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicLoader8 **pptLoader8);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicPerformance8 **pptPerformance8);

    // *************************************************************
	HRESULT GetInterface(CtIUnknown **pptUnkAudioPathConfig);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicAudioPath **pptAudioPath);

    // *************************************************************
    HRESULT GetInterface(CtIDirectMusicSegment8** pptSegment8);
    
    // *************************************************************
    HRESULT GetInterface(CtIDirectMusicSegmentState8** pptSegmentState8);

    // *************************************************************
    HRESULT GetAudioPathEnv(CtIDirectMusicAudioPath **pptAudioPathEnv);


private:
    // *************************************************************
    HRESULT PrivateInitialize(LPCSTR wszSegment,
                                 LPCSTR wszConfig,
                                 DWORD dwDefaultPathType,
                                 DWORD dwPChannelCount
                                 );
    // *************************************************************
    HRESULT PrivateUninitialize(void);



};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\DLS_Volume.cpp ===
/********************************************************************************
	FILE:
		DLS_Volume.cpp

	PURPOSE:
		Test Volume Articulation on DLS2 instruments

	BY:
		DANHAFF
********************************************************************************/
#include "globals.h"


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT DLS_TestSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentName, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    LPSTR szSegmentName = (LPSTR)dwSegmentName;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CtIDirectMusicSegment   *ptSegment = NULL;
    CICMusic Music;
    CHAR *szFileLocation[MAX_PATH] = {0};

    //copy everything in that directory
    CHECKRUN(MediaCopyDirectory(szSegmentName));
    CHECKRUN(Music.Init(ptPerf8, MediaServerToLocal(szSegmentName), DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Music.GetInterface(&ptPath));
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 50000, szSegmentName));
    CHECKRUN(ptSegment->SetRepeats(0));
    CHECKRUN(InsertToolTrace(ptPath));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,0,0,ptPath));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, szSegmentName));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 50000, szSegmentName));
    RemoveToolTrace(ptPath);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);    


    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Helpers.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    Helpers.cpp

Abstract:

    Helper functions for dmtest1

Author:

    Dan Haffner (danhaff)

Revision History:

    13-Mar-2001 robheit
        Added input functions for joystick polling
    19-Mar-2001 robheit
        Added enableBreak functionality in WaitForSegmentStart/Stop
        Added dmthIsAnyButtonDown

--*/

#define __HELPERS_CPP__ // Must be first


//------------------------------------------------------------------------------
//  Includes:
//------------------------------------------------------------------------------
#include "globals.h"
#include "DSSTDFX.h"
#include "dxconio.h"

LPCSTR g_szAppName = "DMTest1";
THREADPRI g_ThreadPris[] =  {
                            {"THREAD_PRIORITY_IDLE",            THREAD_PRIORITY_IDLE},
                            {"THREAD_PRIORITY_LOWEST",          THREAD_PRIORITY_LOWEST},
                            {"THREAD_PRIORITY_BELOW_NORMAL",    THREAD_PRIORITY_BELOW_NORMAL},
                            {"THREAD_PRIORITY_NORMAL",          THREAD_PRIORITY_NORMAL},
                            {"THREAD_PRIORITY_ABOVE_NORMAL",    THREAD_PRIORITY_ABOVE_NORMAL},
                            {"THREAD_PRIORITY_TIME_CRITICAL",   THREAD_PRIORITY_TIME_CRITICAL}
                            };

DWORD g_dwThreadPris = NUMELEMS(g_ThreadPris);


//------------------------------------------------------------------------------
//  Globals
//------------------------------------------------------------------------------
HANDLE              g_dmthInputHandles[4] = {NULL, NULL, NULL, NULL};
DMTHJoystick        g_dmthJoysticks[4];
static const float  minThreshold = 0.0001f;

//Prototype this, since it's not public anymore.
BOOL dmthPromptUserYesNo(IN LPSTR    yesNoQuestion,IN ...);


//------------------------------------------------------------------------------
//  ::UINTToPort
//------------------------------------------------------------------------------
DWORD
UINTToPort(
           IN UINT port
           )
/*++

Routine Description:

    Converts an unsigned integer in the range of 0-3 to a XDEVICE port

Arguments:

    IN port -   Value to convert

Return Value:

    A port XDEVICE_PORT0 - XDEVICE_PORT3

--*/
{
    switch(port)
    {
    case 0:
        return XDEVICE_PORT0;
    case 1:
        return XDEVICE_PORT1;
    case 2:
        return XDEVICE_PORT2;
    case 3:
        return XDEVICE_PORT3;
    default:
        __asm int 3;
        return 0xFFFFFFFF;
    }


}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
static void 
InitInput(
          IN UINT port
          )
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    IN port -   Port to initialize

Return Value:

    None

--*/
{
    // If the port has already been initialized, just return
    if(g_dmthInputHandles[port] != NULL)
        return;
    
    // Create a device
    g_dmthInputHandles[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, UINTToPort(port),
                                          0, NULL);
}

//==========================================================================
// dmthCreatePerformance
//==========================================================================
HRESULT dmthCreatePerformance(REFIID riid, CtIDirectMusicPerformance8 **pwPerformance)
{
    HRESULT                     hr = S_OK;
    IDirectMusicPerformance8    *pdmPerformance = NULL;

    if(!pwPerformance)
    {
        return E_INVALIDARG;
    }

    // CoCreate Loader object
    if(SUCCEEDED(hr)){
        hr = dmthDirectMusicCreateInstance(CLSID_DirectMusicPerformance,
                          NULL,
                          riid,
                          (LPVOID*)&pdmPerformance);
    }
    if(SUCCEEDED(hr) && pdmPerformance)
    {
        // Wrap the Performance object
        *pwPerformance = new CtIDirectMusicPerformance8();
        if(NULL != *pwPerformance)
        {
            hr = (*pwPerformance)->InitTestClass(pdmPerformance);
            if(FAILED(hr))
            {
                (*pwPerformance)->Release();
                (*pwPerformance) = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    // clean up
    SAFE_RELEASE(pdmPerformance);
    return hr;
}



//==========================================================================
// dmthLoadSegment
//
// Does all the leg work for creating a Segment for you.
//==========================================================================
HRESULT dmthLoadSegment(LPCSTR pSegmentFile,
                      CtIDirectMusicSegment8 **ppwSegment)
{
    if(pSegmentFile == NULL)
    {
        Log(ABORTLOGLEVEL, "TEST APP ERROR: Don't pass NULL!!!");
        ASSERT(FALSE);
    }

    HRESULT                     hr              = E_NOTIMPL;
    CtIDirectMusicLoader8        *pwLoader       = NULL;
    char szSegmentName[MAX_PATH];
    char szSegmentPath[MAX_PATH];


    //Take this path 
    hr = ChopPath(pSegmentFile, szSegmentPath, szSegmentName);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment's ChopPath(%s) failed with %s (%08Xh)", pSegmentFile, tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Load the Segment Object
    // **********************************************************************
    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize         = sizeof(DMUS_OBJECTDESC);
    desc.guidClass      = CLSID_DirectMusicSegment;
    desc.dwValidData    |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);

    hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
                TEXT("failed (%s === %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // Get the Segment object
    mbstowcs(desc.wszFileName, szSegmentName, strlen(szSegmentName) + 1);
//    strcpy(desc.wszFileName, szSegmentName);
    hr = pwLoader->GetObject(&desc, CTIID_IDirectMusicSegment8, (void **)ppwSegment);
    if(FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(Segment) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

TEST_END:
    SAFE_RELEASE(pwLoader);
    return hr; //end dmthLoadSegment
}





//==========================================================================
// dmthLoadSegment
//
// Does all the leg work for creating a Segment for you.
// UNWRAPPED VERSION!!!
//==========================================================================
HRESULT dmthLoadSegment(LPCSTR pSegmentFile,
                      IDirectMusicSegment8 **ppSegment)
{
    if(pSegmentFile == NULL)
    {
        Log(ABORTLOGLEVEL, "TEST APP ERROR: Don't pass NULL!!!");
        ASSERT(FALSE);
    }

    HRESULT                     hr              = E_NOTIMPL;
    IDirectMusicLoader8        *pwLoader       = NULL;
    char szSegmentName[MAX_PATH];
    char szSegmentPath[MAX_PATH];


    //Take this path 
    hr = ChopPath(pSegmentFile, szSegmentPath, szSegmentName);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment's ChopPath(%s) failed with %s (%08Xh)", pSegmentFile, tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Load the Segment Object
    // **********************************************************************
    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize         = sizeof(DMUS_OBJECTDESC);
    desc.guidClass      = CLSID_DirectMusicSegment;
    desc.dwValidData    |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);

    hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
                TEXT("failed (%s === %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // Get the Segment object
    mbstowcs(desc.wszFileName, szSegmentName, strlen(szSegmentName) + 1);
//    strcpy(desc.wszFileName, szSegmentName);
    hr = pwLoader->GetObject(&desc, IID_IDirectMusicSegment8, (void **)ppSegment);
    if(FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(Segment) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

TEST_END:
    SAFE_RELEASE(pwLoader);
    return hr; //end dmthLoadSegment
}



//===========================================================================
// TDMGetBogusPointer
//
// Creates a bad pointer.
//
// Parameters: none
//
// Returns: LPVOID
//
// History:
//  12/22/1997 - a-llucar - taken from tdinput sources
//===========================================================================
LPVOID TDMGetBogusPointer(void)
{

    // allocate some memory and mark it not accessable
    return VirtualAlloc(NULL, 8, MEM_COMMIT, PAGE_NOACCESS);

} // *** end dihelpGetBogusPointer()


//===========================================================================
// TDMFreeBogusPointer
//
// Frees bad pointer created by helpGetBogusPointer.
//
// Parameters:
//  LPVOID lpv  - pointer to free
//
// Returns: nothing
//
// History:
//  12/22/1997 - a-llucar - taken from tdinput sources
//  1/22/1998 - a-kellyc - added VirtualProtect
//===========================================================================
void TDMFreeBogusPointer(LPVOID lpv)
{
    DWORD   dwOld;

    if(lpv)
    {
        // set the access rights back to read/write
        VirtualProtect(lpv, 8, PAGE_READWRITE, &dwOld);

        // release memory pointed to by lpv
        VirtualFree(lpv, 0, MEM_RELEASE);

        // set it to NULL
        lpv = NULL;
    }
} 


//===========================================================================
// tdmPackDWORD
//
// Packs two WORDs into a DWORD.
//
// Parameters:
//
// Returns: The packed DWORD
//
// History:
//  10/13/1998 - davidkl - created
//===========================================================================
DWORD tdmPackDWORD(WORD wHigh, WORD wLow)
{
    DWORD dw    = 0;

    // start with the high word
    dw = wHigh;
    dw = dw << 16;

    // or in the low word
    dw |= wLow;

    return dw;

} // *** end tdmPackDWORD()


//===========================================================================
// tdmEnableBreakOnDMAssert
//
// Turns on/off the DebugBreak in DirectMusic assertions by adding the
//  AssertBreak and setting the value to 1 (on) or 0 (off)
//
// Parameters:
//
// Returns: BOOL (return code from WriteProfileString)
//
// History:
//  10/22/1998 - davidkl - created
//===========================================================================
BOOL tdmEnableBreakOnDMAssert(BOOL fBreak)
{
    return WriteProfileStringA(TEXT("Debug"),
                    TEXT("AssertBreak"),
                    (fBreak) ? TEXT("1") : TEXT("0"));

} // *** end tdmEnableBreakOnDMAssert()

/*
//Types of data for loader to scan.
static GUID* g_ScanTypes[] = {
                    (GUID*)&CLSID_DirectMusicAudioPathConfig,
                    (GUID*)&CLSID_DirectMusicBand,
                    (GUID*)&CLSID_DirectMusicContainer,
                    (GUID*)&CLSID_DirectMusicCollection,
//                    (GUID*)&CLSID_DirectMusicChordMap,
                    (GUID*)&CLSID_DirectMusicScript,
//                    (GUID*)&CLSID_DirectMusicSong,
//                    (GUID*)&CLSID_DirectMusicStyle,
                    (GUID*)&CLSID_DirectMusicSegment,
//                    (GUID*)&CLSID_DirectMusicGraph,
//                    (GUID*)&CLSID_DirectSoundWave,
                    };
static DWORD g_dwScanTypes = AMOUNT(g_ScanTypes);
*/



/**********************************************************************
**********************************************************************/
BOOL FillBufferWithSineWave 
(
 LPVOID             pBuffer,
 DWORD              dwBufferBytes,
 DWORD              dwFrequency,
 LPWAVEFORMATEX     pWfx,
 DOUBLE             fFactor
 )
{
    int                 i       = 0;
    double              lfPhase = 0;
    const double        pi      = 3.14159265;
    ASSERT(pBuffer);
    if (dwBufferBytes != 0)
    {
        switch (pWfx->wBitsPerSample)
        {
        case 8:
            while (i < (LONG) dwBufferBytes)
            {
                int    nMag;
                int j;
                lfPhase = 2.0*pi*((double)dwFrequency)*i
                          /pWfx->nSamplesPerSec/pWfx->nBlockAlign;
                nMag = (int)(255*sin(lfPhase)+128);

                nMag = (int) (nMag * fFactor);
                for (j=0;j<pWfx->nChannels;j++)
                {
                    ((char*)pBuffer)[i++] = (char)nMag;
                }
            }
            break;
        case 16:
            while (i*2 < (LONG) dwBufferBytes)
            {
                int    nMag;
                int j;
                lfPhase = 2.0*pi*((double)dwFrequency)*i*2
                          /pWfx->nSamplesPerSec/pWfx->nBlockAlign;
                nMag = (int)(((double)0x7fff)*sin(lfPhase));

                nMag = (int) (nMag * fFactor);
                for (j=0;j<pWfx->nChannels;j++)
                {
                    ((short *)pBuffer)[i++] = (short)nMag;
                }
            }
            break;
        default:
            Log(ABORTLOGLEVEL, "FillBufferWithSinWave: Unsupported Format");
            Log(4, "FillBufferWithSinWave: Unsupported Format, filling with silence.");
            memset(pBuffer, 0, dwBufferBytes);
            return TRUE;
        }
    }

    return TRUE;
};




/**********************************************************************
Added by danhaff 07-17-00

PURPOSE:
    For each stage, lists whether the dwPChannel parameter is used or not.
    If it's used, then one should pass DMUS_PCHANNEL_ALL.  Otherwise
    they should pass 0.
**********************************************************************/
struct STAGEDATA
{
    DWORD dwStage;
    BOOL  bPChannelUsed;
};

STAGEDATA g_StageData[] = 
{
    {DMUS_PATH_SEGMENT          , FALSE},
//    {DMUS_PATH_SEGMENT_TRACK    , FALSE},
//    {DMUS_PATH_SEGMENT_GRAPH    , FALSE},
//    {DMUS_PATH_SEGMENT_TOOL     , TRUE},
    {DMUS_PATH_AUDIOPATH        , FALSE},
//    {DMUS_PATH_AUDIOPATH_GRAPH  , FALSE},
//    {DMUS_PATH_AUDIOPATH_TOOL   , TRUE},
    {DMUS_PATH_PERFORMANCE      , FALSE},
//    {DMUS_PATH_PERFORMANCE_GRAPH, FALSE},
//    {DMUS_PATH_PERFORMANCE_TOOL , TRUE},
//    {DMUS_PATH_PORT             , TRUE},
    {DMUS_PATH_BUFFER           , TRUE},
//    {DMUS_PATH_BUFFER_DMO       , TRUE},
//    {DMUS_PATH_MIXIN_BUFFER     , FALSE},
//    {DMUS_PATH_MIXIN_BUFFER_DMO , FALSE},
//    {DMUS_PATH_PRIMARY_BUFFER   , FALSE}
};



/**********************************************************************
Added by danhaff 07-17-00

PURPOSE:
    Based on the stage, returns a value that says to GetObjectInPath,
    "Ignore the PChannel".
**********************************************************************/
DWORD IgnorePChannel(DWORD dwStage)
{
    DWORD i=0;

    for (i=0; i<AMOUNT(g_StageData); i++)
    {
        if (dwStage == g_StageData[i].dwStage)
        {
            if (g_StageData[i].bPChannelUsed)
                return DMUS_PCHANNEL_ALL;
            else
                return 0;
        }
    }

    //If we made it through, we were passed an invalid value.
    Log(ABORTLOGLEVEL, 
           TEXT("**** ABORT:  TEST_APP ERROR!!!  dwPChannelIgnore passed invalid stage %s (%08Xh)"),  dmthXlatDMUS_STAGE(dwStage), dwStage);
    
    //This should NEVER EVER EVER HAPPEN!!!
    return 0xFFFFFFFF;
};




/**********************************************************************
Added by danhaff 08-02-00

PURPOSE:
    Releases an IUnknown if a call succeeded, otherwise just NULLs it
    out again.  Prints error if API didn't do it's job.
**********************************************************************/
void CleanUpIUnknown(HRESULT hr, LPUNKNOWN &pUnk)
{
    //Make sure we got rid of pUnk if this succeeded unexpectedly.
    if (SUCCEEDED(hr))
    {
        SAFE_RELEASE(pUnk);
    }

    if (FAILED(hr))
    {
        if (pUnk)
        {
            Log(ABORTLOGLEVEL,"**** FYI:  GetObjectInPath didn't zero out *ppUnkObject");
            pUnk = NULL;
        }
    }
};



/**********************************************************************
Added by danhaff 08-08-00

PURPOSE:
    What it says.

NOTES:
    Copied out of the shell code on index 2 because this isn't on 
    @#$@% Windows 95.
**********************************************************************/
#define TEXTW(quote) L##quote      
LPCWSTR PathFindFileNameW(LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}



/**********************************************************************
**********************************************************************/
LPWSTR PathFindFileNameW(LPWSTR pPath)
{
    LPWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/**********************************************************************
**********************************************************************/
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


/**********************************************************************
**********************************************************************/
LPCSTR PathFindFileExtension(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pT; pT++) 
    {
        if (*pT == '.')
        {
            pT++;
            return pT;
        }
    }

    return NULL;
}





//==========================================================================
//==========================================================================
// dmthPlayMidiFile
// 
// Creates all the objects necessary to create a MIDI event, Loads the Midi
// Event, and plays the MIDI segment.  Standard helper for many tests.

// Parameters:
//  REFIID to Graph
//  pointer to wrapped Graph object
//
//  NOTE:  This returns a Segment Object containing a sequence track.
//
//         DOES NOT SUPPORT UNWRAPPED OBJECTS
//==========================================================================
HRESULT dmthPlayMidiFile(CtIDirectMusicPerformance8 *pwPerformance8,
                         REFIID riid,
                         CtIDirectMusicSegment8 **ppwSegment8,
                         CtIDirectMusicSegmentState **ppwSegmentState,
                         LPSTR pMidiFile)

{       
    if (pMidiFile == NULL)
        pMidiFile = g_TestParams.szDefaultMedia;

    HRESULT hr = S_OK;
    CtIDirectMusicLoader8 *ptLoader8 = NULL;
    CtIDirectMusicSegment8 *ptSegment8 = NULL;
    CtIDirectMusicSegmentState8 *ptSegmentState = NULL;
    CtIDirectMusicAudioPath  *ptPath = NULL;

    hr = pwPerformance8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, TRUE, &ptPath);
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL,"**** ABORT: CreateStandardAudioPath failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &ptLoader8);
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL,"**** ABORT: dmthCreateLoader failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


    hr = ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment8, pMidiFile, (void **)&ptSegment8);
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL,"**** ABORT: pLoader8->LoadObjectFromFile failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = pwPerformance8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, (__int64)0, &ptSegmentState, NULL, ptPath);
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL,"**** ABORT: pwPerformance->PlaySegmentEx failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    *ppwSegment8        = ptSegment8;
    if (ppwSegmentState)
    {
        *ppwSegmentState   = ptSegmentState;
    }
    else
    {
        ptSegmentState->Release();
    }
    
TEST_END:

    SAFE_RELEASE(ptLoader8);
    SAFE_RELEASE(ptPath);
    return hr;


} // end dmthPlayMidiFile()



/********************************************************************************
********************************************************************************/
HRESULT CreateAndInitPerformance(CtIDirectMusicPerformance8 **pptPerf8)
{
HRESULT hr = S_OK;
CtIDirectMusicPerformance8 *ptPerf8 = NULL;

hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &ptPerf8);
if (FAILED(hr))
    goto END;


hr = ptPerf8->InitAudioX(NULL, NULL, g_TestParams.dwDMVoiceCount, g_TestParams.bDoWorkLocalThread ? DMUS_INITAUDIO_NOTHREADS : 0);
if (FAILED(hr))
{
    SAFE_RELEASE(ptPerf8);
    goto END;
}

END:
    *pptPerf8 = ptPerf8;
    return hr;

};


/********************************************************************************
********************************************************************************/
HRESULT ChopPath(const char *p_szFullString, LPSTR p_szPathOut, LPSTR p_szFileOut)
{
HRESULT hr = S_OK;
LPCSTR szFile = NULL;
DWORD dwLength;
CHAR szPathOut[MAX_PATH] = {0};
CHAR szFileOut[MAX_PATH] = {0};

ASSERT(p_szPathOut || p_szFileOut);
ASSERT(p_szFullString);

if (SUCCEEDED(hr))
{
    if (!p_szFullString)
    {
        hr = E_POINTER;
    }
}

//Parse out the file name.
if (SUCCEEDED(hr))
{
    //If the name ends in a '/' or a '\\' then there is no file name.
    if ('/' == p_szFullString[strlen(p_szFullString) - 1] ||
        '\\' == p_szFullString[strlen(p_szFullString) - 1] )
    {
        szFile = &p_szFullString[strlen(p_szFullString)];
    }
    else
    {    
        szFile = (LPSTR)PathFindFileName(p_szFullString);
    }

    //Should never happen.
    ASSERT(szFile);

    //Store the file name.
    strcpy(szFileOut, szFile);
}

if (SUCCEEDED(hr))
{
    //Store the path name.
    dwLength = strlen(p_szFullString) - strlen(szFile);
    strncpy(szPathOut, p_szFullString, dwLength);
    szPathOut[dwLength] = NULL;
}

//Regardless of whether the test passed, set these out-parameters.
if (p_szPathOut)
    strcpy(p_szPathOut, szPathOut);
if (p_szFileOut)
    strcpy(p_szFileOut, szFileOut);

return S_OK;
}


/********************************************************************************
********************************************************************************/
HRESULT Wait(DWORD dwWait)
{
    if (g_TestParams.bWait)
        Sleep(dwWait);
    return S_OK;
}


/********************************************************************************
********************************************************************************/
HRESULT CountDown(DWORD dwWait, DWORD dwInterval)
{
DWORD dwNumIntervals; //How many intervals.
DWORD dwLastInterval; //Whatever's left over.
DWORD dwTotalTime = 0;
DWORD i = 0;

if (dwWait==0)
{
    Log(FYILOGLEVEL, "Waiting 0 milliseconds");
    return S_OK;
}

if (dwInterval==0)
    dwInterval = dwWait;

dwLastInterval = dwWait % dwInterval;
dwNumIntervals = dwWait / dwInterval;

Log(FYILOGLEVEL, "Counting up to %d...", dwWait);
Log(FYILOGLEVEL, "%d...", dwTotalTime);

for (i=0; i<dwNumIntervals; i++)
{    
    Wait(dwInterval);
    dwTotalTime += dwInterval;
    Log(FYILOGLEVEL, "%d...", dwTotalTime);
}

Wait(dwLastInterval);

return S_OK;
}



//===========================================================================
// dmthCreateEmptySegment
//
// Creates a wrapped version of IDirectMusicSegment which contains no tracks.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  03/12/1998 - davidkl - created
//  04/28/1998 - davidkl - renamed to indicate that no tracks will be present
//  11/24/1999 - kcraven - moved from dmth to tdmusic to be consistant with other create helpers
//===========================================================================
HRESULT dmthCreateEmptySegment(CtIDirectMusicSegment **ppwSegment)
{
    HRESULT             hRes        = E_NOTIMPL;
    IDirectMusicSegment *pdmSegment = NULL;

    // get a real DirectMusicSegment object
    hRes = DirectMusicCreateInstance(CLSID_DirectMusicSegment,
                            NULL,               // don't support aggregation yet
                            IID_IDirectMusicSegment,
                            (void**)&pdmSegment);

    // if successs and object is not null
    if(SUCCEEDED(hRes) && pdmSegment)
    {
        (*ppwSegment) = new CtIDirectMusicSegment;
        if (!(*ppwSegment))
        {
            Log(ABORTLOGLEVEL, TEXT("new CtIDirectMusicSegment failed"));
            goto TEST_END;
        }

        hRes = (*ppwSegment)->InitTestClass(pdmSegment);
        if(FAILED(hRes))
        {
            Log(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->InitTestClass ")
                    TEXT("failed (%s == %08Xh)"),
                    tdmXlatHRESULT(hRes), hRes);
            goto TEST_END;
        }
    }
TEST_END:
    // cleanup temp object
    if(pdmSegment)
    {
        pdmSegment->Release();
    }

    // done
    return hRes;

} // end dmthCreateEmptySegment()

//------------------------------------------------------------------------------
//  WaitForSegmentStop
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStop(
                   IN CtIDirectMusicPerformance8*   ptPerf8, 
                   IN CtIDirectMusicSegment8*       ptSegment8, 
                   IN CtIDirectMusicSegmentState8*  ptSegmentState8, 
                   IN DWORD                         dwTimeout,
                   IN BOOL                          enableBreak
                   )
/*++

Routine Description:

    Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment stopped within the specified time; E_FAIL otherwise.

--*/
{
    DWORD   dwStartTime     = 0;
    HRESULT hr = E_FAIL;

    // Is break enabled?
    if(enableBreak)
    {
        Log(FYILOGLEVEL, TEXT("Press any button to stop waiting"));
        dmthWaitForAllButtonsUp();
    }

    dwStartTime = timeGetTime();
    while (1)
    {
        // Has the segment stopped playing?
        hr = ptPerf8->IsPlaying(ptSegment8, ptSegmentState8);
        if (FAILED(hr))
        {
            Log(FYILOGLEVEL, "WaitForSegmentStop: Returned %s (%08X)", tdmXlatHRESULT(hr), hr);            
            break;
        }
        else if(S_FALSE == hr)
        {            
            return S_OK;
        }
 
        // Is break enabled?
        else if(enableBreak && dmthIsAnyButtonDown())
        {
            dmthWaitForAllButtonsUp();
            return E_FAIL;
        }

        if (timeGetTime() - dwStartTime >= dwTimeout)
        {
            Log(FYILOGLEVEL, "WaitForSegmentStop: Timed out after %dms", timeGetTime() - dwStartTime);
            hr = S_FALSE;
            break;
        }
    }

//    Log(FYILOGLEVEL, "WaitForSegmentStop: Exitted");


    return hr;
}




//------------------------------------------------------------------------------
//  WaitForSegmentStop
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStart(
                   IN CtIDirectMusicPerformance8*   ptPerf8, 
                   IN CtIDirectMusicSegment8*       ptSegment8, 
                   IN CtIDirectMusicSegmentState8*  ptSegmentState8, 
                   IN DWORD                         dwTimeout,
                   IN BOOL                          enableBreak
                   )
/*++

Routine Description:

    Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment stopped within the specified time; E_FAIL otherwise.

--*/
{
    DWORD   dwStartTime     = 0;
    HRESULT hr = E_FAIL;

    // Is break enabled?
    if(enableBreak)
    {
        Log(FYILOGLEVEL, TEXT("Press any button to stop waiting"));
        dmthWaitForAllButtonsUp();
    }

    dwStartTime = timeGetTime();
    while (1)
    {
        // Has the segment started playing?
        hr = ptPerf8->IsPlaying(ptSegment8, ptSegmentState8);
        if (FAILED(hr))
        {
            Log(FYILOGLEVEL, "WaitForSegmentStart: Returned %s (%08X)", tdmXlatHRESULT(hr), hr);            
            break;
        }
        else if(S_OK == hr)
        {            
            return S_OK;
        }
 
        // Is break enabled?
        else if(enableBreak && dmthIsAnyButtonDown())
        {
            dmthWaitForAllButtonsUp();
            return E_FAIL;
        }

        if (timeGetTime() - dwStartTime >= dwTimeout)
        {
            Log(FYILOGLEVEL, "WaitForSegmentStart: Timed out after %dms", timeGetTime() - dwStartTime);
            hr = S_FALSE;
            break;
        }
    }

    return hr;
}



/********************************************************************************
Returns S_OK if the segment started within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStart(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPCSTR szSegname, BOOL bEnableBreak)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStart(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout, bEnableBreak);
if (hr == S_FALSE)
{
    Log(ABORTLOGLEVEL, "ERROR: ""%s"" didn't start playing after %d ms", szSegname, dwTimeout);
    hr = E_FAIL;
}

return hr;
};


/********************************************************************************
Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStop(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPCSTR szSegname, BOOL bEnableBreak)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStop(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout, bEnableBreak);
if (hr == S_FALSE)
{
    Log(ABORTLOGLEVEL, "ERROR: ""%s"" didn't stop playing after %d ms", szSegname, dwTimeout);
    hr = E_FAIL;
}

return hr;
};


/********************************************************************************
Gets the current tempo.
********************************************************************************/
HRESULT GetTempo(CtIDirectMusicPerformance8 *ptPerf8, double *pdblTempo)
{
MUSIC_TIME mtTime = 0;
HRESULT hr = S_OK;
DMUS_TEMPO_PARAM Tempo = {NULL};
MUSIC_TIME mt = 0;

CHECKRUN(ptPerf8->GetTime(NULL, &mt));
CHECKRUN(ptPerf8->GetParamEx(GUID_TempoParam, 0, 0xFFFFFFFF, 0, mtTime, NULL, (void *)&Tempo));

if (SUCCEEDED(hr))
    *pdblTempo = Tempo.dblTempo;
else
    *pdblTempo = 0.f;

return hr;



}



/********************************************************************************
Caller must release the "real" tool.
********************************************************************************/
HRESULT WrapTool(IDirectMusicTool *pTool, CtIDirectMusicTool **pptTool)
{
    HRESULT             hr          = E_NOTIMPL;
    CtIDirectMusicTool *ptTool = NULL;

    if(!pTool)
    {
        return E_INVALIDARG;
    }

    ALLOCATEANDCHECK(ptTool, CtIDirectMusicTool);
    CHECKRUN(ptTool->InitTestClass(pTool));
    *pptTool = ptTool;
    return hr;

};


/********************************************************************************
********************************************************************************/
HRESULT dmthCreateToolGraph( CtIDirectMusicPerformance8* ptPerf8, IDirectMusicGraph** ppGraph )
{
    if ( NULL == ppGraph || NULL == ptPerf8 )
        return E_POINTER;

    HRESULT hr = S_OK;

    IDirectMusicPerformance* pPerf = NULL;
    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicGraph* pGraph = NULL;

    CHECKRUN( ptPerf8->GetRealObjPtr( &pPerf ) );
    CHECKALLOC( pPerf );

    CHECKRUN( pPerf->CreateStandardAudioPath( DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &pPath ) );
    CHECKALLOC( pPath );

    CHECKRUN( pPerf->SetDefaultAudioPath( pPath ) );

    CHECKRUN( pPath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE_GRAPH, 0, CLSID_DirectMusicGraph, 0, IID_IDirectMusicGraph, (LPVOID*) &pGraph ) );
    CHECKALLOC( pGraph );

    if ( SUCCEEDED( hr ) )
    {
        *ppGraph = pGraph;
        pGraph->AddRef();
    }

    RELEASE( pGraph );
    RELEASE( pPath );
    RELEASE( pPerf );

    return hr;
}



//==========================================================================
// dmthCreateLoader8
//
// CoCreates a loader, wraps the loader object, and does an init test class
//
// Parameters:
//  REFIID to Loader
//  pointer to wrapped loader object
//
// History:
//  03/17/98    a-llucar    Created
//  04/16/1998 - davidkl - cleaned up a bit.  moved here from tdmusic
//  02/10/2000 - kcraven  create overloaded method
//==========================================================================
HRESULT dmthCreateLoader(REFIID riid, CtIDirectMusicLoader8 **pptLoader)
{
    HRESULT hr          = E_NOTIMPL;
    IDirectMusicLoader8 *prLoader   = NULL;
    CtIDirectMusicLoader8  *ptLoader  = NULL;

    // CoCreate Loader object
    hr = DirectMusicCreateInstance(
        CLSID_DirectMusicLoader,
        NULL,        
        IID_IDirectMusicLoader8,
        (LPVOID*)&prLoader);
    if(FAILED(hr))
    {
        Log(MINLOGLEVEL,
            "**** CoCreate IDirectMusicLoader8 object "
            "failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto END;
    }


    // Wrap the Loader object
    ptLoader = new CtIDirectMusicLoader8();
    if(NULL == ptLoader)
    {
        Log(MINLOGLEVEL,
            "**** Unable to create test wrapped object "
            "(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto END;
    }
    hr = ptLoader->InitTestClass(prLoader);
    if(FAILED(hr))
    {
        Log(MINLOGLEVEL,
            "**** Unable to initialize test wrapped object "
            "(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto END;
    }

    // Set the GM DLS Collection so we can load midi files.
    if (g_TestParams.bUseGM_DLS)
    {
        LPCSTR szGM = "DMusic/DMTest1/Random/GM.DLS";
	    
        //Copy this over.
        CHECKRUN(MediaCopyFile(szGM));
        if(FAILED(hr))
        {
            Log(MINLOGLEVEL, "**** Failed to copy GM.DLS (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
            goto END;
        }
        
        DMUS_OBJECTDESC DESC;					
	    memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
	    DESC.dwSize = sizeof (DMUS_OBJECTDESC);
	    DESC.guidClass = CLSID_DirectMusicCollection;  
	    wcscpy(DESC.wszFileName,L"t:\\DMTest1\\random\\gm.dls");
	    DESC.guidObject = GUID_DefaultGMCollection;
	    DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
	    hr = ptLoader->SetObject(&DESC);
        if(FAILED(hr))
        {
            fnsLog(MINLOGLEVEL,
                "**** Unable to SetObject on GM.DLS object "
                "(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
            goto END;
        }
    }


    // clean up
END:
    if (prLoader)
    {
            prLoader->Release();
    }
    if (ptLoader)
    {
            *pptLoader = ptLoader;
    }
    return hr;
} // *** end dmthCreateLoader8






//==========================================================================
// dmthCreateLoader8
// UNWRAPPED VERSION!!!
//==========================================================================
HRESULT dmthCreateLoader(REFIID riid, IDirectMusicLoader8 **pptLoader)
{
    HRESULT hr          = E_NOTIMPL;
    IDirectMusicLoader8 *prLoader   = NULL;

    // CoCreate Loader object
    hr = DirectMusicCreateInstance(
        CLSID_DirectMusicLoader,
        NULL,        
        IID_IDirectMusicLoader8,
        (LPVOID*)&prLoader);
    if(FAILED(hr))
    {
        Log(MINLOGLEVEL,
            "**** CoCreate IDirectMusicLoader8 object "
            "failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto END;
    }

    // clean up
END:
    *pptLoader = prLoader;
    return hr;

} // *** end dmthCreateLoader



struct TRIO
{
LPSTR szExtension;
GUID *pCLSID;
GUID *pIID;
};

TRIO trio[] = 
{
{"aud", (GUID *)&CLSID_DirectMusicAudioPathConfig, (GUID *)&IID_IUnknown},
//{"bnd", (GUID *)&CLSID_DirectMusicBand,             (GUID *)&IID_IDirectMusicBand},
{"cdm", (GUID *)&CLSID_DirectMusicChordMap, (GUID *)&IID_IUnknown},
{"con", (GUID *)&CLSID_DirectMusicContainer, (GUID *)&IID_IUnknown},
{"dls", (GUID *)&CLSID_DirectMusicCollection, (GUID *)&IID_IUnknown},
{"sgt", (GUID *)&CLSID_DirectMusicSegment, (GUID *)&IID_IDirectMusicSegment},
{"sty", (GUID *)&CLSID_DirectMusicStyle, (GUID *)&IID_IUnknown},
{"spt", (GUID *)&CLSID_DirectMusicScript, (GUID *)&IID_IDirectMusicScript},
{"wav", (GUID *)&CLSID_DirectMusicSegment, (GUID *)&IID_IDirectMusicSegment}
};



HRESULT GUIDsFromFileName(LPSTR szFilename, GUID **ppCLSID, GUID **ppIID)
{
LPSTR szExt = NULL;
DWORD i = 0;
HRESULT hr = S_OK;

    //Find the extension.
    szExt = (LPSTR)PathFindFileExtension(szFilename);

    for (i=0; i<AMOUNT(trio); i++)
    {
        if (_strcmpi(trio[i].szExtension, szExt) == 0)
            break;
    }

    //Make sure we found it.
    if (i==AMOUNT(trio))
    {
        Log(ABORTLOGLEVEL, "Test App Error!  Couldn't find %s in array", szExt);
        hr = E_FAIL;
        goto END;
    }

    
    *ppCLSID  = trio[i].pCLSID;    
    *ppIID    = trio[i].pIID;    

END:
    return hr;
}



//------------------------------------------------------------------------------
//  ::dmthInitInput
//------------------------------------------------------------------------------
void 
dmthInitInput(void)
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   dwInputDevices;
    UINT    i;
    
    // Get the devices
    dwInputDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Save time and drop out now if no joysticks are plugged in
    if(!dwInputDevices)
    {
        dmthReleaseInput();
        return;
    }
    
    // Create a device for each port
    for(i=0; i<4; ++i) 
    {
        if(dwInputDevices & (1 << i)) 
            InitInput(i);
        else
            dmthReleaseInput(i);
    }
}

//------------------------------------------------------------------------------
//  ::dmthReleaseInput
//------------------------------------------------------------------------------
void 
dmthReleaseInput(
                 IN UINT port
                 )
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    IN port -   Port to release

Return Value:

    None

--*/
{
    if(g_dmthInputHandles[port]) 
    {
        XInputClose(g_dmthInputHandles[port]);
        g_dmthInputHandles[port] = NULL;
    }
}

//------------------------------------------------------------------------------
//  ::dmthReleaseInput
//------------------------------------------------------------------------------
void 
dmthReleaseInput(void)
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    None

Return Value:

    None

--*/
{
    UINT    i;

    for(i=0; i<4; ++i)
        dmthReleaseInput(i);
}

//------------------------------------------------------------------------------
//  ::dmthGetJoystickStates
//------------------------------------------------------------------------------
void 
dmthGetJoystickStates(void)
/*++

Routine Description:

    Polls the state of all attached joysticks, storing the results in 
    g_dmthJoysticks

Arguments:

    None

Return Value:

    None

--*/
{
    UINT i;

    // Get the state of all ports
    for(i=0; i<4; ++i)
        dmthGetJoystickState(i);
}

//------------------------------------------------------------------------------
//  ::dmthGetJoystickState
//------------------------------------------------------------------------------
BOOL
dmthGetJoystickState(
                     IN UINT    port
                     )
/*++

Routine Description:

    Polls the state of a single joystick, storing the result in 
    g_dmthJoysticks[port]

Arguments:

    IN port -   Port to poll

Return Value:

    TRUE for a valid poll, FLASE otherwise

--*/
{
    XINPUT_STATE    istate;

    // Simple error checking
    if(!dmthIsPortValid(port))
        return FALSE;

    // Query the input state
    if(XInputGetState(g_dmthInputHandles[port], &istate) != ERROR_SUCCESS) 
        return FALSE;

    // Joystick stick states
    g_dmthJoysticks[port].leftStickX    =  (float)istate.Gamepad.sThumbLX / 32768.0f;
    g_dmthJoysticks[port].leftStickY    = -(float)istate.Gamepad.sThumbLY / 32768.0f;
    g_dmthJoysticks[port].rightStickX   =  (float)istate.Gamepad.sThumbRX / 32768.0f;
    g_dmthJoysticks[port].rightStickY   = -(float)istate.Gamepad.sThumbRY / 32768.0f;

    // Analog buttons
    g_dmthJoysticks[port].x             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] / 255.0f;
    g_dmthJoysticks[port].y             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] / 255.0f;
    g_dmthJoysticks[port].white         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] / 255.0f;
    g_dmthJoysticks[port].a             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] / 255.0f;
    g_dmthJoysticks[port].b             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] / 255.0f;
    g_dmthJoysticks[port].black         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] / 255.0f;
    g_dmthJoysticks[port].leftTrigger   = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f;
    g_dmthJoysticks[port].rightTrigger  = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f;

    // Digital buttons
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)
        g_dmthJoysticks[port].leftStick = TRUE;
    else
        g_dmthJoysticks[port].leftStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
        g_dmthJoysticks[port].rightStick = TRUE;
    else
        g_dmthJoysticks[port].rightStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) 
        g_dmthJoysticks[port].dPadUp = TRUE;
    else
        g_dmthJoysticks[port].dPadUp = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) 
        g_dmthJoysticks[port].dPadDown = TRUE;
    else
        g_dmthJoysticks[port].dPadDown = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) 
        g_dmthJoysticks[port].dPadLeft = TRUE;
    else
        g_dmthJoysticks[port].dPadLeft = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) 
        g_dmthJoysticks[port].dPadRight = TRUE;
    else
        g_dmthJoysticks[port].dPadRight = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) 
        g_dmthJoysticks[port].back = TRUE;
    else
        g_dmthJoysticks[port].back = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_START) 
        g_dmthJoysticks[port].start = TRUE;
    else
        g_dmthJoysticks[port].start = FALSE;

    return TRUE;
}

//------------------------------------------------------------------------------
//  ::dmthWaitForAllButtons
//------------------------------------------------------------------------------
void
dmthWaitForAllButtons(
                      IN UINT   port,
                      IN DWORD  buttonMask
                      )
/*++

Routine Description:

    Waits for all buttons in the mask to be pressed.

    Note: Analog buttons/sticks must be pressed at least halfway for this to return TRUE

Arguments:

    IN port -       Port where event must occur
    IN buttonMask - Mask of buttons that will trigger a return

Return Value:

    None

--*/
{

    BOOL    notDone = TRUE;
    if (g_TestParams.bSkipUserInput)
        return;


    while(notDone)
    {
        notDone = FALSE;

        // Query all the joysticks
        if(dmthGetJoystickState(port))
        {
            if(((buttonMask & DMTH_JOYBUTTON_X) && (g_dmthJoysticks[port].x < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_Y) && (g_dmthJoysticks[port].y < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_WHITE) && (g_dmthJoysticks[port].white < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_A) && (g_dmthJoysticks[port].a < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_B) && (g_dmthJoysticks[port].b < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_BLACK) && (g_dmthJoysticks[port].black < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_LTRIG) && (g_dmthJoysticks[port].leftTrigger < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_RTRIG) && (g_dmthJoysticks[port].rightTrigger < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_LSTICK) && (g_dmthJoysticks[port].leftStick < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_RSTICK) && (g_dmthJoysticks[port].rightStick < 0.5f)) ||
               ((buttonMask & DMTH_JOYBUTTON_UP) && (g_dmthJoysticks[port].dPadUp == FALSE)) ||
               ((buttonMask & DMTH_JOYBUTTON_DOWN) && (g_dmthJoysticks[port].dPadDown == FALSE)) ||
               ((buttonMask & DMTH_JOYBUTTON_LEFT) && (g_dmthJoysticks[port].dPadLeft == FALSE)) ||
               ((buttonMask & DMTH_JOYBUTTON_RIGHT) && (g_dmthJoysticks[port].dPadRight == FALSE)) ||
               ((buttonMask & DMTH_JOYBUTTON_BACK) && (g_dmthJoysticks[port].back == FALSE)) ||
               ((buttonMask & DMTH_JOYBUTTON_START) && (g_dmthJoysticks[port].start == FALSE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_X) && (g_dmthJoysticks[port].x > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_Y) && (g_dmthJoysticks[port].y > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_WHITE) && (g_dmthJoysticks[port].white > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_A) && (g_dmthJoysticks[port].a > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_B) && (g_dmthJoysticks[port].b > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_BLACK) && (g_dmthJoysticks[port].black > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_LTRIG) && (g_dmthJoysticks[port].leftTrigger > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_RTRIG) && (g_dmthJoysticks[port].rightTrigger > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_LSTICK) && (g_dmthJoysticks[port].leftStick > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_RSTICK) && (g_dmthJoysticks[port].rightStick > minThreshold)) ||
               (!(buttonMask & DMTH_JOYBUTTON_UP) && (g_dmthJoysticks[port].dPadUp == TRUE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_DOWN) && (g_dmthJoysticks[port].dPadDown == TRUE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_LEFT) && (g_dmthJoysticks[port].dPadLeft == TRUE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_RIGHT) && (g_dmthJoysticks[port].dPadRight == TRUE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_BACK) && (g_dmthJoysticks[port].back == TRUE)) ||
               (!(buttonMask & DMTH_JOYBUTTON_START) && (g_dmthJoysticks[port].start == TRUE)))
            {
                notDone = TRUE;
            }
        }
    }
}

//------------------------------------------------------------------------------
//  ::dmthWaitForAnyButton
//------------------------------------------------------------------------------
DWORD
dmthWaitForAnyButton(
                     IN DWORD buttonMask
                     )
/*++

Routine Description:

    Waits for any button in the mask to be pressed.

    Note: Analog buttons/sticks must be pressed at least halfway for this to return TRUE

Arguments:

    IN buttonMask - Mask of buttons that will trigger a return

Return Value:

    The mask of the button(s) pressed

--*/
{
    BOOL    notDone = TRUE;
    DWORD   mask    = 0;
    UINT    i;

    if (g_TestParams.bSkipUserInput)
        return S_OK;


    while(notDone)
    {
        // Query all the joysticks
        dmthGetJoystickStates();

        for(i=0; i<4; ++i)
        {
            // Only check valid joysticks
            if(g_dmthInputHandles[i])
            {
                if((buttonMask & DMTH_JOYBUTTON_X) && (g_dmthJoysticks[i].x >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_X;
                }

                if((buttonMask & DMTH_JOYBUTTON_Y) && (g_dmthJoysticks[i].y >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_Y;
                }

                if((buttonMask & DMTH_JOYBUTTON_WHITE) && (g_dmthJoysticks[i].white >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_WHITE;
                }

                if((buttonMask & DMTH_JOYBUTTON_A) && (g_dmthJoysticks[i].a >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_A;
                }

                if((buttonMask & DMTH_JOYBUTTON_B) && (g_dmthJoysticks[i].b >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_B;
                }

                if((buttonMask & DMTH_JOYBUTTON_BLACK) && (g_dmthJoysticks[i].black >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_BLACK;
                }

                if((buttonMask & DMTH_JOYBUTTON_LTRIG) && (g_dmthJoysticks[i].leftTrigger >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_LTRIG;
                }

                if((buttonMask & DMTH_JOYBUTTON_RTRIG) && (g_dmthJoysticks[i].rightTrigger >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_RTRIG;
                }

                if((buttonMask & DMTH_JOYBUTTON_LSTICK) && (g_dmthJoysticks[i].leftStick >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_LSTICK;
                }

                if((buttonMask & DMTH_JOYBUTTON_RSTICK) && (g_dmthJoysticks[i].rightStick >= 0.5f))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_RSTICK;
                }

                if((buttonMask & DMTH_JOYBUTTON_UP) && (g_dmthJoysticks[i].dPadUp == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_UP;
                }

                if((buttonMask & DMTH_JOYBUTTON_DOWN) && (g_dmthJoysticks[i].dPadDown == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_DOWN;
                }

                if((buttonMask & DMTH_JOYBUTTON_LEFT) && (g_dmthJoysticks[i].dPadLeft == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_LEFT;
                }

                if((buttonMask & DMTH_JOYBUTTON_RIGHT) && (g_dmthJoysticks[i].dPadRight == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_RIGHT;
                }

                if((buttonMask & DMTH_JOYBUTTON_BACK) && (g_dmthJoysticks[i].back == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_BACK;
                }

                if((buttonMask & DMTH_JOYBUTTON_START) && (g_dmthJoysticks[i].start == TRUE))
                {
                   notDone  = FALSE;
                   mask     |= DMTH_JOYBUTTON_START;
                }
            }
        }
    }
    return mask;
}

//------------------------------------------------------------------------------
//  ::dmthIsPortValid
//------------------------------------------------------------------------------
BOOL
dmthIsPortValid(
                IN UINT port
                )
/*++

Routine Description:

    Returns TRUE if the port number is valid

Arguments:

    IN port -   Port to query

Return Value:

    TRUE if the port is valid (has a controller attached) FALSE otherwise

--*/
{
    if(g_dmthInputHandles[port] == NULL)
    {
        InitInput(port);
        return (g_dmthInputHandles[port] != NULL) ? TRUE : FALSE;
    }
    return TRUE;
}




//------------------------------------------------------------------------------
//  ::dmthPromptUserTestResults
//------------------------------------------------------------------------------
void
dmthPromptUserTestResults(
                    HRESULT &hr,
                    IN ANSWER   yesNoExpected,
                    IN LPSTR    yesNoQuestion,
                    ...
                    )


/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    
    
    BOOL bResult = FALSE;
    va_list va = {0};
    char szBuffer[1000] = {0};

    if (FAILED(hr))
        return;

    if (g_TestParams.bSkipUserInput)
        return;

    va_start(va, yesNoQuestion);
    vsprintf(szBuffer, yesNoQuestion, va);
    va_end(va);

    bResult = dmthPromptUserYesNo(szBuffer);
    if (bResult && (yesNoExpected == EXPECT_NO))
    {
        Log(ABORTLOGLEVEL, "Answer was yes, expected no.");
        hr = E_FAIL;
    }
    if (!bResult && (yesNoExpected == EXPECT_YES))
    {
        Log(ABORTLOGLEVEL, "Answer was no, expected yes.");
        hr = E_FAIL;
    }

};





//------------------------------------------------------------------------------
//  ::dmthPromptUserYesNo
//------------------------------------------------------------------------------
BOOL
dmthPromptUserYesNo(
                    IN LPSTR    yesNoQuestion,
                    IN          ...
                    )
/*++

Routine Description:

    Prompts the user to respond to a yes/no question by pressing the A or B 
    button: A = Yes, B = No

Arguments:

    IN yesNoQuestion -  Question to ask the user (varargs)
    IN ... -            The varargs

Return Value:

    TRUE if the user pressed A (Yes), FALSE if the user pressed B (No)

--*/
{
    DWORD   response = 0;
    va_list va = {0};
    char    szBuffer[1000] = {0};

    if (g_TestParams.bSkipUserInput)
        return TRUE;

    va_start(va, yesNoQuestion);
    vsprintf(szBuffer, yesNoQuestion, va);
    va_end(va);
    
    //
    while(1)
    {
        // Display the question:
        Log(FYILOGLEVEL, TEXT("QUESTION: %s (A = Yes, B = No)"), szBuffer);

        // Wait for a response
        response = dmthWaitForAnyButton(DMTH_JOYBUTTON_A | DMTH_JOYBUTTON_B);

        // Then wait for all buttons to be up
        dmthWaitForAllButtonsUp();

        // Yes? Log success
        if(response == DMTH_JOYBUTTON_A)
        {
            Log(FYILOGLEVEL, TEXT("ANSWER: Yes"));
            return TRUE;
        }

        // No? Log Failure
        else if(response == DMTH_JOYBUTTON_B)
        {
            Log(FYILOGLEVEL, TEXT("ANSWER: No"));
            return FALSE;
        }
    }
}

//------------------------------------------------------------------------------
//  ::dmthWaitForAllButtonsUp
//------------------------------------------------------------------------------
void
dmthWaitForAllButtonsUp(void)
/*++

Routine Description:

    Waits until all joystick buttons are up

Arguments:

    None

Return Value:

    None

--*/
{
    UINT    i;
    BOOL    notDone = TRUE;

    if (g_TestParams.bSkipUserInput)
        return;

    while(notDone)
    {
        notDone = FALSE;

        // Query all the joysticks
        dmthGetJoystickStates();

        for(i=0; i<4; ++i)
        {
            // Only check valid joysticks
            if(g_dmthInputHandles[i])
            {
                if((g_dmthJoysticks[i].x > minThreshold) ||
                   (g_dmthJoysticks[i].y > minThreshold) ||
                   (g_dmthJoysticks[i].white > minThreshold) ||
                   (g_dmthJoysticks[i].a > minThreshold) ||
                   (g_dmthJoysticks[i].b > minThreshold) ||
                   (g_dmthJoysticks[i].black > minThreshold) ||
                   (g_dmthJoysticks[i].leftTrigger > minThreshold) ||
                   (g_dmthJoysticks[i].rightTrigger > minThreshold) ||
                   (g_dmthJoysticks[i].leftStick > minThreshold) ||
                   (g_dmthJoysticks[i].rightStick > minThreshold) ||
                   (g_dmthJoysticks[i].dPadUp == TRUE) ||
                   (g_dmthJoysticks[i].dPadDown == TRUE) ||
                   (g_dmthJoysticks[i].dPadLeft == TRUE) ||
                   (g_dmthJoysticks[i].dPadRight == TRUE) ||
                   (g_dmthJoysticks[i].back == TRUE) ||
                   (g_dmthJoysticks[i].start == TRUE))
                {
                   notDone  = TRUE;
                }
            }
        }
    }
}

//------------------------------------------------------------------------------
//  dmthIsAnyButtonDown
//------------------------------------------------------------------------------
BOOL
dmthIsAnyButtonDown(void)
/*++

Routine Description:

    Returns TRUE if any controller button is down

Arguments:

    None

Return Value:

    TRUE if any controller button is down (at least 50%), FALSE otherwise

--*/
{
    UINT i;

    dmthGetJoystickStates();

    for(i=0; i<4; ++i)
    {
        // Only check valid joysticks
        if(g_dmthInputHandles[i])
        {
            if((g_dmthJoysticks[i].x > 0.5f) ||
               (g_dmthJoysticks[i].y > 0.5f) ||
               (g_dmthJoysticks[i].white > 0.5f) ||
               (g_dmthJoysticks[i].a > 0.5f) ||
               (g_dmthJoysticks[i].b > 0.5f) ||
               (g_dmthJoysticks[i].black > 0.5f) ||
               (g_dmthJoysticks[i].leftTrigger > 0.5f) ||
               (g_dmthJoysticks[i].rightTrigger > 0.5f) ||
               (g_dmthJoysticks[i].leftStick > 0.5f) ||
               (g_dmthJoysticks[i].rightStick > 0.5f) ||
               (g_dmthJoysticks[i].dPadUp == TRUE) ||
               (g_dmthJoysticks[i].dPadDown == TRUE) ||
               (g_dmthJoysticks[i].dPadLeft == TRUE) ||
               (g_dmthJoysticks[i].dPadRight == TRUE) ||
               (g_dmthJoysticks[i].back == TRUE) ||
               (g_dmthJoysticks[i].start == TRUE))
            {
               return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL FloatsAreEqual(const float& f1, const float& f2)
{
  return ((fabs(f1 - f2) < 1.0e-6) ? TRUE : FALSE);
}


HRESULT Fail_On_Purpose(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return E_FAIL;
}


//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    
    if (_strcmpi("Default", g_TestParams.szDSScratchImage) == 0)
    {
        CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));
    }
    else
    {
        CHECKRUN(XAudioDownloadEffectsImage(pszScratchFile, &EffectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, &pDesc));
    }

    return hr;
}

//------------------------------------------------------------------------------
//	InitializeDSound
//------------------------------------------------------------------------------
HRESULT InitializeDSound(IDirectSound **ppDSound)
/*++
Routine Description:
	Downloads the scratch image to the DSP
Return Value:
	S_OK on success, any other value on failure
*/
{
HRESULT hr = S_OK;

CHECKRUN(DirectSoundCreate( NULL, ppDSound, NULL ));
if (_strcmpi("none", g_TestParams.szDSScratchImage))
    CHECKRUN(DownloadScratch(*ppDSound, g_TestParams.szDSScratchImage));

if (_strcmpi("full", g_TestParams.szDSHRTF) == 0)
{CHECK(DirectSoundUseFullHRTF());}
else if (_strcmpi("light", g_TestParams.szDSHRTF) == 0)
{CHECK(DirectSoundUseLightHRTF());}
else ASSERT(FALSE);
return hr;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT ClearAllPMsgs(CtIDirectMusicPerformance8 *ptPerf8)
{
DMUS_NOTIFICATION_PMSG *pMsg = NULL;


    //Cleaning up any last notifications.
    while (S_OK == ptPerf8->GetNotificationPMsg(&pMsg))
    {
        if (pMsg)
        {
            ptPerf8->FreePMsg((DMUS_PMSG *)pMsg);
            pMsg = NULL;
        }
    }

return S_OK;

}




//------------------------------------------------------------------------------
// Caller must delete[] what it receives in ppvAudioData and pwfxFormat.
//------------------------------------------------------------------------------
HRESULT HelpLoadWaveFileData(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize)
{
    LPXFILEMEDIAOBJECT      pFile           = NULL;
    HRESULT                 hr              = DS_OK;
    LPCWAVEFORMATEX         pwfxFormat;
    LPWAVEFORMATEX          pwfxFormatOut   = NULL;
    XMEDIAPACKET            xmp;
    DWORD                   dwAudioDataSize = 0;
    LPVOID                  pvAudioData     = NULL;

    //Create the media object.
    hr = XWaveFileCreateMediaObject(pszFile, &pwfxFormat, &pFile);
    if(SUCCEEDED(hr))
    {
        
        //Allocate our pwfxFormat.
        if(!(pwfxFormatOut = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory(pwfxFormatOut, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = pFile->GetLength(&dwAudioDataSize);
    }

    //Allocate our data.
    if(SUCCEEDED(hr))
    {
        if(!(pvAudioData = new BYTE [dwAudioDataSize]))
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwAudioDataSize;
        
        hr = pFile->Process(NULL, &xmp);
    }

    if(pFile)
    {
        pFile->Release();
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(pwfxFormatOut);
        ASSERT(pvAudioData);
        ASSERT(dwAudioDataSize);
        

        *ppwfxFormat = pwfxFormatOut;
        *ppvAudioData = pvAudioData;
        *pdwAudioDataSize = dwAudioDataSize;
    }

    return hr;
}

//==================================================================================
// StringHexToDWord
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in string representation of a hexadecimal DWORD
//				to the actual DWORD value.  It ignores any non-English number
//				characters.
//
// Arguments:
//	char* szString		Textual representation of value.
//
// Returns: The value of the string converted into a DWORD.
//==================================================================================
DWORD StringHexToDWord(char* szString)
{
	DWORD	dwValue = 0;
	DWORD	dwTemp;


	// If the string starts with that "0x" prefix, we should move past that.
	//if (StringStartsWith(szString, "0x", false))
    if (szString[0] == '0' && szString[0] == 'x')
		szString += 2;


	if ((strlen(szString) < 1) || (strlen(szString) > 8))
		return (0);


	dwValue = 0;
	for(dwTemp = 0; dwTemp < strlen(szString); dwTemp++)
	{
		dwValue *= 16; // shift the hexadecimal place
		switch (szString[dwTemp])
		{
			case '0':
			  break; // don't add anything
			case '1':
				dwValue += 1;
			  break;
			case '2':
				dwValue += 2;
			  break;
			case '3':
				dwValue += 3;
			  break;
			case '4':
				dwValue += 4;
			  break;
			case '5':
				dwValue += 5;
			  break;
			case '6':
				dwValue += 6;
			  break;
			case '7':
				dwValue += 7;
			  break;
			case '8':
				dwValue += 8;
			  break;
			case '9':
				dwValue += 9;
			  break;
			case 'a':
			case 'A':
				dwValue += 10;
			  break;
			case 'b':
			case 'B':
				dwValue += 11;
			  break;
			case 'c':
			case 'C':
				dwValue += 12;
			  break;
			case 'd':
			case 'D':
				dwValue += 13;
			  break;
			case 'e':
			case 'E':
				dwValue += 14;
			  break;
			case 'f':
			case 'F':
				dwValue += 15;
			  break;
			default:
				dwValue = dwValue / 16; // shift the hexadecimal place back
			  break; // we got a wacky character
		} // end switch (on the letter)
	} // end for (loop through each letter in the string)

	return (dwValue);
} // StringHexToDWord


// StringContainsChar
//----------------------------------------------------------------------------------
//
// Description: Returns -1 if the passed string doesn't contain the char, otherwise
//				it returns the zero based position the first instance of the char
//				was found.  This checking starts at the value passed for iPos, so
//				pass zero if you want it to start at the beginning of the string. 
//
// Arguments:
//	char* szString		String to search.
//	char cCharToFind	Character to search for.
//	BOOL fMatchCase		Whether the character's case is important or not.
//	int iPos			Offset in string to begin looking
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringContainsChar(char* szString, char cCharToFind, BOOL fMatchCase, int iPos)
{
	if (szString == NULL)
		return (-1);

	// (int) is to get rid of compiler warning
	if (iPos >= (int) strlen(szString))
		return (-1);

	if (iPos < 0)
		iPos = 0;

	if (cCharToFind == '\0')
		return (-1);

	if (fMatchCase)
	{
		while((szString[iPos] != '\0') && (szString[iPos] != cCharToFind))
			iPos++;
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char	szTemp[2];


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		szTemp[0] = cCharToFind;
		szTemp[1] = '\0';
		_strlwr(szTemp);

		while((pszLowerString[iPos] != '\0') &&
				(pszLowerString[iPos] != szTemp[0]))
		{
			iPos++;
		} // end while (not at end of string and not case-insensitive character)

		LocalFree(pszLowerString);
		pszLowerString = NULL;
	} // end else (we don't have to match the case)

	if (szString[iPos] == '\0')	// if we didn't find it
		return (-1);	// failure
	
	return (iPos);
} // StringContainsChar





//==================================================================================
// StringCountNumChars
//----------------------------------------------------------------------------------
//
// Description: Returns the number of times the string contains the passed in
//				character, or 0 if none. 
//
// Arguments:
//	char* szString		String to search.
//	char cCharToFind	Character to search for.
//	BOOL fMatchCase		Whether the character's case is important or not.
//
// Returns: The index of the char, or -1 if not found.
//==================================================================================
int StringCountNumChars(char* szString, char cCharToFind, BOOL fMatchCase)
{
	int				iCount = 0;
	unsigned int	ui;


	if (szString == NULL)
		return (-1);

	if (fMatchCase)
	{
		for(ui = 0; ui < strlen(szString); ui++)
		{
			if (szString[ui] == cCharToFind)
				iCount++;
		} // end for (each character in the string)
	} // end if (we have to match the case)
	else
	{
		char*	pszLowerString;
		char	szTemp[2];


		pszLowerString = (char*) LocalAlloc(LPTR, strlen(szString) + 1);
		if (pszLowerString == NULL)
			return (-1);

		strcpy(pszLowerString, szString);
		_strlwr(pszLowerString);


		szTemp[0] = cCharToFind;
		szTemp[1] = '\0';
		_strlwr(szTemp);


		for(ui = 0; ui < strlen(szString); ui++)
		{
			if (pszLowerString[ui] == szTemp[0])
				iCount++;
		} // end for (each character in the string)
	} // end else (we don't have to match the case)
	
	return (iCount);
} // StringCountNumChars



// StringToGuid
//----------------------------------------------------------------------------------
//
// Description: Converts the passed in string representation of a GUID to the actual
//				GUID. 
//
// Arguments:
//	char* szString			Textual representation of guid.
//	LPGUID pguidResult		Pointer to guid to store result in.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StringToGuid(char* szString, LPGUID pguidResult)
{
	int		iOldPos = 0;
	int		iNewPos = 0;
	char	szSegment[9];
	DWORD	dwValue = 0;
	int		i;



	// Skip the beginning
	while ((szString[iOldPos] == ' ') ||
			(szString[iOldPos] == '\t') ||
			(szString[iOldPos] == '{'))
	{
		iOldPos++;
	} // end while (it starts with an ignore character)


	// Data1 = 1 DWORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// Make sure we've got 8 valid characters of data (assume high order zeroes if
	// it's fewer than 8 characters).
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 9)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data1 = StringHexToDWord(szSegment);

	iOldPos = iNewPos + 1;



	// Data2 = 1 WORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// 4 characters.
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 5)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data2 = (WORD) StringHexToDWord(szSegment);

	iOldPos = iNewPos + 1;



	// Data3 = 1 WORD

	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	// 4 characters.
	if ((iNewPos < 0) || (iNewPos > (iOldPos + 5)))
		return (ERROR_INVALID_PARAMETER);


	ZeroMemory(szSegment, 9);
	CopyMemory(szSegment, szString + iOldPos, (iNewPos - iOldPos));

	pguidResult->Data3 = (WORD) StringHexToDWord(szSegment);


	iNewPos = StringContainsChar(szString, '-', false, iOldPos);

	iOldPos = strlen(szString); // temp variable

	// Make sure there are enough single bytes at the end here
	if (iNewPos + 16 > iOldPos)
		return (ERROR_INVALID_PARAMETER);


	// Move past dash
	iNewPos++;

	// Data4 = 8 single bytes

	for(i = 0; i < 8; i++)
	{
		if (i == 2)
		{
			if (szString[iNewPos] != '-')
				return (ERROR_INVALID_PARAMETER);

			// If it is the dash, then we want to skip it
			iNewPos++;
		} // end if (we should be at a dash)

		ZeroMemory(szSegment, 9);
		CopyMemory(szSegment, szString + iNewPos, 2);

		pguidResult->Data4[i] = (BYTE) StringHexToDWord(szSegment);

		iNewPos += 2;
	} // end for (each of the 8 individual bytes)


	return (S_OK);
} // StringToGuid



//Memory checking stuff
/********************************************************************************
********************************************************************************/
void GetMemoryStats(LONG *pLongArray, DWORD dwMax)
{
    for (DWORD i=0; i<dwMax; i++)
    {
        pLongArray[i] = DirectMusicMemCheck(i, NULL);
    }
};

/********************************************************************************
********************************************************************************/
void CompareMemoryStats(LONG *pLast, LONG *pCurrent, DWORD dwMax, LPSTR szTestName)
{  
  LPSTR szObjectName = NULL;
  for (DWORD i=0; i<dwMax; i++)
  {
    //Don't check unsupported ones.
    if (pLast[i] != -1 && pCurrent[i] != -1)
    {
        if (pLast[i] < pCurrent[i])
            Log(ABORTLOGLEVEL, "POSSIBLE MEMORY LEAK in %-54s", szTestName);
        if (pLast[i] > pCurrent[i])
            Log(ABORTLOGLEVEL, "REDEMPTION in %-66s", szTestName);

        if (pLast[i] != pCurrent[i])
        {
            DirectMusicMemCheck(i, &szObjectName);
            Log(ABORTLOGLEVEL, "%s count went from %u to %u", szObjectName, pLast[i], pCurrent[i]);
        }
    }
  }
};




/********************************************************************************
Either waits or continues on, at end of test, depending on settings.
********************************************************************************/
void EndTestRun(void)
{
int  dwValue[4] = {0};
CHAR dwDelta[4] = {1, 2, 1, -1};

    if (g_TestParams.bWaitAtTestEnd)    
    {
        Log(FYILOGLEVEL, "Please have a super-happy day!");
        
        //we want to do an infinite loop here.
        //lint -e716 
        while (1)
        //lint +e716
        {

            for (int i=0; i<4; i++)
            {
                dwValue[i] += dwDelta[i];
                if (dwValue[i] > 255)
                {
                    dwValue[i] = 255;
                    dwDelta[i] = -(rand() % 3 + 1);
                }

                if (dwValue[i] < 64 )
                {
                    dwValue[i] = 64;
                    dwDelta[i] = (rand() % 3 + 1);
                }

            }



            xSetBackgroundColor(
                             BYTE(dwValue[0]), 
                             BYTE(dwValue[1]), 
                             BYTE(dwValue[2]), 
                             BYTE(dwValue[3])
                             );
            Sleep(20);
        }

    }
    else
    {
        Log(FYILOGLEVEL, "Displayin' test results for 1 second");
        Sleep(1000);
    }
}



/********************************************************************************
********************************************************************************/
BOOL IsValidAudioPath(DWORD dwAudioPath)
{
BOOL bFound = FALSE;
DWORD dwValidPaths[] = {
  DMUS_APATH_SHARED_STEREOPLUSREVERB,
  DMUS_APATH_SHARED_STEREO,
  DMUS_APATH_DYNAMIC_3D,
  DMUS_APATH_DYNAMIC_MONO,
  DMUS_APATH_MIXBIN_QUAD               ,
  DMUS_APATH_MIXBIN_QUAD_ENV,
  DMUS_APATH_MIXBIN_QUAD_ENV,
  DMUS_APATH_MIXBIN_QUAD_MUSIC,
  DMUS_APATH_MIXBIN_5DOT1,
  DMUS_APATH_MIXBIN_5DOT1_ENV,
  DMUS_APATH_MIXBIN_5DOT1_MUSIC,
  DMUS_APATH_MIXBIN_STEREO_EFFECTS
};

for (int i=0; i<NUMELEMS(dwValidPaths); i++)
{
    if (dwAudioPath == dwValidPaths[i])
    {
        bFound = TRUE;
        break;
    }
}

return bFound;
}


BOOL InitPerformanceEveryTest(void)
{
    return (_strcmpi(g_TestParams.szInitPerformance, "EveryTest") == 0);
};


BOOL InitPerformanceOnce(void)
{
    return (_strcmpi(g_TestParams.szInitPerformance, "Once") == 0);
};


BOOL InitPerformanceNever(void)
{
    return (_strcmpi(g_TestParams.szInitPerformance, "Never") == 0);

};









/********************************************************************************
Note: These conversion functions differ from DMusic's in that DMusic converts
      between the RT passed since performance initialization and the MT passed
      since performance initialization.  Since DMusic's MT "clock" ticks faster or
      slower depending on the tempo, the DMusic converstion functions don't provide
      an accurate conversion for time deltas.
********************************************************************************/
//BASIC FORMULAS FOR CONVERSION BETWEEN REFERENCE AND MUSIC TIME.

//mt = rt ticks   seconds   beats   minutes    mt ticks
//              * ------- * ----- * -------- * -------
//                rt tick   minute  second     beat


//
//mt = 1         fTempo beats  1    mt ticks
//     ------- * -----       * -- * --------
//     10000000  minute        60   beat

//mt = rtTicks * fTempo * DMUS_PPQ * 3
//     ---------------------------
//               600000000

//rt = mtTicks * 600000000 
//     ------------------
//     fTempo  * DMUS_PPQ * 3




//===========================================================================
//===========================================================================
HRESULT ReferenceToMusicTime(CtIDirectMusicPerformance8 *ptPerf8, REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime)
{
    HRESULT hr = S_OK;
    double fTempo = 0;
    MUSIC_TIME mtTime = 0;

    CHECKPTR(ptPerf8);
    CHECKPTR(pmtTime);

    CHECKRUN(GetTempo(ptPerf8, &fTempo));
        
    //Safest to convert things to a double.
    mtTime = MUSIC_TIME(double(rtTime) * fTempo * double(DMUS_PPQ)  / double(600000000));

    *pmtTime = mtTime;

    return S_OK;
}



//===========================================================================
//===========================================================================
HRESULT MusicToReferenceTime(CtIDirectMusicPerformance8 *ptPerf8, MUSIC_TIME mtTime, REFERENCE_TIME *prtTime)
{
    HRESULT hr = S_OK;
    double fTempo = 0;
    REFERENCE_TIME rtTime = 0;

    CHECKPTR(ptPerf8);
    CHECKPTR(prtTime);

    CHECKRUN(GetTempo(ptPerf8, &fTempo));
        
    //Safest to convert things to a double.
    rtTime = REFERENCE_TIME(double(mtTime) * double(600000000) / fTempo / double(DMUS_PPQ));

    *prtTime = rtTime;

    return S_OK;
}

//===========================================================================
//===========================================================================
double CalculateErrorPercentage(double tExpected, double tActual)
{
    double fError = 0.f;

    if (tExpected != 0.f)
        fError = fabs(tExpected- tActual) / tExpected * 100.f;
    else
        fError = fabs(tExpected- tActual) / 1.f * 100.f;

    return fError;
        
}


//===========================================================================
//===========================================================================
LPCSTR MediaServerToLocal(LPCSTR szFrom)
{
ASSERT(szFrom);
CHAR szTemp[MAX_PATH] = {0};
LPSTR szChopped = NULL;
static CHAR szOut[MAX_PATH] = {0};
LPCSTR szStrings[] = {"dmusic/", "sgt/", "wav/", "dls/"};
DWORD i = 0;

//TODO: Add a critical section here.


//Begin the conversion of the from path to the 'to' path.
strcpy(szTemp, szFrom);
_strlwr(szTemp);

//Verify that the string starts with "DMusic\\"
BOOL bFound = FALSE;
for (i=0; i<NUMELEMS(szStrings); i++)
{
    if (strstr(szTemp, szStrings[i]))
    {
        bFound = TRUE;
    }
}
ASSERT(bFound);


ASSERT(szTemp[0] != '/');

//Chop off the directory name if it's "dmusic/"
if (strstr(szTemp, szStrings[0]))
{
    szChopped = strstr(szTemp, szStrings[0]);
    szChopped += strlen(szStrings[0]);
}
else
{
    szChopped = szTemp;
}

//Change all the '/' to '\\'
for (DWORD i=0; (szTemp[i] != NULL) && (i != MAX_PATH); i++)
{
    if (szTemp[i] == '/')
        szTemp[i] = '\\';
}

sprintf(szOut, "T:\\%s", szChopped);

return szOut;
}

//===========================================================================
//===========================================================================
HRESULT MediaServerToLocal(LPCSTR szServer, LPSTR szLocal)
{
    ASSERT(szServer);
    ASSERT(szLocal);
    strcpy(szLocal, MediaServerToLocal(szServer));
    return S_OK;
};


//===========================================================================
//===========================================================================
HRESULT MediaCopyFile(LPCSTR szFromPath, LPCSTR szToPath, DWORD dwFlags)
{
HRESULT hr = S_OK;
MEDIAFILEDESC MediaFileDesc[] = {NULL, NULL, NULL, TERMINATE};
LPCSTR szDestination = NULL;
CHAR szDestinationDir[MAX_PATH] = {0};

if (SUCCEEDED(hr))
{
    if (!szToPath)
        szDestination = MediaServerToLocal(szFromPath);
    else
        szDestination = szToPath;
}

CHECKRUN(ChopPath(szDestination, szDestinationDir, NULL));

if (SUCCEEDED(hr))
{
    MediaFileDesc[0].lpszFromPath= (LPSTR)szFromPath;
    MediaFileDesc[0].lpszToPath  = (LPSTR)szDestinationDir;
    MediaFileDesc[0].dwFlags = dwFlags;

    hr = LoadMedia(&MediaFileDesc[0]);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "MediaCopyFile: Failed to copy %s to %s (%08X = %s)", szFromPath, szDestination, hr, tdmXlatHRESULT(hr));
    }
}

return hr;
}

//===========================================================================
//===========================================================================
HRESULT MediaCopyFile(LPCSTR szFromPath, LPCSTR szToPath)
{
    return MediaCopyFile(szFromPath, szToPath, COPY_IF_NEWER);
};

//===========================================================================
//===========================================================================
HRESULT MediaCopyFile(LPCSTR szFromPath, DWORD dwFlags)
{
    return MediaCopyFile(szFromPath, NULL, dwFlags);
};

//===========================================================================
//===========================================================================
HRESULT MediaCopyFile(LPCSTR szFromPath)
{
    return MediaCopyFile(szFromPath, NULL, COPY_IF_NEWER);
};


//===========================================================================
//This can take a file name as well as a file directory.
//===========================================================================
HRESULT MediaCopyDirectory(LPCSTR szFromPath, LPCSTR szToPath, DWORD dwFlags)
{
MEDIAFILEDESC MediaFileDesc[] = {NULL, NULL, NULL, TERMINATE};

HRESULT hr = S_OK;
CHAR szTemp[MAX_PATH] = {0};
CHAR szSourcePath[MAX_PATH] = {0};
LPCSTR szDestination = NULL;

ASSERT(szFromPath);

if (SUCCEEDED(hr))
{
    
    //If there's no '.' and the name doesn't end in a slash, then we have a problem.
    if ('/' != szFromPath[strlen(szFromPath) - 1] && !strstr(szFromPath, "."))
    {
        Log(ABORTLOGLEVEL, "MediaCopyDirectory: Don't know if %s is a file name or directory name", szFromPath);
        hr = E_FAIL;
    }
}

//Pull any filename off the source path.
CHECKRUN(ChopPath(szFromPath, szTemp, NULL));

if (SUCCEEDED(hr))
{
    //Make a destination path from the source path, if necessary.
    if (!szToPath)
        szDestination = MediaServerToLocal(szTemp);
    else
        szDestination = szToPath;


    //Tack on a "*" to the source path.
    sprintf(szSourcePath, "%s(\\w*).(\\w*)", szTemp);

    //Set up for the copy.
    MediaFileDesc[0].lpszFromPath = (LPSTR)szSourcePath;
    MediaFileDesc[0].lpszToPath   = (LPSTR)szDestination;
    MediaFileDesc[0].dwFlags = dwFlags;

    //Makin' copies!  The copymeister...
    hr = LoadMedia(&MediaFileDesc[0]);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "MediaCopyDirectory: Failed to copy %s to %s (%08X = %s)", szSourcePath, szToPath, hr, tdmXlatHRESULT(hr));
    }
}

return hr;
}

//===========================================================================
//This can take a file name as well as a file directory.
//===========================================================================
HRESULT MediaCopyDirectory(LPCSTR szFromPath, LPCSTR szToPath)
{
    return MediaCopyDirectory(szFromPath, szToPath, COPY_IF_NEWER);
}

//===========================================================================
//This can take a file name as well as a file directory.
//===========================================================================
HRESULT MediaCopyDirectory(LPCSTR szFromPath, DWORD dwFlags)
{
    return MediaCopyDirectory(szFromPath, NULL, dwFlags);
}


//===========================================================================
//This can take a file name as well as a file directory.
//===========================================================================
HRESULT MediaCopyDirectory(LPCSTR szFromPath)
{
    return MediaCopyDirectory(szFromPath, NULL, COPY_IF_NEWER);
}


//===========================================================================
//===========================================================================
BOOL FilesInSameDirectory(LPSTR szFiles[], DWORD dwCount)
{
BOOL bDifferentDirectory = FALSE;
CHAR szPath0[MAX_PATH];
CHAR szPathCurrent[MAX_PATH];
    ChopPath(szFiles[0],szPath0, NULL);
    for (DWORD i=1; i<AMOUNT(szFiles); i++)
    {
        ChopPath(szFiles[i],szPathCurrent, NULL);
        if (_strcmpi(szPathCurrent, szPath0) != 0)
        {
            bDifferentDirectory = TRUE;
            Log(ABORTLOGLEVEL, "%s is in a different directory from %s", szPathCurrent, szPath0);
            break;
        }
    };

    return !bDifferentDirectory;
}


//===========================================================================
//===========================================================================
HRESULT ThreadPriFromString(LPCSTR szString, DWORD *pdwPri)
//Verify that an appropriate thread priority was selected.
{
    if (pdwPri)
        *pdwPri = 0xFFFFFFFF;

    BOOL bFound = FALSE;
    for (DWORD i=0; i<g_dwThreadPris; i++)
    {
        if (_strcmpi(szString, g_ThreadPris[i].sz) == 0)
        {
            bFound = TRUE;
            if (pdwPri)
                *pdwPri = g_ThreadPris[i].dw;
            break;
        }
    }

    if (!bFound)
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\globals.h ===
#pragma once

#undef UNICODE  //Ugh, UNICODE on XBox is like tar on pancakes.
#define INITGUID

#include <xtl.h>
#include <xdbg.h>
#include <xnetref.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xobjbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <float.h>
#include <dmusici.h>

#include <dmth.h>

#ifdef NOLOG
    #include "nakedmacros.h"
#else
    #include <macros.h>
#endif bz

#include "logging.h"
#include "fakestuff.h"
#pragma warning( disable : 4056 4756 4005)

#include "helpers.h"
#include "ToolTest.h"
#include "ToolEcho.h"
#include "ToolTrace.h"
#include "cicmusicx.h"
#include "medialoader.h"

//lint -e762
extern HANDLE g_hLog;
//lint +e762

#define PACK(x,y) (((DWORD)(x << 16)) + (DWORD)y)
#define UNPACK(a, x, y) {x=(a)>>16; y=(a) & 0x0000FFFF;}

// Disable messages about floating point overflow.
#pragma warning( disable : 4056 4756)



#define szInitPerformance_SIZE 10


struct TESTPARAMS
{
    BOOL bWait;
    BOOL bBVT;
    BOOL bValid;
    BOOL bInvalid;
    BOOL bFatal;
    BOOL bPerf;
    BOOL bStress;
    BOOL bWaitAtTestEnd;
    BOOL bSkipUserInput;
    BOOL bLogToScreen;
    BOOL bUseGM_DLS;
    BOOL bSuppressMemInfo;
    DWORD dwPerfWait;
    DWORD dwWaitBetweenTests;
    DWORD dwDebugLevel;
    DWORD dwRIPLevel;
    DWORD dwMLDebugLevel;
    DWORD dwLocalLogLevel;
    DWORD bDoWorkLocalThread;
    DWORD dwDoWorkFrequency;
    DWORD dwDMVoiceCount;
    DWORD dwDecreaseMemory;
    DWORD dwStressFileIODuration;
    CHAR szStressFileIOThreadPri[MAX_PATH];
    CHAR szDSScratchImage[MAX_PATH];
    CHAR szDSHRTF[MAX_PATH];
    CHAR szDefaultMedia[MAX_PATH];
    CHAR szInitPerformance[szInitPerformance_SIZE];
    CHAR szInitialTestCase[MAX_PATH];
    CHAR  szDMHeap[MAX_PATH];
    DWORD dwDMFixedHeapSizeNorm;
    DWORD dwDMFixedHeapSizePhys;

};

#define MAX_PROFILESECTION_SIZE 0xFFFF
extern TESTPARAMS g_TestParams;

#define TERMINATE NULL,NULL,NULL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_ComCounter.cpp ===
#pragma once

#include "globals.h"
#include "Help_ComCounter.h"

HRESULT CreateComCounter(CComCounter **ppComCounter)
{
CComCounter *pComCounter = NULL;
pComCounter = new CComCounter();
    if (pComCounter)
    {
        *ppComCounter= pComCounter;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Buffer3d.cpp ===
/********************************************************************************
FILE:
    BUFFER3D.cpp

PURPOSE:
    This wraps both a DSound and a DSoundBuffer object, so that it can abstract
    the positioning calls.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "Help_Buffer3D.h"



/********************************************************************************
Initializes variables in the function like normal code does.
********************************************************************************/
DMBUFFER::BUFFER3D::BUFFER3D(void)
{

    HRESULT hr  = S_OK;
    m_pDS       = NULL;
    m_pDSB      = NULL;

    //Set up as if you had called DSB_TestMode(TESTAPPLY_IMMEDIATE)
    m_dwActualApplyValue = DS3D_IMMEDIATE;   
    m_eApply    =          TESTAPPLY_IMMEDIATE;
    m_bCommit   =          FALSE;

    //Set up the positioning stuff.
    m_vLisPos   = make_D3DVECTOR(0, 0, 0);
    m_vBufPos   = make_D3DVECTOR(0, 0, 0);
 
    //Relative offset positioning stuff.
    m_vRelPos   = make_D3DVECTOR(0, 0, 0);
    m_bUsingRelPos = FALSE;

};




/********************************************************************************

********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::Init(D3DVECTOR vRelative, IDirectSoundBuffer *pDSB)
{
    HRESULT hr = S_OK;
    static char szFullPath[1000];
    WIN32_FIND_DATA Data = {0};
    DWORD dwCurrentFile     = 0;
    DWORD dwChosenFile      = 0;
    BOOL bRes               = FALSE;

    //Create the DSound object (our "listener")
	CHECK(DMHelp_DirectSoundCreate( 0, &m_pDS, NULL ) );

	if ( SUCCEEDED( hr ) ) 
	{
        m_pDSB = pDSB;
    }


    //Are we relativizing our listener and source?
    m_vRelPos = vRelative;
    if (vRelative == make_D3DVECTOR(0, 0, 0))
        m_bUsingRelPos = FALSE;
    else
        m_bUsingRelPos = TRUE;

    return hr;

};

/********************************************************************************
DESTRUCTOR
********************************************************************************/
DMBUFFER::BUFFER3D::~BUFFER3D(void)
{
//Release buffers
RELEASE(m_pDSB);
RELEASE(m_pDS);

}


/********************************************************************************
Takes debug output and appends stuff to it based on whether we're de
or not.
********************************************************************************/
/*
void BUFFER3D::ConsoleOut(CHAR *szFormat, ...)
{

    va_list va;
    static char szBuffer[1000];

    if (NULL == this)
        Log(ABORTLOGLEVEL, "BUFFER3D ptr is NULL!!!!");


    CHAR *pszWarningDeferred= "(may not apply: Using DEFERRED w/o CommittDeferredSettings)";

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    Log(FYILOGLEVEL, szBuffer);
    va_end(va);

};
*/

/********************************************************************************
PURPOSE:
    This tells the wrapper class how to proxy position changes, etc. 
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_Test_SetTestingApply(TestApplies dwApply)
{
    HRESULT hr = S_OK;
    
    //Store our apply methodology.
    m_eApply    = dwApply;
        
    //Calculate our actual apply value.
    m_dwActualApplyValue = 0;
    switch (dwApply)
    {
        case TESTAPPLY_DEFERRED_NOUPDATE:
            m_dwActualApplyValue = DS3D_DEFERRED;
            break;
        case TESTAPPLY_DEFERRED_UPDATE:
            m_dwActualApplyValue = DS3D_DEFERRED;
            break;
        case TESTAPPLY_IMMEDIATE:
            m_dwActualApplyValue = DS3D_IMMEDIATE;
            break;
        case DS3D_IMMEDIATE:
        case DS3D_DEFERRED:
            m_dwActualApplyValue = dwApply;
        default: 
            Log(ABORTLOGLEVEL, "ERROR: Invalid parameter dwApply=%d passed to GetActualApplyValue", dwApply);
            m_dwActualApplyValue = 0xFFFFFFFF;
            break;
    }

    //Store our commit methodology (do we call CommitDeferredSettings?)
    if (TESTAPPLY_DEFERRED_UPDATE == dwApply)
        m_bCommit = TRUE;
    else
        m_bCommit = FALSE;

    return hr;
};




/********************************************************************************
This intercepts the position call and relativizes the vectors based on the
relative position if any.  
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetPosition(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;
    m_vLisPos = make_D3DVECTOR(x, y, z);
    CHECKRUN(DS_SetActualPositions());
    return hr;
};




/********************************************************************************
PURPOSE:
    Given our object's apparent positions, this function will adjust them as
    follows:

    1)  The relative position (m_vRelPos) is subtracted from both the listener
    and the buffer position.
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetActualPositions(void)
{
    HRESULT hr = S_OK;
    D3DVECTOR vActualLisPos =   m_vLisPos;
    D3DVECTOR vActualBufPos =   m_vBufPos;

    //1)  The relative position (m_vRelPos) is subtracted from both the listener
    //and the buffer position.
    if (m_bUsingRelPos)
    {
        vActualLisPos  -= m_vRelPos;
        vActualBufPos  -= m_vRelPos;
    }

    //Set the positions and apply if necessasry.
    CHECKRUN(m_pDS-> SetPosition(vActualLisPos.x, vActualLisPos.y, vActualLisPos.z, m_dwActualApplyValue));
    CHECKRUN(m_pDSB->SetPosition(vActualBufPos.x, vActualBufPos.y, vActualBufPos.z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());


    return hr;
}


/********************************************************************************
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetAllParameters(LPCDS3DLISTENER pds3dl)
{
HRESULT hr = S_OK;
D3DVECTOR vActualLisPos =   {0, 0, 0};
D3DVECTOR vActualBufPos =   {0, 0, 0};
DS3DLISTENER ds3dl;

ZeroMemory(&ds3dl, sizeof(ds3dl));

//Save the listener data.
ds3dl = *pds3dl;

//Save the current listener position to our class.
m_vLisPos = ds3dl.vPosition;

//1)  The relative position (m_vRelPos) is subtracted from both the listener
//and the buffer position.
if (m_bUsingRelPos)
{
    vActualLisPos = m_vLisPos - m_vRelPos;
    vActualBufPos = m_vBufPos - m_vRelPos;
}
else
{
    vActualLisPos = m_vLisPos;
    vActualBufPos = m_vBufPos;
}

//Stick the new values into the struct.
ds3dl.vPosition = vActualLisPos;

//Set the listener parameters like we're supposed to.
CHECKRUN(m_pDS->SetAllParameters(pds3dl, m_dwActualApplyValue));

//If we're doing some automatic adjustments than set the buffer position too, otherwise leave it alone.
if (m_bUsingRelPos/* || DS3DMODE_HEADRELATIVE == m_dwActualTestMode*/)
{
    CHECKRUN(m_pDSB->SetPosition(vActualBufPos.x, vActualBufPos.y, vActualBufPos.z, m_dwActualApplyValue));
}

//Commit
if (m_bCommit)
    CHECKRUN(m_pDS->CommitDeferredSettings());
    
return hr;
};


/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetDistanceFactor(FLOAT flDistanceFactor)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDS->SetDistanceFactor(flDistanceFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetDopplerFactor(FLOAT flDopplerFactor)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDS->SetDopplerFactor(flDopplerFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDS->SetOrientation(xFront, yFront, zFront, xTop, yTop, zTop, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetRolloffFactor(FLOAT flRolloffFactor)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDS->SetRolloffFactor(flRolloffFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DS_SetVelocity(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDS->SetVelocity(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}



/********************************************************************************
Just like DS_SetAllParameters
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetAllParameters(LPCDS3DBUFFER pds3db)
{
    HRESULT hr = S_OK;
    D3DVECTOR vActualLisPos =   {0, 0, 0};
    D3DVECTOR vActualBufPos =   {0, 0, 0};
    DS3DBUFFER ds3db;

    ZeroMemory(&ds3db, sizeof(ds3db));
    

    //Save the buffer data.
    ds3db = *pds3db;

    //Save the current buffer position to our class.
    m_vBufPos = ds3db.vPosition;

    //1)  The relative position (m_vRelPos) is subtracted from both the listener
    //and the buffer position.
    if (m_bUsingRelPos)
    {
        vActualLisPos = m_vLisPos - m_vRelPos;
        vActualBufPos = m_vBufPos - m_vRelPos;
    }
    else
    {
        vActualLisPos = m_vLisPos;
        vActualBufPos = m_vBufPos;
    }

    //Stick the new values into the struct.
    ds3db.vPosition = vActualBufPos;

    //If we're doing some automatic adjustments than set the listener position too, otherwise leave it alone.
    if (m_bUsingRelPos)
    {
        CHECKRUN(m_pDS->SetPosition(vActualLisPos.x, vActualLisPos.y, vActualLisPos.z, m_dwActualApplyValue));
    }

    //Set the structure.
    CHECKRUN(m_pDSB->SetAllParameters(&ds3db, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
*********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetConeOrientation(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetConeOrientation(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetConeOutsideVolume(LONG lConeOutsideVolume)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetConeOutsideVolume(lConeOutsideVolume, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetMaxDistance(FLOAT flMaxDistance)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetMaxDistance(flMaxDistance, m_dwActualApplyValue))
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetMinDistance(FLOAT flMinDistance)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetMinDistance(flMinDistance, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetPosition(FLOAT x, FLOAT y, FLOAT z)
{
HRESULT hr = S_OK;

//Set the internal variable.
m_vBufPos = make_D3DVECTOR(x, y, z);

//Finally, set the position.
CHECKRUN(DS_SetActualPositions());

return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT DMBUFFER::BUFFER3D::DSB_SetVelocity(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;    
    CHECKRUN(m_pDSB->SetVelocity(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}








/********************************************************************************
Note: These are crap functions cuz the D3DOVERLOADS don't work.
BUG 2371 Overloaded functions unusable on D3DVECTOR due to inclusion of less functional D3DVECTOR class in D3D8TYPES.H
********************************************************************************/
D3DVECTOR DMBUFFER::operator - (const D3DVECTOR& v, const D3DVECTOR& w)
{
    D3DVECTOR a;
    a.x = v.x - w.x;
    a.y = v.y - w.y;
    a.z = v.z - w.z;
    return a;    
};

D3DVECTOR DMBUFFER::operator -= (D3DVECTOR& v, const D3DVECTOR& w)
{
    v.x -= w.x;
    v.y -= w.y;
    v.z -= w.z;
    return v;    
};

BOOL DMBUFFER::operator == (D3DVECTOR& v, const D3DVECTOR& w)
{
    return
    (
    v.x == w.x &&
    v.y == w.y &&
    v.z == w.z
    );
};


//constructor
D3DVECTOR DMBUFFER::make_D3DVECTOR(FLOAT _x, FLOAT _y, FLOAT _z)
{
D3DVECTOR v;

v.x = _x;
v.y = _y;
v.z = _z;
return v;
}


/********************************************************************************
********************************************************************************/
HRESULT DMBUFFER::DMHelp_DirectSoundCreate(DWORD dwDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter)
{
HRESULT hr = S_OK;
CHECK(DirectSoundCreate(0, ppDirectSound, pUnkOuter));
return hr;
};


/********************************************************************************
Makes it easy to print out which mode you're in.
********************************************************************************/
static char *pszApplyStrings[] = {"TESTAPPLY_DEFERRED_NOUPDATE", "TESTAPPLY_DEFERRED_UPDATE", "TESTAPPLY_IMMEDIATE"};
char *DMBUFFER::String(TestApplies eTestApply)
{
    return pszApplyStrings[eTestApply - TESTAPPLY_DEFERRED_NOUPDATE];
}


/********************************************************************************
PURPOSE:
    Sets the x, y, or z component of a vector where x, y, z are indexed by
    dwComponent values 0-2.  Is nice for loops that test all 3 axes.
********************************************************************************/
void DMBUFFER::DMSetComponent(D3DVECTOR *pVector, DWORD dwComponent, FLOAT fValue)
{
    switch (dwComponent)
    {
        case 0: 
            pVector->x = fValue;
            break;
        case 1: 
            pVector->y = fValue;
            break;
        case 2: 
            pVector->z = fValue;
            break;
        default:
            Log(ABORTLOGLEVEL, "Test Error in DMSetComponent, see danhaff!!!!");
            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_ComCounter.h ===
#pragma once

/********************************************************************************
Counts calls to COM objects.
********************************************************************************/
class CComCounter: public IUnknown
{

public:
    //IUnknown methods.
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv)
    {
        m_dwCalledQueryInterface++;
        return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        m_dwCalledAddRef++;
        return 0xFFFFFFFF;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        m_dwCalledRelease++;
        return 0xFFFFFFFF;

    };

    //Construktor.
    CComCounter(void)
    {
        m_dwCalledRelease = 0;
        m_dwCalledAddRef = 0;
        m_dwCalledQueryInterface = 0;
    }
    
    //Actually calls the destructor.
    void ActualRelease(void)
    {
        delete this;
    }


    DWORD m_dwCalledRelease;
    DWORD m_dwCalledAddRef;
    DWORD m_dwCalledQueryInterface;

};



HRESULT CreateComCounter(CComCounter **ppComCounter);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Definitions.cpp ===
/********************************************************************************
FILE:
    tdmapthHelpDefs2.cpp

PURPOSE:
    This contains definitions for audiopaths containing a bunch of different
    effects settings, namely the minimum and maximum possible.

    Defs_SinkinDMOsAMin.aud
    Defs_MixinDMOsAMin.aud
    Defs_SinkinDMOsAMax.aud
    Defs_MixinDMOsAMax.aud
    B...
    C...

HISTORY:
  09/21/2000   danhaff - Created.
********************************************************************************/


#include "globals.h"
#include "Help_Definitions.h"

/*

// ********************  DEFAULT 3D BUFFER DEFINITION ********************
DS3DBUFFER g_dnDefault3DBufferParams = 
{
    sizeof(DS3DBUFFER),
    {0, 0, 0},
    {0, 0, 0},
    DS3D_DEFAULTCONEANGLE,
    DS3D_DEFAULTCONEANGLE,
    {0, 0, 1},
    DS3D_DEFAULTCONEOUTSIDEVOLUME,
    DS3D_DEFAULTMINDISTANCE,
    DS3D_DEFAULTMAXDISTANCE,
    DS3DMODE_NORMAL
};

// ********************  DEFAULT 3D LISTENER DEFINITION ********************
DS3DLISTENER g_dnDefault3DListenerParams= 
{
    sizeof(DS3DLISTENER),
    {0, 0, 0},
    {0, 0, 0},
    {0, 0, 1},
    {0, 1, 0},
    DS3D_DEFAULTDISTANCEFACTOR,
    DS3D_DEFAULTROLLOFFFACTOR,
    DS3D_DEFAULTDOPPLERFACTOR
};

// ********************  DEFAULT DSFXI3DL2Reverb ********************
DSFXI3DL2Reverb g_dnDefaultFXI3DL2Reverb =
{
    DSFX_I3DL2REVERB_ROOM_DEFAULT,              //lRoom
    DSFX_I3DL2REVERB_ROOMHF_DEFAULT,            //lRoomHF
    DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT, //flRoomRolloffFactor
    DSFX_I3DL2REVERB_DECAYTIME_DEFAULT,         //flDecayTime
    DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT,      //flDecayHFRatio
    DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT,       //lReflections
    DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT,  //flReflectionsDelay
    DSFX_I3DL2REVERB_REVERB_DEFAULT,            //lReverb
    DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT,       //flReverbDelay
    DSFX_I3DL2REVERB_DIFFUSION_DEFAULT,         //flDiffusion
    DSFX_I3DL2REVERB_DENSITY_DEFAULT,           //flDensity
    DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        //flHFReference
};



// ********************  DEFAULT DSFXI3DL2Send ********************
//DSFXSend g_dnDefaultFXSend=
//{
//    0                               //lVolume
//};


// ********************  DEFAULT Waves Reverb ********************
DSFXWavesReverb g_dnDefaultWavesReverb= 
{
    DSFX_WAVESREVERB_INGAIN_DEFAULT,
    DSFX_WAVESREVERB_REVERBMIX_DEFAULT,
    DSFX_WAVESREVERB_REVERBTIME_DEFAULT,
    DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT
};
*/

// ******************** DEFAULT PRIMARY BUFFER DEFINITION ********************

//Note: These numbers don't matter and aren't checked.
/*
BUFFER_DEFINITION g_dnDefaultPrimaryBuffer =
{
    //Playback status flags
    //Since the beginning of time primary buffers have always returned zero for this.  Hence,
    //  we must expect this and forego the ability to determine what flags it was created with.
    {
        //Flags the buffer must have.
        0,

        //Flags the buffer must NOT have.
        DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

        //Flags about which we don't care.
        0
        
    },

    //0 DMOs
    0,
    NULL

};

*/

// ******************** DMUS_APATH_SHARED_STEREOPLUSREVERB DEFINITION ********************
//This is DMO #1 (and the only DMO) on the Buffer 2 in the DMUS_APATH_SHARED_STEREOPLUSREVERB.
//  It is the waves reverb DMO.
/*
static DMO_DEFINITION SPMusic_SinkinBuffer2_DMOs[] =
{
    {
        (GUID *)&IID_IDirectSoundFXWavesReverb,
        (void *)&g_dnDefaultWavesReverb
    }
//    Additional DMOs for the second Sinkin buffer would go here.
//    ,
//    {
//
//    }
};

*/
//The list of Sinkin buffers.  All Sinkin buffers must be listed here.
static BUFFER_DEFINITION SPMusic_SinkinBuffers[] =
{

    ///////////////Sinkin Buffer 1: Stereo, no DMOs
    {
        //Playback status flags
        {
            //Flags the buffer must have.
            DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

            //Flags the buffer must NOT have.
            0,

            //Flags about which we don't care.
            0
        },

        //0 DMOs
        0,
        NULL

    }//,

    /////////////////Sinkin Buffer 2: contains Waves Reverb.
/*
    {
        //Playback status flags
        {
            //Flags the buffer must have.
            DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

            //Flags the buffer must NOT have.
            0,

            //Flags about which we don't care.
            0
        },

        //1 DMO, the Waves Reverb.  It's on the second buffer.
        //  If there were more DMOs on this buffer, they would all be addressed by this ptr.        

        //1,
//        SPMusic_SinkinBuffer2_DMOs
//  Note: put this back in!!
          0,
          NULL
        
    }
*/

};




//The DMUS_APATH_SHARED_STEREOPLUSREVERB should contain 1 SINKIN buffers and 0 MIXIN buffers.
PATH_DEFINITION g_DefaultPathStereoPlusReverb =
{
    //Zero Sinkin buffers.
    0,
    NULL,

    //Zero Mixin Buffer
    0,
    NULL,
};





// ******************** DMUS_APATH_DYNAMIC_3D DEFINITION ********************
//The DMUS_APATH_DYNAMIC_3D should contain 1 SINKIN buffer and 0 MIXIN buffers.
static BUFFER_DEFINITION SP3DDry_SinkinBuffers[] =
{
    ///////////////Sinkin Buffer 1: Dynamic (3D)
    {
        //Playback status flags
        {
            //Flags the buffer must have.
            DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

            //Flags the buffer must NOT have.
            0,

            //Flags about which we don't care.
            0
        },

        //No DMOs
        0,
        NULL
    }
};



PATH_DEFINITION g_DefaultPath3D= 
{
    //One Sinkin buffer (the 3D one with the Source Reverb upon it)
    1,
    SP3DDry_SinkinBuffers,

    //No Mixin buffers
    0,
    NULL

};




// ******************** DMUS_APATH_DYNAMIC_MONO DEFINITION ********************
//The list of SINKIN buffers.  In this case, just one.
static BUFFER_DEFINITION SPMono_SinkinBuffers[] =
{

    ///////////////Sinkin Buffer 1.
    {
        //Playback status flags
        {
            //Flags the buffer must have.
            DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

            //Flags the buffer must NOT have.
            0,

            //Flags about which we don't care.
            0
        },

        //No DMOs
        0,
        NULL
    },
};




PATH_DEFINITION g_DefaultPathMono = 
{
    //One Sinkin buffer
    1,
    SPMono_SinkinBuffers,

    //No Mixin buffers
    0,
    NULL

};





// ******************** DMUS_APATH_SHARED_STEREO DEFINITION ********************
//The list of SINKIN buffers.  In this case, just one.
static BUFFER_DEFINITION SPStereo_SinkinBuffers[] =
{    ///////////////Sinkin Buffer 1.
    {
        //Playback status flags
        {
            //Flags the buffer must have.
            DSBSTATUS_LOOPING | DSBSTATUS_PLAYING,

            //Flags the buffer must NOT have.
            0,

            //Flags about which we don't care.
            0
        },

        //No DMOs
        0,
        NULL,

    }
};


PATH_DEFINITION g_DefaultPathStereo = 
{
    //One Sinkin buffer
    0,
    NULL,

    //No Mixin buffers
    0,
    NULL

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Buffer3D.h ===
#pragma once
#include "globals.h"

namespace DMBUFFER
{
/********************************************************************************
MACROS
********************************************************************************/

enum TestApplies {TESTAPPLY_DEFERRED_NOUPDATE=0x5678, TESTAPPLY_DEFERRED_UPDATE, TESTAPPLY_IMMEDIATE};


/********************************************************************************
CLASS:
    BUFFER3D

This class supports all the methods of the buffer and listener (dsound), but
proxies the calls so it can move the objects relative to one another.

3D Stuff.  The real positions are calculated after these are set, but never stored.
There are two relativisms applied "underneath" the user.

1)  The relative position (m_vRelPos) is subtracted from both the listener
    and the buffer position.
2)  If we're in HEADRELATIVE mode, the listener position is subtracted from the
    buffer position before the buffer position is set.  

These two steps must be done in order.  I have a function to do this: 
SetActualPositions.
********************************************************************************/
class BUFFER3D
{
private:
    LPDIRECTSOUND           m_pDS;
    LPDIRECTSOUNDBUFFER     m_pDSB;

    //Data describing how to apply changes.
    DWORD                    m_dwActualApplyValue;
    TestApplies              m_eApply;
    BOOL                     m_bCommit;

    //3D data.
    D3DVECTOR               m_vLisPos;      //Where the user thinks the listener really is.
    D3DVECTOR               m_vBufPos;      //Where the user thinks the buffer really is.
    
    //Relative 3D data
    D3DVECTOR               m_vRelPos;      //Random user offset
    BOOL                    m_bUsingRelPos; //Are we using this?

public:

    //Contructor
    BUFFER3D(void);
    HRESULT Init(D3DVECTOR vRelative, IDirectSoundBuffer *pBuffer);

    //Destructor
    ~BUFFER3D(void);

    //Special functions to control proxying.
//    HRESULT DSB_Test_SetRelativePosition(FLOAT x, FLOAT y, FLOAT z);
//    HRESULT DSB_Test_SetUsingRelativePosition(BOOL bUsingRelPos);    

    HRESULT DSB_Test_SetTestingApply(TestApplies dwApply);
//    HRESULT DSB_Test_SetTestingMode(DWORD dwTestMode);


    HRESULT DS_SetActualPositions(void);
    
    __inline HRESULT GetDirectSound(IDirectSound **ppDS)
    {
        *ppDS = m_pDS;
        m_pDS->AddRef();
        return S_OK;
    }

    __inline HRESULT GetDirectSoundBuffer(IDirectSoundBuffer **ppDSB)
    {
        *ppDSB = m_pDSB;
        m_pDSB->AddRef();
        return S_OK;
    }

    __inline ULONG DS_AddRef(void)
    {
        return m_pDS->AddRef();
    }

    __inline ULONG DS_Release(void)
    {
        return m_pDS->Release();
    }

    __inline HRESULT DS_GetCaps(LPDSCAPS pdsc)
    {
        return m_pDS->GetCaps( pdsc);
    }

    __inline HRESULT DS_CreateSoundBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
    {
        return m_pDS->CreateSoundBuffer( pdsbd, ppBuffer, pUnkOuter);
    }

    __inline HRESULT DS_CreateSoundStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
    {
        return m_pDS->CreateSoundStream( pdssd, ppStream, pUnkOuter);
    }

    __inline HRESULT DS_GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
    {
        return m_pDS->GetSpeakerConfig( pdwSpeakerConfig);
    }

    __inline HRESULT DS_CommitDeferredSettings(void)
    {
        return m_pDS->CommitDeferredSettings();
    }

    __inline HRESULT DS_GetTime(REFERENCE_TIME *prtCurrent)
    {
        return m_pDS->GetTime( prtCurrent);
    }

    __inline HRESULT DS_QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return m_pDS->QueryInterface( iid, ppvInterface);
    }

    __inline HRESULT DS_SetCooperativeLevel(HWND hWnd, DWORD dwLevel)
    {
        return m_pDS->SetCooperativeLevel( hWnd, dwLevel);
    }

    __inline HRESULT DS_Compact(void)
    {
        return m_pDS->Compact();
    }



    __inline ULONG DSB_AddRef(void)
    {
        return m_pDSB->AddRef();
    }

    __inline ULONG DSB_Release(void)
    {
        return m_pDSB->Release();
    }

    __inline HRESULT DSB_Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
    {
        return S_OK;
//        return m_pDSB->Play( dwReserved1, dwReserved2, dwFlags);
    }

    __inline HRESULT DSB_PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return S_OK;
//        return m_pDSB->PlayEx( rtTimeStamp, dwFlags);
    }

    __inline HRESULT DSB_Stop(void)
    {
        return S_OK;
//        return m_pDSB->Stop();
    }

    __inline HRESULT DSB_StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return S_OK;
//        return m_pDSB->StopEx( rtTimeStamp, dwFlags);
    }


//    __inline HRESULT DSB_SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength)
//    {
//        return m_pDSB->SetLoopRegion( dwLoopStart, dwLoopLength);
//    }


    __inline HRESULT DSB_GetStatus(LPDWORD pdwStatus)
    {
        return m_pDSB->GetStatus( pdwStatus);
    }

    __inline HRESULT DSB_GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
    {
        return m_pDSB->GetCurrentPosition( pdwPlayCursor, pdwWriteCursor);
    }

    __inline HRESULT DSB_SetCurrentPosition(DWORD dwPlayCursor)
    {
        return S_OK;
     //   return m_pDSB->SetCurrentPosition( dwPlayCursor);
    }

    __inline HRESULT DSB_SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes)
    {
        return m_pDSB->SetBufferData( pvBufferData, dwBufferBytes);
    }

    __inline HRESULT DSB_Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
    {
        return m_pDSB->Lock( dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    __inline HRESULT DSB_SetFrequency(DWORD dwFrequency)
    {
        return m_pDSB->SetFrequency( dwFrequency);
    }

    __inline HRESULT DSB_SetVolume(LONG lVolume)
    {
        return m_pDSB->SetVolume( lVolume);
    }

/*
    __inline HRESULT DSB_SetChannelVolume(LPDSCHANNELVOLUME pdscv)
    {
        return m_pDSB->SetChannelVolume(pdscv);
    }
*/


    //3D Stuff that must be wrapped due to proxying of 3D positions.
    HRESULT DSB_SetAllParameters(LPCDS3DBUFFER pds3db);
    HRESULT DSB_SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle);
    HRESULT DSB_SetConeOrientation(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DSB_SetConeOutsideVolume(LONG lConeOutsideVolume);
    HRESULT DSB_SetMaxDistance(FLOAT flMaxDistance);
    HRESULT DSB_SetMinDistance(FLOAT flMinDistance);
    HRESULT DSB_SetMode(DWORD dwMode);
    HRESULT DSB_SetPosition(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DSB_SetVelocity(FLOAT x, FLOAT y, FLOAT z);

    HRESULT DS_SetAllParameters(LPCDS3DLISTENER pds3db);
    HRESULT DS_SetDistanceFactor(FLOAT flDistanceFactor);
    HRESULT DS_SetDopplerFactor(FLOAT flDopplerFactor);
    HRESULT DS_SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop);
    HRESULT DS_SetPosition(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DS_SetRolloffFactor(FLOAT flRolloffFactor);
    HRESULT DS_SetVelocity(FLOAT x, FLOAT y, FLOAT z);

    __inline HRESULT DSB_SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
    {
        return m_pDSB->SetNotificationPositions( dwNotifyCount, paNotifies);
    }

    __inline HRESULT DSB_QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return m_pDSB->QueryInterface( iid, ppvInterface);
    }

    __inline HRESULT DSB_Unlock(LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
    {
        return m_pDSB->Unlock( pvLock1, dwLockSize1, pvLock2, dwLockSize2);
    }

    __inline HRESULT DSB_Restore(void)
    {
        return m_pDSB->Restore();
    }


};


static D3DVECTOR vDefault = {0,0,0};

// Disable warning messages about floating point overflow.
#pragma warning( disable : 4056 4756)
//#define INFINITY (FLT_MAX * FLT_MAX)       
//#define ALMOST_FLT_MAX (FLT_MAX * 0.99f)        //so we don't run up against MAXDISTANCE.
#define FLT_BIG (FLT_MAX / 100.f)
#define FLT_SMALL (FLT_MIN * 100.f)


/********************************************************************************
Note: These are crap functions cuz the D3DOVERLOADS don't work.
BUG 2371 Overloaded functions unusable on _D3DVECTOR due to inclusion of less functional _D3DVECTOR class in D3D8TYPES.H
//TODO: blow away when D3DOVERLOADS work.
********************************************************************************/
D3DVECTOR operator - (const D3DVECTOR& v, const D3DVECTOR& w);
D3DVECTOR operator -= (D3DVECTOR& v, const D3DVECTOR& w);
BOOL operator == (D3DVECTOR& v, const D3DVECTOR& w);
D3DVECTOR make_D3DVECTOR(FLOAT _x, FLOAT _y, FLOAT _z);

//Sets the x, y, or z component of a vector where x, y, z are indexed by values 0-2.
void DMSetComponent(D3DVECTOR *pVector, DWORD dwComponent, FLOAT fValue);

HRESULT DMHelp_DirectSoundCreate(DWORD dwDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter);
HRESULT DMHelp_DirectSoundCreateBuffer(DWORD dwDeviceId, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);



// Constants
#define PI 3.141592653589793238
#define PI_TIMES_TWO 6.28318530718
#define PI_OVER_TWO 1.570796326795
#define THREE_PI_OVER_TWO 4.712388980385
#define NEG_PI_OVER_TWO -1.570796326795
#define C180_OVER_PI 57.29577951308
#define PI_OVER_360 0.008726646259972
#define TWO_OVER_PI 0.6366197723676
#define SPEEDOFSOUND 359660.0
#define LOGE_2_INV 1.44269504088896
#define LOG10_2 0.30102999566398


char *String(TestApplies eTestApply);
}

using namespace DMBUFFER;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Helpers.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.h

Abstract:

	Helper functions for dmtest1

Author:

	Dan Haffner (danhaff) 

Revision History:

	13-Mar-2001 robheit
		Added input functions for joystick polling

--*/
#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "globals.h"
//---------------------------------------------------------------------------

// minimum logging level
#ifndef MINLOGLEVEL
#define MINLOGLEVEL         0
#endif
// logging level for "test aborting" messages
#ifndef ABORTLOGLEVEL
#define ABORTLOGLEVEL       0
#endif
// logging level for "bug found" messages
#ifndef BUGLOGLEVEL
#define BUGLOGLEVEL         0
#endif
// logging level for "for your information" messages
#ifndef WARNLOGLEVEL
#define WARNLOGLEVEL        1
#endif
// logging level for "for your information" messages
#ifndef FYILOGLEVEL
#define FYILOGLEVEL         2
#endif
// logging level for parameter data
#ifndef PARAMLOGLEVEL
#define PARAMLOGLEVEL       5           
#endif
// logging level for structure contents
#ifndef STRUCTLOGLEVEL
#define STRUCTLOGLEVEL      6
#endif
// maximum logging level
#ifndef MAXLOGLEVEL
#define MAXLOGLEVEL         10
#endif
// max length of a logging string
#ifndef MAX_LOGSTRING
#define MAX_LOGSTRING       256
#endif
// max length of a string
#ifndef MAX_STRING
#define MAX_STRING          256
#endif

//MIDI helpers
#define MAKEPATCH(msb,lsb,patch) (((msb) << 16) | ((lsb) << 8) | (patch))
#define MAKEDRUMS(patch) ((patch) | 0x80000000)

// MIDI EVENT TYPE DEFINES
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define CC_MODWHEEL		0x01
#define CC_VOLUME		0x07
#define CC_PAN			0x0A
#define CC_EXPRESSION	0x0B
#define CC_SUSTAIN		0x40


//Stuff for translating thread priority strings into their values.
struct THREADPRI
{
    LPCSTR sz;
    DWORD  dw;
};
extern THREADPRI g_ThreadPris[];
extern DWORD g_dwThreadPris;
HRESULT ThreadPriFromString(LPCSTR szString, DWORD *pdwPri);




/*
//===========================================================================
//===========================================================================
template <class T>
FLOAT CalculateErrorPercentage(T tExpected, T tActual)
{
FLOAT fError = 0.f;

    if (tExpected != 0.f)
        fError = (FLOAT)fabs( FLOAT(tExpected) - FLOAT(tActual) / FLOAT(tExpected)) * 100.f;
    else
        fError = (FLOAT)fabs( FLOAT(tExpected) - FLOAT(tActual) / 1.0f) * 100.f;

    return fError;
        
}
*/

double CalculateErrorPercentage(double tExpected, double tActual);

//===========================================================================
// dmthCreateTestWrappedObject
//
// template for making object creation easier
//
// Parameters:
//  REALOBJECT  *pObj   - pointer to the real object
//  TESTOBJECT  *pptObj - ptr to return newly created test object
//
// Returns: HRESULT
//===========================================================================
//lint -e10
template <class REALOBJECT, class TESTOBJECT>
HRESULT _stdcall dmthCreateTestWrappedObject(REALOBJECT *pObj, TESTOBJECT **pptObj) 
//lint +e10
{
    HRESULT hRes    = E_FAIL;

    // validate pObj
    if(!helpIsValidPtr((void*)pObj, sizeof(REALOBJECT), FALSE))
    {
        Log(MINLOGLEVEL, "Invalid ptr (Arg 1) passed to "
                "dmthCreateTestWrappedObject (%08Xh)",
                pObj);
        return E_POINTER;
    }

    // validate pptObj
    if(!helpIsValidPtr((void*)pptObj, sizeof(TESTOBJECT*), FALSE))
    {
        Log(MINLOGLEVEL, "Invalid ptr (Arg 2) passed to dmthCreateTestWrappedObject (%08Xh)", pptObj);
        return E_POINTER;
    }

    // create the test object
    *pptObj = new TESTOBJECT();
    if(NULL != *pptObj)
    {
        // initialize the test class
        hRes = (*pptObj)->InitTestClass(pObj);
        if(FAILED(hRes))
        {
            Log(MINLOGLEVEL, "**** Unable to initalize XXXXX test class (%s == %08Xh)",tdmXlatHRESULT(hRes), hRes);
            delete (*pptObj);
            *pptObj = NULL; 
        }
    }

    // done
    return hRes;

} 





//MACROS.
#define AMOUNT(a) (sizeof(a) / sizeof(a[0]))
//lint -e14
DEFINE_GUID(GUID_Random, 0x7040c11f, 0xd6da, 0x4c16, 0x99, 0x80, 0x71, 0xb, 0xe0, 0x1a, 0x69, 0x54);  // {7040C11F-D6DA-4c16-9980-710BE01A6954}
//lint +e14


//Creating and loading helpers.
HRESULT dmthCreateEmptySegment(CtIDirectMusicSegment **ppwSegment);
HRESULT dmthCreateToolGraph( CtIDirectMusicPerformance8* ptPerf8, IDirectMusicGraph** ppGraph );
HRESULT dmthCreateLoader(REFIID riid,CtIDirectMusicLoader **ppwLoader);
HRESULT dmthCreateLoader(REFIID riid, IDirectMusicLoader8 **pptLoader);
HRESULT dmthLoadSegment(LPCSTR pSegmentFile, CtIDirectMusicSegment8 **ppwSegment); //dx8
HRESULT dmthLoadSegment(LPCSTR pSegmentFile, IDirectMusicSegment8 **ppSegment); //dx8
HRESULT dmthCreatePerformance(REFIID riid, CtIDirectMusicPerformance8 **pwPerformance); //dx8
HRESULT dmthPlayMidiFile(CtIDirectMusicPerformance8 *pwPerformance8,REFIID riid,CtIDirectMusicSegment8 **ppwSegment8,CtIDirectMusicSegmentState **ppwSegmentState,CHAR *pMidiFile);

//Scriptin' stuff.
HRESULT dmthCreateScript( LPCSTR szScriptName, CtIDirectMusicLoader8* pLoader, CtIDirectMusicScript** ppScript );
HRESULT dmthInitScriptErrorInfo( DMUS_SCRIPT_ERRORINFO* pInfo );
void dmthVerifyScriptError( DMUS_SCRIPT_ERRORINFO* pInfo );


//Helpers to time playback.
HRESULT WaitForSegmentStart(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, BOOL enableBreak=FALSE);
HRESULT WaitForSegmentStop(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, BOOL enableBreak=FALSE);
HRESULT ExpectSegmentStart(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPCSTR szSegname, BOOL enableBreak = FALSE);
HRESULT ExpectSegmentStop(CtIDirectMusicPerformance8 *ptPerf8, CtIDirectMusicSegment8 *ptSegment8, CtIDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPCSTR szSegname, BOOL enableBreak = FALSE);
HRESULT Wait(DWORD dwWait);
HRESULT CountDown(DWORD dwWait, DWORD dwInterval);
HRESULT GetTempo(CtIDirectMusicPerformance8 *ptPerf8, double *pdblTempo);

//Path parsing.
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut);
LPCSTR PathFindFileName(LPCSTR pPath);
HRESULT GUIDsFromFileName(LPSTR szFilename, GUID **ppCLSID, GUID **ppIID);


//Other
HRESULT WrapTool(IDirectMusicTool *pTool, CtIDirectMusicTool **pptTool);
LPVOID TDMGetBogusPointer(void);
void TDMFreeBogusPointer(LPVOID lpv);
BOOL FillBufferWithSineWave(
 LPVOID			    pBuffer, 
 DWORD				dwBufferBytes,
 DWORD              dwFrequency,
 LPWAVEFORMATEX		pWfx,
 DOUBLE				fFactor
 );
DWORD IgnorePChannel(DWORD dwStage);
void CleanUpIUnknown(HRESULT hr, LPUNKNOWN &pUnk);
HRESULT CreateAndInitPerformance(CtIDirectMusicPerformance8 **ppPerf8);

LPCSTR PathFindFileExtension(LPCSTR pPath);

//------------------------------------------------------------------------------
//	Input Helpers
//------------------------------------------------------------------------------
struct DMTHJoystick
{
	float	leftStickX;
	float	leftStickY;
	float	rightStickX;
	float	rightStickY;
	float	a;
	float	b;
	float	x;
	float	y;
	float	black;
	float	white;
	float	leftTrigger;
	float	rightTrigger;
	BOOL	back;
	BOOL	start;
	BOOL	dPadLeft;
	BOOL	dPadRight;
	BOOL	dPadUp;
	BOOL	dPadDown;
	BOOL	leftStick;
	BOOL	rightStick;
};
static const DWORD DMTH_JOYBUTTON_X			= 0x00000001;
static const DWORD DMTH_JOYBUTTON_Y			= 0x00000002;
static const DWORD DMTH_JOYBUTTON_WHITE		= 0x00000004;
static const DWORD DMTH_JOYBUTTON_A			= 0x00000008;
static const DWORD DMTH_JOYBUTTON_B			= 0x00000010;
static const DWORD DMTH_JOYBUTTON_BLACK		= 0x00000020;
static const DWORD DMTH_JOYBUTTON_LTRIG		= 0x00000040;
static const DWORD DMTH_JOYBUTTON_RTRIG		= 0x00000080;
static const DWORD DMTH_JOYBUTTON_LSTICK	= 0x00000100;
static const DWORD DMTH_JOYBUTTON_RSTICK	= 0x00000200;
static const DWORD DMTH_JOYBUTTON_UP		= 0x00000400;
static const DWORD DMTH_JOYBUTTON_DOWN		= 0x00000800;
static const DWORD DMTH_JOYBUTTON_LEFT		= 0x00001000;
static const DWORD DMTH_JOYBUTTON_RIGHT		= 0x00002000;
static const DWORD DMTH_JOYBUTTON_BACK		= 0x00004000;
static const DWORD DMTH_JOYBUTTON_START		= 0x00008000;
static const DWORD DMTH_JOYBUTTON_ALL		= 0xffffffff;

extern HANDLE		g_dmthInputHandles[4];
extern DMTHJoystick	g_dmthJoysticks[4];
enum ANSWER {EXPECT_YES, EXPECT_NO};


#define TESTNOTIFICATION_MEASUREANDBEAT     1
#define TESTNOTIFICATION_PERFORMANCE        2
#define TESTNOTIFICATION_SEGMENT            4
#define TESTNOTIFICATION_ALL                7            

#define CLOSEDOWN_BEFORESTOPPING 1
#define CLOSEDOWN_BEFOREUNLOADING 2
#define CLOSEDOWN_BEFORERELEASINGPATH 3
#define CLOSEDOWN_AFTEREVERYTHINGELSE 4
#define CLOSEDOWN_TWICE 5


void dmthInitInput(void);		// Will be called internally if not explicitly called
void dmthReleaseInput(UINT port);	
void dmthReleaseInput(void);		// Must be called before exit to clean up
void dmthGetJoystickStates(void);
BOOL dmthGetJoystickState(UINT port);
void dmthWaitForAllButtons(UINT port, DWORD buttonMask);
DWORD dmthWaitForAnyButton(DWORD buttonMask);
BOOL dmthIsAnyButtonDown(void);
BOOL dmthIsPortValid(UINT port);
void dmthPromptUserTestResults(HRESULT &hr, IN ANSWER   yesNoExpected,IN LPSTR	yesNoQuestion, ...);
void dmthWaitForAllButtonsUp(void);
BOOL FloatsAreEqual(const float& f1, const float& f2);
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile);
HRESULT InitializeDSound(IDirectSound **ppDSound);
HRESULT ClearAllPMsgs(CtIDirectMusicPerformance8 *ptPerf8);
HRESULT HelpLoadWaveFileData(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize);
HRESULT StringToGuid(char* szString, LPGUID pguidResult);

extern LPCSTR g_szAppName;

void GetMemoryStats(LONG *pLongArray, DWORD dwMax);
void CompareMemoryStats(LONG *pLast, LONG *pCurrent, DWORD dwMax, LPSTR szTestName);
void EndTestRun(void);
BOOL IsValidAudioPath(DWORD dwAudioPath);


BOOL InitPerformanceEveryTest(void);
BOOL InitPerformanceOnce(void);
BOOL InitPerformanceNever(void);

HRESULT ReferenceToMusicTime(CtIDirectMusicPerformance8 *ptPerf8, REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime);
HRESULT MusicToReferenceTime(CtIDirectMusicPerformance8 *ptPerf8, MUSIC_TIME mtTime, REFERENCE_TIME *prtTime);


//Copies one file.
HRESULT MediaCopyFile(LPCSTR szFromPath, LPCSTR szToPath, DWORD dwFlags);
HRESULT MediaCopyFile(LPCSTR szFromPath, LPCSTR szToPath);
HRESULT MediaCopyFile(LPCSTR szFromPath, DWORD dwFlags);
HRESULT MediaCopyFile(LPCSTR szFromPath);


//Takes the name of a file (or directory), strips off the file name, and copies everything in that directory to the "to" destination.
HRESULT MediaCopyDirectory(LPCSTR szFromPath, LPCSTR szToPath, DWORD dwFlags);
HRESULT MediaCopyDirectory(LPCSTR szFromPath, LPCSTR szToPath);
HRESULT MediaCopyDirectory(LPCSTR szFromPath, DWORD dwFlags);
HRESULT MediaCopyDirectory(LPCSTR szFromPath);

//Translates a path on the server to a corresponding local path.

//TODO: Translate all calls to the second one; delete the first one.
LPCSTR MediaServerToLocal(LPCSTR szFrom);
HRESULT MediaServerToLocal(LPCSTR szServer, LPSTR szLocal);


BOOL FilesInSameDirectory(LPSTR szFiles[], DWORD dwCount);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Definitions.h ===
/********************************************************************************
Microsoft Windows
Copyright (C) Microsoft Corporation, 1999 - 2000
File:
    tdmapthDefinitions.h

History:
    04/15/2000 - danhaff - Created
    05/04/2000 - danhaff - split into separate file.
    08/29/2000 - danhaff - Removed instances of DYNAMIC_APATH_ENV3D

Purpose:
    * Contains the definitions of certain default structs which may be
      compared against for default-ness, etc.        

    * To compare PATH_DEFINITIONs, BUFFER_DEFINITIONs, and DMO_DEFINITIONs,
      use the VerifyData functions defined in tdmapthHelp.h

    * To compare standard structures including DSFX settings and 3DBuffer/Listener
      data, use the Compare_Type functions in dmth.h.
********************************************************************************/

#pragma once

#include "Help_VerifyPath.h"


//----------------- STANDARD AudioPath Defaults ---------------------
//The default data for the DMUS_APATH_SHARED_STEREOPLUSREVERB.
extern  PATH_DEFINITION     g_DefaultPathStereoPlusReverb;
extern  PATH_DEFINITION     g_DefaultPath3D;
extern  PATH_DEFINITION     g_DefaultPathMono;
extern  PATH_DEFINITION     g_DefaultPathStereo;

//----------------- DMO Defaults ---------------------
//The default parameters for the WavesReverb DMO.
//extern DSFXWavesReverb     g_dnDefaultWavesReverb;
//extern DSFXI3DL2Reverb     g_dnDefaultFXI3DL2Reverb;

//----------------- Buffer Defaults-----------------
//This is what you should see when you pull it out of the standard audio path.
//extern BUFFER_DEFINITION    g_dnDefaultPrimaryBuffer;


//This is what you should see when you pull a 3D buffer
//  out of the standard audio path.
extern BUFFER_DEFINITION    g_dnDefault3DBuffer;


//----------------- Misc Defaults _-----------------
//The default params of a 3D Buffer.
extern DS3DBUFFER           g_dnDefault3DBufferParams;

//The default params of a 3D Listener.
//extern DS3DLISTENER         g_dnDefault3DListenerParams;


//----------------- NONSTANDARD Audiopath Defaults -------------------
/*
extern PATH_DEFINITION g_DefsSinkinDMOsAMin;
extern PATH_DEFINITION g_DefsMixinDMOsAMin;
extern PATH_DEFINITION g_DefsSinkinDMOsAMax;
extern PATH_DEFINITION g_DefsMixinDMOsAMax;
extern PATH_DEFINITION g_DefsSinkinDMOsBMin;
extern PATH_DEFINITION g_DefsMixinDMOsBMin;
extern PATH_DEFINITION g_DefsSinkinDMOsBMax;
extern PATH_DEFINITION g_DefsMixinDMOsBMax;
extern PATH_DEFINITION g_DefsSinkinDMOsCMin;
extern PATH_DEFINITION g_DefsMixinDMOsCMin;
extern PATH_DEFINITION g_DefsSinkinDMOsCMax;
extern PATH_DEFINITION g_DefsMixinDMOsCMax;

extern PATH_DEFINITION g_Defs2_3DAlg;
extern PATH_DEFINITION g_Defs2_3DMuteAtMax;
extern PATH_DEFINITION g_Defs2_3DParams;
extern PATH_DEFINITION g_Defs2_DopplerNo3D;
extern PATH_DEFINITION g_Defs2_DopplerWith3D;
extern PATH_DEFINITION g_Defs2_Mono3D;
extern PATH_DEFINITION g_Defs2_Stereo3D;
extern PATH_DEFINITION g_Defs2_NoVolume;
extern PATH_DEFINITION g_Defs2_NULLGUID;
extern PATH_DEFINITION g_Defs2_OneBussTwoChannels;
extern PATH_DEFINITION g_Defs2_PanLeft;
extern PATH_DEFINITION g_Defs2_PanRight;
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_DoWork.h ===
#pragma once

HRESULT StartDoDMWorkThreadProc(void);
HRESULT StopDoDMWorkThreadProc(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_DoWork.cpp ===
#include "globals.h"
#include "help_DoWork.h"

DWORD DoDMWorkThreadProc(void* pvhWndMain);
void WaitForDoDMWorkThreadEnd(HANDLE *phThread);
HANDLE g_hDoDMWorkThread= NULL;
HANDLE g_hDoDMWorkQuitEvent = NULL;

/********************************************************************************
********************************************************************************/
HRESULT StartDoDMWorkThreadProc(void)
{
    DWORD dwTemp = 0;

    //If we're letting DMusic do our thread, then bail.
    if (!g_TestParams.bDoWorkLocalThread)
        return S_OK;

    g_hDoDMWorkQuitEvent = CreateEvent(NULL, TRUE, 0, 0);
    if (!g_hDoDMWorkQuitEvent)
    {
        Log(ABORTLOGLEVEL, "StartDoDMWorkThreadProc: CreateEvent failed!!");
        return E_FAIL;        
    }
    
    g_hDoDMWorkThread =    CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)DoDMWorkThreadProc,(void*)dwTemp,0,NULL);
    if (!g_hDoDMWorkQuitEvent)
    {
        Log(ABORTLOGLEVEL, "StartDoDMWorkThreadProc: CreateThread(DoDMWorkThreadProc) failed!!");
        CloseHandle(g_hDoDMWorkQuitEvent);
        return E_FAIL;        
    }

    return S_OK;
};


/********************************************************************************
********************************************************************************/
HRESULT StopDoDMWorkThreadProc(void)
{
HRESULT hr = S_OK;

    //If we're letting DMusic do our thread, then bail.
    if (!g_TestParams.bDoWorkLocalThread)
        return S_OK;

    if (!SetEvent(g_hDoDMWorkQuitEvent))
    {
        Log(ABORTLOGLEVEL, "StopDoDMWorkThreadProc: SetEvent failed!!  App may hang!");
        hr = E_FAIL;
    }
    
    WaitForDoDMWorkThreadEnd(&g_hDoDMWorkThread);
    
    if (!CloseHandle(g_hDoDMWorkQuitEvent))
    {
        Log(ABORTLOGLEVEL, "StopDoDMWorkThreadProc: CloseHandle failed!!  App may leak!");
        hr = E_FAIL;
    }

return hr;
};

/********************************************************************************
********************************************************************************/
DWORD DoDMWorkThreadProc(void* pvhWndMain)
{
    
    DWORD dwQuantum;
    if (g_TestParams.dwDoWorkFrequency)
    {
        dwQuantum = 1000 / g_TestParams.dwDoWorkFrequency;
        Log(FYILOGLEVEL, "DoDMWorkThreadProc: Setting dwQuantum to %dms.", dwQuantum);
    }
    else
        Log(FYILOGLEVEL, "DoDMWorkThreadProc: not calling DirectMusicDoDMWork.");


    while (WAIT_OBJECT_0 != WaitForSingleObject(g_hDoDMWorkQuitEvent, 0))
    {   
        if (g_TestParams.dwDoWorkFrequency)
            DirectMusicDoWork(dwQuantum);
        Sleep(dwQuantum);
    }

    Log(FYILOGLEVEL, "g_hDoDMWorkQuitEvent has been set - bailing out of DoDMWorkThreadProc");
    return 0;
} 



/********************************************************************************
********************************************************************************/
void WaitForDoDMWorkThreadEnd(HANDLE *phThread)
{
    DWORD dwWaitResult = WAIT_TIMEOUT;

    if(*phThread)
    {
        dwWaitResult = WAIT_TIMEOUT;
        while(dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = WaitForSingleObject(*phThread, 0);
            Sleep(100);
        }

        CloseHandle(*phThread);
        *phThread = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_FileIOStress.h ===
#pragma once

HRESULT StartFileIOStressThreadProc(void);
HRESULT StopFileIOStressThreadProc(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_FileIOStress.cpp ===
#include "globals.h"
#include "help_FileIOStress.h"

DWORD FileIOStressThreadProc(void* pvhWndMain);
void WaitForFileIOStressThreadEnd(HANDLE *phThread);
HANDLE g_hFileIOStressThread= NULL;
HANDLE g_hFileIOStressQuitEvent = NULL;

/********************************************************************************
********************************************************************************/
HRESULT StartFileIOStressThreadProc(void)
{
    DWORD dwTemp = 0;
    
    if (0 == g_TestParams.dwStressFileIODuration)
        return S_OK;

    g_hFileIOStressQuitEvent = CreateEvent(NULL, TRUE, 0, 0);
    if (!g_hFileIOStressQuitEvent)
    {
        Log(ABORTLOGLEVEL, "StartFileIOStressThreadProc: CreateEvent failed!!");
        return E_FAIL;        
    }
    
    g_hFileIOStressThread =    CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)FileIOStressThreadProc,(void*)dwTemp,0,NULL);
    if (!g_hFileIOStressQuitEvent)
    {
        Log(ABORTLOGLEVEL, "StartFileIOStressThreadProc: CreateThread(FileIOStressThreadProc) failed!!");
        CloseHandle(g_hFileIOStressQuitEvent);
        return E_FAIL;        
    }

    if (FAILED(ThreadPriFromString(g_TestParams.szStressFileIOThreadPri, &dwTemp)))
    {
        Log(ABORTLOGLEVEL, "StartFileIOStressThreadProc: didn't recognize thread pri %s so using THREAD_PRIORITY_NORMAL", g_TestParams.szStressFileIOThreadPri);
        dwTemp = THREAD_PRIORITY_NORMAL;
    }

    if (0 == SetThreadPriority(g_hFileIOStressThread, dwTemp))
    {
        Log(ABORTLOGLEVEL, "SetThreadPriority(%u) failed with error code %u", dwTemp, GetLastError());
    }

    return S_OK;
};


/********************************************************************************
********************************************************************************/
HRESULT StopFileIOStressThreadProc(void)
{
HRESULT hr = S_OK;

    if (0 == g_TestParams.dwStressFileIODuration)
        return S_OK;


    if (!SetEvent(g_hFileIOStressQuitEvent))
    {
        Log(ABORTLOGLEVEL, "StopFileIOStressThreadProc: SetEvent failed!!  App may hang!");
        hr = E_FAIL;
    }
    
    WaitForFileIOStressThreadEnd(&g_hFileIOStressThread);
    
    if (!CloseHandle(g_hFileIOStressQuitEvent))
    {
        Log(ABORTLOGLEVEL, "StopFileIOStressThreadProc: CloseHandle failed!!  App may leak!");
        hr = E_FAIL;
    }

return hr;
};

/********************************************************************************
********************************************************************************/
#define LENGTH 10
DWORD FileIOStressThreadProc(void* pvhWndMain)
{
    DWORD dwStartTime = 0;
    CHAR szFileName[LENGTH] = {0};
    CHAR szFullPath[MAX_PATH] = {0};
    CHAR DummyData[512];
    DWORD i = 0;
    FILE *fyle = NULL;
    DWORD dwDeleteTime = 0;
    
    //Initialization.
    if (g_TestParams.dwStressFileIODuration)
    {
        Log(FYILOGLEVEL, "FileIOStressThreadProc: Doing File I/O for %dms at a time.", g_TestParams.dwStressFileIODuration);
    }
    else
        Log(FYILOGLEVEL, "FileIOStressThreadProc: not performaing FileIOStress.");


    while (WAIT_OBJECT_0 != WaitForSingleObject(g_hFileIOStressQuitEvent, 0))
    {   
        if (g_TestParams.dwStressFileIODuration)
        {
            dwStartTime = timeGetTime();
            do
            {
                for (i=0; i<LENGTH - 1; i++)
                {
                    szFileName[i] = 'a'+ rand() % 25;
                }
                szFileName[LENGTH-1] = 0;
                sprintf(szFullPath, "T:\\DMTest1\\%s", szFileName);
                fyle = NULL;
                fyle = fopen(szFullPath, "wb");


                if (fyle)
                {
                    for (i=0; i<512; i++)
                        DummyData[i] = rand() % 256;

                    fwrite((void *)&DummyData, 1, 512, fyle);
                    fclose(fyle);
                    dwDeleteTime = timeGetTime();
                    do
                    {
                        if (0 == DeleteFile(szFullPath))
                        {                            
                            DWORD dwLastError = GetLastError();
                            Log(ABORTLOGLEVEL, "DeleteFile(%s) failed with error code %u", szFileName, dwLastError);
                        }
                        else
                        {
                            break;
                        }
                    }
                    while (timeGetTime() - dwDeleteTime < 1000);
                }
            }
            while (timeGetTime() - dwStartTime < g_TestParams.dwStressFileIODuration);

            Sleep(500);
        }
    }

    Log(FYILOGLEVEL, "g_hFileIOStressQuitEvent has been set - bailing out of FileIOStressThreadProc");
    return 0;
} 



/********************************************************************************
********************************************************************************/
void WaitForFileIOStressThreadEnd(HANDLE *phThread)
{
    DWORD dwWaitResult = WAIT_TIMEOUT;

    if(*phThread)
    {
        dwWaitResult = WAIT_TIMEOUT;
        while(dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = WaitForSingleObject(*phThread, 0);
            Sleep(100);
        }

        CloseHandle(*phThread);
        *phThread = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_StatsMemoryUse.h ===
#include "globals.h"

#define MEM_PHYSICAL TRUE
#define MEM_NORMAL   FALSE

HRESULT CreateHeaps(LPCSTR szHeap, DWORD dwLimitNormal, DWORD dwLimitPhysical);
HRESULT DestroyHeaps(void);
HRESULT InitializeDMusicWithCreatedHeaps(void);
HRESULT GetMemoryUsage(BOOL bPhysical, DWORD *pdwMemUsage);
HRESULT WaitForMemoryToStabilize(BOOL bPhysical, DWORD dwTargetRange, DWORD dwTargetDuration, DWORD dwTimeOut, BOOL *pbStabilized, DWORD *pdwMemory);
HRESULT ExpectMemoryToStabilize(BOOL bPhysical, DWORD dwTargetRange, DWORD dwTargetDuration, DWORD dwTimeOut, BOOL *pbStabilized, DWORD *pdwMemory);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_MusicHeap.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "dmusici.h"


#undef INTERFACE
#define INTERFACE  IMusicHeap
DECLARE_INTERFACE_(IMusicHeap, IDirectMusicHeap)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* pData) PURE;
    STDMETHOD(Free)       (THIS_ PVOID pData) PURE;
    STDMETHOD(GetSize)    (THIS_ PVOID pData, LPDWORD pcbSize) PURE;

    /* IDirectMusicHeap Info */
    STDMETHOD(GetHeapAllocation          )(THIS_ DWORD *pdwHeapAllocation) PURE;
    STDMETHOD(GetHeapAllocationPeak      )(THIS_ DWORD *pdwHeapAllocationPeak) PURE;
    STDMETHOD(GetHeapAllocationBlocks    )(THIS_ DWORD *pdwHeapAllocationBlocks) PURE;
    STDMETHOD(GetHeapAllocationBlocksPeak)(THIS_ DWORD *pdwHeapAllocationBlocksPeak) PURE;
    STDMETHOD(SetSize                    )(THIS_ DWORD dwLimit) PURE;

};                                  


    HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical);
    HRESULT CreateMusicHeapFixed(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);
    HRESULT CreateMusicHeapFixedCache(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Stream.H ===
/****************************************************************************

    Contains the definition for IStream interface

    Copyright (C) Microsoft Corporation  1994 - 1999
    
    Stolen and Modified 3/5/96 by Mark Burton from 2/21/95 Tom Laird-McConnell

    07/28/1998 - t-jwex - added unicode support to the methods/functions contained
						here.  Also updated all old 16-bit File I/O calls to 
						respective Win32 calls.
    08/13/1998 - jimmo - Changed CFileStream::Read prototype
    11/11/1999 - danhaff - copied into dsapitst8.

*******************************************************************************/

#pragma once

namespace LocalFileStream
{

enum STREAM_MODES 
{
	STREAM_WRITE			= 	1,		
	STREAM_READ				= 	2,		
};

HRESULT AllocStreamFromFile( LPSTREAM *ppStream, 
                            LPCSTR szAbsFilePath, 
							DWORD dwOffset );
// **************************************
//
// CFileStream
//
// Implementation of IStream interface, and IUnknown
//
// **************************************
class CFileStream : public IStream
{
private:
    int     m_RefCnt;
    char    m_szFileName[MAX_PATH];

	HANDLE	m_hFile;
    DWORD   m_dwStartOffset;
    DWORD   m_dwLength;
    DWORD	m_fdwFlags;
	BOOL	m_fInited;

//    IStream *m_pCachedClone;
//    IStream *m_pOriginal;

public:

	CFileStream(HANDLE hfile) :m_hFile(hfile){ AddRef();}
	CFileStream(void);
    ~CFileStream();

    STDMETHODIMP	Init( const char *szAbsFilePath, DWORD dwOffset, DWORD fdwFlags );
	
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS) ;
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods ***
    STDMETHOD(Read) (void* pv, ULONG cb, ULONG* pcbRead );

    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm);

//    STDMETHOD(GetMyClone)(THIS_ IStream FAR * FAR *ppstm){*ppstm = m_pClone; return S_OK;};
};

}//end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\help_stream.cpp ===
/****************************************************************************

    Contains the implementation of CFileStream

    Copyright (C) Microsoft Corporation  1994 - 1999
    
    Stolen and Modified 3/5/96 by Mark Burton from 10/10/95 Brian McDowell

    07/28/1998 - t-jwex - added unicode support to the methods/functions contained
						here.  Also updated all old 16-bit File I/O calls to 
						respective Win32 calls.
    08/13/1998 - jimmo  - Changed CFileStream::Read so it doesn't fail when
                        you send in a NULL for BytesRead param.
    11/11/1999 - danhaff - copied into dsapitst8.
                           added fake g_isUnicode variabel.

*******************************************************************************/
#include <globals.h>
#include "Help_Stream.h"

using namespace LocalFileStream;

namespace LocalFileStream
{

#define FILE_BEGIN	0
#define FILE_CURRENT	1
#define	FILE_END	2



// ************************************************************************
// ************************************************************************
//
//  Unicode functions
//
// ************************************************************************
// ************************************************************************


// ---------------------------------------------------
//  AllocFileStream()
// ---------------------------------------------------
HRESULT STDAPICALLTYPE AllocFileStream( LPSTREAM FAR *ppStream, 
									   LPCSTR szAbsFilePath, 
									   DWORD dwOffset, 
									   DWORD dwFlags )
{
	HRESULT		hr	= E_OUTOFMEMORY;
    CFileStream	*pStream;
	
	pStream = new CFileStream;

	if ( pStream )
	{
		pStream->AddRef();

		hr = pStream->Init( szAbsFilePath, dwOffset, dwFlags );

		if ( SUCCEEDED(hr) )
		{
			*ppStream = pStream;
		}
		else
		{
			pStream->Release();
		}

        Log(FYILOGLEVEL, "New IStream %08X", pStream);
	}

    return(hr);
}


// ---------------------------------------------------
//  AllocStreamFromFile()
// ---------------------------------------------------
HRESULT AllocStreamFromFile( LPSTREAM *ppStream, 
											LPCSTR szAbsFilePath, 
											DWORD dwOffset )
{
	return AllocFileStream( ppStream, szAbsFilePath, dwOffset, STREAM_READ );
}


// ************************************************************************
// ************************************************************************
//
//  CFileStream
//
// ************************************************************************
// ************************************************************************

// ---------------------------------------------------
//  CFileStream
// ---------------------------------------------------
CFileStream::CFileStream(void)
{
    m_RefCnt = 0;
//    m_szFileName[0] = '0';
    m_dwStartOffset = 0;
	m_fInited = false;
    //m_pCachedClone = NULL;
    //m_pOriginal = NULL;



	// Unicode stuff
	//m_wzFileName[0] = '0';
}

// ---------------------------------------------------
//  ~CFileStream
// ---------------------------------------------------
CFileStream::~CFileStream()
{

    Log(FYILOGLEVEL, "Deleting IStream %08X", this);

    // close file if it is open
    if ( m_hFile )
    {
		CloseHandle( m_hFile );
        m_hFile = NULL;
    }

    //If we're referencing another stream, then release it.
//    RELEASE(m_pOriginal);

}

// ---------------------------------------------------
//  CFileStream::AddRef()
// ---------------------------------------------------
STDMETHODIMP_(ULONG) CFileStream::AddRef() 
{ 
    return ++m_RefCnt;
} 

// ---------------------------------------------------
//  CFileStream::Release()
// ---------------------------------------------------
STDMETHODIMP_(ULONG) CFileStream::Release() 
{
    DWORD RefCnt = --m_RefCnt;
    if (RefCnt == 0)
        delete this; 
    return RefCnt; 
}

// ---------------------------------------------------
//  CFileStream::QueryInterface()
// ---------------------------------------------------
STDMETHODIMP CFileStream::QueryInterface(REFIID iid, LPVOID* ppvObj) 
{ 
//    ASSERT(ppvObj);

    *ppvObj = NULL;

    if (IsEqualIID(iid, IID_IUnknown))
        *ppvObj = (LPVOID)(LPUNKNOWN)this;

    if (IsEqualIID(iid, IID_IStream))
        *ppvObj = (LPVOID)(LPSTREAM)this;

    if (*ppvObj)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
} 


// ---------------------------------------------------
//  CFileStream::Init
// ---------------------------------------------------
STDMETHODIMP CFileStream::Init( const char *szAbsFilePath, 
							   DWORD dwOffset, 
							   DWORD fdwFlags )
{
	HRESULT	hr	= E_FAIL;

	m_fdwFlags = fdwFlags;

	if ( m_fdwFlags & STREAM_READ )
	{ 
	    // open the file read only
		m_hFile = CreateFile( szAbsFilePath, 
								GENERIC_READ,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								fdwFlags,
								NULL );

	    // if we opened it, and we could seek to position specified
	    if ( ( INVALID_HANDLE_VALUE != m_hFile ) && 
			( 0xffffFFFF != SetFilePointer( m_hFile, (long)dwOffset, NULL, FILE_BEGIN ) ) )
	    {
	        // then set up all of our variables
	        strcpy( m_szFileName, szAbsFilePath );
	        m_dwStartOffset = dwOffset;
	       	m_dwLength = 0;
			m_fInited = TRUE;
	    }
	}
	else if ( m_fdwFlags & STREAM_WRITE )
	{
		// open the file for writing - create the file if it does not exist.
		m_hFile = CreateFile( szAbsFilePath, 
								GENERIC_WRITE,
								0,
								NULL,
								OPEN_ALWAYS,
								fdwFlags,
								NULL );
		if ( INVALID_HANDLE_VALUE != m_hFile )
		{
			m_fInited = TRUE;
		}
	}
	
	if ( m_fInited )
	{
		hr = S_OK;
	}

	return(hr);
}


// ---------------------------------------------------
//  CFileStream::Read()
// ---------------------------------------------------
STDMETHODIMP CFileStream::Read
(
    void* pv, 
    ULONG cb, 
    ULONG* pcbRead 
)
{ 
	DWORD dw;

	if( ReadFile( m_hFile, pv, cb, &dw, NULL ) &&
		dw == cb )
	{
		if( pcbRead != NULL )
		{
			*pcbRead = dw;
		}
		return S_OK;
	}
	return E_FAIL;
} 

// ---------------------------------------------------
//  CFileStream::Seek()
// ---------------------------------------------------
STDMETHODIMP CFileStream::Seek( THIS_ 
							   LARGE_INTEGER dlibMove, 
							   DWORD dwOrigin, 
							   ULARGE_INTEGER *pliNewPosition )
{
	HRESULT	hr			= E_FAIL;
	DWORD	dwOffset	= 0xffffFFFF;

	long	lOffset	= HFILE_ERROR;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET : 
		dwOffset = SetFilePointer( m_hFile, (LONG)(m_dwStartOffset + dlibMove.LowPart), NULL, FILE_BEGIN );
        break;

    case STREAM_SEEK_CUR : 
		dwOffset = SetFilePointer( m_hFile, (LONG)(dlibMove.LowPart), NULL, FILE_CURRENT );
        break;

    case STREAM_SEEK_END :
		dwOffset = SetFilePointer( m_hFile, (LONG)(dlibMove.LowPart), NULL, FILE_END );
        break;
    
    default:
    	break;
//        ASSERTSZ(FALSE,"Invalid Flag for Stream::Seek");
    }

	if ( 0xffffFFFF == dwOffset )
	{
		hr = E_FAIL;
	}
	else
	{ 
		hr = S_OK;

		if ( pliNewPosition )
		{
			pliNewPosition->LowPart = SetFilePointer( m_hFile, 0, NULL, FILE_CURRENT );
			pliNewPosition->HighPart = 0;
		}
	}

    return hr;
} 

// ---------------------------------------------------
//  CFileStream::Write()
// ---------------------------------------------------

STDMETHODIMP CFileStream::Write( THIS_ 
								VOID const HUGEP *pv,
								ULONG cb, 
								ULONG * pcbWritten )
{   
	return ( ( WriteFile( m_hFile, pv, cb, pcbWritten, NULL ) == 0 ) 
		? E_FAIL : S_OK );
}


STDMETHODIMP CFileStream::Clone(THIS_ IStream ** ppFileStream)
{   
    HRESULT hr;
    *ppFileStream = NULL;
    hr = AllocStreamFromFile(ppFileStream, m_szFileName, 0);
    
    //Set the clone's original pointer to us, and addref us.
    //((CFileStream *)pStream)->m_pOriginal = this;
    //AddRef();
    //m_pCachedClone = pStream;

    Log(FYILOGLEVEL, "Cloned %08X -> %08X", this, *ppFileStream);

    return hr;
}

// NOT IMPLEMENTED CFileStream IStream methods


STDMETHODIMP CFileStream::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::CopyTo(THIS_ IStream * pStm, ULARGE_INTEGER cb,   ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Commit(THIS_ DWORD grfCommitFlags)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Revert(THIS)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::LockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::UnlockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,   DWORD dwLockType)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Stat(THIS_ STATSTG * pstatstg, DWORD grfStatFlag)
{   return E_NOTIMPL; }




}//end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_MusicHeapTrack.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <globals.h>
#include "help_musicheap.h"

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
class CMusicHeapTrack : public IMusicHeap
{

public:

    CMusicHeapTrack(void);
    ~CMusicHeapTrack(void);
    HRESULT Initialize(bool bIsPhysicalHeap);


    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);
    STDMETHOD(Free)(void *pv);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);
    STDMETHOD(SetSize                    )(DWORD dwLimit);

private:
    void* Alloc(size_t cb);

    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    bool m_bPhysicalHeap;
    LONG m_cRef;
    bool m_bLimit;
    DWORD m_dwLimit;
};


CMusicHeapTrack::CMusicHeapTrack(void)
{
    InitializeCriticalSection(&m_csHeap);
    m_cRef = 1;
    m_bPhysicalHeap = false;
    m_dwHeapAllocation = 0;
    m_dwHeapAllocationPeak = 0;
    m_dwHeapAllocationBlocks = 0;
    m_dwHeapAllocationBlocksPeak = 0;
    m_bLimit  = FALSE;
    m_dwLimit = 0;

}

CMusicHeapTrack::~CMusicHeapTrack(void)
{
    DeleteCriticalSection(&m_csHeap);
}

HRESULT CMusicHeapTrack::Initialize(bool bIsPhysicalHeap)
{
    m_bPhysicalHeap = bIsPhysicalHeap;
    return S_OK;
}

ULONG STDMETHODCALLTYPE CMusicHeapTrack::AddRef( void)         
{
return InterlockedIncrement(&m_cRef);
}



ULONG STDMETHODCALLTYPE CMusicHeapTrack::Release(void) 
{
    ULONG cRef;            
    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

STDMETHODIMP CMusicHeapTrack::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
return E_NOTIMPL;
}



STDMETHODIMP CMusicHeapTrack::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = Alloc(dwSize);
    if(!pData){
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}



void* CMusicHeapTrack::Alloc(size_t cb)
{
    DWORD* pBlock = 0;

    EnterCriticalSection(&m_csHeap);
    if (m_bLimit)
    {
        if(cb + sizeof(DWORD) + m_dwHeapAllocation > m_dwLimit)
        {        
            Log(ABORTLOGLEVEL, "");
            Log(ABORTLOGLEVEL, "%s HEAP OUT OF MEMORY!!!", m_bPhysicalHeap ? "PHYSICAL" : "NON-PHYSICAL");
            Log(ABORTLOGLEVEL, "Requested size                 = %u", cb);
            Log(ABORTLOGLEVEL, "m_dwHeapAllocation             = %u", m_dwHeapAllocation);
            Log(ABORTLOGLEVEL, "m_dwHeapSize                   = %u", m_dwLimit);
            Log(ABORTLOGLEVEL, "m_dwHeapAllocationBlocks       = %u", m_dwHeapAllocationBlocks);
            Log(ABORTLOGLEVEL, "m_dwHeapAllocationBlocksPeak   = %u", m_dwHeapAllocationBlocksPeak);
            Log(ABORTLOGLEVEL, "");
            ASSERT(FALSE);
            LeaveCriticalSection(&m_csHeap);
            return NULL;
        }
    }
    
    if (!m_bPhysicalHeap)
        pBlock = (DWORD *)LocalAlloc(LMEM_FIXED, cb + sizeof(DWORD));
    else
        pBlock = (DWORD *)XPhysicalAlloc(cb + sizeof(DWORD), MAXULONG_PTR, 0, PAGE_READWRITE);

    if(!pBlock)
    {
        LeaveCriticalSection(&m_csHeap);
        return NULL;
    }


    m_dwHeapAllocation += (cb + sizeof(DWORD));
    if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
        m_dwHeapAllocationPeak = m_dwHeapAllocation;
    }
    ++m_dwHeapAllocationBlocks;
    if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
        m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }

    LeaveCriticalSection(&m_csHeap);

    *pBlock = cb;
    return pBlock + 1;
}

STDMETHODIMP CMusicHeapTrack::GetSize(PVOID pData, LPDWORD pcbSize)
{
    ASSERT(pData);
    DWORD* pBlock = ((DWORD*) pData) - 1;
    *pcbSize = *pBlock;

    return S_OK;
}

STDMETHODIMP CMusicHeapTrack::Free(void *pv)
{
    ASSERT(pv);
    DWORD* pBlock = ((DWORD*) pv) - 1;
    DWORD cb = *pBlock;
    EnterCriticalSection(&m_csHeap);
    ASSERT(cb+sizeof(DWORD) < 64 * 1024 * 1024);
    
    //Update our stats
    m_dwHeapAllocation -= (cb + sizeof(DWORD));
    --m_dwHeapAllocationBlocks;

    //Set all block memory to a certain value.
    memset((void *)pBlock, 0xFE, cb+sizeof(DWORD));

    LeaveCriticalSection(&m_csHeap);
    if (m_bPhysicalHeap)
        XPhysicalFree(pBlock);
    else
        LocalFree(pBlock);

    return S_OK;
}



STDMETHODIMP CMusicHeapTrack::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    *pdwHeapAllocation = m_dwHeapAllocation;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    return S_OK;
};


STDMETHODIMP CMusicHeapTrack::SetSize(DWORD dwLimit)
{
ASSERT(dwLimit < 64 * 1024 * 1024);
m_bLimit = TRUE;
m_dwLimit = dwLimit;
return S_OK;
};



HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical)
{
    HRESULT hr = S_OK;
    CMusicHeapTrack* pHeap = new CMusicHeapTrack();
    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_StatsMemoryUse.cpp ===
#include "globals.h"
#include "Help_MusicHeap.h"


static IMusicHeap *g_pNormal   = NULL;
static IMusicHeap *g_pPhysical = NULL;

/********************************************************************************
********************************************************************************/
//HRESULT CreateHeaps(IMusicHeap **ppNormal, IMusicHeap **ppPhysical)
HRESULT CreateHeaps(LPCSTR szHeap, DWORD dwLimitNormal, DWORD dwLimitPhysical)
{
HRESULT hr = S_OK;

ASSERT(&g_pNormal);
ASSERT(&g_pPhysical);

CHECKRUN(CreateMusicHeapTrack(&g_pNormal, FALSE));
CHECKRUN(CreateMusicHeapTrack(&g_pPhysical, TRUE));
if (_strcmpi(szHeap, "tracking") == 0)
{
}
else if (_strcmpi(szHeap, "fixeduser") == 0)
{
    CHECKRUN(g_pNormal->SetSize  (dwLimitNormal));
    CHECKRUN(g_pPhysical->SetSize(dwLimitPhysical));
}
else
{
    ::Log(ABORTLOGLEVEL, "Error: specified unknown heap type %s", szHeap);
    hr = E_FAIL;
}

if (FAILED(hr))
{
    RELEASE(g_pNormal);
    RELEASE(g_pPhysical);
}

return hr;
};

/********************************************************************************
********************************************************************************/
HRESULT InitializeDMusicWithCreatedHeaps(void)
{
    ASSERT(g_pNormal);
    ASSERT(g_pPhysical);
    return DirectMusicInitializeEx(g_pNormal, g_pPhysical, &DirectMusicDefaultFactory);
}


/********************************************************************************
********************************************************************************/
//HRESULT DestroyHeaps(IMusicHeap *pNormal, IMusicHeap *pPhysical)
HRESULT DestroyHeaps(void)
{
HRESULT hr = S_OK;

//No reason to call this if they're NULL anyway.
ASSERT(g_pNormal);
ASSERT(g_pPhysical);

RELEASE(g_pNormal);
RELEASE(g_pPhysical);

return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT GetMemoryUsage(BOOL bPhysical, DWORD *pdwMemUsage)
{
    IMusicHeap *pHeap = bPhysical ? g_pPhysical : g_pNormal;
    ASSERT(pHeap);
    ASSERT(pdwMemUsage);
    return pHeap->GetHeapAllocation(pdwMemUsage);
}



/********************************************************************************
INPARAMS:
    bPhysical           = TRUE if physical memory, FALSE if normal memory.
    dwTargetRange       = The maximum number of bytes the memory may vary over the target duration.
    dwTargetDuration    = how long the memory must stay within the target range.
    dwTimeOut           = how long we'll wait before timing out.

OUTPARAMS:
    pbStabilized        = Did the memory stabilize within the given parameters before the timeout period elapsed?
    pdwMemory           = The final memory reading, after stabilization has been reached.

NOTES:
    If memory doesn't stabilize, the function will still return
        S_OK
        *pbStabilized = FALSE
        *pdwMemory    = 0
********************************************************************************/
//How many milliseconds to wait between memory samples.  Currently a target duration of 1-second will require a 50-element array.
#define SAMPLE_FREQUENCY 20
HRESULT WaitForMemoryToStabilize(BOOL bPhysical, DWORD dwTargetRange, DWORD dwTargetDuration, DWORD dwTimeOut, BOOL *pbStabilized, DWORD *pdwMemory)
{
HRESULT hr = S_OK;
DWORD dwStartTime = 0;
DWORD  dwTotalMemorySamples = 0;
DWORD  dwNextSample = 0;
BOOL   bFilledArray = FALSE;
DWORD *pdwMemorySamples = NULL;
BOOL   bStabilized = FALSE;
DWORD  dwMemory = 0;


//We allocate a circular array to hold the samples.
dwTotalMemorySamples = dwTargetDuration / SAMPLE_FREQUENCY;
pdwMemorySamples = new DWORD[dwTotalMemorySamples];

ASSERT(dwTotalMemorySamples > 20);

//Repeatedly take samples.
dwStartTime = timeGetTime();
while (timeGetTime() - dwStartTime < dwTimeOut)
{
    //Take a sample.
    CHECKRUN(GetMemoryUsage(bPhysical, &pdwMemorySamples[dwNextSample]));

    //If we've hit the end of the array, wrap around.  Also set the "filled" flag
    //  if its our first time, signifying we've collected enough data to analyze.
    if (SUCCEEDED(hr))
    {
        dwNextSample++;
        if (dwNextSample == dwTotalMemorySamples)
        {
            if (!bFilledArray)
                bFilledArray = TRUE;

            dwNextSample = 0;
        }

        //If we've collection enough data to analyze...
        if (bFilledArray)
        {
            
            //Then calculate the range of the samples.  Not the most efficient code, but the most readable.
            DWORD dwLowest = 0xFFFFFFFF;
            DWORD dwHighest = 0;
            DWORD dwRange = 0;
            DWORD i = 0;

            for (i=0; i<dwTotalMemorySamples; i++)
            {
                if (pdwMemorySamples[i] < dwLowest)
                    dwLowest = pdwMemorySamples[i];
                if (pdwMemorySamples[i] > dwHighest)
                    dwHighest = pdwMemorySamples[i];                
            }

            //If we meet our criteria, then memory has stabilized and we're outta here!!
            dwRange = (dwHighest - dwLowest);
            if (dwRange <= dwTargetRange)
            {
                bStabilized = TRUE;
                break;
            }
        }
    }

    Sleep(SAMPLE_FREQUENCY);
}

//If we stabilize then set our memory to the last sample taken.
if (bStabilized)
{
    DWORD dwMostRecentSample;

    if (0 == dwNextSample)
        dwMostRecentSample = dwTotalMemorySamples - 1;
    else
        dwMostRecentSample = dwNextSample - 1;

    dwMemory = pdwMemorySamples[dwMostRecentSample];
}
else
{
    dwMemory = 0;
}

//At the highest log level, print out all the values obtained.
if (SUCCEEDED(hr))
{
    Log(MAXLOGLEVEL, "MEMORY STABLIZED: %s", bStabilized ? "YES" : "NO");
    Log(MAXLOGLEVEL, "Memory values");
    Log(MAXLOGLEVEL, "-------------");

    for (DWORD i=0; i<dwTotalMemorySamples; i++)
    {
        Log(MAXLOGLEVEL, "%8u", pdwMemorySamples[ (dwNextSample + i) % dwTotalMemorySamples]);
    }
}

//Clean up.
delete []pdwMemorySamples;
pdwMemorySamples = NULL;

//Set the outparams.
if (pbStabilized)
    *pbStabilized = bStabilized;
if (pdwMemory)
    *pdwMemory = dwMemory;

return hr;


}
#undef SAMPLE_FREQUENCY


/********************************************************************************
********************************************************************************/
HRESULT ExpectMemoryToStabilize(BOOL bPhysical, DWORD dwTargetRange, DWORD dwTargetDuration, DWORD dwTimeOut, BOOL *pbStabilized, DWORD *pdwMemory)
{
HRESULT hr = WaitForMemoryToStabilize(bPhysical, dwTargetRange, dwTargetDuration, dwTimeOut, pbStabilized, pdwMemory);
if (SUCCEEDED(hr))
{
    if (!(*pbStabilized))
    {
        hr = E_FAIL;
    }
}

return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Suite.cpp ===
#include "globals.h"
#include "help_suite.h"
#include "help_dowork.h"
#include "help_worsttimes.h"
#include "help_FileIOStress.h"
#include "help_statsmemoryuse.h"

#define CHECK_SUITE_INITIALIZED {                                                            \
    if (!m_bInitialized)                                                                 \
    {                                                                                   \
        ::Log(ABORTLOGLEVEL, "ERROR (%s, line %d): SUITE %08X is not initialized!", __FILE__, __LINE__, this);    \
        hr = E_FAIL;                                                                    \
    }                                                                                   \
}

static BOOL g_bDMusicAlreadyInitialized = FALSE;

/********************************************************************************
********************************************************************************/
SUITE::SUITE(void)
{
    m_bInitialized = FALSE;
};

/********************************************************************************
********************************************************************************/
HRESULT SUITE::Init(LPCSTR cszSectionName, const TESTCASE *pTestCases, DWORD dwTestArraySize)
{
    HRESULT hr = S_OK;
    const CHAR *szAppNamePosition= NULL;
    CHAR szAppNamePrefix[MAX_PATH] = {0};
    ZeroMemory(&m_TestParams, sizeof(m_TestParams));
    m_pbRunTest = NULL;        
    ZeroMemory(m_szSuiteName, sizeof(CHAR) * MAX_PATH);
    m_pTestCases = NULL;
    m_dwTestArraySize = 0;
    m_pSuite = NULL;
    m_dwPassed = 0;
    m_dwFailed = 0;

    //Add an '_'.
    sprintf(szAppNamePrefix, "%s_", g_szAppName);
    
    //Make sure we're not already initialized.
    if (m_bInitialized)
    {   
        ::Log(ABORTLOGLEVEL, "Init failed: SUITE %08X is already initialized!", this);
        hr = E_FAIL;
    }

    //Verification: make sure our name follows the rules:
    //  A) Must contain "DMTEST1_" at the beginning, or
    //  B) Must contain only "DMTEST1";

    if (SUCCEEDED(hr))
    {
        szAppNamePosition = strstr(cszSectionName, szAppNamePrefix);
        if (!szAppNamePosition)
        {
            if (_strcmpi(g_szAppName, cszSectionName))
            {
                ::Log(ABORTLOGLEVEL, "Error: %s was not found in %s", szAppNamePrefix, cszSectionName);
                hr = E_FAIL;
            }
            else
            {
                szAppNamePosition = cszSectionName;
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (szAppNamePosition != cszSectionName)
        {
            ::Log(ABORTLOGLEVEL, "Error: %s was not found at beginning of %s", szAppNamePrefix, cszSectionName);
            hr = E_FAIL;            
        }
    }

    m_dwTestArraySize = dwTestArraySize;
    m_pTestCases      = pTestCases;
    
    //Allocate and clear the array
    CHECK(m_pbRunTest = new BOOL[m_dwTestArraySize]);
    CHECKALLOC(m_pbRunTest);
    CHECK(ZeroMemory(m_pbRunTest, m_dwTestArraySize * sizeof(BOOL)));

    //Clear out our testparams
    CHECK(ZeroMemory((void*)&m_TestParams, sizeof(m_TestParams)));

    //Save our good name.
    CHECK(strncpy(m_szSuiteName, cszSectionName, MAX_PATH - 1));

    if (SUCCEEDED(hr))
        m_bInitialized = TRUE;

    return hr;
};

/********************************************************************************
********************************************************************************/
SUITE::~SUITE(void)
{    
    if (m_bInitialized)
    {
        if (m_pbRunTest)
        {
            memset(m_pbRunTest, 0xFFFF, m_dwTestArraySize);
            delete []m_pbRunTest;
        }
        m_pbRunTest = NULL;
    }
};


#define SUFFIXES 3

/********************************************************************************
********************************************************************************/
HRESULT SUITE::Load(void)
{
HRESULT hr = S_OK;
CHECK_SUITE_INITIALIZED;

//Local vars and const strings.
DWORD i;
DWORD dwMax = 0;
DWORD dwPurpose = 0;
LPCSTR szCountKey[SUFFIXES] = {"maxtestomit", "maxtestadd", "defaultmediafilesadd"};
LPCSTR szSuffix[SUFFIXES] = {"testomit", "testadd", "defaultmediafiles"};
LPCSTR szDefaultDirectory = "T:\\DMTest1\\Default\\";
LPSTR szTemp = NULL;


//Allocate a temporary string.  If this fails, just bail.
szTemp = new CHAR[MAX_PROFILESECTION_SIZE];
CHECKALLOC(szTemp);
if (FAILED(hr))
    return hr;


//Set up the final names, such as [DMTEST1_SUITE2_TESTADD]
CHAR szSectionNameAddOmit[SUFFIXES][MAX_PATH];
for (i=0; i<SUFFIXES; i++)
{
    sprintf(szSectionNameAddOmit[i], "%s_%s",  m_szSuiteName, szSuffix[i]);
}


    //Read all the main test params.
    m_TestParams.bWait  =           GetProfileInt(m_szSuiteName, "wait",   TRUE);
    m_TestParams.bBVT   =           GetProfileInt(m_szSuiteName, "bvt",    FALSE);
    m_TestParams.bValid =           GetProfileInt(m_szSuiteName, "valid",  FALSE);
    m_TestParams.bInvalid =         GetProfileInt(m_szSuiteName, "invalid",FALSE);
    m_TestParams.bFatal =           GetProfileInt(m_szSuiteName, "fatal",  FALSE);
    m_TestParams.bPerf  =           GetProfileInt(m_szSuiteName, "perf",   FALSE);
    m_TestParams.dwPerfWait=        GetProfileInt(m_szSuiteName, "perfwait",10);
    m_TestParams.bStress=           GetProfileInt(m_szSuiteName, "stress", FALSE);
    m_TestParams.bLogToScreen   =   GetProfileInt(m_szSuiteName, "logtoscreen", FALSE);    
    m_TestParams.dwWaitBetweenTests=GetProfileInt(m_szSuiteName, "waitbetweentests", 0);
    m_TestParams.bWaitAtTestEnd =   GetProfileInt(m_szSuiteName, "waitattestend", FALSE);
    GetProfileString(m_szSuiteName, "initperformance", "Once", m_TestParams.szInitPerformance, szInitPerformance_SIZE);
    m_TestParams.bSkipUserInput    =GetProfileInt(m_szSuiteName, "skipuserinput", FALSE);
    m_TestParams.bSuppressMemInfo  =GetProfileInt(m_szSuiteName, "suppressmeminfo", FALSE);
    m_TestParams.bUseGM_DLS        =GetProfileInt(m_szSuiteName, "usegm_dls", FALSE);
    m_TestParams.dwDebugLevel =     GetProfileInt(m_szSuiteName, "debuglevel", 1);
    m_TestParams.dwRIPLevel =       GetProfileInt(m_szSuiteName, "riplevel", 0);
    m_TestParams.dwLocalLogLevel   =GetProfileInt(m_szSuiteName, "localloglevel", FYILOGLEVEL);
    m_TestParams.dwMLDebugLevel    =GetProfileInt(m_szSuiteName, "MLDebugLevel",       2);
    m_TestParams.bDoWorkLocalThread=GetProfileInt(m_szSuiteName, "doworklocalthread", FALSE);
    m_TestParams.dwDoWorkFrequency =GetProfileInt(m_szSuiteName, "doworkfrequency", 0);
    m_TestParams.dwDMVoiceCount    =GetProfileInt(m_szSuiteName, "dmvoicecount", 128);
    m_TestParams.dwDecreaseMemory=  GetProfileInt(m_szSuiteName, "decreasememory", 0);
    m_TestParams.dwStressFileIODuration  =GetProfileInt(m_szSuiteName, "stressfileioduration", 0);
                                    GetProfileString(m_szSuiteName, "stressfileiothreadpri",    "THREAD_PRIORITY_NORMAL", m_TestParams.szStressFileIOThreadPri, MAX_PATH);
                                    GetProfileString(m_szSuiteName, "DSScratchImage",           "Default",                m_TestParams.szDSScratchImage, MAX_PATH);
                                    GetProfileString(m_szSuiteName, "DSHRTF",                   "FULL",                   m_TestParams.szDSHRTF, MAX_PATH);
                                    GetProfileString(m_szSuiteName, "InitialTestCase",          "",                       m_TestParams.szInitialTestCase, MAX_PATH);

    DWORD dwFixedSizeHeapDefaultNorm = 4 * 1024 * 1024;
    DWORD dwFixedSizeHeapDefaultPhys = 1024 * 1024 / 2;
    LPCSTR szDMDefaultHeap = "Tracking";
    GetProfileString(m_szSuiteName, "DMHeap", szDMDefaultHeap, m_TestParams.szDMHeap, MAX_PATH);
    BOOL bFixedSizeHeap = (_strcmpi(m_TestParams.szDMHeap, "FixedUser") == 0);
    m_TestParams.dwDMFixedHeapSizeNorm  = GetProfileInt(m_szSuiteName, "DMFixedHeapSizeNorm",   bFixedSizeHeap ? dwFixedSizeHeapDefaultNorm  : 0);
    m_TestParams.dwDMFixedHeapSizePhys  = GetProfileInt(m_szSuiteName, "DMFixedHeapSizePhys",   bFixedSizeHeap ? dwFixedSizeHeapDefaultPhys  : 0);

    if (!m_TestParams.bDoWorkLocalThread && m_TestParams.dwDoWorkFrequency)
    {
        ::Log(ABORTLOGLEVEL, "Warning: You're not running a local DoWork() thread but you've set DoWorkFrequency() to %d.  This # will be ignored.", m_TestParams.dwDoWorkFrequency); 
    }
   

    //Print out the test parameters.
    Log();

    //Enable/Disable tests of each type according to parameters.
    if (m_TestParams.bBVT)
        EnableAllTestsOfType("BVT");
    if (m_TestParams.bValid)
        EnableAllTestsOfType("Valid");
    if (m_TestParams.bInvalid)
        EnableAllTestsOfType("Invalid");
    if (m_TestParams.bFatal)
        EnableAllTestsOfType("Fatal");
    if (m_TestParams.bPerf)
        EnableAllTestsOfType("PerfMem");    
    
    
    MLSetErrorLevel(m_TestParams.dwMLDebugLevel);
    DirectMusicSetDebugLevel(m_TestParams.dwDebugLevel, m_TestParams.dwRIPLevel);
    if (m_TestParams.dwDebugLevel < m_TestParams.dwRIPLevel)
        ::Log(ABORTLOGLEVEL, "Warning: Debug level is %d but RIP level is higher (%d).");

    // Initialize DMusic here.  We can only do it once, even if we delete and re-create
    //  the performance object many times.
    if (!g_bDMusicAlreadyInitialized)
    {
        CHECKRUN(CreateHeaps(m_TestParams.szDMHeap, m_TestParams.dwDMFixedHeapSizeNorm, m_TestParams.dwDMFixedHeapSizePhys));
        CHECKRUN(InitializeDMusicWithCreatedHeaps());
        CHECK   (g_bDMusicAlreadyInitialized = TRUE);
    }
    else
    {
        if (_strcmpi(m_TestParams.szDMHeap, szDMDefaultHeap))
        {
            ::Log(ABORTLOGLEVEL, "Error: Specified a heap (%s), but DMusic heaps have already been initialized.", m_TestParams.szDMHeap);
        }        
        if (m_TestParams.dwDMFixedHeapSizeNorm != dwFixedSizeHeapDefaultNorm)
        {
            ::Log(ABORTLOGLEVEL, "Error: Specified a value (%u) DMFixedHeapSizeNorm, but DMusic heaps have already been initialized.", m_TestParams.dwDMFixedHeapSizeNorm);
        }
        if (m_TestParams.dwDMFixedHeapSizePhys != dwFixedSizeHeapDefaultPhys)
        {
            ::Log(ABORTLOGLEVEL, "Error: Specified a value (%u) DMFixedHeapSizePhys, but DMusic heaps have already been initialized.", m_TestParams.dwDMFixedHeapSizePhys);
        }
    }
 
    //Make sure we chose a valid type of HRTF function.
    if (_strcmpi(m_TestParams.szDSHRTF, "full") &&
        _strcmpi(m_TestParams.szDSHRTF, "light")
        )
    {
        ::Log(ABORTLOGLEVEL, "Error: Specified %s for m_TestParams.szDSHRTF, but need to specify ""FULL"" or ""LIGHT""\n", m_TestParams.szDSHRTF);
    }

    if (_strcmpi(m_TestParams.szInitPerformance, "EveryTest") &&
        _strcmpi(m_TestParams.szInitPerformance, "Once") &&
        _strcmpi(m_TestParams.szInitPerformance, "Never")
        )
    {
        ::Log(ABORTLOGLEVEL, "Error: Specified %s for m_TestParams.szInitPerformance, but need to specify ""EveryTest"", ""Once"", or ""Never""\n", m_TestParams.szInitPerformance);
    }

    if (_strcmpi(m_TestParams.szStressFileIOThreadPri, "THREAD_PRIORITY_IDLE") &&
        _strcmpi(m_TestParams.szInitPerformance, "Once") &&
        _strcmpi(m_TestParams.szInitPerformance, "Never")
        )
    {
        ::Log(ABORTLOGLEVEL, "Error: Specified %s for m_TestParams.szInitPerformance, but need to specify ""EveryTest"", ""Once"", or ""Never""\n", m_TestParams.szDSHRTF);
    }

    if //(_strcmpi(m_TestParams.szDMHeap, "Default") &&
        (_strcmpi(m_TestParams.szDMHeap, "Tracking") &&
        _strcmpi(m_TestParams.szDMHeap, "FixedUser")
        //_strcmpi(m_TestParams.szDMHeap, "FixedDefault")

        )
    {
        ::Log(ABORTLOGLEVEL, "Error: Specified %s for m_TestParams.szDMHeap; need to specify ""Tracking"" or ""FixedUser""\n", m_TestParams.szDMHeap);
        hr = E_FAIL;
    }

    if (FAILED(ThreadPriFromString(m_TestParams.szStressFileIOThreadPri, NULL)))
    {
        ::Log(ABORTLOGLEVEL, "Error: Specified invalid string (%s) for m_TestParams.szStressFileIOThreadPri", m_TestParams.szStressFileIOThreadPri);
    }
    
    //Now go through our array of test cases and check for omissions or additions.  If a test has been added or omitted via
    //  the addition of all tests of a certain type (say "valid" tests), this will override that.
    for (dwPurpose = 0; dwPurpose < SUFFIXES; dwPurpose++)
    {
        dwMax = GetProfileInt(m_szSuiteName, szCountKey[dwPurpose], 0);
        CHAR szKey[MAX_PATH] = {0};
        CHAR szTestName[MAX_PATH];
        for (i=0; i<=dwMax; i++)
        {
            sprintf(szKey, "%s%04d", szSuffix[dwPurpose], i);
            GetProfileString(m_szSuiteName, szKey, "NULL", szTestName, MAX_PATH);        
            if (strcmp("NULL", szTestName) == 0)
                continue;
            
            if (dwPurpose < 2)
                AddOmitTestCase(szTestName, dwPurpose);
            else
                {
                    hr = MediaCopyFile(szTestName, szDefaultDirectory, COPY_IF_NEWER);
                    if (FAILED(hr))
                    {
                        ::Log(ABORTLOGLEVEL, "Error: Failed to copy %s to %s (%s)", szTestName, szDefaultDirectory, tdmXlatHRESULT(hr));
                    }
                }
        }
    }

    //Added support for doing this w/o the numbers.
    CHAR *szLastString= NULL;
    for (dwPurpose = 0; dwPurpose < 2; dwPurpose++)
    {
        //dwMax = GetPrivateProfileSectionA(szSectionNameAddOmit[dwPurpose], szTemp, MAX_PROFILESECTION_SIZE , szININame);
        dwMax = GetProfileSection(szSectionNameAddOmit[dwPurpose], szTemp, MAX_PROFILESECTION_SIZE );
        if (dwMax == MAX_PROFILESECTION_SIZE  - 2)
        {
            ::Log(ABORTLOGLEVEL, "ERROR: Filled up entire %d characters, need to increase MAX_PROFILESECTION_SIZE ", MAX_PROFILESECTION_SIZE );
        }

        //Get all test cases and attempt to add them in.
        if (!szTemp[0])
            continue;

        szLastString = szTemp;
        for (i=0;;i++)
        {
            if (szTemp[i]==0 && i)
            {
                                
                if (dwPurpose < 2)
                    AddOmitTestCase(szLastString, dwPurpose);
                else
                {
                    hr = MediaCopyFile(szLastString, szDefaultDirectory, COPY_IF_NEWER);
                    if (FAILED(hr))
                    {
                        ::Log(ABORTLOGLEVEL, "Error: Failed to copy %s to %s (%s)", szLastString, szDefaultDirectory, tdmXlatHRESULT(hr));
                    }
                }

                szLastString = &szTemp[i+1];
            }

            //break on \0\0
            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }

    //Add two lines of space below list of test cases.
    ::Log(ABORTLOGLEVEL, "");
    ::Log(ABORTLOGLEVEL, "");






    //Dealing with the "default" media is kinda complex:
    //1) Copy the default piece of media to the default directory.
    CHAR szDefaultNetworkMedia[MAX_PATH] = {0};
    CHAR szDefaultMediaName   [MAX_PATH] = {0};
    if (SUCCEEDED(hr))
    {
        GetProfileString(m_szSuiteName, "defaultmedia", "SGT/test.sgt", szDefaultNetworkMedia, MAX_PATH);
        CHECKRUN(MediaCopyFile(szDefaultNetworkMedia, szDefaultDirectory, COPY_IF_NEWER));
    }

    //2) Figure out the file's local path.
    //2a) Figure out the file's name
    if (SUCCEEDED(hr))
    {
        CHECK(ChopPath(szDefaultNetworkMedia, NULL, szDefaultMediaName));    
        ASSERT(szDefaultMediaName[0]);
    }

    //2b) Tack that name onto the local file path.
    CHECK   (sprintf(m_TestParams.szDefaultMedia, "%s%s", szDefaultDirectory, szDefaultMediaName));

    //If we're using "test.sgt" then also copy over MAIN1.DLS.
    if (SUCCEEDED(hr))
    {
        if (strstr(m_TestParams.szDefaultMedia, "test.sgt"))
            CHECKRUN(MediaCopyFile("DLS/Main1.DLS", szDefaultDirectory, COPY_IF_NEWER));
    }
        

    //Free allocations.
    delete[]szTemp;
    return hr;
};


/********************************************************************************
Print out all the test parameters.
********************************************************************************/
HRESULT SUITE::Log(void)
{
    HRESULT hr = S_OK;
    CHECK_SUITE_INITIALIZED;

    ::Log(FYILOGLEVEL, "%s TEST PARAMETERS", m_szSuiteName);
    ::Log(FYILOGLEVEL, "----------------------------------");
    ::Log(FYILOGLEVEL, "bWait            : %s", m_TestParams.bWait  ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bBVT             : %s", m_TestParams.bBVT   ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bValid           : %s", m_TestParams.bValid ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bInvalid         : %s", m_TestParams.bInvalid?"TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bFatal           : %s", m_TestParams.bFatal ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bPerf            : %s", m_TestParams.bPerf  ? "TRUE" : "FALSE");    
    ::Log(FYILOGLEVEL, "dwWaitBetweenTsts: %d", m_TestParams.dwWaitBetweenTests);
    ::Log(FYILOGLEVEL, "dwPerfWait       : %d", m_TestParams.dwPerfWait);
    ::Log(FYILOGLEVEL, "bStress          : %s", m_TestParams.bStress        ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bWaitAtTestEnd   : %s", m_TestParams.bWaitAtTestEnd ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bLogToScreen     : %s", m_TestParams.bLogToScreen   ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "dwDebugLevel     : %d", m_TestParams.dwDebugLevel);
    ::Log(FYILOGLEVEL, "dwRIPLevel       : %d", m_TestParams.dwRIPLevel);
    ::Log(FYILOGLEVEL, "dwMLDebugLevel   : %d", m_TestParams.dwMLDebugLevel);
    ::Log(FYILOGLEVEL, "szInitPerformance: %s", m_TestParams.szInitPerformance);
    ::Log(FYILOGLEVEL, "bSkipUserInput   : %s", m_TestParams.bSkipUserInput  ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bUseGM_DLS:      : %s", m_TestParams.bUseGM_DLS  ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "bSuppressMemInfo : %s", m_TestParams.bSuppressMemInfo ? "TRUE" : "FALSE");
    ::Log(FYILOGLEVEL, "dwStressFileIODuration: %d", m_TestParams.dwStressFileIODuration);
    ::Log(FYILOGLEVEL, "dwLocalLogLevel    : %d", m_TestParams.dwLocalLogLevel);    
    ::Log(FYILOGLEVEL, "bDoWorkLocalThread: %s", m_TestParams.bDoWorkLocalThread? "TRUE" : "FALSE");    
    
    if (m_TestParams.dwDoWorkFrequency)
        ::Log(FYILOGLEVEL, "dwDoWorkFrequency: %d times / second", m_TestParams.dwDoWorkFrequency);
    else
        ::Log(FYILOGLEVEL, "dwDoWorkFrequency: NEVER");

    ::Log(FYILOGLEVEL, "dwVoiceCount     : %d", m_TestParams.dwDMVoiceCount);    
    ::Log(FYILOGLEVEL, "dwDecreaseMemory : %d", m_TestParams.dwDecreaseMemory);    


    if (m_TestParams.dwStressFileIODuration)
    {
        ::Log(FYILOGLEVEL, "dwStressFileIODuration:  %d ms", m_TestParams.dwStressFileIODuration);
        ::Log(FYILOGLEVEL, "dwStressFileIOThreadPri: %s ms", m_TestParams.szStressFileIOThreadPri);
    }
    else
        ::Log(FYILOGLEVEL, "dwStressFileIODuration: NO FILE IO STRESS");
    ::Log(FYILOGLEVEL, "szDefaultMedia   : %s", m_TestParams.szDefaultMedia);
    ::Log(FYILOGLEVEL, "szDSScratchImage : %s", m_TestParams.szDSScratchImage);
    ::Log(FYILOGLEVEL, "szDSHRTF         : %s", m_TestParams.szDSHRTF);
    ::Log(FYILOGLEVEL, "szInitialTestCase: %s", m_TestParams.szInitialTestCase);
    ::Log(FYILOGLEVEL, "szDMHeap                : %s", m_TestParams.szDMHeap);
    ::Log(FYILOGLEVEL, "dwDMFixedHeapSizeNorm   : %u", m_TestParams.dwDMFixedHeapSizeNorm);
    ::Log(FYILOGLEVEL, "dwDMFixedHeapSizePhys   : %u", m_TestParams.dwDMFixedHeapSizePhys);

    return S_OK;
};


/********************************************************************************
********************************************************************************/
HRESULT SUITE::GetTestParams(TESTPARAMS *pTestParams)
{
    HRESULT hr = S_OK;
    CHECK_SUITE_INITIALIZED;

    if (!pTestParams)
        return E_INVALIDARG;

    *pTestParams = m_TestParams;
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT SUITE::SetTestParams(TESTPARAMS &TestParams)
{
    HRESULT hr = S_OK;
    CHECK_SUITE_INITIALIZED;

    m_TestParams = TestParams;
    return hr;
};


/********************************************************************************
Loop through all tests and enable those of a certain type.
********************************************************************************/
void SUITE::EnableAllTestsOfType(LPSTR szType)
{
HRESULT hr = S_OK;
CHECK_SUITE_INITIALIZED;

DWORD i = 0;
    for (i=0; i<m_dwTestArraySize; i++)
    {
        if (strcmp(szType, m_pTestCases[i].szTestDesc) == 0)
        {
            m_pbRunTest[i] = TRUE;
        }
    }
};


/********************************************************************************
********************************************************************************/
void SUITE::AddOmitTestCase(LPSTR szTestName, BOOL bAdd)
{
HRESULT hr = S_OK;
CHECK_SUITE_INITIALIZED;

    BOOL bFound = FALSE;
    DWORD i = 0;
    DWORD dwPurpose = bAdd ? 1 : 0;
    CHAR *szPurpose[2]  = {"omitted", "added"};

    //We found a test to add/omit.  Go through our list of cases and turn on/off the "run" flag.
    for (i=0; i<m_dwTestArraySize; i++)
    {
        if (_strcmpi(m_pTestCases[i].szTestName, szTestName) == 0)
        {
            
            //Check to see if the test case was already in this state.  If so, warn the user.
            //No need to fail though.
            if (m_pbRunTest[i] == dwPurpose)
            {
                ::Log(FYILOGLEVEL, "Note: Test parameters requested %s to be %s, but it's already %s.", szTestName, szPurpose[dwPurpose], dwPurpose ? "there" : "absent");
            }
            
            m_pbRunTest[i] = dwPurpose; //0 = omit, 1 = add.
            ::Log(FYILOGLEVEL,"  -> %s %s %s set of test cases.", szPurpose[dwPurpose], szTestName, dwPurpose ? "to" : "from");
            bFound = TRUE;
            break;
        }
    }

    //Print an error if this test we were trying to add or omit wasn't found.
    if (!bFound)
    {
        ::Log(ABORTLOGLEVEL, "ReadAndProcessTestParams Error!!:");
        ::Log(ABORTLOGLEVEL, "Test Parameters requested that the ""%s"" test be %s, but that test doesn't exist", szTestName, szPurpose[dwPurpose]);
    }
}




#define MAX_MEMORY_OBJECTS 100
static    LONG lLastMemoryArray[MAX_MEMORY_OBJECTS] = {-1};
static    LONG lCurrentMemoryArray[MAX_MEMORY_OBJECTS]= {-1};



/******************************************************************************************
Runs through a whole array of tests.
******************************************************************************************/
void SUITE::RunTestArray(void)
{
    DWORD i;
    HRESULT hr = S_OK;
    HRESULT hrMemoryStats = S_OK;
    CtIDirectMusicPerformance8 *ptPerf8 = NULL;
    IDirectSound *pDSound = NULL;
    LPVOID        pMemory = NULL;

    //Copy our test suite's data to the global variable before anything else happens.  
    //THIS IS HORRIBLE DESIGN!!!!!!!  Only a quick hack because all the tests reference this structure.
    //TODO: Remove all references to g_TestParams!!    
    g_TestParams = m_TestParams;

    //Initresults
    m_dwPassed = 0;
    m_dwFailed = 0;

    //Steal memory, if requested.
    if (g_TestParams.dwDecreaseMemory)
    {
        pMemory = malloc(g_TestParams.dwDecreaseMemory);
        CHECKALLOC(pMemory);
    }

    //Initialize our high-score table of the worst test times.
    CHECKRUN(InitializeWorstTimes());

    //Initialize D3D ::Logging to screen.
    CHECKRUN(LogInit())

    //Initialize DSound (download scratch image)
    CHECKRUN(InitializeDSound(&pDSound));

    //Set DMusic's debug level.
    CHECK(LogSetDbgLevel(g_TestParams.dwLocalLogLevel));

    //Commence threads.
    //(DMusic's worker thread simulates a game running at (x=g_TestParams.dwDoWorkFrequency) FPS.)
    CHECKRUN(StartDoDMWorkThreadProc());
    CHECKRUN(StartFileIOStressThreadProc());

    //Initialize memory data.
    if (SUCCEEDED(hr))
    {
        memset((void *)lLastMemoryArray, 0, sizeof(LONG) * MAX_MEMORY_OBJECTS);
        memset((void *)lCurrentMemoryArray, 0, sizeof(LONG) * MAX_MEMORY_OBJECTS);
    }

    //Create the performance.
    if (InitPerformanceOnce())
    {
        CHECKRUN(CreateAndInitPerformance(&ptPerf8));
        if (FAILED(hr))
            ::Log(ABORTLOGLEVEL, "CreateAndInitPerformance returned %s (%08X)", dmthXlatHRESULT(hr), hr);
    }

    do
    {
        
        //Set "i" to either the beginning of the test array, or the specified test case, depending on the variable szInitialTestCase.
        if (_strcmpi(g_TestParams.szInitialTestCase, "") == 0)
        {
            i = 0;
        }
        else
        {

            BOOL bFound = FALSE;
            for (i=0; i<m_dwTestArraySize; i++)
            {
                if (_strcmpi(g_TestParams.szInitialTestCase, m_pTestCases[i].szTestName) == 0)
                {
                    bFound = TRUE;
                    break;
                }
            }
            if (!bFound)
            {
                ::Log(FYILOGLEVEL, "ERROR: Initial test case %s wasn't found - starting at index 0.", g_TestParams.szInitialTestCase);
                i = 0;
            }
        }
        
        //Loop through the array.
        for (; i<m_dwTestArraySize; i++)
        {
            HRESULT hrCall = S_OK;
            DWORD dwStartTime = 0;
            DWORD dwTotalTime = 0;

            if (!m_pbRunTest[i])
                continue;

            //Start the timer
            dwStartTime = timeGetTime();

            hrCall = RunTestCase(ptPerf8, m_pTestCases[i]);

            //Stop the timer.
            dwTotalTime = timeGetTime() - dwStartTime;

            ProcessTime(dwTotalTime, m_pTestCases[i].szTestName);
            
            
            if (S_FALSE == hrCall)
                hrCall = S_OK;
            if (SUCCEEDED(hrCall))
                m_dwPassed++;
            else
                m_dwFailed++;

            Wait(g_TestParams.dwWaitBetweenTests * 1000);
            //Take another reading of the current memory stats.
            if (!g_TestParams.bSuppressMemInfo)
            {
                GetMemoryStats(lCurrentMemoryArray, MAX_MEMORY_OBJECTS);
                CompareMemoryStats(lLastMemoryArray, lCurrentMemoryArray, MAX_MEMORY_OBJECTS, m_pTestCases[i].szTestName);
                DirectMusicMemDump(); 
                memcpy(lLastMemoryArray, lCurrentMemoryArray, sizeof(LONG) * MAX_MEMORY_OBJECTS);
            }
        }

    }
    while (g_TestParams.bStress);

    
    //Close down the performance.
    if (InitPerformanceOnce())
    {
        hr = ptPerf8->CloseDown();
        SAFE_RELEASE(ptPerf8);
    }

    //Shut down threads
    CHECKRUN(StopFileIOStressThreadProc());
    CHECKRUN(StopDoDMWorkThreadProc());

    
    //Release DSound
    RELEASE(pDSound);

    //Kill the D3D ::Logging to screen.
    CHECKRUN(LogFree());

    //Print and then Uninitialize our high-score table of the worst test times.
    CHECKRUN(PrintTimes());
    CHECKRUN(UnInitializeWorstTimes());


    //Release the wasted memory
    if (pMemory)
    {
        free(pMemory);
        pMemory = NULL;
    }

};





/********************************************************************************
********************************************************************************/
HRESULT SUITE::RunTestCase(CtIDirectMusicPerformance8 *ptPerf8_In, TESTCASE TestCase)
{
HRESULT hr = S_OK;
HRESULT hrTemp = S_OK;
CtIDirectMusicPerformance8 *ptPerf8 = NULL;

    //If a performance was passed in.
    if (InitPerformanceEveryTest())
    {
        ASSERT(!ptPerf8_In);
        hrTemp = CreateAndInitPerformance(&ptPerf8);
        if (FAILED(hrTemp))
            ::Log(ABORTLOGLEVEL, "CreateAndInitPerformance returned %s (%08X)", dmthXlatHRESULT(hrTemp), hrTemp);
    }
    else if (InitPerformanceOnce())
    {
        ASSERT(ptPerf8_In);
        ptPerf8 = ptPerf8_In;
    }
    //else if (InitPerformanceNever()) we'll expect the test to create the performance itself.  Only tests that expect this
    //  behavior should be run with this setting.

    
    //Call the test function and ::Log the result.
    SETLOG(g_hLog, "danhaff", "DMusic", "DMTest1", TestCase.szTestName);
    ::Log(1, "RUNNING %s", TestCase.szTestName);
    hr = TestCase.pTestProc(ptPerf8, TestCase.dwParam1, TestCase.dwParam2);
    if ( FAILED( hr ) )                                              
    {                                                                
        DbgPrint("%s returned %s (0x%x)\n", TestCase.szTestName, tdmXlatHRESULT(hr), hr );                
        xLog( g_hLog, XLL_FAIL, "%s returned %s (0x%x)\n", TestCase.szTestName, tdmXlatHRESULT(hr), hr );  
        ::Log(1, "FAIL: %s returned %s (0x%x)", TestCase.szTestName, tdmXlatHRESULT(hr), hr );  
        ::Log(1, "---------------------------------------------------------------------------");  
        ::Log(1, "");
    }                                                                
    else                                                             
    {                                                                
        
        xLog( g_hLog, XLL_PASS, "%s returned: %s (0x%x)\n", TestCase.szTestName, tdmXlatHRESULT(hr), hr );  
        ::Log(1, "PASS: %s returned %s (0x%x)", TestCase.szTestName, tdmXlatHRESULT(hr), hr );  
        ::Log(1, "---------------------------------------------------------------------------");  
        ::Log(1, "");
    }                                                                

    //If we initialized this, then close it down.
    if (InitPerformanceEveryTest())
    {
        hrTemp = S_OK;        
        hrTemp = ptPerf8->CloseDown();
        if (FAILED(hrTemp))
            ::Log(ABORTLOGLEVEL, "ERROR: CloseDown returned %s (%08X)", tdmXlatHRESULT(hrTemp), hrTemp);
        SAFE_RELEASE(ptPerf8);

    }
    else if (InitPerformanceOnce())
    {
        ASSERT(ptPerf8_In);
    }
    //else do nothing.

    return hr;

}


/********************************************************************************
********************************************************************************/
HRESULT SUITE::GetSuiteName(CHAR *pszSuiteName)
{
    strcpy(pszSuiteName, m_szSuiteName);
    return S_OK;
};


/********************************************************************************
********************************************************************************/
HRESULT SUITE::GetTestResults(DWORD *pdwPassed, DWORD *pdwFailed)
{
HRESULT hr = S_OK;
CHECK_SUITE_INITIALIZED

    if (pdwPassed)
        *pdwPassed = m_dwPassed;

    if (pdwFailed)
        *pdwFailed = m_dwFailed;

return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_Suite.h ===
#pragma once

#include "globals.h"
#include "help_testcases.h"


class SUITE
{   
public:
    SUITE(void);
    ~SUITE(void);
    HRESULT Init(LPCSTR cszSectionName, const TESTCASE *pTestCases, DWORD dwTestArraySize);
    HRESULT Load(void);
    void RunTestArray     (void);
    HRESULT SetTestParams (TESTPARAMS &TestParams);
    HRESULT GetTestParams (TESTPARAMS *pTestParams);
    HRESULT GetTestResults(DWORD *pdwPassed, DWORD *pdwFailed);
    HRESULT GetSuiteName  (CHAR *pszSuiteName);


private:

    //methods
    HRESULT Log                 (void);
    void EnableAllTestsOfType   (LPSTR szType);
    void AddOmitTestCase        (LPSTR szTestName, BOOL bAdd);
    HRESULT RunTestCase            (CtIDirectMusicPerformance8 *ptPerf8, TESTCASE TestCase);

    //variables
    BOOL m_bInitialized;
    TESTPARAMS m_TestParams;
    BOOL *m_pbRunTest;    
    
    CHAR m_szSuiteName[MAX_PATH];
    const TESTCASE *m_pTestCases;
    DWORD m_dwTestArraySize;
    SUITE *m_pSuite;

    DWORD m_dwPassed;
    DWORD m_dwFailed;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_SuiteList.cpp ===
#include "globals.h"
#include "help_suite.h"
#include "help_suitelist.h"

#define CHECK_SUITELIST_INITIALIZED {                                                       \
    if (!m_bInitialized)                                                                 \
    {                                                                                   \
        Log(ABORTLOGLEVEL, "%s, line %d: Init failed: SUITELIST %08X is not initialized (loaded)!", __FILE__, __LINE__, this);    \
        hr = E_FAIL;                                                                    \
    }                                                                                   \
}


/********************************************************************************
********************************************************************************/
SUITELIST::SUITELIST(void)
{
    m_bInitialized = FALSE;
    m_pSuite = NULL;
    memset(m_szAppName, 0, MAX_PATH);
    m_dwMaxSuites = 0;
};

/********************************************************************************
********************************************************************************/
SUITELIST::~SUITELIST(void)
{
    delete []m_pSuite;
    m_pSuite = NULL;
};




/********************************************************************************
Reads in and loads up a bunch of SUITEs, which will print out their own information.
********************************************************************************/
HRESULT SUITELIST::Load(LPCSTR cszAppName, const TESTCASE *pTestCases, DWORD dwTestArraySize)
{
    HRESULT hr = S_OK;
    LPCSTR cszSuites = "Suites";
    DWORD dwMax = 0;
    CHAR *szTemp = NULL;
    DWORD i = 0;

    CHAR *szFullSectionKey  = NULL;
    CHAR *szSectionData     = NULL;

    szFullSectionKey        = new CHAR[MAX_PATH];
    CHECKALLOC(szFullSectionKey);
    szSectionData           = new CHAR[MAX_PROFILESECTION_SIZE];
    CHECKALLOC(szSectionData   );

    if (SUCCEEDED(hr))
    {
        m_dwMaxSuites = 0;
        strncpy(m_szAppName, cszAppName, MAX_PATH -1);
    }

    //Load up the list of suites into szSectionData.
    if (SUCCEEDED(hr))
    {
        sprintf(szFullSectionKey, "%s_%s", cszAppName, cszSuites);
        dwMax = GetProfileSection(szFullSectionKey, szSectionData, MAX_PROFILESECTION_SIZE);
        if (dwMax == MAX_PROFILESECTION_SIZE  - 2)
        {
            Log(ABORTLOGLEVEL, "ERROR: Filled up entire %d characters, need to increase MAX_PROFILESECTION_SIZE ", MAX_PROFILESECTION_SIZE);
            hr = E_FAIL;
        }
    }

    //If we didn't find any suites under "DMTEST1_Suites" (or whatever the section key was) then we'll use "DMTEST1" for the suite area, and
    //  (therefore) "DMTest1_TestAdd"/"DMTest1_TestOmit" for the subarea.  This is to support the original bug files.
    if (SUCCEEDED(hr) && 0==dwMax)
    {
        sprintf(szSectionData, "%s", cszAppName);
        CHAR *szEnd = szSectionData;
        while (*szEnd)
            szEnd++;
        *(++szEnd) = NULL;
        dwMax = 1;
    }


    //Get all test cases and attempt to add them in.
    if (SUCCEEDED(hr))
    {
        szTemp = szSectionData;
        if (!szTemp[0])
        {
            Log(ABORTLOGLEVEL, "No Suites found in suite list [%s]", szFullSectionKey);
            hr = E_FAIL;
        }
    }
    
    //Count 'em
    if (SUCCEEDED(hr))
    {
        m_dwMaxSuites = 0;
        for (i=0;;i++)
        {
            if (szTemp[i]==0 && i)
                m_dwMaxSuites++;
            //break on \0\0
            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }

    //Allocate an array of suites.
    if (SUCCEEDED(hr))
    {
        m_pSuite = new SUITE[m_dwMaxSuites];
        if (!m_pSuite)
        {
            hr = E_FAIL;
        }
    }

    //Now load 'em into the array.
    if (SUCCEEDED(hr))
    {
        DWORD dwSuite = 0;
        CHAR *szLastString;
        szTemp = szSectionData;
        szLastString = szTemp;
        for (i=0; SUCCEEDED(hr);i++)
        {
            if (szTemp[i]==0 && i)
            {
                //The name of our test suite is in szLastString.  Initialize the suite with it.
                CHECKRUN(m_pSuite[dwSuite].Init(szLastString, pTestCases, dwTestArraySize));
                CHECKRUN(m_pSuite[dwSuite].Load());
                if (SUCCEEDED(hr))
                {
                    szLastString = &szTemp[i+1];
                    dwSuite++;
                }
            }

            //break on \0\0
            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_bInitialized = TRUE;
    }
    
    delete []szFullSectionKey;
    delete []szSectionData   ;

    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "Error: Could not load suite %s", cszAppName);
    }
    return hr;

};

/********************************************************************************
********************************************************************************/
HRESULT SUITELIST::RunSuites(DWORD *pdwPassed, DWORD *pdwFailed)
{  
HRESULT hr = S_OK;
DWORD i = 0;
DWORD dwPassed      = 0;
DWORD dwFailed      = 0;
DWORD dwPassedSuite = 0;
DWORD dwFailedSuite = 0;
CHAR szSuiteName[MAX_PATH] = {0};
CHECK_SUITELIST_INITIALIZED

    for (i=0; i<m_dwMaxSuites && SUCCEEDED(hr); i++)
    {
        dwPassedSuite = 0;
        dwFailedSuite = 0;
        ZeroMemory(szSuiteName, MAX_PATH);
        CHECKRUN(m_pSuite[i].GetSuiteName(szSuiteName));
        CHECK(m_pSuite[i].RunTestArray());
        CHECKRUN(m_pSuite[i].GetTestResults(&dwPassedSuite, &dwFailedSuite))
        if (SUCCEEDED(hr))
        {
            Log(ABORTLOGLEVEL, "SUITE: %s", szSuiteName);
            Log(ABORTLOGLEVEL, "---------------------------------------");
            Log(ABORTLOGLEVEL, "PASSED: %d", dwPassedSuite);
            Log(ABORTLOGLEVEL, "FAILED: %d", dwFailedSuite);
            Log(ABORTLOGLEVEL, "---------------------------------------");
            Log(ABORTLOGLEVEL, "");
            Log(ABORTLOGLEVEL, "");
        }
        else
        {
            Log(ABORTLOGLEVEL, "ERROR: Failed running suite #%d (%s)", i, szSuiteName);
        }
    }

    //Now that we're all done running the tests, print out the results again, this time in column form.
        Log(ABORTLOGLEVEL, "Suite                              Passed     Failed");
        Log(ABORTLOGLEVEL, "------------------------------     ------     ------");
        //                  30                            5    6     5    6       
    for (i=0; i<m_dwMaxSuites && SUCCEEDED(hr); i++)
    {
        CHECKRUN(m_pSuite[i].GetSuiteName(szSuiteName));
        CHECKRUN(m_pSuite[i].GetTestResults(&dwPassedSuite, &dwFailedSuite))
        Log(ABORTLOGLEVEL, "%-30s     %6u     %6u", szSuiteName, dwPassedSuite, dwFailedSuite);
        dwPassed += dwPassedSuite;
        dwFailed += dwFailedSuite;
    }

        Log(ABORTLOGLEVEL, "                                                    ");
        Log(ABORTLOGLEVEL, "TOTAL                              %6u     %6u", dwPassed, dwFailed);


    if (pdwPassed)
        *pdwPassed = dwPassed;
    if (pdwFailed)
        *pdwFailed = dwFailed;

    return hr;
};




/********************************************************************************
Purpose:
    Print warnings about potential problems across the suites.  i.e.
    1) There's no reason for suites to have different screen logging settings.
    2) A suite with stress mode on (making it loop forever) prevents subsequent suites from running.


TODO:

Note: This function is bad OOP design because it couples SUITELIST to the specific
      data parts of the SUITE object.  A better solution would be to either aggregate
      or contain (wrap) the SUITE object such that the user of SUITELIST would
      be required to process this information, not SUITELIST itself.  This change
      would also put the results printout code into the user of SUITELIST.
********************************************************************************/
HRESULT SUITELIST::CheckSuites(void)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    TESTPARAMS TestParams = {0};
    CHAR szSuiteName[MAX_PATH] = {0};
    BOOL bWarnings = FALSE;

    CHECK_SUITELIST_INITIALIZED 

    // 1) There's no reason for suites to have different screen logging settings.
    {
        BOOL bLogToScreen;
        CHAR szSuiteNameFirst[MAX_PATH] = {0};

        for (i=0; i<m_dwMaxSuites && SUCCEEDED(hr); i++)
        {        

            CHECKRUN(m_pSuite[i].GetTestParams(&TestParams));
            CHECKRUN(m_pSuite[i].GetSuiteName(szSuiteName));
            if (SUCCEEDED(hr))
            {
                if (0==i)
                {
                    bLogToScreen = TestParams.bLogToScreen;
                    CHECKRUN(m_pSuite[i].GetSuiteName(szSuiteNameFirst));
                }
                else
                {
                    if (TestParams.bLogToScreen != bLogToScreen)
                    {
                        Log(ABORTLOGLEVEL, "Error: Suite #%d (%s) has bLogToScreen = %s, but suite #%d (%s) has bLogToScreen = %s",
                                            0, szSuiteNameFirst, bLogToScreen ? "TRUE" : "FALSE",
                                            i, szSuiteName     , TestParams.bLogToScreen ? "TRUE" : "FALSE");
                        bWarnings = TRUE;
                    }

                }
            }
        }
    }

    // 2) A suite with stress mode on (making it loop forever) prevents subsequent suites from running.
    for (i=0; i<m_dwMaxSuites-1 && SUCCEEDED(hr); i++)
    {
        CHECKRUN(m_pSuite[i].GetTestParams(&TestParams));
        CHECKRUN(m_pSuite[i].GetSuiteName(szSuiteName));
        if (SUCCEEDED(hr))
        {
            if (TestParams.bStress)
            {
                Log(ABORTLOGLEVEL, "Error: Suite #%d (%s) has bStress = TRUE although suites follow it.", i, szSuiteName);
                bWarnings = TRUE;
            }
        }
    }

    if (bWarnings)
    {
        Log(ABORTLOGLEVEL,"");
        Log(ABORTLOGLEVEL,"");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_SuiteList.h ===
#pragma once
#include "globals.h"
#include "help_suite.h"
#include "help_testcases.h"

class SUITELIST
{
public:
    SUITELIST(void);
    ~SUITELIST(void);
    HRESULT Load(LPCSTR cszAppName, const TESTCASE *pTestCases, DWORD dwTestArraySize);
    HRESULT RunSuites(DWORD *pdwPassed, DWORD *pdwFailed);
    HRESULT CheckSuites(void);

private:
    SUITE *m_pSuite;
    BOOL m_bInitialized;
    CHAR m_szAppName[MAX_PATH];
    DWORD m_dwMaxSuites;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_TestCases.h ===
#pragma once

typedef HRESULT (*TESTPROC)(CtIDirectMusicPerformance*, DWORD, DWORD);

struct TESTCASE
{
    LPSTR szTestName;
    LPSTR szTestDesc;
    TESTPROC pTestProc;
    DWORD dwParam1;
    DWORD dwParam2;
};

extern const TESTCASE g_TestCases[];
extern DWORD g_dwNumTestCases;

HRESULT SanityCheckTestCases(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_WorstTimes.h ===
#include "globals.h"

//Basically a high score table of the longest tests to run.

HRESULT InitializeWorstTimes(void);
HRESULT UnInitializeWorstTimes(void);
HRESULT ProcessTime(DWORD dwTime, LPCSTR szTestName);
HRESULT PrintTimes(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_WorstTimes.cpp ===
#include "globals.h"

struct TIMINGMETRICS
{
CHAR szTestName[MAX_PATH];
DWORD dwTime;
};
#define MAXTIMINGMETRICS 10

TIMINGMETRICS *g_pTimingMetrics = NULL;
BOOL           g_bInitialized = FALSE;

/********************************************************************************
********************************************************************************/
HRESULT InitializeWorstTimes(void)
{
    HRESULT hr = S_OK;
    ASSERT(!g_bInitialized);
    //Allocate our set of timing metrics
    g_pTimingMetrics = new TIMINGMETRICS[MAXTIMINGMETRICS];
    CHECKALLOC(g_pTimingMetrics);
    if (SUCCEEDED(hr))
    {
        ZeroMemory(g_pTimingMetrics, sizeof(TIMINGMETRICS) * MAXTIMINGMETRICS);
        g_bInitialized = TRUE;
    }

    return hr;
}

/********************************************************************************
********************************************************************************/
HRESULT UnInitializeWorstTimes(void)
{
    HRESULT hr = S_OK;
    ASSERT(g_bInitialized);
    delete []g_pTimingMetrics;
    g_pTimingMetrics= NULL;
    g_bInitialized = FALSE;
    return hr;
}


/********************************************************************************
********************************************************************************/
//Do the "high score" thing.
//Element x is the lowest time (of the highs), Element 0 is the highest.
HRESULT ProcessTime(DWORD dwTime, LPCSTR szTestName)
{
    DWORD dwReplacingIndex = 0;
    DWORD dwScootingIndex = 0;
    BOOL bFound = FALSE;
    HRESULT hr = S_OK;

    ASSERT(g_bInitialized);

    //Start with the highest
    for (dwReplacingIndex =0; dwReplacingIndex < MAXTIMINGMETRICS; dwReplacingIndex++)
    {
        if (dwTime > g_pTimingMetrics[dwReplacingIndex].dwTime)
        {
            bFound = TRUE;
            break;
        }
    }

    //if we found one, replace it.
    if (bFound)
    {
        for (dwScootingIndex=MAXTIMINGMETRICS-1;  dwScootingIndex>dwReplacingIndex; dwScootingIndex--)
        {
            g_pTimingMetrics[dwScootingIndex] = g_pTimingMetrics[dwScootingIndex - 1];
        }

        g_pTimingMetrics[dwReplacingIndex].dwTime = dwTime;
        strncpy(g_pTimingMetrics[dwReplacingIndex].szTestName, szTestName, MAX_PATH);
    }
    return hr;
};
    


/********************************************************************************
********************************************************************************/
HRESULT PrintTimes(void)
{
    HRESULT hr = S_OK;
    ASSERT(g_bInitialized);

    Log(1, "Longest tests to run");
    Log(1, "--------------------");

    for (DWORD i=0; i<MAXTIMINGMETRICS; i++)
    {
        if (g_pTimingMetrics[i].dwTime)
        {
            Log(1, "%-60s:  %10ums", g_pTimingMetrics[i].szTestName, g_pTimingMetrics[i].dwTime); 
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_VerifyPath.cpp ===
#include "globals.h"
#include "Help_VerifyPath.h"
#include "Help_Definitions.h"

HRESULT VerifyAllBufferDMOs(BUFFER_DEFINITION *pBufferDef,
                            DWORD             dwBufferIndex,
                            DWORD             dwBufferStage,       //is this a MIXIN or SINKIN buffer.
                            CtIDirectMusicAudioPath *ptInterface,   //interfaces to obtain the DMO from.
                            IDirectSoundBuffer8 *pBuffer8);
HRESULT VerifyInvalidBufferMethods(IDirectSoundBuffer8 *pBuffer8);
HRESULT VerifyBufferData(BUFFER_DEFINITION *pBufferDef, IDirectSoundBuffer *pBuffer);
//HRESULT VerifyBufferData(BUFFER_DEFINITION *pBufferDef, IDirectSoundBuffer8 *pBuffer8);


LPSTR TypeOfDMO(IUnknown *pUnk);

/*
GUID *All_DMO_GUIDs[] = 
{
//(GUID *)&IID_IDirectSoundFXSend,
(GUID *)&IID_IDirectSoundFXGargle,
(GUID *)&IID_IDirectSoundFXChorus,
(GUID *)&IID_IDirectSoundFXFlanger,
(GUID *)&IID_IDirectSoundFXEcho,
(GUID *)&IID_IDirectSoundFXDistortion,
(GUID *)&IID_IDirectSoundFXCompressor, 
(GUID *)&IID_IDirectSoundFXParamEq,
(GUID *)&IID_IDirectSoundFXI3DL2Reverb,
(GUID *)&IID_IDirectSoundFXWavesReverb
};
*/

//DWORD gdw_All_DMO_GUIDs = AMOUNT(All_DMO_GUIDs);

                         
static DWORD g_dwValidStatusFlags =
    DSBSTATUS_LOOPING | DSBSTATUS_PLAYING;



/********************************************************************************
HISTORY:
    Created 04/12/00      danhaff

Description:
    Helper function to verify the absense of any DMOs at an SegState8's
    buffer/index.
********************************************************************************/
/*
HRESULT VerifyDMOAbsence(CtIDirectMusicSegmentState8 *ptSegState8, DWORD dwStage, DWORD dwBuffer, DWORD dwIndex)
{
    IUnknown *pUnkDMO = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;


    //Verify that no other DMOs are on this buffer.
    for (i=0; i<AMOUNT(All_DMO_GUIDs); i++)
    {

        hr = ptSegState8->GetObjectInPath(IgnorePChannel(dwStage),
                                          dwStage,
                                          dwBuffer,
                                          GUID_All_Objects,
                                          dwIndex,
                                          *(All_DMO_GUIDs[i]),
                                          (void **)&pUnkDMO);
        if (hr != DMUS_E_NOT_FOUND)
        {
            Log(ABORTLOGLEVEL, "This SegState8 has a %s DMO at dwStage %s, dwBuffer %d, dwIndex %d!!",
                                    dmthXlatGUID(*(All_DMO_GUIDs[i])),
                                    dmthXlatDMUS_STAGE(dwStage),
                                    dwBuffer,
                                    dwIndex);

            SAFE_RELEASE(pUnkDMO);
            hr = E_FAIL;
        }                   

    }

    SAFE_RELEASE(pUnkDMO);
    return hr;

};
*/

/********************************************************************************
HISTORY:
    Created 04/12/00      danhaff

Description:
    Helper function to verify the absense of any DMOs at an AudioPath's
    buffer/index.
********************************************************************************/
/*
HRESULT VerifyDMOAbsence(CtIDirectMusicAudioPath *ptAudioPath, DWORD dwStage, DWORD dwBuffer, DWORD dwIndex)
{
    IUnknown *pUnkDMO = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;


    //Verify that no other DMOs are on this buffer.
    for (i=0; i<AMOUNT(All_DMO_GUIDs); i++)
    {

        hr = ptAudioPath->GetObjectInPath(IgnorePChannel(dwStage),
                                          dwStage,
                                          dwBuffer,
                                          GUID_All_Objects,
                                          dwIndex,
                                         *(All_DMO_GUIDs[i]),
                                          (void **)&pUnkDMO);
        
        if (hr != DMUS_E_NOT_FOUND)
        {
            Log(ABORTLOGLEVEL, "This AudioPath has a %s DMO at dwStage %s, dwBuffer %d, dwIndex %d!!",
                                    dmthXlatGUID(*(All_DMO_GUIDs[i])),
                                    dmthXlatDMUS_STAGE(dwStage),
                                    dwBuffer,
                                    dwIndex);

            SAFE_RELEASE(pUnkDMO);
            hr = E_FAIL;
        }                   

    }

    SAFE_RELEASE(pUnkDMO);
    return hr;

};

*/
/********************************************************************************
HELPER FUNCTION

HISTORY:
    Created 04/13/00      danhaff

DESCRIPTION:
    Given a BUFFER_DESCRIPTION, this method catches stupid mistakes have been made
    in its creation and describes the location of those mistakes.  This prevents the
    actual verification function (VerifyPathDefaults) from mistakenly passing (our worst fear).
    
    Note: this does NOT verify DMO data.  It would be possible but would take a while,
    and any invalid data would cause VerifyPathDefaults to fail anyway, attracting attention.
********************************************************************************/
HRESULT SanityCheckBufferDef(BUFFER_DEFINITION *pBufferDef)
{
    HRESULT hr                  = S_OK;
//    DWORD dwCapFlagUsage[32]    = {0};
//    DWORD dwCapFlagValue        = 0;
    DWORD dwStatusFlagUsage[32] = {0};
    DWORD dwStatusFlagValue     = 0;
    DWORD dwDMOIndex            = 0;   
    DWORD i                     = 0;
    DWORD j                     = 0;

    //Sanity check the StatusFlags passed in.
    //Count how many times each StatusFlag is used, store in the dwStatusFlagUsage array.
    for (i=0; i<3; i++)
        for (j=0; j<32; j++)
        {
            dwStatusFlagValue = 1 << j;
            if (pBufferDef->dwStatusFlags[i] & dwStatusFlagValue)
                dwStatusFlagUsage[j]++;
        }

    //Check each of the valid StatusFlags and make sure they're only used once.
    //We won't let people leave out a StatusFlag, and we won't let people specify a StatusFlag
    //in two different sections.  This verifies they didn't screw up majorly.
    for (j=0; j<32; j++)
    {
        dwStatusFlagValue = 1 << j;

        //If this is a valid flag, it should be used exactly once.
        if (dwStatusFlagValue & g_dwValidStatusFlags)
        {
            if (0 == dwStatusFlagUsage[j])
            {
                Log(ABORTLOGLEVEL, "TEST APP ERROR: The following flag was not specified in our buffer definition.");
                //Log_DSBStatus(ABORTLOGLEVEL, dwStatusFlagValue);
                Log(ABORTLOGLEVEL, "%08X", dwStatusFlagValue);
                hr = E_FAIL;
            }

            if (dwStatusFlagUsage[j] >= 2)
            {
                Log(ABORTLOGLEVEL, "TEST APP ERROR: The following flag was specified more than once in our buffer definition.");
                //Log_DSBStatus(ABORTLOGLEVEL, dwStatusFlagValue);
                Log(ABORTLOGLEVEL, "%08X", dwStatusFlagValue);
                hr = E_FAIL;
            }
        }
        //If this is NOT a valid flag, it shouldn't be used at all.
        else
        {
            if (0 != dwStatusFlagUsage[j])
            {
                Log(ABORTLOGLEVEL, "TEST APP ERROR: The following flag is invalid but specified in our buffer definition anyway: %08X", dwStatusFlagValue);
                hr = E_FAIL;
            }
        }
    }


    //Make sure you have DMOs if you say you do.
    if (pBufferDef->dwDMOs != 0&& pBufferDef->pDMOs == NULL)
    {
        Log(ABORTLOGLEVEL, "TEST APP ERROR: Even though your DMO count is %d, your DMO pointer is NULL", pBufferDef->dwDMOs);
        hr = E_FAIL;
    }

    
    //Sanity check all the DMOs.
/*BUGBUG: Put this back in later!
    for (dwDMOIndex = 0; dwDMOIndex < pBufferDef->dwDMOs; dwDMOIndex++)
    {
        //Make sure the specified DMO matches one of the known DMO GUIDs.
        BOOL bFound = FALSE;
        for (i=0; i<gdw_All_DMO_GUIDs; i++)
        {
            if (memcmp((void *)pBufferDef->pDMOs[dwDMOIndex].refguidDMO, (void *)All_DMO_GUIDs[i], sizeof(GUID)) == 0)
            {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound)
        {
            Log(ABORTLOGLEVEL, "TEST APP ERROR: Buffer DMO #%d's GUID is not recognized", dwDMOIndex);
            hr = E_FAIL;
        }

        //Make sure you have data to check against.
        if (NULL == pBufferDef->pDMOs[dwDMOIndex].pvDMOParams)
        {
            Log(ABORTLOGLEVEL, "TEST APP ERROR: Buffer DMO #%d's data ptr is NULL", dwDMOIndex);
            hr = E_FAIL;
        }
    }
  */  

return hr;
};


/********************************************************************************
HELPER FUNCTION for many many Test Case Functions

HISTORY:
    Created 04/13/00      danhaff

DESCRIPTION:
    This mammoth function takes an "active" AudioPath (AP) or SegmentState (SS) 
    interface and compares it with a PATH_DEFINITION structure to make sure everything's
    in the "path" interface (AP or SS) that should be, and nothing's in the path
    that shouldn't be.  It spews everything that's wrong with the path using
    FNS_ABORTLOGLEVEL and of course returns E_FAIL or S_OK depending on the
    results.

    This interface (AP or SS) MUST have been obtained from a CICMusic class.  This
    guarantees that everything is set up correctly and looping.    
********************************************************************************/
HRESULT VerifyPathData(PATH_DEFINITION *pDef, CtIDirectMusicAudioPath *ptInterface)
{
    //State of the test.
    HRESULT                     hr                  = S_OK;
    BOOL                        bPassing            = TRUE;

    //Which actual buffer we're checking.
    DWORD                       dwBufferIndex       = 0;

    //Interfaces we pick up along the way.
    IDirectSoundBuffer8 *       pBuffer8            = NULL;    //The Buffer interface we use to obtain data from.


    //For both SINKIN and MIXIN buffers, we set this data according to which type we're using.
    DWORD                       dwBufferTypeIndex   = 0;       //Only used for iterating through SINKIN/MIXIN buffers.  Either 0 or 1.
    DWORD                       dwBufferDefs        = 0;       //Number of buffer definitions of this type.
    BUFFER_DEFINITION *         pBufferDefs         = NULL;    //All the buffer definitions of this type.
    DWORD                       dwBufferStage       = 0;       //which stage do we GOIP with. Either DMUS_PATH_BUFFER or DMUS_PATH_MIXIN_BUFFER

    //Temporary data storage.
//    DS3DBUFFER                  ds3dBuffer          = {0};      //Used to store 3D data for comparision with that in the BufferDef.
//    DS3DLISTENER                ds3dListener        = {0};      //Used to store 3D data for comparision with that in the default Listener struct.
    
    //We must do the same for both SINKIN and MIXIN buffers.
    for (dwBufferTypeIndex = 0; dwBufferTypeIndex < 1; dwBufferTypeIndex ++)
    {
        
        //Simply point us to the correct data, since we must do the
        //  same thing twice, once for MIXIN buffers and once for SINKIN
        //  buffers.
        if (0 == dwBufferTypeIndex)
        {
            dwBufferDefs  = pDef->dwSinkinBuffers;
            pBufferDefs   = pDef->pSinkinBuffers;
            dwBufferStage = DMUS_PATH_BUFFER;
            Log(ABORTLOGLEVEL, "Checking Sinkin Buffers", dwBufferIndex);
            Log(ABORTLOGLEVEL, "***********************", dwBufferIndex);

        }
/*        else if (1 == dwBufferTypeIndex)
        {
            dwBufferDefs  = pDef->dwMixinBuffers;
            pBufferDefs   = pDef->pMixinBuffers;
            dwBufferStage = DMUS_PATH_MIXIN_BUFFER;
            Log(ABORTLOGLEVEL, "Checking Mixin Buffers");
            Log(ABORTLOGLEVEL, "**********************");

        }*/
        else 
            ASSERT(FALSE);

        //For each buffer...
        for (dwBufferIndex=0; dwBufferIndex < dwBufferDefs; dwBufferIndex++)
        {


            //Make sure the "buffer definition" struct we're checking against isn't bogus in some way.
            hr = SanityCheckBufferDef(&pBufferDefs[dwBufferIndex]);
            if (S_OK != hr)
            {
                Log(ABORTLOGLEVEL, "TEST APP ERROR: Buffer Definition %d failed sanity check!!!", dwBufferIndex + 1);
                bPassing = FALSE;
                goto TEST_END;
            }


            //Obtain the buffer at this index from the AudioPath / SegmentState.
            hr = ptInterface->GetObjectInPath(IgnorePChannel(dwBufferStage), //dwPChannel
                                              dwBufferStage,                 //dwStage
                                              dwBufferIndex,                 //dwBuffer
                                              GUID_All_Objects,              //guidObject
                                              0,                             //dwIndex
                                              GUID_NULL,                     //pIID
                                              (void **)&pBuffer8);  
            //We demand full success.
            if (S_OK != hr)
            {
                Log(ABORTLOGLEVEL, "ERROR: %s->GetObjectInPath for buffer %d/%d returned (%s == %08Xh)",
                                        ptInterface->m_szInterfaceName,
                                        dwBufferIndex + 1,
                                        dwBufferDefs,
                                        tdmXlatHRESULT(hr),
                                        hr);
                bPassing = FALSE;
            }

            //If this call succeeded then scrutinize the buffer.
            //if (bPassing)
            if (SUCCEEDED(hr))
            {
                Log(ABORTLOGLEVEL, "-------------- Verifying buffer %d ----------------", dwBufferIndex + 1);

                hr = VerifyBufferData(&pBufferDefs[dwBufferIndex], pBuffer8);
                if (S_OK != hr)
                {
                    Log(ABORTLOGLEVEL, "ERROR! Buffer %d failed verification!!!", dwBufferIndex + 1);
                    bPassing = FALSE;
                }

                //Release our regular buffer.
                SAFE_RELEASE(pBuffer8);
                Log(ABORTLOGLEVEL, "-------------- End verifying buffer %d ----------------", dwBufferIndex + 1);
            }//END: if (pBuffer8)
        }//END: for all buffers.


        //Now that we're done testing all the valid buffers, attempt to obtain the first INVALID 
        //  buffer and verify that it is absent.
        hr = ptInterface->GetObjectInPath(IgnorePChannel(dwBufferStage), //dwPChannel
                                          dwBufferStage,             //dwStage
                                          dwBufferDefs,              //the Max of the buffers.
                                          GUID_All_Objects,          //guidObject
                                          0,                         //dwIndex
                                          GUID_NULL,                //iidInterface
                                          (void **)&pBuffer8);          
        if (DMUS_E_NOT_FOUND != hr)
        {
            Log(ABORTLOGLEVEL, "ERROR: %s->GetObjectInPath for first invalid %s buffer (#%d) returned (%s == %08Xh) instead of DMUS_E_NOT_FOUND",
                                    ptInterface->m_szInterfaceName,
                                    0 ==dwBufferTypeIndex  ? "SINKIN" : "MIXIN",
                                    dwBufferDefs + 1,
                                    tdmXlatHRESULT(hr),
                                    hr);
            bPassing = FALSE;
            SAFE_RELEASE(pBuffer8);
        };
    }//END: for both SINKIN and MIXIN buffers.



TEST_END:
    
    //Free the good stuff.
    SAFE_RELEASE(pBuffer8);

    if (bPassing)
        return S_OK;
    else
        return E_FAIL;    
};





/********************************************************************************
HELPER FUNCTION

HISTORY:
    Created 04/14/00      danhaff

DESCRIPTION:
    This function takes an IDirectSoundBuffer8 and compares it with a
    BUFFER_DEFINITION structure to make sure everything's correct.

NOTES:
    This does NOT verify a buffer's DMOs, or 3D data.  Only data obtainable
    through the buffer interface do we verify.
********************************************************************************/
HRESULT VerifyBufferData(BUFFER_DEFINITION *pBufferDef, IDirectSoundBuffer8 *pBuffer8)
{

    //BUGBUG: 
    return S_OK;

/*
    //Properties of the buffer we're checking.
    DWORD                       dwFormatSize        = 0;
    LPWAVEFORMATEX              pWfx                = NULL;
    DWORD                       dwBufferStatus      = 0;
    DWORD                       dwFrequency         = 0;
    LONG                        lVolume             = 0;
    LONG                        lPan                = 0;
    DWORD                       dwDsfxResult        = 0;
    DWORD                       dwStatusFlags       = 0;        //Buffer status flags.
    BOOL                        bPassing            = TRUE;
    HRESULT                     hr                  = E_FAIL;
    DWORD                       j                   = 0;        //Used for indexing 
    DWORD                       dwFlagValue         = 0;        //Used to store the single value of a flag as we're indexing through.
//    DWORD dwChannelVolumes[]                        = {SPEAKER_FRONT_LEFT};
    LONG plVolume                                   = 0;
//    DSEFFECTDESC dsfx                               = {0};      //In-param for SetFx() test.
    DWORD                       *pdwDSFXResult      = NULL;

    

    hr = pBuffer8->GetStatus(&dwStatusFlags);
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL, "ERROR: IDirectSoundBuffer8->GetStatus returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        bPassing = FALSE;
        goto TEST_END;
    }

    //Verify the STATUS flags.
    for (j=0; j<32; j++)
    {
        dwFlagValue = 1 << j;

        //If this is a wanted flag, verify it's there.
        if (dwFlagValue & pBufferDef->dwStatusFlags[0])
        {
            if (!(dwStatusFlags & dwFlagValue))
            {
                Log(ABORTLOGLEVEL, "ERROR: The following flag is missing from IDirectSoundBuffer8's status");
                //Log_DSBStatus(ABORTLOGLEVEL, dwFlagValue);
                Log(ABORTLOGLEVEL, "%08X", dwFlagValue);
                bPassing = FALSE;
            }
        }

        //If this is an unwanted flag, verify it's NOT there.
        if (dwFlagValue & pBufferDef->dwStatusFlags[1])
        {
            if (dwStatusFlags & dwFlagValue)
            {
                Log(ABORTLOGLEVEL, "ERROR: The following flag is present in IDirectSoundBuffer8's status");
                //Log_DSBStatus(ABORTLOGLEVEL, dwFlagValue);
                Log(ABORTLOGLEVEL, "%08X", dwFlagValue);
                bPassing = FALSE;
            }
        }
    }

    

TEST_END:


    if (pWfx)
    {
        LocalFree(pWfx);
        pWfx = NULL;
    }

    if (pdwDSFXResult)
    {
        LocalFree(pdwDSFXResult);
        pdwDSFXResult= NULL;
    }

    if (bPassing)
        return S_OK;
    else
        return E_FAIL;
*/
}






/********************************************************************************
HELPER
VerifyBufferDMOs

HISTORY:
    Created 04/14/00      danhaff

DESCRIPTION:
    Given a buffer and its description, verify that it has the correct set of
    DMOs in it.
********************************************************************************/
/*
HRESULT VerifyAllBufferDMOs(BUFFER_DEFINITION *pBufferDef,
                            DWORD             dwBufferIndex,
                            DWORD             dwBufferStage,       //is this a MIXIN or SINKIN buffer.
                            CtIDirectMusicAudioPath *ptInterface,   //interfaces to obtain the DMO from.
                            IDirectSoundBuffer8 *pBuffer8)
{
    BOOL bPassing = TRUE;
    HRESULT hr = S_OK;
    DWORD dwDMOStage = 0;
    DWORD dwDMOIndex = 0;
    DWORD dwDMOQIMethod = 0;
    IUnknown *pUnkDMO = NULL;

    //Set the DMO stage correctly.
    if (DMUS_PATH_BUFFER == dwBufferStage)
        dwDMOStage = DMUS_PATH_BUFFER_DMO;
    else if (DMUS_PATH_MIXIN_BUFFER == dwBufferStage)
        dwDMOStage = DMUS_PATH_MIXIN_BUFFER_DMO;

    for (dwDMOIndex = 0; dwDMOIndex < pBufferDef->dwDMOs; dwDMOIndex++)
    {
        for (dwDMOQIMethod = 0; dwDMOQIMethod < 2; dwDMOQIMethod ++)
        {
        
            ///////////////// GET THE DMO as an IUnknown ////////////////////
            if (0 == dwDMOQIMethod)
            {
                hr = pBuffer8->GetObjectInPath(GUID_All_Objects,
                                          dwDMOIndex,
                                          IID_IUnknown,
                                          (void **)&pUnkDMO);
                if (hr != S_OK)
                {
                    Log(ABORTLOGLEVEL, "ERROR: IDirectSoundBuffer->GetObjectInPath for DMO #%d (%s) returned (%s == %08Xh) instead of S_OK",
                                           dwDMOIndex + 1,
                                           dmthXlatGUID(*pBufferDef->pDMOs[dwDMOIndex].refguidDMO),
                                           tdmXlatHRESULT(hr),
                                           hr);
                    bPassing = FALSE;
                }
                
            }
            else
            {
                hr = ptInterface->GetObjectInPath(IgnorePChannel(dwDMOStage),//dwPChannel
                                                  dwDMOStage,                //dwStage
                                                  dwBufferIndex,             //Which buffer we're on.
                                                  GUID_All_Objects,          //guidObject
                                                  dwDMOIndex,                //Max of the DMOs.
                                                  IID_IUnknown,              //iidInterface
                                                  (void **)&pUnkDMO);
                if (hr != S_OK)
                {
                    Log(ABORTLOGLEVEL, "ERROR: %s->GetObjectInPath for DMO #%d (%s) returned (%s == %08Xh) instead of S_OK",
                                           ptInterface->m_szInterfaceName,
                                           dwDMOIndex + 1,
                                           dmthXlatGUID(*pBufferDef->pDMOs[dwDMOIndex].refguidDMO),
                                           tdmXlatHRESULT(hr),
                                           hr);
                    bPassing = FALSE;
                }    

            }

            //If that call actually returned something, we'll check it out.
            if (pUnkDMO)            
            {
                hr = VerifyDMOData(&pBufferDef->pDMOs[dwDMOIndex], pUnkDMO);
                if (S_OK != hr)
                {
                    Log(ABORTLOGLEVEL, "ERROR: Buffer %d's DMO %d had incorrect parameters.", dwBufferIndex + 1, dwDMOIndex + 1);
                    bPassing = FALSE;
                    SAFE_RELEASE(pUnkDMO);
                }

                SAFE_RELEASE(pUnkDMO);
            }
        }//END: for both QI methods.
    }//END: for all DMOs in the buffer.


    DWORD dwTemp = DMUS_E_NOT_FOUND;
    DWORD dwTemp2 = DSERR_OBJECTNOTFOUND;
    ///////////////// Verify Non-existent DMOs don't exist ////////////////////
    //Attempt to obtain the DMOs both ways; verify they fail..
    hr = pBuffer8->GetObjectInPath(GUID_All_Objects,
                                   pBufferDef->dwDMOs,
                                   IID_IUnknown,
                                   (void **)&pUnkDMO);
    if (hr != DMUS_E_NOT_FOUND)
    {
        Log(ABORTLOGLEVEL, "ERROR: IDirectSoundBuffer(#%d)->GetObjectInPath for IUnk from nonexistent DMO #%d returned (%s == %08Xh) instead of DMUS_E_NOT_FOUND",
                               dwBufferIndex + 1,            
                               pBufferDef->dwDMOs + 1,
                               tdmXlatHRESULT(hr),
                               hr);
        bPassing = FALSE;
    }

    SAFE_RELEASE(pUnkDMO);


    hr = ptInterface->GetObjectInPath(IgnorePChannel(dwDMOStage),//dwPChannel
                                      dwDMOStage,                //dwStage
                                      dwBufferIndex,             //Which buffer we're on.
                                      GUID_All_Objects,          //guidObject
                                      pBufferDef->dwDMOs,         //Max of the DMOs.
                                      IID_IUnknown,              //iidInterface
                                      (void **)&pUnkDMO);
    if (hr != DMUS_E_NOT_FOUND)
    {
        Log(ABORTLOGLEVEL, "ERROR: %s->GetObjectInPath for IUnk from buffer %d's nonexistent DMO #%d returned (%s == %08Xh) instead of DMUS_E_NOT_FOUND",
                               ptInterface->m_szInterfaceName,
                               dwBufferIndex + 1,
                               pBufferDef->dwDMOs + 1,
                               tdmXlatHRESULT(hr),
                               hr);
        bPassing = FALSE;
    }
    SAFE_RELEASE(pUnkDMO);


    if (bPassing)
        return S_OK;
    else
        return E_FAIL;
};

*/


/********************************************************************************
HELPER
VerifyDMOData

HISTORY:
    Created 04/14/00      danhaff

DESCRIPTION:
    Given a DMO and its description, verify that it has the correct parameters.
********************************************************************************/
/*
HRESULT VerifyDMOData(DMO_DEFINITION *pDMO, IUnknown *pUnk)
{
//IDirectSoundFXSend              *pSend          = NULL;
IDirectSoundFXGargle            *pGargle        = NULL;
IDirectSoundFXChorus            *pChorus        = NULL; 
IDirectSoundFXFlanger           *pFlanger       = NULL;
IDirectSoundFXEcho              *pEcho          = NULL; 
IDirectSoundFXDistortion        *pDistortion    = NULL;
IDirectSoundFXCompressor        *pCompressor    = NULL;
IDirectSoundFXParamEq           *pParamEq       = NULL;
IDirectSoundFXI3DL2Reverb       *pReverb        = NULL;
IDirectSoundFXWavesReverb       *pWavesReverb   = NULL;


//DSFXSend                        SendParams;
DSFXGargle                      GargleParams;
DSFXChorus                      ChorusParams;
DSFXFlanger                     FlangerParams;
DSFXEcho                        EchoParams;
DSFXDistortion                  DistortionParams;
DSFXCompressor                  CompressorParams;
DSFXParamEq                     ParamEqParams;
DSFXI3DL2Reverb                ReverbParams;
DSFXWavesReverb                WavesReverbParams;

HRESULT                         hr              = S_OK;
BOOL                            bPassing        = TRUE;
BOOL                            bEqual          = 0;

//We gotta make sure we have the correct type of DMO before getting parameters from it.

//Obtain the correct interface.

//if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    hr = pUnk->QueryInterface(IID_IDirectSoundFXSend, (void **)&pSend);
//else
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXGargle, (void **)&pGargle);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXFlanger, (void **)&pFlanger);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXChorus, (void **)&pChorus);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXEcho, (void **)&pEcho);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXDistortion, (void **)&pDistortion);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXCompressor, (void **)&pCompressor);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXParamEq, (void **)&pParamEq);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXI3DL2Reverb, (void **)&pReverb);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    hr = pUnk->QueryInterface(IID_IDirectSoundFXWavesReverb, (void **)&pWavesReverb);
else
{

    //Okay, if it's a send then we're not gonna be able to query ANY of these interfaces.  However, we'll
    //  know this because we passed in the GUID IID_SendPlaceHolder.  Bail here; there's no more
    //  checking to do.
    if (memcmp((void *)pDMO->refguidDMO, (void *)&GUID_SendPlaceholder, sizeof(GUID))==0)
    {
        Log(FYILOGLEVEL, "VerifyDMOData was passed a DMO from which no FX could be QI'd.  However, this is a Send, hence it's expected. Returning S_OK.");
        return S_OK;    
    }

    //If we're not expecting this, then fail the call.
    Log(ABORTLOGLEVEL, "TEST APP ERROR: trying to test params on unsupported DMO %s", dmthXlatGUID(*pDMO->refguidDMO));
    bPassing = FALSE;
    goto TEST_END;
}


if (S_OK != hr)
{
    Log(ABORTLOGLEVEL, "ERROR: IUnknown->QueryInterface for %s returned (%s == %08Xh)", dmthXlatGUID(*pDMO->refguidDMO), tdmXlatHRESULT(hr), hr);
    Log(ABORTLOGLEVEL, "       The DMO is a %s instead.", TypeOfDMO(pUnk));
    bPassing = FALSE;
    goto TEST_END;
};

//Get the correct parameters.
//if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    hr = pSend->GetAllParameters(&SendParams);
//else
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    hr = pGargle->GetAllParameters(&GargleParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    hr = pFlanger->GetAllParameters(&FlangerParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    hr = pChorus->GetAllParameters(&ChorusParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    hr = pEcho->GetAllParameters(&EchoParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    hr = pDistortion->GetAllParameters(&DistortionParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    hr = pCompressor->GetAllParameters(&CompressorParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    hr = pParamEq->GetAllParameters(&ParamEqParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    hr = pReverb->GetAllParameters(&ReverbParams);
else if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    hr = pWavesReverb->GetAllParameters(&WavesReverbParams);
else
{
    Log(ABORTLOGLEVEL, "TEST APP ERROR, trying to test params on unsupported DMO %s", dmthXlatGUID(*pDMO->refguidDMO));
    bPassing = FALSE;
    goto TEST_END;
}
if (S_OK != hr)
{
    Log(ABORTLOGLEVEL, "ERROR: %s->GetAllParameters for returned (%s == %08Xh)", dmthXlatGUID(*pDMO->refguidDMO), tdmXlatHRESULT(hr), hr);
    bPassing = FALSE;
    goto TEST_END;
};


//Log the parameters.
//if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    Log_Send_Params(FYILOGLEVEL, &SendParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    Log_Gargle_Params(FYILOGLEVEL, &GargleParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    Log_Flanger_Params(FYILOGLEVEL, &FlangerParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    Log_Chorus_Params(FYILOGLEVEL, &ChorusParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    Log_Echo_Params(FYILOGLEVEL, &EchoParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    Log_Distortion_Params(FYILOGLEVEL, &DistortionParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    Log_Compressor_Params(FYILOGLEVEL, &CompressorParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    Log_ParamEq_Params(FYILOGLEVEL, &ParamEqParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    Log_I3DL2Reverb_Params(FYILOGLEVEL, &ReverbParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    Log_WavesReverb_Params(FYILOGLEVEL, &WavesReverbParams);

//Compare the parameters.
//if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    bEqual = Equal_Send_Params((DSFXSend *)pDMO->pvDMOParams, &SendParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    bEqual = Equal_Gargle_Params((DSFXGargle *)pDMO->pvDMOParams, &GargleParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    bEqual = Equal_Flanger_Params((DSFXFlanger *)pDMO->pvDMOParams, &FlangerParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    bEqual = Equal_Chorus_Params((DSFXChorus *)pDMO->pvDMOParams, &ChorusParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    bEqual = Equal_Echo_Params((DSFXEcho *)pDMO->pvDMOParams, &EchoParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    bEqual = Equal_Distortion_Params((DSFXDistortion *)pDMO->pvDMOParams, &DistortionParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    bEqual = Equal_Compressor_Params((DSFXCompressor *)pDMO->pvDMOParams, &CompressorParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    bEqual = Equal_ParamEq_Params((DSFXParamEq *)pDMO->pvDMOParams, &ParamEqParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    bEqual = Equal_I3DL2Reverb_Params((DSFXI3DL2Reverb *)pDMO->pvDMOParams, &ReverbParams);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    bEqual = Equal_WavesReverb_Params((DSFXWavesReverb *)pDMO->pvDMOParams, &WavesReverbParams);
if (!bEqual)
{
    Log(ABORTLOGLEVEL, "ERROR: %s's parameters were incorrect (see returned, followed by expected)", dmthXlatGUID(*pDMO->refguidDMO));
    bPassing = FALSE;


//    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    {
//        Log(ABORTLOGLEVEL, "--- RETURNED -----");
//        Log_Send_Params(ABORTLOGLEVEL, &SendParams);
//        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
//        Log_Send_Params(ABORTLOGLEVEL, (DSFXSend *)pDMO->pvDMOParams);
//    }

    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Gargle_Params(ABORTLOGLEVEL, &GargleParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Gargle_Params(ABORTLOGLEVEL, (DSFXGargle *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Flanger_Params(ABORTLOGLEVEL, &FlangerParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Flanger_Params(ABORTLOGLEVEL, (DSFXFlanger *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Chorus_Params(ABORTLOGLEVEL, &ChorusParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Chorus_Params(ABORTLOGLEVEL, (DSFXChorus *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Echo_Params(ABORTLOGLEVEL, &EchoParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Echo_Params(ABORTLOGLEVEL, (DSFXEcho *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Distortion_Params(ABORTLOGLEVEL, &DistortionParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Distortion_Params(ABORTLOGLEVEL, (DSFXDistortion *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_Compressor_Params(ABORTLOGLEVEL, &CompressorParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_Compressor_Params(ABORTLOGLEVEL, (DSFXCompressor *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_ParamEq_Params(ABORTLOGLEVEL, &ParamEqParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_ParamEq_Params(ABORTLOGLEVEL, (DSFXParamEq *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_I3DL2Reverb_Params(ABORTLOGLEVEL, &ReverbParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_I3DL2Reverb_Params(ABORTLOGLEVEL, (DSFXI3DL2Reverb *)pDMO->pvDMOParams);
    }
    if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    {
        Log(ABORTLOGLEVEL, "--- RETURNED -----");
        Log_WavesReverb_Params(ABORTLOGLEVEL, &WavesReverbParams);
        Log(ABORTLOGLEVEL, "--- EXPECTED -----");
        Log_WavesReverb_Params(ABORTLOGLEVEL, (DSFXWavesReverb *)pDMO->pvDMOParams);
    }

    goto TEST_END;
}



TEST_END:

//Release the new interface.
//if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXSend, sizeof(GUID)) == 0)
//    SAFE_RELEASE(pSend);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXGargle, sizeof(GUID)) == 0)
    SAFE_RELEASE(pGargle);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXFlanger, sizeof(GUID)) == 0)
    SAFE_RELEASE(pFlanger);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXChorus, sizeof(GUID)) == 0)
    SAFE_RELEASE(pChorus);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXEcho, sizeof(GUID)) == 0)
    SAFE_RELEASE(pEcho);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXDistortion, sizeof(GUID)) == 0)
    SAFE_RELEASE(pDistortion);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXCompressor, sizeof(GUID)) == 0)
    SAFE_RELEASE(pCompressor);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXParamEq, sizeof(GUID)) == 0)
    SAFE_RELEASE(pParamEq);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXI3DL2Reverb, sizeof(GUID)) == 0)
    SAFE_RELEASE(pReverb);
if (memcmp((void **)pDMO->refguidDMO, (void **)&IID_IDirectSoundFXWavesReverb, sizeof(GUID)) == 0)
    SAFE_RELEASE(pWavesReverb);

if (bPassing)
    return S_OK;
else
    return S_FALSE;

};





char *TypeOfDMO(IUnknown *pUnk)
{
    DWORD i = 0;
    void *pv = NULL;

    for (i=0; i<gdw_All_DMO_GUIDs; i++)
    {
        HRESULT hr;
         hr = pUnk->QueryInterface(*All_DMO_GUIDs[i], &pv);
         if (SUCCEEDED(hr))
         {            
            ((IUnknown *)pv)->Release();
            return dmthXlatGUID(*All_DMO_GUIDs[i]);
         }
    }

    return "Unknown GUID";
};


*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_VerifyPath.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//--------------------------------------------------------------------------

#pragma once


HRESULT Verify3DDefaults(DS3DBUFFER *pParams);
//HRESULT VerifyListenerDefaults(DS3DLISTENER* pParams);
//HRESULT VerifyPrimaryBufferDefaults(IDirectSoundBuffer8 *pBuffer8);
//HRESULT VerifySecondaryBufferDefaults(DSBCAPS *pDSBCaps);

//HRESULT Verify_IDirectSoundFXWavesReverb_Defaults(DSFXWavesReverb *pReverbParams);


//Helpers to verify that no DMOs exist at a certain place in the audiopath.
HRESULT VerifyDMOAbsence(CtIDirectMusicSegmentState8 *ptSegState8,
                         DWORD dwStage,
                         DWORD dwBuffer,
                         DWORD dwIndex);
HRESULT VerifyDMOAbsence(CtIDirectMusicAudioPath *ptAudioPath,
                         DWORD dwStage,
                         DWORD dwBuffer,
                         DWORD dwIndex);
HRESULT VerifyDMOAbsence(IDirectSoundBuffer8 * pBuffer8,
                         DWORD dwIndex);

//A nice array of all the DMO GUIDs.  Used to loop through to verify that no DMOs exist
//  where they're not supposed to be.
//GUID *All_DMO_GUIDs[]={};
extern DWORD gdw_All_DMO_GUIDs;


///----------------------------- DEFINING AN AUDIOPATH -------------------------------
//A BUFFER_DEFINITION includes a list of DMO definitions, and optionally a 3D Buffer definition.
//A DMO_DEFINITION includes the DMO's GUID and a ptr to its expected params.

/********************************************************************************
DMO_DEFINITION: Lists the type and parameters of a DMO.
********************************************************************************/
struct DMO_DEFINITION
{
    GUID *refguidDMO;                           //IID of the DMO
    void *pvDMOParams;                          //Expected params of the DMO.
};


/********************************************************************************
BUFFER_DEFINITION: A complete definition of what properties a buffer should and
                   shouldn't have.
********************************************************************************/
struct BUFFER_DEFINITION
{
    DWORD               dwStatusFlags[3];   //    "wanted," "notwanted," and "dontcare."
                                            //    The "CapFlags" are those of the buffer,
                                            //    while the "StatusFlags" show the buffer's
                                            //    playing state.  All flags must be specified
                                            //    in exactly one set.  See examples.

    DWORD               dwDMOs;             //How many DMOs we expect.
    DMO_DEFINITION *    pDMOs;              //Definitions of expected DMOs.
};

/********************************************************************************
PATH_DEFINITION: A complete definition of what should and shouldn't be in an
                 audiopath.

                Includes 2 lists of BUFFER_DEFINITIONs, one for SINKIN buffers
                and one for MIXIN buffers.  These 2 types of buffers are
                mutually exclusive (i.e. you can never get a certain buffer by
                specifying the other type of flag)
********************************************************************************/
struct PATH_DEFINITION
{
    DWORD               dwSinkinBuffers;    //How many SINKIN BUFFERs we expect.
    BUFFER_DEFINITION * pSinkinBuffers;     //Definitions for SINKIN buffers.
    DWORD               dwMixinBuffers;     //How many MIXIN BUFFERs we expect.
    BUFFER_DEFINITION*  pMixinBuffers;      //Definitions for MIXIN buffers.
};


HRESULT SanityCheckBufferDef(BUFFER_DEFINITION *pBufferDef);
HRESULT VerifyPathData      (PATH_DEFINITION    *pDef,       CtIDirectMusicAudioPath *ptInterface);
//HRESULT VerifyBufferData    (BUFFER_DEFINITION  *pBufferDef, IDirectSoundBuffer8     *pBuffer8);
HRESULT VerifyBufferData    (BUFFER_DEFINITION  *pBufferDef, IDirectSoundBuffer      *pBuffer);
HRESULT VerifyDMOData       (DMO_DEFINITION     *pDMO,       IUnknown                *pUnk);


// {60383005-A25F-425b-A6FD-6DAEB0F4D222}
//lint -e14
DEFINE_GUID(GUID_SendPlaceholder, 0x60383005, 0xa25f, 0x425b, 0xa6, 0xfd, 0x6d, 0xae, 0xb0, 0xf4, 0xd2, 0x22);
//lint +e14
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Help_TestCases.cpp ===
#include "globals.h"
#include "help_testcases.h"
#include "help_definitions.h"
#include "tests.h"

static REFERENCE_TIME rt0           = 0;
static REFERENCE_TIME rt1           = 1;
static REFERENCE_TIME rt10000       = 10000;
static REFERENCE_TIME rt7770000     = 7770000;
static REFERENCE_TIME rt1000000     = 1000000;
static REFERENCE_TIME rt10000000    = 10000000;
static REFERENCE_TIME rt100000000    = 100000000;
static REFERENCE_TIME rt599990000   = 599990000;
static REFERENCE_TIME rt999990000   = 999990000;
static REFERENCE_TIME rt599999990000 = 599999990000;
static REFERENCE_TIME rt0x7FFFFFFFFFFFFFFF = 0x7FFFFFFFFFFFFFFF;
static REFERENCE_TIME rt208         = 208;
static REFERENCE_TIME rt833         = 833;
static REFERENCE_TIME rt1041        = 1041;

const TESTCASE g_TestCases[] =
{
/******************************************************************************************
BVTTEST CASES
******************************************************************************************/

    //AudioPath Tests
    //------------------
    {"AudioPath_Activate_BVT"               ,"BVT", AudioPath_Activate_BVT,    0, 0},
    {"AudioPath_GetObjectInPath_BVT"   ,     "BVT", AudioPath_GetObjectInPath_BVT, 0, 0},
    {"AudioPath_SetVolume_BVT",              "BVT", AudioPath_SetVolume_BVT, 0, 0},
    {"AudioPath_SetPitch_BVT",               "BVT", AudioPath_SetPitch_BVT, 0, 0},

    //Loader Tests
    //------------
    {"Loader_ClearCache_BVT"            ,     "BVT", Loader_ClearCache_BVT, 0, 0},
    {"Loader_LoadObjectFromFile_BVT"    ,     "BVT", Loader_LoadObjectFromFile_BVT , 0, 0},
    {"Loader_GetObject_BVT"             ,     "BVT", Loader_GetObject_BVT , 0, 0},
    {"Loader_SetObject_BVT"             ,     "BVT", Loader_SetObject_BVT, 0, 0},
    {"Loader_SetSearchDirectory_BVT"    ,     "BVT", Loader_SetSearchDirectory_BVT , 0, 0},
    {"Loader_ReleaseObjectByUnknown_BVT",     "BVT", Loader_ReleaseObjectByUnknown_BVT, 0, 0},

    //Performance8 Tests
    //------------------
    {"Performance8_AddNotificationType_BVT",  "BVT" , Performance8_AddNotificationType_BVT, 0, 0},           //PASS
    {"Performance8_AllocPMsg_BVT",            "BVT" , Performance8_AllocPMsg_BVT, 0, 0},                     //PASS
    {"Performance8_ClonePMsg_BVT",            "BVT" , Performance8_ClonePMsg_BVT, 0, 0},                     //PASS
    {"Performance8_CreateStandardAudioPath_BVT","BVT",Performance8_CreateStandardAudioPath_BVT, 0, 0},      //PASS
    {"Performance8_FreePMsg_BVT",             "BVT" , Performance8_FreePMsg_BVT, 0, 0},                      //PASS 
    {"Performance8_GetGlobalParam_BVT",       "BVT" , Performance8_GetGlobalParam_BVT, 0, 0},                //PASS
    {"Performance8_GetNotificationPMsg_BVT",  "BVT" , Performance8_GetNotificationPMsg_BVT, 0, 0},           //PASS   
    {"Performance8_GetSegmentState_BVT",      "BVT" , Performance8_GetSegmentState_BVT, 0, 0},               //PASS
    {"Performance8_GetSetDefaultAudioPath_BVT","BVT",Performance8_GetSetDefaultAudioPath_BVT, 0, 0},        //PASS

    {"Performance8_GetTime_BVT_ReferenceTime", "BVT" , Performance8_GetTime_BVT_ReferenceTime, 5, 0},                       //PASS
    {"Performance8_GetTime_BVT_MusicTime",     "BVT" , Performance8_GetTime_BVT_MusicTime,     5, 0},                       //PASS


    {"Performance8_InitAudio_BVT",            "BVT" , Performance8_InitAudio_BVT, 0, 0},                     //PASS
    {"Performance8_IsPlaying_BVT",            "BVT" , Performance8_IsPlaying_BVT, 0, 0},                     //PASS
    {"Performance8_MusicToReferenceTime_BVT", "BVT" , Performance8_MusicToReferenceTime_BVT, 0, 0},          //PASS
    {"Performance8_PlaySegmentEx_BVT",        "BVT" , Performance8_PlaySegmentEx_BVT, 0, 0},                 //FAILS 3807, 3841 (listening)
    {"Performance8_ReferenceToMusicTime_BVT", "BVT" , Performance8_ReferenceToMusicTime_BVT, 0, 0},          //PASS
    {"Performance8_RemoveNotificationType_BVT","BVT" , Performance8_RemoveNotificationType_BVT, 0, 0},      //Not implemented yet (partly covered in Add)
    {"Performance8_SendPMsg_BVT",             "BVT" , Performance8_SendPMsg_BVT, 0, 0},                      //FAILS 2968 (listening)
    {"Performance8_SetGlobalParam_BVT",       "BVT" , Performance8_SetGlobalParam_BVT, 0, 0},                //PASS
    {"Performance8_StopEx_BVT",               "BVT" , Performance8_StopEx_BVT, 0, 0},                        //PASS   

    //Segment8 Tests
    //--------------
    {"Segment8_Compose_BVT",                  "BVT" , Segment8_Compose_BVT, 0, 0},    //PASS
//    {"Segment8_Download_BVT",                 "BVT" , Segment8_Download_BVT, 0, 0},   //PASS
    {"Segment8_SetRepeats_BVT",               "BVT" , Segment8_SetRepeats_BVT, 0, 0}, //PASS
    {"Segment8_GetLength_BVT",                "BVT" , Segment8_GetLength_BVT , 0, 0}, //PASS
    {"Segment8_SetLength_BVT",                "BVT" , Segment8_SetLength_BVT , 0, 0}, //PASS

    //SegmentState8 Tests
    //-------------------
    {"SegmentState_GetObjectInPath_BVT",      "BVT" , SegmentState_GetObjectInPath_BVT, 0, 0},   //PASS
    {"SegmentState_GetSegment_BVT",           "BVT" , SegmentState_GetSegment_BVT, 0, 0},        //PASS   
    {"SegmentState_GetStartTime_BVT",         "BVT" , SegmentState_GetStartTime_BVT, 0, 0},      //???
    {"SegmentState_SetPitch_BVT",             "BVT" , SegmentState_SetPitch_BVT, 0, 0},          //FAIL: 3514 (Listening)
    {"SegmentState_SetVolume_BVT",            "BVT" , SegmentState_SetVolume_BVT, 0, 0},         //Same as above.

    //ToolGraph tests
    //---------------
    {"ToolGraph_InsertTool_BVT",              "BVT" , ToolGraph_InsertTool_BVT, 0, 0},   
    {"ToolGraph_StampPMsg_BVT",               "BVT" , ToolGraph_StampPMsg_BVT, 0, 0},
    {"ToolGraph_RemoveTool_BVT",              "BVT" , ToolGraph_RemoveTool_BVT, 0, 0},
    {"ToolGraph_GetTool_BVT",                 "BVT" , ToolGraph_GetTool_BVT, 0, 0},


/******************************************************************************************
VALID TEST CASES
******************************************************************************************/

    {"ADPCM_OneShot_11_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_11_1"},
    {"ADPCM_OneShot_11_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_11_2"},
    {"ADPCM_OneShot_22_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_22_1"},
    {"ADPCM_OneShot_22_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_22_2"},
    {"ADPCM_OneShot_44_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_44_1"},
    {"ADPCM_OneShot_44_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"OneShot", (DWORD)"OS_44_2"},

    {"ADPCM_Looping_11_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_11_1"},
    {"ADPCM_Looping_11_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_11_2"},
    {"ADPCM_Looping_22_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_22_1"},
    {"ADPCM_Looping_22_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_22_2"},
    {"ADPCM_Looping_44_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_44_1"},
    {"ADPCM_Looping_44_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Looping64", (DWORD)"LP_44_2"},

    {"ADPCM_Streaming_11_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_11_1"},
    {"ADPCM_Streaming_11_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_11_2"},
    {"ADPCM_Streaming_22_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_22_1"},
    {"ADPCM_Streaming_22_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_22_2"},
    {"ADPCM_Streaming_44_1",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_44_1"},
    {"ADPCM_Streaming_44_2",  "Valid", ADPCM_TestWaveSegment, (DWORD)"Streaming", (DWORD)"ST_44_2"},


    //TODO: Run these tests.
    {"ADPCM_DLS_Looping_11_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_LP_11_1.sgt"},
    {"ADPCM_DLS_Looping_22_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_LP_22_1.sgt"},
    {"ADPCM_DLS_Looping_44_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_LP_44_1.sgt"},
    {"ADPCM_DLS_OneShot_11_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_OS_11_1.sgt"},
    {"ADPCM_DLS_OneShot_22_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_OS_22_1.sgt"},
    {"ADPCM_DLS_OneShot_44_1",    "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_OS_44_1.sgt"},
    {"ADPCM_DLS_Streaming_11_1",  "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_ST_11_1.sgt"},
    {"ADPCM_DLS_Streaming_22_1",  "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_ST_22_1.sgt"},
    {"ADPCM_DLS_Streaming_44_1",  "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegDLS_ADPCM_ST_44_1.sgt"},

    {"ADPCM_WaveSeg_Looping_11_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_11_1.sgt"},
    {"ADPCM_WaveSeg_Looping_11_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_11_2.sgt"},
    {"ADPCM_WaveSeg_Looping_22_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_22_1.sgt"},
    {"ADPCM_WaveSeg_Looping_22_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_22_2.sgt"},
    {"ADPCM_WaveSeg_Looping_44_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_44_1.sgt"},
    {"ADPCM_WaveSeg_Looping_44_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_LP_44_2.sgt"},
    {"ADPCM_WaveSeg_OneShot_11_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_11_1.sgt"},
    {"ADPCM_WaveSeg_OneShot_11_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_11_2.sgt"},
    {"ADPCM_WaveSeg_OneShot_22_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_22_1.sgt"},
    {"ADPCM_WaveSeg_OneShot_22_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_22_2.sgt"},
    {"ADPCM_WaveSeg_OneShot_44_1",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_44_1.sgt"},
    {"ADPCM_WaveSeg_OneShot_44_2",     "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_OS_44_2.sgt"},
    {"ADPCM_WaveSeg_Streaming_11_1",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_11_1.sgt"},
    {"ADPCM_WaveSeg_Streaming_11_2",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_11_2.sgt"},
    {"ADPCM_WaveSeg_Streaming_22_1",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_22_1.sgt"},
    {"ADPCM_WaveSeg_Streaming_22_2",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_22_2.sgt"},
    {"ADPCM_WaveSeg_Streaming_44_1",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_44_1.sgt"},
    {"ADPCM_WaveSeg_Streaming_44_2",   "Valid",  ADPCM_TestMusicSegment, NULL, (DWORD)"SegWAV_ADPCM_ST_44_2.sgt"},


    //Audiopath Tests
    //---------------
    {"AudioPath_Activate_Valid_Many(STEREOPLUSREVERB,191)",  "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_SHARED_STEREOPLUSREVERB, 191},
    {"AudioPath_Activate_Valid_Many(STEREO,191)",            "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_SHARED_STEREO,           191},
    {"AudioPath_Activate_Valid_Many(3D,64)",                 "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_3D,              64},
    {"AudioPath_Activate_Valid_Many(MONO,191)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            191},

    {"AudioPath_Activate_Valid_Many(MONO,32)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            32},
    {"AudioPath_Activate_Valid_Many(MONO,64)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            64},
    {"AudioPath_Activate_Valid_Many(MONO,128)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            128},
    {"AudioPath_Activate_Valid_Many(MONO,150)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            150},
    {"AudioPath_Activate_Valid_Many(MONO,160)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            160},

//    {"AudioPath_Activate_Valid_Many(MONO,191)",              "Valid", AudioPath_Activate_Valid_Many,  DMUS_APATH_DYNAMIC_MONO,            136},


    {"AudioPath_Activate_Valid_Sharing_Shared",      "Valid", AudioPath_Activate_Valid_Sharing,  TRUE, 0},
    {"AudioPath_Activate_Valid_Sharing_Unshared",    "Valid", AudioPath_Activate_Valid_Sharing,  FALSE, 0},
    {"AudioPath_Activate_Valid_OnAndOff",            "Valid", AudioPath_Activate_Valid_OnAndOff, 0, 0},

    {"AudioPath_GetObjectInPath_Valid_GetAll",       "Valid", AudioPath_GetObjectInPath_Valid_GetAll, 0, 0},

    {"AudioPath_GetObjectInPath_Valid_Traverse(STEREOPLUSREVERB)",     "Valid", AudioPath_GetObjectInPath_Valid_Traverse, DMUS_APATH_SHARED_STEREOPLUSREVERB, (DWORD)&g_DefaultPathStereoPlusReverb},
    {"AudioPath_GetObjectInPath_Valid_Traverse(MONO)",     "Valid", AudioPath_GetObjectInPath_Valid_Traverse, DMUS_APATH_DYNAMIC_MONO,          (DWORD)&g_DefaultPathMono},
    {"AudioPath_GetObjectInPath_Valid_Traverse(STEREO)",   "Valid", AudioPath_GetObjectInPath_Valid_Traverse, DMUS_APATH_SHARED_STEREO,         (DWORD)&g_DefaultPathStereo},
    {"AudioPath_GetObjectInPath_Valid_Traverse(3D)",     "Valid", AudioPath_GetObjectInPath_Valid_Traverse, DMUS_APATH_DYNAMIC_3D,              (DWORD)&g_DefaultPath3D},

    {"AudioPath_GetObjectInPath_Valid_SimplyGetBuffer","Valid", AudioPath_GetObjectInPath_Valid_SimplyGetBuffer, 0, 0},


    //Audiopath tests - BUFFERS
    //---------------------------
    {"AudioPath_GetObjectInPath_3DBuf_SetAllParameters(3D)",             "Valid", AudioPath_GetObjectInPath_3DBuf_SetAllParameters,          DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetConeAngles(3D)",                "Valid", AudioPath_GetObjectInPath_3DBuf_SetConeAngles,             DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases(3D)","Valid", AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_Listening(3D)", "Valid", AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_Listening, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetConeOutsideVolume(3D)",         "Valid", AudioPath_GetObjectInPath_3DBuf_SetConeOutsideVolume,      DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases(3D)", "Valid", AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource(3D)",  "Valid", AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases(3D)", "Valid", AudioPath_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetMinDistance_Listening(3D)",     "Valid", AudioPath_GetObjectInPath_3DBuf_SetMinDistance_Listening,  DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetMode(3D)",                      "Valid", AudioPath_GetObjectInPath_3DBuf_SetMode,                   DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetPosition_BoundaryCases(3D)",    "Valid", AudioPath_GetObjectInPath_3DBuf_SetPosition_BoundaryCases, DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetPosition_Listening(3D)",        "Valid", AudioPath_GetObjectInPath_3DBuf_SetPosition_Listening,     DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetVelocity(3D)",                  "Valid", AudioPath_GetObjectInPath_3DBuf_SetVelocity,               DMUS_APATH_DYNAMIC_3D, 0},
//    {"AudioPath_GetObjectInPath_3DBuf_Test_INFINITY_Bug(3D)",            "Valid", AudioPath_GetObjectInPath_3DBuf_INFINITY_Bug,              DMUS_APATH_DYNAMIC_3D, 0},

    {"AudioPath_GetObjectInPath_3DBuf_SetFrequency_Listening",         "Valid", AudioPath_GetObjectInPath_3DBuf_SetFrequency_Listening,      DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetFrequency_Range",             "Valid", AudioPath_GetObjectInPath_3DBuf_SetFrequency_Range,          DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetVolume_Listening",            "Valid", AudioPath_GetObjectInPath_3DBuf_SetVolume_Listening,         DMUS_APATH_DYNAMIC_3D, 0},
    {"AudioPath_GetObjectInPath_3DBuf_SetVolume_Range",                "Valid", AudioPath_GetObjectInPath_3DBuf_SetVolume_Range,             DMUS_APATH_DYNAMIC_3D, 0},

    {"AudioPath_GetObjectInPath_MonoBuf_SetFrequency_Listening",         "Valid", AudioPath_GetObjectInPath_3DBuf_SetFrequency_Listening,  DMUS_APATH_DYNAMIC_MONO, 0},
    {"AudioPath_GetObjectInPath_MonoBuf_SetFrequency_Range",             "Valid", AudioPath_GetObjectInPath_3DBuf_SetFrequency_Range,      DMUS_APATH_DYNAMIC_MONO, 0},
    {"AudioPath_GetObjectInPath_MonoBuf_SetVolume_Listening",            "Valid", AudioPath_GetObjectInPath_3DBuf_SetVolume_Listening,     DMUS_APATH_DYNAMIC_MONO, 0},
    {"AudioPath_GetObjectInPath_MonoBuf_SetVolume_Range",                "Valid", AudioPath_GetObjectInPath_3DBuf_SetVolume_Range,         DMUS_APATH_DYNAMIC_MONO, 0},



//    {"AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Channel_Listening","Valid", AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Channel_Listening, DMUS_APATH_DYNAMIC_3D, 0},
//    {"AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Mask_Listening","Valid",  AudioPath_GetObjectInPath_3DBuf_SetChannelVolume_Mask_Listening, DMUS_APATH_DYNAMIC_3D, 0},



    {"AudioPath_SetVolume_Valid_Ramp_0ms",            "Valid", AudioPath_SetVolume_Valid_Ramp, 0,            DMUS_APATH_DYNAMIC_MONO},
    {"AudioPath_SetVolume_Valid_Ramp_1ms",            "Valid", AudioPath_SetVolume_Valid_Ramp, 1,            DMUS_APATH_DYNAMIC_MONO},
    {"AudioPath_SetVolume_Valid_Ramp_1000ms",         "Valid", AudioPath_SetVolume_Valid_Ramp, 1000,         DMUS_APATH_DYNAMIC_MONO},
    {"AudioPath_SetVolume_Valid_Ramp_10000ms",        "Valid", AudioPath_SetVolume_Valid_Ramp, 10000,        DMUS_APATH_DYNAMIC_MONO},
    {"AudioPath_SetVolume_Valid_Ramp_ULONG_MAXms",    "Valid", AudioPath_SetVolume_Valid_Ramp, ULONG_MAX,    DMUS_APATH_DYNAMIC_MONO},
    {"AudioPath_SetVolume_Valid_Ramp_0ms_STEREOPLUSREVERB",            "Valid", AudioPath_SetVolume_Valid_Ramp, 0,            DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"AudioPath_SetVolume_Valid_Ramp_1ms_STEREOPLUSREVERB",            "Valid", AudioPath_SetVolume_Valid_Ramp, 1,            DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"AudioPath_SetVolume_Valid_Ramp_1000ms_STEREOPLUSREVERB",         "Valid", AudioPath_SetVolume_Valid_Ramp, 1000,         DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"AudioPath_SetVolume_Valid_Ramp_10000ms_STEREOPLUSREVERB",        "Valid", AudioPath_SetVolume_Valid_Ramp, 10000,        DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"AudioPath_SetVolume_Valid_Ramp_ULONG_MAXms_STEREOPLUSREVERB",    "Valid", AudioPath_SetVolume_Valid_Ramp, ULONG_MAX,    DMUS_APATH_SHARED_STEREOPLUSREVERB},

    {"AudioPath_SetPitch_Valid_Immediate",           "Valid", AudioPath_SetPitch_Valid_Immediate, 0, 0},
    {"AudioPath_SetPitch_Valid_Ramp_0ms(listen)",    "Valid", AudioPath_SetPitch_Valid_Ramp, 0,      2400},
    {"AudioPath_SetPitch_Valid_Ramp_1000ms(listen)", "Valid", AudioPath_SetPitch_Valid_Ramp, 1000,   2400},
    {"AudioPath_SetPitch_Valid_Ramp_10000ms(listen)","Valid", AudioPath_SetPitch_Valid_Ramp, 10000,  2400},

    {"AudioPath_SetVolume_Valid_Ind(DLS,DYNAMIC)",           "Valid", AudioPath_SetVolume_Valid_Ind, FALSE,  FALSE},
    {"AudioPath_SetVolume_Valid_Ind(WAVE,DYNAMIC)",          "Valid", AudioPath_SetVolume_Valid_Ind, TRUE,   FALSE},
    {"AudioPath_SetVolume_Valid_Ind(DLS,SHARED)",            "Valid", AudioPath_SetVolume_Valid_Ind, FALSE,  TRUE},
    {"AudioPath_SetVolume_Valid_Ind(WAVE,SHARED)",           "Valid", AudioPath_SetVolume_Valid_Ind, TRUE,   TRUE},
    


    //DLS Tests
    //---------     
     //Volume
     {"DLS_TestSegment(0000_Attack_00s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0000_Attack_00s.sgt", 0},
     {"DLS_TestSegment(0001_Attack_01s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0001_Attack_01s.sgt", 0},
     {"DLS_TestSegment(0002_Attack_05s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0002_Attack_05s.sgt", 0},
     {"DLS_TestSegment(0003_Attack_40s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0003_Attack_40s.sgt", 0},
     {"DLS_TestSegment(0010_Decay_00s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0010_Decay_00s.sgt", 0},
     {"DLS_TestSegment(0011_Decay_01s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0011_Decay_01s.sgt", 0},
     {"DLS_TestSegment(0012_Decay_05s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0012_Decay_05s.sgt", 0},
     {"DLS_TestSegment(0013_Decay_40s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0013_Decay_40s.sgt", 0},
     {"DLS_TestSegment(0020_Hold_00s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0020_Hold_00s.sgt", 0},
     {"DLS_TestSegment(0021_Hold_01s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0021_Hold_01s.sgt", 0},
     {"DLS_TestSegment(0022_Hold_05s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0022_Hold_05s.sgt", 0},
     {"DLS_TestSegment(0023_Hold_40s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0023_Hold_40s.sgt", 0},
     {"DLS_TestSegment(0031_Release_01s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0031_Release_01s.sgt", 0},
     {"DLS_TestSegment(0032_Release_05s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0032_Release_05s.sgt", 0},
     {"DLS_TestSegment(0033_Release_40s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0033_Release_40s.sgt", 0},
     {"DLS_TestSegment(0040_Sustain_000)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0040_Sustain_000.sgt", 0},
     {"DLS_TestSegment(0041_Sustain_050)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0041_Sustain_050.sgt", 0},
     {"DLS_TestSegment(0042_Sustain_085)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0042_Sustain_085.sgt", 0},
     {"DLS_TestSegment(0043_Sustain_100)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0043_Sustain_100.sgt", 0},
     {"DLS_TestSegment(0050_Pan_Left_50)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0050_Pan_Left_50.sgt", 0},
     {"DLS_TestSegment(0051_Pan_Left_25)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0051_Pan_Left_25.sgt", 0},
     {"DLS_TestSegment(0052_Pan_Mid)",     "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0052_Pan_Mid.sgt", 0},
     {"DLS_TestSegment(0053_Pan_Right_25)","Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0053_Pan_Right_25.sgt", 0},
     {"DLS_TestSegment(0054_Pan_Right_50)","Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Volume/0054_Pan_Right_50.sgt", 0},

     //Pitch
     {"DLS_TestSegment(0100_Attack_00s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0100_Attack_00s.sgt", 0},
     {"DLS_TestSegment(0101_Attack_01s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0101_Attack_01s.sgt", 0},
     {"DLS_TestSegment(0102_Attack_05s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0102_Attack_05s.sgt", 0},
     {"DLS_TestSegment(0103_Attack_40s)",  "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0103_Attack_40s.sgt", 0},
     {"DLS_TestSegment(0110_Decay_00s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0110_Decay_00s.sgt", 0},
     {"DLS_TestSegment(0111_Decay_01s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0111_Decay_01s.sgt", 0},
     {"DLS_TestSegment(0112_Decay_05s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0112_Decay_05s.sgt", 0},
     {"DLS_TestSegment(0113_Decay_40s)",   "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0113_Decay_40s.sgt", 0},
     {"DLS_TestSegment(0120_Hold_00s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0120_Hold_00s.sgt", 0},
     {"DLS_TestSegment(0121_Hold_01s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0121_Hold_01s.sgt", 0},
     {"DLS_TestSegment(0122_Hold_05s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0122_Hold_05s.sgt", 0},
     {"DLS_TestSegment(0123_Hold_40s)",    "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0123_Hold_40s.sgt", 0},
     {"DLS_TestSegment(0130_Release_00s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0130_Release_00s.sgt", 0},
     {"DLS_TestSegment(0131_Release_01s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0131_Release_01s.sgt", 0},
     {"DLS_TestSegment(0132_Release_05s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0132_Release_05s.sgt", 0},
     {"DLS_TestSegment(0133_Release_40s)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0133_Release_40s.sgt", 0},
     {"DLS_TestSegment(0140_Sustain_000)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0140_Sustain_000.sgt", 0},
     {"DLS_TestSegment(0141_Sustain_050)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0141_Sustain_050.sgt", 0},
     {"DLS_TestSegment(0142_Sustain_085)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0142_Sustain_085.sgt", 0},
     {"DLS_TestSegment(0143_Sustain_100)", "Valid",  DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0143_Sustain_100.sgt", 0},
     {"DLS_TestSegment(0150_Range_-01)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0150_Range_-01.sgt", 0},
     {"DLS_TestSegment(0151_Range_-12)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0151_Range_-12.sgt", 0},
     {"DLS_TestSegment(0152_Range_01)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0152_Range_01.sgt", 0},
     {"DLS_TestSegment(0153_Range_12)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Pitch/0153_Range_12.sgt", 0},


    //Mod LFO
     {"DLS_TestSegment(0200_ChanPressToFc_00000)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0200_ChanPressToFc_00000.sgt", 0},
     {"DLS_TestSegment(0200_ChanPressToFc_12800)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0200_ChanPressToFc_12800.sgt", 0},
     {"DLS_TestSegment(0200_ChanPressToFc_-12800)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0200_ChanPressToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0210_ChanPressToGain_00db)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0210_ChanPressToGain_00db.sgt", 0},
     {"DLS_TestSegment(0211_ChanPressToGain_12db)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0211_ChanPressToGain_12db.sgt", 0},
     {"DLS_TestSegment(0220_ChanPressToPitch_-06)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0220_ChanPressToPitch_-06.sgt", 0},
     {"DLS_TestSegment(0221_ChanPressToPitch_-12)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0221_ChanPressToPitch_-12.sgt", 0},
     {"DLS_TestSegment(0222_ChanPressToPitch_00)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0222_ChanPressToPitch_00.sgt", 0},
     {"DLS_TestSegment(0223_ChanPressToPitch_06)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0223_ChanPressToPitch_06.sgt", 0},
     {"DLS_TestSegment(0224_ChanPressToPitch_12)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0224_ChanPressToPitch_12.sgt", 0},
     {"DLS_TestSegment(0230_Delay00s)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0230_Delay00s.sgt", 0},
     {"DLS_TestSegment(0231_Delay01s)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0231_Delay01s.sgt", 0},
     {"DLS_TestSegment(0232_Delay05s)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0232_Delay05s.sgt", 0},
     {"DLS_TestSegment(0233_Delay10s)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0233_Delay10s.sgt", 0},
     {"DLS_TestSegment(0240_Frequency_01Hz)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0240_Frequency_01Hz.sgt", 0},
     {"DLS_TestSegment(0241_Frequency_05Hz)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0241_Frequency_05Hz.sgt", 0},
     {"DLS_TestSegment(0242_Frequency_0p1Hz)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0242_Frequency_0p1Hz.sgt", 0},
     {"DLS_TestSegment(0242_Frequency_10Hz)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0242_Frequency_10Hz.sgt", 0},
     {"DLS_TestSegment(0250_MWToPitch_-12)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0250_MWToPitch_-12.sgt", 0},
     {"DLS_TestSegment(0251_MWToPitch_12)",         "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0251_MWToPitch_12.sgt", 0},
     {"DLS_TestSegment(0260_MWToVolume_12)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0260_MWToVolume_12.sgt", 0},
     {"DLS_TestSegment(0270_PitchRange_-01)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0270_PitchRange_-01.sgt", 0},
     {"DLS_TestSegment(0271_PitchRange_-12)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0271_PitchRange_-12.sgt", 0},
     {"DLS_TestSegment(0272_PitchRange_00)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0272_PitchRange_00.sgt", 0},
     {"DLS_TestSegment(0273_PitchRange_01)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0273_PitchRange_01.sgt", 0},
     {"DLS_TestSegment(0274_PitchRange_12)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0274_PitchRange_12.sgt", 0},
     {"DLS_TestSegment(0280_VolRange_00db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0280_VolRange_00db.sgt", 0},
     {"DLS_TestSegment(0281_VolRange_01db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0281_VolRange_01db.sgt", 0},
     {"DLS_TestSegment(0282_VolRange_05db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0282_VolRange_05db.sgt", 0},
     {"DLS_TestSegment(0283_VolRange_12db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/ModLFO/0283_VolRange_12db.sgt", 0},

    //Vib LFO
     {"DLS_TestSegment(0300_ChanPressToPitch_00)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0300_ChanPressToPitch_00.sgt", 0},
     {"DLS_TestSegment(0301_ChanPressToPitch_-06)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0301_ChanPressToPitch_-06.sgt", 0},
     {"DLS_TestSegment(0302_ChanPressToPitch_06)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0302_ChanPressToPitch_06.sgt", 0},
     {"DLS_TestSegment(0303_ChanPressToPitch_-12)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0303_ChanPressToPitch_-12.sgt", 0},
     {"DLS_TestSegment(0304_ChanPressToPitch_12)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0304_ChanPressToPitch_12.sgt", 0},
     {"DLS_TestSegment(0310_Delay_00s)",           "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0310_Delay_00s.sgt", 0},
     {"DLS_TestSegment(0311_Delay_01s)",           "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0311_Delay_01s.sgt", 0},
     {"DLS_TestSegment(0312_Delay_05s)",           "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0312_Delay_05s.sgt", 0},
     {"DLS_TestSegment(0313_Delay_10s)",           "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0313_Delay_10s.sgt", 0},
     {"DLS_TestSegment(0320_Frequency_0p01)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0320_Frequency_0p01.sgt", 0},
     {"DLS_TestSegment(0321_Frequency_01)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0321_Frequency_01.sgt", 0},
     {"DLS_TestSegment(0322_Frequency_05)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0322_Frequency_05.sgt", 0},
     {"DLS_TestSegment(0323_Frequency_10)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0323_Frequency_10.sgt", 0},
     {"DLS_TestSegment(0324_Frequency_20)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0324_Frequency_20.sgt", 0},
     {"DLS_TestSegment(0330_MWToPitch_00)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0330_MWToPitch_00.sgt", 0},
     {"DLS_TestSegment(0331_MWToPitch_-06)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0331_MWToPitch_-06.sgt", 0},
     {"DLS_TestSegment(0332_MWToPitch_06)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0332_MWToPitch_06.sgt", 0},
     {"DLS_TestSegment(0333_MWToPitch_-1)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0333_MWToPitch_-1.sgt", 0},
     {"DLS_TestSegment(0334_MWToPitch_12)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0334_MWToPitch_12.sgt", 0},
     {"DLS_TestSegment(0350_PitchRange_00)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0350_PitchRange_00.sgt", 0},
     {"DLS_TestSegment(0351_PitchRange_-06)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0351_PitchRange_-06.sgt", 0},
     {"DLS_TestSegment(0352_PitchRange_06)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0352_PitchRange_06.sgt", 0},
     {"DLS_TestSegment(0353_PitchRange_-12)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0353_PitchRange_-12.sgt", 0},
     {"DLS_TestSegment(0354_PitchRange_12)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/VibLFO/0354_PitchRange_12.sgt", 0},


    //Filter
     {"DLS_TestSegment(0500_EnableFilter_Off)",    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0500_EnableFilter_Off.sgt", 0},
     {"DLS_TestSegment(0500_EnableFilter_Off1)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0500_EnableFilter_Off1.sgt", 0},
     {"DLS_TestSegment(0510_InitialFc_05535)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0510_InitialFc_05535.sgt", 0},
     {"DLS_TestSegment(0511_InitialFc_11921)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0511_InitialFc_11921.sgt", 0},
     {"DLS_TestSegment(0520_KeyNumberToFc_0)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0520_KeyNumberToFc_0.sgt", 0},
     {"DLS_TestSegment(0521_KeyNumberToFc_-1000)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0521_KeyNumberToFc_-1000.sgt", 0},
     {"DLS_TestSegment(0522_KeyNumberToFc_1000)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0522_KeyNumberToFc_1000.sgt", 0},
     {"DLS_TestSegment(0523_KeyNumberToFc_-12800)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0523_KeyNumberToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0524_KeyNumberToFc_12800)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0524_KeyNumberToFc_12800.sgt", 0},
     {"DLS_TestSegment(0530_KeyVelocityToFc_0)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0530_KeyVelocityToFc_0.sgt", 0},
     {"DLS_TestSegment(0531_KeyVelocityToFc_-1000)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0531_KeyVelocityToFc_-1000.sgt", 0},
     {"DLS_TestSegment(0532_KeyVelocityToFc_1000)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0532_KeyVelocityToFc_1000.sgt", 0},
     {"DLS_TestSegment(0533_KeyVelocityToFc_-12800)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0533_KeyVelocityToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0534_KeyVelocityToFc_12800)", "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0534_KeyVelocityToFc_12800.sgt", 0},
     {"DLS_TestSegment(0540_MODLFOCC1ToFc_0)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0540_MODLFOCC1ToFc_0.sgt", 0},
     {"DLS_TestSegment(0541_MODLFOCC1ToFc_-4000)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0541_MODLFOCC1ToFc_-4000.sgt", 0},
     {"DLS_TestSegment(0542_MODLFOCC1ToFc_4000)",    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0542_MODLFOCC1ToFc_4000.sgt", 0},
     {"DLS_TestSegment(0543_MODLFOCC1ToFc_-12800)",  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0543_MODLFOCC1ToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0544_MODLFOCC1ToFc_12800)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0544_MODLFOCC1ToFc_12800.sgt", 0},
     {"DLS_TestSegment(0550_MODLFOToFc_0)",          "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0550_MODLFOToFc_0.sgt", 0},
     {"DLS_TestSegment(0551_MODLFOToFc_-4000)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0551_MODLFOToFc_-4000.sgt", 0},
     {"DLS_TestSegment(0552_MODLFOToFc_4000)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0552_MODLFOToFc_4000.sgt", 0},
     {"DLS_TestSegment(0553_MODLFOToFc_-12800)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0553_MODLFOToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0554_MODLFOToFc_12800)",      "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0554_MODLFOToFc_12800.sgt", 0},
     {"DLS_TestSegment(0561_PitchEnvToFc_-1000)",    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0561_PitchEnvToFc_-1000.sgt", 0},
     {"DLS_TestSegment(0562_PitchEnvToFc_1000)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0562_PitchEnvToFc_1000.sgt", 0},
     {"DLS_TestSegment(0563_PitchEnvToFc_-6000)",    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0563_PitchEnvToFc_-6000.sgt", 0},
     {"DLS_TestSegment(0564_PitchEnvToFc_6000)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0564_PitchEnvToFc_6000.sgt", 0},
     {"DLS_TestSegment(0565_PitchEnvToFc_-12800)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0565_PitchEnvToFc_-12800.sgt", 0},
     {"DLS_TestSegment(0566_PitchEnvToFc_12800)",    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0566_PitchEnvToFc_12800.sgt", 0},
     {"DLS_TestSegment(0570_Resonance_00db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0570_Resonance_00db.sgt", 0},
     {"DLS_TestSegment(0571_Resonance_22db)",        "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Filter/0571_Resonance_22db.sgt", 0},

    //Regions
     {"DLS_TestSegment(0601_Layers)",                    "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Regions/0601_Layers.sgt", 0},
     {"DLS_TestSegment(0602_Layers_Multiple_Waves)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Regions/0602_Layers_Multiple_Waves.sgt", 0},
     {"DLS_TestSegment(0603_NotesOutsideRegionDontPlay)","Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Regions/0603_NotesOutsideRegionDontPlay.sgt", 0},
     {"DLS_TestSegment(0610_VelocityRange_Exclude)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Regions/0610_VelocityRange_Exclude.sgt", 0},
     {"DLS_TestSegment(0611_VelocityRange_Include)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/Regions/0611_VelocityRange_Include.sgt", 0},


    //Continuous Controllers (CCs)
     {"DLS_TestSegment(CC1_001_ModWheel)",           "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_001_ModWheel.sgt", 0},
     {"DLS_TestSegment(CC1_002_BreathController)",   "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_002_BreathController.sgt", 0},
     {"DLS_TestSegment(CC1_007_Volume)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_007_Volume.sgt", 0},
     {"DLS_TestSegment(CC1_008_Balance)",            "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_008_Balance.sgt", 0},
     {"DLS_TestSegment(CC1_010_Pan)",                "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_010_Pan.sgt", 0},
     {"DLS_TestSegment(CC1_011_Expression)",         "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_011_Expression.sgt", 0},
     {"DLS_TestSegment(CC1_064_Sustain)",            "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_064_Sustain.sgt", 0},
     {"DLS_TestSegment(CC1_069_Hold2)",              "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_069_Hold2.sgt", 0},
     {"DLS_TestSegment(CC1_074_FilterCutoff)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_074_FilterCutoff.sgt", 0},
     {"DLS_TestSegment(CC1_091_ExtEffects)",         "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_091_ExtEffects.sgt", 0},
     {"DLS_TestSegment(CC1_092_Tremelo)",            "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_092_Tremelo.sgt", 0},
     {"DLS_TestSegment(CC1_093_Chorus)",             "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_093_Chorus.sgt", 0},
     {"DLS_TestSegment(CC1_MonoAT)",                 "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_MonoAT.sgt", 0},
     {"DLS_TestSegment(CC1_PBend)",                  "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_PBend.sgt", 0},
     {"DLS_TestSegment(CC1_RPN_CoarseTuning)",       "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_RPN_CoarseTuning.sgt", 0},
     {"DLS_TestSegment(CC1_RPN_FineTuning)",         "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_RPN_FineTuning.sgt", 0},
     {"DLS_TestSegment(CC1_RPN_PitchBendRange)",     "Valid", DLS_TestSegment, (DWORD)"DMusic/DMTest1/DLS/CC/CC1_RPN_PitchBendRange.sgt", 0},


    //Loader Tests
    //------------
    //Move the real tests in here!!
//     {" Loader_ClearCache",  CC1_001_ModWheel.sgt", Loader_ClearCache_Valid(ptPerf8));
     {"Loader_LoadObjectFromFile_Valid",              "Valid",  Loader_LoadObjectFromFile_Valid, 0, 0},     //FAIL 3802
     {"Loader_LoadObjectFromFile_Valid_AbsolutePath(SegEmbedWave)", "Valid",  Loader_LoadObjectFromFile_Valid_AbsolutePath, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt", 0},
     {"Loader_LoadObjectFromFile_Valid_Bug7707", "Valid",  Loader_LoadObjectFromFile_Valid_Bug7707, 0, 0},
     

//These don't work anyway.
//     {"Loader_LoadObjectFromFile_Container_ByFileName(SegmentDLS)",   "Valid",  Loader_LoadObjectFromFile_Container_ByFileName, FALSE, (DWORD)"ff2end.sgt"},     
//     {"Loader_LoadObjectFromFile_Container_ByFileName(Wave)",         "Valid",  Loader_LoadObjectFromFile_Container_ByFileName,       TRUE, (DWORD)"looping20s.wav"}, 
//     {"Loader_LoadObjectFromFile_Container_ByFileName_Script(SegmentDLS)", "Valid",  Loader_LoadObjectFromFile_Container_ByFileName_Script,       FALSE, (DWORD)"ff2end.sgt"},     
//     {"Loader_LoadObjectFromFile_Container_ByFileName_Script(Wave)",       "Valid",  Loader_LoadObjectFromFile_Container_ByFileName_Script,       TRUE, (DWORD)"looping20s.wav"}, 

     {"Loader_LoadObjectFromFile_Container_ByName(SegmentDLS)",       "Valid",  Loader_LoadObjectFromFile_Container_ByName,     FALSE, (DWORD)"ff2end"},     
     {"Loader_LoadObjectFromFile_Container_ByGUID(SegmentDLS)",       "Valid",  Loader_LoadObjectFromFile_Container_ByGUID,     FALSE, (DWORD)"{C7C88355-14E1-4A6D-B45B-3F099DF28DB5}"},                                                                                                                                        

//WontFixed bug 8444
//     {"Loader_LoadObjectFromFile_Container_ByName(Wave)",             "Valid",  Loader_LoadObjectFromFile_Container_ByName,           TRUE, (DWORD)"looping20s"},     
//     {"Loader_LoadObjectFromFile_Container_ByGUID(Wave)",             "Valid",  Loader_LoadObjectFromFile_Container_ByGUID,           TRUE, (DWORD)"{7589C574-79E4-4564-BA9F-486B99B6F648}"},
     {"Loader_LoadObjectFromFile_Container_ByName_Script(SegmentDLS)",     "Valid",  Loader_LoadObjectFromFile_Container_ByName_Script,           FALSE, (DWORD)"ff2end"},     
     {"Loader_LoadObjectFromFile_Container_ByGUID_Script(SegmentDLS)",     "Valid",  Loader_LoadObjectFromFile_Container_ByGUID_Script,           FALSE, (DWORD)"{C7C88355-14E1-4A6D-B45B-3F099DF28DB5}"},                                                                                                                                        
     {"Loader_LoadObjectFromFile_Container_ByName_Script(Wave)",           "Valid",  Loader_LoadObjectFromFile_Container_ByName_Script,           TRUE, (DWORD)"looping20s"},     
     {"Loader_LoadObjectFromFile_Container_ByGUID_Script(Wave)",           "Valid",  Loader_LoadObjectFromFile_Container_ByGUID_Script,           TRUE, (DWORD)"{7589C574-79E4-4564-BA9F-486B99B6F648}"},

     //{"Loader_LoadObjectFromFile_Container_ByName(Wave)",       "Valid",  Loader_LoadObjectFromFile_Container_ByName, (DWORD)"DMusic/DMTest1/Loader/Cont01/Cont01.con", (DWORD)"Looping20s.wav"},


     //{"Loader_CollectGarbage_Valid",                  "Valid" , Loader_CollectGarbage_Valid, 0, 0},
     {"Loader_GetObject_IStream(test)",                "Valid" , Loader_GetObject_IStream_Test,         (DWORD)"DMusic/DMTest1/test.sgt", 0},
     {"Loader_GetObject_IStream(streaming)",           "Valid" , Loader_GetObject_IStream_Streaming,    (DWORD)"WAV/Streaming10s.wav", 0},

//     {"Loader_GetObject",                           "Valid",  Loader_GetObject_Valid, 0, 0},
//     {"Loader_SetObject",                           "Valid",  Loader_SetObject_Valid, 0, 0},
//     {"Loader_SetSearchDirectory",                  "Valid",  Loader_SetSearchDirectory_Valid, 0, 0},
//     {"Loader_ReleaseObjectByUnknown",              "Valid",  Loader_ReleaseObjectByUnknown_Valid, 0, 0},

    
    //Performance8 Tests
    //------------------
    {"Performance8_AddNotificationType_NoRestart(1,0)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    0},       //PASS
    {"Performance8_AddNotificationType_NoRestart(2,0)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       0},       //FAIL, 3240
    {"Performance8_AddNotificationType_NoRestart(4,0)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           0},       //FAIL, 3240
    {"Performance8_AddNotificationType_NoRestart(7,0)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_ALL,               0},       //FAIL, 3240

    //Verify that removals work.
    {"Performance8_AddNotificationType_NoRestart(1,1)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    TESTNOTIFICATION_MEASUREANDBEAT},
    {"Performance8_AddNotificationType_NoRestart(2,2)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       TESTNOTIFICATION_PERFORMANCE},
    {"Performance8_AddNotificationType_NoRestart(4,4)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           TESTNOTIFICATION_SEGMENT},
    {"Performance8_AddNotificationType_NoRestart(7,7)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_ALL,               TESTNOTIFICATION_ALL},

    //Make sure that each removal.is the correct one.
    {"Performance8_AddNotificationType_NoRestart(1,2)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    TESTNOTIFICATION_PERFORMANCE},
    {"Performance8_AddNotificationType_NoRestart(2,4)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       TESTNOTIFICATION_SEGMENT},
    {"Performance8_AddNotificationType_NoRestart(4,1)",       "Valid", Performance8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           TESTNOTIFICATION_MEASUREANDBEAT},

    //Make sure that duplicate removals don't hurt anything
    {"Performance8_AddNotificationType_NoRestart(0,1)",       "Valid", Performance8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_MEASUREANDBEAT},
    {"Performance8_AddNotificationType_NoRestart(0,2)",       "Valid", Performance8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_PERFORMANCE},
    {"Performance8_AddNotificationType_NoRestart(0,4)",       "Valid", Performance8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_SEGMENT},

    //Make sure all the notifications work after you restart a segment.
    {"Performance8_AddNotificationType_Restart(1,0)",       "Valid", Performance8_AddNotificationType_Restart, TESTNOTIFICATION_MEASUREANDBEAT,    0},       //PASS
    {"Performance8_AddNotificationType_Restart(2,0)",       "Valid", Performance8_AddNotificationType_Restart, TESTNOTIFICATION_PERFORMANCE,       0},       //FAIL, 3240
    {"Performance8_AddNotificationType_Restart(4,0)",       "Valid", Performance8_AddNotificationType_Restart, TESTNOTIFICATION_SEGMENT,           0},       //FAIL, 3240



     {"Performance8_AllocPMsg_Valid",                 "Valid", Performance8_AllocPMsg_Valid, 0, 0},                      
     {"Performance8_ClonePMsg_Valid",                 "Valid", Performance8_ClonePMsg_Valid, 0, 0},                   

      //Create standard audiopath.
     {"Performance8_CreateStandardAudioPath_AllCombos(FALSE)","Valid", Performance8_CreateStandardAudioPath_AllCombos, FALSE, 0},
     {"Performance8_CreateStandardAudioPath_AllCombos(TRUE)","Valid", Performance8_CreateStandardAudioPath_AllCombos, TRUE,  0},
     {"Performance8_CreateStandardAudioPath_Wait","Valid", Performance8_CreateStandardAudioPath_Wait, 0,  0},
     {"Performance8_Play2AudioPaths",             "Valid", Performance8_Play2AudioPaths, 0,  0},

     {"Performance8_CloseDown(BEFORESTOPPING)",             "Valid", Performance8_CloseDown_WhilePlaying, CLOSEDOWN_BEFORESTOPPING,  0},
//     {"Performance8_CloseDown(BEFOREUNLOADING)",            "Valid", Performance8_CloseDown_WhilePlaying, CLOSEDOWN_BEFOREUNLOADING,  0},
     {"Performance8_CloseDown(BEFORERELEASINGPATH)",        "Valid", Performance8_CloseDown_WhilePlaying, CLOSEDOWN_BEFORERELEASINGPATH,  0},
     {"Performance8_CloseDown(AFTEREVERYTHINGELSE)",        "Valid", Performance8_CloseDown_WhilePlaying, CLOSEDOWN_AFTEREVERYTHINGELSE,  0},
     {"Performance8_CloseDown(TWICE)",                      "Valid", Performance8_CloseDown_WhilePlaying, CLOSEDOWN_TWICE,  0},

     {"Performance8_CreateStandardAudioPath_LimitPChannels","Valid", Performance8_CreateStandardAudioPath_LimitPChannels, 0,  0},

     {"Performance8_FreePMsg_Valid",                  "Valid", Performance8_FreePMsg_Valid, 0, 0},                
     {"Performance8_GetGlobalParam_Valid",            "Valid", Performance8_GetGlobalParam_Valid, 0, 0},          
     {"Performance8_GetNotificationPMsg_Valid_Segment","Valid", Performance8_GetNotificationPMsg_Valid, 0, 0},
     {"Performance8_GetSegmentState_Valid",           "Valid", Performance8_GetSegmentState_Valid, 0, 0},           
     {"Performance8_GetTime_Valid_InOrder",           "Valid", Performance8_GetTime_Valid_InOrder, 0, 0},   
     //{"Performance8_InitAudio_Valid",               "Valid", Performance8_InitAudio_Valid, 0, 0},                            //Not tested.
     {"Performance8_IsPlaying_Valid",                 "Valid", Performance8_IsPlaying_Valid, 0, 0},                              //FAILS due to 3677
     {"Performance8_GetSetDefaultAudioPath_Valid",    "Valid", Performance8_GetSetDefaultAudioPath_Valid, 0, 0},    //PASSES!
     {"Performance8_MusicToReferenceTime_Repeat",     "Valid", Performance8_MusicToReferenceTime_Repeat,      0, 0},
     {"Performance8_MusicToReferenceTime_TempoChange","Valid", Performance8_MusicToReferenceTime_TempoChange, 0, 0},

//     {"Performance8_PlaySegmentEx_Valid",             "Valid", Performance8_PlaySegmentEx_Valid, 0, 0},          //FAIL: 3713, 3714, 3717


    //Multiple copies of the same wave streaming at different points; no repeating.
    {"Performance8_PlaySegmentEx_Multiple(Streaming10s,30,NoRepeat)", "Valid", Performance8_PlaySegmentEx_Multiple_NoRepeats, (DWORD)"WAV/Streaming10s.wav", 30},

    //Multiple copies of the same wave streaming at different points; repeating.
    {"Performance8_PlaySegmentEx_Multiple(Streaming10s,30,Repeat)", "Valid", Performance8_PlaySegmentEx_Multiple_OneRepeat, (DWORD)"WAV/Streaming10s.wav", 30},
    
    //Multiple different waves, streaming.
    {"Performance8_PlaySegmentEx_Multiple(Random,NoRepeat)", "Valid", Performance8_PlaySegmentEx_Multiple_NoRepeats,  NULL, 0},
    {"Performance8_PlaySegmentEx_Multiple(Random,OneRepeat)", "Valid", Performance8_PlaySegmentEx_Multiple_OneRepeat, NULL, 0},  

    //Multiple looping waves, not repeating and repeating", "Valid", it doesn't make a difference).
    {"Performance8_PlaySegmentEx_Multiple(Looping,NoRepeat)", "Valid", Performance8_PlaySegmentEx_Multiple_NoRepeats, (DWORD)"WAV/LoopForever.wav", 5},
    {"Performance8_PlaySegmentEx_Multiple(Looping,OneRepeat)", "Valid", Performance8_PlaySegmentEx_Multiple_OneRepeat, (DWORD)"WAV/LoopForever.wav", 5},


     {"Performance8_PlaySegmentEx_Valid_Play(Default,10)","Valid", Performance8_PlaySegmentEx_Valid_Play,                   (DWORD)"DEFAULT", 10}, //Play for 10 seconds.
     {"Performance8_PlaySegmentEx_Valid_Play(Desert,10)","Valid", Performance8_PlaySegmentEx_Valid_Play,                    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Scott01/DesertAmbience.sgt", 10}, //Play for 10 seconds.
     {"Performance8_PlaySegmentEx_Valid_Play(IndSegment,All)",    "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/IndSegment.sgt",        0xFFFFFFFF}, //Play all the way.
     {"Performance8_PlaySegmentEx_Valid_Play(RefSegment,All)",    "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/RefSegment.sgt",        0xFFFFFFFF},
//     {"Performance8_PlaySegmentEx_Valid_Play(Seg16MBDLS,5)",      "Valid", Performance8_PlaySegmentEx_Valid_Play,         (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/Seg16MBDLS.sgt",      0xFFFFFFFF},
     {"Performance8_PlaySegmentEx_Valid_Play(SegChordmap,All)",   "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegChordmap.sgt",       0xFFFFFFFF},
     {"Performance8_PlaySegmentEx_Valid_Play(SegTriggering,All)", "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegTriggering.sgt",     0xFFFFFFFF},
      {"Performance8_PlaySegmentEx_Valid_Play(SegWaveLoopForever,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,      (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveLoopForever.sgt",0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(SegWaveShort,All)",  "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveShort.sgt",      0xFFFFFFFF},
     {"Performance8_PlaySegmentEx_Valid_Play(SegWaveStreaming10s,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,      (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveStreaming10s.sgt",0xFFFFFFFF},
     {"Performance8_PlaySegmentEx_Valid_Play(WaveLoopForever,5)", "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/WaveLoopForever.wav",     10},           //10s
     {"Performance8_PlaySegmentEx_Valid_Play(WaveShort,All)",     "Valid", Performance8_PlaySegmentEx_Valid_Play,           (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/WaveShort.wav",         0xFFFFFFFF},  //Play all the way.
     {"Performance8_PlaySegmentEx_Valid_Play(WaveStreaming10s,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,         (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/WaveStreaming10s.wav",  0xFFFFFFFF},  //Play all the way.
//    {"Performance8_PlaySegmentEx_Valid_Play(16MB_OneShot,5s)",   "Valid", Performance8_PlaySegmentEx_Valid_Play,          (DWORD)"WAV/16MB_OneShot.wav",                          10},           //5s
//     {"Performance8_PlaySegmentEx_Valid_Play(16MB_OneShot,VerifyLoop)",   "Valid", Performance8_PlaySegmentEx_Valid_Play, (DWORD)"WAV/16MB_OneShot.wav", 120},           //2 minutes
     {"Performance8_PlaySegmentEx_Valid_Play(GrayedOutInstrument,5)","Valid", Performance8_PlaySegmentEx_Valid_Play,        (DWORD)"DMusic/DMTest1/loader/Inv_GMRefs/GrayedOutInstrument.sgt", 5}, 
     {"Performance8_PlaySegmentEx_Valid_Play(Timing01,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,                 (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Timing/Timing.sgt", 0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(PB01,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,                     (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PB01/PB01.sgt", 0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(Fur,5s)","Valid", Performance8_PlaySegmentEx_Valid_Play,                       (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Fur/Fur.sgt", 5}, 
     {"Performance8_PlaySegmentEx_Valid_Play(MultipleNotes_SamePChannel,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,(DWORD)"DMusic/DMTest1/Perf8/PlaySeg/MultipleNotes_SamePChannel/MultipleNotes_SamePChannel.sgt", 0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(MNSP_Decay2.sgt,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,          (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/MultipleNotes_SamePChannel/MNSP_Decay2.sgt", 0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(Walk.sgt,10s)","Valid", Performance8_PlaySegmentEx_Valid_Play,                 (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Walk/Walk.sgt", 10}, 
     {"Performance8_PlaySegmentEx_Valid_Play(Harp.sgt,Long)","Valid", Performance8_PlaySegmentEx_Valid_Play,                (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Harp/Harp.sgt", 30}, 
     {"Performance8_PlaySegmentEx_Valid_Play(Ambience.sgt,20s)","Valid", Performance8_PlaySegmentEx_Valid_Play,             (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Other/Ambience.sgt", 20}, 
     {"Performance8_PlaySegmentEx_Valid_Play(MusicReverb.sgt,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,          (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/MusicReverb/MusicReverb.sgt", 0xFFFFFFFF}, 
     {"Performance8_PlaySegmentEx_Valid_Play(PCMandADPCM,All)","Valid", Performance8_PlaySegmentEx_Valid_Play,              (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PCMandADPCM/PCMandADPCM.sgt", 27},
     {"Performance8_PlaySegmentEx_Valid_Play(16Streams,All)",  "Valid", Performance8_PlaySegmentEx_Valid_Play,              (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Streams/16Streams.sgt", 0xFFFFFFFF},
     
     //BUGBUG: Where did this come from?  Why is there no media for it?
     //{"Performance8_PlaySegmentEx_Valid_Play(32Streams,All)",  "Valid", Performance8_PlaySegmentEx_Valid_Play,              (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Streams/32Streams.sgt", 0xFFFFFFFF},

     {"Performance8_PlaySegment_StartTime_Start(10Ticks)","Valid", Performance8_PlaySegment_StartTime_Start, 10, 0},
     {"Performance8_PlaySegment_StartTime_Start(4Notes)", "Valid", Performance8_PlaySegment_StartTime_Start, DMUS_PPQ * 4, 0},
     {"Performance8_PlaySegment_StartTime_Start(100ms)",  "Valid", Performance8_PlaySegment_StartTime_Start, 0, 1000000},
     {"Performance8_PlaySegment_StartTime_Start(2s)",     "Valid", Performance8_PlaySegment_StartTime_Start, 0, 20000000},
     {"Performance8_PlaySegment_StartTime_Transition(10Ticks)","Valid", Performance8_PlaySegment_StartTime_Transition, 10, 0},
     {"Performance8_PlaySegment_StartTime_Transition(4Notes)", "Valid", Performance8_PlaySegment_StartTime_Transition, DMUS_PPQ * 4, 0},
     {"Performance8_PlaySegment_StartTime_Transition(100ms)",  "Valid", Performance8_PlaySegment_StartTime_Transition, 0, 1000000},
     {"Performance8_PlaySegment_StartTime_Transition(2s)",     "Valid", Performance8_PlaySegment_StartTime_Transition, 0, 20000000},


     {"Performance8_PlaySegment_TransitionType(DMUS_SEGF_QUEUE)",  "Valid", Performance8_PlaySegment_TransitionType, DMUS_SEGF_QUEUE, 0},
     {"Performance8_PlaySegment_TransitionType(DMUS_SEGF_GRID)",   "Valid", Performance8_PlaySegment_TransitionType, DMUS_SEGF_GRID, 0},
     {"Performance8_PlaySegment_TransitionType(DMUS_SEGF_BEAT)",   "Valid", Performance8_PlaySegment_TransitionType, DMUS_SEGF_BEAT, 0},
     {"Performance8_PlaySegment_TransitionType(DMUS_SEGF_MEASURE)","Valid", Performance8_PlaySegment_TransitionType, DMUS_SEGF_MEASURE, 0},
     {"Performance8_PlaySegment_TransitionType(DMUS_SEGF_DEFAULT)","Valid", Performance8_PlaySegment_TransitionType, DMUS_SEGF_DEFAULT, 0},

     {"Performance8_PlaySegment_TransPreAlign(DMUS_SEGF_ALIGN|DMUS_SEGF_VALID_START_BEAT)",   "Valid", Performance8_PlaySegment_TransPreAlign, DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_BEAT, 0},
     {"Performance8_PlaySegment_TransPreAlign(DMUS_SEGF_ALIGN|DMUS_SEGF_VALID_START_GRID)",   "Valid", Performance8_PlaySegment_TransPreAlign, DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_GRID, 0},
     {"Performance8_PlaySegment_TransPreAlign(DMUS_SEGF_ALIGN|DMUS_SEGF_VALID_START_MEASURE)","Valid", Performance8_PlaySegment_TransPreAlign, DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_MEASURE, 0},
     {"Performance8_PlaySegment_TransPreAlign(DMUS_SEGF_ALIGN|DMUS_SEGF_VALID_START_TICK)",   "Valid", Performance8_PlaySegment_TransPreAlign, DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_TICK, 0},


     {"Performance8_PlaySegmentEx_Valid_SetFrequency(LoopingWave,10s)","Valid", Performance8_PlaySegmentEx_Valid_SetFrequency, (DWORD)"WAV/LoopForever.wav", 10},    
     {"Performance8_PlaySegmentEx_Valid_SetFrequency(Default,All)","Valid", Performance8_PlaySegmentEx_Valid_SetFrequency, (DWORD)"SGT/test.sgt", 0xFFFFFFFF},    


     {"Performance8_PlaySegmentEx_Valid_Play(Sine,All)","Valid", Performance8_PlaySegmentEx_Segment_WaitFor10Seconds, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Glitch/PCM_LP_11_1_Short.wav", 0xFFFFFFFF},
     {"Performance8_PlaySegmentEx_Segment_WaitForEnd(Streaming10s.wav,0)",                    "Valid", Performance8_PlaySegmentEx_Segment_WaitForEnd, (DWORD)"WAV/Streaming10s.wav", 0},
     {"Performance8_PlaySegmentEx_Segment_WaitForEnd(Streaming10s.wav,1)",                    "Valid", Performance8_PlaySegmentEx_Segment_WaitForEnd, (DWORD)"WAV/Streaming10s.wav", 1},
     {"Performance8_PlaySegmentEx_Segment_WaitForEnd(ShortWave.wav,0)",                       "Valid", Performance8_PlaySegmentEx_Segment_WaitForEnd, (DWORD)"WAV/ShortWave.wav"   , 0},
     {"Performance8_PlaySegmentEx_Segment_WaitForEnd(ShortWave.wav,1)",                       "Valid", Performance8_PlaySegmentEx_Segment_WaitForEnd, (DWORD)"WAV/ShortWave.wav"   , 1},
     {"Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(Loop3Times.wav,0)","Valid", Performance8_PlaySegmentEx_Segment_WaitFor10Seconds,(DWORD)"WAV/Loop3Times.wav"  , 0},
     {"Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(Loop3Times.wav,1)","Valid", Performance8_PlaySegmentEx_Segment_WaitFor10Seconds,(DWORD)"WAV/Loop3Times.wav"  , 1},
     {"Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(LoopForever.wav,0)","Valid", Performance8_PlaySegmentEx_Segment_WaitFor10Seconds,(DWORD)"WAV/LoopForever.wav" , 0},
     {"Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(LoopForever.wav,1)","Valid", Performance8_PlaySegmentEx_Segment_WaitFor10Seconds,(DWORD)"WAV/LoopForever.wav" , 1},


     {"Performance8_PlaySegmentEx_Valid_PlayBeforeDoWork(Cliff01,All)","Valid", Performance8_PlaySegmentEx_Valid_PlayBeforeDoWork, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Cliff01/Control.sgt", 0xFFFFFFFF}, //Play entire segment.
     {"Performance8_PlaySegmentEx_Valid_DelayDoWork(Timing,500)","Valid", Performance8_PlaySegmentEx_Valid_DelayDoWork, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Timing/Timing.sgt", 1500}, //Play entire segment.

     {"Performance8_PlaySegment_Latency",                         "Valid", Performance8_PlaySegment_Latency, 0,0}, 
     {"Performance8_PlaySegment_Latency_Interactive",             "Valid", Performance8_PlaySegment_Latency_Interactive, 0,0}, 
     {"Performance8_PlaySegmentEx_QuickStartStop_ADPCM",          "Valid", Performance8_PlaySegmentEx_QuickStartStop_ADPCM, 0,0}, 
     {"Performance8_PlaySegmentEx_QuickStartStop_WaveFiles",      "Valid", Performance8_PlaySegmentEx_QuickStartStop_WaveFiles, 0,0}, 
     {"Performance8_PlaySegmentEx_QuickStartStop_WaveSegments",   "Valid", Performance8_PlaySegmentEx_QuickStartStop_WaveSegments, 0,0}, 
     {"Performance8_PlaySegmentEx_QuickStartStopOneFile",         "Valid", Performance8_PlaySegmentEx_QuickStartStopOneFile, 0,0},
     {"Performance8_PlaySegmentEx_RelativeVolume",                "Valid", Performance8_PlaySegmentEx_RelativeVolume, 0,0}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(ADPCM_LP_11_1.wav)",           "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/ADPCM_LP_11_1.wav"}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(PCM_LP_11_1.wav)",             "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/PCM_LP_11_1.wav"}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(Glitch_Sine.wav)",         "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/Glitch_Sine.wav"}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(Glitch_Silence01s.wav)",         "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/Glitch_Silence01s.wav"}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(Glitch_SineSilence.wav)",        "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/Glitch_SineSilence.wav"}, 
     {"Performance8_PlaySegmentEx_CompareWithDSound(Glitch_SineSilenceChopped.wav)", "Valid", Performance8_PlaySegmentEx_CompareWithDSound, DMUS_APATH_SHARED_STEREO, (DWORD)"WAV/Glitch_SineSilenceChopped.wav"}, 

     {"Performance8_PlaySegmentEx_Timing(Seg1)",                        "Valid", Performance8_PlaySegmentEx_Timing, (DWORD)"DMusic/DMTest1/script/Play02Trans/seg1.sgt", 12800},
     {"Performance8_PlaySegmentEx_Timing(Seg2)",                        "Valid", Performance8_PlaySegmentEx_Timing, (DWORD)"DMusic/DMTest1/script/Play02Trans/seg2.sgt", 12800},
     {"Performance8_PlaySegmentEx_Timing(10sWave)",                     "Valid", Performance8_PlaySegmentEx_Timing, (DWORD)"WAV/Streaming10s.wav", 10000},

     {"Performance8_PlaySegmentEx_Leak",                                "Valid", Performance8_PlaySegmentEx_Leak, (DWORD)"WAV/LoopForever.wav", NULL},

     #define SEGMENT 0
     #define WAVE 1
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_0_3_1r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_3_1r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_0_3_2r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_3_2r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_0_6_1r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_6_1r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_0_6_2r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_6_2r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_1_5_1r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"1_5_1r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_1_5_2r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"1_5_2r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_3_6_1r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"3_6_1r", SEGMENT},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_SEGMENT_3_6_2r",  "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"3_6_2r", SEGMENT},

//    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB)","Valid", Performance8_PlaySegmentEx_AudioPath, DMUS_APATH_SHARED_STEREOPLUSREVERB, 0},

#define ONESHOT     0
#define STREAMING   1
#define MUSIC       2
#define MULTIPAN    3
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,1,OS)",       "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1,         ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,2,OS)",       "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1,         ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,6,OS)",       "Valid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1,         ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,1,OS)",   "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_ENV,     ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,1,OS)", "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,2,OS)", "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,4,OS)", "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   ONESHOT},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,1,ST)",       "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1,         STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,2,ST)",       "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1,         STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,6,ST)",       "Valid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1,         STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,1,ST)",   "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_ENV,     STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,1,ST)", "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,2,ST)", "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,4,ST)", "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   STREAMING},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,1,MU)",       "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1,         MUSIC},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,1,MU)",   "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_ENV,     MUSIC},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,1,MU)", "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   MUSIC},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,1,MP)",       "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1,         MULTIPAN},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,1,MP)",   "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_ENV,     MULTIPAN},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,1,MP)", "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   MULTIPAN},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,1,OS)",        "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD,          ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,2,OS)",        "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD,          ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,4,OS)",        "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD,          ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,1,OS)",    "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_ENV,      ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,1,OS)",  "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_MUSIC,    ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,2,OS)",  "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD_MUSIC,    ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,4,OS)",  "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD_MUSIC,    ONESHOT},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,1,ST)",        "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD,          STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,2,ST)",        "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD,          STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,4,ST)",        "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD,          STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,1,ST)",    "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_ENV,      STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,1,ST)",  "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_MUSIC,    STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,2,ST)",  "Valid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD_MUSIC,    STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,4,ST)",  "Valid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD_MUSIC,    STREAMING},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,1,MU)",        "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD,          MUSIC},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,1,MU)",    "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_ENV,      MUSIC},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,1,MU)",  "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_MUSIC,    MUSIC},

    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,1,MP)",        "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD,          MULTIPAN},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,1,MP)",    "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_ENV,      MULTIPAN},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,1,MP)",  "Valid", Performance8_PlaySegmentEx_AudioPath_1, DMUS_APATH_MIXBIN_QUAD_MUSIC,    MULTIPAN},

#undef STREAMING
#undef ONESHOT
#undef MUSIC
#undef PANNING 

    {"Performance8_PlaySegmentEx_MunchPerf",                                     "Valid", Performance8_PlaySegmentEx_MunchPerf,   0, 0},
    {"Performance8_PlaySegmentEx_AntzLooping",                                   "Valid", Performance8_PlaySegmentEx_AntzLooping, 0, 0},

/*THESE WILL FAIL!!
     {"Performance8_PlaySegmentEx_ClockTime_Looping_WAVE_0_3_1r",     "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_3_1r", WAVE},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_WAVE_0_6_1r",     "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"0_6_1r", WAVE},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_WAVE_1_5_1r",     "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"1_5_1r", WAVE},
     {"Performance8_PlaySegmentEx_ClockTime_Looping_WAVE_3_6_1r",     "Valid", Performance8_PlaySegmentEx_ClockTime_Looping, (DWORD)"3_6_1r", WAVE},
*/
     #undef SEGMENT
     #undef WAVE
    
     {"Script_CallRoutine_Valid_TransitionTempo",                 "Valid", Script_CallRoutine_Valid_TransitionTempo, 0,0}, 

     {"Performance8_ReferenceToMusicTime_TempoChange",      "Valid", Performance8_ReferenceToMusicTime_TempoChange, 0, 0},
     //{"Performance8_RemoveNotificationType_Valid",  "Valid", Performance8_RemoveNotificationType_Valid, 0, 0}, 
     {"Performance8_PMsg_Valid_Tempos",              "Valid", Performance8_PMsg_Valid_Tempos, 0, 0},                          
     {"Performance8_PMsg_Valid_Transpose",           "Valid", Performance8_PMsg_Valid_Transpose, 0, 0},                          
     {"Performance8_PMsg_Valid_PitchBend",           "Valid", Performance8_PMsg_Valid_PitchBend, 0, 0},                          
     {"Performance8_PMsg_Valid_Transpose_ChangeSong","Valid", Performance8_PMsg_Valid_Transpose_ChangeSong, 0, 0},                          
     {"Performance8_PMsg_Crossfade(Wave Segments)",                 "Valid", Performance8_PMsg_Crossfade, (DWORD)"WAV/LoopForever.wav", (DWORD)"WAV/08_08_2.wav"},
     {"Performance8_PMsg_Crossfade(DLS Segments)",                  "Valid", Performance8_PMsg_Crossfade, (DWORD)"DMusic/DMTest1/test.sgt", (DWORD)"DMusic/DMTest1/test2.sgt"},  
     {"Performance8_PMsg_Crossfade(Complex DLS Segments)",          "Valid", Performance8_PMsg_Crossfade, (DWORD)"DMusic/DMTest1/script/Play02Trans/seg1.sgt", (DWORD)"DMusic/DMTest1/script/Play02Trans/seg2.sgt"},  

     {"Performance8_SetGlobalParam_Valid",            "Valid", Performance8_SetGlobalParam_Valid, 0, 0},                    

     {"Performance8_StopEx_NoSegments","Valid", Performance8_StopEx_NoSegments, 0, 0},                            
     {"Performance8_StopEx_1Segment_DLS",    "Valid", Performance8_StopEx_1Segment_DLS,   0, 0},                            
     {"Performance8_StopEx_1Segment_Wave",   "Valid", Performance8_StopEx_1Segment_Wave,   0, 0},                            
     {"Performance8_StopEx_2Segments_DLS(1Path,1Seg)",  "Valid", Performance8_StopEx_2Segments_DLS,  TRUE,  TRUE },
     {"Performance8_StopEx_2Segments_DLS(1Path,2Seg)",  "Valid", Performance8_StopEx_2Segments_DLS,  TRUE,  FALSE},                            
     {"Performance8_StopEx_2Segments_DLS(2Path,1Seg)",  "Valid", Performance8_StopEx_2Segments_DLS,  FALSE, TRUE},                             
     {"Performance8_StopEx_2Segments_DLS(2Path,2Seg)",  "Valid", Performance8_StopEx_2Segments_DLS,  FALSE, FALSE},                            
     {"Performance8_StopEx_2Segments_Wave(1Path,1Seg)", "Valid", Performance8_StopEx_2Segments_Wave,  TRUE,  TRUE },
     {"Performance8_StopEx_2Segments_Wave(1Path,2Seg)", "Valid", Performance8_StopEx_2Segments_Wave,  TRUE,  FALSE},                            
     {"Performance8_StopEx_2Segments_Wave(2Path,1Seg)", "Valid", Performance8_StopEx_2Segments_Wave,  FALSE, TRUE},                             
     {"Performance8_StopEx_2Segments_Wave(2Path,2Seg)", "Valid", Performance8_StopEx_2Segments_Wave,  FALSE, FALSE},                            
     {"Performance8_StopEx_TimePast",    "Valid", Performance8_StopEx_TimePast,    0, 0},                            
     {"Performance8_StopEx_TimeFuture",  "Valid", Performance8_StopEx_TimeFuture,  0, 0},
     {"Performance8_StopEx_NoDoWork",    "Valid", Performance8_StopEx_NoDoWork,    0, 0},
     


    // Script Tests
    //-------------------
     {"Script_Init_Valid",                            "Valid",  Script_Init_Valid             , 0, 0},                      
     {"Script_CallRoutine_Valid",                     "Valid",  Script_CallRoutine_Valid      , 0, 0},                      
     
     //Fails by design; bad script.
     //{"Script_CallRoutine_Valid_PlayOneScript(Area51)","Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Bug5337/Area51_005.spt", (DWORD)"ExitAlienRoom"},                      

     {"Script_CallRoutine_Valid_PlayOneScript(Embed,1)",       "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Embedding/Script1.spt", (DWORD)"PlayMe"},                      
     {"Script_CallRoutine_Valid_PlayOneScript(Embed,2)",       "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Embedding/Script2.spt", (DWORD)"PlayMe"},                      
     {"Script_CallRoutine_Valid_PlayOneScript(Embed,3)",       "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Embedding/Script3.spt", (DWORD)"PlayMe"},                      
     {"Script_CallRoutine_Valid_PlayOneScript(Bug6511)", "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Other/Script1.spt", (DWORD)"PlayMeSecondary"}, 
     {"Script_CallRoutine_Valid_PlayOneScript(Bug6496)", "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Other/Bug6496/Bug6496.spt", (DWORD)"PlayMe"}, 
     {"Script_CallRoutine_Valid_PlayOneScript(Bug6497)", "Valid",  Script_CallRoutine_Valid_PlayOneScript, (DWORD)"DMusic/DMTest1/script/Other/ScriptA.spt", (DWORD)"DoNothing"}, 

     {"Script_SetVariableNumber_Valid",               "Valid",  Script_SetVariableNumber_Valid, 0, 0},                      
     {"Script_GetVariableNumber_Valid",               "Valid",  Script_GetVariableNumber_Valid, 0, 0},                      
     {"Script_SetvariableObject_Valid",               "Valid",  Script_SetVariableObject_Valid, 0, 0},                      
     {"Script_GetVariableObject_Valid",               "Valid",  Script_GetVariableObject_Valid, 0, 0},                      
     {"Script_SetVariableString_Valid",               "Valid",  Script_SetVariableString_Valid, 0, 0},                      
     {"Script_GetVariableString_Valid",               "Valid",  Script_GetVariableString_Valid, 0, 0},                      

     {"Script_AudioPath_SetGetVolume",                "Valid",  Script_CallRoutine_Valid_TestScript,   0, S_OK},
     {"Script_AudioPath_SetVolumeListeningTest",      "Valid",  Script_CallRoutine_Valid_TestScript,   1, S_OK},
     {"Script_AudioPathConfig_Create",                "Valid",  Script_CallRoutine_Valid_TestScript,  10, S_OK},
     {"Script_AudioPathConfig_Load",                  "Valid",  Script_CallRoutine_Valid_TestScript,  11, S_OK},
     {"Script_Segment_PlayStop",                      "Valid",  Script_CallRoutine_Valid_TestScript,  20, S_OK},
     {"Script_Performance_SetMasterGrooveLevel",      "Valid",  Script_CallRoutine_Valid_TestScript,  30, S_OK},
     {"Script_Performance_SetMasterTempo(DLS)",       "Valid",  Script_CallRoutine_Valid_TestScript,  32, S_OK},
     {"Script_Performance_SetMasterTempo(WAVE)",      "Valid",  Script_CallRoutine_Valid_TestScript,  33, S_OK},
     {"Script_Performance_GetMasterTempo",            "Valid",  Script_CallRoutine_Valid_TestScript,  34, S_OK},
     {"Script_Performance_SetMasterTranspose",        "Valid",  Script_CallRoutine_Valid_TestScript,  35, S_OK},
     {"Script_Performance_GetMasterTranspose",        "Valid",  Script_CallRoutine_Valid_TestScript,  36, S_OK},
     {"Script_Performance_Rand",                      "Valid",  Script_CallRoutine_Valid_TestScript,  37, S_OK},
     {"Script_PlayingSegment_IsPlaying(VerifyTrue)",  "Valid",  Script_CallRoutine_Valid_TestScript,  50, S_OK},
     {"Script_PlayingSegment_IsPlaying(VerifyFalse)", "Valid",  Script_CallRoutine_Valid_TestScript,  51, S_OK},
     {"Script_PlayingSegment_Stop",                   "Valid",  Script_CallRoutine_Valid_TestScript,  52, S_OK},
     {"Script_AutoLoadUnchecked_SegmentNoLoad",       "Valid",  Script_CallRoutine_Valid_TestScript, 100, DMUS_E_SCRIPT_ERROR_IN_SCRIPT},
     {"Script_AutoLoadUnchecked_SegmentLoad",         "Valid",  Script_CallRoutine_Valid_TestScript, 101, S_OK},
  //   {"Script_AutoLoadUnchecked_AudioPathNoLoad",     "Valid",  Script_CallRoutine_Valid_TestScript, 102, DMUS_E_SCRIPT_ERROR_IN_SCRIPT},
//     {"Script_AutoLoadUnchecked_AudioPathLoad",       "Valid",  Script_CallRoutine_Valid_TestScript, 103, S_OK}, //Not valid yet.
     {"Script_AutoLoadChecked_SegmentLoad",           "Valid",  Script_CallRoutine_Valid_TestScript, 110, S_OK},
//     {"Script_AutoLoadChecked_AudioPathLoad",         "Valid",  Script_CallRoutine_Valid_TestScript, 111, S_OK},

     {"Script_AutoDownloadUnchecked_NoDownload",     "Valid",  Script_CallRoutine_Valid_TestScript, 120, S_OK},
     {"Script_AutoDownloadUnchecked_Download",       "Valid",  Script_CallRoutine_Valid_TestScript, 121, S_OK},
     {"Script_AutoDownloadUnchecked_Unload",         "Valid",  Script_CallRoutine_Valid_TestScript, 122, S_OK},

//     {"Script_EmbeddedContent",                      "Valid",  Script_CallRoutine_Valid_TestScript, 150, S_OK},  //Not valid test.
     {"Script_Recompose",                            "Valid",  Script_CallRoutine_Valid_TestScript, 160, S_OK},

     // ************************************************************************************************************************
     // SCRIPT TRANSITION TESTS
     // ************************************************************************************************************************    
     
     //USE SEGMENT'S DEFAULT TRANSITION BOUNDARY
     {"Script_Transition_PlayIntro(Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 500, S_OK},
     {"Script_Transition_PlayIntro(SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 501, S_OK},
     {"Script_Transition_PlayIntro(DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 502, S_OK},
     {"Script_Transition_PlayFill (Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 510, S_OK},
     {"Script_Transition_PlayFill (SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 511, S_OK},
     {"Script_Transition_PlayFill (DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 512, S_OK},
     {"Script_Transition_PlayBreak(Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 520, S_OK},
     {"Script_Transition_PlayBreak(SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 521, S_OK},
     {"Script_Transition_PlayBreak(DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 522, S_OK},
     {"Script_Transition_PlayEnd  (Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 530, S_OK},
     {"Script_Transition_PlayEnd  (SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 531, S_OK},
     {"Script_Transition_PlayEnd  (DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 532, S_OK},
     {"Script_Transition_PlayEndAndIntro  (Startup)","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 540, S_OK},
     {"Script_Transition_PlayEndAndIntro  (SameSeg)","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 541, S_OK},
     {"Script_Transition_PlayEndAndIntro  (DiffSeg)","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 542, S_OK},

     
     //USE ATMEASURE TRANSITION BOUNDARY
     {"Script_Transition_AtMeasure_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 600, S_OK},
     {"Script_Transition_AtMeasure_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 601, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 602, S_OK},
     {"Script_Transition_AtMeasure_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 605, S_OK},
     {"Script_Transition_AtMeasure_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 606, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 608, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 609, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 610, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 611, S_OK},
     {"Script_Transition_AtMeasure_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 612, S_OK},
     {"Script_Transition_AtMeasure_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 613, S_OK},
     {"Script_Transition_AtMeasure_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 615, S_OK},

     //USE ATIMMEDIATE TRANSITION BOUNDARY
     {"Script_Transition_AtImmediate_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 620, S_OK},
     {"Script_Transition_AtImmediate_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 621, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 622, S_OK},
     {"Script_Transition_AtImmediate_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 625, S_OK},
     {"Script_Transition_AtImmediate_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 626, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 628, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 629, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 630, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 631, S_OK},
     {"Script_Transition_AtImmediate_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 632, S_OK},
     {"Script_Transition_AtImmediate_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 633, S_OK},
     {"Script_Transition_AtImmediate_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 635, S_OK},

     //USE ATBEAT TRANSITION BOUNDARY
     {"Script_Transition_AtBeat_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 640, S_OK},
     {"Script_Transition_AtBeat_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 641, S_OK},
     {"Script_Transition_AtBeat_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 642, S_OK},
     {"Script_Transition_AtBeat_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 645, S_OK},
     {"Script_Transition_AtBeat_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 646, S_OK},
     {"Script_Transition_AtBeat_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 648, S_OK},
     {"Script_Transition_AtBeat_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 649, S_OK},
     {"Script_Transition_AtBeat_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 650, S_OK},
     {"Script_Transition_AtBeat_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 651, S_OK},
     {"Script_Transition_AtBeat_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 652, S_OK},
     {"Script_Transition_AtBeat_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 653, S_OK},
     {"Script_Transition_AtBeat_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 655, S_OK},

     //USE ATGRID TRANSITION BOUNDARY
     {"Script_Transition_AtGrid_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 660, S_OK},
     {"Script_Transition_AtGrid_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 661, S_OK},
     {"Script_Transition_AtGrid_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 662, S_OK},
     {"Script_Transition_AtGrid_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 665, S_OK},
     {"Script_Transition_AtGrid_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 666, S_OK},
     {"Script_Transition_AtGrid_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 668, S_OK},
     {"Script_Transition_AtGrid_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 669, S_OK},
     {"Script_Transition_AtGrid_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 670, S_OK},
     {"Script_Transition_AtGrid_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 671, S_OK},
     {"Script_Transition_AtGrid_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 672, S_OK},
     {"Script_Transition_AtGrid_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 673, S_OK},
     {"Script_Transition_AtGrid_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 675, S_OK},

     //USE ATFINISH TRANSITION BOUNDARY
     {"Script_Transition_AtFinish_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 680, S_OK},
     {"Script_Transition_AtFinish_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 681, S_OK},
     {"Script_Transition_AtFinish_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 682, S_OK},
     {"Script_Transition_AtFinish_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 685, S_OK},
     {"Script_Transition_AtFinish_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 686, S_OK},
     {"Script_Transition_AtFinish_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 688, S_OK},
     {"Script_Transition_AtFinish_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 689, S_OK},
     {"Script_Transition_AtFinish_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 690, S_OK},
     {"Script_Transition_AtFinish_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 691, S_OK},
     {"Script_Transition_AtFinish_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 692, S_OK},
     {"Script_Transition_AtFinish_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 693, S_OK},
     {"Script_Transition_AtFinish_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 695, S_OK},

     //USE AtMarker TRANSITION BOUNDARY
     {"Script_Transition_AtMarker_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 700, S_OK},
     {"Script_Transition_AtMarker_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 701, S_OK},
     {"Script_Transition_AtMarker_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 702, S_OK},
     {"Script_Transition_AtMarker_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 705, S_OK},
     {"Script_Transition_AtMarker_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 706, S_OK},
     {"Script_Transition_AtMarker_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 708, S_OK},
     {"Script_Transition_AtMarker_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 709, S_OK},
     {"Script_Transition_AtMarker_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 710, S_OK},
     {"Script_Transition_AtMarker_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 711, S_OK},
     {"Script_Transition_AtMarker_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_Transition, 712, S_OK},
     {"Script_Transition_AtMarker_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 713, S_OK},
     {"Script_Transition_AtMarker_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_Transition, 715, S_OK},

     
     //Verify flag boundaries override default segment boundaries on PLAY
     {"Script_SegBoundaries_Play_AtMeasure_AtImmediate_NoTrans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 0, S_OK},
     {"Script_SegBoundaries_Play_AtMeasure_AtImmediate_Trans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 1, S_OK},
     {"Script_SegBoundaries_Play_AtMeasure_AtGrid_NoTrans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 2, S_OK},
     {"Script_SegBoundaries_Play_AtMeasure_AtGrid_Trans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 3, S_OK},
     {"Script_SegBoundaries_Play_AtMeasure_AtBeat_NoTrans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 4, S_OK},
     {"Script_SegBoundaries_Play_AtMeasure_AtBeat_Trans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 5, S_OK},
     {"Script_SegBoundaries_Play_AtImmediate_AtMeasure_NoTrans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 6, S_OK},
     {"Script_SegBoundaries_Play_AtImmediate_AtMeasure_Trans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 7, S_OK},
     {"Script_SegBoundaries_Play_AtImmediate_AtFinish_NoTrans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 8, S_OK},
     {"Script_SegBoundaries_Play_AtImmediate_AtFinish_Trans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 9, S_OK},
     {"Script_SegBoundaries_Play_AtBeat_AtMeasure_NoTrans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 10, S_OK},
     {"Script_SegBoundaries_Play_AtBeat_AtMeasure_Trans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 11, S_OK},

     //Verify flag boundaries override default segment boundaries on STOP
     {"Script_SegBoundaries_Stop_AtMeasure_AtImmediate_NoTrans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 100, S_OK},
     {"Script_SegBoundaries_Stop_AtMeasure_AtImmediate_Trans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 101, S_OK},
     {"Script_SegBoundaries_Stop_AtMeasure_AtGrid_NoTrans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 102, S_OK},
     {"Script_SegBoundaries_Stop_AtMeasure_AtGrid_Trans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 103, S_OK},
     {"Script_SegBoundaries_Stop_AtMeasure_AtBeat_NoTrans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 104, S_OK},
     {"Script_SegBoundaries_Stop_AtMeasure_AtBeat_Trans",     "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 105, S_OK},
     {"Script_SegBoundaries_Stop_AtImmediate_AtMeasure_NoTrans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 106, S_OK},
     {"Script_SegBoundaries_Stop_AtImmediate_AtMeasure_Trans","Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 107, S_OK},
     {"Script_SegBoundaries_Stop_AtImmediate_AtFinish_NoTrans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 108, S_OK},
     {"Script_SegBoundaries_Stop_AtImmediate_AtFinish_Trans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 109, S_OK},
     {"Script_SegBoundaries_Stop_AtBeat_AtMeasure_NoTrans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 110, S_OK},
     {"Script_SegBoundaries_Stop_AtBeat_AtMeasure_Trans", "Valid",  Script_CallRoutine_Valid_TestScript_SegBoundaries, 111, S_OK},


     //Script TRANSITION tests (with simple wave playback instead of cool music)!!
//     {"Script_TransSimple_PlayIntro(Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 500, S_OK},
//     {"Script_TransSimple_PlayIntro(SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 501, S_OK},
//     {"Script_TransSimple_PlayIntro(DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 502, S_OK},
//     {"Script_TransSimple_PlayFill (Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 510, S_OK},
//     {"Script_TransSimple_PlayFill (SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 511, S_OK},
//     {"Script_TransSimple_PlayFill (DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 512, S_OK},
//     {"Script_TransSimple_PlayBreak(Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 520, S_OK},
//     {"Script_TransSimple_PlayBreak(SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 521, S_OK},
//     {"Script_TransSimple_PlayBreak(DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 522, S_OK},
//     {"Script_TransSimple_PlayEnd  (Startup)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 530, S_OK},
//     {"Script_TransSimple_PlayEnd  (SameSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 531, S_OK},
//     {"Script_TransSimple_PlayEnd  (DiffSeg)",        "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 532, S_OK},
//     {"Script_TransSimple_PlayEndAndIntro  (Startup)","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 540, S_OK},
//     {"Script_TransSimple_PlayEndAndIntro  (SameSeg)","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 541, S_OK},
//     {"Script_TransSimple_PlayEndAndIntro  (DiffSeg)","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 542, S_OK},

//     {"Script_TransSimple_AtMeasure_Startup",          "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 600, S_OK},
//     {"Script_TransSimple_AtMeasure_SameSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 601, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg",          "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 602, S_OK},
//     {"Script_TransSimple_AtMeasure_Startup_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 605, S_OK},
//     {"Script_TransSimple_AtMeasure_SameSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 606, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg_PlayIntro","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 608, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg_PlayBreak","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 609, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg_PlayFill", "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 610, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 611, S_OK},
//     {"Script_TransSimple_AtMeasure_SameSeg_PlayEndAndIntro","Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 612, S_OK},
//     {"Script_TransSimple_AtMeasure_DiffSeg_PlayEnd",  "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 613, S_OK},
//     {"Script_TransSimple_AtMeasure_End_PlayEnd",      "Valid",  Script_CallRoutine_Valid_TestScript_TransSimple, 615, S_OK},


    //Segment8 Tests
    //--------------
    {"Segment8_AddNotificationType_NoRestart(1,0)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    0},  
//    {"Segment8_AddNotificationType_NoRestart(2,0)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       0},
    {"Segment8_AddNotificationType_NoRestart(4,0)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           0},  
//    {"Segment8_AddNotificationType_NoRestart(7,0)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_ALL,               0},

    //Verify that removals work.
    {"Segment8_AddNotificationType_NoRestart(1,1)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    TESTNOTIFICATION_MEASUREANDBEAT},
//    {"Segment8_AddNotificationType_NoRestart(2,2)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       TESTNOTIFICATION_PERFORMANCE},
    {"Segment8_AddNotificationType_NoRestart(4,4)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           TESTNOTIFICATION_SEGMENT},
//    {"Segment8_AddNotificationType_NoRestart(7,7)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_ALL,               TESTNOTIFICATION_ALL},

    //Make sure that each removal.is the correct one.
//    {"Segment8_AddNotificationType_NoRestart(1,2)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_MEASUREANDBEAT,    TESTNOTIFICATION_PERFORMANCE},
//    {"Segment8_AddNotificationType_NoRestart(2,4)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_PERFORMANCE,       TESTNOTIFICATION_SEGMENT},
    {"Segment8_AddNotificationType_NoRestart(4,1)",       "Valid", Segment8_AddNotificationType_NoRestart, TESTNOTIFICATION_SEGMENT,           TESTNOTIFICATION_MEASUREANDBEAT},

    //Make sure that duplicate removals don't hurt anything
    {"Segment8_AddNotificationType_NoRestart(0,1)",       "Valid", Segment8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_MEASUREANDBEAT},
//    {"Segment8_AddNotificationType_NoRestart(0,2)",       "Valid", Segment8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_PERFORMANCE},
    {"Segment8_AddNotificationType_NoRestart(0,4)",       "Valid", Segment8_AddNotificationType_NoRestart, 0, TESTNOTIFICATION_SEGMENT},

    //Make sure all the notifications work after you restart a segment.
    {"Segment8_AddNotificationType_Restart(1,0)",       "Valid", Segment8_AddNotificationType_Restart, TESTNOTIFICATION_MEASUREANDBEAT,    0},  
//    {"Segment8_AddNotificationType_Restart(2,0)",       "Valid", Segment8_AddNotificationType_Restart, TESTNOTIFICATION_PERFORMANCE,       0},
    {"Segment8_AddNotificationType_Restart(4,0)",       "Valid", Segment8_AddNotificationType_Restart, TESTNOTIFICATION_SEGMENT,           0},  




//     {"Segment8_Compose_Valid",                       "Valid", Segment8_Compose_Valid, 0, 0},                                        //NOT A VALID TEST.
//     {"Segment8_Download_Test1_Valid",                "Valid", Segment8_Download_Test1_Valid, 0, 0},                          
//     {"Segment8_Download_Test2_Valid",                "Valid", Segment8_Download_Test2_Valid, 0, 0},                          
//     {"Segment8_Download_Test3_Valid",                "Valid", Segment8_Download_Test3_Valid, 0, 0},                          
//     {"Segment8_Download_Test4_Valid",                "Valid", Segment8_Download_Test4_Valid, 0, 0},                          
//     {"Segment8_Download_Segment8_Download_PreCache_NoCon",   "Valid", Segment8_Download_PreCache, (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming01/Streaming01a.sgt", (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming01/Streaming01b.sgt"},
//     {"Segment8_Download_Segment8_Download_PreCache_Con",     "Valid", Segment8_Download_PreCache, (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming02/Streaming02a.sgt", (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming02/Streaming02b.sgt"},
//     {"Segment8_Download_Segment8_Download_PreCache_Original","Valid", Segment8_Download_PreCache, (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming04/y_shaman.sgt", (DWORD)"DMusic/DMTest1/Segment8/Download/Streaming04/ssR0001.sgt"},
//     {"Segment8_Download_PreCache_Multiple01",   "Valid", Segment8_Download_PreCache_Multiple01, 0, 0},
  //   {"Segment8_Download_PreCache_Multiple02",   "Valid", Segment8_Download_PreCache_Multiple02, 0, 0},

//     {"Segment8_Unload_Test1_Valid",                  "Valid", Segment8_Unload_Test1_Valid, 0, 0},                            
//     {"Segment8_Unload_Test2_Valid",                  "Valid", Segment8_Unload_Test2_Valid, 0, 0},                            
//     {"Segment8_Unload_Test3_Valid",                  "Valid", Segment8_Unload_Test3_Valid, 0, 0},                            
//     {"Segment8_Unload_Test4_Valid",                  "Valid", Segment8_Unload_Test4_Valid, 0, 0},                                         
     {"Segment8_SetRepeats_Test1_Valid",              "Valid", Segment8_SetRepeats_Test1_Valid, 0, 0},
     {"Segment8_SetRepeats_Test2_Valid",              "Valid", Segment8_SetRepeats_Test2_Valid, 0, 0},
     {"Segment8_SetRepeats_Test3_Valid",              "Valid", Segment8_SetRepeats_Test3_Valid, 0, 0},
     {"Segment8_SetRepeats_Test4_Valid",              "Valid", Segment8_SetRepeats_Test4_Valid, 0, 0},
     {"Segment8_SetRepeats_Test5_Valid",              "Valid", Segment8_SetRepeats_Test5_Valid, 0, 0},
     {"Segment8_SetRepeats_Test6_Valid",              "Valid", Segment8_SetRepeats_Test6_Valid, 0, 0},
     {"Segment8_GetLength_Valid",                     "Valid", Segment8_GetLength_Valid, 0, 0},                          //PASSES!
     {"Segment8_SetLength_Test1_Valid",               "Valid", Segment8_SetLength_Test1_Valid, 0, 0},
     {"Segment8_SetLength_Range(DMUS_PPQ-1)",         "Valid", Segment8_SetLength_Range, DMUS_PPQ-1, 0},
     {"Segment8_SetLength_Range(DMUS_PPQ)",           "Valid", Segment8_SetLength_Range, DMUS_PPQ,   0},
     {"Segment8_SetLength_Range(DMUS_PPQ+1)",         "Valid", Segment8_SetLength_Range, DMUS_PPQ+1, 0},
     {"Segment8_SetLength_Range(0x7FFFFFFF)",         "Valid", Segment8_SetLength_Range, 0x7FFFFFFF, 0},

     {"Segment8_GetClockTimeLength_VerifyLength(mt_1Bar.sgt)",            "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_1Bar.sgt",                (DWORD)&rt0}, 
     {"Segment8_GetClockTimeLength_VerifyLength(mt_1BarExtended.sgt)",    "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_1BarExtended.sgt",        (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(mt_1BarWaveTrack.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_1BarWaveTrack.sgt",       (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(mt_2Bars.sgt)",           "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_2Bars.sgt",               (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(mt_2BarsLoopingInfinite.sgt)", "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_2BarsLoopingInfinite.sgt", (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(mt_2BarsLoopingOnce.sgt)","Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/mt_2BarsLoopingOnce.sgt",    (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m000s000ms.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m000s000ms.sgt",       (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m000s001ms.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m000s001ms.sgt",       (DWORD)&rt10000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m000s777ms.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m000s777ms.sgt",       (DWORD)&rt7770000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m001s000ms_Ext1.sgt)", "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m001s000ms_Ext1.sgt", (DWORD)&rt10000000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m001s000ms_Ext2.sgt)", "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m001s000ms_Ext2.sgt", (DWORD)&rt10000000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m001s000ms_Pkup.sgt)","Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m001s000ms_Pkup.sgt",  (DWORD)&rt10000000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_000m059s999ms.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_000m059s999ms.sgt",       (DWORD)&rt599990000},
     {"Segment8_GetClockTimeLength_VerifyLength(rt_999m059s999ms.sgt)",   "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/rt_999m059s999ms.sgt",       (DWORD)&rt0x7FFFFFFFFFFFFFFF},

//Supposedly these aren't valid cases either!  (see comments in bug 5287)
//     {"Segment8_GetClockTimeLength_VerifyLength(1sample.wav)",            "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/1sample.wav",                (DWORD)&rt208}, //actually 208 1/3 per sample at 48k
//     {"Segment8_GetClockTimeLength_VerifyLength(4samples.wav)",           "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/4samples.wav",               (DWORD)&rt833},
//     {"Segment8_GetClockTimeLength_VerifyLength(5samples.wav)",           "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/5samples.wav",               (DWORD)&rt1041},

     {"Segment8_GetClockTimeLength_VerifyLength(48000Samples.wav)",       "Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/48000Samples.wav",           (DWORD)&rt10000000},
     {"Segment8_GetClockTimeLength_VerifyLength(48000SamplesLooping.wav)","Valid", Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/48000SamplesLooping.wav",    (DWORD)&rt0x7FFFFFFFFFFFFFFF},
     {"Segment8_GetClockTimeLength_VerifyLength(480000Samples.wav)","Valid",Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/480000Samples.wav",                 (DWORD)&rt100000000},
     {"Segment8_GetClockTimeLength_VerifyLength(480000SamplesLooping.wav)","Valid",Segment8_GetClockTimeLength_VerifySegmentLength, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/480000SamplesLooping.wav",   (DWORD)&rt100000000},

     {"Segment8_GetClockTimeLength_GetSet(0,0)",      "Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/1Sample.wav",  (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_GetSet(0,1)",      "Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/1Sample.wav",  (DWORD)&rt1},
     {"Segment8_GetClockTimeLength_GetSet(0,10000000)","Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/1Sample.wav",  (DWORD)&rt10000000},
     {"Segment8_GetClockTimeLength_GetSet(1,0)",      "Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/48000Samples.wav",  (DWORD)&rt0},
     {"Segment8_GetClockTimeLength_GetSet(1,1)",      "Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/48000Samples.wav",  (DWORD)&rt1},
     {"Segment8_GetClockTimeLength_GetSet(1,10000000)","Valid", Segment8_GetClockTimeLength_GetSet, (DWORD)"DMusic/DMTest1/Segment8/GetClockTimeLength/48000Samples.wav",  (DWORD)&rt10000000},


     //Function naming "DLS" and "1Measure" signifies the type of segment and where the start point is set.
     //The two parameters are used to set the loop points, which must be tested in combination with the start points.
     // -1 for both loop points means "don't call SetLoopPoints"
     
     
     //Start points set, no looping.
     {"Segment8_SetStartPoint_DLS_1Measure_NoLoop",           "Valid", Segment8_SetStartPoint_DLS_1Measure, -1, -1},    //No looping.
     {"Segment8_SetStartPoint_DLS_2Measure_NoLoop",           "Valid", Segment8_SetStartPoint_DLS_2Measure, -1, -1},    
     {"Segment8_SetStartPoint_DLS_5Measure_NoLoop",           "Valid", Segment8_SetStartPoint_DLS_5Measure, -1, -1},    
     {"Segment8_SetStartPoint_DLS_EndMinus1_NoLoop",          "Valid", Segment8_SetStartPoint_DLS_EndMinus1,-1, -1},    
     {"Segment8_SetStartPoint_DLS_1Measure_2_4",              "Valid", Segment8_SetStartPoint_DLS_1Measure, 2, 4},    //Start before the loop starts.
     {"Segment8_SetStartPoint_DLS_1Measure_1_4",              "Valid", Segment8_SetStartPoint_DLS_1Measure, 1, 4},    //Start at the beginning of the loop.
     {"Segment8_SetStartPoint_DLS_2Measure_1_4",              "Valid", Segment8_SetStartPoint_DLS_2Measure, 1, 4},    //Start in the middle of the loop.
     {"Segment8_SetStartPoint_DLS_5Measure_1_5",              "Valid", Segment8_SetStartPoint_DLS_5Measure, 1, 5},    //Start at the end of the loop.
     {"Segment8_SetStartPoint_DLS_5Measure_1_4",              "Valid", Segment8_SetStartPoint_DLS_5Measure, 1, 4},    //Start past the end of the loop.

     {"Segment8_SetStartPoint_WaveSeg_1Measure_NoLoop",           "Valid", Segment8_SetStartPoint_WaveSeg_1Measure, -1, -1},    //No looping.
     {"Segment8_SetStartPoint_WaveSeg_2Measure_NoLoop",           "Valid", Segment8_SetStartPoint_WaveSeg_2Measure, -1, -1},    
     {"Segment8_SetStartPoint_WaveSeg_5Measure_NoLoop",           "Valid", Segment8_SetStartPoint_WaveSeg_5Measure, -1, -1},    
     {"Segment8_SetStartPoint_WaveSeg_EndMinus1_NoLoop",          "Valid", Segment8_SetStartPoint_WaveSeg_EndMinus1,-1, -1},    
     {"Segment8_SetStartPoint_WaveSeg_1Measure_2_4",              "Valid", Segment8_SetStartPoint_WaveSeg_1Measure, 2, 4},    //Start before the loop starts.
     {"Segment8_SetStartPoint_WaveSeg_1Measure_1_4",              "Valid", Segment8_SetStartPoint_WaveSeg_1Measure, 1, 4},    //Start at the beginning of the loop.
     {"Segment8_SetStartPoint_WaveSeg_2Measure_1_4",              "Valid", Segment8_SetStartPoint_WaveSeg_2Measure, 1, 4},    //Start in the middle of the loop.
     {"Segment8_SetStartPoint_WaveSeg_5Measure_1_5",              "Valid", Segment8_SetStartPoint_WaveSeg_5Measure, 1, 5},    //Start at the end of the loop.
     {"Segment8_SetStartPoint_WaveSeg_5Measure_1_4",              "Valid", Segment8_SetStartPoint_WaveSeg_5Measure, 1, 4},    //Start past the end of the loop.

     {"Segment8_GetStartPoint_Generic_Measure1",               "Valid", Segment8_GetStartPoint_Generic, (DWORD)"DMusic/DMTest1/Segment8/GetSetStartPoint/SegStartPoint_Measure1.sgt", 0 * 4 * DMUS_PPQ},
     {"Segment8_GetStartPoint_Generic_Measure2",               "Valid", Segment8_GetStartPoint_Generic, (DWORD)"DMusic/DMTest1/Segment8/GetSetStartPoint/SegStartPoint_Measure2.sgt", 1 * 4 * DMUS_PPQ},
     {"Segment8_GetStartPoint_Generic_Wave",                   "Valid", Segment8_GetStartPoint_Generic, (DWORD)"DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav",               0 * 4 * DMUS_PPQ},

/*
     {"Segment8_SetClockTimeLoopPoints_DLS(0,1)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 0,        10000000},
     {"Segment8_SetClockTimeLoopPoints_DLS(0,6)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 0,        60000000},
     {"Segment8_SetClockTimeLoopPoints_DLS(1,6)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 10000000, 60000000},
     {"Segment8_SetClockTimeLoopPoints_DLS(5,6)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 50000000, 60000000},

     {"Segment8_SetClockTimeLoopPoints_WaveSeg(0,1)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 0,        10000000},
     {"Segment8_SetClockTimeLoopPoints_WaveSeg(0,6)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 0,        60000000},
     {"Segment8_SetClockTimeLoopPoints_WaveSeg(1,6)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 10000000, 60000000},
     {"Segment8_SetClockTimeLoopPoints_WaveSeg(5,6)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 50000000, 60000000},

     {"Segment8_SetClockTimeLoopPoints_Wave(0,1)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 0,        10000000},
     {"Segment8_SetClockTimeLoopPoints_Wave(0,6)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 0,        60000000},
     {"Segment8_SetClockTimeLoopPoints_Wave(1,6)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 10000000, 60000000},
     {"Segment8_SetClockTimeLoopPoints_Wave(5,6)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 50000000, 60000000},

//     {"Segment8_SetClockTimeLoopPoints_SetsClockTimeMode",   "Valid", Segment8_SetClockTimeLoopPoints_SetsClockTimeMode, 0, 0},
     {"Segment8_SetClockTimeLoopPoints_KeepsLength",         "Valid", Segment8_SetClockTimeLoopPoints_KeepsLength, 0, 0},    
     {"Segment8_GetClockTimeLoopPoints_SetAndGet",          "Valid",  Segment8_GetClockTimeLoopPoints_SetAndGet,  0, 0},    
*/

//     {"Segment8_SetWavePlaybackParams_WAVEF_OFF(normal)",    "Valid",  Segment8_SetWavePlaybackParams_WAVEF_OFF, (DWORD)"WAV/CountTo3.wav", 0},    
//     {"Segment8_SetWavePlaybackParams_WAVEF_OFF(looping)",   "Valid",  Segment8_SetWavePlaybackParams_WAVEF_OFF, (DWORD)"WAV/Loop3Times.wav", 0},    

/*
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingOFF_RA0", "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingOFF, DMUS_READAHEAD_MIN, 1808322},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON_RA0" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON,  DMUS_READAHEAD_MIN, 934 + 44100 * 2 * 2 / 20 * 2},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingOFF_RA0", "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingOFF,         DMUS_READAHEAD_MIN, 546884},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingON_RA0" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingON,          DMUS_READAHEAD_MIN, 934 + 44100 * 2 * 2 / 20 * 2},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON_RA1s" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON, 1000,   44100 * 2 * 2 * 1 * 2},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON_RA4s" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON, 4000,   44100 * 2 * 2 * 4 * 2},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON_RA10s" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON, 10000, 44100 * 2 * 2 * 10 * 2},
     {"Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON_RA20s" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON, 20000, 44100 * 2 * 2 * 20 * 2},
*/
     
     {"Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE_FALSE" , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE, FALSE, 0},
     {"Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE_TRUE"  , "Valid",  Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE, TRUE,  0},


#define CUTOFF 0
#define NOCUT 1
#define NOCHANGE 2

     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(CUTOFF,CUTOFF)" ,     "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, CUTOFF, CUTOFF},
     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(CUTOFF,NOCUT)" ,      "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, CUTOFF, NOCUT},
     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(CUTOFF,NOCHANGE)" ,   "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, CUTOFF, NOCHANGE},
     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(NOCUT,CUTOFF)" ,      "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, NOCUT, CUTOFF},
     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(NOCUT,NOCUT)" ,       "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, NOCUT, NOCUT},
     {"Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS_FALSE(NOCUT,NOCHANGE)" ,    "Valid",  Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS, NOCUT, NOCHANGE},

#undef NOCHANGE 
#undef CUTOFF 
#undef NOCUT 


     {"Segment8_GetRepeats_Content(0)" ,            "Valid",  Segment8_GetRepeats_Content, 0,          NULL},
     {"Segment8_GetRepeats_Content(1)" ,            "Valid",  Segment8_GetRepeats_Content, 1,          NULL},
     {"Segment8_GetRepeats_Content(2)" ,            "Valid",  Segment8_GetRepeats_Content, 2,          NULL},
     {"Segment8_GetRepeats_Content(32767)" ,        "Valid",  Segment8_GetRepeats_Content, 32767,      NULL},
     {"Segment8_GetRepeats_Content(0xFFFFFFFF)" ,   "Valid",  Segment8_GetRepeats_Content, 0xFFFFFFFF, NULL},
     {"Segment8_GetRepeats_Programmatic" ,          "Valid",  Segment8_GetRepeats_Programmatic, NULL, NULL},


//Invalid test cases
//     {"Segment8_SetClockTimeLoopPoints_DLS(0,8)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 0,        80000000},
//     {"Segment8_SetClockTimeLoopPoints_DLS(7,8)",   "Valid", Segment8_SetClockTimeLoopPoints_DLS, 60000000, 80000000},
//     {"Segment8_SetStartPoint_DLS_2Measure_1_4",           "Valid", Segment8_SetStartPoint_DLS_1Measure, 1, 6},    //Start in the middle of the loop.
//     {"Segment8_SetClockTimeLoopPoints_WaveSeg(0,8)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 0,        80000000},
//     {"Segment8_SetClockTimeLoopPoints_WaveSeg(7,8)",   "Valid", Segment8_SetClockTimeLoopPoints_WaveSeg, 60000000, 80000000},
//     {"Segment8_SetClockTimeLoopPoints_Wave(0,8)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 0,        80000000},
//     {"Segment8_SetClockTimeLoopPoints_Wave(7,8)",   "Valid", Segment8_SetClockTimeLoopPoints_Wave, 60000000, 80000000},



    //SegmentState8 Tests
    //-------------------
     {"SegmentState_GetObjectInPath_Valid",           "Valid", SegmentState_GetObjectInPath_Valid, 0, 0},                  
     {"SegmentState_GetSegment_Valid",                "Valid", SegmentState_GetSegment_Valid, 0, 0},
     {"SegmentState_GetStartTime_Valid",              "Valid", SegmentState_GetStartTime_Valid, 0, 0},

    {"SegmentState_SetVolume_Valid_Ramp_0ms",            "Valid", SegmentState_SetVolume_Valid_Ramp, 0,      DMUS_APATH_DYNAMIC_MONO},
    {"SegmentState_SetVolume_Valid_Ramp_1ms",            "Valid", SegmentState_SetVolume_Valid_Ramp, 1,      DMUS_APATH_DYNAMIC_MONO},
    {"SegmentState_SetVolume_Valid_Ramp_1000ms",         "Valid", SegmentState_SetVolume_Valid_Ramp, 1000,   DMUS_APATH_DYNAMIC_MONO},
    {"SegmentState_SetVolume_Valid_Ramp_10000ms",        "Valid", SegmentState_SetVolume_Valid_Ramp, 10000,  DMUS_APATH_DYNAMIC_MONO},
    {"SegmentState_SetVolume_Valid_Ramp_ULONG_MAXms",    "Valid", SegmentState_SetVolume_Valid_Ramp, ULONG_MAX,DMUS_APATH_DYNAMIC_MONO},
    {"SegmentState_SetVolume_Valid_Ramp_0ms_STEREOPLUSREVERB",            "Valid", SegmentState_SetVolume_Valid_Ramp, 0,      DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"SegmentState_SetVolume_Valid_Ramp_1ms_STEREOPLUSREVERB",            "Valid", SegmentState_SetVolume_Valid_Ramp, 1,      DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"SegmentState_SetVolume_Valid_Ramp_1000ms_STEREOPLUSREVERB",         "Valid", SegmentState_SetVolume_Valid_Ramp, 1000,   DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"SegmentState_SetVolume_Valid_Ramp_10000ms_STEREOPLUSREVERB",        "Valid", SegmentState_SetVolume_Valid_Ramp, 10000,  DMUS_APATH_SHARED_STEREOPLUSREVERB},
    {"SegmentState_SetVolume_Valid_Ramp_ULONG_MAXms_STEREOPLUSREVERB",    "Valid", SegmentState_SetVolume_Valid_Ramp, ULONG_MAX,DMUS_APATH_SHARED_STEREOPLUSREVERB},

    {"SegmentState_SetPitch_Valid_Ramp_0ms(listen)",    "Valid", SegmentState_SetPitch_Valid_Ramp, 0,      2400},
    {"SegmentState_SetPitch_Valid_Ramp_1000ms(listen)", "Valid", SegmentState_SetPitch_Valid_Ramp, 1000,   2400},
    {"SegmentState_SetPitch_Valid_Ramp_10000ms(listen)","Valid", SegmentState_SetPitch_Valid_Ramp, 10000,  2400},

    //ToolGraph tests
    //---------------
    {"ToolGraph_InsertTool_Valid",                    "Valid" , ToolGraph_InsertTool_Valid, 0, 0},   
    {"ToolGraph_StampPMsg_Valid",                     "Valid" , ToolGraph_StampPMsg_Valid, 0, 0},
    {"ToolGraph_RemoveTool_Valid",                    "Valid" , ToolGraph_RemoveTool_Valid, 0, 0},
    {"ToolGraph_GetTool_Valid",                       "Valid" , ToolGraph_GetTool_Valid, 0, 0},

    {"Sleep_Zero",                       "Valid" , Sleep_Zero, 0, 0},



/******************************************************************************************
PERFORMANCE_MEMORY TEST CASES
******************************************************************************************/
//     {"Loader_GetObject_PerfMem_DownloadWaveLeak(one-shot)",  "PerfMem", Loader_GetObject_PerfMem_DownloadWaveLeak, FALSE, 0},
//     {"Loader_GetObject_PerfMem_DownloadWaveLeak(streaming)", "PerfMem", Loader_GetObject_PerfMem_DownloadWaveLeak, TRUE,  0},

     {"Loader_GetObject_PerfMem_Type_Full(IndAudioPath)"    , "PerfMem", Loader_GetObject_PerfMem_Type_Full,            (DWORD)"DMusic/DMTest1/Loader/Perf/IndAudioPath.aud", 0},
//     {"Loader_GetObject_PerfMem_Type_Full(IndBand)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,          (DWORD)"DMusic/DMTest1/Loader/Perf/IndBand.bnd", 0},
     {"Loader_GetObject_PerfMem_Type_Full(IndChordmap)"     , "PerfMem", Loader_GetObject_PerfMem_Type_Full,            (DWORD)"DMusic/DMTest1/Loader/Perf/IndChordmap.cdm", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ContainerEmbedIndSegment)"  , "PerfMem", Loader_GetObject_PerfMem_Type_Full,  (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerEmbedIndSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ContainerEmbedRefSegment)"  , "PerfMem", Loader_GetObject_PerfMem_Type_Full,  (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerEmbedRefSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ContainerRefRefSegment)"    , "PerfMem", Loader_GetObject_PerfMem_Type_Full,  (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerRefRefSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Full(DLS)"         ,     "PerfMem", Loader_GetObject_PerfMem_Type_Full,            (DWORD)"DMusic/DMTest1/Loader/Perf/DLS.dls", 0},
     {"Loader_GetObject_PerfMem_Type_Full(IndSegment)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,         (DWORD)"DMusic/DMTest1/Loader/Perf/IndSegment.sgt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(RefSegment)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,         (DWORD)"DMusic/DMTest1/Loader/Perf/RefSegment.sgt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ScriptNoRef)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,        (DWORD)"DMusic/DMTest1/Loader/Perf/ScriptNoRef.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ScriptEmbedIndSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Full,      (DWORD)"DMusic/DMTest1/Loader/Perf/ScriptEmbedIndSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ScriptEmbedRefSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Full,      (DWORD)"DMusic/DMTest1/Loader/Perf/ScriptEmbedRefSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(ScriptRefRefSegment)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,(DWORD)"DMusic/DMTest1/Loader/Perf/ScriptRefRefSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Full(IndStyle)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Full,           (DWORD)"DMusic/DMTest1/Loader/Perf/IndStyle.sty", 0},
     {"Loader_GetObject_PerfMem_Type_Full(Shortwave)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Full,             (DWORD)"WAV/ShortWave.wav", 0},
//     {"Loader_GetObject_PerfMem_Type_Full(16MB_OneShot)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Full,        (DWORD)"WAV/16MB_OneShot.wav", 0}, //Can't load a band anymore
     {"Loader_GetObject_PerfMem_Type_Full(Streaming)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Full,             (DWORD)"WAV/Streaming10s.wav", 0},
     {"Loader_GetObject_PerfMem_Type_Full(LoopForever)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Full,           (DWORD)"WAV/LoopForever.wav", 0},
     {"Loader_GetObject_PerfMem_Type_Full(SegEmbedWave)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Full,          (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt", 0},



     {"Loader_GetObject_PerfMem_Type_Partial(IndAudioPath)"    , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,      (DWORD)"DMusic/DMTest1/Loader/Perf/IndAudioPath.aud", 0},
//     {"Loader_GetObject_PerfMem_Type_Partial(IndBand)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,    (DWORD)"DMusic/DMTest1/Loader/Perf/IndBand.bnd", 0}, //Can't load a band anymore
     {"Loader_GetObject_PerfMem_Type_Partial(IndChordmap)"     , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,      (DWORD)"DMusic/DMTest1/Loader/Perf/IndChordmap.cdm", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ContainerEmbedIndSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Partial, (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerEmbedIndSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ContainerEmbedRefSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Partial, (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerEmbedRefSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ContainerRefRefSegment)"   , "PerfMem", Loader_GetObject_PerfMem_Type_Partial, (DWORD)"DMusic/DMTest1/Loader/Perf/ContainerRefRefSegment.con", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(DLS)"         ,     "PerfMem", Loader_GetObject_PerfMem_Type_Partial,      (DWORD)"DMusic/DMTest1/Loader/Perf/DLS.dls", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(IndSegment)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,   (DWORD)"DMusic/DMTest1/Loader/Perf/IndSegment.sgt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(RefSegment)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,   (DWORD)"DMusic/DMTest1/Loader/Perf/RefSegment.sgt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ScriptNoRef)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,  (DWORD)"DMusic/DMTest1/Loader/Perf/ScriptNoRef.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ScriptEmbedIndSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,(DWORD)"DMusic/DMTest1/Loader/Perf/ScriptEmbedIndSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ScriptEmbedRefSegment)" , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,(DWORD)"DMusic/DMTest1/Loader/Perf/ScriptEmbedRefSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(ScriptRefRefSegment)"   , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,(DWORD)"DMusic/DMTest1/Loader/Perf/ScriptRefRefSegment.spt", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(IndStyle)"         , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,     (DWORD)"DMusic/DMTest1/Loader/Perf/IndStyle.sty", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(Shortwave)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,       (DWORD)"WAV/ShortWave.wav", 0},
//     {"Loader_GetObject_PerfMem_Type_Partial(16MB_OneShot)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,  (DWORD)"WAV/16MB_OneShot.wav", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(Streaming)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,       (DWORD)"WAV/Streaming10s.wav", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(LoopForever)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,     (DWORD)"WAV/LoopForever.wav", 0},
     {"Loader_GetObject_PerfMem_Type_Partial(SegEmbedWave)"      , "PerfMem", Loader_GetObject_PerfMem_Type_Partial,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt", 0},

    //CreateStandardAudioPath    
     {"Performance8_CreateStandardAudioPath_PerfMem(STEREOPLUSREVERB,FULL)",         "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    TRUE, DMUS_APATH_SHARED_STEREOPLUSREVERB},
     {"Performance8_CreateStandardAudioPath_PerfMem(STEREOPLUSREVERB,PARTIAL)",      "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    FALSE, DMUS_APATH_SHARED_STEREOPLUSREVERB},
     {"Performance8_CreateStandardAudioPath_PerfMem(STEREO,FULL)",                   "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    TRUE, DMUS_APATH_SHARED_STEREO},
     {"Performance8_CreateStandardAudioPath_PerfMem(STEREO,PARTIAL)",                "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    FALSE, DMUS_APATH_SHARED_STEREO},
     {"Performance8_CreateStandardAudioPath_PerfMem(3D,FULL)",                       "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    TRUE, DMUS_APATH_DYNAMIC_3D},
     {"Performance8_CreateStandardAudioPath_PerfMem(3D,PARTIAL)",                    "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    FALSE, DMUS_APATH_DYNAMIC_3D},
     {"Performance8_CreateStandardAudioPath_PerfMem(MONO,FULL)",                     "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    TRUE, DMUS_APATH_DYNAMIC_MONO},
     {"Performance8_CreateStandardAudioPath_PerfMem(MONO,PARTIAL)",                  "PerfMem", Performance8_CreateStandardAudioPath_PerfMem,    FALSE, DMUS_APATH_DYNAMIC_MONO},

     {"Performance8_CreateStandardAudioPath_PerfMem_Bug10385(20,DMUS_APATH_SHARED_STEREOPLUSREVERB)",   "PerfMem", Performance8_CreateStandardAudioPath_PerfMem_Bug10385, 1, DMUS_APATH_DYNAMIC_MONO},
    
    
    //PlaySegmentEx
//     {"Performance8_PlaySegmentEx_PerfMem(Seg16MBDLS,FULL)",         "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/Seg16MBDLS.sgt",         TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegChordmap,FULL)",        "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegChordmap.sgt",        TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegTriggering,FULL)",      "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegTriggering.sgt",      TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveLoopForever,FULL)", "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveLoopForever.sgt", TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveShort,FULL)",       "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveShort.sgt",       TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveStreaming10s,FULL)","PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveStreaming10s.sgt",TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegEmbedWave,FULL)",       "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt"       ,TRUE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(IndSegment,FULL)"        , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/IndSegment.sgt",       TRUE},
     {"Performance8_PlaySegmentEx_PerfMem(RefSegment,FULL)"        , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/RefSegment.sgt",       TRUE},
     {"Performance8_PlaySegmentEx_PerfMem(Shortwave,FULL)"         , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"WAV/ShortWave.wav",                            TRUE},
//     {"Performance8_PlaySegmentEx_PerfMem(16MB_OneShot,FULL)"      , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"WAV/16MB_OneShot.wav",                         TRUE},
     {"Performance8_PlaySegmentEx_PerfMem(Streaming,FULL)"         , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"WAV/Streaming10s.wav",                         TRUE},
     {"Performance8_PlaySegmentEx_PerfMem(LoopForever,FULL)"       , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"WAV/LoopForever.wav",                          TRUE},
     {"Performance8_PlaySegmentEx_PerfMem(48_16_2,FULL)"           , "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"WAV/48_16_2.wav",                              TRUE},

//     {"Performance8_PlaySegmentEx_PerfMem(Seg16MBDLS,PARTIAL)",         "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/Seg16MBDLS.sgt",      FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegChordmap,PARTIAL)",        "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegChordmap.sgt",     FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegTriggering,PARTIAL)",      "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegTriggering.sgt",   FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveLoopForever,PARTIAL)", "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveLoopForever.sgt",FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveShort,PARTIAL)",       "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveShort.sgt",    FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegWaveStreaming10s,PARTIAL)","PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveStreaming10s.sgt",FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(SegEmbedWave,PARTIAL)",       "PerfMem", Performance8_PlaySegmentEx_PerfMem,    (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt"       ,FALSE}, //Play all the way.
     {"Performance8_PlaySegmentEx_PerfMem(IndSegment,PARTIAL)"     ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/IndSegment.sgt",       FALSE},
     {"Performance8_PlaySegmentEx_PerfMem(RefSegment,PARTIAL)"     ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/RefSegment.sgt",       FALSE},
     {"Performance8_PlaySegmentEx_PerfMem(Shortwave,PARTIAL)"      ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"WAV/ShortWave.wav",                            FALSE},
//     {"Performance8_PlaySegmentEx_PerfMem(16MB_OneShot,PARTIAL)"   ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"WAV/16MB_OneShot.wav",                         FALSE},
     {"Performance8_PlaySegmentEx_PerfMem(Streaming,PARTIAL)"      ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"WAV/Streaming10s.wav",                         FALSE},
     {"Performance8_PlaySegmentEx_PerfMem(LoopForever,PARTIAL)"    ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"WAV/LoopForever.wav",                          FALSE},
     {"Performance8_PlaySegmentEx_PerfMem(48_16_2,PARTIAL)"        ,    "PerfMem", Performance8_PlaySegmentEx_PerfMem, (DWORD)"WAV/48_16_2.wav",                              FALSE},

     {"Performance8_PlaySegmentEx_StartStopStreaming_PerfMem",  "PerfMem", Performance8_PlaySegmentEx_StartStopStreaming_PerfMem, 0, 0},

     //SegmentState8
     {"SegmentState_GetSegment_PerfMem(PARTIAL)"                   ,"PerfMem", SegmentState_GetSegment_PerfMem, FALSE,0},
     {"SegmentState_GetSegment_PerfMem(FULL)"                      ,"PerfMem", SegmentState_GetSegment_PerfMem, TRUE, 0},

    //Script
     {"Script_CallRoutine_PerfMem1_Full(Routines,0)",    "PerfMem", Script_CallRoutine_PerfMem1_Full,    (DWORD)"DMusic/DMTest1/script/perfmem/Routines.spt", 0},
     {"Script_CallRoutine_PerfMem1_Full(Routines,1)",    "PerfMem", Script_CallRoutine_PerfMem1_Full,    (DWORD)"DMusic/DMTest1/script/perfmem/Routines.spt", 1},
     {"Script_CallRoutine_PerfMem1_Partial(Routines,0)", "PerfMem", Script_CallRoutine_PerfMem1_Partial, (DWORD)"DMusic/DMTest1/script/perfmem/Routines.spt", 0},
     {"Script_CallRoutine_PerfMem1_Partial(Routines,1)", "PerfMem", Script_CallRoutine_PerfMem1_Partial, (DWORD)"DMusic/DMTest1/script/perfmem/Routines.spt", 1},

    // More script Tests
    //-------------------
     {"Script_PerfMem_AudioPath_SetGetVolume(FULL)",          "PerfMem",  Script_CallRoutine_PerfMem_TestScript,   0, TRUE},
     {"Script_PerfMem_AudioPath_SetVolumeListeningTest(FULL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,   1, TRUE},
     {"Script_PerfMem_AudioPathConfig_Create(FULL)",          "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  10, TRUE},
     {"Script_PerfMem_AudioPathConfig_Load(FULL)",            "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  11, TRUE},
     {"Script_PerfMem_Segment_PlayStop(FULL)",                "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  20, TRUE},
     {"Script_PerfMem_Performance_SetMasterGrooveLevel(FULL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,  30, TRUE},
     {"Script_PerfMem_Performance_SetMasterTempo(DLS)(FULL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  32, TRUE},
     {"Script_PerfMem_Performance_SetMasterTempo(WAVE)(FULL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,  33, TRUE},
     {"Script_PerfMem_Performance_GetMasterTempo(FULL)",      "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  34, TRUE},
     {"Script_PerfMem_Performance_SetMasterTranspose(FULL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  35, TRUE},
     {"Script_PerfMem_Performance_GetMasterTranspose(FULL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  36, TRUE},
     {"Script_PerfMem_Performance_Rand(FULL)",                "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  37, TRUE},
     {"Script_PerfMem_PlayingSegment_IsPlaying(VerifyTrue)(FULL)", "PerfMem",Script_CallRoutine_PerfMem_TestScript,50,TRUE},
     {"Script_PerfMem_PlayingSegment_IsPlaying(VerifyFalse)(FULL)","PerfMem",Script_CallRoutine_PerfMem_TestScript,51,TRUE},
     {"Script_PerfMem_PlayingSegment_Stop(FULL)",             "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  52, TRUE},
     {"Script_PerfMem_AutoLoadUnchecked_SegmentNoLoad(FULL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 100, TRUE},
     {"Script_PerfMem_AutoLoadUnchecked_SegmentLoad(FULL)",   "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 101, TRUE},
     {"Script_PerfMem_AutoLoadUnchecked_AudioPathNoLoad(FULL)","PerfMem", Script_CallRoutine_PerfMem_TestScript, 102, TRUE},
     {"Script_PerfMem_AutoLoadUnchecked_AudioPathLoad(FULL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 103, TRUE},
     {"Script_PerfMem_AutoLoadChecked_SegmentLoad(FULL)",     "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 110, TRUE},
     {"Script_PerfMem_AutoLoadChecked_AudioPathLoad(FULL)",   "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 111, TRUE},
     {"Script_PerfMem_AutoDownloadUnchecked_NoDownload(FULL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript, 120, TRUE},
     {"Script_PerfMem_AutoDownloadUnchecked_Download(FULL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 121, TRUE},
     {"Script_PerfMem_AutoDownloadUnchecked_Unload(FULL)",    "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 122, TRUE},
     {"Script_PerfMem_EmbeddedContent(FULL)",                 "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 150, TRUE},
     {"Script_PerfMem_Recompose(FULL)",                       "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 160, TRUE},

     {"Script_PerfMem_AudioPath_SetGetVolume(PARTIAL)",          "PerfMem",  Script_CallRoutine_PerfMem_TestScript,   0, FALSE},
     {"Script_PerfMem_AudioPath_SetVolumeListeningTest(PARTIAL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,   1, FALSE},
     {"Script_PerfMem_AudioPathConfig_Create(PARTIAL)",          "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  10, FALSE},
     {"Script_PerfMem_AudioPathConfig_Load(PARTIAL)",            "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  11, FALSE},
     {"Script_PerfMem_Segment_PlayStop(PARTIAL)",                "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  20, FALSE},
     {"Script_PerfMem_Performance_SetMasterGrooveLevel(PARTIAL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,  30, FALSE},
     {"Script_PerfMem_Performance_SetMasterTempo(DLS)(PARTIAL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  32, FALSE},
     {"Script_PerfMem_Performance_SetMasterTempo(WAVE)(PARTIAL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript,  33, FALSE},
     {"Script_PerfMem_Performance_GetMasterTempo(PARTIAL)",      "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  34, FALSE},
     {"Script_PerfMem_Performance_SetMasterTranspose(PARTIAL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  35, FALSE},
     {"Script_PerfMem_Performance_GetMasterTranspose(PARTIAL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  36, FALSE},
     {"Script_PerfMem_Performance_Rand(PARTIAL)",                "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  37, FALSE},
     {"Script_PerfMem_PlayingSegment_IsPlaying(VerifyTrue) (PARTIAL)","PerfMem",Script_CallRoutine_PerfMem_TestScript,50,FALSE},
     {"Script_PerfMem_PlayingSegment_IsPlaying(VerifyFalse)(PARTIAL)","PerfMem",Script_CallRoutine_PerfMem_TestScript,51,FALSE},
     {"Script_PerfMem_PlayingSegment_Stop(PARTIAL)",             "PerfMem",  Script_CallRoutine_PerfMem_TestScript,  52, FALSE},
     {"Script_PerfMem_AutoLoadUnchecked_SegmentNoLoad(PARTIAL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 100, FALSE},
     {"Script_PerfMem_AutoLoadUnchecked_SegmentLoad(PARTIAL)",   "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 101, FALSE},
     {"Script_PerfMem_AutoLoadUnchecked_AudioPathNoLoad(PARTIAL)","PerfMem", Script_CallRoutine_PerfMem_TestScript, 102, FALSE},
     {"Script_PerfMem_AutoLoadUnchecked_AudioPathLoad(PARTIAL)", "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 103, FALSE},
     {"Script_PerfMem_AutoLoadChecked_SegmentLoad(PARTIAL)",     "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 110, FALSE},
     {"Script_PerfMem_AutoLoadChecked_AudioPathLoad(PARTIAL)",   "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 111, FALSE},
     {"Script_PerfMem_AutoDownloadUnchecked_NoDownload(PARTIAL)","PerfMem",  Script_CallRoutine_PerfMem_TestScript, 120, FALSE},
     {"Script_PerfMem_AutoDownloadUnchecked_Download(PARTIAL)",  "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 121, FALSE},
     {"Script_PerfMem_AutoDownloadUnchecked_Unload(PARTIAL)",    "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 122, FALSE},
     {"Script_PerfMem_EmbeddedContent(PARTIAL)",                 "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 150, FALSE},
     {"Script_PerfMem_Recompose(PARTIAL)",                       "PerfMem",  Script_CallRoutine_PerfMem_TestScript, 160, FALSE},



/******************************************************************************************
INVALID TEST CASES
******************************************************************************************/
    {"AudioPath_GetObjectInPath_Invalid",            "Invalid",AudioPath_GetObjectInPath_Invalid, 0, 0},
    {"AudioPath_SetVolume_Invalid",                  "Invalid",AudioPath_SetVolume_Invalid, 0, 0},
    {"Performance8_AllocPMsg_Invalid",               "Invalid",Performance8_AllocPMsg_Invalid, 0, 0},
    {"Performance8_IsPlaying_Invalid",               "Invalid",Performance8_IsPlaying_Invalid, 0, 0},
    {"Performance8_PlaySegmentEx_Invalid(ContainsAP,10)","Invalid", Performance8_PlaySegmentEx_Valid_Play, (DWORD)"DMusic/DMTest1/Perf8/PlaySeg/Other/ContainsAudioPathConfig.sgt", 10}, //Play for 10 seconds.


    {"Loader8_LoadObjectFromFile_Invalid",           "Invalid",Loader8_LoadObjectFromFile_Invalid, 0, 0},
    {"Loader8_LoadObjectFromFile_Invalid_GMRef",     "Invalid",Loader8_LoadObjectFromFile_Invalid_GMRef, (DWORD)"DMusic/DMTest1/Loader/Inv_GMRefs/Inv_GMRefs.sgt", 0},
    {"Loader8_LoadObjectFromFile_TooLongPath",       "Invalid",Loader8_LoadObjectFromFile_TooLongPath, 0, 0},
    {"Loader8_LoadObjectFromFile_Invalid_Content",           "Invalid",Loader8_LoadObjectFromFile_Invalid_Content, 0, 0},

    {"Script_Invalid_NoAudioPath",                   "Invalid",Script_CallRoutine_Invalid_NoAudioPath, 20, DMUS_E_LOADER_FAILEDCREATE},
    {"Script_Invalid_EmbeddedContentMissing",        "Invalid",Script_CallRoutine_Invalid_TestScript, 150, DMUS_E_LOADER_FAILEDCREATE},
    {"Segment8_SetStartPoint_DLS_End_NoLoop",        "Invalid", Segment8_SetStartPoint_DLS_End,-1, -1},    

     {"Segment8_SetStartPoint_Wave_1Measure_NoLoop",           "Invalid", Segment8_SetStartPoint_Wave_1Measure, -1, -1},    //No looping.
     {"Segment8_SetStartPoint_Wave_2Measure_NoLoop",           "Invalid", Segment8_SetStartPoint_Wave_2Measure, -1, -1},    
     {"Segment8_SetStartPoint_Wave_5Measure_NoLoop",           "Invalid", Segment8_SetStartPoint_Wave_5Measure, -1, -1},    
     {"Segment8_SetStartPoint_Wave_EndMinus1_NoLoop",          "Invalid", Segment8_SetStartPoint_Wave_EndMinus1,-1, -1},    
     {"Segment8_SetStartPoint_Wave_1Measure_2_4",              "Invalid", Segment8_SetStartPoint_Wave_1Measure, 2, 4},    //Start before the loop starts.
     {"Segment8_SetStartPoint_Wave_1Measure_1_4",              "Invalid", Segment8_SetStartPoint_Wave_1Measure, 1, 4},    //Start at the beginning of the loop.
     {"Segment8_SetStartPoint_Wave_2Measure_1_4",              "Invalid", Segment8_SetStartPoint_Wave_2Measure, 1, 4},    //Start in the middle of the loop.
     {"Segment8_SetStartPoint_Wave_5Measure_1_5",              "Invalid", Segment8_SetStartPoint_Wave_5Measure, 1, 5},    //Start at the end of the loop.
     {"Segment8_SetStartPoint_Wave_5Measure_1_4",              "Invalid", Segment8_SetStartPoint_Wave_5Measure, 1, 4},    //Start past the end of the loop.

#define ONESHOT     0
#define STREAMING   1
#define MUSIC       2
#define MULTIPAN    3
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,4,OS)",       "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1,         ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,2,OS)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1_ENV,     ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,4,OS)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1_ENV,     ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,6,OS)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1_ENV,     ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,6,OS)", "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1,4,ST)",       "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1,         STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,2,ST)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_5DOT1_ENV,     STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,4,ST)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_5DOT1_ENV,     STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_ENV,6,ST)",   "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1_ENV,     STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_5DOT1_MUSIC,6,ST)", "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_5DOT1_MUSIC,   STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,6,OS)",        "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD,          ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,2,OS)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD_ENV,      ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,4,OS)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD_ENV,      ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,6,OS)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD_ENV,      ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,6,OS)",  "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD_MUSIC,    ONESHOT},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD,6,ST)",        "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD,          STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,2,ST)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_2, DMUS_APATH_MIXBIN_QUAD_ENV,      STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,4,ST)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_4, DMUS_APATH_MIXBIN_QUAD_ENV,      STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_ENV,6,ST)",    "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD_ENV,      STREAMING},
    {"Performance8_PlaySegmentEx_AudioPath(DMUS_APATH_MIXBIN_QUAD_MUSIC,6,ST)",  "Invalid", Performance8_PlaySegmentEx_AudioPath_6, DMUS_APATH_MIXBIN_QUAD_MUSIC,    STREAMING},

#undef STREAMING
#undef ONESHOT
#undef MUSIC
#undef PANNING 




    {"Fail_On_Purpose"                           ,   "Invalid",Fail_On_Purpose,    0, 0},


    
//    {"Performance8_InitAudio_Invalid",             "Invalid",Performance8_InitAudio_Invalid, 0, 0},


/******************************************************************************************
FATAL TEST CASES
******************************************************************************************/
    {"Script_CallRoutine_Fatal",                     "Fatal", Script_CallRoutine_Fatal, 0, 0},
    {"Script_Init_Fatal",                            "Fatal", Script_Init_Fatal, 0, 0},
//    {"Script_SetVariableObject_Fatal",             "Fatal", Script_SetVariableObject_Fatal, 0, 0},
//    {"Script_SetVariableNumber_Fatal",             "Fatal", Script_SetVariableNumber_Fatal, 0, 0}
};

DWORD g_dwNumTestCases = AMOUNT(g_TestCases);




/********************************************************************************
Verify our test array is set up without any bugs.  If there are problems,
we'll print them and return E_FAIL;
********************************************************************************/
HRESULT SanityCheckTestCases(void)
{
LPSTR szValidTestTypes[] = {"BVT", "Valid", "Invalid", "Fatal", "PerfMem"};
HRESULT hr = S_OK;
DWORD i=0, j=0;

//Verify no dupes.
for (i=0; i<AMOUNT(g_TestCases)-1; i++)
{
    for (j=i+1; j<AMOUNT(g_TestCases); j++)
    {
        if (_strcmpi(g_TestCases[i].szTestName, g_TestCases[j].szTestName) == 0)
        {
            hr = E_FAIL;
            Log(ABORTLOGLEVEL, "Sanity check error: g_TestCases array elements %d and %d both have %s as the Test Name", i, j, g_TestCases[i].szTestName);
        }
    }
}

//Verify all test "types" are valid.
for (i=0; i<AMOUNT(g_TestCases); i++)
{
    BOOL bFound = FALSE;
    for (j=0; j<AMOUNT(szValidTestTypes); j++)
    {
        if (strcmp(g_TestCases[i].szTestDesc, szValidTestTypes[j]) == 0)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "Sanity check error: g_TestCases array element %d had invalid description (%s)", i, g_TestCases[i].szTestDesc);
    }
}



//Verify that a method of a certain type isn't "sandwiched" between other types (for readability)
for (i=0; i<AMOUNT(g_TestCases)-2; i++)
{
    if (
        (_strcmpi(g_TestCases[i].szTestDesc, g_TestCases[i+1].szTestDesc) != 0) &&
        (_strcmpi(g_TestCases[i].szTestDesc, g_TestCases[i+2].szTestDesc) == 0)
        )
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "Sanity check error: %s is sandwiched between two elements with different descriptions", g_TestCases[i+1]);
    }
}


return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\loader8.h ===
#pragma once
#include "globals.h"

HRESULT Loader_CollectGarbage( CtIDirectMusicPerformance8* ptPerf8 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_ClearCache.cpp ===
/********************************************************************************
	FILE:
		Loader_CollectGarbage.cpp

	PURPOSE:
		CollectGarbage Tests for Loader

	BY:
		DANROSE
********************************************************************************/
#include "globals.h"


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_ClearCache_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader8_ClearCache_BVT())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_ClearCache_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader8_ClearCache())");
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_CollectGarbage.cpp ===
/********************************************************************************
	FILE:
		Loader_CollectGarbage.cpp

	PURPOSE:
		CollectGarbage Tests for Loader

	BY:
		DANROSE
********************************************************************************/

#include "globals.h"
#include <loader8.h>

static const LPSTR MEDIA_ROOT = "T:\\DMTest1";

static GUID* guids[] = {
	(GUID*) &CLSID_DirectMusicSegment,
//	(GUID*) &CLSID_DirectMusicBand,
	(GUID*) &CLSID_DirectMusicScript,
	(GUID*) &CLSID_DirectMusicAudioPathConfig
};

static GUID* interfaces[] = { 
	(GUID*) &CTIID_IDirectMusicSegment,
//	(GUID*) &CTIID_IDirectMusicBand,
	(GUID*) &CTIID_IDirectMusicScript,
	(GUID*) &CTIID_IUnknown 
};

struct ListNode {
	ListNode* pNext;
	CtIUnknown* pUnk;
};

static ListNode* g_pList = NULL;

HRESULT Insert( CtIUnknown* pUnk )
{
    HRESULT hr = S_OK;
	ListNode* pTemp = new ListNode;
    CHECKALLOC(pTemp);
    if (SUCCEEDED(hr))
    {
	    pTemp->pUnk = pUnk;
	    pTemp->pNext = g_pList;
	    g_pList = pTemp;
    }

    return hr;
}

void Delete()
{
	for( ListNode* pNode = g_pList; pNode != NULL; pNode = g_pList )
	{
		g_pList = pNode->pNext;
		RELEASE( pNode->pUnk );
		delete pNode;
		pNode = NULL;
	}
}

HRESULT dmthLoadFile( LPSTR szFileName, CtIDirectMusicLoader8* pLoader, CtIUnknown** ppUnk )
{
	if ( NULL == szFileName || NULL == pLoader || NULL == ppUnk )
		return E_POINTER;

    CHAR szPath[MAX_PATH] = {NULL};
    CHAR szName[MAX_PATH] = {NULL};


	HRESULT hr = S_OK;

    CHECKRUN(ChopPath(szFileName, szPath, szName));
    CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes ,szPath, FALSE));
    if (FAILED(hr))
        return hr;
    

	for ( ULONG i = 0; i < NUMELEMS( interfaces ); i++ )
	{

		CHECKRUN( pLoader->LoadObjectFromFile( *guids[i], *interfaces[i], szFileName, (LPVOID*) ppUnk ) );
	
		if ( SUCCEEDED( hr ) )
		{
			break;
		}
        else
        {
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT LoadOneFile( LPSTR szFile, CtIDirectMusicLoader8* pLoader )
{
	HRESULT hr = S_OK;

	CtIUnknown* pUnk = NULL;

	CHECKRUN( dmthLoadFile( szFile, pLoader, &pUnk ) );

	if ( pUnk && SUCCEEDED( hr ) )
	{
		CHECKRUN(Insert( pUnk ));

		Log(FYILOGLEVEL, "********************* %s\n", szFile );
	}

	RELEASE( pUnk );

	return hr;
}

HRESULT RecurseDirectory( LPSTR szDir, CtIDirectMusicLoader8* pLoader  )
{
	HRESULT hr = S_OK;

	WIN32_FIND_DATA findData;
	BOOL bMore = TRUE;
	HANDLE hFiles;

	CHAR szFullPath[MAX_PATH];
	CHAR szFiles[MAX_PATH];

	sprintf( szFiles, "%s\\*", szDir ); 

	hFiles = FindFirstFile( szFiles, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore && SUCCEEDED( hr ) )
	{
		sprintf( szFullPath, "%s\\%s", szDir, findData.cFileName );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CHECKRUN( RecurseDirectory( szFullPath, pLoader ) );
		}

		else
		{
			CHECKRUN( LoadOneFile( szFullPath, pLoader ) );
		}

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}

HRESULT Loader_CollectGarbage_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );

	CHECKRUN( RecurseDirectory( MEDIA_ROOT, pLoader ) );
//	CHECKRUN( LoadOneFile( "T:\\DMTest1\\old\\SonicImplants Live Band.sgt", pLoader ) );

	for ( ListNode* pNode = g_pList; pNode != NULL && SUCCEEDED( hr ); pNode = pNode->pNext )
	{
		CHECKRUN( pLoader->ReleaseObjectByUnknown( pNode->pUnk ) );
	}

	CHECK(pLoader->CollectGarbage());

	Delete();

	RELEASE( pLoader );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_SetObject.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_SetObject_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader_SetObject())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_SetObject_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader_SetObject())");
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_ReleaseObjectByUnknown.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_ReleaseObjectByUnknown_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader_ReleaseObjectByUnknown())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_ReleaseObjectByUnknown_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader_ReleaseObjectByUnknown())");
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_GetObject.cpp ===
#include "globals.h"
#include "cicmusicx.h"


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_GetObject_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader_GetObject())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_GetObject_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader_GetObject())");
    return hr;
};



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_GetObject_PerfMem_DownloadWaveLeak(CtIDirectMusicPerformance8* ptPerf8, DWORD bStreaming, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    IDirectMusicSegment *pSegment = NULL;
    IDirectMusicSegmentState *pSegmentState = NULL;
    IDirectMusicAudioPath *pPath = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    CHAR szPath[MAX_PATH];
    CHAR szFile[MAX_PATH];
    LPSTR szServerPathNames[] = {"WAV/08_08_2.wav", "DMusic/DMTest1/_wav/Streaming10s.wav"};
    CHAR szPathNames[2][MAX_PATH] = {0};
    LPSTR szFullPath = NULL;


    //Copy the files locally.
    for (DWORD i=0; i<NUMELEMS(szServerPathNames); i++)
    {
        CHECKRUN(MediaCopyFile(szServerPathNames[i]));
        strcpy(szPathNames[i], MediaServerToLocal(szServerPathNames[i]));
    }


    if (bStreaming)
        szFullPath = szPathNames[1];
    else
        szFullPath = szPathNames[0];
    
    CHECKRUN(ChopPath(szFullPath, szPath, szFile));
    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));
    dwStartTime = timeGetTime();
    do
    {
        CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
        CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
        CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFile, (void **)&pSegment));
        if (FAILED(hr))
            Log(FYILOGLEVEL, "FAIL!!!!");

        CHECKRUN(pPerf->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &pPath));    

//        CHECKRUN(pPerf->PlaySegmentEx(pSegment,0,0,0,0,&pSegmentState,0,pPath));    
//        CHECKRUN(pPerf->StopEx(pSegmentState, 0, 0));    

        Wait(100);

        SAFE_RELEASE(pSegmentState);
        SAFE_RELEASE(pSegment);
        SAFE_RELEASE(pPath);
        SAFE_RELEASE(pLoader);
        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    SAFE_RELEASE(pPerf);

    return hr;
};




/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_GetObject_PerfMem_Type_Full(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    IUnknown *pUnknown = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    DWORD dwLoads = 0;
    CHAR szPath[MAX_PATH];
    CHAR szFile[MAX_PATH];
    CHAR szFullPath[MAX_PATH] = {0};
    GUID *pCLSID= NULL;
    GUID *pIID= NULL;
    
    CHECKRUN(MediaCopyDirectory((LPSTR)dwFilename));
    strcpy(szFullPath, MediaServerToLocal((LPSTR)dwFilename));
    CHECKRUN(GUIDsFromFileName(szFullPath, &pCLSID, &pIID));
    CHECKRUN(ChopPath(szFullPath, szPath, szFile));
    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));
    dwStartTime = timeGetTime();
    do
    {
        dwLoads++;
        CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
        CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
        CHECKRUN(pLoader->LoadObjectFromFile(*pCLSID, *pIID, szFile, (void **)&pUnknown));
        if (FAILED(hr))
        {
            Log(ABORTLOGLEVEL, "Attempt %u to load %s FAILED!!!!", dwLoads, szFile);
        }

        SAFE_RELEASE(pUnknown);
        SAFE_RELEASE(pLoader);
        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    //Make sure everything gets released.
    SAFE_RELEASE(pUnknown);
    SAFE_RELEASE(pLoader);
    SAFE_RELEASE(pPerf);

    if (FAILED(hr))
        Log(ABORTLOGLEVEL, "Loader_GetObject_PerfMem_Type_Full failed with %s (%08X)", tdmXlatHRESULT(hr), hr);
    return hr;
};



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_GetObject_PerfMem_Type_Partial(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    IUnknown *pUnknown = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    CHAR szPath[MAX_PATH];
    CHAR szFile[MAX_PATH];
    CHAR szFullPath[MAX_PATH] = {0};
    GUID *pCLSID= NULL;
    GUID *pIID= NULL;

    CHECKRUN(MediaCopyDirectory((LPSTR)dwFilename));
    strcpy(szFullPath, MediaServerToLocal((LPSTR)dwFilename));
    CHECKRUN(GUIDsFromFileName(szFullPath, &pCLSID, &pIID));
    CHECKRUN(ChopPath(szFullPath, szPath, szFile));
    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));
    CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
    CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
    dwStartTime = timeGetTime();
    do
    {
        CHECKRUN(pLoader->LoadObjectFromFile(*pCLSID, *pIID, szFile, (void **)&pUnknown));
        if (FAILED(hr))
        {
            Log(ABORTLOGLEVEL, "Load %s FAILED!!!!", szFile);
        }

        SAFE_RELEASE(pUnknown);
        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    //Make sure everything gets released.
    SAFE_RELEASE(pUnknown);
    SAFE_RELEASE(pLoader);
    SAFE_RELEASE(pPerf);

    if (FAILED(hr))
        Log(ABORTLOGLEVEL, "Loader_GetObject_PerfMem_Type_Full failed with %s (%08X)", tdmXlatHRESULT(hr), hr);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_LoadObjectFromFile_Invalid.cpp ===
#include "globals.h"

HRESULT Loader8_LoadObjectFromFile_Invalid_Ref(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectFromFile_Invalid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    DMTEST_EXECUTE(Loader8_LoadObjectFromFile_Invalid_Ref(ptPerf8));
    return hr;
}



/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectFromFile_Invalid_Ref(CtIDirectMusicPerformance8* ptPerf8)
{
	HRESULT						hr				= 0;
	CtIDirectMusicSegment8		*ptSegment		= NULL;
	CHAR						*szSegmentFileServer = "DMusic/DMTest1/Loader/Inv_BrokenRef/Inv_BrokenRef.sgt";
	CHAR						szSegmentFile[MAX_PATH] = {0};
	CHAR						szSegmentPath[MAX_PATH] = {0};
    CtIDirectMusicLoader       *ptLoader      = NULL;

    CHECKRUN(MediaCopyFile(szSegmentFileServer));
    strcpy(szSegmentFile, MediaServerToLocal(szSegmentFileServer));
    CHECKRUN(ChopPath(szSegmentFile, szSegmentPath, NULL));

    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));
    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE));
    CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szSegmentFile, (void **)&ptSegment));
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader);

    return hr;
}



/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectFromFile_Invalid_GMRef(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2)
{
	HRESULT						hr				        = 0;
	CtIDirectMusicSegment		*ptSegment		        = NULL;
    CtIDirectMusicLoader        *ptLoader               = NULL;
	CHAR						*szSegmentFileServer	= (CHAR *)dwFilename;
    CHAR                        szSegmentFile[MAX_PATH] = {0};
    CHAR                        szPath[MAX_PATH] = {0};
    CHAR                        szFile[MAX_PATH] = {0};

    
    CHECKRUN(MediaCopyFile(szSegmentFileServer));
    strcpy(szSegmentFile, MediaServerToLocal(szSegmentFileServer));
    CHECKRUN(ChopPath(szSegmentFile, szPath, szFile));
    
    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));
    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, FALSE));
    CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szFile, (void **)&ptSegment));
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader);

    return hr;
}


/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectFromFile_TooLongPath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT						hr				= 0;
	CtIDirectMusicSegment8		*ptSegment		= NULL;
	CHAR						*szSegmentFileServer = "DMusic/DMTest1/Loader/Inv_TooLongPath/40CharacterName789_123456789_123456.wav";
	CHAR						szSegmentFile[MAX_PATH] = {0};
	CHAR						szSegmentPath[MAX_PATH] = {0};
    CtIDirectMusicLoader       *ptLoader      = NULL;
    HRESULT hrCall = S_OK;

    CHECKRUN(MediaCopyFile(szSegmentFileServer));
    strcpy(szSegmentFile, MediaServerToLocal(szSegmentFileServer));
    CHECKRUN(ChopPath(szSegmentFile, szSegmentPath, NULL));


    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));
    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE));
    if (SUCCEEDED(hr))
    {
        hrCall = ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szSegmentFile, (void **)&ptSegment);
    }
    if (hrCall != DMUS_E_LOADER_FAILEDCREATE)
    {
        Log(ABORTLOGLEVEL, "Error: LoadObjectFromFile returned %s instead of DMUS_E_LOADER_FAILEDCREATE", tdmXlatHRESULT(hr));
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader);
    return hr;
}


/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectFromFile_Invalid_Content(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT						hr			   = 0;
	CtIDirectMusicSegment8		*ptSegment	   = NULL;
	CHAR						*szSegmentFileServer = "DMusic/DMTest1/Loader/Inv_AudioPath/Inv_AudioPath.sgt";	
	CHAR						szSegmentFile[MAX_PATH] = {0};
	CHAR						szSegmentPath[MAX_PATH] = {0};
    CtIDirectMusicLoader        *ptLoader      = NULL;

    CHECKRUN(MediaCopyFile(szSegmentFileServer));
    strcpy(szSegmentFile, MediaServerToLocal(szSegmentFileServer));
    CHECKRUN(ChopPath(szSegmentFile, szSegmentPath, NULL));

    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));
    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE));
    CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szSegmentFile, (void **)&ptSegment));
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Logging.cpp ===
//lint -e416    
#include "globals.h"
#include "dxconio.h"

DWORD g_dwDebugLevel = 5;
DWORD g_dwIndentLevel = 0;
DWORD g_dwPassed = 0;
DWORD g_dwFailed = 0;


HRESULT LogInit(void)
{
HRESULT hr = S_OK;

    if (!g_TestParams.bLogToScreen)
        return S_OK;

    //To load another texture, use xSetBackground.
    xCreateConsole(NULL);
            xSetBackgroundColor(
                             255, 
                             255, 
                             255, 
                             255
                             );

    xSetBackgroundImage("T:\\DMTest1\\BGImage.bmp");
//    xprintf("Welcome to DMusic!!!\n");
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT LogFree(void)
{
HRESULT hr = S_OK;

if (!g_TestParams.bLogToScreen)
    return S_OK;

xReleaseConsole();
return hr;
};



/********************************************************************************
********************************************************************************/
void LogSetDbgLevel(DWORD dwLevel)
{
    g_dwDebugLevel = dwLevel;
}


void LogIncrementIndent()
{
    g_dwIndentLevel++;
};


void LogDecrementIndent()
{
    g_dwIndentLevel--;
};


/********************************************************************************
********************************************************************************/
HRESULT LogConsole
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    if (!g_TestParams.bLogToScreen)
        return S_OK;

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    //A carriage return goes here when we've decided not to output to VC anymore!!
    xprintf("%s\n", szBuffer);
    return S_OK;
};


/********************************************************************************
********************************************************************************/
HRESULT Log
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return S_OK;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
    if (dwDestinationFlags & LOG_DEBUG)
        DbgPrint("%s\n", szBuffer);
    if (dwDestinationFlags & LOG_FILE)
        xLog(g_hLog, XLL_INFO, szBuffer);
    return S_OK;
};

/********************************************************************************
********************************************************************************/
HRESULT Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return S_OK;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
        DbgPrint("%s\n", szBuffer);
        LogConsole(szBuffer);

    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_LoadObjectFromFile_IStream.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "Help_Stream.h"

using namespace LocalFileStream;

HRESULT VerifyRefCount(LPSTR szName, IUnknown *pUnk, DWORD dwExpected)
{
HRESULT hr = S_OK;
DWORD dwRefCount = 0;

    if (!pUnk)
        return E_FAIL;

    pUnk->AddRef();
    dwRefCount = pUnk->Release();

    //Verify that the refcount is 1.
    if (dwRefCount != dwExpected)
    {   
        Log(ABORTLOGLEVEL, "Error: refcount of %s is %u instead of %u", szName ? szName : "object", dwRefCount, dwExpected);
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}



/********************************************************************************
********************************************************************************/
HRESULT Loader_GetObject_IStream_Generic(CtIDirectMusicPerformance8* ptPerf8, LPCSTR szFileName)
{
    HRESULT hr = S_OK;
    IStream *pStream = NULL;
    IStream *pClone = NULL;
    CtIDirectMusicLoader *ptLoader = NULL;
    IDirectMusicSegment *pSegment = NULL;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;

    DMUS_OBJECTDESC dmod = {0};
    CHAR szPath[MAX_PATH];
    CHAR szFile[MAX_PATH];


    //Create the loader.
    CHECKRUN(dmthCreateLoader(CTIID_IDirectMusicLoader, &ptLoader));
    CHECKRUN(ChopPath(szFileName, szPath, szFile));
    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes , szPath, FALSE));

    
    //Create a stream from this file.
    AllocStreamFromFile(&pStream, szFileName, 0);
    if (NULL == pStream)
    {
        Log(ABORTLOGLEVEL, "AllocStreamFromFile(%s) returned %08X (%s)", szFileName, hr, tdmXlatHRESULT(hr));
        hr = E_FAIL;
    }

    //Refcount should be one.
//    VerifyRefCount("stream before loaded or playing", pStream, 1);
    
    //Set up my DMOD
    dmod.dwSize = sizeof(dmod);
    dmod.dwValidData = DMUS_OBJ_STREAM | DMUS_OBJ_CLASS;
    dmod.pStream = pStream;
    memcpy(&dmod.guidClass, (GUID *)&CLSID_DirectMusicSegment, sizeof(GUID));

    //Get the segment from the stream.
    CHECKRUN(ptLoader->GetObject(&dmod, IID_IDirectMusicSegment, (void **)&pSegment));
    CHECKRUN(dmthCreateTestWrappedObject(pSegment, &ptSegment));

    //Get the clone of this stream.
    //CHECKRUN(((CFileStream *)(pStream))->GetMyClone(&pClone));

    //TODO: replace pStream w/pClone
    //CHECKRUN(VerifyRefCount("clone stream while loaded but before or playing", pClone, 1));

    //Play the segment on an audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREO, 128, TRUE, &ptPath));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));

    //Refcount should be 2 while the clone stream is playing.
    //CHECKRUN(VerifyRefCount("clone stream while playing", pClone, 1));

    //Stop the segment
    CHECKRUN(ptPerf8->StopEx(ptSegment, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE));
    
    //
    //CHECKRUN(VerifyRefCount("clone stream after playing but still loaded", pClone, 1));

    //Free the loader: Refcount should be one.
    RELEASE(ptLoader);
    //CHECKRUN(VerifyRefCount("clone stream after playing and unloaded", pClone, 1));

//    CHECKRUN(VerifyRefCount("stream after playing and unloaded", pStream, 1));

    RELEASE(ptPath);
    RELEASE(ptSegment);
    RELEASE(pSegment);
    RELEASE(pStream);

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Loader_GetObject_IStream_Test(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
LPCSTR szFileName = "T:\\DMTest1\\test.sgt";

CHECKRUN(LoadMedia(MediaFileDesc));
CHECKRUN(Loader_GetObject_IStream_Generic(ptPerf8, szFileName));
return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Loader_GetObject_IStream_Streaming(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
LPCSTR szFilename = "WAV/Streaming10s.wav";
CHECKRUN(MediaCopyFile(szFilename));
CHECKRUN(Loader_GetObject_IStream_Generic(ptPerf8, MediaServerToLocal(szFilename)));
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_LoadObjectFromFile.cpp ===
#include "globals.h"
#include "cicmusicx.h"


HRESULT Loader_LoadObjectFromFile_Valid_RepeatLoadScript(CtIDirectMusicPerformance *ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader_LoadObjectFromFile())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader_LoadObjectFromFile())");
    DMTEST_EXECUTE(Loader_LoadObjectFromFile_Valid_RepeatLoadScript(ptPerf8));
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Valid_AbsolutePath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    CHAR *szServerFilename = (CHAR *)dwFilename;
    CHAR szFilename[MAX_PATH] = {0};
    CHAR szPath[MAX_PATH] = {0};
    CtIDirectMusicLoader *ptLoader = NULL;
    IUnknown *pUnk = NULL;
    GUID *pCLSID = NULL;
    GUID *pIID = NULL;

    
    CHECKRUN(MediaCopyFile(szServerFilename));
    strcpy(szFilename, MediaServerToLocal(szServerFilename));
    CHECKRUN(ChopPath(szFilename, szPath, NULL));
    CHECKRUN(GUIDsFromFileName(szFilename, &pCLSID, &pIID));
    CHECKRUN(dmthCreateLoader(CTIID_IDirectMusicLoader, &ptLoader));

    CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
    CHECKRUN(ptLoader->LoadObjectFromFile(*pCLSID, *pIID, szFilename, (void **)&pUnk));
    SAFE_RELEASE(pUnk);
    SAFE_RELEASE(ptLoader);
    return hr;
};




/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Perf (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Perf test function Loader_LoadObjectFromFile_Perf())");
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Valid_RepeatLoadScript(CtIDirectMusicPerformance *ptPerf8)
{
    HRESULT hr = S_OK;  
    CtIDirectMusicScript* pScript = NULL;
    CtIDirectMusicLoader8* pLoader = NULL;
    LPSTR szFilename = "DMusic/DMTest1/script/variables.spt";
    CHAR szDirectory[MAX_PATH] = {0};
    int i=0; 


    CHECKRUN(MediaCopyFile(szFilename));
    for (i=0; i<1000 && SUCCEEDED(hr); i++)
    {
        CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
        CHECKRUN( ChopPath(MediaServerToLocal(szFilename), szDirectory, NULL));
        CHECKRUN( pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szDirectory, TRUE));
        CHECKALLOC( pLoader );
        CHECKRUN( dmthCreateScript( MediaServerToLocal(szFilename), pLoader, &pScript ) );
        CHECKALLOC( pScript );
        SAFE_RELEASE( pScript );
        SAFE_RELEASE( pLoader );
        if (FAILED(hr))
        {
            Log(ABORTLOGLEVEL, "Loading the script failed on iteration %d", i);
            break;
        }
    }

    return hr;

}

/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectTwice(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT                     hr              = 0;
    HRESULT                     hrCall          = S_OK;
    CtIDirectMusicSegment8      *ptSegment      = NULL;

    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                    {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                    {TERMINATE}
                                    };

    CHAR                        *szSegmentFile  = "T:\\DMTest1\\test.sgt";
    CHAR                        *szSegmentPath  = "T:\\DMTest1";
    CtIDirectMusicLoader8       *ptLoader8      = NULL;
    DWORD i;

    CHECKRUN(LoadMedia(MediaFileDesc));

    // **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &ptLoader8);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
                TEXT("failed (%s === %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Load the Segment Object
    // **********************************************************************
    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize         = sizeof(DMUS_OBJECTDESC);
    desc.guidClass      = CLSID_DirectMusicSegment;
    desc.dwValidData    |= (DMUS_OBJ_CLASS | DMUS_OBJ_FULLPATH);


    // Get the Segment object
    mbstowcs(desc.wszFileName, szSegmentFile, strlen(szSegmentFile) + 1);

//    strcpy(desc.wszFileName, szSegmentFile);
    for (i=0; i<2; i++)
    {
        hr = ptLoader8->GetObject(&desc, CTIID_IDirectMusicSegment, (void **)&ptSegment);
        Log(ABORTLOGLEVEL, "dmthLoadSegment(%s) returned %s (%08Xh)", szSegmentFile, tdmXlatHRESULT(hr), hr);
        if(FAILED(hr))
        {
            hrCall = hr;
        }

        SAFE_RELEASE(ptSegment);
    }

    TEST_END:


    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader8);
    return hrCall;

}


enum LOADTYPE {BYFILENAME, BYNAME, BYGUID};

HRESULT Loader_LoadObjectFromFile_Container(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwName, LOADTYPE eLoadType, DWORD dwUseScript);



/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByFileName(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwFileName)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwFileName, BYFILENAME, FALSE);
};

/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByName(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwName)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwName, BYNAME, FALSE);
};

/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByGUID(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwGUID)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwGUID, BYGUID, FALSE);
};

/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByFileName_Script(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwFileName)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwFileName, BYFILENAME, TRUE);
};

/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByName_Script(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwName)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwName, BYNAME, TRUE);
};

/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Container_ByGUID_Script(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwGUID)
{
    return Loader_LoadObjectFromFile_Container(ptPerf8, bWave, dwGUID, BYGUID, TRUE);
};



/********************************************************************************
Note: Search Path is hard-coded.
********************************************************************************/
#define COUNT 1
#define TESTS 8

//#define SCRIPT
HRESULT Loader_LoadObjectFromFile_Container(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwName, LOADTYPE eLoadType, DWORD dwUseScript)
{
CtIDirectMusicSegment* ptSegment = NULL;
CtIDirectMusicLoader * ptLoader = NULL;
CtIUnknown *ptUnk               = NULL;
DWORD dwStartTime = 0, dwTotalTime = 0;
HRESULT hr = S_OK;
DWORD dwIndex = 0;
BOOL bLoadFromContainer = 0xFFFFFFFF;
LPSTR szName  = (LPSTR)dwName;
DWORD dwTimes[TESTS] = {0};
GUID guidObject = {NULL};
LPSTR szContLocationServer = "DMusic/DMTest1/Loader/Cont01/Cont/Cont01.con";
LPSTR szScrLocationServer  = "DMusic/DMTest1/Loader/Cont01/Cont/Cont01.spt";
LPSTR szFilesPathServer    = "DMusic/DMTest1/Loader/Cont01/Files/";
CHAR szContLocation[MAX_PATH] = {0};
CHAR szScrLocation [MAX_PATH] = {0};
CHAR szFilesPath   [MAX_PATH] = {0};
LPSTR szContainer = NULL;
BOOL bFailed = FALSE;

//Copy the directory containing these files.
CHECKRUN(MediaCopyDirectory(szContLocationServer));
CHECKRUN(MediaCopyDirectory(szScrLocationServer));
CHECKRUN(MediaCopyDirectory(szFilesPathServer));
strcpy(szContLocation,  MediaServerToLocal(szContLocationServer));
strcpy(szScrLocation,   MediaServerToLocal(szScrLocationServer));
strcpy(szFilesPath,     MediaServerToLocal(szFilesPathServer));

//Define the location of the container based on whether we're using the script or the container.
if (dwUseScript)
    szContainer = szScrLocation;
else
    szContainer = szContLocation;

for (dwIndex = 0; dwIndex < TESTS && SUCCEEDED(hr); dwIndex++)
{

    //Create a loader.
    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));

    //bLoadFromContainer = !(dwIndex % 2);
    bLoadFromContainer = (dwIndex % 2);
    
    //If we're not loading by filename, we can't load directly from the disk.
    if ((BYGUID == eLoadType || BYNAME == eLoadType) && !bLoadFromContainer)
    {
        RELEASE(ptLoader);
        continue;
    }

    //Cache the files in the container.
    if (bLoadFromContainer)
    {
        if (dwUseScript)
        {
            CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IUnknown, szContainer, (void **)&ptUnk));
        }
        else
        {
            CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicContainer, CTIID_IUnknown, szContainer, (void **)&ptUnk));
        }
    }
    //Load and free the object MAX times.
    if (SUCCEEDED(hr))
    {
        DMUS_OBJECTDESC dmod = {0};
        dmod.dwSize = sizeof(dmod);
        dmod.dwValidData = DMUS_OBJ_CLASS;
        
        if (0)
            memcpy((void *)&dmod.guidClass, &CLSID_DirectSoundWave, sizeof(GUID));
        else
            memcpy((void *)&dmod.guidClass, &CLSID_DirectMusicSegment, sizeof(GUID));

        if (BYFILENAME == eLoadType)
        {
            mbstowcs(dmod.wszFileName, szName, MAX_PATH);
            dmod.dwValidData |= DMUS_OBJ_FILENAME;
        }
        else if (BYNAME == eLoadType)
        {
            mbstowcs(dmod.wszName, szName, MAX_PATH);
            dmod.dwValidData |= DMUS_OBJ_NAME;
        }
        else if (BYGUID == eLoadType)
        {                
            CHECKRUN(StringToGuid(szName, &dmod.guidObject));
            dmod.dwValidData |= DMUS_OBJ_OBJECT;
        }
        else
        {
            Log(ABORTLOGLEVEL, "Test App Error!!!  eLoadType = %d", eLoadType);
        }
        //If we haven't loaded from a container, then point ourselves to the directory.
        if (!bLoadFromContainer)
        {
            hr = ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szFilesPath, TRUE);
        }
        dwStartTime = timeGetTime();
        for (DWORD i=0; i<COUNT && SUCCEEDED(hr); i++)
        {
            if (SUCCEEDED(hr))
            {

//                if (bWave)
//                {
//                    //1) Call GetObject() with IID_IDirectMusicObject, then call GetDescriptor.  If this descriptor has a valid pStream pointer,
//                    //   then try calling SetObject with the same descriptor with the guidClass set to CLSID_DirectMusicSegment.
//                    Log(FYILOGLEVEL, "Since this is a WAVE object, we're gonna try James's trick of calling SetObject with CLSID_DirectMusicSegment");
//                    CtIDirectMusicObject *ptObject = NULL;
//                    DMUS_OBJECTDESC dmodObject = {0};
//                    
//                    //Copy the original objectdesc
//                    dmodObject = dmod;
//                    
//                    CHECKRUN(ptLoader->GetObject(&dmodObject, CTIID_IDirectMusicObject, (void **)&ptObject));
//                    if (FAILED(hr))
//                    {
//                        Log(ABORTLOGLEVEL, "GetObject on the wave for an IID_IDirectMusicObject interface failed with a %s (%08X)", tdmXlatHRESULT(hr), hr);
//                    }
//                    CHECKRUN(ptObject->GetDescriptor(&dmodObject));
//                    if (dmodObject.pStream)
//                    {
//                        memcpy((void *)&dmodObject.guidClass, &CLSID_DirectMusicSegment, sizeof(GUID));
//                        CHECKRUN(ptLoader->SetObject(&dmodObject));
//                    }
//                    else
//                    {
//                        Log(ABORTLOGLEVEL, "The Object Descriptor obtained from the loader had a NULL pStream");
//                        hr = E_FAIL;
//                    }
//                }
                CHECKRUN(ptLoader->GetObject(&dmod, CTIID_IDirectMusicSegment, (void **)&ptSegment));
                if (FAILED(hr))
                {
                    Log(ABORTLOGLEVEL, "GetObject from %s for object %s returned %s (%08X)", bLoadFromContainer ? "container" : "disk", szName, tdmXlatHRESULT(hr), hr);                    
                }
            }            
            RELEASE(ptSegment);
        }
        dwTotalTime = timeGetTime() - dwStartTime;
    }
    
    //store and print the timing info.
    if (SUCCEEDED(hr))
    {
        dwTimes[dwIndex] = dwTotalTime;
        Log(FYILOGLEVEL, "Took %u ms to load %s %u times from %s", dwTimes[dwIndex], szName, COUNT, bLoadFromContainer ? "container" : "disk");
    }
    else
    {
        bFailed = TRUE;
        hr = S_OK;
    }

    //If we loaded the container, release it.
    if (bLoadFromContainer)
    {
        CHECKRUN(ptLoader->ReleaseObjectByUnknown(ptUnk));
        RELEASE(ptUnk);
    }

    //Always clear the cache before we try the next method of loading.
//    CHECKRUN(ptLoader->ClearCache(GUID_DirectMusicAllTypes));
    RELEASE(ptLoader);

}

RELEASE(ptUnk);     //release container
RELEASE(ptSegment); //release segment
RELEASE(ptLoader);  //release loader

if (SUCCEEDED(hr))
    if (bFailed)
        hr = E_FAIL;

return hr;
};
#undef COUNT


/********************************************************************************
********************************************************************************/
HRESULT Loader_LoadObjectFromFile_Valid_Bug7707(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{   
    HRESULT hr = S_OK;
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Loader/Bug7707/"));
    CHECKRUN(Loader_LoadObjectFromFile_Valid_AbsolutePath(ptPerf8, (DWORD)"DMusic/DMTest1/Loader/Bug7707/Segment1.sgt", 0));
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Loader_SetSearchDirectory.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Loader_SetSearchDirectory_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Loader_SetSearchDirectory())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Loader_SetSearchDirectory_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Loader_SetSearchDirectory())");
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Logging.h ===
#pragma once

#define LOG_DEBUG 1
#define LOG_FILE 2
#define LOG_ALL 3


#define ABORTLOGLEVEL 1
#define FYILOGLEVEL 2


HRESULT Log
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags,
    LPSTR                   szFormat,
    ...
);

//Logs everywhere.
HRESULT Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
);


/*
//So the test logging will still work.  Grrr.
HRESULT Log
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags, 
    LPSTR                   szFormat,
    ...
);

HRESULT Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
);

*/

void LogSetDbgLevel(DWORD dwLevel);
void LogIncrementIndent(void);
void LogDecrementIndent(void);
HRESULT LogInit(void);
HRESULT LogFree(void);


extern DWORD g_dwPassed;
extern DWORD g_dwFailed;



//This macro is for those main test functions which call a bunch of other test functions (subtests).  This helps log
//  the subtest that failed, although these subtest results are not logged in the main test results.

#define DMTEST_EXECUTE( func )                                      \
{                                                                   \
HRESULT hrXXXCall;                                                  \
    hrXXXCall = (func);                                               \
	if ( FAILED( hrXXXCall) )                                       \
	{                                                               \
        Log(FYILOGLEVEL, "FAILED: "#func ## );                      \
        Log(FYILOGLEVEL, "-------");    \
        hr = hrXXXCall;                                             \
	}                                                               \
	else                                                            \
	{                                                               \
        Log(FYILOGLEVEL, "PASSED: "#func ## );                      \
        Log(FYILOGLEVEL, "-------");    \
	}                                                               \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_AddNotificationType.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "Performance8_AddNotificationType.hpp"


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_AddNotificationType_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Valid test function Performance8_AddNotificationType())");  //PASS
    DMTEST_EXECUTE(Template_AddRemoveNotifications<CtIDirectMusicPerformance8>(ptPerf8, 1, 0, 0));      
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_AddNotificationType_NoRestart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes)
{
    return Template_AddRemoveNotifications<CtIDirectMusicPerformance8>(ptPerf8, dwAddNotificationTypes, dwRemNotificationTypes, 0);
}

/********************************************************************************
********************************************************************************/
HRESULT Performance8_AddNotificationType_Restart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes)
{
    return Template_AddRemoveNotifications<CtIDirectMusicPerformance8>(ptPerf8, dwAddNotificationTypes, dwRemNotificationTypes, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\nakedmacros.h ===
#pragma once

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}

#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_AddNotificationType.hpp ===
/********************************************************************************


guidNotificationType
--------------------
Which of these are pertinent to XBox:
GUID_NOTIFICATION_MEASUREANDBEAT 
Measure and beat event. 
GUID_NOTIFICATION_PERFORMANCE 
Performance event, further defined in dwNotificationOption. 
GUID_NOTIFICATION_SEGMENT 
Segment event, further defined in dwNotificationOption. 
YES


dwNotificationOption 
--------------------
There are all pertinent to XBox.
Identifier of the notification subtype. 
If the notification type is GUID_NOTIFICATION_SEGMENT, this member can contain one of the following values: 
DMUS_NOTIFICATION_SEGABORT 
The segment was stopped prematurely, or was removed from the primary segment queue. 
DMUS_NOTIFICATION_SEGALMOSTEND 
The segment has reached the end minus the prepare time. 
DMUS_NOTIFICATION_SEGEND 
The segment has ended. 
DMUS_NOTIFICATION_SEGLOOP 
The segment has looped. 
DMUS_NOTIFICATION_SEGSTART 
The segment has started. 


If the notification type is GUID_NOTIFICATION_PERFORMANCE, this member can contain one of the following values: 
DMUS_NOTIFICATION_MUSICALMOSTEND 
The currently playing primary segment has reached the end minus the prepare time, and no more primary segments are cued to play. 
DMUS_NOTIFICATION_MUSICSTARTED 
Playback has started. 
DMUS_NOTIFICATION_MUSICSTOPPED 
Playback has stopped. 


********************************************************************************/


/********************************************************************************
IDirectMusicPerformance8::AddNotificationType()

//One piece of code can test both addage and removal.

HISTORY:
    Updated     04/05/00      danhaff - created.

//TODO: Since we're not looping yet, we don't get any loop messages.  We need
/       to write another test to check for these.
********************************************************************************/
struct PMSG_COUNTER
{
    DMUS_NOTIFICATION_PMSG * pMsg[32];
    DWORD                    dwCount;
    DWORD                    dwExpected;
};



template <class T>
HRESULT Template_AddRemoveNotifications(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes, DWORD dwRestarts, T* pDoNotUseDoNotRemove = NULL)
{
    HRESULT                     hr              = S_OK;
    CICMusic                    Music;
    CtIDirectMusicAudioPath     *ptAudioPath     = NULL;
    CtIDirectMusicSegment       *ptSegment8      = NULL;
    T                           *ptInterface     = NULL;
    DWORD                       i = 0;

    DMUS_NOTIFICATION_PMSG *    pMsg = NULL;

    PMSG_COUNTER PMsgCounter[3] = { 
                                    {{0}, 0, 32}, //Should have 2 x 16 notifications (2 because it plays twice)
                                    {{0}, 0, 2},  //DMUS_NOTIFICATION_MUSICSTARTED, DMUS_NOTIFICATION_MUSICALMOSTEND (not DMUS_NOTIFICATION_MUSICSTOPPED)
                                    {{0}, 0, 3}   //SEGSTART, SEGLOOP, SEGALMOSTEND, (not SEGEND)
                                  };

    BOOL bAdd[3] = {0};
    BOOL bRem[3] = {0};
    GUID *pGuid[3] = {(GUID *)&GUID_NOTIFICATION_MEASUREANDBEAT,
                      (GUID *)&GUID_NOTIFICATION_PERFORMANCE,
                      (GUID *)&GUID_NOTIFICATION_SEGMENT
                      };
    char *pszName[3] = {"GUID_NOTIFICATION_MEASUREANDBEAT",
                      "GUID_NOTIFICATION_PERFORMANCE",
                      "GUID_NOTIFICATION_SEGMENT"
                      };
    BOOL bNotificationsAdded = FALSE;    
    DWORD j;

    /*
    #define TEST_MEASUREANDBEAT 0
    #define TEST_PERFORMANCE    1
    #define TEST_SEGMENT        2
*/

    
    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DMusic/DMTest1/Perf8/AddNot/Notify.sgt", "T:\\DMTest1\\Perf8\\AddNot\\",    COPY_IF_NEWER},
                                    {"DLS/Main1.DLS",          "T:\\DMTest1\\Perf8\\AddNot\\",    COPY_IF_NEWER},
                                    {TERMINATE}
                                    };
    CHECKRUN(LoadMedia(MediaFileDesc));
   
    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Perf8\\AddNot\\Notify.sgt", DMUS_APATH_DYNAMIC_MONO));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptAudioPath));

    //Get the IDirectMusicSegment interface.
    CHECKRUN(Music.GetInterface(&ptSegment8));

    //Get the IDirectMusicSegment interface.
    CHECKRUN(Music.GetInterface(&ptInterface));

    //Stop the music for the moment.
    CHECKRUN(ptPerf8->StopEx(ptSegment8, __int64(0), 0));

    //Tell the segment to repeat once (play twice);
    CHECKRUN(ptSegment8->SetRepeats(1));

    //Set up the array of Booleans.
    for (i=0; i<3; i++)
    {
        bAdd[i] = dwAddNotificationTypes & (1 << i);
        bRem[i] = dwRemNotificationTypes & (1 << i);
    }


    //Add notification types.
    for (i=0; i<3; i++)
    {
        if (bAdd[i])
        {
            CHECKRUN(ptInterface->AddNotificationType(*pGuid[i]));
        }
    }

    //Remove notification types.
    for (i=0; i<3; i++)
    {
        if (bRem[i])
        {
            CHECKRUN(ptInterface->RemoveNotificationType(*pGuid[i]));
        }
    }
    bNotificationsAdded = TRUE;

    //Play and stop a specified # of times.
    for (i=0; i<dwRestarts; i++)
    {
        CHECKRUN(Log(FYILOGLEVEL, "Playing music with notifications on for 4 seconds.  Not polling for pMsgs"));
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, __int64(0), NULL, NULL, ptAudioPath));
        CHECKRUN(Wait(4000));
        CHECKRUN(ptPerf8->StopEx(ptSegment8, NULL, NULL));
        CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 5000, NULL, FALSE));
    }

    //Wipe out all pMsgs accumulated from that run.
    CHECKRUN(Log(FYILOGLEVEL, "Stopped music; clearing all pMsgs."));
    CHECKRUN(ClearAllPMsgs(ptPerf8));

    //Play on the audiopath.
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, __int64(0), NULL, NULL, ptAudioPath));

    //Wait for segment to start playing.
    CHECKRUN(Log(FYILOGLEVEL, "Started music; checking for pMsgs."));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL, FALSE));

    BOOL  bStoppedPlaying = FALSE;

    //Time to start recording the events that come in.   Do this for 10 seconds.
    if (SUCCEEDED(hr))
    {
        HRESULT hrMessage = S_OK;
        do
        {
            pMsg = NULL;
            if (SUCCEEDED(hr))
                hrMessage = ptPerf8->GetNotificationPMsg(&pMsg);

            //If we got one, then store it somewhere.
            if (S_OK == hrMessage)
            {
                if (!pMsg)
                {
                    hr = E_FAIL;
                    Log(ABORTLOGLEVEL, "GetNotificationPMsg returned %s (%08X) but pMsg was NULL!!", tdmXlatHRESULT(hr), hr);
                    break;
                }

                BOOL bFound = FALSE;            
                for (i=0; i<3; i++)
                {
                    if (memcmp((void *)&pMsg->guidNotificationType, (void *)pGuid[i], sizeof(GUID))==0)
                    {
                        MUSIC_TIME mtNow;
                        ptPerf8->GetTime(NULL, &mtNow);
                        Log(FYILOGLEVEL, "%2d. GUID: %s, dwNotificationOption: %d, Field1: %d, Field2: %d, SegState: %lx, ID: %ld ", 
                            PMsgCounter[i].dwCount, pszName[i], pMsg->dwNotificationOption, pMsg->dwField1, pMsg->dwField2, pMsg->punkUser, pMsg->dwVirtualTrackID);
                        if (PMsgCounter[i].dwCount == PMsgCounter[i].dwExpected)
                        {
                            hr = E_FAIL;
                            Log(ABORTLOGLEVEL, "**** ABORT: Got more than %d notifications for %s", PMsgCounter[i].dwExpected, pszName[i]);
                            if (pMsg)
                            {
                                ptPerf8->FreePMsg((DMUS_PMSG*)pMsg);
                                pMsg = NULL;
                            }
                        }
                        else
                        {                            
                            //Move the pMsg from the local variable to the array, which will have FreePMsg called on it later.
                            PMsgCounter[i].pMsg[PMsgCounter[i].dwCount] = pMsg;
                            PMsgCounter[i].dwCount++;                            
                            pMsg = NULL;  
                        }

                        bFound = TRUE;
                        break;
                    }
                }

                
                if (!bFound && pMsg) 
                {
                    ptPerf8->FreePMsg((DMUS_PMSG*)pMsg);
                    pMsg = NULL;
                }
            }

        
            if (!bStoppedPlaying && ptPerf8->IsPlaying(ptSegment8, NULL) != S_OK)
            {
                bStoppedPlaying = TRUE;
            }
        }
        while (!bStoppedPlaying || S_OK == hrMessage);
        
    }//end if (SUCCEEDED(hr))



    //Analyze the counts of each type according to the flags that were passed in.
    if (SUCCEEDED(hr))
    {
        for (i=0; i<3; i++)
        {
            if (bAdd[i] && !bRem[i])
            {
                //Make sure the count is the same.
                if (PMsgCounter[i].dwCount != PMsgCounter[i].dwExpected)
                {
                    hr = E_FAIL;
                    Log(ABORTLOGLEVEL, "**** ABORT: Got %d notifications for %s instead of %d",
                                          PMsgCounter[i].dwCount, pszName[i], PMsgCounter[i].dwExpected);
                }

                for (j=0; j<32; j++)
                {
                    if (PMsgCounter[i].pMsg[j])
                        if (memcmp((void *)&PMsgCounter[i].pMsg[j]->guidNotificationType, (void *)&GUID_NOTIFICATION_MEASUREANDBEAT, sizeof(GUID))==0)
                        {
                            //Check the individual pMsgs.
                            if (PMsgCounter[i].pMsg[j]->dwNotificationOption != DMUS_NOTIFICATION_MEASUREBEAT)
                            {
                                Log(ABORTLOGLEVEL, "PMsg %d's dwNotificationOption was %d instead of GUID_NOTIFICATION_MEASUREANDBEAT", j, PMsgCounter[i].pMsg[j]->dwNotificationOption);
                                hr = E_FAIL;
                            }

                            if (PMsgCounter[i].pMsg[j]->dwField1 != j%4)
                            {
                                Log(ABORTLOGLEVEL, "PMsg %d's dwField1 (BEAT) was %d instead of %d", j, PMsgCounter[i].pMsg[j]->dwField1, j%4);
                                hr = E_FAIL;
                            }

                            if (PMsgCounter[i].pMsg[j]->dwField2 != (j/4) % 4)
                            {
                                Log(ABORTLOGLEVEL, "PMsg %d's dwField2 (MEASURE) was %d instead of %d", j, PMsgCounter[i].pMsg[j]->dwField2, (j/4) % 4);
                                hr = E_FAIL;
                            }
                        }
                }
            }
            else
            {
                if (PMsgCounter[i].dwCount !=  0)
                {
                    hr = E_FAIL;
                    Log(ABORTLOGLEVEL, "**** ABORT: Got %d notifications for %s instead of 0", PMsgCounter[i].dwCount, pszName[i]);
                }
            }
        }
    }

    for (i=0; i<3; i++)
    {
        //Release all the NotificationMeasureAndBeat pMsgs.
        for (j=0; j<32; j++)
        {
            if (PMsgCounter[i].pMsg[j])
            {
                ptPerf8->FreePMsg((DMUS_PMSG*)PMsgCounter[i].pMsg[j]);
                PMsgCounter[i].pMsg[j] = NULL;
            }
        }
    }


    //Remove any notifications that were added.
    if (bNotificationsAdded)
    {
        for (i=0; i<3; i++)
        {
            if (bAdd[i] && !bRem[i])
            {
                if (ptInterface)
                {
                    ptInterface->RemoveNotificationType(*pGuid[i]);
                }
            }
        }
    }

   SAFE_RELEASE(ptInterface);
   SAFE_RELEASE(ptAudioPath);
   SAFE_RELEASE(ptSegment8);

    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_CloseDown.cpp ===
#include "globals.h"
#include "helpers.h"
#include "cicmusicx.h"
/*
#define BEFORESTOPPING 1
#define BEFOREUNLOADING 2
#define BEFORERELEASINGPATH 3
#define AFTEREVERYTHINGELSE 4
#define TWICE 5
*/



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_CloseDown_WhilePlaying(CtIDirectMusicPerformance8* ptPerf8_x, DWORD dwScenario, DWORD dwUnused2)
{
    HRESULT hr = S_OK;


    CtIDirectMusicPerformance8* ptPerf8 = NULL;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    LPSTR szSegmentName = (LPSTR)g_TestParams.szDefaultMedia;

    
    if (!InitPerformanceNever())
        return S_OK;

    ASSERT(!ptPerf8_x);

    CHECKRUN(dmthCreatePerformance(IID_IDirectMusicPerformance, &ptPerf8))
    CHECKRUN(ptPerf8->InitAudioX(NULL, NULL, g_TestParams.dwDMVoiceCount, g_TestParams.bDoWorkLocalThread ? DMUS_INITAUDIO_NOTHREADS : 0));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_3D, 16, TRUE, &ptPath));
    CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,NULL,0,ptPath));
    CHECKRUN(Log(FYILOGLEVEL, "Playing %s times; waiting until done", szSegmentName));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE));
    CHECKRUN(Wait(2000));
    
    if (ptPerf8)
    {
        if (CLOSEDOWN_BEFORESTOPPING == dwScenario)
            ptPerf8->CloseDown();

        CHECKRUN(Wait(1000));    

        if (CLOSEDOWN_BEFOREUNLOADING == dwScenario)
            ptPerf8->CloseDown();
    }


    SAFE_RELEASE(ptSegment);

    if (ptPerf8)
    {
        if (CLOSEDOWN_BEFORERELEASINGPATH == dwScenario)
            ptPerf8->CloseDown();
    }

    SAFE_RELEASE(ptPath);    

    if (ptPerf8)
    {
        if (CLOSEDOWN_AFTEREVERYTHINGELSE== dwScenario)
            ptPerf8->CloseDown();
    }

    SAFE_RELEASE(ptPerf8);


    if (ptPerf8)
    {
        if (CLOSEDOWN_TWICE == dwScenario)
        {
            ptPerf8->CloseDown();
            ptPerf8->CloseDown();
        }
    }



    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_AllocPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_AllocPMsg_Many(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg_Big(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg_Generic(CtIDirectMusicPerformance8* ptPerf8);



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_AllocPMsg_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_AllocPMsg())");
    DMTEST_EXECUTE(Performance8_AllocPMsg_Generic(ptPerf8));  //PASS
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_AllocPMsg_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_AllocPMsg())");

    DMTEST_EXECUTE(Performance8_AllocPMsg_Many(ptPerf8));  //PASS
    DMTEST_EXECUTE(Performance8_AllocPMsg_Big(ptPerf8));   //PASS

    return hr;
};


/********************************************************************************
Note: Tested by itself, we can allocate 976521 PMsgs.  Let's just do 900000 for now.
********************************************************************************/
typedef DMUS_PMSG* LPDMUS_PMSG;
HRESULT Performance8_AllocPMsg_Many(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwMax = 800000; //Allocate dwMax PMsgs
    DWORD i = 0;
    LPDMUS_PMSG *ppMsg = NULL;
    
    
    ppMsg = new LPDMUS_PMSG[dwMax];
    CHECKALLOC(ppMsg);

    //Allocate the PMsgs.
    for (i=0; i<dwMax && SUCCEEDED(hr); i++)
    {
        if (i%100000 == 0)
            Log(FYILOGLEVEL, "Allocated %d pMsgs...", i);
        CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_PMSG), &ppMsg[i]));
    }

    //Free these PMsgs.
    for (i=0; i<dwMax && SUCCEEDED(hr); i++)
    {
        if (ppMsg[i])
        {
            ptPerf8->FreePMsg(ppMsg[i]);
            ppMsg[i] = NULL;
            if (i%100000 == 0)
                Log(FYILOGLEVEL, "Freed %d pMsgs...", i);

        }
    }

    delete []ppMsg;
    //SAFEDELETE(ppMsg);
    return hr;

};



/********************************************************************************
To the closest million, I could allocate a message of size 13000000.  14000000 failed.
********************************************************************************/
HRESULT Performance8_AllocPMsg_Big(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT     hr  = S_OK;
    DMUS_PMSG * pMsg= NULL;
    DWORD dwSize = 1000;

    //Allocate the PMsg
    CHECKRUN(ptPerf8->AllocPMsg(dwSize,  &pMsg));  //Allocate an appx 13 MB PMsg

    //Free these PMsgs.
    if (pMsg)
    {
        ptPerf8->FreePMsg(pMsg);
        pMsg = NULL;
    }

    return hr;

};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_AllocPMsg_Generic(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    CHECKALLOC(pTempo);

    if (SUCCEEDED(hr))
    {
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTempo );
        if (FAILED(hr))
        {
            ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo );
            pTempo = NULL;
            goto TEST_END;
        }


        Log(FYILOGLEVEL, "Just sent a temp=500 pMsg, should notice a tempo change.  Playing at tempo=500 for 5s.");
        Wait(5000);
    }

TEST_END:
    //No need to free a sent pMsg.
    return hr;
};


//lint -e10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_AllocPMsg_Invalid.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_AllocPMsg_Invalid_SizeZero(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg_Invalid_SizeSmall(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg_Invalid_SizeBig(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg_Invalid_NULLppMsg(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_AllocPMsg_Invalid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_AllocPMsg_Invalid())");
    
    Performance8_AllocPMsg_Invalid_SizeZero(ptPerf8);  
    Performance8_AllocPMsg_Invalid_SizeSmall(ptPerf8); 
    Performance8_AllocPMsg_Invalid_SizeBig(ptPerf8);   
    Performance8_AllocPMsg_Invalid_NULLppMsg(ptPerf8); 


    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_AllocPMsg_Invalid_SizeZero(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DMUS_PMSG *pMsg = NULL;
    CHECKRUN(ptPerf8->AllocPMsg(0, &pMsg));
    return hr;

};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_AllocPMsg_Invalid_SizeSmall(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DMUS_PMSG *pMsg = NULL;
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_PMSG) - 1, &pMsg));
    return hr;

};




/********************************************************************************
********************************************************************************/
HRESULT Performance8_AllocPMsg_Invalid_SizeBig(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DMUS_PMSG *pMsg = NULL;
    CHECKRUN(ptPerf8->AllocPMsg(0xFFFFFFFF, &pMsg));
    return hr;

};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_AllocPMsg_Invalid_NULLppMsg(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_PMSG), NULL));
    Log(FYILOGLEVEL, "Function correctly asserted!!");
    return hr;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_ClonePMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "help_comcounter.h"


HRESULT Performance8_ClonePMsg_BVT1(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_ClonePMsg_AddRefpUnk(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_ClonePMsg_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_ClonePMsg())");             //PASS!!
    DMTEST_EXECUTE(Performance8_ClonePMsg_BVT1(ptPerf8));
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_ClonePMsg_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_ClonePMsg())");           //PASS
    DMTEST_EXECUTE(Performance8_ClonePMsg_AddRefpUnk(ptPerf8));
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_ClonePMsg_BVT1(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo  = NULL;
DMUS_TEMPO_PMSG* pCloned = NULL;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    CHECKALLOC(pTempo);


    if (SUCCEEDED(hr))
    {    
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
    }

    //Clone it.
    CHECKRUN(ptPerf8->ClonePMsg((DMUS_PMSG*)pTempo, (DMUS_PMSG**)&pCloned));
    CHECKALLOC(pCloned);
    if (FAILED(hr))
        goto TEST_END;

    //Make sure it's exactly the same.
    if (memcmp(pTempo, pCloned, sizeof(DMUS_TEMPO_PMSG)) != 0)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "Cloned PMsg is different than original");
        goto TEST_END;
    }

    //Send the PMsg.
    CHECKRUN(ptPerf8->SendPMsg( (DMUS_PMSG*)pCloned));

    Log(FYILOGLEVEL, "Just sent a tempo=500 pMsg, should notic a tempo change.  Playing at tempo=500 for 5s.");
    Wait(5000);

TEST_END:
    //Free the unsent one yerself.
    if (pTempo)
        ptPerf8->FreePMsg((DMUS_PMSG*)pTempo);

    return hr;
};





/********************************************************************************
Verify that ClonePMsg addrefs the punkUser.
********************************************************************************/
HRESULT Performance8_ClonePMsg_AddRefpUnk(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;
DMUS_TEMPO_PMSG* pCloned = NULL;
CComCounter *pUnkComCounter = NULL;

    //Create our virtual COM object.
    CHECKRUN(CreateComCounter(&pUnkComCounter));

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    if (pTempo)
    {
        //Set up some typical data.
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        pTempo->punkUser = (IUnknown *)pUnkComCounter;
    }

    //Clone it.
    CHECKRUN(ptPerf8->ClonePMsg((DMUS_PMSG*)pTempo, (DMUS_PMSG**)&pCloned));


    //Make sure our COM object was addref'd.
    if (pUnkComCounter->m_dwCalledRelease != 0)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's Release was called %d instead %d times", pUnkComCounter->m_dwCalledRelease, 1);
        goto TEST_END;
    }

    if (pUnkComCounter->m_dwCalledAddRef != 1)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's AddRef was called %d instead %d times", pUnkComCounter->m_dwCalledAddRef, 1);
        goto TEST_END;
    }

    if (pUnkComCounter->m_dwCalledQueryInterface != 0)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's QueryInterface was called %d instead %d times", pUnkComCounter->m_dwCalledQueryInterface, 1);
        goto TEST_END;
    }

//    if (
    CHECKRUN(ptPerf8->FreePMsg((DMUS_PMSG *)pTempo));
    CHECKRUN(ptPerf8->FreePMsg((DMUS_PMSG *)pCloned));

TEST_END:
    pUnkComCounter->ActualRelease();
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetNotificationPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_GetNotificationPMsg_Valid(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


HRESULT Performance8_GetNotificationPMsg_BVT(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_GetNotificationPMsg_Valid(ptPerf8, dwUnused1, dwUnused2);
}


/********************************************************************************
********************************************************************************/
#define MAX 100
HRESULT Performance8_GetNotificationPMsg_Valid(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT                     hr              = S_OK;
    CICMusic                    Music;
    CtIDirectMusicAudioPath     *ptAudioPath     = NULL;
    CtIDirectMusicSegment8      *ptSegment8        = NULL;
    DWORD                       i = 0;
//    DMUS_NOTIFICATION_PMSG *    pMsg = NULL;
    DMUS_NOTIFICATION_PMSG *    pMsgStored[MAX] = {0};
    DWORD                       dwStored = 0;
/*
    GUID *pGuid[3] = {(GUID *)&GUID_NOTIFICATION_MEASUREANDBEAT,
                      (GUID *)&GUID_NOTIFICATION_PERFORMANCE,
                      (GUID *)&GUID_NOTIFICATION_SEGMENT
                      };
    char *pszName[3] = {"GUID_NOTIFICATION_MEASUREANDBEAT",
                      "GUID_NOTIFICATION_PERFORMANCE",
                      "GUID_NOTIFICATION_SEGMENT"
                      };
*/
    BOOL bNotificationsAdded = FALSE;    
    DWORD j;

    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DMusic/DMTest1/Perf8/AddNot/Notify.sgt", "T:\\DMTest1\\Perf8\\AddNot\\",    COPY_IF_NEWER},
                                    {"DLS/Main1.DLS",          "T:\\DMTest1\\Perf8\\AddNot\\",    COPY_IF_NEWER},
                                    {TERMINATE}
                                    };
    CHECKRUN(LoadMedia(MediaFileDesc));
   
    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Perf8\\AddNot\\Notify.sgt", DMUS_APATH_DYNAMIC_MONO));

    //Get the IDirectMusicAudioPath interface.
    CHECKRUN(Music.GetInterface(&ptAudioPath));

    //Get the IDirectMusicSegment interface.
    CHECKRUN(Music.GetInterface(&ptSegment8));

    //Stop the music for the moment.
    CHECKRUN(ptPerf8->StopEx(ptSegment8, __int64(0), 0));

    //Tell the segment to repeat once (play twice);
    CHECKRUN(ptSegment8->SetRepeats(1));

    CHECKRUN(ptPerf8->AddNotificationType(GUID_NOTIFICATION_SEGMENT));
    bNotificationsAdded = TRUE;

    CHECKRUN(ClearAllPMsgs(ptPerf8));

    //Play and stop a specified # of times.
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, __int64(0), NULL, NULL, ptAudioPath));

    //Wait for segment to start playing.
    CHECKRUN(Log(FYILOGLEVEL, "Started music; checking for pMsgs."));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL, FALSE));

    //Get and free everything that comes in.
    if (SUCCEEDED(hr))
    {
        HRESULT hrPMSG = S_OK;
        do
        {
            hrPMSG= ptPerf8->GetNotificationPMsg(&pMsgStored[dwStored++]);
            if (dwStored > MAX)
            {
                Log(ABORTLOGLEVEL, "Got over %d pMsgs", MAX);
                break;
            }
        }
        while (ptPerf8->IsPlaying(ptSegment8, NULL) == S_OK);
    }//end if (SUCCEEDED(hr))

    for (i=0; i<MAX; i++)
    {
        if (pMsgStored[i])
        {
            ptPerf8->FreePMsg((DMUS_PMSG *)pMsgStored[i]);
            pMsgStored[i] = NULL;
        }
    }

    //Remove any notifications that were added.
    if (bNotificationsAdded)
    {
        ptPerf8->RemoveNotificationType(GUID_NOTIFICATION_SEGMENT);
    }


   SAFE_RELEASE(ptAudioPath);
   SAFE_RELEASE(ptSegment8);

    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_FreePMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "help_comcounter.h"

HRESULT Performance8_FreePMsg_BVT1(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_FreePMsg_ReleasepUnk(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_FreePMsg_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_FreePMsg())");
    DMTEST_EXECUTE(Performance8_FreePMsg_BVT1(ptPerf8));
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_FreePMsg_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Valid test function Performance8_FreePMsg())");
    DMTEST_EXECUTE(Performance8_FreePMsg_ReleasepUnk(ptPerf8));
    return hr;
};





/********************************************************************************
Allocate and free a PMsg.
********************************************************************************/
HRESULT Performance8_FreePMsg_BVT1(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    if (pTempo)
    {
        //Set up some typical data.
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        CHECKRUN(ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo ));
    }

    return hr;
};



/********************************************************************************
Make sure that the pUnknown associated with a pMsg is freed also.
********************************************************************************/
HRESULT Performance8_FreePMsg_ReleasepUnk(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;
CComCounter *pUnkComCounter = NULL;

    //Create our virtual COM object.
    CHECKRUN(CreateComCounter(&pUnkComCounter));

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    if (pTempo)
    {
        //Set up some typical data.
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        pTempo->punkUser = (IUnknown *)pUnkComCounter;
        CHECKRUN(ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo ));
    }

    //Make sure our COM object wasn't abused.
    if (pUnkComCounter->m_dwCalledRelease != 1)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's Release was called %d instead %d times", pUnkComCounter->m_dwCalledRelease, 1);
        goto TEST_END;
    }

    if (pUnkComCounter->m_dwCalledAddRef != 0)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's AddRef was called %d instead %d times", pUnkComCounter->m_dwCalledAddRef, 1);
        goto TEST_END;
    }

    if (pUnkComCounter->m_dwCalledQueryInterface != 0)
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "COM object's QueryInterface was called %d instead %d times", pUnkComCounter->m_dwCalledQueryInterface, 1);
        goto TEST_END;
    }


TEST_END:
    pUnkComCounter->ActualRelease();
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetGlobalParam.cpp ===
#include "globals.h"
#include "cicmusicx.h"


#include "globals.h"
#include "cicmusicx.h"


HRESULT Performance8_GetGlobalParam_Groove_Range(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetGlobalParam_Tempo_Range(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetGlobalParam_Volume_Range(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_GetGlobalParam_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_GetGlobalParam_BVT()");  //THESE ALL PASS!!!
    DMTEST_EXECUTE(Performance8_GetGlobalParam_Groove_Range(ptPerf8));
    DMTEST_EXECUTE(Performance8_GetGlobalParam_Tempo_Range (ptPerf8));
    DMTEST_EXECUTE(Performance8_GetGlobalParam_Volume_Range(ptPerf8));
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_GetGlobalParam_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_GetGlobalParam()");
    return hr;
};

/********************************************************************************
********************************************************************************/
HRESULT Performance8_GetGlobalParam_Groove_Range(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    char bOldMasterGrooveLevel                               = 0;
    char bNewMasterGrooveLevel                            = 0;
    LPCSTR szSegmentServer = "DMusic/DMTest1/Perf8/SetGlob/Groove.sgt";
    CHAR szSegment[MAX_PATH] = {0};
    char i = 0;


    CHECKRUN(MediaCopyDirectory(szSegmentServer));
    strcpy(szSegment, MediaServerToLocal(szSegmentServer));

    //Set the groove level to 1.
    bOldMasterGrooveLevel = 1;

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));


    //Go through all the groove levels.
    for (i=1; i<=100; i++)
    {    
        bNewMasterGrooveLevel = i;
        if (i%20 == 0)
            Log(FYILOGLEVEL, "Setting bNewMasterGrooveLevel to %d", i);
        CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&i, sizeof(i)));
        CHECKRUN(ptPerf8->GetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bNewMasterGrooveLevel, sizeof(bNewMasterGrooveLevel)));
        if (bNewMasterGrooveLevel != i)
        {
            Log(ABORTLOGLEVEL, "Error: We set a groove level of %d and retrieved %d", i, bNewMasterGrooveLevel);
	        goto TEST_END;
        }
    }

    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bOldMasterGrooveLevel, sizeof(bOldMasterGrooveLevel)));
    Log(ABORTLOGLEVEL, "Setting groove level back to %d", bOldMasterGrooveLevel);
    Wait(1000);

TEST_END:
    SAFE_RELEASE(ptSegment8);
    return  hr;
};





/********************************************************************************
********************************************************************************/
HRESULT Performance8_GetGlobalParam_Tempo_Range(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    FLOAT fOldTempo                               = 0;
    FLOAT fNewTempo                            = 0;
    CHAR *szSegment = g_TestParams.szDefaultMedia;
    FLOAT f = 0;
    DWORD dwCounter = 0;

    //Set the tempo level to 1.
    fOldTempo = 1.f;

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    Wait(2000);


    //Set the tempo up way high.
    for (f = DMUS_MASTERTEMPO_MIN; f < DMUS_MASTERTEMPO_MAX && SUCCEEDED(hr); f+= (DMUS_MASTERTEMPO_MAX - DMUS_MASTERTEMPO_MIN) / 100)
    {

        //Logging
        if (dwCounter++ % 20 == 0)
        {
            Log(ABORTLOGLEVEL, "fNewTempo = %g.", f);
        }

        CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&f, sizeof(f)));
        CHECKRUN(ptPerf8->GetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempo, sizeof(fNewTempo)));
        if (!FloatsAreEqual(fNewTempo,f))
        {
            Log(ABORTLOGLEVEL, "Error: We set a tempo of %g and retrieved %g", f, fNewTempo);
            hr = E_FAIL;
        }
    }

    //Set the old one again, even if our test failed.    
    ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo));
    Log(ABORTLOGLEVEL, "Setting tempo back to %d", fOldTempo);
    Wait(1000);
    SAFE_RELEASE(ptSegment8);
    return  hr;
};



/********************************************************************************
d********************************************************************************/
HRESULT Performance8_GetGlobalParam_Volume_Range(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    long  lOldVolume                               = 0;
    long lNewVolume                            = 0;
    CHAR *szSegment = g_TestParams.szDefaultMedia;
    long i = 0;

    //Set the volume level to 0
    lOldVolume = 0;

    //Start music playing.
    Log(FYILOGLEVEL, "Playing %s normally.", szSegment);
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));

    //Set the Volume up way high.
    for (i = -200; i<=20; i++)
    {
        if (i%20==0)
        {
            Log(ABORTLOGLEVEL, "Setting Volume to %d", i);
        }

        CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&i, sizeof(i)));
        CHECKRUN(ptPerf8->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lNewVolume, sizeof(lNewVolume)));
        if (i != lNewVolume)
        {
            Log(ABORTLOGLEVEL, "Error: We set a volume level of %d and retrieved %d", i, lNewVolume);
	        goto TEST_END;
        }
    }


    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume)));
    Log(ABORTLOGLEVEL, "Setting Volume back to %d", lOldVolume);
    Wait(1000);

TEST_END:
    SAFE_RELEASE(ptSegment8);
    return  hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetParamEx.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_GetParamEx_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_GetParamEx())");
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_GetParamEx_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_GetParamEx())");
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_CreateStandardAudioPath.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_CreateStandardAudioPath_AllCombos(CtIDirectMusicPerformance8* ptPerf8, DWORD bAllCombos, DWORD dwUnused2);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    CtIDirectMusicAudioPath *ptPath = NULL;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_CreateStandardAudioPath_BVT())");

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          16,
                                          TRUE,
                                          &ptPath));

    RELEASE(ptPath);


    return hr;
};


/********************************************************************************
//Later we'll go through the entire audiopath and make sure we can get everything
//  out of it.  For now though we'll just play a bunch of stuff on them.

********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_AllCombos(CtIDirectMusicPerformance8* ptPerf8, DWORD bAllCombos, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath     = NULL;
DWORD dwStandardPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, 
                         DMUS_APATH_DYNAMIC_MONO,
                         DMUS_APATH_SHARED_STEREO,
                         DMUS_APATH_DYNAMIC_3D};
DWORD dwPChannelValues[] = {1, 16, 17, 999, 1000};
BOOL bActivateValues[] = {0, 99};
DWORD dwStandardPath = 0;
DWORD dwPChannelValue = 0;
DWORD dwActivateValue = 0;


    //Load Default Media.
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment8));

    for (dwStandardPath = 0; dwStandardPath<AMOUNT(dwStandardPaths); dwStandardPath++)
    {
        for (dwPChannelValue=0; dwPChannelValue<AMOUNT(dwPChannelValues); dwPChannelValue++)
        {
            for (dwActivateValue=0; dwActivateValue<AMOUNT(bActivateValues); dwActivateValue++)
            {
                //Create the audiopath.
                Log(FYILOGLEVEL, "dwStandardPath = %s", dmthXlatDMUS_APATH(dwStandardPaths[dwStandardPath]));
                Log(FYILOGLEVEL, "dwPChannels    = %d", dwPChannelValues[dwPChannelValue]);
                Log(FYILOGLEVEL, "Activate       = %s", bActivateValues[dwActivateValue] ? "TRUE " : "FALSE");
                CHECKRUN(ptPerf8->CreateStandardAudioPath(dwStandardPaths[dwStandardPath],
                                                      dwPChannelValues[dwPChannelValue],
                                                      bActivateValues[dwActivateValue],
                                                      &ptPath));

                //If it's an active audiopath, download to and try to play the segment.
                if (bActivateValues[dwActivateValue])
                {

	                CHECKRUN(ptPerf8->PlaySegmentEx( 
		                ptSegment8, 
		                0,
		                NULL,
                        0, 
		                0,
		                NULL,
		                NULL,
		                ptPath));
                    Log(FYILOGLEVEL, "Playing segment on active audiopath for 3 seconds.");
                    Wait(3000);

                    //Stop the segment (is this necessary?)
	                CHECKRUN(ptPerf8->StopEx(ptSegment8, 0, 0));

                    if (FAILED(hr))
                        goto TEST_END;
                }
                
                //Release the audiopath.  The segment should stop playing.
                SAFE_RELEASE(ptPath);
            }

            //Break outta here if we're just doing one set.
            if (!bAllCombos)
                goto TEST_END;
        }
    }


TEST_END:
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return hr;
};



/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
HRESULT Performance8_Play2AudioPaths(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath[2]          = {NULL};
CtIDirectMusicSegmentState         *ptSegmentState[2] = {NULL};
CtIDirectMusicSegment8              *ptSegment8[2]      = {NULL};
CHAR *szFileName[2]               = {"T:\\DMTest1\\Test.sgt", "T:\\DMTest1\\Test2.sgt"};
DWORD i, dwIteration;

MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };


    CHECKRUN(LoadMedia(MediaFileDesc));

    for (dwIteration = 0; dwIteration < 2  && SUCCEEDED(hr); dwIteration++)
    {

        //Create the audiopath.
        for (i=0; i<2 && SUCCEEDED(hr); i++)
        {
            CHECKRUN(ptPerf8->CreateStandardAudioPath(i ? DMUS_APATH_DYNAMIC_MONO : DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                                  i ? 32 :                      64,
                                                  TRUE,
                                                  &ptPath[i]));

            //Load a segment.
            CHECKRUN(dmthLoadSegment(szFileName[i], &ptSegment8[i]));

            //PlaySegment.
	        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8[i],
                                        0,
                                        0,
                                        i ? DMUS_SEGF_SECONDARY : 0,
                                        0,
                                        &ptSegmentState[i],
                                        0,
                                        ptPath[i]));
            CHECKRUN(Log(FYILOGLEVEL, " Playing %s as %s segment for 4 seconds.", szFileName[i], i ? "secondary " : "primary "));
        }

        //Moment of silence.
        CHECKRUN(Wait(4000));

        //Stop everything anyway.
        CHECKRUN(ptPerf8->StopEx(0, 0, 0));
        CHECKRUN(Log(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop"));
        CHECKRUN(Wait(1000));

        //Release all items that might have been allocated.
        for (i=0; i<2; i++)
        {
            SAFE_RELEASE(ptSegment8[i]);
            SAFE_RELEASE(ptPath[i]);
            SAFE_RELEASE(ptSegmentState[i]);
        }

    }//end for dwIteration.

    //Release all items that might have been allocated.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment8[i]);
        SAFE_RELEASE(ptPath[i]);
        SAFE_RELEASE(ptSegmentState[i]);
    }

    return hr;

};









/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_Wait1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName               = g_TestParams.szDefaultMedia;
DWORD i = 0;


    //Create the audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath));

    //Load up media file.
    CHECKRUN(dmthLoadSegment(szFileName, &ptSegment8));

    //Play our segments.
    Log(FYILOGLEVEL, "Playing Segment:");
	CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8,
                                0,
                                0,
                                0,
                                0,
                                NULL,
                                0,
                                ptPath));


    //Now both segments are playing.
    Log(FYILOGLEVEL, "Playing %s as %s segment.", szFileName, i ? "secondary " : "primary ");
    Log(FYILOGLEVEL, "Should hear music playing for 2 seconds.");
    Wait(2000);


    CHECKRUN(ptPerf8->StopEx(NULL, 0, 0));
    Log(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL)");


    //Moment of silence.
    Log(FYILOGLEVEL, "Waiting 4 seconds");
    Wait(4000);

    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return hr;

};




/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_Wait2(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName               = g_TestParams.szDefaultMedia;
DWORD i = 0;


    //Create the audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath));

    //Load up media file.
    CHECKRUN(dmthLoadSegment(szFileName, &ptSegment8));

    //Play our segments.
    Log(FYILOGLEVEL, "Playing Segment:");
	CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8,
                                0,
                                0,
                                0,
                                0,
                                NULL,
                                0,
                                ptPath));
    Log(FYILOGLEVEL, " Playing %s as %s segment.", szFileName, i ? "secondary " : "primary ");


    //Now both segments are playing.
    Log(FYILOGLEVEL, "Should hear music playing for 5 seconds.");
    Wait(5000);


    CHECKRUN(ptPerf8->StopEx(NULL, 0, 0));
    Log(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 4 seconds");

    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return hr;

};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_Wait(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_StopEx())");
    DMTEST_EXECUTE(Performance8_CreateStandardAudioPath_Wait1(ptPerf8, 0, 0));
    DMTEST_EXECUTE(Performance8_CreateStandardAudioPath_Wait2(ptPerf8, 0, 0));  
    return hr;
}




/********************************************************************************

********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_LimitPChannels(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
LPCSTR szFileNameServer = "DMusic/DMTest1/Perf8/CreateStandardAudioPath/PChannel_Limit/PChannel_Limit.sgt";
CHAR szFileName[MAX_PATH]= {0};
DWORD i = 0;
DWORD dwPChannelValues[] = {1, 2, 3, 4};


    CHECKRUN(MediaCopyDirectory(szFileNameServer));
    strcpy(szFileName, MediaServerToLocal(szFileNameServer));

    //Load up media file.
    CHECKRUN(dmthLoadSegment(szFileName, &ptSegment8));

    for (i=0; i<AMOUNT(dwPChannelValues); i++)
    {

        //Create the audiopath.
        CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                              dwPChannelValues[i],
                                              TRUE,
                                              &ptPath));

        //Play our segments.
        Log(FYILOGLEVEL, "Playing Segment:");
	    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8,
                                    0,
                                    0,
                                    0,
                                    0,
                                    NULL,
                                    0,
                                    ptPath));
        Log(FYILOGLEVEL, "Maximum PChannels on path is %d, should numbers up through %d spoken.", dwPChannelValues[i], dwPChannelValues[i]);
        Wait(2000);

        //Stop anything that's playin'.
        CHECKRUN(ptPerf8->StopEx(NULL, 0, 0));

        //Release all items that might have been allocated.
        SAFE_RELEASE(ptPath);

    }



    SAFE_RELEASE(ptSegment8);

    return hr;

};




/********************************************************************************

********************************************************************************/

HRESULT Performance8_CreateStandardAudioPath_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD bFull, DWORD dwAudioPath)
{
    HRESULT hr = S_OK;
    IDirectMusicPerformance *pPerf = NULL;
    IDirectMusicAudioPath *pPath = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;

    
    ASSERT(IsValidAudioPath(dwAudioPath));
    
    if (!bFull)
        CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));

    dwStartTime = timeGetTime();
    do
    {

        if (bFull)
            CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));

        CHECKRUN(pPerf->CreateStandardAudioPath(dwAudioPath,64,TRUE,&pPath));
        SAFE_RELEASE(pPath);
        
        
        if (bFull)
            SAFE_RELEASE(pPerf);

        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    SAFE_RELEASE(pPath);
    SAFE_RELEASE(pPerf);
    return S_OK;
};






/********************************************************************************

********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_PerfMem_Bug10385(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTempoFactor, DWORD dwAudioPath)
{
    HRESULT hr = S_OK;
    IDirectMusicPerformance *pPerf = NULL;
    IDirectMusicAudioPath *pPath = NULL;
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicSegment *pSegment = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    float fTempoFactor = (float)dwTempoFactor;
    float fTempoFactorNormal = 1;
    LPCSTR szFile = g_TestParams.szDefaultMedia;
    CHAR szPath[MAX_PATH] = {0};

    ASSERT(IsValidAudioPath(dwAudioPath));    
    CHECKRUN(ChopPath(szFile, szPath, NULL));

    //Set the tempo factor.
    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));
    CHECKRUN(pPerf->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fTempoFactor, sizeof(fTempoFactor)));
    CHECKRUN(Log(FYILOGLEVEL, "Setting fNewTempoFactor to %g, will hear music at %g times normal tempo.", fTempoFactor, fTempoFactor));
    //CHECK(Wait(2000));

    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));
    CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
    CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));


    dwStartTime = timeGetTime();
    do
    {
        //Load a bunch of other stuff here too.        
        CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFile, (void **)&pSegment));
        CHECKRUN(pPerf->CreateStandardAudioPath(rand() % 2 ? DMUS_APATH_SHARED_STEREOPLUSREVERB : DMUS_APATH_DYNAMIC_MONO, 190, TRUE, &pPath));
        CHECKRUN(pPerf->PlaySegmentEx(pSegment, NULL, NULL, 0, 0, NULL, NULL, pPath));
        SAFE_RELEASE(pPath);
        SAFE_RELEASE(pSegment);
        CHECKRUN(pPerf->StopEx(0, 0, 0));
        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    SAFE_RELEASE(pPath);
    SAFE_RELEASE(pPerf);
    SAFE_RELEASE(pLoader);
    SAFE_RELEASE(pSegment);
    ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fTempoFactorNormal, sizeof(fTempoFactorNormal));
    //Sleep(2000);


    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetSetDefaultAudioPath.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_GetDefaultAudioPath_BVT_Same (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetSetDefaultAudioPath_Valid_Independent(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetSetDefaultAudioPath_Valid_Dependent(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
BVT test function.  Set and get all the different types of paths.
********************************************************************************/
HRESULT Performance8_GetSetDefaultAudioPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_GetSetDefaultAudioPath())");
    DMTEST_EXECUTE(Performance8_GetDefaultAudioPath_BVT_Same (ptPerf8));
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_GetSetDefaultAudioPath_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_GetSetDefaultAudioPath())");

    DMTEST_EXECUTE(Performance8_GetSetDefaultAudioPath_Valid_Independent(ptPerf8));
    DMTEST_EXECUTE(Performance8_GetSetDefaultAudioPath_Valid_Dependent(ptPerf8));  

    return hr;

};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_GetDefaultAudioPath_BVT_Same (CtIDirectMusicPerformance8* ptPerf8)
{

CtIDirectMusicAudioPath *ptAudioPath[2] = {NULL};
IDirectMusicAudioPath   *pAudioPath[2]  = {NULL};

DWORD dwPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_APATH_DYNAMIC_3D, DMUS_APATH_DYNAMIC_MONO, DMUS_APATH_SHARED_STEREO};
DWORD i,j = 0;
HRESULT hr = S_OK;

    //Set and get every type of default audiopath.
    for (i=0; i<AMOUNT(dwPaths) && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPaths[i], 8, TRUE, &ptAudioPath[0]);
        CHECKRUN(ptPerf8->SetDefaultAudioPath(ptAudioPath[0]));
        CHECKRUN(ptPerf8->GetDefaultAudioPath(&ptAudioPath[1]));
    
        //Get the real object pointers out and compare them.
        for (j=0; j<2; j++)
        {
            CHECKRUN(ptAudioPath[j]->GetRealObjPtr(&pAudioPath[j])));
        }

        //Compare them.
        if (pAudioPath[0] != pAudioPath[1])
        {
            hr = E_FAIL;
            Log(ABORTLOGLEVEL, "FAIL: Pointers are %08X and %08X, but should be equal!", pAudioPath[0], pAudioPath[1]);
            goto END;
        }

        //Release both real and wrapped audiopaths.
        for (j=0; j<2; j++)
        {
            SAFE_RELEASE(ptAudioPath[j]);
            SAFE_RELEASE(pAudioPath[j]);
        }
    }

    //Destroy reference to the default audiopath.
    ptPerf8->SetDefaultAudioPath(NULL);

END:
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptAudioPath[i]);
        SAFE_RELEASE(pAudioPath[i]);
    }


return S_OK;

};





/********************************************************************************
1) Set the default audiopath when music is playing.on another audiopath.
********************************************************************************/
HRESULT Performance8_GetSetDefaultAudioPath_Valid_Independent(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptAudioPath = NULL;
    CICMusic Music;

    DWORD dwPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_APATH_DYNAMIC_3D, DMUS_APATH_DYNAMIC_MONO, DMUS_APATH_SHARED_STEREO};
    DWORD dwPath = 0;
    DWORD i = 0;

    //Start the music playing.
    dwPath = DMUS_APATH_SHARED_STEREOPLUSREVERB;
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwPath));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Log(FYILOGLEVEL, "Playing %s on a separate %s for 2 seconds", g_TestParams.szDefaultMedia, dmthXlatDMUS_APATH(dwPath)));
    CHECKRUN(Wait(2000));

    //Go through all the paths and back.
    for (i=0; i<AMOUNT(dwPaths)+1 && SUCCEEDED(hr); i++)
    {
        dwPath = dwPaths[i % AMOUNT(dwPaths)];
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPath, 8, TRUE, &ptAudioPath));
        CHECKRUN(ptPerf8->SetDefaultAudioPath(ptAudioPath));
        CHECKRUN(Log(FYILOGLEVEL, "Switching default audiopath to %s for 1 second, should hear no sound change.", dmthXlatDMUS_APATH(dwPath)));
        CHECKRUN(Wait(1000));
        SAFE_RELEASE(ptAudioPath);
    }

    //Destroy reference to the default audiopath.
    CHECKRUN(ptPerf8->SetDefaultAudioPath(NULL));

    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptAudioPath);
    return hr;
};




/********************************************************************************
1) Set the default audiopath when music is playing.on the default audiopath.
********************************************************************************/
HRESULT Performance8_GetSetDefaultAudioPath_Valid_Dependent(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptAudioPath = NULL;
    CICMusic Music;

    DWORD dwPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_APATH_DYNAMIC_3D, DMUS_APATH_DYNAMIC_MONO, DMUS_APATH_SHARED_STEREO};
    DWORD dwPath = 0;
    DWORD i = 0;

    //Start the music playing.
    dwPath = DMUS_APATH_SHARED_STEREOPLUSREVERB;
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, dwPath));
    CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
    CHECKRUN(Music.GetInterface(&ptSegment));
    
    //Set this one as the default one.
    CHECKRUN(Music.GetInterface(&ptAudioPath));
    CHECKRUN(ptPerf8->SetDefaultAudioPath(ptAudioPath));
    RELEASE(ptAudioPath);

    dwPath = DMUS_APATH_SHARED_STEREOPLUSREVERB;
	CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,
                                0,
                                0,
                                0,
                                __int64(0),
                                0,
                                0,
                                NULL));


    CHECKRUN(Log(FYILOGLEVEL, "Playing %s on a default %s for 2 seconds", g_TestParams.szDefaultMedia, dmthXlatDMUS_APATH(dwPath)));
    CHECKRUN(Wait(2000));

    //Go through all the paths and back.
    for (i=0; i<AMOUNT(dwPaths)+1 && SUCCEEDED(hr); i++)
    {
        dwPath = dwPaths[i % AMOUNT(dwPaths)];
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPath, 8, TRUE, &ptAudioPath));
        CHECKRUN(ptPerf8->SetDefaultAudioPath(ptAudioPath));
        CHECKRUN(Log(FYILOGLEVEL, "Switching default audiopath to %s for 2 seconds, should hear no sound change.", dmthXlatDMUS_APATH(dwPath)));
        CHECKRUN(Wait(2000));
        SAFE_RELEASE(ptAudioPath);
    }

    //Destroy reference to the default audiopath.
    ptPerf8->SetDefaultAudioPath(NULL);

    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptAudioPath);
    return hr;
};



/********************************************************************************

********************************************************************************/
HRESULT Performance8_GetSetDefaultAudioPath_Valid_UserCreated(CtIDirectMusicPerformance8* ptPerf8)
{
//TODO: When user-created paths become available, 

return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_InitAudio_Invalid.cpp ===
#include "globals.h"
#include "cicmusicx.h"





/********************************************************************************
Valid test function.
********************************************************************************/
/*
HRESULT Performance8_InitAudio_Fatal (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    IDirectMusicPerformance *pPerformance = NULL;
    Log(FYILOGLEVEL, "Calling invalid test function Performance8_InitAudio())");

    hr = DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&pPerformance);
    hr = pPerformance->InitAudioX(NULL, NULL);
    
    _asm int 3;

    return hr;
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetTime.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
We measure reference time in real time.
********************************************************************************/
HRESULT Performance8_GetTime_BVT_ReferenceTime(CtIDirectMusicPerformance8* ptPerf8, DWORD dwErrorMargin, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;

REFERENCE_TIME rtStart=0, rtEnd=0, rtDiff=0;
REFERENCE_TIME rtExpected = 50000000;    
FLOAT fError = 0.f;         //
FLOAT fErrorMargin = (FLOAT)dwErrorMargin;

    //Play some music just to get things going.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(ptPerf8->GetTime(&rtStart , NULL));
    Log(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", DWORD(rtStart >> 32), DWORD(rtStart & 0xFFFFFFFF));
    Log(FYILOGLEVEL, "Waiting 5s from call.");
    
    //Wait 5s.
    CHECKRUN(Wait(5000));
    CHECKRUN(ptPerf8->GetTime(&rtEnd, NULL));

    //Calculate the results and pass or fail the test.
    rtDiff = abs(int(rtStart - rtEnd));
    Log(FYILOGLEVEL, "%d reference units passed; %d were expected to pass.", (DWORD)rtDiff, (DWORD)rtExpected);    
    fError = (FLOAT)fabs((FLOAT(rtDiff) - FLOAT(rtExpected)) / FLOAT(rtExpected) * 100.f);
    Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fError, fErrorMargin);
    if (fError > fErrorMargin)
    {
        hr = E_FAIL;
        goto TEST_END;
    }
    


TEST_END:
    return hr;
};



/********************************************************************************
We measure music time in notes.  This segment has 16 quarter notes, so it should
last DMUS_PPQ * 16 units in music time.
********************************************************************************/
HRESULT Performance8_GetTime_BVT_MusicTime(CtIDirectMusicPerformance8* ptPerf8, DWORD dwErrorMargin, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegment8      *ptSegment8       = NULL;
CtIDirectMusicSegmentState  *ptSegmentState   = NULL;
CtIDirectMusicAudioPath     *ptPath           = NULL;

MUSIC_TIME mtStart=0, mtEnd=0, mtDiff=0;
MUSIC_TIME mtExpected = DMUS_PPQ * 16;    
FLOAT fError = 0.f;
FLOAT fErrorMargin = (FLOAT)dwErrorMargin;

MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/16Notes.sgt",          "T:\\DMTest1\\Perf8\\GetTime\\", COPY_IF_NEWER},
                                {"DLS/Main1.DLS",            "T:\\DMTest1\\Perf8\\GetTime\\", COPY_IF_NEWER},
                                {TERMINATE}
                                };

    CHECKRUN(LoadMedia(MediaFileDesc));


    //Play some music just to get things going.
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Perf8\\GetTime\\16Notes.sgt", DMUS_APATH_SHARED_STEREOPLUSREVERB));

    //Get some interfaces.
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));

    //Stop the music.  We'll use the length of a segment to measure time.
    CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));

    //Tell it not to repeat.
    CHECKRUN(ptSegment8->SetRepeats(0));

    //Play the segment
	CHECKRUN(ptPerf8->PlaySegmentEx( 
		ptSegment8, 
		0,
		NULL,
        0, 
		//DMUS_SEGF_QUEUE,
		__int64(0),
		&ptSegmentState,
		NULL,
		ptPath));

    CHECKRUN(ExpectSegmentStart(ptPerf8, NULL, ptSegmentState, 5000, "16Notes.sgt"));

    //Get the time.
    CHECKRUN(ptPerf8->GetTime(NULL, &mtStart));

    if (SUCCEEDED(hr))
    {
        Log(FYILOGLEVEL, "Pre-playback MUSIC_TIME is %08X", mtStart);
        Log(FYILOGLEVEL, "Waiting 5s from call.");
    }
    
    //Wait for the segment to finish.
    CHECKRUN(ExpectSegmentStop(ptPerf8, NULL, ptSegmentState, 20000, "16Notes.sgt"));
    CHECKRUN(ptPerf8->GetTime(NULL, &mtEnd));

    //Calculate the results and pass or fail the test.
    if (SUCCEEDED(hr))
    {
        Log(FYILOGLEVEL, "Post-playback MUSIC_TIME is %08X", mtEnd);
        mtDiff = abs(mtStart - mtEnd);
        Log(FYILOGLEVEL, "%d MUSIC_TIME units passed; %d were expected", (DWORD)mtDiff, (DWORD)mtExpected);    
        fError = (FLOAT)fabs(  (FLOAT(mtDiff) - FLOAT(mtExpected)) / FLOAT(mtExpected) * 100.f);
        Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fError, fErrorMargin);
        if (fError > fErrorMargin)
        {
            hr = E_FAIL;
            goto TEST_END;
        }
    }
    

TEST_END:
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptPath);
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_GetTime_Valid_InOrder(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
MUSIC_TIME mtLast = 0, mtThis = 0;
DWORD dwStart = 0;
HRESULT hr = S_OK;
HRESULT hrCompare = S_OK;
CICMusic Music;

    
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    
    //Get the time.
    dwStart = timeGetTime();
    CHECKRUN(ptPerf8->GetTime(NULL, &mtLast));
    do
    {

        CHECKRUN(ptPerf8->GetTime(NULL, &mtThis));
        CHECKRUN(Log(MAXLOGLEVEL, "Current MUSIC_TIME is %d", mtThis));

        if (SUCCEEDED(hr))
        {
            if (mtThis < mtLast)
            {
                Log(FYILOGLEVEL, "Error: MUSIC_TIME reversed by %d units", mtLast- mtThis);
                hrCompare = E_FAIL;
            }        
            mtLast = mtThis;
        }
    }
    while (timeGetTime() - dwStart < 5000 && SUCCEEDED(hr));

    if (FAILED(hrCompare))
        hr = E_FAIL;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_InitAudio.cpp ===
#include "globals.h"
#include "cicmusicx.h"



HRESULT Performance8_InitAudio_Params(CtIDirectMusicPerformance8* ptPerf8, DWORD dwDefaultPath, DWORD dwPChannels, LPSTR szSegment);


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_InitAudio_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Performance8_InitAudio())");

    //Not going to mess with a global performance; it's too risky.  If it's not global; we'll shut this
    //  one down and then re-open it.  If that doesn't work we'll create another one.
    if (InitPerformanceOnce())
        return S_OK;

    //TODO: Add some more tests in here!!!!  Wasn't test

    return hr;
};

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_InitAudio_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_InitAudio())");

    //Not going to mess with a global performance; it's too risky.  If it's not global; we'll shut this
    //  one down and then re-open it.  If that doesn't work we'll create another one.
    if (InitPerformanceOnce())
        return S_OK;


//    DMTEST_EXECUTE(Performance8_InitAudio_Params       (ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, g_TestParams.szDefaultMedia));

    return hr;
};




/********************************************************************************
********************************************************************************/
/*
HRESULT Performance8_InitAudio_Params(CtIDirectMusicPerformance8* ptPerf8, DWORD dwDefaultPath, DWORD dwPChannels, LPSTR szSegment)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8  *ptSegment8 = NULL;
   
    //Start up the performance.
    CHECKRUN(ptPerf8->InitAudioX(NULL, NULL));//pAudioParams));

    //Play your content!
	CHECKRUN(dmthPlayMidiFile(ptPerf8,CTIID_IDirectMusicSegment,&ptSegment8, NULL, szSegment));
    Log(FYILOGLEVEL, "Called InitAudio(dwDefaultPath = %s, dwPChannels = %d", szSegment);
    Log(FYILOGLEVEL, "Should hear %s playing for 3 seconds.", szSegment);
    Wait(3000);


    SAFE_RELEASE(ptSegment8);
    return hr;
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_GetSegmentState.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_GetSegmentState_BVT1(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetSegmentState_1(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_GetSegmentState_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_GetSegmentState_BVT())");

    DMTEST_EXECUTE(Performance8_GetSegmentState_BVT1(ptPerf8));                                            

    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_GetSegmentState_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_GetSegmentState_Valid())");

    DMTEST_EXECUTE(Performance8_GetSegmentState_1(ptPerf8));  //PASSES!                                           

    return hr;
};





/********************************************************************************
********************************************************************************/
HRESULT Performance8_GetSegmentState_BVT1(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT                     hr                  = S_OK;
    CtIDirectMusicSegment8      *ptSegment          = NULL;
    CtIDirectMusicSegmentState  *ptSegmentState     = NULL;
    MUSIC_TIME                  mt                  = 1024;
    CICMusic Music;

    // Call PlayMidiFile() convienence function
    //CHECKRUN(dmthPlayMidiFile(ptPerf8,CTIID_IDirectMusicSegment,&ptSegment, &ptSegmentState, NULL));

    //Start the music playing.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));

    //Wait til it starts playing.
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE));

    // Call GetTime() and check results
    CHECKRUN(ptPerf8->GetTime( NULL, &mt ));

    // Call GetSegmentState and check resutls
    CHECKRUN(ptPerf8->GetSegmentState( &ptSegmentState, mt));

    // Call Stop and check results
    CHECKRUN(Wait(3000));
    CHECKRUN(ptPerf8->StopEx(NULL, __int64(0), 0));


    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptSegment);

    return hr;

}




/******************************************************************************************
******************************************************************************************/
HRESULT Performance8_GetSegmentState_1(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT                     hr              = S_OK;
    CtIDirectMusicSegment8      *pwSegment      = NULL;
    CtIDirectMusicSegmentState  *pwSegmentState = NULL;
    CtIDirectMusicAudioPath     *pwAudioPath    = NULL;
    MUSIC_TIME                  mt              = 0;

    CHAR                        *pSegmentFile   = g_TestParams.szDefaultMedia;

    // Get the Segment object
    CHECKRUN(dmthLoadSegment(pSegmentFile, &pwSegment));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, TRUE, &pwAudioPath));

    // Call GetTime to get the current time and check results
    CHECKRUN(ptPerf8->GetTime(NULL, &mt));

    //Queue segment for a ways in advance.
    Log(FYILOGLEVEL, "MUSIC_TIME is         %d.", mt);
    mt = mt + 1000000;
    Log(FYILOGLEVEL, "Queuing segment for   %d.", mt);


    // Call PlaySegment way into the future and check results
    CHECKRUN(ptPerf8->PlaySegmentEx(pwSegment, NULL, NULL, DMUS_SEGF_BEAT, __int64(mt), NULL, NULL, pwAudioPath));

    // Call GetSegmentState way in the future
    CHECKRUN(ptPerf8->GetSegmentState(&pwSegmentState, mt));
    Log(FYILOGLEVEL, "Getting segment state at %d.", mt);
    Wait(5000);
        
    // CLEANUP
    SAFE_RELEASE(pwSegment);
    SAFE_RELEASE(pwSegmentState);
    SAFE_RELEASE(pwAudioPath);
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_MusicToReferenceTime.cpp ===
#include "globals.h"
#include "cicmusicx.h"


/********************************************************************************
********************************************************************************/
HRESULT Performance8_MusicToReferenceTime_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
CICMusic Music;
MUSIC_TIME mtBase = 0;
REFERENCE_TIME rtBase = 0, rtConverted = 0;

//The 
//768 * 100BPM / 60s = MUSIC_TIME ticks per second.  
//FLOAT fTempo = 100.f;
FLOAT fMaxErrorPercent = 0.33f;  //1/3 percent error is allowed on this one.
FLOAT fErrorPercent = 0.f;
HRESULT hr = S_OK;


//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));


//Play some muzak, it will play at 100 BPM.  That's 2 BPS, or quarter-notes per second.  So each second, DMUS_PPQ*2 
//  MUSIC_TIME units will go by.
CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Test.sgt", DMUS_APATH_DYNAMIC_MONO));

//Get the base time in both formats.
CHECKRUN(ptPerf8->GetTime(&rtBase, &mtBase));

//Convert one to the other.
CHECKRUN(ptPerf8->MusicToReferenceTime(mtBase, &rtConverted));

//Get the error percent.
fErrorPercent = (FLOAT)CalculateErrorPercentage((double)rtBase, (double)rtConverted);

//Check the conversion.
Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fErrorPercent, fMaxErrorPercent);
if (fErrorPercent> fMaxErrorPercent)
{
    hr = E_FAIL;
    goto END;
}

END:

return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_MusicToReferenceTime_Repeat(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
CICMusic Music;
MUSIC_TIME mtBase = 0;
REFERENCE_TIME rtBase = 0;

MUSIC_TIME mtConverted = 0;
REFERENCE_TIME rtConverted = 0;


//The 
//768 * 100BPM / 60s = MUSIC_TIME ticks per second.  
//FLOAT fTempo = 100.f;
FLOAT fErrorPercent = 0.f;
FLOAT fMaxErrorPercent = 2.f;
HRESULT hr = S_OK;
DWORD i = 0;

//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));

//Play some muzak, it will play at 100 BPM.  That's 2 BPS, or quarter-notes per second.  So each second, DMUS_PPQ*2 
//  MUSIC_TIME units will go by.
CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Test.sgt", DMUS_APATH_DYNAMIC_MONO));

//Get the base time in both formats.
CHECKRUN(ptPerf8->GetTime(&rtBase, &mtBase));

mtConverted = mtBase;
rtConverted = rtBase;

//Repeatedly convert back and forth.
Log(FYILOGLEVEL, "Repeatedly converting MUSIC_TIME->REFERENCE_TIME...");
for (i=0; i<10000; i++)
{
    //Convert one to the other.
    CHECKRUN(ptPerf8->MusicToReferenceTime(mtConverted, &rtConverted));
    CHECKRUN(ptPerf8->ReferenceToMusicTime(rtConverted, &mtConverted));
    if (i%1000 == 0)
    {   
        Log(FYILOGLEVEL, "Iteration %5d: MUSIC_TIME = %08X, REFERENCE_TIME = %I64X", i, mtConverted, rtConverted);
    }
}

//Check REFERENCE_TIME
fErrorPercent = (FLOAT)fabs( FLOAT(rtConverted - rtBase) / FLOAT(rtBase)) * 100.f;
Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fErrorPercent, fMaxErrorPercent);
if (fErrorPercent> fMaxErrorPercent)
{
    hr = E_FAIL;
    goto END;
}

//Check MUSIC_TIME
fErrorPercent = (FLOAT)CalculateErrorPercentage((double)mtBase, (double)mtConverted);
Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fErrorPercent, fMaxErrorPercent);
if (fErrorPercent> fMaxErrorPercent)
{
    hr = E_FAIL;
    goto END;
}


END:


return hr;
};




    

/********************************************************************************
RT units = MT   beats    mt's    seconds   rt units
              / ------ / ----- * ------  * ------
                minute   beat    minute    second

RT units = MT   minutes  beats   seconds   rt units
              * ------  *----- * ------  * ------
                beat     mt      minute    second

RT units = MT   1                       1    60    10000000
              * ------               *  ---- --- * ------  
                (BPM * fTempoFactor)    768  1     1

RT units = MT   1                       1    60    10000000
              * ------               *  ---- --- * ------  
                (BPM * fTempoFactor)    768  1     1


RT units = MT   1                       1           60    10000000
              * ------               *  ----        --- * ------  
                (BPM * fTempoFactor)    DMUS_PPQ    1     1




RT units = MT   600000000
              * ------              
                BPM * fTempoFactor * DMUS_PPQ

********************************************************************************/
HRESULT Performance8_MusicToReferenceTime_TempoChange(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
MUSIC_TIME mtBase = 0;
REFERENCE_TIME rtBase = 0;
MUSIC_TIME mtDeltas[] = {0, 1, DMUS_PPQ, 0x70000};
REFERENCE_TIME rtConverted = 0;
REFERENCE_TIME rtTotalDeltaExpected = 0;
REFERENCE_TIME rtConvertedExpected = 0;
FLOAT fTempoFactors[] = {1.f, 0.5f, 0.01f, .2f, 100.f};
DWORD i = 0;
DWORD dwTempoIndex = 0;
FLOAT fNewTempoFactor= 0;
FLOAT fErrorPercent = 0.f, fMaxErrorPercent = 1.f;


//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));


//Play some muzak, it will play at 100 BPM.  That's 2 BPS, or quarter-notes per second.  So each second, DMUS_PPQ*2 
//  MUSIC_TIME units will go by.
CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Test.sgt", DMUS_APATH_DYNAMIC_MONO));


for (dwTempoIndex = 0; dwTempoIndex < AMOUNT(fTempoFactors) && SUCCEEDED(hr); dwTempoIndex++)
{
    //Set the tempo factor.
    fNewTempoFactor = fTempoFactors[dwTempoIndex];
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempoFactor, sizeof(fNewTempoFactor)));
    Log(FYILOGLEVEL, "Setting fNewTempoFactor to %g, will hear music at %g times normal tempo.", fNewTempoFactor, fNewTempoFactor);
    Log(FYILOGLEVEL, "Waiting 2 seconds");
    Wait(2000);

    //Get the base time.
    CHECKRUN(ptPerf8->GetTime(&rtBase, &mtBase));
    Log(FYILOGLEVEL, "Base times: mt = %u, rt = %I64u", mtBase, rtBase);

    //Check that all the deltas are converted correctly.
    for (i=0; i<AMOUNT(mtDeltas) && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ptPerf8->MusicToReferenceTime(mtDeltas[i] + mtBase, &rtConverted));
        rtTotalDeltaExpected = REFERENCE_TIME(mtDeltas[i]) * 600000000 / REFERENCE_TIME( FLOAT(DMUS_PPQ * 100) * fNewTempoFactor);
        //rtTotalDelta = rtConverted - rtBase;

        rtConvertedExpected = rtBase + rtTotalDeltaExpected;
        
        //Check the error factor here.
        fErrorPercent = (FLOAT)CalculateErrorPercentage((double)rtConvertedExpected, (double)rtConverted);
        Log(FYILOGLEVEL, "TempoFactor = %g, Delta = 0x%08X: Error = %5.2f%%, MaxError= %5.2f%%.", fNewTempoFactor, mtDeltas[i], fErrorPercent, fMaxErrorPercent);
        if (fErrorPercent> fMaxErrorPercent)
        {
            Log(ABORTLOGLEVEL, "   InParam  mt=%u", mtDeltas[i] + mtBase);
            Log(ABORTLOGLEVEL, "   OutParam rt=%020I64u", rtConverted);
            Log(ABORTLOGLEVEL, "   Expected rt=%020I64u", rtConvertedExpected);
            hr = E_FAIL;
            goto END;
        }

    }

}

//Reset the tempo.
fNewTempoFactor = 1.f;
ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempoFactor, sizeof(fNewTempoFactor));


END:
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_RemoveNotificationType.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_RemoveNotificationType_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_RemoveNotificationType())");

    Log(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN AddNotificationType ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_Release.cpp ===
/********************************************************************************
FILE:
    Performance8_Release.cpp

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_Release_Feb(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_Release (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_Release())");

    hr = Performance8_Release_Feb(ptPerf8);

    return hr;
};


/********************************************************************************
THIS SHOUDLD ASSERT!!!!
********************************************************************************/
HRESULT Performance8_Release_Feb(CtIDirectMusicPerformance8* ptPerf8)
{
    //Attempt to Release the global performance.  This should assert for February!!
    ptPerf8->Release();
    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_ReferenceToMusicTime.cpp ===
#include "globals.h"
#include "cicmusicx.h"

//TODO: Continue conversion here.


/********************************************************************************
********************************************************************************/
HRESULT Performance8_ReferenceToMusicTime_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
CICMusic Music;
MUSIC_TIME mtBase = 0, mtConverted = 0;
REFERENCE_TIME rtBase = 0;

//The 
//768 * 100BPM / 60s = MUSIC_TIME ticks per second.  
//FLOAT fTempo = 100.f;
FLOAT fMaxErrorPercent = 0.0f;  //1/3 percent error is allowed on this one.
FLOAT fErrorPercent = 0.f;
HRESULT hr = S_OK;

//Load media.
MEDIAFILEDESC MediaFileDesc[]=
{
{"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
{"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));

//Play some muzak, it will play at 100 BPM.  That's 2 BPS, or quarter-notes per second.  So each second, DMUS_PPQ*2 
//  MUSIC_TIME units will go by.
CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Test.sgt", DMUS_APATH_DYNAMIC_MONO));

//Get the base time in both formats.
CHECKRUN(ptPerf8->GetTime(&rtBase, &mtBase));

//Convert one to the other.
CHECKRUN(ptPerf8->ReferenceToMusicTime(rtBase, &mtConverted));

//Get the error percent.
fErrorPercent = (FLOAT)CalculateErrorPercentage((double)mtBase, (double)mtConverted);

//Check the conversion.
Log(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fErrorPercent, fMaxErrorPercent);
if (fErrorPercent> fMaxErrorPercent)
{
    hr = E_FAIL;
    goto END;
}

END:


return hr;
};



/********************************************************************************
RT units = MT   beats    mt's    seconds   rt units
              / ------ / ----- * ------  * ------
                minute   beat    minute    second

RT units = MT   minutes  beats   seconds   rt units
              * ------  *----- * ------  * ------
                beat     mt      minute    second

RT units = MT   1                       1    60    10000000
              * ------               *  ---- --- * ------  
                (BPM * fTempoFactor)    768  1     1

RT units = MT   1                       1    60    10000000
              * ------               *  ---- --- * ------  
                (BPM * fTempoFactor)    768  1     1


RT units = MT   1                       1           60    10000000
              * ------               *  ----        --- * ------  
                (BPM * fTempoFactor)    DMUS_PPQ    1     1




RT units = MT   600000000
              * ------              
                BPM * fTempoFactor * DMUS_PPQ

MT units = RT Units * BMP * fTempoFactor * DMUS_PPQ
           ----------------------------------------
           600000000

********************************************************************************/

HRESULT Performance8_ReferenceToMusicTime_TempoChange(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
MUSIC_TIME mtBase = 0;
REFERENCE_TIME rtBase = 0;
REFERENCE_TIME rtDeltas[] = {0, 1, 100000, 20000000, 36000000000, 864000000000 }; //2 seconds, 1 hour, 1 day.
FLOAT fTempo = 100.f;
MUSIC_TIME mtConverted = 0;
MUSIC_TIME mtTotalDeltaExpected = 0;
MUSIC_TIME mtConvertedExpected = 0;
FLOAT fTempoFactors[] = {1.f, 0.5f, 0.01f, .2f, 100.f};
DWORD i = 0;
DWORD dwTempoIndex = 0;
FLOAT fNewTempoFactor= 0;
FLOAT fErrorPercent = 0.f, fMaxErrorPercent = 1.f;

//Load media.
MEDIAFILEDESC MediaFileDesc[]=
{
{"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
{"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));


//Play some muzak, it will play at 120 BPM.  That's 2 BPS, or quarter-notes per second.  So each second, DMUS_PPQ*2 
//  MUSIC_TIME units will go by.
CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Test.sgt", DMUS_APATH_DYNAMIC_MONO));


for (dwTempoIndex = 0; dwTempoIndex < AMOUNT(fTempoFactors) && SUCCEEDED(hr); dwTempoIndex++)
{
    //Set the tempo factor.
    fNewTempoFactor = fTempoFactors[dwTempoIndex];
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempoFactor, sizeof(fNewTempoFactor)));
    Log(FYILOGLEVEL, "Setting fNewTempoFactor to %g, will hear music at %g times normal tempo.", fNewTempoFactor, fNewTempoFactor);
    Wait(4000);

    //Get the base time.
    CHECKRUN(ptPerf8->GetTime(&rtBase, &mtBase));
    Log(FYILOGLEVEL, "Base times: mt = %u, rt = %I64u", mtBase, rtBase);

    //Check that all the deltas are converted correctly.
    for (i=0; i<AMOUNT(rtDeltas) && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ptPerf8->ReferenceToMusicTime(rtDeltas[i] + rtBase, &mtConverted));
        
        
        //Calculate expected time.
        REFERENCE_TIME rtTemp = 0;
        mtTotalDeltaExpected = 0;

        rtTemp = (REFERENCE_TIME)(FLOAT(rtDeltas[i]) * FLOAT(fTempo) * FLOAT(fNewTempoFactor) * FLOAT(DMUS_PPQ) / 600000000.f);        
        if (rtTemp > 0x7FFFFFFF)
        {
            Log(FYILOGLEVEL, "ERROR: Expected mtTemp would be %016I64X - greater than mt can hold", rtTemp);
            goto END;
        };

        mtTotalDeltaExpected = (MUSIC_TIME)rtTemp;
        //mtTotalDelta = mtConverted - mtBase;
        mtConvertedExpected = mtBase + mtTotalDeltaExpected;
        
        //Check the error factor here.
        fErrorPercent = (FLOAT)CalculateErrorPercentage((double)mtConvertedExpected, (double)mtConverted);
        Log(FYILOGLEVEL, "TempoFactor = %g, Delta = %020I64u: Error = %5.2f%%, MaxError= %5.2f%%.", fNewTempoFactor, rtDeltas[i], fErrorPercent, fMaxErrorPercent);
        if (fErrorPercent> fMaxErrorPercent)
        {
            Log(ABORTLOGLEVEL, "   InParam  rt=%020I64u", rtDeltas[i] + rtBase);
            Log(ABORTLOGLEVEL, "   OutParam mt=%u",       mtConverted);
            Log(ABORTLOGLEVEL, "   Expected mt=%u",       mtConvertedExpected);
            hr = E_FAIL;
            goto END;
        }

    }

}

END:

//reset the tempo back to normal
fNewTempoFactor = 1.f;
if (ptPerf8)
    ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempoFactor, sizeof(fNewTempoFactor));

return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_IsPlaying_Invalid.cpp ===
/********************************************************************************

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_IsPlaying_Invalid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    CICMusic Music;
    HRESULT hr = S_OK;

    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, NULL);
    Log(FYILOGLEVEL, "INT3 INT3 INT3 INT3 INT3 ON DEBUG!!!!");

    hr = ptPerf8->IsPlaying(NULL, NULL);
    Log(FYILOGLEVEL, "INT3 INT3 INT3 INT3 INT3 ON DEBUG!!!!");


    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_IsPlaying.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"


HRESULT Performance8_IsPlaying_Same(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_IsPlaying_Transition(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_IsPlaying_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_IsPlaying_BVT())");
    DMTEST_EXECUTE(Performance8_IsPlaying_Same(ptPerf8));                               
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_IsPlaying_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_IsPlaying_Valid())");
    DMTEST_EXECUTE(Performance8_IsPlaying_Transition(ptPerf8));

    return hr;
};




/********************************************************************************
********************************************************************************/
HRESULT Performance8_IsPlaying_Same(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegmentState8 *ptSegmentState8 = NULL;
CtIDirectMusicSegment8 *ptSegment8 = NULL;


    //Load up and play our segment.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    //Get our segment and segment state.
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptSegmentState8));
    CHECKRUN(ptPerf8->IsPlaying(ptSegment8, NULL));
    CHECKRUN(ptPerf8->IsPlaying(NULL, ptSegmentState8));
    CHECKRUN(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8));
    Log(ABORTLOGLEVEL, "Waiting 4 seconds, you should hear music playing");
    Wait(4000);

    //Stop immediately.
    CHECKRUN(ptPerf8->StopEx(ptSegment8, __int64(0), 0));
    CHECKRUN(SUCCEED_ON_FAIL(ptPerf8->IsPlaying(ptSegment8, NULL), S_FALSE));
    CHECKRUN(SUCCEED_ON_FAIL(ptPerf8->IsPlaying(NULL, ptSegmentState8), S_FALSE));
    CHECKRUN(SUCCEED_ON_FAIL(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8), S_FALSE));
    Log(ABORTLOGLEVEL, "Waiting 4 seconds, you should hear no music because we just called StopEx(ptSegment8)");
    Wait(4000);

    SAFE_RELEASE(ptSegmentState8);
    SAFE_RELEASE(ptSegment8);

    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_IsPlaying_Transition(CtIDirectMusicPerformance8* ptPerf8)
{

HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegmentState8 *ptSegmentState[2] = {NULL};
CtIDirectMusicSegment8 *ptSegment          [2] = {NULL};
CtIDirectMusicAudioPath *ptAudioPath           = NULL;

MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //Load up and play our segment.
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\test.sgt", DMUS_APATH_SHARED_STEREOPLUSREVERB));

    //Get our segment and segment state.
    CHECKRUN(Music.GetInterface(&ptSegment[0]));
    CHECKRUN(Music.GetInterface(&ptSegmentState[0]));
    CHECKRUN(Music.GetInterface(&ptAudioPath));

    //Load up a different segment.
    CHECKRUN(dmthLoadSegment("T:\\DMTest1\\test2.sgt", &ptSegment[1]));
    
    //Do a transition to the next segment on the next measure.
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[1],
                            0,
                            0,
                            DMUS_SEGF_MEASURE,
                            __int64(0),
                            &ptSegmentState[1],
                            0,
                            ptAudioPath));

    //Since it hasn't transitioned yet, the first segment should still be playing.
    CHECKRUN(ptPerf8->IsPlaying(ptSegment[0], NULL));    
    CHECKRUN(ptPerf8->IsPlaying(NULL, ptSegmentState[0]));
    CHECKRUN(ptPerf8->IsPlaying(ptSegment[0], ptSegmentState[0]));
    if (hr != S_OK)
    {
        Log(ABORTLOGLEVEL, "Segment[0]->IsPlaying returned %s even though it hasn't transitioned yet", dmthXlatHRESULT(hr));
        hr = E_FAIL;
        goto END;
    }

    //Wait for this segment to stop playin'.  This means the other one has to be playin'.
    CHECKRUN(WaitForSegmentStop(ptPerf8, ptSegment[0], NULL, 20000, FALSE));

    //Since the "From" segment has stopped, the "To" segment had better be playing.
    CHECKRUN(ptPerf8->IsPlaying(ptSegment[1], NULL));    
    CHECKRUN(ptPerf8->IsPlaying(NULL, ptSegmentState[1]));
    CHECKRUN(ptPerf8->IsPlaying(ptSegment[1], ptSegmentState[1]));
    if (hr != S_OK)
    {
        Log(ABORTLOGLEVEL, "Segment[1]->IsPlaying returned %s even though its precursor has stopped.", dmthXlatHRESULT(hr));
        hr = E_FAIL;
        goto END;
    }
    
END:
    Log(FYILOGLEVEL, "Playing for 2 seconds");
    Wait(2000);

    //Release what we've acquired.
    for (int i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
        SAFE_RELEASE(ptSegmentState[i]);
    }

    SAFE_RELEASE(ptAudioPath);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_PlaySegmentEx.cpp ===
#include "globals.h"
#include "cicmusicX.h"

HRESULT Performance8_PlaySegment_BVT1(CtIDirectMusicPerformance8 *ptPerf8);
HRESULT Performance8_PlaySegment_StartTime(CtIDirectMusicPerformance8 *ptPerf8, BOOL bTransition, MUSIC_TIME mtRel, REFERENCE_TIME rtRel);


LPSTR szWaveFiles[] = { 
	"WAV/48_16_2.wav",  // 48000, 16, 2												
	"WAV/48_16_1.wav",  // 48000, 16, 1												
	"WAV/48_08_2.wav",  // 48000,  8, 2
	"WAV/48_08_1.wav",  // 48000,  8, 1 
	"WAV/44_16_2.wav",  // 44100, 16, 2 
	"WAV/44_16_1.wav",  // 44100, 16, 1
	"WAV/44_08_2.wav",  // 44100,  8, 2
	"WAV/44_08_1.wav",  // 44100,  8, 1
	"WAV/32_16_2.wav",  // 32000, 16, 2
	"WAV/32_16_1.wav",  // 32000, 16, 1
	"WAV/32_08_2.wav",  // 32000,  8, 2
	"WAV/32_08_1.wav",  // 32000,  8, 1
	"WAV/22_16_2.wav",  // 22050, 16, 2
	"WAV/22_16_1.wav",  // 22050, 16, 1
	"WAV/22_08_2.wav",  // 22050,  8, 2
	"WAV/22_08_1.wav",  // 22050,  8, 1
	"WAV/16_16_2.wav",  // 16000, 16, 2
	"WAV/16_16_2.wav",  // 16000, 16, 1
	"WAV/16_08_2.wav",  // 16000,  8, 2
	"WAV/16_08_1.wav",  // 16000,  8, 1
	"WAV/11_16_2.wav",  // 11025, 16, 2
	"WAV/11_16_1.wav",  // 11025, 16, 1
	"WAV/11_08_2.wav",  // 11025,  8, 2
	"WAV/11_08_1.wav",  // 11025,  8, 1
	"WAV/08_16_2.wav",  //  8000, 16, 2
	"WAV/08_16_1.wav",  //  8000, 16, 1
	"WAV/08_08_2.wav",  //  8000,  8, 2
	"WAV/08_08_1.wav"   //  8000,  8, 1
};


LPSTR szADPCMWaves[] = 
{
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_LP_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_LP_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_LP_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_OS_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_OS_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_OS_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_ST_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_ST_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegDLS_ADPCM_ST_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_11_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_22_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_LP_44_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_11_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_22_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_OS_44_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_11_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_11_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_22_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_22_2.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_44_1.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/ADPCM/SegWAV_ADPCM_ST_44_2.sgt"
};


LPSTR szWaveSegments[] = 
{
"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegEmbedWave.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveLoopForever.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveShort.sgt",
"DMusic/DMTest1/Perf8/PlaySeg/PerfMem/SegWaveStreaming10s.sgt"
};


/*
LPSTR szWaves[] = 
{
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\HitTile.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\Rocket1.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\Rocket2.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\Torpedo.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\HitWater.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\HitWorld.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\Explosion1.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\Explosion2.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\MiniCannon.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\PassBy_Rocket.sgt",
"T:\\DMTest1\\Perf8\\PlaySeg\\Scott02\\PassBy_Torpedo.sgt"
};
*/






/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_PlaySegmentEx_BVT())");
    

    //Play MIDI segment.
    DMTEST_EXECUTE(Performance8_PlaySegment_BVT1(ptPerf8));

    return hr;
};

/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegment_BVT1(CtIDirectMusicPerformance8 *ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegment *ptSegment = NULL;

//Play some music whose tempo we're gonna change.
CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));
CHECKRUN(Music.GetInterface(&ptSegment));
CHECKRUN(ptSegment->SetRepeats(0));
CHECKRUN(WaitForSegmentStop(ptPerf8, ptSegment, NULL, 15000));
SAFE_RELEASE(ptSegment);
return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegment_StartTime_Start(CtIDirectMusicPerformance8 *ptPerf8, DWORD mtRel, DWORD rtRel)
{
    return Performance8_PlaySegment_StartTime(ptPerf8, FALSE, mtRel, rtRel);
}

/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegment_StartTime_Transition(CtIDirectMusicPerformance8 *ptPerf8, DWORD mtRel, DWORD rtRel)
{
    return Performance8_PlaySegment_StartTime(ptPerf8, TRUE, mtRel, rtRel);
}


/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegment_StartTime(CtIDirectMusicPerformance8 *ptPerf8, BOOL bTransition, MUSIC_TIME mtRel, REFERENCE_TIME rtRel)
{
HRESULT hr = S_OK;
CHAR *szSegmentName[2] = {"T:\\DMTest1\\test.sgt", "T:\\DMTest1\\test2.sgt"};
CtIDirectMusicSegment *ptSegment[2] = {NULL};
CtIDirectMusicAudioPath *ptPath = NULL;
MUSIC_TIME mt=0;
REFERENCE_TIME rt=__int64(0);
DWORD dwTempo = 100;
LONG lWait = 0;
int i = 0;

//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));


    //Load segs.
    for (i=0; i<2; i++)
    {
        CHECKRUN(dmthLoadSegment(szSegmentName[i], &ptSegment[i]));
    }
    
    //Create AP for them to play on.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_3D, 16, TRUE, &ptPath));

    //If we're gonna transition, then start the original segment playing.
    if (bTransition)
    {	    
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0],0,0,0,0,NULL,0,ptPath));
        CHECKRUN(Log(FYILOGLEVEL, "Playing %s, will transition in 4 seconds.", szSegmentName[0]));
        CHECKRUN(CountDown(4000, 200));
    }
    else
    {
        CHECKRUN(Log(FYILOGLEVEL, "No sound for 4 seconds..."));
        CHECKRUN(CountDown(4000, 500));
    }

    //Wait exactly that long.
    if (mtRel)
    {
        lWait = 1000 * mtRel *  60 / dwTempo  / 768;
    }
    else
    {
        lWait = LONG(rtRel / 10000);
    }

    if (lWait < 0)
        lWait = 0;


    //Queue segment to play relative.
    CHECKRUN(ptPerf8->GetTime(&rt, &mt));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[1], 0, 0, mtRel?0:DMUS_SEGF_REFTIME, mtRel?mtRel+mt:rtRel+rt, NULL,0,ptPath));
    CHECKRUN(Log(FYILOGLEVEL, "%s is queued to play with in %s = %I64d units (%d ms)", szSegmentName[1], mtRel ? "MUSIC_TIME" : "REFERENCE_TIME", REFERENCE_TIME(mtRel ? mtRel+mt : rtRel+rt), lWait));
    CHECKRUN(CountDown(lWait, lWait / 10)); 
    CHECKRUN(Log(FYILOGLEVEL, "%s should be playing now.  Waiting 4 more seconds.", szSegmentName[1]));
    CHECKRUN(CountDown(4000, 500));
    
    
    
    ptPerf8->StopEx(0, __int64(0), 0); 
    //Unload and free the segments.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
    }
        
    SAFE_RELEASE(ptPath);


return hr;
};

 

/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegment_TransitionType(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwFlags, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CHAR *szSegmentName[2] = {"T:\\DMTest1\\test.sgt", "T:\\DMTest1\\test2.sgt"};
CtIDirectMusicSegment *ptSegment[2] = {NULL};
CtIDirectMusicAudioPath *ptPath = NULL;
LONG lWait = 0;
int i = 0;

//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
                                {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));


    //Load segs.
    for (i=0; i<2; i++)
    {
        CHECKRUN(dmthLoadSegment(szSegmentName[i], &ptSegment[i]));
    }
    
    //Create AP for them to play on.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_3D, 16, TRUE, &ptPath));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0],0,0,0,0,NULL,0,ptPath));
    CHECKRUN(Log(FYILOGLEVEL, "Playing %s.", szSegmentName[0]));
    CHECKRUN(Log(FYILOGLEVEL, "In 4s, %s will be queued to play with dwFlags = %s.", szSegmentName[1], Log_DMUS_SEGF(dwFlags)));
    CHECKRUN(CountDown(4000, 1000));    
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[1],0,0,dwFlags,0,NULL,0,ptPath));
    
    //How long we wait depends on what we're doing.
    if (dwFlags & DMUS_SEGF_QUEUE)
        lWait = 10000;
    else
        lWait = 4000;

    CHECKRUN(Log(FYILOGLEVEL, "%s is queued to play with dwFlags = %s.  Waiting %ds for it", szSegmentName[1], Log_DMUS_SEGF(dwFlags)));
    CHECKRUN(CountDown(lWait, lWait / 5)); 
    
    
    ptPerf8->StopEx(0, 0, 0);
 
    //Unload and free the segments.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
    }
        
    SAFE_RELEASE(ptPath);
return hr;
};

 

/********************************************************************************
Using the DMUS_SEGF_ALIGN flag in combo with other flags, switch between segments
on certain boundaries.
********************************************************************************/
HRESULT Performance8_PlaySegment_TransPreAlign(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwFlags, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CHAR *szSegmentName[2] = {"T:\\DMTest1\\Perf8\\PlaySeg\\TransPreAlign0.sgt", "T:\\DMTest1\\Perf8\\PlaySeg\\TransPreAlign1.sgt"};
CtIDirectMusicSegment *ptSegment[2] = {NULL};
CtIDirectMusicAudioPath *ptPath = NULL;
MUSIC_TIME mt=0;
REFERENCE_TIME rt=0;
int i = 0;
DWORD dwWaits[] = {500, 1000, 2000, 3000};
DWORD dwCurrentSegment = 0;

//Load the needed medja.
MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Perf8/PlaySeg/TransPreAlign0.sgt", "T:\\DMTest1\\Perf8\\PlaySeg\\",    COPY_IF_NEWER},
                                {"DMusic/DMTest1/Perf8/PlaySeg/TransPreAlign1.sgt", "T:\\DMTest1\\Perf8\\PlaySeg\\",    COPY_IF_NEWER},
                                {"DMusic/DMTest1/Perf8/PlaySeg/WaveEmb.sgt",        "T:\\DMTest1\\Perf8\\PlaySeg\\",    COPY_IF_NEWER},
                                {"DLS/Main1.DLS",                   "T:\\DMTest1\\Perf8\\PlaySeg\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
CHECKRUN(LoadMedia(MediaFileDesc));


    //Load segs.
    for (i=0; i<2; i++)
    {
        CHECKRUN(dmthLoadSegment(szSegmentName[i], &ptSegment[i]));
        CHECKRUN(ptSegment[i]->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    }
    
    //Create AP for them to play on.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_3D, 16, TRUE, &ptPath));

    //Play the original segment.
    dwCurrentSegment = 0;
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[dwCurrentSegment],0,0,0,0,NULL,0,ptPath));
    CHECKRUN(ptPerf8->GetTime(&rt, &mt));


    for (i=0; i<AMOUNT(dwWaits); i++)
    {
        CHECKRUN(Log(FYILOGLEVEL, "Playing %s, will invoke transition in %d ms.", szSegmentName[dwCurrentSegment], dwWaits[i]));
        CHECKRUN(Wait(dwWaits[i]));   
        //Transition based on the original time.
        dwCurrentSegment = !dwCurrentSegment;
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[dwCurrentSegment],0,0,dwFlags,mt,NULL,0,ptPath));
        CHECKRUN(Log(FYILOGLEVEL, "%s has been queued with dwFlags = %s.  Listing for 4s.", szSegmentName[dwCurrentSegment], Log_DMUS_SEGF(dwFlags)));
        CHECKRUN(Wait(4000)); 
    }

    //Stop everything.
    ptPerf8->StopEx(0, 0, 0);
 
    //Unload and free the segments.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
    }
        
    SAFE_RELEASE(ptPath);
return hr;
};

//Scenarios!

//Streaming wave BVT (done)
//One-shot wave BVT (done)
//MIDI BVT (done)


/**********************************************************************
Plays a segment all the way through once.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Segment_WaitForEnd(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwSegmentNameServer, DWORD dwRepeats)
{
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
HRESULT hr = S_OK;
LPSTR szSegmentNameServer = (LPSTR)dwSegmentNameServer;
CHAR szSegmentName[MAX_PATH] = {0};

//Since we're only copying the file, we're assuming no .SGT files are being used that reference other wave files.
ASSERT(strstr(szSegmentNameServer, ".wav"));
CHECKRUN(MediaCopyFile(szSegmentNameServer));
strcpy(szSegmentName, MediaServerToLocal(szSegmentNameServer));

CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment));
CHECKRUN(ptSegment->SetRepeats(dwRepeats));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,NULL,0,ptPath));
CHECKRUN(Log(FYILOGLEVEL, "Playing %s %d times; waiting until done", szSegmentName, dwRepeats));
if (SUCCEEDED(hr))
{
    ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE);
    ExpectSegmentStop (ptPerf8, ptSegment, NULL, 0xFFFFFFFF, NULL, TRUE);
}

ptPerf8->StopEx(NULL, NULL, NULL);

SAFE_RELEASE(ptSegment);
SAFE_RELEASE(ptPath);
return hr;
};



/**********************************************************************
Plays a segment for 10 seconds.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwSegmentNameServer, DWORD dwRepeats)
{
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
HRESULT hr = S_OK;
LPSTR szSegmentNameServer = (LPSTR)dwSegmentNameServer;
CHAR szSegmentName[MAX_PATH] = {0};


//Since we're only copying the file, we're assuming no .SGT files are being used that reference other files.
ASSERT(strstr(szSegmentNameServer, ".wav"));
CHECKRUN(MediaCopyFile(szSegmentNameServer));
strcpy(szSegmentName, MediaServerToLocal(szSegmentNameServer));

CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment));
CHECKRUN(ptSegment->SetRepeats(dwRepeats));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,NULL,0,ptPath));
CHECKRUN(Log(FYILOGLEVEL, "Playing %s %d times; waiting for 10 seconds", szSegmentName, dwRepeats));
if (SUCCEEDED(hr))
{
    CountDown(10000, 1000);
}

ptPerf8->StopEx(NULL, NULL, NULL);

SAFE_RELEASE(ptSegment);
SAFE_RELEASE(ptPath);
return hr;
};






/**********************************************************************
if (szSegmentName == NULL) do (dwCount) multiple segments.
else do (dwCount) same segment.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Multiple(CtIDirectMusicPerformance *ptPerf8, LPSTR szSegmentNameServer, DWORD dwCount, DWORD dwRepeats)
{
#define MAX 30
CtIDirectMusicSegment *ptSegment[MAX] = {0};
CtIDirectMusicSegmentState *ptSegmentState[MAX] = {0};
CtIDirectMusicAudioPath *ptPath = NULL;
HRESULT hr = S_OK;
DWORD i = 0;
CHAR szSegmentName[MAX_PATH] = {0};


ASSERT(dwCount <= MAX);

//Make sure we're using a .WAV file, so there are no dependencies for medialoader to deal with.
if (szSegmentNameServer)
{
    ASSERT(strstr(szSegmentNameServer, ".wav"));
}
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
if (szSegmentNameServer)
{
    CHECKRUN(MediaCopyFile(szSegmentNameServer));
    CHECK   (strcpy(szSegmentName, MediaServerToLocal(szSegmentNameServer)));
    CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment[0]));
    CHECKRUN(ptSegment[0]->SetRepeats(dwRepeats));
    for (i=1; i<dwCount && SUCCEEDED(hr); i++)
    {
        ptSegment[i] = ptSegment[0];
        ptSegment[i]->AddRef();
    }
}
else
{
    //Download the file they specified and get its location. 
    Log(FYILOGLEVEL, "Downloading wave files from server...");
    CHECKRUN(MediaCopyDirectory(szWaveFiles[0]));    
    ASSERT(FilesInSameDirectory(szWaveFiles, dwCount));

    for (i=0; i<dwCount && SUCCEEDED(hr); i++)
    {
        CHECKRUN(dmthLoadSegment(MediaServerToLocal(szWaveFiles[i]), &ptSegment[i]));
        CHECKRUN(ptSegment[i]->SetRepeats(dwRepeats));
    }
}

/*
for (i=0; i<dwCount && SUCCEEDED(hr); i++)
{
    CHECKRUN(Log(FYILOGLEVEL, "Playing segment %2d/%2d (%s)", i+1, dwCount, szSegmentName ? szSegmentName : MediaServerToLocal(szWaveFiles[i])));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[i],0,0,i ? DMUS_SEGF_SECONDARY : 0,0,&ptSegmentState[i],0,ptPath));
    Sleep(1000);
}
*/


CHECKRUN(Log(FYILOGLEVEL, "Waiting 10 seconds."));
CountDown(10000, 1000);

//Stop and release everything.
for (i=0; i<dwCount; i++)
{
    if (ptSegmentState[i])
        ptPerf8->StopEx(ptSegmentState[i], 0, 0);
    SAFE_RELEASE(ptSegmentState[i]);
    SAFE_RELEASE(ptSegment[i]);
}

SAFE_RELEASE(ptPath);
return hr;
}

/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Multiple_NoRepeats(CtIDirectMusicPerformance *ptPerf8, DWORD szSegmentName, DWORD dwCount)
{

    return Performance8_PlaySegmentEx_Multiple(ptPerf8, (LPSTR)szSegmentName, dwCount, 0);
}

/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Multiple_OneRepeat(CtIDirectMusicPerformance *ptPerf8, DWORD szSegmentName, DWORD dwCount)
{

    return Performance8_PlaySegmentEx_Multiple(ptPerf8, (LPSTR)szSegmentName, dwCount, 1);
}





/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegment_Latency(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;

    CICMusic Music;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicSegmentState *ptSegmentState = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CHAR *szSegmentNameServer[] = {"WAV/08_08_1.wav", "WAV/48_16_2.wav"};
    CHAR szSegmentName[2][MAX_PATH] = {0};
    DWORD i=0;
    //Copy down the files.
    for (i=0; i<AMOUNT(szSegmentName); i++)
    {
        CHECKRUN(MediaCopyFile(szSegmentNameServer[i]));
        strcpy(szSegmentName[i], MediaServerToLocal(szSegmentNameServer[i]));                
        ASSERT(i < 2);
    }

    for (i=0; i<AMOUNT(szSegmentName); i++)
    {

        CHECKRUN(dmthLoadSegment(szSegmentName[i], &ptSegment));
        CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));    
        Log(FYILOGLEVEL, "Will play %s in 1 second - listen for latency.", szSegmentName[i]);
        Wait(1000);

        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,&ptSegmentState,0,ptPath));
        Log(FYILOGLEVEL, "Playing");
        Log(FYILOGLEVEL, "0ms");
        Wait(200);
        Log(FYILOGLEVEL, "200ms");
        Wait(200);
        Log(FYILOGLEVEL, "400ms");
        Wait(200);
        Log(FYILOGLEVEL, "600ms");
        Wait(200);
        Log(FYILOGLEVEL, "800ms");
        Wait(200);
        Log(FYILOGLEVEL, "1000ms");
    
        CHECKRUN(ptPerf8->StopEx(ptSegmentState, 0, 0));    

        SAFE_RELEASE(ptSegmentState);
        SAFE_RELEASE(ptSegment);
        SAFE_RELEASE(ptPath);
    }

    return hr;
}


/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegment_Latency_Interactive(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;

    CICMusic Music;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicSegmentState *ptSegmentState = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CHAR *szSegmentNameServer = "WAV/08_08_1.wav";
    CHAR szSegmentName[MAX_PATH];

    DWORD i=0;
    BOOL bDone = FALSE;
    DWORD dwButtonMask = 0;


    if (g_TestParams.bSkipUserInput)
        return S_OK;

    CHECKRUN(MediaCopyFile(szSegmentNameServer));
    strcpy(szSegmentName, szSegmentNameServer);

    CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));    


    while (!bDone)
    {
        Log(ABORTLOGLEVEL, "Press button A to trigger the sound; B to quit.");
        dwButtonMask = dmthWaitForAnyButton(DMTH_JOYBUTTON_A | DMTH_JOYBUTTON_B);
        if (dwButtonMask & DMTH_JOYBUTTON_A)
        {            
            CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,&ptSegmentState,0,ptPath));
            dmthWaitForAllButtonsUp();
        }
        else
        {
            bDone = TRUE;
        }
    };


    CHECKRUN(ptPerf8->StopEx(ptSegmentState, 0, 0));    
    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptPath);

    return hr;
}


/********************************************************************************
dwTime = 0xFFFFFFFF = WAIT for segment to stop
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_Valid_Play(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime)
{
    HRESULT hr = S_OK;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CICMusic Music;
    BYTE bMasterGrooveLevel_100 = 100;
    BYTE bMasterGrooveLevel_0 = 0;  
    LPCSTR szFullPathServer = NULL;
    CHAR szFullPath[MAX_PATH];

    //Cast our parameter.
    szFullPathServer = LPSTR(dwFilename);
    
    if (_strcmpi(szFullPathServer, "DEFAULT") == 0)
    {
        strcpy(szFullPath,g_TestParams.szDefaultMedia);
    }
    else
    {
        //Copy all files locally, main1.dls, and get the name of your specific file.

        CHECKRUN(MediaCopyDirectory(szFullPathServer));
        strcpy(szFullPath, MediaServerToLocal(szFullPathServer));
        CHAR szDirectoryLocal[MAX_PATH] = {0};
        CHECKRUN(ChopPath(szFullPath, szDirectoryLocal, NULL));

        MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DLS/Main1.DLS", szDirectoryLocal, COPY_IF_NEWER},
                                    {TERMINATE}
                                    };

        CHECKRUN(LoadMedia(MediaFileDesc));
    }

    CHECKRUN(Music.Init(ptPerf8, szFullPath, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Music.GetInterface(&ptPath));
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE));
    CHECKRUN(ptSegment->SetRepeats(0));
    CHECKRUN(InsertToolTrace(ptPath));


    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bMasterGrooveLevel_100, sizeof(bMasterGrooveLevel_100)));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,0,0,ptPath));

    if (dwTime == 0xFFFFFFFF)
    {
        CHECKRUN(Log(FYILOGLEVEL, "Playing %s all the way through.", szFullPath));
        CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, szFullPath));
        CHECKRUN(ExpectSegmentStop (ptPerf8, ptSegment, NULL, 20000, szFullPath)); //15 seconds max length of segment.
    }
    else
    {
        CHECKRUN(Log(FYILOGLEVEL, "Playing %s for %d seconds.", PathFindFileName(szFullPath), dwTime));
        CHECKRUN(CountDown(dwTime * 1000, 1000));
    }

    ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bMasterGrooveLevel_0, sizeof(bMasterGrooveLevel_0));
    if (ptPath)
        RemoveToolTrace(ptPath);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);

    dmthPromptUserTestResults(hr, EXPECT_YES, "Does %s playing correctly?", PathFindFileName(szFullPath));
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD bFull)
{
    HRESULT hr = S_OK;
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    IDirectMusicSegment *pSegment = NULL;
    IDirectMusicAudioPath *pPath= NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    CHAR szPath[MAX_PATH];
    CHAR szFile[MAX_PATH];
    LPCSTR szFullPathServer = NULL;
    CHAR szFullPath[MAX_PATH] = {0};
    szFullPathServer = LPSTR(dwFilename);
    
    //Cast our parameter.
    szFullPathServer = LPSTR(dwFilename);

    //Copy all files locally and get the name of your specific file.
    CHECKRUN(MediaCopyDirectory(szFullPathServer));
    strcpy(szFullPath, MediaServerToLocal(szFullPathServer));


    CHECKRUN(ChopPath(szFullPath, szPath, szFile));
    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf));

    //If we're testing the full load/free scenario, then do this inside the loop.  Otherwise do it here.
    if (!bFull)
    {
        CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
        CHECKRUN(pPerf->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &pPath));
        CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
        CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFile, (void **)&pSegment));
    }



    dwStartTime = timeGetTime();
    do
    {

        //If we're testing the full load/free scenario, then do everything *inside* the loop.
        if (bFull)
        {
            CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader));
            CHECKRUN(pPerf->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &pPath));
            CHECKRUN(pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));
            CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFile, (void **)&pSegment));
        }

        //Here's the money maker.
       CHECKRUN(pPerf->PlaySegmentEx(pSegment,0,0,0,0,NULL,0,pPath));
       Wait(100);
        
        //If we're testing the full load/free scenario, then do everything *inside* the loop.
        if (bFull)
        {
            
            SAFE_RELEASE(pPath);
            SAFE_RELEASE(pSegment);
            SAFE_RELEASE(pLoader);

        }



        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));



    //Make sure everything gets released.
    SAFE_RELEASE(pPath);
    SAFE_RELEASE(pSegment);
    SAFE_RELEASE(pLoader);
    SAFE_RELEASE(pPerf);

    if (FAILED(hr))
        Log(ABORTLOGLEVEL, "Loader_GetObject_PerfMem_Type_Full failed with %s (%08X)", tdmXlatHRESULT(hr), hr);
    return hr;
};



/********************************************************************************
dwTime = 0xFFFFFFFF = WAIT for segment to stop

NOTE: This is meant to be called when DoWork is NOT being called!!  See the first check.
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_Valid_PlayBeforeDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime)
{
    HRESULT hr = S_OK;
    CICMusic Music;

    //Copy the current content.
    LPCSTR szFullPathServer = LPSTR(dwFilename);
    CHAR szFullPath[MAX_PATH] = {0};
    strcpy(szFullPath, MediaServerToLocal(szFullPathServer));
    CHECKRUN(MediaCopyDirectory(szFullPathServer));
    //Also copy MAIN1.DLS, how annoying.
    CHAR szDirectory[MAX_PATH] = {0};
    CHECKRUN(ChopPath(szFullPath, szDirectory, NULL));
    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DLS/Main1.DLS", szDirectory, COPY_IF_NEWER},
                                    {TERMINATE}
                                    };


    if (0 != g_TestParams.dwDoWorkFrequency)
        Log(ABORTLOGLEVEL, "ERROR!!! Performance8_PlaySegmentEx_Valid_PlayBeforeDoWork() called when DoWork thread is active!!!");

    CHECKRUN(Music.Init(ptPerf8, szFullPath, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    Wait(2000);
    CHECK(DirectMusicDoWork(16));

    dmthPromptUserTestResults(hr, EXPECT_YES, "Does %s playing correctly?", PathFindFileName(szFullPath));
    return hr;
};


/********************************************************************************
dwTime = 0xFFFFFFFF = WAIT for segment to stop

NOTE: This is meant to be called when DoWork is NOT being called!!  See the first check.
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_Valid_DelayDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwDelay)
{
    HRESULT hr = S_OK;
    CICMusic Music;
    DWORD dwStartTime = 0;
    HRESULT hrIsPlaying = S_OK;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;

    //Copy the current content.
    LPCSTR szFullPathServer = LPSTR(dwFilename);
    CHAR szFullPath[MAX_PATH] = {0};
    strcpy(szFullPath, MediaServerToLocal(szFullPathServer));
    CHECKRUN(MediaCopyDirectory(szFullPathServer));
    //Also copy MAIN1.DLS, how annoying.
    CHAR szDirectory[MAX_PATH] = {0};
    CHECKRUN(ChopPath(szFullPath, szDirectory, NULL));
    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DLS/Main1.DLS", szDirectory, COPY_IF_NEWER},
                                    {TERMINATE}
                                    };


    CHECKRUN(LoadMedia(MediaFileDesc));
    if (0 != g_TestParams.dwDoWorkFrequency)
        Log(ABORTLOGLEVEL, "ERROR!!! Performance8_PlaySegmentEx_Valid_DelayDoWork() called when DoWork thread is active!!!");


    CHECKRUN(Music.Init(ptPerf8, szFullPath, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Music.GetInterface(&ptPath));
    CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
    CHECKRUN(ptSegment->SetRepeats(0));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
    CHECKRUN(CountDown(dwDelay, dwDelay));

    dwStartTime = timeGetTime();
    do
    {            
        CHECK(DirectMusicDoWork(16));
        CHECK(Sleep(16));
        CHECK(hrIsPlaying = ptPerf8->IsPlaying(ptSegment, NULL));
    }
    while (S_OK == hrIsPlaying && SUCCEEDED(hr));


    dmthPromptUserTestResults(hr, EXPECT_YES, "Does %s playing correctly?", PathFindFileName(szFullPath));
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptPath);
    return hr;
};




/********************************************************************************
********************************************************************************/
HRESULT Performance8_PlaySegmentEx_Valid_SetFrequency(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime)
{
    HRESULT hr = S_OK;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CICMusic Music;

    //Copy the current content.
    LPCSTR szFullPathServer = LPSTR(dwFilename);
    CHAR szFullPath[MAX_PATH] = {0};
    strcpy(szFullPath,MediaServerToLocal(szFullPathServer));
    CHECKRUN(MediaCopyDirectory(szFullPathServer));

    //Also copy MAIN1.DLS, how annoying.
    CHAR szDirectory[MAX_PATH] = {0};
    CHECKRUN(ChopPath(szFullPath, szDirectory, NULL));
    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DLS/Main1.DLS", szDirectory, COPY_IF_NEWER},
                                    {TERMINATE}
                                    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    CHECKRUN(Music.Init(ptPerf8, szFullPath, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Music.GetInterface(&ptPath));
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    CHECKRUN(ptSegment->SetRepeats(0));
    //Set pitch to increase.
    CHECKRUN(ptPath->SetPitch(2000, 5000));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,0,0,0,ptPath));


    if (dwTime == 0xFFFFFFFF)
    {
        CHECKRUN(Log(FYILOGLEVEL, "%s should repeat normally.", szFullPath));
        CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 5000, szFullPath));
        CHECKRUN(ExpectSegmentStop (ptPerf8, ptSegment, NULL, 20000, szFullPath)); //15 seconds max length of segment.
    }
    else
    {
        CHECKRUN(Log(FYILOGLEVEL, "Playing %s for %d seconds.", PathFindFileName(szFullPath), dwTime));
        CHECKRUN(CountDown(dwTime * 1000, 1000));
    }

    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);
    dmthPromptUserTestResults(hr, EXPECT_YES, "Does %s playing correctly?", PathFindFileName(szFullPath));
    return hr;
};


HRESULT Sleep_Zero(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime)
{
Sleep(0);
return S_OK;

}



//prototype
HRESULT Performance8_PlaySegmentEx_QuickStartStop(CtIDirectMusicPerformance *ptPerf8, LPSTR *szWaveFiles, DWORD dwNumFiles, DWORD dwNumSounds);


/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_QuickStartStop_ADPCM(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_PlaySegmentEx_QuickStartStop(ptPerf8, szADPCMWaves, NUMELEMS(szADPCMWaves), 10);
};

/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_QuickStartStop_WaveFiles(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_PlaySegmentEx_QuickStartStop(ptPerf8, szWaveFiles, NUMELEMS(szWaveFiles), 10);
};

/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_QuickStartStop_WaveSegments(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_PlaySegmentEx_QuickStartStop(ptPerf8, szWaveSegments, NUMELEMS(szWaveSegments), 1);
};



/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_QuickStartStop(CtIDirectMusicPerformance *ptPerf8, LPSTR *szWaveFiles, DWORD dwNumFiles, DWORD dwNumSounds)
{
#define TOTALTIME 2000  //Test for x milliseconds.
#define INTERVAL 0     //Check every x milliseconds
#define HITPERCENTAGE 100 //30% of the time, toggle sound on/off

//Seed with some random, but constant, value.
srand(101400);

CtIDirectMusicSegment *ptSegment            [100] = {0};
CtIDirectMusicSegmentState *ptSegmentState  [100] = {0};
CtIDirectMusicAudioPath *ptPath             [100] = {NULL};

HRESULT hr = S_OK;
DWORD i = 0;


//Assuming all the files are in the same directory.
CHECKRUN(MediaCopyDirectory(szWaveFiles[0]));

for (i=0; i<dwNumSounds; i++)
{
    //Create a 3D path.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath[i]));

    //Load a random file for the path.
//    CHECKRUN(dmthLoadSegment(szWaveFiles[rand() % dwNumFiles], &ptSegment[i]));

    CHECKRUN(dmthLoadSegment(MediaServerToLocal(szWaveFiles[i % dwNumFiles]), &ptSegment[i]));

    //Verify these files are in the perfmem directory.
    ASSERT(!strstr(szWaveFiles[i % dwNumFiles], "Perfmem"));
}

Log(FYILOGLEVEL, "\n\nPLAYING %d sounds FOR %u ms", dwNumSounds, TOTALTIME);

//For 5 seconds start and stop sounds.
DWORD dwStartTime = timeGetTime();
do
{
    for (i=0; i<dwNumSounds; i++)
    {
        if (rand() % 100 < HITPERCENTAGE)
        {
            if (!ptSegmentState[i])
            {
                CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[i], NULL, NULL, 0, 0, &ptSegmentState[i], NULL, ptPath[i]));
            }
            else
            {
                CHECKRUN(ptPerf8->StopEx(ptSegmentState[i], 0, 0));
                RELEASE(ptSegmentState[i]);
            }
        }

    }

    Sleep(INTERVAL);
}
while (timeGetTime() - dwStartTime < TOTALTIME);




//Stop all segment states.
Log(FYILOGLEVEL, "STOPPING ALL SEGMENT STATES...");
for (i=0; i<dwNumSounds; i++)
{
    if (ptSegmentState[i])
    {
        CHECKRUN(ptPerf8->StopEx(ptSegmentState[i], 0, 0));
        RELEASE(ptSegmentState[i]);
    }
}

Log(FYILOGLEVEL, "\n\nALL SOUNDS SHOULD BE TOTALLY STOPPED NOW.\n\n");
Log(FYILOGLEVEL, "Waiting 5 seconds so you can hear any rogue sounds.");
Log(FYILOGLEVEL, "File a bug if you hear any");
Sleep(5000);

//Release everything.
for (i=0; i<dwNumSounds; i++)
{
    RELEASE(ptSegmentState[i]);
    RELEASE(ptSegment[i]);
    RELEASE(ptPath[i]);
}


return hr;
}

#undef dwNumFiles 
#undef TOTALTIME
#undef INTERVAL 
#undef HITPERCENTAGE 




/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_QuickStartStopOneFile(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicSegmentState *ptSegmentState = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
HRESULT hr = S_OK;
DWORD i = 0;


LPCSTR szWaveServer = "WAV/08_08_2.wav";
LPCSTR szWave       = MediaServerToLocal(szWaveServer);

CHECKRUN(MediaCopyFile(szWaveServer));

//Create a 3D path.
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));

//Load a random file for the path.
CHECKRUN(dmthLoadSegment(szWave, &ptSegment));

//Quickly start and stop segment.
CHECKRUN(Log(FYILOGLEVEL, "Waiting 1 second for download to complete, then we'll play and stop the file..."));
CHECKRUN(Wait(1000));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, &ptSegmentState, NULL, ptPath));
CHECKRUN(ptPerf8->StopEx(ptSegmentState, 0, 0));

//Check to see if sound has stopped.
CHECKRUN(Log(FYILOGLEVEL, "Sound should be totally stopped now.  File bug if it ain't"));
CHECKRUN(Log(FYILOGLEVEL, "Waiting 2 seconds"));
CHECKRUN(Wait(2000));

//Stop playback.
if (ptSegmentState)
{
    CHECKRUN(ptPerf8->StopEx(ptSegmentState, 0, 0));
}

//Release
RELEASE(ptSegmentState);
RELEASE(ptSegment);
RELEASE(ptPath);

return hr;
}




/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_TransitionTempo(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;	
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;

    LPCSTR szScriptServer = "DMusic/DMTest1/Perf8/PlaySeg/TransTempo/TransTempo.spt";
    CHAR szScript[MAX_PATH] = {0};
    CHAR  szPath[MAX_PATH] = {0};
    CHAR  szFile[MAX_PATH] = {0};
    LPSTR szRoutine[2] = {"StartMusic", "Transition"};

    //Copy the current content.
    strcpy(szScript, MediaServerToLocal(szScriptServer));
    CHECKRUN(MediaCopyDirectory(szScriptServer));

    //Also copy MAIN1.DLS, how annoying.
    CHECKRUN(ChopPath(szScript, szPath, szFile));
    MEDIAFILEDESC MediaFileDesc[] = {
                                    {"DLS/Main1.DLS", szPath, COPY_IF_NEWER},
                                    {TERMINATE}
                                    };
    CHECKRUN(LoadMedia(MediaFileDesc));

    //For processing
    LONG  lNextRoutineDelay = 0;
 
    //Init performance
    CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
    CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
    CHECKRUN( InsertToolTrace(ptPerf8));
    
    //Init loader
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );
    CHECKRUN( ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, TRUE));


    //Load/Init our script
    CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szFile, (void **)&ptScript));
    CHECKRUN(ptScript->Init( ptPerf8, NULL));

    //Call the routine we're supposed to.  If it doesn't exist, the script is messed up.
    CHECKRUN(ptScript->CallRoutine(szRoutine[0], NULL));
    Log(FYILOGLEVEL, "Calling %s, waiting 2 seconds before transition", szRoutine[0]);
    Wait(2000);
    CHECKRUN(ptScript->CallRoutine(szRoutine[1], NULL));
    Log(FYILOGLEVEL, "Calling %s, should hear transition segment playing at same tempo as previous segment.", szRoutine[1]);
    Log(FYILOGLEVEL, "Waiting 5 seconds");
    
    Wait(5000);
        
    //Stop everything.
    ptPerf8->StopEx(0, 0, 0);

    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    SAFE_RELEASE(ptPath);
    return hr;
};




/**********************************************************************
if (szSegmentName == NULL) do (dwCount) multiple segments.
else do (dwCount) same segment.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_RelativeVolume(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
DWORD i = 0;
LPCSTR szWaveServer = "WAV/GuitarLoop.wav";
LPCSTR szWave = MediaServerToLocal(szWaveServer);
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
DWORD dwPath[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_APATH_SHARED_STEREO, DMUS_APATH_DYNAMIC_MONO, DMUS_APATH_DYNAMIC_3D};
IDirectSoundBuffer *pBuffer = NULL;
DWORD dwDataSize    = 0;
DSBUFFERDESC dsbd = {0};

CHECKRUN(MediaCopyFile(szWaveServer));

//These will be allocated and must be freed.
LPVOID pvData        = NULL;
LPCWAVEFORMATEX pWfx = NULL;

//Load the wave file into our soundbuffer
CHECKRUN(HelpLoadWaveFileData(szWave, &pWfx, &pvData, &dwDataSize));
dsbd.dwSize = sizeof(dsbd);
dsbd.dwFlags = 0;
dsbd.dwBufferBytes = dwDataSize;
dsbd.lpwfxFormat = (LPWAVEFORMATEX)pWfx;
//dsbd.dwMixBinMask = 0;      //Defaults, I guess.
dsbd.lpMixBins = NULL;      //Defaults, I guess.
//dsbd.dwMixBinMask = DSMIXBIN_FRONT_LEFT;

//dsbd.dwInputMixBinMask = 0;
dsbd.dwInputMixBin = 0;
CHECKRUN(DirectSoundCreateBuffer(&dsbd, &pBuffer));
CHECKRUN(pBuffer->SetBufferData(pvData, dwDataSize));

//Load the wave file into our segment.
CHECKRUN(dmthLoadSegment(szWave, &ptSegment));


for (i=0; i<NUMELEMS(dwPath) * 2 && SUCCEEDED(hr); i++)
{    
    //Play the DSound version
    if (i%2 == 0)
    {        
        CHECKRUN(pBuffer->SetCurrentPosition(0));
        CHECKRUN(Log(FYILOGLEVEL, "Playing via IDirectSoundBuffer"));
        CHECKRUN(pBuffer->Play(0, 0, 0));
        CHECKRUN(Wait(1500));
        CHECKRUN(pBuffer->Stop());

    }
    //Play the DMusic version on an audiopath
    else
    {    

        CHECKRUN(Log(FYILOGLEVEL, "Playing on %s", tdmXlatDMUS_APATH(dwPath[i/2])));

        //Create the one of our paths.
        CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPath[i / 2], 128, TRUE, &ptPath));

        //Play the file.
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));

        //Release the path (the playing segment will have a reference to it, making things okay)
        CHECKRUN(Wait(1500));
        CHECKRUN(ptPerf8->StopEx(ptSegment, NULL, NULL));
        RELEASE(ptPath);
    }
}

//Release DMusic stuff
RELEASE(ptSegment);
RELEASE(ptPath);

//Release DSound stuff
RELEASE(pBuffer);

//Release allocated memory.
delete [](BYTE *)pvData;
delete [](BYTE *)pWfx;

return hr;
}




/**********************************************************************
if (szSegmentName == NULL) do (dwCount) multiple segments.
else do (dwCount) same segment.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_CompareWithDSound(CtIDirectMusicPerformance *ptPerf8, DWORD dwPath, DWORD dwWave)
{
HRESULT hr = S_OK;
DWORD i = 0;
LPSTR szWaveServer = LPSTR(dwWave);
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
IDirectSoundBuffer *pBuffer = NULL;
DWORD dwDataSize    = 0;
DSBUFFERDESC dsbd = {0};
DWORD dwStatus = 0;
CHAR szWave[MAX_PATH] = {0};

ASSERT(szWaveServer);
ASSERT(strstr(szWaveServer, ".wav"));
strcpy(szWave, MediaServerToLocal(szWaveServer));
_strlwr(szWave);
CHECKRUN(MediaCopyFile(szWaveServer));

//These will be allocated and must be freed.
LPVOID pvData        = NULL;
LPCWAVEFORMATEX pWfx = NULL;

//Load the wave file into our soundbuffer
CHECKRUN(HelpLoadWaveFileData(szWave, &pWfx, &pvData, &dwDataSize));


if (SUCCEEDED(hr))
{
    DSMIXBINVOLUMEPAIR pair[2] = {DSMIXBIN_FRONT_LEFT, 0, DSMIXBIN_FRONT_RIGHT, 0};
    DSMIXBINS dsmixbins = {2, pair};
    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = 0;
    dsbd.dwBufferBytes = dwDataSize;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pWfx;
    dsbd.lpMixBins = &dsmixbins;
    dsbd.dwInputMixBin = 0;
    CHECKRUN(DirectSoundCreateBuffer(&dsbd, &pBuffer));
}

CHECKRUN(pBuffer->SetBufferData(pvData, dwDataSize));

//Load the wave file into our segment.
CHECKRUN(dmthLoadSegment(szWave, &ptSegment));

//DSound
CHECKRUN(pBuffer->SetCurrentPosition(0));
CHECKRUN(Log(FYILOGLEVEL, "Playing via IDirectSoundBuffer"));
CHECKRUN(pBuffer->Play(0, 0, 0));
if (SUCCEEDED(hr))
{
    do
    {
        CHECKRUN(pBuffer->GetStatus(&dwStatus));
    }
    while (DSBSTATUS_PLAYING & dwStatus);
}
CHECKRUN(pBuffer->Stop());
CHECKRUN(Wait(1000));

///DMusic
CHECKRUN(Log(FYILOGLEVEL, "Playing on %s", tdmXlatDMUS_APATH(dwPath)));
CHECKRUN(ptPerf8->CreateStandardAudioPath(dwPath, 128, TRUE, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000,  szWave, TRUE));

if (strstr(szWave, "_lp_"))
{
    CHECKRUN(WaitForSegmentStop(ptPerf8, ptSegment, NULL, 2000, TRUE));
}
else
{
    CHECKRUN(ExpectSegmentStop (ptPerf8, ptSegment, NULL, 20000, szWave, TRUE));
}

if (ptPerf8)
    ptPerf8->StopEx(0, 0, 0);


//Release DMusic stuff
RELEASE(ptSegment);
RELEASE(ptPath);

//Release DSound stuff
RELEASE(pBuffer);

//Release allocated memory.
delete [](BYTE *)pvData;
delete [](BYTE *)pWfx;

return hr;
}






/**********************************************************************
Play a segment and verify it takes the expected amount of time.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Timing(CtIDirectMusicPerformance *ptPerf8, DWORD dwSegment, DWORD dwExpectedTime)
{
HRESULT hr = S_OK;
DWORD i = 0;
LPCSTR szSegmentServer = LPSTR(dwSegment);
CHAR szSegment[MAX_PATH] = {0};
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
DWORD dwStartTime = 0;
DWORD dwDiffTime = 0;
double fErrorPercent = 0.f;
const double fMaxErrorPercent = 5.f;

//Copy everything in that directory.
//BUGBUG: We may need to copy something else as well?
CHECKRUN(MediaCopyDirectory(szSegmentServer));
strcpy(szSegment, MediaServerToLocal(szSegmentServer));

//Load the wave file into our segment.
CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));

///DMusic
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000, NULL, TRUE));
dwStartTime = timeGetTime();
CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, dwExpectedTime * 2, NULL, TRUE));
dwDiffTime = timeGetTime() - dwStartTime;

//Analyze the time spent playing the segment.
if (SUCCEEDED(hr))
{
    fErrorPercent = fabs(double(dwDiffTime) - double(dwExpectedTime)) * 100.f / double(dwExpectedTime);
    Log(FYILOGLEVEL, "%s took %ums to play.  Expected %ums", PathFindFileName(szSegment), dwDiffTime, dwExpectedTime);    
    Log(FYILOGLEVEL, "Error: %5.2f%%.  Maximum Allowed: %5.2f%%", fErrorPercent, fMaxErrorPercent);
    if (fErrorPercent > fMaxErrorPercent)
    {
        hr = E_FAIL;
    }
}

//Release DMusic stuff
//if (ptSegment && ptPath)
//{
//    ptSegment->Unload(ptPath);
//}
RELEASE(ptSegment);
RELEASE(ptPath);

return hr;
}


/**********************************************************************
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_Leak(CtIDirectMusicPerformance *ptPerf8, DWORD dwSegment1, DWORD dwSegment2)
{
HRESULT hr = S_OK;
DWORD i = 0;

CtIDirectMusicAudioPath *ptPath = NULL;
CtIDirectMusicSegment *ptSegment = NULL;
LPCSTR szSegmentServer = (LPSTR)dwSegment1;
LPCSTR szSegment = MediaServerToLocal(szSegmentServer);

ASSERT(strstr(szSegment, ".wav"));
CHECKRUN(MediaCopyFile(szSegmentServer));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREO, 128, TRUE, &ptPath));
CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0,0,NULL, NULL, ptPath));//  repro
CHECKRUN(ptPerf8->StopEx(0, 0, 0));

//Release the good stuff.
RELEASE(ptPath);
RELEASE(ptSegment);
return hr;
}





/**********************************************************************
if (szSegmentName == NULL) do (dwCount) multiple segments.
else do (dwCount) same segment.
**********************************************************************/
HRESULT Performance8_PlaySegmentEx_StartStopStreaming_PerfMem(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
#define MAX 30
CtIDirectMusicSegment *ptSegment[MAX] = {0};
//CtIDirectMusicSegmentState *ptSegmentState[MAX] = {0};
CtIDirectMusicAudioPath *ptPath = NULL;
DWORD dwStartTime = 0;
DWORD dwTimePassed = 0;
DWORD dwCounter = 0;
DWORD dwCount = 0;
HRESULT hr = S_OK;
DWORD i = 0;


dwCount = AMOUNT(szWaveFiles);

Log(FYILOGLEVEL, "Downloading wave files from server...");
/*

for (i=0; i<dwCount && SUCCEEDED(hr); i++)
{
    CHECKRUN(MediaCopyFile(szWaveFiles[i]));
};
*/
//Since they're all in the same directory, do them all at once.
CHECKRUN(MediaCopyDirectory(szWaveFiles[0]));



CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
for (i=0; i<dwCount && SUCCEEDED(hr); i++)
{
    CHECKRUN(dmthLoadSegment(MediaServerToLocal(szWaveFiles[i]), &ptSegment[i]));
    CHECKRUN(ptSegment[i]->SetWavePlaybackParams(DMUS_WAVEF_STREAMING, DMUS_READAHEAD_MIN));
}


dwStartTime = timeGetTime();
do
{
    for (i=0; i<dwCount && SUCCEEDED(hr); i++)
    {
        //CHECKRUN(Log(FYILOGLEVEL, "Playing segment %2d/%2d (%s)", i+1, dwCount, MediaServerToLocal(szWaveFiles[i])));
        if (rand() % 2)
        {
            CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[i],0,0,DMUS_SEGF_SECONDARY,0,NULL,0,ptPath));
        }
        
        if (SUCCEEDED(hr))
        {
            HRESULT hrPlaying = ptPerf8->IsPlaying(ptSegment[i], NULL);
            if (S_OK == hrPlaying)
            {
                if (rand() % 2)
                   ptPerf8->StopEx(ptSegment[i],0,0);
            }

        }
    }

    Sleep(rand() % 32);

    dwTimePassed = timeGetTime() - dwStartTime;
    if (dwTimePassed / 1000 > dwCounter)
    {
        Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
        dwCounter++;
    }
}
while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));



//Stop and release everything.
ptPerf8->StopEx(0, 0, 0);
for (i=0; i<dwCount && SUCCEEDED(hr); i++)
{
//    ptPerf8->StopEx(ptSegmentState[i], 0, 0);
//    SAFE_RELEASE(ptSegmentState[i]);
    SAFE_RELEASE(ptSegment[i]);
}

SAFE_RELEASE(ptPath);
return hr;
}
#undef MAX



/********************************************************************************
/********************************************************************************/
HRESULT Performance8_PlaySegmentEx_ClockTime_Looping(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, DWORD dwLoopPoint1, DWORD dwLoopPoint2, DWORD dwRepeats)
{
    HRESULT hr = S_OK;
    HRESULT hrPlaying = S_OK;
    REFERENCE_TIME rtLoopPoint[2] = {dwLoopPoint1, dwLoopPoint2};
    REFERENCE_TIME rtExpectedPlayingTime = 0;
    DWORD dwExpectedPlayingTime = 0;
    DWORD dwStartTime = 0;
    DWORD dwStopTime  = 0;
    DWORD dwPlayingTime = 0;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    FLOAT fErrorPercent = 0.f;
    FLOAT fMaxErrorPercent = 2.f;
    BOOL bClockTimeSegment = FALSE;
    REFERENCE_TIME rtDummy = 0;

    //Assuming media has already been loaded from the calling function.    
    CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));    
    CHECK   (dwStartTime = timeGetTime());
    CHECK   (Log(FYILOGLEVEL, "Playing %s (contains loop points at %d and %d ticks, and repeats %d time(s)", PathFindFileName(szSegment), dwLoopPoint1, dwLoopPoint2, dwRepeats));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, 0, 0, 0, 0, 0, 0, ptPath));
    //CHECKRUN(Log(FYILOGLEVEL, "Expecting loop points to %I64u and %I64u", rtLoopPoint[0], rtLoopPoint[1]));

    //Calculate how long the file SHOULD play given these loop points.  6 + (loop2 - loop1) * repeats
    rtExpectedPlayingTime = 60000000 + (rtLoopPoint[1] - rtLoopPoint[0]) * dwRepeats;

    dwExpectedPlayingTime = DWORD(rtExpectedPlayingTime / 10000);
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, dwExpectedPlayingTime, NULL));
    CHECKRUN(WaitForSegmentStop (ptPerf8, ptSegment, NULL, dwExpectedPlayingTime * 4, NULL));
    CHECK   (dwStopTime = timeGetTime());
    if (SUCCEEDED(hr))
    {
        dwPlayingTime = dwStopTime - dwStartTime;
        fErrorPercent = 100.f * FLOAT(fabs(LONG(dwPlayingTime - dwExpectedPlayingTime) / FLOAT(dwExpectedPlayingTime)));
        Log(FYILOGLEVEL, "Segment stopped at %ums, expected to stop at %ums.", dwPlayingTime, dwExpectedPlayingTime);
        Log(FYILOGLEVEL, "Error = %.2f%%, maximum allowed error is %.2f%%", fErrorPercent, fMaxErrorPercent);
        if (fErrorPercent > fMaxErrorPercent)
        {
            Log(ABORTLOGLEVEL, "FAILURE!!  %.2f%% exceeds maximum allowed error of %.2f%%!!!", fErrorPercent, fMaxErrorPercent);
            hr = E_FAIL;
        }
    }

    ptPerf8->StopEx(0, 0, 0);    
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);

    return hr;

};



/********************************************************************************
/********************************************************************************/
/*
HRESULT Performance8_PlaySegmentEx_ClockTime_Looping_Wave(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    MEDIAFILEDESC MediaFileDesc[] = {
                                    //{"DMusic/DMTest1/Segment8/GetClockTimeLength/CountTo6.wav", "T:\\DMTest1\\Segment8\\GetClockTimeLength\\",    COPY_IF_NEWER},
                                    {"WAV/CountTo6Looped.wav", "T:\\WAV\\",    COPY_IF_NEWER},
                                    {TERMINATE}
                                    };

    CHECKRUN(LoadMedia(MediaFileDesc));
    CHECKRUN(Performance8_PlaySegmentEx_ClockTime_Looping(ptPerf8, "T:\\WAV\\CountTo6Looped.wav", 0, 60000000));
    return hr;
}

*/

/********************************************************************************
/********************************************************************************/
#define SEGMENT 0
#define WAVE 1

HRESULT Performance8_PlaySegmentEx_ClockTime_Looping(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSuffix, DWORD dwType)
{
    HRESULT hr = S_OK;
    LPCSTR szSuffix = (LPCSTR)dwSuffix;
    DWORD dwNumber[3] = {0};

    CHAR szSrcSeg[MAX_PATH] = {0};
    CHAR szDstSeg[MAX_PATH] = {0};
    CHAR szDstPath[MAX_PATH] = {0};

    //We're getting the start point, endpoint, and repeat count from the title of the wave file.  Totally hacky but works as
    //  long as we don't use some random wave file in here.
    {
        LPCSTR szCurrent = szSuffix;
        for (DWORD i = 0; i<3; i++)
        {
            ASSERT(*szCurrent);
            while (!isdigit(*szCurrent))
            {
                ASSERT(*szCurrent);
                szCurrent++;
            }
            dwNumber[i] = atoi(szCurrent++);
        }
    }


    sprintf(szSrcSeg, "DMusic/DMTest1/Perf8/PlaySeg/CTLooping/%sCTLooped_%s.%s", (dwType==SEGMENT) ? "Seg" : "Wav", szSuffix, (dwType==SEGMENT) ? "sgt" : "wav");
    sprintf(szDstSeg, MediaServerToLocal(szSrcSeg));
    CHECKRUN(ChopPath(szDstSeg, szDstPath, NULL));

    MEDIAFILEDESC MediaFileDesc[3] = {0};
    
    MediaFileDesc[0].lpszFromPath = szSrcSeg;
    MediaFileDesc[0].lpszToPath   = szDstPath;
    MediaFileDesc[0].dwFlags      = COPY_IF_NEWER;

    if (dwType == SEGMENT)
    {
        MediaFileDesc[1].lpszFromPath = "DMusic/DMTest1/Perf8/PlaySeg/CTLooping/CTLooping.dls";
        MediaFileDesc[1].lpszToPath   = "T:\\DMTest1\\Perf8\\PlaySeg\\CtLooping\\";
        MediaFileDesc[1].dwFlags      = COPY_IF_NEWER;
    }

    CHECKRUN(LoadMedia(MediaFileDesc));
    CHECKRUN(Performance8_PlaySegmentEx_ClockTime_Looping(ptPerf8, szDstSeg, dwNumber[0] * 10000000, dwNumber[1] * 10000000, dwNumber[2]));
    return hr;
}
#undef SEGMENT
#undef WAVE


/********************************************************************************
/********************************************************************************/
#define MAXMEDIA 10

#define PMAX 4
#define CMAX 7
#define OS 0
#define ST 1
#define MU 2
#define MP 3


HRESULT Performance8_PlaySegmentEx_AudioPath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback, DWORD dwContentChannels)
{
    HRESULT hr = S_OK;
    MEDIAFILEDESC MediaFileDesc[MAXMEDIA] = {0};
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    CHAR szSegmentLocal[MAX_PATH] = {0};
    LPCSTR szSegmentName = NULL;


    LPCSTR szPlayBack[CMAX][PMAX] =  {
         {NULL, NULL, NULL},
         {"WAV/PCM_OS_11_1.wav",        "WAV/PCM_ST_11_1.wav",          g_TestParams.szDefaultMedia, "SGT/MultiPan.sgt"},        //1 Channel
         {"WAV/PCM_OS_11_2.wav",        "WAV/PCM_ST_11_2.wav",          g_TestParams.szDefaultMedia, "SGT/MultiPan.sgt"},        //2 Channel
         {NULL, NULL, NULL},
         {"WAV/4Chan16Short.wav",       "WAV/4Chan16Long.wav",          g_TestParams.szDefaultMedia, "SGT/MultiPan.sgt"},        //4 Channel
         {NULL, NULL, NULL},
         {"WAV/FivePointOne16.wav",     "WAV/FivePointOne16Long.wav",   g_TestParams.szDefaultMedia, "SGT/MultiPan.sgt"}         //6 Channel
         };

    ASSERT(IsValidAudioPath(dwType));
    ASSERT(dwContentPlayback <= PMAX);
    ASSERT(dwContentChannels <= CMAX);

    szSegmentName = szPlayBack[dwContentChannels][dwContentPlayback];
    if (szSegmentName == g_TestParams.szDefaultMedia)
    {
        strcpy(szSegmentLocal, szSegmentName);
    }
    else
    {
        CHECKRUN(MediaCopyFile(szSegmentName));
        strcpy(szSegmentLocal, MediaServerToLocal(szSegmentName));
    }

    
    ASSERT(szSegmentLocal[0]);
    CHECK(   Log(FYILOGLEVEL, "Playing %s on %s", szSegmentName, dmthXlatDMUS_APATH(dwType)));
    CHECKRUN(dmthLoadSegment(szSegmentLocal, &ptSegment));
    CHECKRUN(ptPerf8->CreateStandardAudioPath(dwType, 16, TRUE, &ptPath));
    CHECKRUN(InsertToolTrace(ptPath));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
    CHECKRUN(WaitForSegmentStop(ptPerf8, ptSegment, NULL, 25000));
    CHECK   (RemoveToolTrace(ptPath));
    RELEASE(ptSegment);
    RELEASE(ptPath);
    
    //Unconditional wait; necessary to prevent future assert from reused audiopath.
    Sleep(1000);  
    return hr;
}



HRESULT Performance8_PlaySegmentEx_AudioPath_1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback)
{
    return Performance8_PlaySegmentEx_AudioPath(ptPerf8, dwType, dwContentPlayback, 1);
}

HRESULT Performance8_PlaySegmentEx_AudioPath_2(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback)
{
    return Performance8_PlaySegmentEx_AudioPath(ptPerf8, dwType, dwContentPlayback, 2);
}

HRESULT Performance8_PlaySegmentEx_AudioPath_4(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback)
{
    return Performance8_PlaySegmentEx_AudioPath(ptPerf8, dwType, dwContentPlayback, 4);
}

HRESULT Performance8_PlaySegmentEx_AudioPath_6(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback)
{
    return Performance8_PlaySegmentEx_AudioPath(ptPerf8, dwType, dwContentPlayback, 6);
}

#undef PMAX 
#undef CMAX 
#undef OS 
#undef ST 
#undef MU
#undef MP


/********************************************************************************
/********************************************************************************/
HRESULT Performance8_PlaySegmentEx_MunchPerf(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
char chLowGrooveLevel  = -9;
char chHighGrooveLevel = 99;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
REFERENCE_TIME rtStart = 0;
DWORD dwSeconds = 15;

CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, &chHighGrooveLevel, sizeof(chLowGrooveLevel)));
CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Perf8/PlaySeg/MunchPerf/"));
CHECKRUN(Log(FYILOGLEVEL, "Silence for %d seconds", dwSeconds));
CHECKRUN(CountDown(dwSeconds * 1000, 1000));

CHECKRUN(dmthLoadSegment("T:\\DMTest1\\Perf8\\PlaySeg\\MunchPerf\\Munch06.sgt", &ptSegment));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, 64, &ptPath));
CHECKRUN(ptPerf8->GetTime(&rtStart, NULL));
rtStart -= dwSeconds * 10000000;

//Play segment 5 seconds ago.
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, 0, 0, DMUS_SEGF_REFTIME | DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_TICK, rtStart, 0, 0, ptPath));

CHECKRUN(Log(FYILOGLEVEL, "Playing for 4 seconds at high groove level"));
CHECKRUN(Wait(4000));
CHECKRUN(ptPerf8->StopEx(0, 0, 0));
CHECKRUN(Log(FYILOGLEVEL, "Silence for 1 second"));
CHECKRUN(Wait(1000));
RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};


/********************************************************************************
/********************************************************************************/
HRESULT Performance8_PlaySegmentEx_AntzLooping(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;

CHECKRUN(MediaCopyFile("SGT/Antz2_melody_strings_a.sgt"));
CHECKRUN(dmthLoadSegment("T:\\SGT\\Antz2_melody_strings_a.sgt", &ptSegment));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, 64, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, 0, 0, 0, 0, 0, 0, ptPath));
CHECKRUN(Log(FYILOGLEVEL, "Playing for 10 seconds, should loop smoothly."));
CHECKRUN(Wait(10000));
CHECKRUN(ptPerf8->StopEx(0, 0, 0));
CHECKRUN(Log(FYILOGLEVEL, "Silence for 1 second"));
CHECKRUN(Wait(1000));
RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_SendPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_PMsg_Generic(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_SendPMsg_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_SendPMsg_BVT())");
    DMTEST_EXECUTE(Performance8_PMsg_Generic(ptPerf8));   //FAIL: 2968
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_PMsg_Generic(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);

    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
    CHECKALLOC(pTempo);

    if (SUCCEEDED(hr))
    {
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        pTempo->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
        hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTempo );
        if (FAILED(hr))
        {
            ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo );
            pTempo = NULL;
            goto TEST_END;
        }
    }


    CHECKRUN(Log(FYILOGLEVEL, "Just sent a tempo=500 pMsg, should notice a tempo change.  Playing at tempo=500 for 5s."));
    CHECKRUN(Wait(5000));

TEST_END:
    //No need to free a sent pMsg.
    return hr;
};


 

/********************************************************************************
********************************************************************************/
HRESULT Performance8_PMsg_Valid_Tempos(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;
double dblTempos[] = {0, 1, 120, 1000, 2000};
DWORD i = 0;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Wait(2000);


    for (i=0; i<AMOUNT(dblTempos); i++)
    {
        //Create your PMsg.  I copied this from the sample
        CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pTempo ));
        CHECKALLOC(pTempo);

        if (SUCCEEDED(hr))
        {
            pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
            pTempo->dblTempo = dblTempos[i];
            pTempo->rtTime = 0;
            pTempo->dwFlags = DMUS_PMSGF_REFTIME;
            pTempo->dwType = DMUS_PMSGT_TEMPO;
            pTempo->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
            hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTempo );
            if (FAILED(hr))
            {
                ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo );
                pTempo = NULL;
                goto TEST_END;
            }
        }

        CHECKRUN(Log(FYILOGLEVEL, "Just sent a tempo=%g pMsg, should notice a tempo change.  Playing for 4s.", dblTempos[i]));
        CHECKRUN(Wait(4000));

    }



TEST_END:
    //No need to free a sent pMsg.
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_PMsg_Valid_Transpose(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TRANSPOSE_PMSG* pTranspose = NULL;
LPSTR szSegmentName = "T:\\DMTest1\\Perf8\\SendPMsg\\OnePitch.sgt";
int nTranspose = 0;
BOOL bDone = FALSE;

    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DMusic/DMTest1/Perf8/SendPMsg/OnePitch.sgt",  "T:\\DMTest1\\Perf8\\SendPMsg\\", COPY_IF_NEWER},
    {"DLS/Main1.DLS",               "T:\\DMTest1\\Perf8\\SendPMsg\\", COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, szSegmentName, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    Log(FYILOGLEVEL, "Playing C-5 note at default key for 2s.");
    Wait(2000);


    Log(FYILOGLEVEL, "Transposing playback from -128 to 127...");
    for (nTranspose=-128; nTranspose<=127 ; nTranspose++)
    {
        
        //Create your PMsg.  I copied this from the sample
        CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose ));
        CHECKALLOC(pTranspose)

        if (SUCCEEDED(hr))
        {
            pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
            pTranspose->rtTime = 0;
            pTranspose->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_DX8;
            pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
            pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
            pTranspose->nTranspose = (short)nTranspose;
            pTranspose->wMergeIndex = 1;
            hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTranspose );
            if (FAILED(hr))
            {
                ptPerf8->FreePMsg( (DMUS_PMSG*)pTranspose );
                pTranspose = NULL;
                goto TEST_END;
            }


            if (nTranspose % 32 == 0)
                Log(FYILOGLEVEL, "Tranpose = %d", nTranspose);
            Wait(80);
        }
    }



TEST_END:

        
        //Set the transpose back to zero.
        ptPerf8->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose );
        if (pTranspose)
        {
            pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
            pTranspose->rtTime = 0;
            pTranspose->dwFlags = DMUS_PMSGF_REFTIME;
            pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
            pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
            pTranspose->nTranspose = 0;
            hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTranspose );
        }



    //No need to free a sent pMsg.
    return hr;
};

/********************************************************************************
********************************************************************************/
HRESULT Performance8_PMsg_Valid_Transpose_ChangeSong(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TRANSPOSE_PMSG* pTranspose  = NULL;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
LPSTR szSegmentName = "T:\\DMTest1\\Perf8\\SendPMsg\\OnePitch.sgt";
int nTranspose = 0;
BOOL bDone = FALSE;

    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DMusic/DMTest1/Perf8/SendPMsg/OnePitch.sgt",  "T:\\DMTest1\\Perf8\\SendPMsg\\", COPY_IF_NEWER},
    {"DLS/Main1.DLS",               "T:\\DMTest1\\Perf8\\SendPMsg\\", COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, szSegmentName, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment));
    CHECKRUN(Music.GetInterface(&ptPath));
    Log(FYILOGLEVEL, "Playing C-5 note at default key for 2s.");
    Wait(2000);

    nTranspose = 24;
        
    //Create your PMsg.  I copied this from the sample
    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose ));
    CHECKALLOC(pTranspose)

    if (SUCCEEDED(hr))
    {
        pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
        pTranspose->rtTime = 0;
        pTranspose->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_DX8;
        pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
        pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
        pTranspose->nTranspose = (short)nTranspose;
        pTranspose->wMergeIndex = 1;
        hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pTranspose );
        if (FAILED(hr))
        {
            ptPerf8->FreePMsg( (DMUS_PMSG*)pTranspose );
            pTranspose = NULL;
            goto TEST_END;
        }
    }

    Log(FYILOGLEVEL, "Transposing playback up two octaves for 4 seconds.");
    CHECKRUN(Wait(4000));


    CHECKRUN(Log(FYILOGLEVEL, "Restarting the song; Playing 4 seconds; Transpose level should remain at 2 octaves"));
    CHECKRUN(ptPerf8->StopEx(ptSegment, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 5000, NULL, FALSE));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, NULL, 0, NULL, NULL, ptPath));
    CHECKRUN(Wait(4000));

TEST_END:
        
        //Set the transpose back to zero.
        ptPerf8->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose );
        if (pTranspose)
        {
            HRESULT hrResetTranspose;
            pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
            pTranspose->rtTime = 0;
            pTranspose->dwFlags = DMUS_PMSGF_REFTIME;
            pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
            pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
            pTranspose->nTranspose = 0;
            hrResetTranspose = ptPerf8->SendPMsg( (DMUS_PMSG*)pTranspose );
            if (FAILED(hrResetTranspose))
            {
                Log(ABORTLOGLEVEL, "ERROR: Resetting the transpose level failed because SendPMsg returned %s (%08X)", tdmXlatHRESULT(hr), hr);
                if (SUCCEEDED(hr))
                    hr = hrResetTranspose;
            }
        }



    //No need to free a sent pMsg.
    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptPath);
    return hr;
};










/********************************************************************************
********************************************************************************/
HRESULT Performance8_PMsg_Valid_PitchBend(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CICMusic Music;
DMUS_CURVE_PMSG* pCurve= NULL;
DWORD dwEndValue[] = {4000};
DWORD i = 0;

    //Play some music whose tempo we're gonna change.
    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    Log(FYILOGLEVEL, "Playing at default for one measure.");


    for (i=0; i<AMOUNT(dwEndValue); i++)
    {
        //Create your PMsg.  I copied this from the sample
        CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pCurve ));
        CHECKALLOC(pCurve);

        if (SUCCEEDED(hr))
        {
            pCurve->dwSize = sizeof(DMUS_CURVE_PMSG);


        pCurve->mtDuration = DMUS_PPQ * 4;      /* how long this curve lasts */
        pCurve->mtOriginalStart = 0; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
        pCurve->mtResetDuration = 0; /* how long after the curve is finished to allow a flush or
                                                        invalidation to reset to the reset value, nResetValue */
        pCurve->nStartValue = 0;      /* curve's start value */
        pCurve->nEndValue = (short)dwEndValue[i];    /* curve's end value */
        pCurve->nResetValue = 0;     /* curve's reset value, set when a flush or invalidation
                                                    occurs within mtDuration + mtResetDuration */
        pCurve->wMeasure = 1;        /* Measure in which this curve occurs */
        pCurve->nOffset = 0;         /* Offset from grid at which this curve occurs */
        pCurve->bBeat = 0;           /* Beat (in measure) at which this curve occurs */
        pCurve->bGrid = 0;           /* Grid offset from beat at which this curve occurs */
        pCurve->bType = DMUS_CURVET_PBCURVE ;           /* type of curve */
        pCurve->bCurveShape = DMUS_CURVES_LINEAR ;     /* shape of curve */
        pCurve->bCCData = 0;         /* CC# if this is a control change type */
        pCurve->bFlags = DMUS_CURVE_RESET ;          /* Curve reset and start from current value flags. */
        pCurve->wParamType = 0;      /* RPN or NRPN parameter number. */
        pCurve->wMergeIndex = 0;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/



        hr = ptPerf8->SendPMsg( (DMUS_PMSG*)pCurve );
        if (FAILED(hr))
        {
            ptPerf8->FreePMsg( (DMUS_PMSG*)pCurve );
            pCurve = NULL;
            goto TEST_END;
        }
    }

    CHECKRUN(Log(FYILOGLEVEL, "Just sent a %s curve.", "PitchBend"));
    CHECKRUN(Wait(8000));

    }



TEST_END:
    //No need to free a sent pMsg.
    return hr;
};



/**********************************************************************
Crossfade smoothly from one segment to another (they can be DLS or Wave
segments)
**********************************************************************/
HRESULT Performance8_PMsg_Crossfade(CtIDirectMusicPerformance *ptPerf8, DWORD dwSegmentServer1, DWORD dwSegmentServer2)
{
HRESULT hr = S_OK;
DWORD i = 0;
CHAR  szSegment[2][MAX_PATH]    = {0};
LPSTR szSegmentServer[2]        = {NULL};
CtIDirectMusicAudioPath *ptPath[2] = {NULL};
CtIDirectMusicSegment *ptSegment[2] = {NULL};
IDirectMusicGraph *pGraph[2] = {NULL};
CtIDirectMusicSegmentState *ptSegmentState[2] = {NULL};
szSegmentServer[0] = (LPSTR)dwSegmentServer1;
szSegmentServer[1] = (LPSTR)dwSegmentServer2;
DMUS_CURVE_PMSG *pCurve[2] = {NULL};

//Copy the media, and everything else in its directory.
for (i=0; i<2; i++)
{
    CHAR szDirectory[MAX_PATH] = {0};
    strcpy(szSegment[i], MediaServerToLocal(szSegmentServer[i]));
    CHECKRUN(MediaCopyDirectory(szSegmentServer[i]));

    //Get the directory of that file.
    CHECKRUN(ChopPath(szSegment[i], szDirectory, NULL));
    //Put MAIN1.DLS in that directory too, just in case.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS", szDirectory,    COPY_IF_NEWER},
    {TERMINATE}
    };
    
    CHECKRUN(LoadMedia(MediaFileDesc));

}




//How long to play the first segment before starting the fade.
const DWORD dwWaitDuration              = 2000;  

//How long the fade should last.
const DWORD dwFadeoutDuration           = 2000;  

//How long the fade should last in reftime.
const LONGLONG llWaitDuration           = LONGLONG(dwWaitDuration) * LONGLONG(10000); 

//How soon to start the curve before the actual segment starts, so it doesn't start
//  playing at full volume slightly before it starts it's fade-in curve from 0-127.
//  200ms.
const LONGLONG llPreRollDuration       = LONGLONG(10000 * 200);   
REFERENCE_TIME rt                       = 0;

//Create segments on their respective audiopaths.
//Segments must be on separate audiopaths or crossfades will interfere with each other.
for (i=0; i<2; i++)
{
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREO, 128, TRUE, &ptPath[i]));
    CHECKRUN(dmthLoadSegment(szSegment[i], &ptSegment[i]));
}

//Play segment 1 immediately.  We play it as secondary because if it's primary we hit problems
//  when we play the next segment (this one pauses for some reason).
//  We must set use this segment's tempo though, so we specify DMUS_SEGF_CONTROL too.
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0], NULL, NULL, DMUS_SEGF_REFTIME | DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL,0,&ptSegmentState[0], NULL, ptPath[0]));

//After the specified wait time, queue the next segment slightly in the future, and start the crossfade curves immediately.
//  If we don't queue the next segment in the future, it will play at full volume for a short time before the fade-in curve
//  turns it down.  Being a secondary segment, it will pick up the previous segment's tempo which is fine.
Wait(dwWaitDuration);
CHECKRUN(ptPerf8->GetTime(&rt, NULL));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[1], NULL, NULL, DMUS_SEGF_REFTIME | DMUS_SEGF_SECONDARY, rt + llPreRollDuration,&ptSegmentState[1], NULL, ptPath[1]));

//Create volume curve pMsgs for both segments.  They are exactly the same except
//the first segment fades out slowly and the second segment fades in quickly.
for (i=0; i<2; i++)
{
    //Obtain the tool graph for our segment state.
    CHECKRUN(ptSegmentState[i]->QueryInterface(IID_IDirectMusicGraph, (LPVOID *)&pGraph[i]));

    CHECKRUN(ptPerf8->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pCurve[i] ));
    CHECKALLOC(pCurve[i])
    if (SUCCEEDED(hr))
    {
        pCurve[i]->dwSize = sizeof(DMUS_CURVE_PMSG);
        
        //Send this message immediately.
        pCurve[i]->rtTime = 0;  

        //Unused since we specified DMUS_PMSGF_REFTIME
        pCurve[i]->mtTime = 0;
        
        
        //Use the rtTime member instead of mtTime.
        pCurve[i]->dwFlags |= DMUS_PMSGF_REFTIME;

        //mtDuration is in milliseconds, not MUSIC_TIME.
        pCurve[i]->dwFlags |= DMUS_PMSGF_LOCKTOREFTIME;

        //"Message should be processed immediately, regardless of its time stamp."
        //This is redundant with specifying 0 for the time.
        pCurve[i]->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;

        //If this flag is not specified, wMergeIndex field will be ignored.
        pCurve[i]->dwFlags |= DMUS_PMSGF_DX8;               

        //Send to all pChannels on this segment.
        pCurve[i]->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
        pCurve[i]->dwVirtualTrackID = 0;
        pCurve[i]->pTool= NULL;
        pCurve[i]->pGraph = NULL;
        pCurve[i]->dwType = DMUS_PMSGT_CURVE;
        pCurve[i]->dwVoiceID = 0;
        pCurve[i]->dwGroupID = 0xFFFFFFF;
        pCurve[i]->punkUser = NULL;

        //How long this curve lasts in milliseconds (since we specified DMUS_PMSGF_LOCKTOREFTIME)
        pCurve[i]->mtDuration = dwFadeoutDuration;

        //Must be set to either zero when this PMSG is created or to the original mtTime of the curve 
        pCurve[i]->mtOriginalStart = 0; 

        //How long after the curve is finished to allow a flush or invalidation to reset to the reset value, nResetValue 
        pCurve[i]->mtResetDuration = 0; 
                                                        
        //Fade high to low if, or low to high if fading in.
        pCurve[i]->nStartValue = (i==0) ? 127 :    0;
        pCurve[i]->nEndValue   = (i==0) ? 0   :  127;

        //Curve's reset value, set when a flush or invalidation
        pCurve[i]->nResetValue = 0;     

        //These 4 fields don't have any effect if we've specified DMUS_PMSGF_LOCKTOREFTIME
        pCurve[i]->wMeasure = 0;        // Measure in which this curve occurs 
        pCurve[i]->nOffset = 0;         // Offset from grid at which this curve occurs 
        pCurve[i]->bBeat = 0;           // Beat (in measure) at which this curve occurs 
        pCurve[i]->bGrid = 0;           // Grid offset from beat at which this curve occurs 


        //Volume curves are CC curves of type 7.
        pCurve[i]->bType = DMUS_CURVET_CCCURVE ;                              
        pCurve[i]->bCCData = 7;                                              

        //Fade out slowly and fade in quickly to preserve overall volume.
        pCurve[i]->bCurveShape = (i==0) ? DMUS_CURVES_EXP: DMUS_CURVES_LOG;   // shape of curve 

        //Blow away any current curves.
        pCurve[i]->bFlags = DMUS_CURVE_RESET;

        //RPN or NRPN parameter number (irrelevant here)
        pCurve[i]->wParamType = 0;      
        
        //An arbitrary value.  Choose one other than zero, and other than those used by curves in your content, if any.
        pCurve[i]->wMergeIndex = 55;
        
    }

    //Tell this pMsg to go to the correct segment's toolgraph.
    CHECKRUN(pGraph[i]->StampPMsg((DMUS_PMSG *)pCurve[i]));
    CHECKRUN(ptPerf8->SendPMsg( (DMUS_PMSG*)pCurve[i] ));
    if (FAILED(hr))
    {
        if (ptPerf8 && pCurve[i])
            ptPerf8->FreePMsg( (DMUS_PMSG*)pCurve[i]);
        pCurve[i] = NULL;
    }
}

//Wait the appripriate time for the fadeout to start, finish, plus 5 seconds.  Then stop everything.
CHECKRUN(Wait(dwFadeoutDuration + 5000));
CHECKRUN(ptPerf8->StopEx(0, 0, 0));

//Release the good stuff.
for (i=0; i<2; i++)
{    
    RELEASE(ptPath[i]);
    RELEASE(ptSegment[i]);
    RELEASE(pGraph[i]);
    RELEASE(ptSegmentState[i]);
}

return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Perf_Template.cpp ===
/********************************************************************************
Function template used by performance tests.

PARAMETERS:
lTime: 
    PERF_ONEITERATION:  



********************************************************************************/
#define PERF_ONEITERATION (-696969)


HRESULT PerformanceTemplate(LONG lTime,
                            LONG *lTimeSpent,
                            DWORD *dwIterations
                            )
{
//LOCAL VARIABLES
HRESULT hr = S_OK;
LARGE_INTEGER liStartTime  = 0;
LARGE_INTEGER liFinishTime = 0;
DWORD dwIterations = ;
DWORD dwCount;


//INITIALIZATION CODE
//-------------------





//TIMING CODE
//-----------
dwCount = 0;
QueryPerformanceCounter(&liStartTime);
while (





//RELEASE Code


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_SetGlobalParam.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_SetGlobalParam_Groove_BVT(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_SetGlobalParam_Tempo1(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, FLOAT fNewTempo);
HRESULT Performance8_SetGlobalParam_Volume1(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, long lNewVolume);





/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_SetGlobalParam_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Performance8_SetGlobalParam_BVT())");

    DMTEST_EXECUTE(Performance8_SetGlobalParam_Groove_BVT(ptPerf8));
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 2.0f));  
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, -1000));
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_SetGlobalParam_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Valid test function Performance8_SetGlobalParam_Valid())");

    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 0.01f));  
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 0.10f));  
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 1.00f));  
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 10.f));  
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Tempo1 (ptPerf8, g_TestParams.szDefaultMedia, 100.f));  

    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, 0));
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, -100));
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, -1000));
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, -5000));
    DMTEST_EXECUTE(Performance8_SetGlobalParam_Volume1(ptPerf8, g_TestParams.szDefaultMedia, -10000));

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_SetGlobalParam_Groove_BVT(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    char bOldMasterGrooveLevel                               = 0;
    char dwNewMasterGrooveLevel                            = 0;
    CHAR *szSegmentServer = "DMusic/DMTest1/Perf8/SetGlob/Groove.sgt";
    char i = 0;

    CHECKRUN(MediaCopyDirectory(szSegmentServer));

    bOldMasterGrooveLevel = 0;

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, MediaServerToLocal(szSegmentServer), DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    Log(FYILOGLEVEL, "Playing %s normally for 2 seconds.", MediaServerToLocal(szSegmentServer));
    Wait(2000);


    //Go through 5 groove levels.
    for (i=0; i<=4; i++)
    {
        dwNewMasterGrooveLevel = i;
        CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&dwNewMasterGrooveLevel, sizeof(dwNewMasterGrooveLevel)));
        Log(FYILOGLEVEL, "Setting dwNewMasterGrooveLevel to %d.  Should switch to ""%d"" being spoken at next measure break.", i, i+1);
        Wait(5000);
    }

    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bOldMasterGrooveLevel, sizeof(bOldMasterGrooveLevel)));

    //CLEANUP
    SAFE_RELEASE(ptSegment8);
    return  hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_SetGlobalParam_Groove1(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    char bOldMasterGrooveLevel                               = 0;
    char bNewMasterGrooveLevel                            = 0;
    CHAR *szSegmentServer = "DMusic/DMTest1/Perf8/SetGlob/Groove.sgt";
    DWORD i = 0;
    char dwLevels[] = {0, 1, 10, 100};


    CHECKRUN(MediaCopyDirectory(szSegmentServer));

    bOldMasterGrooveLevel = 0;

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, MediaServerToLocal(szSegmentServer), DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    Log(FYILOGLEVEL, "Playing %s normally for 2 seconds.", MediaServerToLocal(szSegmentServer));
    Wait(2000);


    //Go through 100 groove levels.
    for (i=0; i<AMOUNT(dwLevels); i++)
    {
        bNewMasterGrooveLevel = dwLevels[i];
        CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bNewMasterGrooveLevel, sizeof(bNewMasterGrooveLevel)));
        Log(FYILOGLEVEL, "Setting bNewMasterGrooveLevel to %d for 3 seconds.");
        Wait(3000);
    }

    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bOldMasterGrooveLevel, sizeof(bOldMasterGrooveLevel)));

    //CLEANUP
    SAFE_RELEASE(ptSegment8);
    return  hr;
};




/********************************************************************************
********************************************************************************/
HRESULT Performance8_SetGlobalParam_Tempo1(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, FLOAT fNewTempo)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    FLOAT fOldTempo                               = 0;
    fOldTempo = 1.f;

    ASSERT(strcmp(g_TestParams.szDefaultMedia, szSegment) == 0);

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    Log(FYILOGLEVEL, "Playing %s normally for 2 seconds.", szSegment);
    Wait(2000);

    //Set the tempo up way high.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempo, sizeof(fNewTempo)));
    Log(FYILOGLEVEL, "Setting fNewTempo to %g, will hear music at %g times normal for 5 seconds.", fNewTempo, fNewTempo);
    Wait(5000);

    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo)));
    Log(FYILOGLEVEL, "Setting tempo back to %g, will hear normal music for 3 seconds.", fOldTempo);
    Wait(3000);

    //CLEANUP
    SAFE_RELEASE(ptSegment8);
    return  hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_SetGlobalParam_Volume1(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, long lNewVolume)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    long  lOldVolume                               = 0;

    ASSERT(strcmp(g_TestParams.szDefaultMedia, szSegment) == 0);

    //Start music playing.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
    Log(FYILOGLEVEL, "Playing %s normally for 2 seconds.", szSegment);
    Wait(2000);

    //Set the Volume down way low.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lNewVolume, sizeof(lNewVolume)));
    Log(FYILOGLEVEL, "Setting lNewVolume to %d, will hear quiet music for 5 seconds.", lNewVolume);
    Wait(5000);

    //Set the old one again.
    CHECKRUN(ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume)));
    Log(FYILOGLEVEL, "Setting Volume back to %d, will hear normal-volume music for 3 seconds", lOldVolume);
    Wait(3000);

    SAFE_RELEASE(ptSegment8);
    return  hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\script.h ===
#pragma once

#include "cicmusicx.h"

static const LPSTR INIT_SCRIPT           = "T:\\DMTest1\\script\\init.spt";
static const LPSTR INIT_SCRIPT_NOEXIST   = "T:\\DMTest1\\script\\haha.spt";
static const LPSTR INIT_SCRIPT_BAD       = "T:\\DMTest1\\script\\bad.spt";
static const LPSTR INIT_SCRIPT_SYNTAX    = "T:\\DMTest1\\script\\syntax.spt";
static const LPSTR INIT_SCRIPT_RUNTIME   = "T:\\DMTest1\\script\\runtime.spt";
static const LPSTR CALLROUTINE_MASTER    = "T:\\DMTest1\\script\\master.spt";
static const LPSTR VARIABLE_MASTER       = "T:\\DMTest1\\script\\variables.spt";

static const LPSTR ROUTINE_GOOD          = "NoError";
static const LPSTR ROUTINE_NO_EXIST      = "Bingo";
static const LPSTR ROUTINE_RUNTIME_ERROR = "BadObject";
static const LPSTR ROUTINE_EMPTY         = "";

static const LPSTR VARIABLE_INIT         = "Init";
static const LPSTR NUMBER_GOOD           = "Number";
static const LPSTR VARIABLE_EMPTY        = "";
static const LPSTR VARIABLE_NO_EXIST     = "Bingo";
static const LONG NUMBER_VALUE           = 100;
static const LONG NEW_VALUE              = 200;

static const LPSTR SEGMENT_GOOD          = "PlayingSegment1";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\script.cpp ===
#include "globals.h"
//#include "script.h"

HRESULT dmthCreateScript( LPCSTR szScriptName, CtIDirectMusicLoader8* pLoader, CtIDirectMusicScript** ppScript )
{
	CHAR szPath[MAX_PATH] = {0};
    if ( NULL == ppScript || NULL == szScriptName )
		return E_POINTER;

	HRESULT hr = S_OK;

	CHECKRUN( ChopPath(szScriptName, szPath, NULL));
    CHECKRUN( pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, FALSE));
	CHECKRUN( pLoader->LoadObjectFromFile( CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScriptName, (LPVOID*) ppScript ) );

	return hr;
}

HRESULT dmthInitScriptErrorInfo( DMUS_SCRIPT_ERRORINFO* pInfo )
{
	if ( NULL == pInfo )
		return S_OK;

	HRESULT hr = S_OK;

	ZeroMemory( pInfo, sizeof( DMUS_SCRIPT_ERRORINFO ) );
	pInfo->dwSize = sizeof( DMUS_SCRIPT_ERRORINFO );

	return hr;
}

void dmthVerifyScriptError( DMUS_SCRIPT_ERRORINFO* pInfo )
{
	if ( NULL == pInfo )
		return;

	if ( FAILED( pInfo->hr ) )
	{
		Log(FYILOGLEVEL, "DMUS_SCRIPT_ERROR_INFO:" );
		Log(FYILOGLEVEL, "   hr = 0x%x", pInfo->hr );
		Log(FYILOGLEVEL, "   Line Number = %u", pInfo->ulLineNumber );
		Log(FYILOGLEVEL, "   Char Position = %i", pInfo->ichCharPosition );
		Log(FYILOGLEVEL, "   Source file = %S", pInfo->wszSourceFile );
		Log(FYILOGLEVEL, "   Source component = %S", pInfo->wszSourceComponent );
		Log(FYILOGLEVEL, "   Description = %S", pInfo->wszDescription );
		Log(FYILOGLEVEL, "   Text = %S", pInfo->wszSourceLineText );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Performance8_StopEx.cpp ===
#include "globals.h"
#include "cicmusicx.h"

HRESULT Performance8_StopEx_1Segment(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwUnused2);


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Performance8_StopEx_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_StopEx_BVT())");
    DMTEST_EXECUTE(Performance8_StopEx_1Segment(ptPerf8, 0, 0));                    
    return hr;
};


/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Performance8_StopEx_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Performance8_StopEx_Valid())");


    return hr;
};



/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
HRESULT Performance8_StopEx_NoSegments(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    CHECKRUN(ptPerf8->StopEx(NULL, __int64(0), NULL));
    return hr;

};





/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_1Segment(CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwUnused2)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegmentState         *ptSegmentState = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName                    = NULL;
DWORD dwScenario                    = 0;

//Load media.
MEDIAFILEDESC MediaFileDesc[]=
{
{"SGT/test.sgt",              "T:\\DMTest1",          COPY_IF_NEWER},
{"DLS/Main1.DLS",             "T:\\DMTest1",          COPY_IF_NEWER},
{"WAV/Streaming10s.wav",      "T:\\WAV",    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));



if (!bWave)
{
    szFileName = "T:\\DMTest1\\test.sgt";
}
else
{
    szFileName = "T:\\WAV\\Streaming10s.wav";
}



    //Create the audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath));

    //Load up the media file.
    CHECKRUN(dmthLoadSegment(szFileName, &ptSegment8));

    for (dwScenario = 0; dwScenario<4; dwScenario++)
    {    
        //Play our segments.
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8,0,0,0,__int64(0),&ptSegmentState,0,ptPath));

        //Now both segments are playing.
       Log(FYILOGLEVEL, " Playing %s as segment.", szFileName);
       Log(FYILOGLEVEL, "Should hear music playing for 4 seconds.");
       Wait(4000);

        switch (dwScenario)
        {
            //StopEx(global)
            case 0:             
                CHECKRUN(ptPerf8->StopEx(NULL, __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(segment)
            case 1:             
                CHECKRUN(ptPerf8->StopEx(ptSegment8, __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptSegment8, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(SegmentState)
            case 2:             
                CHECKRUN(ptPerf8->StopEx(ptSegmentState, __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptSegmentState, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(AudioPath)
            case 3:             
                CHECKRUN(ptPerf8->StopEx(ptPath, __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptPath, NULL, NULL), all sound should stop for 2 seconds");
                break;
            
            default:
                Log(ABORTLOGLEVEL, "**** ABORT: TEST ERROR!!!!!!!");
                hr = E_FAIL;
                break;                
        };

        //Moment of silence.
        Wait(2000);

        //Stop everything anyway.
        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        Log(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop");
        Wait(1000);

        //Release the segstates we aquired.
        SAFE_RELEASE(ptSegmentState);

        if (FAILED(hr))
            break;

    }


    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegmentState);
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_1Segment_DLS(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_StopEx_1Segment(ptPerf8, FALSE, 0);
}

/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_1Segment_Wave(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Performance8_StopEx_1Segment(ptPerf8, TRUE, 0);
}




/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
HRESULT Performance8_StopEx_2Segments(CtIDirectMusicPerformance8* ptPerf8, DWORD bSinglePath, DWORD bSingleSegment, BOOL bWave)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath[2]          = {NULL};
CtIDirectMusicSegmentState          *ptSegmentState[2]  = {NULL};
CtIDirectMusicSegment8              *ptSegment8[2]      = {NULL};
CHAR *szFileName[2]               = {0};
DWORD dwSegment = 0;
DWORD dwPath = 0;
DWORD i = 0;
DWORD dwScenario = 0; 

//Load media.
MEDIAFILEDESC MediaFileDesc[]=
{
{"SGT/test.sgt",              "T:\\DMTest1",          COPY_IF_NEWER},
{"SGT/test2.sgt",             "T:\\DMTest1",          COPY_IF_NEWER},
{"DLS/Main1.DLS",             "T:\\DMTest1",          COPY_IF_NEWER},
{"WAV/Streaming10s.wav",      "T:\\WAV",    COPY_IF_NEWER},
{"WAV/GuitarStream1.wav",     "T:\\WAV",    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));




if (!bWave)
{
    szFileName[0] = "T:\\DMTest1\\Test.sgt";
    szFileName[1] = "T:\\DMTest1\\Test2.sgt";
}
else
{
    szFileName[0] = "T:\\WAV\\Streaming10s.wav";
    szFileName[1] = "T:\\WAV\\GuitarStream1.wav";
}


    Log(FYILOGLEVEL, "");
    Log(FYILOGLEVEL, "================= STOPEX TEST: %d AudioPath(s), %d Segment(s)", bSinglePath ? 1 : 2, bSingleSegment ? 1 : 2);
    Log(FYILOGLEVEL, "");

    //Create the audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath[0]));

    //Create another different audiopath if required.
    if (!bSinglePath)
    {
        CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                              32,
                                              TRUE,
                                              &ptPath[1]));

    }

    //Load up 1 or 2 segments.
    for (i=0; i<2 && SUCCEEDED(hr); i++)
    {
        if (bSingleSegment && i==1)
            break;

        //Load up media file.
        CHECKRUN(dmthLoadSegment(szFileName[i], &ptSegment8[i]));
    }


    //Download our stuff to audiopaths or single audiopath (depending on test parameters)
    for (i=0; i<2 && SUCCEEDED(hr); i++)
    {
        //Bail if we don't have 2 segments.
        if (bSingleSegment && i==1)
            break;

        //Download both segments to path one if there's only one path, otherwise download each seg to respective path.
        dwPath = i;
        if (bSinglePath)
            dwPath = 0;

    }

    for (dwScenario = 0; dwScenario<4 && SUCCEEDED(hr); dwScenario++)
    {    
        //Play our segments.
        Log(FYILOGLEVEL, "Playing Segments:");
        for (i=0; i<2 && SUCCEEDED(hr); i++)
        {

            dwPath = i;
            if (bSinglePath)
                dwPath = 0;

            dwSegment = i;
            if (bSingleSegment)
                dwSegment = 0;

            CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8[dwSegment],
                                        0,
                                        0,
                                        i ? DMUS_SEGF_SECONDARY : 0,
                                        __int64(0),
                                        &ptSegmentState[i],
                                        0,
                                        ptPath[dwPath]));

            Log(FYILOGLEVEL, " Playing %s as %s segment.", szFileName[dwSegment], i ? "secondary " : "primary ");
        }

        //Now both segments are playing.
        Log(FYILOGLEVEL, "Should hear music playing for 5 seconds.");
        Wait(5000);


        switch (dwScenario)
        {
            //StopEx(global)
            case 0:             
                CHECKRUN(ptPerf8->StopEx(NULL, __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 4 seconds");
                break;

            //StopEx(segment)
            case 1:             
                CHECKRUN(ptPerf8->StopEx(ptSegment8[0], __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptSegment8[0], NULL, NULL), %sSegment should Stop for 4 seconds.", bSingleSegment ? "" : "first ");
                break;

            //StopEx(SegmentState)
            case 2:             
                CHECKRUN(ptPerf8->StopEx(ptSegmentState[0], __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptSegmentState[0], NULL, NULL), SegmentState[0] should Stop for 4 seconds.");
                break;

            //StopEx(AudioPath)
            case 3:             
                CHECKRUN(ptPerf8->StopEx(ptPath[0], __int64(0), 0));
                Log(FYILOGLEVEL, "Calling StopEx(ptPath[0], NULL, NULL),%s should Stop for 4 seconds.", bSinglePath ? "All Music" : "Segment on Path 1");
                break;
            
            default:
                Log(ABORTLOGLEVEL, "**** ABORT: TEST ERROR!!!!!!!");
                hr = E_FAIL;
                break;                
        };

        //Moment of silence.
        Wait(4000);

        //Stop everything anyway.
        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        Log(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop");
        Wait(1000);

        //Release the segstates we aquired.
        for (i=0; i<2; i++)
        {
            SAFE_RELEASE(ptSegmentState[i]);
        }

    }

    //Release all items that might have been allocated.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment8[i]);
        SAFE_RELEASE(ptPath[i]);
        SAFE_RELEASE(ptSegmentState[i]);
    }

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_2Segments_DLS(CtIDirectMusicPerformance8* ptPerf8, DWORD bSinglePath, DWORD bSingleSegment)
{
    return Performance8_StopEx_2Segments(ptPerf8, bSinglePath, bSingleSegment, FALSE);
}


/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_2Segments_Wave(CtIDirectMusicPerformance8* ptPerf8, DWORD bSinglePath, DWORD bSingleSegment)
{
    return Performance8_StopEx_2Segments(ptPerf8, bSinglePath, bSingleSegment, TRUE);
}




/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_TimeFuture(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    CICMusic    Music;
    CHAR *szSegment = "T:\\DMTest1\\Perf8\\StopEx\\16Notes.sgt";
    REFERENCE_TIME rt = 0;
    MUSIC_TIME mt = 0;

    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"SGT/16Notes.sgt",           "T:\\DMTest1\\Perf8\\StopEx\\",          COPY_IF_NEWER},
    {"DLS/Main1.DLS",             "T:\\DMTest1\\Perf8\\StopEx\\",          COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //Load up and play the media.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));

    //Get the time.
    CHECKRUN(ptPerf8->GetTime(&rt, &mt));

    Log(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
    mt += DMUS_PPQ * 8;
    hr = ptPerf8->StopEx(0,__int64(mt),0);
    Log(FYILOGLEVEL, "Stopping in 8 quarter-notes, or at mt = %08X.", mt);
    Log(FYILOGLEVEL, "You should hear music stop in 8 quarter notes.");

    //Check the result of StopEx.
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL, "StopEx failed");
        goto TEST_END;
    }

    //Wait 6 seconds.
    Wait(6000);

    Log(FYILOGLEVEL, "Music should be stopped now.  Waiting 5 more second.");
    Wait(5000);


    CHECKRUN(Music.Shutdown());


TEST_END:
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Performance8_StopEx_TimePast(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CHAR *szSegment = "T:\\DMTest1\\Perf8\\StopEx\\16Notes.sgt";
    REFERENCE_TIME rt = __int64(0);
    MUSIC_TIME mt = 0;

    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"SGT/16Notes.sgt",           "T:\\DMTest1\\Perf8\\StopEx\\",          COPY_IF_NEWER},
    {"DLS/Main1.DLS",             "T:\\DMTest1\\Perf8\\StopEx\\",          COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));

    //Load up and play the media.
    CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
    Log(FYILOGLEVEL, "Playing for 2 seconds.");
    Wait(2000);

    //Get the time.
    CHECKRUN(ptPerf8->GetTime(&rt, &mt));
    Log(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
    mt -= DMUS_PPQ * 8;
    hr = ptPerf8->StopEx(0, __int64(mt), 0);
    Log(FYILOGLEVEL, "Stopping 8 quarter-notes ago, or at mt = %08X.", mt);
    Log(FYILOGLEVEL, "You should hear music stop immediately");

    //Check the results of StopEx.
    if (S_OK != hr)
    {
        Log(ABORTLOGLEVEL, "StopEx failed");
        goto TEST_END;
    }

    Wait(4000);
    CHECKRUN(Music.Shutdown());


TEST_END:
    return  hr;
};


/********************************************************************************
Call this test while DoWork ISN'T being called.
********************************************************************************/
HRESULT Performance8_StopEx_NoDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    CICMusic    Music;
    CHAR *szSegmentServer = "WAV/GuitarLoop.wav";
    DWORD i;
    DWORD dwStartTime = 0;
    CtIDirectMusicSegment *ptSegment = NULL;


    //Load teh media.
    CHECKRUN(MediaCopyFile(szSegmentServer));

    //Call DoWork
    DirectMusicDoWork(100);
    
    //Load up and play the media.
    CHECKRUN(Music.Init(ptPerf8, MediaServerToLocal(szSegmentServer), DMUS_APATH_SHARED_STEREOPLUSREVERB));

    //Wait a second.
    Log(FYILOGLEVEL, "Will stop sound in 1 second...");
    dwStartTime= timeGetTime();
    do
    {
        DirectMusicDoWork(50);            
        Sleep(50);
    }
    while (timeGetTime() - dwStartTime < 1000);

    //Call StopEx, but don't call DoWork.
    Log(FYILOGLEVEL, "Sound should stop NOW!!!");
    CHECK(ptPerf8->StopEx(ptSegment, 0, 0));
    Wait(2000);

    //After 2 seconds, call DoWork()
    Log(FYILOGLEVEL, "Calling DirectMusicDoWork()");
    CHECK(DirectMusicDoWork(2000));

    //Wait 2 seconds.
    Wait(2000);

    CHECKRUN(Music.Shutdown());

    RELEASE(ptSegment);
    return hr;
};




//TODO:!!!!
/********************************************************************************
********************************************************************************/
/* 
HRESULT Performance8_StopEx_BoundaryFlags(TESTPARAMS)
{
    HRESULT hr                                              = S_OK;
    CICMusic    Music;
    CHAR *szSegment = "T:\\DMTest1\\Perf8\\StopEx\\Boundary.sgt';
    REFERENCE_TIME rt;
    MUSIC_TIME mt;


    for (i=0; i<2 && SUCCEEDED(hr); i++)
    {

        //Load up and play the media.
        CHECKRUN(Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB));
        Log(FYILOGLEVEL, "Playing for a second.");
        Wait(1000);

        //Get the time.
        CHECKRUN(ptPerf8->GetTime(&rt, &mt));
        if (i==0)
        {
            Log(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", rt >> 32, rt & 0xFFFFFFFF);
            rt -= 50000000;
            Log(FYILOGLEVEL, "Stopping 5 seconds ago, or at %08X%08X.", rt >> 32, rt & 0xFFFFFFFF);
            Log(FYILOGLEVEL, "You should hear music stop immediately.");
        }
        else
        {
            Log(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
            mt -= DMUS_PPQ * 8;
            Log(FYILOGLEVEL, "Stopping 8 quarter-notes ago, or at mt = %08X.", mt);
            Log(FYILOGLEVEL, "You should hear music stop immediately");


        }

        //Run our test.
        CHECKRUN(ptPerf8->StopEx(0,
                             i==0 ? rt : mt,
                             i==0 ? DMUS_SEGF_REFTIME : 0))
        Log(FYILOGLEVEL, "Music should be stopped.  Waiting 1 second.");
        Wait(1000);


        CHECKRUN(Music.Shutdown());
    }


TEST_END:
    return  hr
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_GetSetVariableString.cpp ===
/********************************************************************************
	FILE:
		Script_GetSetVariableString.cpp

	PURPOSE:
		GetVariableString and SetVariableString tests for scripts

	BY:
		DANHAFF
********************************************************************************/

#include "globals.h"
#include "script.h"


/********************************************************************************
********************************************************************************/
HRESULT Script_SetVariableString_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;	
    HRESULT hrCallRoutine = S_OK;
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;
    CHAR szString[255] = {0};
    LPSTR szScriptServer = "DMusic/DMTest1/Script/GetSetVariableString/GetSetVariableString.spt";
    CHECKRUN(MediaCopyFile(szScriptServer));
    

    CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
    CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
    CHECKRUN( InsertToolTrace(ptPerf8));
    
    //Init loader
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );

    //Load/Init our script
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, MediaServerToLocal(szScriptServer), (void **)&ptScript));
    CHECKRUN(ptScript->Init( ptPerf8, NULL));
    CHECKRUN(ptScript->CallRoutine("InitializeBeforeTest", NULL));

    //Call the routine we're supposed to.
    CHECKRUN(ptScript->CallRoutine("InitializeBeforeTest", NULL));
    CHECKRUN(ptScript->SetVariableString("ScriptString", "", NULL));
    CHECKRUN(ptScript->CallRoutine("Receive_01_Nothing", NULL));

    CHECKRUN(ptScript->CallRoutine("InitializeBeforeTest", NULL));
    CHECKRUN(ptScript->SetVariableString("ScriptString", "a", NULL));
    CHECKRUN(ptScript->CallRoutine("Receive_02_OneLetter", NULL));
 
    CHECKRUN(ptScript->CallRoutine("InitializeBeforeTest", NULL));
    CHECKRUN(ptScript->SetVariableString("ScriptString", "LongString0010_6789_0020_6789_0030_6789_0040_6789_0050_6789_0060_6789_0070_6789_0080_6789_0090_6789_0100_6789_0110_6789_0120_6789_0130_6789_0140_6789_0150_6789_0160_6789_0170_6789_0180_6789_0190_6789_0200_6789_0210_6789_0220_6789_0230_6789_0240_6789_0250_", NULL));
    CHECKRUN(ptScript->CallRoutine("Receive_03_LongString", NULL));

    for (int i=0; i<255; i++)
        szString[i] = i+1;
    CHECKRUN(ptScript->SetVariableString("ScriptString", szString, NULL));
    CHECKRUN(ptScript->CallRoutine("Receive_04_AllCharacters", NULL));
  

    Log(ABORTLOGLEVEL, "Check the output to make sure everything was printed okay");
    Wait(4000);  
  
        
    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Script_GetVariableString_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;	
    HRESULT hrCallRoutine = S_OK;
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;
    CHAR szString[256] = {0};
    CHAR *szScriptServer = "DMusic/DMTest1/Script/GetSetVariableString/GetSetVariableString2.spt";
    CHAR *szStrings     [4] = {"", "a", "0000_6789^0010_6789^0020_6789^0030_6789^0040_6789^0050_6789^0060_6789^0070_6789^0080_6789^0090_6789^0100_6789^0110_6789^0120_6789^0130_6789^0140_6789^0150_6789^0160_6789^0170_6789^0180_6789^0190_6789^0200_6789^0210_6789^0220_6789^0230_6789^0240_6789^0250^", "Do you like movies about gladiators?"};
    CHAR *szRoutineNames[4] = {"Send_01_Nothing", "Send_02_OneLetter", "Send_03_LongString", "Send_04_LongStringName"};
    CHAR *szVarNames    [4] = {"ScriptString", "ScriptString", "ScriptString", "LongStringName_6789_0020_6789_0030_6789_0040_6789_0050_6789_0060_6789_0070_6789_0080_6789_0090_6789_0100_6789_0110_6789_0120_6789_0130_6789_0140_6789_0150_6789_0160_6789_0170_6789_0180_6789_0190_6789_0200_6789_0210_6789_0220_6789_0230_6789_0240_6789_0250_"};
    DWORD i=0;



    LONG lConverted = 0;
    BOOL bPassing = TRUE;

    CHECKRUN(MediaCopyDirectory(szScriptServer));
    CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
    CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
    CHECKRUN( InsertToolTrace(ptPerf8));
    
    //Init loader
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );

    //Load/Init our script
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, (CHAR *)MediaServerToLocal(szScriptServer), (void **)&ptScript));
    CHECKRUN(ptScript->Init( ptPerf8, NULL));

    //Go through these three tests.    
    for (i=1; i<4 && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ptScript->CallRoutine("InitializeBeforeTest", NULL));
    
        //Call the routine we're supposed to.
        CHECKRUN(ptScript->CallRoutine(szRoutineNames[i], NULL));
        CHECKRUN(ptScript->GetVariableString(szVarNames[i], szString, 256, &lConverted, NULL));
        if (strcmp(szString, szStrings[i]))
        {
            bPassing = FALSE;
            Log(ABORTLOGLEVEL, "Error (iteration %d): GetVariableString returned [%s] instead of [%s]", i, szString, szStrings[i]);
        }
        if (lConverted != strlen(szStrings[i]) + 1)
        {
            bPassing = FALSE;
            Log(ABORTLOGLEVEL, "Error (iteration %d): GetVariableString returned length of %d instead of %d", i, strlen(szString), strlen(szStrings[i]));
        }
    }

    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_CallRoutine_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_CallRoutine_Invalid.cpp

	PURPOSE:
		CallRoutine invalid/fatal tests for script

	BY:
		DANHAFF
********************************************************************************/

#include "globals.h"

HRESULT Script_CallRoutine( LPSTR szRoutine, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );


HRESULT Script_CallRoutine_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;
	DMUS_SCRIPT_ERRORINFO dmScriptError;

    DMTEST_EXECUTE( Script_CallRoutine( NULL, ptPerf8, NULL ) );
    DMTEST_EXECUTE( Script_CallRoutine( NULL, ptPerf8, &dmScriptError ) );
    
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Invalid_NoAudioPath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD dwUnused)
{
	HRESULT hr = S_OK;	
    DMUS_SCRIPT_ERRORINFO dmScriptError = {0};
    CHAR *szBasePathServer = "DMusic/DMTest1/Script/Play01/";
    CHAR  szBasePath[MAX_PATH] = {0};
    CHAR  szScriptName[MAX_PATH] = {0};
    CHAR  szRoutineName[MAX_PATH] = {0};
    DWORD dwRangeBottom = 0;
    LONG lRoutineCall = 0;
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicScript *ptScriptGlobals   = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;

    //Get all the media in that directory.
    CHECKRUN(MediaCopyDirectory(szBasePathServer));
    strcpy(szBasePath, MediaServerToLocal(szBasePathServer));

    //Get MAIN1.dls
    {
    CHAR  szBaseDir [MAX_PATH] = {0};
    CHECKRUN(ChopPath(szBasePath, szBaseDir, NULL));
    CHECKRUN(MediaCopyFile("DLS/Main1.DLS", szBaseDir));
    }

    dwRangeBottom = (dwRoutineNumber / 10) * 10;
    CHECK(sprintf(szScriptName, "Routines%03d-%03d.spt", dwRangeBottom, dwRangeBottom + 9));
    CHECK(Log(FYILOGLEVEL, "Script: %s", szScriptName));
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );
    CHECKRUN( ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szBasePath, TRUE));
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, "Globals.spt", (void **)&ptScriptGlobals));
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScriptName, (void **)&ptScript));
    CHECKALLOC(ptScript);
    CHECKRUN( ptScript->Init( ptPerf8, &dmScriptError));
    CHECK(dmthVerifyScriptError( &dmScriptError ));

    //Concatenate the RoutineName together.
    CHECK(sprintf(szRoutineName, "Routine%03dc%1d", dwRoutineNumber, lRoutineCall));  //i.e. for dwRoutineNumber = 100, dwRoutineCall=3, makes "Routine100c3"
    CHECK(Log(FYILOGLEVEL, "RoutineName: %s", szRoutineName));

    //Call the routine we're supposed to.  If it doesn't exist, the script is messed up.
    CHECKRUN(ptScript->CallRoutine(szRoutineName, &dmScriptError));
    if (SUCCEEDED(hr))
    {
        if (hr != DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
        {
            Log(ABORTLOGLEVEL, "Error: CallRoutine returned %s (%08X) instead of DMUS_E_SCRIPT_ERROR_IN_SCRIPT", tdmXlatHRESULT(hr), hr);
            hr = E_FAIL;
        }
        else
        {
            Log(ABORTLOGLEVEL, "Error: CallRoutine returned DMUS_E_SCRIPT_ERROR_IN_SCRIPT as expected");
            hr = S_OK;
        }
    }

    SAFE_RELEASE(ptScriptGlobals);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_CallRoutine.cpp ===
/********************************************************************************
	FILE:
		Script_CallRoutine.cpp

	PURPOSE:
		CallRoutine tests for script

	BY:
		DANROSE
********************************************************************************/

#include "globals.h"
#include "script.h"

HRESULT Script_CallRoutine_PerfMem1_Real( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptName, DWORD dwRoutineIndex, BOOL bFull);

 
HRESULT Script_CallRoutine( LPSTR szRoutine, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( CALLROUTINE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( szRoutine, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_CallRoutine_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

	DMTEST_EXECUTE( Script_CallRoutine( ROUTINE_GOOD, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_CallRoutine( ROUTINE_GOOD, ptPerf8, &dmScriptError ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_EMPTY, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ROUTINE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_NO_EXIST, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ROUTINE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_RUNTIME_ERROR, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ERROR_IN_SCRIPT ) );

	return hr;
}
                                                      

HRESULT Script_CallRoutine_PerfMem1_Partial( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptName, DWORD dwRoutineIndex)
{
    return Script_CallRoutine_PerfMem1_Real(ptPerf8, dwScriptName, dwRoutineIndex, FALSE);
};


HRESULT Script_CallRoutine_PerfMem1_Full( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptName, DWORD dwRoutineIndex)
{
    return Script_CallRoutine_PerfMem1_Real(ptPerf8, dwScriptName, dwRoutineIndex, TRUE);
};


HRESULT Script_CallRoutine_PerfMem1_Real( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptNameServer, DWORD dwRoutineIndex, BOOL bFull)
{
	HRESULT hr = S_OK;	
    DWORD dwLoads = 0;
    CHAR szRoutineName[1000] = {NULL};
    CHAR *szScriptNameServer = (CHAR *)dwScriptNameServer;
    CHAR szScriptName[MAX_PATH] = {0};
	CtIDirectMusicScript* ptScript = NULL;
	CtIDirectMusicLoader8* ptLoader = NULL;
    DWORD dwStartTime = 0, dwTimePassed = 0, dwCounter = 0;
    sprintf(szRoutineName, "Routine%02d", dwRoutineIndex);
    CtIDirectMusicAudioPath *ptPath = NULL;

    CHECKRUN(MediaCopyDirectory(szScriptNameServer));
    strcpy(szScriptName, MediaServerToLocal(szScriptNameServer));

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, TRUE, &ptPath));
    CHECKRUN(ptPerf8->SetDefaultAudioPath(ptPath));

    if (!bFull)
    {
	    CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &ptLoader ) );
	    CHECKRUN( dmthCreateScript(szScriptName, ptLoader, &ptScript ) );
	    CHECKALLOC( ptScript );
	    CHECKRUN( ptScript->Init( ptPerf8, NULL) );
    }


    CHECKRUN(Log(FYILOGLEVEL, "Calling %s's %s", PathFindFileName(szScriptName), szRoutineName));
    dwStartTime = timeGetTime();
    do
    {
        dwLoads++;
        if (bFull)
        {
	        CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &ptLoader ) );
	        CHECKRUN( dmthCreateScript(szScriptName, ptLoader, &ptScript ) );
	        CHECKALLOC( ptScript );
	        CHECKRUN( ptScript->Init( ptPerf8, NULL) );
        }

        CHECKRUN(ptScript->CallRoutine(szRoutineName, NULL));
        if (FAILED(hr))
            Log(ABORTLOGLEVEL, "Attempt #%u to call %s's %s FAILED!!!!", dwLoads, szScriptName, szRoutineName);

        if (bFull)
        {
            SAFE_RELEASE(ptScript);
            SAFE_RELEASE(ptLoader);
        }

        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }

    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));

    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    return hr;
};






/********************************************************************************
This separates out the init code so it can be easily called from either inside
or outside the main loop based on a flag.
********************************************************************************/
HRESULT Script_CallRoutine_PerfMem_TestScript_Init(
CtIDirectMusicPerformance*(&ptPerf8),
CtIDirectMusicScript*(&ptScript),
CtIDirectMusicScript*(&ptScriptGlobals),
CtIDirectMusicLoader*(&ptLoader),
CtIDirectMusicAudioPath*(&ptPath),
LPSTR szBasePath,
LPSTR szScriptName
)
{
HRESULT hr = S_OK;


//Init performance
CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
CHECKRUN( InsertToolTrace(ptPerf8));

//Init loader
CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );
CHECKRUN( ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szBasePath, TRUE));

//Load/Init ScriptGlobals
CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, "Globals.spt", (void **)&ptScriptGlobals));
CHECKRUN(ptScriptGlobals->Init( ptPerf8, NULL));

//Load/Init our script
CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScriptName, (void **)&ptScript));
CHECKRUN(ptScript->Init( ptPerf8, NULL));

return hr;

}

/********************************************************************************
This separates out the cleanup code so it can be easily called from either inside
or outside the main loop based on a flag.
********************************************************************************/
HRESULT Script_CallRoutine_PerfMem_TestScript_Cleanup(
CtIDirectMusicPerformance*(&ptPerf8),
CtIDirectMusicScript*(&ptScript),
CtIDirectMusicScript*(&ptScriptGlobals),
CtIDirectMusicLoader*(&ptLoader),
CtIDirectMusicAudioPath*(&ptPath)
)
{
    //Clean up.
    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptScriptGlobals);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    SAFE_RELEASE(ptPath);
    return S_OK;
}



/********************************************************************************
The only difference between these two functions is that they reference content
in different directories.  They both call Script_CallRoutine_Valid_RunScripts
********************************************************************************/
HRESULT Script_CallRoutine_PerfMem_TestScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD bFull)
{
	HRESULT hr = S_OK;	
    CHAR  szScriptName[MAX_PATH] = {0};
    CHAR  szRoutineName[MAX_PATH] = {0};
    DWORD dwRangeBottom = 0;
    LONG lRoutineCall = 0;
    LONG lNumRoutines = 0;
    LONG lNextRoutineDelay = 0;
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicScript *ptScriptGlobals   = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;
    LPSTR szBasePath = "T:\\DMTest1\\Script\\Play01\\";

    //We need everything from this directory, AND main1.dls
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/Play01/"));
    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS", szBasePath, COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //Determine the name of the script (stays the same for the whole function)
    memset((void *)szScriptName, 0, MAX_PATH);
    dwRangeBottom = 0;
    dwRangeBottom = (dwRoutineNumber / 10) * 10;
    CHECK(sprintf(szScriptName, "Routines%03d-%03d.spt", dwRangeBottom, dwRangeBottom + 9));
    CHECK(Log(FYILOGLEVEL, "Script: %s", szScriptName));

    //If we're testing the full load/free scenario, then do this inside the loop.  Otherwise do it here.
    if (!bFull)
        CHECKRUN(Script_CallRoutine_PerfMem_TestScript_Init(ptPerf8, ptScript, ptScriptGlobals, ptLoader, ptPath, szBasePath, szScriptName));

    dwStartTime = timeGetTime();
    do
    {
        //Rethink initialization of variables here. *routinecall, etc)
        lRoutineCall = 0;
        lNumRoutines = 0;

        //If we're fully creating everything every time, then do this inside the loop.
        if (bFull)
            CHECKRUN(Script_CallRoutine_PerfMem_TestScript_Init(ptPerf8, ptScript, ptScriptGlobals, ptLoader, ptPath, szBasePath, szScriptName));

        //Call all the routines.
        do
        {        
            //Reset this since it's set every loop.
            lNextRoutineDelay = 0;

            //Concatenate the RoutineName together.
            memset((void *)szRoutineName, 0, MAX_PATH);
            CHECK(sprintf(szRoutineName, "Routine%03dc%1d", dwRoutineNumber, lRoutineCall));  //i.e. for dwRoutineNumber = 100, dwRoutineCall=3, makes "Routine100c3"
            CHECK(Log(FYILOGLEVEL, "RoutineName: %s", szRoutineName));

            //Call the routine we're supposed to.  If it doesn't exist, the script is messed up.
            CHECK(hr = ptScript->CallRoutine(szRoutineName, NULL));
        
            //Grab the number of routines.
            if (0 == lRoutineCall)
            {
                CHECKRUN(ptScriptGlobals->GetVariableNumber("NumRoutines", &lNumRoutines, NULL));
            }

            CHECKRUN(ptScriptGlobals->GetVariableNumber("NextRoutineDelay", &lNextRoutineDelay, NULL));
            //Don't wait!!
            CHECK(lRoutineCall++);
        }
        while (lRoutineCall < lNumRoutines && SUCCEEDED(hr));

        if (bFull)
            Script_CallRoutine_PerfMem_TestScript_Cleanup(ptPerf8, ptScript, ptScriptGlobals, ptLoader, ptPath);

        //Record the time.
        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));


    //Cleanup time!!!
    if (!bFull)
        Script_CallRoutine_PerfMem_TestScript_Cleanup(ptPerf8, ptScript, ptScriptGlobals, ptLoader, ptPath);

    return hr;
};



//these would normally be local, but we're having problems with stack size.
static CHAR  szScriptName[MAX_PATH] = {0};
static CHAR  szRoutineName[MAX_PATH] = {0};


/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_RunScripts(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected, LPSTR szBasePathServer)
{
	HRESULT hr = S_OK;	
    HRESULT hrCallRoutine = S_OK;
    DWORD dwRangeBottom = 0;
    LONG lRoutineCall = 0;
    LONG lNumRoutines = 0;
    LONG lTestResult = FALSE; //FALSE = FAIL, TRUE = SUCCESS.
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicScript *ptScriptGlobals   = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;
    CHAR szBasePath[MAX_PATH]  = {0};

    strcpy(szBasePath, MediaServerToLocal(szBasePathServer));

    //Copy everything from the base path.
    CHECKRUN(MediaCopyDirectory(szBasePathServer));
    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS",                           szBasePath, COPY_IF_NEWER},
    {"DLS/SonicImplants Live Band.dls",         szBasePath, COPY_IF_NEWER},
    {"DLS/SonicImplants Orchestral.dls",        szBasePath, COPY_IF_NEWER},
    {"DLS/SonicImplants SFX.dls",        szBasePath, COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));


    //For processing
    LONG  lNextRoutineDelay = 0;
 
    dwRangeBottom = (dwRoutineNumber / 10) * 10;
    CHECK(sprintf(szScriptName, "Routines%03d-%03d.spt", dwRangeBottom, dwRangeBottom + 9));
    CHECK(Log(FYILOGLEVEL, "Script: %s", szScriptName));
  
    //Init performance
    CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
    CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
    CHECKRUN( InsertToolTrace(ptPerf8));
    
    //Init loader
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );
    CHECKRUN( ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szBasePath, TRUE));

    //Load/Init ScriptGlobals
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, "Globals.spt", (void **)&ptScriptGlobals));
    CHECKRUN(ptScriptGlobals->Init( ptPerf8, NULL));

    //Load/Init our script
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScriptName, (void **)&ptScript));
    CHECKRUN(ptScript->Init( ptPerf8, NULL));
    do
    {        
        //Concatenate the RoutineName together.
        CHECK(sprintf(szRoutineName, "Routine%03dc%1d", dwRoutineNumber, lRoutineCall));  //i.e. for dwRoutineNumber = 100, dwRoutineCall=3, makes "Routine100c3"
        CHECK(Log(FYILOGLEVEL, "RoutineName: %s", szRoutineName));

        //Call the routine we're supposed to.  If it doesn't exist, the script is messed up.
        CHECK(hrCallRoutine = ptScript->CallRoutine(szRoutineName, NULL));
        
        //If we didn't get the expected HRESULT then set the test's hr correctly.
        if (SUCCEEDED(hr))
        {
            if (hrCallRoutine != hrExpected)
            {
                Log(ABORTLOGLEVEL, "CallRoutine(%s) returned %s (%08X) instead of %s (%08X)", szRoutineName, tdmXlatHRESULT(hrCallRoutine), hrCallRoutine, tdmXlatHRESULT(hrExpected), hrExpected);
                if (S_OK == hrExpected)
                    hr = hrCallRoutine;
                else
                    hr = E_FAIL;
            }
        }

        if (0 == lRoutineCall)
        {
            CHECKRUN(ptScriptGlobals->GetVariableNumber("NumRoutines", &lNumRoutines, NULL));
        }

        CHECKRUN(ptScriptGlobals->GetVariableNumber("NextRoutineDelay", &lNextRoutineDelay, NULL));
        CHECK(lRoutineCall++);
        
        //Skip this if we're just finishing up the last segment.
        if (lRoutineCall != lNumRoutines)
            CHECKRUN(Wait(lNextRoutineDelay));        
    }
    while (lRoutineCall < lNumRoutines && SUCCEEDED(hr) && SUCCEEDED(hrExpected));

    CHECKRUN(ptScriptGlobals->GetVariableNumber("TestResult", &lTestResult, NULL));
    if (lTestResult != 1 && SUCCEEDED(hr) && SUCCEEDED(hrCallRoutine))
    {
        CHECK(Log(ABORTLOGLEVEL, "According to %s's last test routine %s, the test failed.", szScriptName, szRoutineName));
        CHECK(hr = E_FAIL);
    }


    //Stop everything.
    ptPerf8->StopEx(0, 0, 0);

    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptScriptGlobals);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    SAFE_RELEASE(ptPath);
    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_TestScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected)
{
    return Script_CallRoutine_Valid_RunScripts(ptPerf8, dwRoutineNumber, hrExpected, "DMusic/DMTest1/Script/Play01/");
}


/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_TestScript_Transition(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected)
{
    return Script_CallRoutine_Valid_RunScripts(ptPerf8, dwRoutineNumber, hrExpected, "DMusic/DMTest1/Script/Play02Trans/");
}


/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_TestScript_TransSimple(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected)
{
    return Script_CallRoutine_Valid_RunScripts(ptPerf8, dwRoutineNumber, hrExpected, "DMusic/DMTest1/Script/Play02TransSimple/");
}

/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_TestScript_SegBoundaries(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected)
{
    return Script_CallRoutine_Valid_RunScripts(ptPerf8, dwRoutineNumber, hrExpected, "DMusic/DMTest1/Script/Play03SegBoundaries/");
}

/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Invalid_TestScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected)
{
    return Script_CallRoutine_Valid_RunScripts(ptPerf8, dwRoutineNumber, hrExpected, "DMusic/DMTest1/Script/Inv_EmbeddedContentMissing/");
}





/********************************************************************************
********************************************************************************/
HRESULT Script_CallRoutine_Valid_PlayOneScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwScriptServer, DWORD dwRoutine)
{
	HRESULT hr = S_OK;	
    HRESULT a = S_OK;
    DWORD dwRangeBottom = 0;
    LONG lRoutineCall = 0;
    LONG lNumRoutines = 0;
    LONG lTestResult = FALSE; //FALSE = FAIL, TRUE = SUCCESS.
    CtIDirectMusicScript *ptScript          = NULL;
    CtIDirectMusicLoader *ptLoader          = NULL;
    CtIDirectMusicAudioPath *ptPath         = NULL;
    LPSTR szScriptServer = (LPSTR)dwScriptServer;
    CHAR szScript[MAX_PATH] = {0};
    CHAR szDirectory[MAX_PATH] = {0};
    LPSTR szRoutine = (LPSTR)dwRoutine;

    strcpy(szScript, MediaServerToLocal(szScriptServer));
    CHECKRUN(ChopPath(szScript, szDirectory, NULL));

    //Copy everything from the base path.
    CHECKRUN(MediaCopyDirectory(szScriptServer));
    //Load media.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS", szDirectory, COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));

    //For processing
    LONG  lNextRoutineDelay = 0;
 
    //Init performance
    CHECKRUN( ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &ptPath));
    CHECKRUN( ptPerf8->SetDefaultAudioPath(ptPath));
    CHECKRUN( InsertToolTrace(ptPerf8));
    
    //Init loader
    CHECKRUN( dmthCreateLoader( CTIID_IDirectMusicLoader8, &ptLoader ) );
//    CHECKRUN( ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szBasePath, TRUE));

    //Load/Init our script
    CHECKRUN( ptLoader->LoadObjectFromFile(CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScript, (void **)&ptScript));
    CHECKRUN(ptScript->Init( ptPerf8, NULL));

    //Call the routine we're supposed to.  If it doesn't exist, the script is messed up.
    //CHECK(hrCallRoutine = ptScript->CallRoutine(szRoutine, NULL));
    CHECKRUN(ptScript->CallRoutine(szRoutine, NULL));

    Wait(5000);
        

    //Stop everything.
    ptPerf8->StopEx(0, 0, 0);

    RemoveToolTrace(ptPerf8);
    ptPerf8->SetDefaultAudioPath(NULL);
    SAFE_RELEASE(ptScript);
    SAFE_RELEASE(ptLoader);
    SAFE_RELEASE(ptPath);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_GetVariableNumber_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableNumber_Invalid.cpp

	PURPOSE:
		GetVariableNumber invalid/fatal tests for script

	BY:
		DANHAFF
********************************************************************************/

#include "globals.h"
#include "script.h"
 
HRESULT Script_GetVariableNumber( LPSTR szVariableName, LONG* plValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );

HRESULT Script_GetVariableNumber_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;
	DMUS_SCRIPT_ERRORINFO dmScriptError;
	LONG lValue = 0;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));

	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, &lValue, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, &lValue, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NUMBER_GOOD, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NUMBER_GOOD, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
    
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_GetVariableObject.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableObject.cpp

	PURPOSE:
		GetVariableObject tests for script

	BY:
		DANROSE
********************************************************************************/
#include "globals.h"
#include "script.h"


 
HRESULT Script_GetVariableObject( LPSTR szVariableName, REFIID riid, LPVOID* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );

	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableObject( szVariableName, riid, ppv, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( NULL != *((IDirectMusicSegment**)ppv) ? S_OK : E_FAIL );
	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_GetVariableObject_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	IDirectMusicSegmentState8* pSeg = NULL;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));	

	DMTEST_EXECUTE( Script_GetVariableObject( SEGMENT_GOOD, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, NULL ) );
	SAFE_RELEASE( pSeg );
	DMTEST_EXECUTE( Script_GetVariableObject( SEGMENT_GOOD, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ) );
	SAFE_RELEASE( pSeg );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( VARIABLE_EMPTY, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	SAFE_RELEASE( pSeg );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( VARIABLE_NO_EXIST, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	SAFE_RELEASE( pSeg );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_GetVariableObject_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableObject_Invalid.cpp

	PURPOSE:
		GetVariableObject invalid/fatal tests

	BY:
		DANHAFF
********************************************************************************/
#include "globals.h"
#include "script.h"

HRESULT Script_GetVariableObject( LPSTR szVariableName, REFIID riid, LPVOID* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );


HRESULT Script_GetVariableObject_Invalid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
    LPVOID pVoid = NULL;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));

	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, GUID_NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, GUID_NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, IID_IDirectMusicSegment, &pVoid, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, IID_IDirectMusicSegment, &pVoid, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( SEGMENT_GOOD, GUID_NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( SEGMENT_GOOD, GUID_NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );

    return hr;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_GetVariableNumber.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableNumber.cpp

	PURPOSE:
		GetVariableNumber tests for script

	BY:
		DANROSE
********************************************************************************/
#include "globals.h" 
#include "script.h"
 
HRESULT Script_GetVariableNumber( LPSTR szVariableName, LONG* plValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableNumber( szVariableName, plValue, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( NUMBER_VALUE == *plValue ? S_OK : E_FAIL );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_GetVariableNumber_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	LONG lValue = 0;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));
	
	DMTEST_EXECUTE( Script_GetVariableNumber( NUMBER_GOOD, &lValue, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_GetVariableNumber( NUMBER_GOOD, &lValue, ptPerf8, &dmScriptError ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( VARIABLE_EMPTY, &lValue, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( VARIABLE_NO_EXIST, &lValue, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_Init_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_Init_Invalid.cpp

	PURPOSE:
		Init invalid/fatal tests for script

	BY:
		DANHAFF
********************************************************************************/
#include "globals.h"
#include "script.h"

HRESULT Script_Init( LPSTR szScript, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );

HRESULT Script_Init_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;
    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));

	DMUS_SCRIPT_ERRORINFO dmScriptError;


	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, NULL ), E_POINTER ) );
    DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, &dmScriptError ), E_POINTER ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_Init.cpp ===
/********************************************************************************
	FILE:
		Script_Init.cpp

	PURPOSE:
		Init tests for script

	BY:
		DANROSE
********************************************************************************/
#include "globals.h"
#include "script.h"

HRESULT Script_Init( LPSTR szScript, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( szScript, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_Init_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));

//	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, NULL ), E_POINTER ) );
//	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_NOEXIST, ptPerf8, &dmScriptError ), E_OUTOFMEMORY ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_BAD, ptPerf8, &dmScriptError ), E_OUTOFMEMORY ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_SYNTAX, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ERROR_IN_SCRIPT ) );

	DMTEST_EXECUTE( Script_Init( INIT_SCRIPT, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_Init( INIT_SCRIPT, ptPerf8, &dmScriptError ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_SetVariableNumber_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableNumber_Invalid.cpp

	PURPOSE:
		SetVariableNumber invalid/fatal tests for script

	BY:
		DANHAFF
********************************************************************************/
#include "globals.h"
#include "script.h"

HRESULT Script_SetVariableNumber( LPSTR szVariableName, LONG lValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );

 
HRESULT Script_SetVariableNumber_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));
	
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, &dmScriptError ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_EMPTY, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_NO_EXIST, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_AddNotificationType.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "Performance8_AddNotificationType.hpp"

/********************************************************************************
********************************************************************************/
HRESULT Segment8_AddNotificationType_NoRestart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes)
{
    return Template_AddRemoveNotifications<CtIDirectMusicSegment8>(ptPerf8, dwAddNotificationTypes, dwRemNotificationTypes, 0);
}

/********************************************************************************
********************************************************************************/
HRESULT Segment8_AddNotificationType_Restart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes)
{
    return Template_AddRemoveNotifications<CtIDirectMusicSegment8>(ptPerf8, dwAddNotificationTypes, dwRemNotificationTypes, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_SetVariableNumber.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableNumber.cpp

	PURPOSE:
		SetVariableNumber tests for script

	BY:
		DANROSE
********************************************************************************/
#include "globals.h"

#include "script.h"
 
HRESULT Script_SetVariableNumber( LPSTR szVariableName, LONG lValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	LONG lVal = 0;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->SetVariableNumber( szVariableName, lValue, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableNumber( szVariableName, &lVal, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( lVal == lValue ? S_OK : E_FAIL );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_SetVariableNumber_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));
	
//	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, NULL ), E_POINTER ) );
//	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, &dmScriptError ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_EMPTY, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_NO_EXIST, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_GetClockTimeLength.cpp ===
#include "globals.h"


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetClockTimeLength_VerifySegmentLength(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentNameServer, DWORD dwExpectedLength)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
LPSTR szSegmentNameServer = (LPSTR)dwSegmentNameServer;
CHAR szSegmentName[MAX_PATH] = {0};
REFERENCE_TIME rtExpectedLength = *(REFERENCE_TIME *)dwExpectedLength;
REFERENCE_TIME rtLength             = 0;
BOOL           bClockTime           = 0;
BOOL           bExpectedClockTime   = 0;



//Copy everything from this segment's directory to the corresponding local directory, and also copy main1.dls to that directory.
strcpy(szSegmentName, MediaServerToLocal(szSegmentNameServer));
CHECKRUN(MediaCopyDirectory(szSegmentNameServer));
CHAR szDirectory[MAX_PATH] = {0};
CHECKRUN(ChopPath(szSegmentName, szDirectory, NULL));
MEDIAFILEDESC MediaFileDesc[]=
{
{"DLS/Main1.DLS",  szDirectory,    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));


if (strstr(szSegmentName, "rt") || strstr(szSegmentName, ".wav"))
    bExpectedClockTime = TRUE;
else if (strstr(szSegmentName, "mt"))
    bExpectedClockTime = FALSE;
else
    {
        Log(ABORTLOGLEVEL, "Test App Error - can't figure out type of segment from name");
        hr = E_FAIL;
    }

CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment8));
CHECKRUN(ptSegment8->GetClockTimeLength(&rtLength, &bClockTime));
if (SUCCEEDED(hr))
{
    if (rtLength != rtExpectedLength)
    {
        Log(ABORTLOGLEVEL, "%s: rtLength was %I64u instead of %I64u.", szSegmentName, rtLength, rtExpectedLength);
        hr = E_FAIL;
    }

    if (bClockTime != bExpectedClockTime)
    {
        Log(ABORTLOGLEVEL, "%s: bClockTime was %s instead of %s.", szSegmentName, bClockTime ? "TRUE" : "FALSE", bExpectedClockTime ? "TRUE" : "FALSE");
        hr = E_FAIL;
    }
}


SAFE_RELEASE(ptSegment8);
return hr;
};





/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetClockTimeLength_GetSet(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentNameServer, DWORD dwExpectedLength)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
LPSTR szSegmentNameServer = (LPSTR)dwSegmentNameServer;
CHAR szSegmentName[MAX_PATH] = {0};
REFERENCE_TIME rtExpectedLength = *(REFERENCE_TIME *)dwExpectedLength;
REFERENCE_TIME rtLength             = 0;
BOOL           bClockTime           = 0;
BOOL           bExpectedClockTime   = 0;

//Copy everything from this segment's directory to the corresponding local directory, and also copy main1.dls to that directory.
strcpy(szSegmentName, MediaServerToLocal(szSegmentNameServer));
CHECKRUN(MediaCopyDirectory(szSegmentNameServer));
CHAR szDirectory[MAX_PATH] = {0};
CHECKRUN(ChopPath(szSegmentName, szDirectory, NULL));
MEDIAFILEDESC MediaFileDesc[]=
{
{"DLS/Main1.DLS",  szDirectory,    COPY_IF_NEWER},
{TERMINATE}
};
CHECKRUN(LoadMedia(MediaFileDesc));

    for (bExpectedClockTime = 0; bExpectedClockTime < 2; bExpectedClockTime++)
    {
        CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment8));
        CHECKRUN(ptSegment8->SetClockTimeLength(rtLength, bExpectedClockTime));
        CHECKRUN(ptSegment8->GetClockTimeLength(&rtExpectedLength, &bClockTime));
        if (SUCCEEDED(hr))
        {
            if (rtLength != rtExpectedLength)
            {
                Log(ABORTLOGLEVEL, "%s: rtLength was %I64u instead of %I64u.", szSegmentName, rtLength, rtExpectedLength);
                hr = E_FAIL;
            }

            if (bClockTime != bExpectedClockTime)
            {
                Log(ABORTLOGLEVEL, "%s: bClockTime was %s instead of %s.", szSegmentName, bClockTime ? "TRUE" : "FALSE", bExpectedClockTime ? "TRUE" : "FALSE");
                hr = E_FAIL;
            }
        }
        SAFE_RELEASE(ptSegment8);
    }

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_SetVariableObject_Invalid.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableObject_Invalid.cpp

	PURPOSE:
		SetVariableObject tests for script

	BY:
		DANROSE
********************************************************************************/

#include "globals.h"
#include "script.h"
 
HRESULT Script_SetVariableObject( LPSTR szVariableName, IUnknown* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo );

HRESULT Script_SetVariableObject_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	IDirectMusicSegmentState8* pSeg = NULL;	
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, pSeg, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, pSeg, ptPerf8, &dmScriptError ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( SEGMENT_GOOD, NULL, ptPerf8, NULL ), E_POINTER ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( SEGMENT_GOOD, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	RELEASE( pSeg );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_Download.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Segment8_Download.cpp

Abstract:

	Tests for IDirectMusicSegment8::Download

Author:

	Dan Haffner (danhaff) 

Revision History:

	14-Mar-2001 robheit
		Added additional valid tests

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "globals.h"

//------------------------------------------------------------------------------
//	Function Declarations:
//------------------------------------------------------------------------------
HRESULT Segment8_DownloadUnload_BVT(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Segment8_Download_PreCache_Multiple(CtIDirectMusicPerformance8* ptPerf8, LPSTR *szFileName);

//------------------------------------------------------------------------------
//	Segment8_Download_BVT 
//------------------------------------------------------------------------------
HRESULT 
Segment8_Download_BVT(
					  IN CtIDirectMusicPerformance8*	ptPerf8, 
					  DWORD								dwUnused1, 
					  DWORD								dwUnused2
					  )
/*++

Routine Description:

	Performs all BVT tests for IDirectMusicSegment8

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Segment8_Download_BVT())");
    DMTEST_EXECUTE(Segment8_DownloadUnload_BVT(ptPerf8));           //PASSES
    return hr;
};

//------------------------------------------------------------------------------
//	Segment8_Download_Test1_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Download_Test1_Valid(
							  IN CtIDirectMusicPerformance8*	ptPerf8, 
							  IN DWORD							dwUnused1, 
							  IN DWORD							dwUnused2
							  )
/*++

Routine Description:

	Verify that playing a wave segment without downloading results in silence.

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
	DWORD						dwSegment		= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName[2]	= {"T:\\DMTest1\\Segment8\\Download\\One.sgt",
												   "T:\\DMTest1\\Segment8\\Download\\Two.sgt"};

    Log(FYILOGLEVEL, "Calling main test function Segment8_Download_Test1_Valid())");

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));
    
    //Try downloading to both the performance and the audiopath.
    for (downloadToPerf = 0; downloadToPerf < 2 && SUCCEEDED(hr); downloadToPerf++)
    {
        //Play both the segments.
        for (dwSegment=0; dwSegment<2 && SUCCEEDED(hr); dwSegment++)
        {
            //Load up the media file.
            hr = dmthLoadSegment(szFileName[dwSegment], &ptSegment8);
			if(FAILED(hr))
			{
				Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
				failed = TRUE;
				continue;
			}

            //Play the segment.
	        hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
	        if(FAILED(hr))
	        {
		        Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
                CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
				failed = TRUE;
	        }

			// Prompt the user
			else
			{
				Log(FYILOGLEVEL, "We did not download anything; you should hear silence.");
				Log(FYILOGLEVEL, "Playing segment; you should NOT hear the phrase ""%d"" being spoken", dwSegment+1);
				CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 2000, NULL));
				CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 15000, NULL));				
                dmthPromptUserTestResults(hr, EXPECT_NO, "Did you hear any audio?");
			}

	        Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
            SAFE_RELEASE(ptSegment8);            
        }
    };

    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
};

//------------------------------------------------------------------------------
//	Segment8_Download_Test2_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Download_Test2_Valid(
							  IN CtIDirectMusicPerformance8*	ptPerf8, 
							  IN DWORD							dwUnused1, 
							  IN DWORD							dwUnused2
							  )
/*++

Routine Description:

	Verify that playing a wave segment with 257 different waves works.

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName		= "T:\\DMTest1\\Segment8\\257Waves\\257Waves.sgt";

    Log(FYILOGLEVEL, "Calling main test function Segment8_Download_Test2_Valid())");

	CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

	//Try downloading to both the performance and the audiopath.
	for (downloadToPerf = 0; downloadToPerf < 2 && SUCCEEDED(hr); downloadToPerf++)
	{
		//Load up the media file.
		hr = dmthLoadSegment(szFileName, &ptSegment8);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		// Download the segment
		Log(FYILOGLEVEL, "Downloading to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		CHECKRUN(ptSegment8->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);) 

		//Play the segment.
		hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
		}

		// Prompt the user
		else
		{
			Log(FYILOGLEVEL, "Playing the segment, you should hear 257 notes");
			CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL));
			CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL));
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did you hear 257 notes?");
		}

	    Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
		SAFE_RELEASE(ptSegment8);            
	}
	SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
};

//------------------------------------------------------------------------------
//	Segment8_Download_Test3_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Download_Test3_Valid(
							  IN CtIDirectMusicPerformance8*	ptPerf8, 
							  IN DWORD							dwUnused1, 
							  IN DWORD							dwUnused2
							  )
/*++

Routine Description:

	Determines if downloading a band segment after another segment is loaded and
	playing replaces the band

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment8*		pOriginalSegment	= NULL;
	CtIDirectMusicSegment8*		pNewSegment			= NULL;
	CtIDirectMusicAudioPath*	ptPath				= NULL;
	UINT						downloadToPerf		= 0;
	BOOL						failed				= FALSE;
	CHAR*						original			= "T:\\DMTest1\\Segment8\\Download\\OriginalSegment.sgt";
	CHAR*						change				= "T:\\DMTest1\\Segment8\\Download\\NewBand.sgt";

    // Create a audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));
    
	// Try downloading to both the performance and the audiopath.
    for(downloadToPerf = 0; downloadToPerf < 2; downloadToPerf++)
    {
		// Load the original data
	    hr = dmthLoadSegment(original, &pOriginalSegment);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

	    // Load the original data
	    hr = dmthLoadSegment(change, &pNewSegment);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		// Download everything.
		Log(FYILOGLEVEL, "Downloading original to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		CHECKRUN(pOriginalSegment->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath)); 

        // Play the segment.
	    hr = ptPerf8->PlaySegmentEx(pOriginalSegment, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
	    if(FAILED(hr))
	    {
		    Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
            CHECKRUN(pOriginalSegment->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			SAFE_RELEASE(pOriginalSegment);            
			SAFE_RELEASE(pNewSegment);            
			continue;
	    }
        Log(FYILOGLEVEL, "Playing segment with original band.");
		WaitForSegmentStart(ptPerf8, pOriginalSegment, NULL, 5000);

		// Download the new segment
		Log(FYILOGLEVEL, "Downloading new segment to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		CHECKRUN(pNewSegment->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);) 

        Log(FYILOGLEVEL, "You should hear a different band playing the same segment.");
		Wait(3000);

		// Prompt for response
		dmthPromptUserTestResults(hr, EXPECT_YES, "Did the band change?");

        Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
        CHECKRUN(pOriginalSegment->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
        SAFE_RELEASE(pOriginalSegment);            

        Log(FYILOGLEVEL, "Unloading new segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
        CHECKRUN(pNewSegment->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
        SAFE_RELEASE(pNewSegment);            
    }

    SAFE_RELEASE(ptPath);
    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_Download_Test4_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Download_Test4_Valid(
							  IN CtIDirectMusicPerformance8*	ptPerf8, 
							  IN DWORD							dwUnused1, 
							  IN DWORD							dwUnused2
							  )
/*++

Routine Description:

	Verify that playing a MIDI+DLS segment with a wave track without downloading
	results in silence.

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName		= "T:\\DMTest1\\Segment8\\MIDIandWave\\MIDIandWave.sgt";

    Log(FYILOGLEVEL, "Calling main test function Segment8_Download_Test4_Valid())");

	CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

	//Try downloading to both the performance and the audiopath.
	for (downloadToPerf = 0; downloadToPerf < 2; downloadToPerf++)
	{
		//Load up the media file.
		hr = dmthLoadSegment(szFileName, &ptSegment8);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		//Play the segment.
		hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
		if(FAILED(hr))
			failed = TRUE;

		// Prompt the user
		else
		{
			Log(FYILOGLEVEL, "Playing the segment, you should not hear anything");
			ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL);
			dmthPromptUserTestResults(hr, EXPECT_NO, "Did you hear anything?");
		}
		SAFE_RELEASE(ptSegment8);            
	}
	SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_DownloadUnload_BVT
//------------------------------------------------------------------------------
HRESULT 
Segment8_DownloadUnload_BVT(
							IN CtIDirectMusicPerformance8* ptPerf8
							)
/*++

Routine Description:

	Performs a download and unload test for the BVT

Arguments:

	IN ptPerf8 -	Performance object

Return Value:

	S_OK on success, some other error code on failure

--*/
{
	BOOL						failed			= FALSE;
	HRESULT						hr				= S_OK;
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
	DWORD						dwSegment		= 0;
	CHAR*						szFileName[2]	= {"T:\\DMTest1\\Segment8\\Download\\One.sgt",
												   "T:\\DMTest1\\Segment8\\Download\\Two.sgt"};

    //Create a audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));
    
    //Try downloading to both the performance and the audiopath.
    for (downloadToPerf = 0; downloadToPerf < 2; downloadToPerf++)
    {
        //Play both the segments.
        for (dwSegment=0; dwSegment<2 && SUCCEEDED(hr); dwSegment++)
        {
            //Load up the media file.
            hr = dmthLoadSegment(szFileName[dwSegment], &ptSegment8);
			if(FAILED(hr))
			{
				Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
				failed = TRUE;
				continue;
			}

            //Download everything.
            Log(FYILOGLEVEL, "Downloading to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
            CHECKRUN(ptSegment8->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);) 
	        if(FAILED(hr))
				failed = TRUE;

            //Play the segment.
	        hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
	        if(FAILED(hr))
	        {
		        Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
                CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
				failed = TRUE;
	        }
            Log(FYILOGLEVEL, "Playing segment for 5 seconds, you should hear the phrase ""%d"" being spoken", dwSegment+1);
            Wait(5000);

            Log(FYILOGLEVEL, "Unloading from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
            CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
	        if(FAILED(hr))
				failed = TRUE;

            SAFE_RELEASE(ptSegment8);            
        }
    };

    SAFE_RELEASE(ptPath);
    return failed ? E_FAIL : S_OK;
}


#define WAVES 4

HRESULT Segment8_Download_PreCache_Multiple01(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	CHAR*						szFileName[4]   = {
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming03\\StreamingWaves.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming03\\NonStreamingWaves.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming03\\StreamingWavesPlay.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming03\\NonStreamingWavesPlay.sgt",
                                                    };


    return Segment8_Download_PreCache_Multiple(ptPerf8, szFileName);
}

/*
HRESULT Segment8_Download_PreCache_Multiple02(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
	CHAR*						szFileName[4]   = {
                                                    "T:\\DMTest1\\Segment8\\Download\\StreamingNone\\y_shaman.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming04\\y_shaman.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\StreamingNone\\ssR0001.sgt",
                                                    "T:\\DMTest1\\Segment8\\Download\\Streaming04\\ssR0001.sgt"
                                                    };


    return Segment8_Download_PreCache_Multiple(ptPerf8, szFileName);
}
*/

/********************************************************************************
Verify that by downloading a segment, another segment can use its waves
********************************************************************************/
HRESULT Segment8_Download_PreCache_Multiple(CtIDirectMusicPerformance8* ptPerf8, LPSTR *szFileName)
{
	HRESULT						hr				= S_OK;
	CtIDirectMusicSegment8*		ptSegment[4]	= {NULL};
	CtIDirectMusicAudioPath*	ptPath			= NULL;
    CtIDirectMusicLoader *ptLoader = NULL;
	DWORD						dwSegment		= 0;
    CHAR szPath[MAX_PATH] = {NULL};
    CHAR szFile[MAX_PATH] = {NULL};


    
    DWORD i = 0;
    BOOL bDownloaded = FALSE;

    //Create an audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

    //Create a loader.
    CHECKRUN(dmthCreateLoader(IID_IDirectMusicLoader, &ptLoader));


    //Load and download the first 2 segments.
    for (i=0; i<2 && SUCCEEDED(hr); i++)
    {

        CHECKRUN(ChopPath(szFileName[i], szPath, szFile));
        CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, FALSE));
        CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szFile, (void **)&ptSegment[i]));
        CHECKRUN(ptSegment[i]->Download(ptPerf8));
    }

    //Download the first 2 segments.
    if (SUCCEEDED(hr))
        bDownloaded = TRUE;

    //Load the last 2 segments.
    for (i=2; i<4 && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ChopPath(szFileName[i], szPath, szFile));
        CHECKRUN(ptLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szPath, FALSE));
        CHECKRUN(ptLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment, szFile, (void **)&ptSegment[i]));
    }

    //Don't download the last 2 segments, just play them.
    Log(FYILOGLEVEL, "You should hear both a oneshot and a streaming wave");
    for (i=2; i<4 && SUCCEEDED(hr); i++)
    {
        CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[i], NULL, NULL, DMUS_SEGF_SECONDARY, 0, NULL, NULL, ptPath));
        CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment[i], NULL, 2000, NULL));
    }

    //Stop the segments after 5 seconds.
    Wait(5000);
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));


    //Unload
    if (bDownloaded)
    {
        for (i=0; i<2; i++)
        {
            ptSegment[i]->Unload(ptPerf8);
        }
    }

    //RELEASE everything.
    for (i=0; i<WAVES; i++)
    {
        RELEASE(ptSegment[i]);
    }

     RELEASE(ptPath);
     RELEASE(ptLoader);
     return hr;
}

#undef WAVES


/********************************************************************************
Verify that by downloading a segment, another segment can use its waves
********************************************************************************/
/*
HRESULT Segment8_Download_PreCache(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFileName1, DWORD dwFileName2)
{
	HRESULT						hr				= S_OK;
	CtIDirectMusicSegment8*		ptSegment[2]	= {NULL};
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	DWORD						dwSegment		= 0;
	CHAR*						szFileName[2]   = {NULL};


    
    DWORD i = 0;
    LPSTR szExpected = "You should hear a guy counting (streaming wave) and music (oneshot wave) simultaneously";
    BOOL bDownloaded = FALSE;
    szFileName[0] = (LPSTR)dwFileName1;
    szFileName[1] = (LPSTR)dwFileName2;

    //Create an audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));   

    //Load andthe segments.
    for (i=0; i<2 && SUCCEEDED(hr); i++)
    {
        CHECKRUN(dmthLoadSegment(szFileName[i], &ptSegment[i]));
    }

    //Download the first one and play it.
    CHECKRUN(ptSegment[0]->Download(ptPerf8));
    if (SUCCEEDED(hr))
        bDownloaded = TRUE;
    //CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0], NULL, NULL, 0, 0, NULL, NULL, ptPath));
    //CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment[0], NULL, 2000, NULL));
    //CHECKRUN(Log(FYILOGLEVEL, "First wave (downloaded and played)"));
    CHECKRUN(Log(FYILOGLEVEL, szExpected));
    Wait(5000);
    
    //Stop the first segment
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment[0], NULL, 2000, NULL));

    //Simply play the second segment.
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[1], NULL, NULL, 0, 0, NULL, NULL, ptPath));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment[1], NULL, 2000, NULL));
    CHECKRUN(Log(FYILOGLEVEL, "Second wave (merely played)"));
    CHECKRUN(Log(FYILOGLEVEL, szExpected));
    Wait(5000);

    //Stop the second segment
    CHECKRUN(ptPerf8->StopEx(0, 0, 0));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment[1], NULL, 2000, NULL));

    //Unload
    if (bDownloaded)
        ptSegment[0]->Unload(ptPerf8);

    //RELEASE everything.
    for (i=0; i<2; i++)
    {
        RELEASE(ptSegment[i]);
    }

     RELEASE(ptPath);

     return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Script_SetVariableObject.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableObject.cpp

	PURPOSE:
		SetVariableObject tests for script

	BY:
		DANROSE
********************************************************************************/

#include "globals.h"
#include "script.h"
 
HRESULT Script_SetVariableObject( LPSTR szVariableName, IUnknown* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->SetVariableObject( szVariableName, ppv, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_SetVariableObject_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	IDirectMusicSegmentState8* pSeg = NULL;

    //Copy down everything in the scripts directory.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Script/"));
	
	DMTEST_EXECUTE( Script_SetVariableObject( SEGMENT_GOOD, pSeg, ptPerf8, NULL ) );
	DMTEST_EXECUTE( Script_SetVariableObject( SEGMENT_GOOD, pSeg, ptPerf8, &dmScriptError ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( VARIABLE_EMPTY, pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	DMTEST_EXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( VARIABLE_NO_EXIST, pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	RELEASE( pSeg );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_Compose.cpp ===
#include "globals.h"

#define ORIGINAL_SEGMENT 0
#define NEW_SEGMENT 1


HRESULT Segment8_Compose_Transition(CtIDirectMusicPerformance8* ptPerf8, MUSIC_TIME mt, LPSTR szFrom, LPSTR szTo, BOOL bNewSegment);
HRESULT Segment8_Compose_Yourself(CtIDirectMusicPerformance8* ptPerf8, LPSTR szFileName, BOOL bClone, LPSTR szInfo);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Segment8_Compose_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return Segment8_Compose_Yourself(ptPerf8, g_TestParams.szDefaultMedia, FALSE, "Should hear normal boring test segment");
};

/********************************************************************************
Valid test function.
********************************************************************************/
/*
HRESULT Segment8_Compose_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{   
    //Load media.
    HRESULT hr = S_OK;
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"SGT/test.sgt",      "T:\\DMTest1",    COPY_IF_NEWER},
    {"SGT/test2.sgt",     "T:\\DMTest1",    COPY_IF_NEWER},
    {"DLS/Main1.DLS",     "T:\\DMTest1",    COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));
    CHECKRUN(Segment8_Compose_Transition(ptPerf8, 0, "T:\\DMTest1\\test.sgt", "T:\\DMTest1\\test2.sgt", NEW_SEGMENT));
    return hr;
};  
*/

/********************************************************************************
BVT test function.  Makes a segment compose itself.
********************************************************************************/
HRESULT Segment8_Compose_Yourself(CtIDirectMusicPerformance8* ptPerf8, LPSTR szFileName, BOOL bClone, LPSTR szInfo)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = NULL;
CtIDirectMusicSegment8              *ptSegment       = NULL;
CtIDirectMusicSegment8              *ptClone         = NULL;

CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&ptPath));
CHECKRUN(dmthLoadSegment(szFileName, &ptSegment));
CHECKRUN(ptSegment->Compose(0, NULL, NULL, bClone ? &ptClone : NULL));
CHECKRUN(ptPerf8->PlaySegmentEx(bClone ? ptClone : ptSegment,0,0,0,__int64(0),0,0,ptPath));
CHECKRUN(Log(FYILOGLEVEL, "Playing composed, %s segment %s in its entirety.", bClone ? "cloned" : "non-cloned", szFileName));
if (szInfo)
    CHECKRUN(Log(FYILOGLEVEL, szInfo));
CHECKRUN(ExpectSegmentStart(ptPerf8, bClone ? ptClone : ptSegment, NULL, 2000,  "To"));
CHECKRUN(ExpectSegmentStop (ptPerf8, bClone ? ptClone : ptSegment, NULL, 20000, "To"));

SAFE_RELEASE(ptSegment);
SAFE_RELEASE(ptClone);
SAFE_RELEASE(ptPath);
return hr;

};


/********************************************************************************
Valid test function.
********************************************************************************/
/*
HRESULT Segment8_Compose_Transition(CtIDirectMusicPerformance8* ptPerf8, MUSIC_TIME mt, LPSTR szFrom, LPSTR szTo, BOOL bNewSegment)
{
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = NULL;
CtIDirectMusicSegment8              *ptSegment8[2]   = {NULL};
CtIDirectMusicSegment8              *ptOriginalEmpty = NULL;
CtIDirectMusicSegment8              *ptComposed        = NULL;

CHAR *szFileName[2]                 = {NULL};
DWORD i = 0;

    szFileName[0] = szFrom;
    szFileName[1] = szTo;
    
    //Create the audiopath.
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath));

    //Load up the filez.
    for (i=0; i<2; i++)
    {
        if (szFileName[i])
        {
            CHECKRUN(dmthLoadSegment(szFileName[i], &ptSegment8[i]));
        }
    }
    //Create an empty segment and compose something.
    CHECKRUN(dmthCreateEmptySegment(&ptOriginalEmpty));
    CHECKRUN(ptOriginalEmpty->Compose(mt, ptSegment8[0], ptSegment8[1], bNewSegment ? &ptComposed : NULL));    //Play
	CHECKRUN(ptPerf8->PlaySegmentEx(bNewSegment ? ptComposed : ptOriginalEmpty,0,0,0,__int64(0),0,0,ptPath));

    
    CHECKRUN(Log(FYILOGLEVEL, "Playing 'from' segment (%s)", szFileName[0]));
    CHECKRUN(ExpectSegmentStart(ptPerf8, bNewSegment ? ptComposed : ptOriginalEmpty, NULL, 2000,  "From"));
    CHECKRUN(ExpectSegmentStop (ptPerf8, bNewSegment ? ptComposed : ptOriginalEmpty, NULL, 20000, "From"));

    SAFE_RELEASE(ptOriginalEmpty);
    SAFE_RELEASE(ptComposed);
    SAFE_RELEASE(ptPath);

    return hr;

}



*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_GetClockTimeLoopPoints.cpp ===
#include "globals.h"



/********************************************************************************
Verify that you get what you set.
/********************************************************************************/
HRESULT Segment8_GetClockTimeLoopPoints_SetAndGet(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
REFERENCE_TIME rtLoopPoint[2] = {0};
const REFERENCE_TIME rtLoopPointExpected[][2] = {
                                                {0,       1},
                                                {0,       10000000},
                                                {0,       60000000},
                                                {5999999, 60000000}
                                                };
BOOL bClockTime = 0;
CtIDirectMusicSegment *ptSegment = NULL;
CHECKRUN(dmthLoadSegment("T:\\DMTest1\\Segment8\\GetSetClockTimeLoopPoints\\CountTo6.wav", &ptSegment));


//Set some random loop points.
if (SUCCEEDED(hr))
{
    for (int j=0; j<AMOUNT(rtLoopPointExpected);j++)
    {
        CHECKRUN(ptSegment->SetClockTimeLoopPoints(rtLoopPointExpected[j][0],rtLoopPointExpected[j][1]));
        CHECKRUN(ptSegment->GetClockTimeLoopPoints(&rtLoopPoint[0], &rtLoopPoint[1]));
        for (int i=0; i<2; i++)
        {
            if (rtLoopPointExpected[j][i] != rtLoopPoint[i])
            {
                Log(ABORTLOGLEVEL, "Error: Set %I64u for %s but got back %I64u", rtLoopPointExpected[i], (i==0 ? "rtStart" : "rtEnd"),  rtLoopPoint[i]);
                hr = E_FAIL;
                break;
            }
        }
    }
}


SAFE_RELEASE(ptSegment);
return hr;
};



/********************************************************************************
Verify that you get what you set.
/********************************************************************************/
/*
HRESULT Segment8_GetClockTimeLoopPoints_FromSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegment, DWORD dwLoopPointSet)
{
HRESULT hr = S_OK;
REFERENCE_TIME rtLoopPoint[2] = {0};
REFERENCE_TIME rtLoopPointExpected[][2] =   {
                                            {0,       1},
                                            {0,       10000000},


{0};
LPSTR szSegment = (LPSTR)dwSegment;


BOOL bClockTime = 0;
CtIDirectMusicSegment *ptSegment = NULL;
CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));

//Set some random loop points.
CHECKRUN(ptSegment->GetClockTimeLoopPoints(&rtLoopPoint[0], &rtLoopPoint[1]));
        for (int i=0; i<2; i++)
        {
            if (rtLoopPointExpected[j][i] != rtLoopPoint[i])
            {
                Log(ABORTLOGLEVEL, "Error: Set %I64u for %s but got back %I64u", rtLoopPointExpected[i], (i==0 ? "rtStart" : "rtEnd"),  rtLoopPoint[i]);
                hr = E_FAIL;
                break;
            }
        }
    }
}


SAFE_RELEASE(ptSegment);
return hr;};


*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetClockTimeLength.cpp ===
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_GetStartPoint.cpp ===
#include "globals.h"



/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetStartPoint_Generic(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentServer, DWORD dwStartPointExpected)
{
HRESULT hr = S_OK;
LPSTR szSegmentServer = (LPSTR)dwSegmentServer;
MUSIC_TIME mtStartPointExpected = dwStartPointExpected;
MUSIC_TIME mtStart = 0;
CtIDirectMusicSegment *ptSegment = NULL;
CHAR szSegment[MAX_PATH] = {0};

ASSERT(mtStartPointExpected >=0);

//Copy down the media.
CHECKRUN(MediaCopyDirectory(szSegmentServer));
strcpy(szSegment, MediaServerToLocal(szSegmentServer));

CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
CHECKRUN(ptSegment->GetStartPoint(&mtStart));
if (mtStart != mtStartPointExpected)
{
    Log(ABORTLOGLEVEL, "Start point for %s was %d instead of %d", szSegment, mtStart, mtStartPointExpected);
    hr = E_FAIL;
}

RELEASE(ptSegment);
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_GetRepeats.cpp ===
#include "globals.h"

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetRepeats_Content(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRepeats, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
CHAR szServer[MAX_PATH] = {0};
CHAR szLocal [MAX_PATH] = {0};
DWORD dwRepeatsActualValue = 0;
DWORD dwStartTime = 0;
DWORD dwExpectedTime = 0;
DWORD dwActualTime = 0;
double fErrorPercent= 0;
double fMaxErrorPercent= 0;

//Download the media.
if (dwRepeats != 0xFFFFFFFF)
    sprintf(szServer, "DMusic/DMTest1/Segment8/GetRepeats/Repeat_%d.sgt", dwRepeats);
else
    sprintf(szServer, "DMusic/DMTest1/Segment8/GetRepeats/Repeat_Inf.sgt");
CHECKRUN(MediaServerToLocal(szServer, szLocal))
CHECKRUN(MediaCopyFile(szServer));

//Verify we got the correct repeats programatically.
CHECKRUN(dmthLoadSegment(szLocal, &ptSegment));
CHECKRUN(ptSegment->GetRepeats(&dwRepeatsActualValue));
if (SUCCEEDED(hr))
{
    if (dwRepeatsActualValue != dwRepeats)
    {
        Log(ABORTLOGLEVEL, "Error: Expected %u repeats, got %u.", dwRepeats, dwRepeatsActualValue);
        hr = E_FAIL;
    }
}

//Verify the timing is correct.
if (dwRepeats != 0xFFFFFFFF && dwRepeats != 32767)
{
    dwExpectedTime = (dwRepeats + 1) * 2 * 1000;
    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
    dwStartTime = timeGetTime();
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000, NULL));
    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, dwExpectedTime * 2, szLocal));
    if (SUCCEEDED(hr))
    {   
        dwActualTime = timeGetTime() - dwStartTime;
        fErrorPercent = CalculateErrorPercentage((double)dwExpectedTime, (double)dwActualTime);
        Log(FYILOGLEVEL, "Error = %.2f%%, maximum allowed error is %.2f%%", fErrorPercent, fMaxErrorPercent);
        if (fErrorPercent> fMaxErrorPercent)
        {
                Log(ABORTLOGLEVEL, "FAILURE!!  %.2f%% exceeds maximum allowed error of %.2f%%!!!", fErrorPercent, fMaxErrorPercent);
            hr = E_FAIL;
        }
    }
}

//Print info regarding the tempo.
if (SUCCEEDED(hr))
{
    double fTempo = 0;
    if (SUCCEEDED(GetTempo(ptPerf8, &fTempo)))
    {
        if (fTempo != 120.f)
        {
            Log(ABORTLOGLEVEL, "Note: Tempo was %.2f% instead of 120", fTempo);
        }
    }
}

ptPerf8->StopEx(0, 0, 0);
RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};



/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetRepeats_Programmatic(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment *ptSegment = NULL;
LPSTR szServer = "DMusic/DMTest1/Segment8/GetRepeats/Repeat_1.sgt";
CHAR szLocal [MAX_PATH] = {0};

DWORD dwRepeats[] = {0, 1, 2, 32767, 0x0000FFFF, 0xFFFFFFFF};

CHECKRUN(MediaServerToLocal(szServer, szLocal))
CHECKRUN(MediaCopyFile(szServer));
CHECKRUN(dmthLoadSegment(szLocal, &ptSegment));

for (DWORD i=0; i<NUMELEMS(dwRepeats) && SUCCEEDED(hr); i++)
{
    DWORD dwTemp = 0;
    CHECKRUN(ptSegment->SetRepeats(dwRepeats[i]));
    CHECKRUN(ptSegment->GetRepeats(&dwTemp));
    if (dwTemp != dwRepeats[i])
    {
        Log(ABORTLOGLEVEL, "Error: SetRepeats %u, got back %u", dwRepeats[i], dwTemp);
        hr = E_FAIL;
    }
}

RELEASE(ptSegment);
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_getLength.cpp ===
#include "globals.h"

HRESULT Segment8_GetLength_VerifySegmentLength(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegmentName, MUSIC_TIME dwExpectedLength);
HRESULT Segment8_GetLength_SetAndGetSegmentLength(CtIDirectMusicPerformance8* ptPerf8);

struct SEGLENGTH
{
LPSTR szSegmentName;
MUSIC_TIME mtLength;
};


/********************************************************************************
1) Verify length is 1 for wave files.
2) Verify length is 0 for 0-length segments.
3) Verify length is correct for other segments.
********************************************************************************/


/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT Segment8_GetLength_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    //Get the needed media for this test.
    CHECKRUN(MediaCopyDirectory("DMusic/DMTest1/Segment8/GetLength/"));
    LPSTR szDirectory = "T:\\DMTest1\\Segment8\\GetLength\\";
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS",      szDirectory,    COPY_IF_NEWER},
    {"SGT/1Bar.sgt",       szDirectory,    COPY_IF_NEWER},
    {"SGT/2Bars.sgt",      szDirectory,    COPY_IF_NEWER},
    {"SGT/999Bars.sgt",    szDirectory,    COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));




    SEGLENGTH SegLength[] = {
                             {"T:\\DMTest1\\Segment8\\GetLength\\1Bar.sgt",                       DMUS_PPQ * 4 * 1},
                             {"T:\\DMTest1\\Segment8\\GetLength\\1BarExtended.sgt",               DMUS_PPQ * 4 * 1},
                             {"T:\\DMTest1\\Segment8\\GetLength\\2Bars.sgt",                      DMUS_PPQ * 4 * 2},
                             {"T:\\DMTest1\\Segment8\\GetLength\\2BarsLoopingInfinite.sgt",       DMUS_PPQ * 4 * 2},
                             {"T:\\DMTest1\\Segment8\\GetLength\\2BarsLoopingOnce.sgt",           DMUS_PPQ * 4 * 2},
                             {"T:\\DMTest1\\Segment8\\GetLength\\999Bars.sgt",                    DMUS_PPQ * 4 * 999}, 
                             {"T:\\DMTest1\\Segment8\\GetLength\\WaveSegment.wav",                1}          
                            };

    Log(FYILOGLEVEL, "Calling BVT test function Segment8_GetLength_BVT())");
    for (i=0; i<AMOUNT(SegLength); i++)
    {
        DMTEST_EXECUTE(Segment8_GetLength_VerifySegmentLength(ptPerf8, SegLength[i].szSegmentName, SegLength[i].mtLength));
    }
    
    return hr;

};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT Segment8_GetLength_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function Segment8_GetLength_Valid())");

    DMTEST_EXECUTE(Segment8_GetLength_SetAndGetSegmentLength(ptPerf8));

    return hr;

};





/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetLength_VerifySegmentLength(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegmentName, MUSIC_TIME mtExpectedLength)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
MUSIC_TIME mtLength = 0;

//Note: No need to load the media here, as it is already loaded by the calling function.
CHECKRUN(dmthLoadSegment(szSegmentName, &ptSegment8));
CHECKRUN(ptSegment8->GetLength(&mtLength));
if (mtLength != mtExpectedLength)
{
    Log(ABORTLOGLEVEL, "%s: Length was %d instead of %d.", szSegmentName, mtLength, mtExpectedLength);
    hr = E_FAIL;
}


SAFE_RELEASE(ptSegment8);
return hr;
};


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_GetLength_SetAndGetSegmentLength(CtIDirectMusicPerformance8* ptPerf8)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
LPSTR szSegmentNameServer = "DMusic/DMTest1/Segment8/GetLength/1Bar.sgt";
MUSIC_TIME mtLength = 17;
MUSIC_TIME mtLength2 = 0;

LPSTR szDirectory = "T:\\DMTest1\\Segment8\\GetLength\\";
MEDIAFILEDESC MediaFileDesc[]=
{
{"DLS/Main1.DLS",      szDirectory,    COPY_IF_NEWER},
{"SGT/1Bar.sgt",       szDirectory,    COPY_IF_NEWER},
{TERMINATE}
};

CHECKRUN(LoadMedia(MediaFileDesc));
CHECKRUN(dmthLoadSegment(MediaServerToLocal(szSegmentNameServer), &ptSegment8));
CHECKRUN(ptSegment8->SetLength(mtLength));
CHECKRUN(ptSegment8->GetLength(&mtLength2));
if (mtLength != mtLength2)
{
    Log(ABORTLOGLEVEL, "%s: Set length to %d but returned length was %d.", mtLength, mtLength2);
    hr = E_FAIL;
}

SAFE_RELEASE(ptSegment8);
return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetLength.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Segment8_SetLength.cpp

Abstract:

	Tests the SetLength methods of IDirectMusicSegment8

Author:

	Dan Haffner (danhaff) 

Revision History:

	20-Mar-2001 robheit
		Added all Valid tests
    01-Aug-2001 danhaff
        Combied 4 tests into one, calling now from external test struct

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "globals.h"
#include "CICMusicX.h"

//------------------------------------------------------------------------------
//	Function Prototypes:
//------------------------------------------------------------------------------
HRESULT Segment8_SetLength_Range(IN CtIDirectMusicPerformance8*	ptPerf8, DWORD dwMusicTimeLength,DWORD dwUnused2);

//------------------------------------------------------------------------------
//	Segment8_SetLength_BVT
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetLength_BVT(
					   IN CtIDirectMusicPerformance8*	ptPerf8, 
					   IN DWORD							dwUnused1, 
					   IN DWORD							dwUnused2
					   )
/*++

Routine Description:

	BVT test for IDirectMusicSegment8::SetLength

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused 
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function Segment8_SetLength_BVT())");

    DMTEST_EXECUTE(Segment8_SetLength_Range(ptPerf8, 100, 0));

    return hr;
}

//------------------------------------------------------------------------------
//	Segment8_SetLength_Test1_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetLength_Test1_Valid(
							   IN CtIDirectMusicPerformance8*	ptPerf8, 
							   IN DWORD							dwUnused1,
							   IN DWORD							dwUnused2
							   )
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetLength

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused 
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    DWORD						i;
    CICMusic					Music;
    HRESULT						hr			= S_OK;
	BOOL						failed		= FALSE;
    CtIDirectMusicSegment8*		ptSegment8	= NULL;
    CtIDirectMusicAudioPath*	ptPath		= NULL;
    MUSIC_TIME					mtTime[]	= {DMUS_PPQ*4, DMUS_PPQ-1, DMUS_PPQ, DMUS_PPQ+1, MT_MIN, MT_MAX};
	DWORD						numValues	= sizeof(mtTime) / sizeof(MUSIC_TIME);

    CHECKRUN(MediaCopyFile("DMusic/DMTest1/Segment8/SetRep/Repeat5.sgt"));
    CHECKRUN(MediaCopyFile("DMusic/DMTest1/Segment8/SetRep/Demo.dls"));	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat5.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
    CHECKRUN(ptSegment8->SetRepeats(0));
	
    //Try all these length values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetLength(%u)", mtTime[i]);
		CHECKRUN(ptSegment8->SetLength(mtTime[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL, TRUE);

        //Wait until done
		Log(FYILOGLEVEL, "Waiting until segment stops");
		if(FAILED(WaitForSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, TRUE)))
			CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
		dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio play for the correct length?");
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}



//------------------------------------------------------------------------------
//	Segment8_SetLength_Range
//------------------------------------------------------------------------------
HRESULT Segment8_SetLength_Range(IN CtIDirectMusicPerformance8*	ptPerf8, DWORD dwMusicTimeLength,DWORD dwUnused2)
/*++

Routine Description:

	Portion of the BVT test for IDirectMusicSegment8::SetLength

Arguments:

	IN ptPerf8 -	Performance object
	IN mtLength -	

Return Value:

	None

--*/
{
	CICMusic				Music;
	HRESULT					hr				= S_OK;
	CtIDirectMusicSegment8*	ptSegment8		= NULL;
	LPSTR					szSegmentName	= "T:\\DMTest1\\Segment8\\GetLength\\1Bar.sgt";
    MUSIC_TIME              mtLength        = (MUSIC_TIME)dwMusicTimeLength;
	MUSIC_TIME				mtLength2		= 0;

    CHECKRUN(MediaCopyFile("SGT/1Bar.sgt",               "T:\\DMTest1\\Segment8\\GetLength\\"));
    CHECKRUN(MediaCopyFile("DLS/Main1.DLS",              "T:\\DMTest1\\Segment8\\GetLength\\"));
	CHECKRUN(Music.Init(ptPerf8, szSegmentName, DMUS_APATH_SHARED_STEREOPLUSREVERB));

	Log(FYILOGLEVEL, "FYI: Playing for 1 second with default length");
	Wait(1000);

	CHECKRUN(Music.GetInterface(&ptSegment8));
	CHECKRUN(ptSegment8->SetLength(mtLength));
	CHECKRUN(ptSegment8->GetLength(&mtLength2));
	if (mtLength != mtLength2)
	{
		Log(ABORTLOGLEVEL, "%s: Set length to %d but returned length was %d.", szSegmentName, mtLength, mtLength2);
		hr = E_FAIL;
	}

	Log(FYILOGLEVEL, "FYI: Playing for 4 seconds with length = %d", mtLength2);
	Wait(4000);

	SAFE_RELEASE(ptSegment8);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetClockTimeLoopPoints.cpp ===
#include "globals.h"


/********************************************************************************
Verify that calling SetClockTimeLoopPoints sets segment to clocktime mode
(we can verify this with GetClockTimeLoopPoint's 2nd param)
/********************************************************************************/
/*
HRESULT Segment8_SetClockTimeLoopPoints_SetsClockTimeMode(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
REFERENCE_TIME rtDummy = 0;
BOOL bClockTime = 0;
CtIDirectMusicSegment *ptSegment = NULL;

CHECKRUN(dmthLoadSegment("T:\\DMTest1\\Segment8\\GetSetClockTimeLoopPoints\\SegMusicTime2Bars.sgt", &ptSegment));

//Verify the segment is in music time.
CHECKRUN(ptSegment->GetClockTimeLength(&rtDummy, &bClockTime));
if (SUCCEEDED(hr))
{
    if (bClockTime)
    {
        Log(ABORTLOGLEVEL, "Error: Music time segment initially had CLOCK TIME mode set instead of music time");
        hr = E_FAIL;
    }
}

//Set some random loop points.
CHECKRUN(ptSegment->SetClockTimeLoopPoints(10000000, 20000000));

//Verify we transitioned to Clock Time.
CHECKRUN(ptSegment->GetClockTimeLength(&rtDummy, &bClockTime));

if (SUCCEEDED(hr))
{
    if (!bClockTime)
    {
        Log(ABORTLOGLEVEL, "Error: Music time segment didn't have CLOCK TIME mode set after SetClockTimeLoopPoints was called.");
        hr = E_FAIL;
    }
}

//Set music-time loop points.
CHECKRUN(ptSegment->SetClockTimeLoopPoints(768, 0));

//Verify we transitioned to Music Time.
CHECKRUN(ptSegment->GetClockTimeLength(&rtDummy, &bClockTime));
if (SUCCEEDED(hr))
{
    if (bClockTime)
    {
        Log(ABORTLOGLEVEL, "Error: Music time segment didn't return to MUSIC_TIME mode after SetClockTimeLoopPoints was called with rtEnd= 0");
        hr = E_FAIL;
    }
}



SAFE_RELEASE(ptSegment);
return hr;
};

*/



/********************************************************************************
Verify that calling SetClockTimeLoopPoints doesn't change clocktime length
/********************************************************************************/
#define DEFAULT_CLOCKTIME_LENGTH 200090000
HRESULT Segment8_SetClockTimeLoopPoints_KeepsLength(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;
REFERENCE_TIME rtBefore = 0;
REFERENCE_TIME rtAfter  = 0;
BOOL bClockTime = 0;
CtIDirectMusicSegment *ptSegment = NULL;
LPCSTR szSegmentServer= "T:\\DMTest1\\Segment8\\GetSetClockTimeLoopPoints\\SegGetClockTime200090000.sgt";


CHECKRUN(MediaCopyFile(szSegmentServer));
CHECKRUN(dmthLoadSegment(MediaServerToLocal(szSegmentServer), &ptSegment));

//Verify the segment's initial clock time is correct.
CHECKRUN(ptSegment->GetClockTimeLength(&rtBefore, &bClockTime));
if (SUCCEEDED(hr))
{
    if (!bClockTime)
    {
        Log(ABORTLOGLEVEL, "Error: clocktime segment didn't initially have CLOCK TIME mode set.");
        hr = E_FAIL;
    }

    if (rtBefore != DEFAULT_CLOCKTIME_LENGTH)
    {
        Log(ABORTLOGLEVEL, "Error: initial length wasn't %d.", DEFAULT_CLOCKTIME_LENGTH);
        hr = E_FAIL;
    }

}

//Set some random loop points.
CHECKRUN(ptSegment->SetClockTimeLoopPoints(10000000, 20000000));
if (SUCCEEDED(hr))
{
    //Verify we transitioned to Clock Time.
    CHECKRUN(ptSegment->GetClockTimeLength(&rtAfter, &bClockTime));
    if (!bClockTime)
    {
        Log(ABORTLOGLEVEL, "Error: clocktime segment didn't have CLOCK TIME mode set after SetClockTimeLoopPoints was called.");
        hr = E_FAIL;
    }

    if (rtAfter != DEFAULT_CLOCKTIME_LENGTH)
    {
        Log(ABORTLOGLEVEL, "Error: clocktime length after calling SetClockTimeLoopPoints was %d instead of %d", rtAfter, DEFAULT_CLOCKTIME_LENGTH);
        hr = E_FAIL;        
    }
}


SAFE_RELEASE(ptSegment);
return hr;
};

#undef DEFAULT_CLOCKTIME_LENGTH




//Prototyping is cool.
HRESULT Segment8_SetClockTimeLoopPoints_Generic(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, DWORD dwLoopPoint1, DWORD dwLoopPoint2);

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetClockTimeLoopPoints_DLS(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    HRESULT hr = S_OK;
    LPSTR szServerFile = "DMusic/DMTest1/Segment8/GetSetClockTimeLoopPoints/SegCountDLS.sgt";
    CHECKRUN(MediaCopyDirectory(szServerFile));    
    CHECKRUN(Segment8_SetClockTimeLoopPoints_Generic(ptPerf8, MediaServerToLocal(szServerFile), dwLoopPoint1, dwLoopPoint2));
    return hr;
};

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetClockTimeLoopPoints_WaveSeg(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    HRESULT hr = S_OK;
    LPSTR szServerFile = "DMusic/DMTest1/Segment8/GetSetClockTimeLoopPoints/SegCountWaveTrack.sgt";
    CHECKRUN(MediaCopyDirectory(szServerFile));    
    CHECKRUN(Segment8_SetClockTimeLoopPoints_Generic(ptPerf8, MediaServerToLocal(szServerFile), dwLoopPoint1, dwLoopPoint2));
    return hr;
};

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetClockTimeLoopPoints_Wave(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    HRESULT hr = S_OK;
    LPSTR szServerFile = "DMusic/DMTest1/Segment8/GetSetClockTimeLoopPoints/CountTo6.wav";
    CHECKRUN(MediaCopyDirectory(szServerFile));    
    CHECKRUN(Segment8_SetClockTimeLoopPoints_Generic(ptPerf8, MediaServerToLocal(szServerFile), dwLoopPoint1, dwLoopPoint2));
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetRepeats.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Segment8_SetRepeates.cpp

Abstract:

	Tests the functionality of IDirectMusicSegment8::SetRepeats

Author:

	Dan Haffner (danhaff) 

Revision History:

	19-Mar-2001 robheit
		Added all Valid Tests

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "globals.h"
#include "CICMusicX.h"

//------------------------------------------------------------------------------
//	Static Function Declarations:
//------------------------------------------------------------------------------
HRESULT Segment8_SetRepeats_BVT1(CtIDirectMusicPerformance8* ptPerf8);

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_BVT
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_BVT(
						IN CtIDirectMusicPerformance8*	ptPerf8, 
						IN DWORD						dwUnused1,
						IN DWORD						dwUnused2
						)
/*++

Routine Description:

	BVT tests or IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Segment8_SetRepeats_BVT())");
    DMTEST_EXECUTE(Segment8_SetRepeats_BVT1(ptPerf8));
    return hr;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test1_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test1_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test1_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/Repeat1.sgt",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"WAV/GuitarClip1.wav",            "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));

	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat1.sgt", DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
	
    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test2_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test2_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test2_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/Repeat2.sgt",       "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"WAV/GuitarStream1.wav",            "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));

	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat2.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
	
    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test3_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test3_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test3_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/Repeat3.sgt",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"WAV/GuitarClip1.wav",            "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));

	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat3.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
	
    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test4_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test4_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test4_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/Repeat4.sgt",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"WAV/GuitarClip1.wav",            "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));

	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat4.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
	
    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test5_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test5_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test5_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/Repeat5.sgt",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"DMusic/DMTest1/Segment8/SetRep/Demo.DLS",        "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };
    CHECKRUN(LoadMedia(MediaFileDesc));
	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\Repeat5.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}
	
    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_Test6_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_Test6_Valid(
								IN CtIDirectMusicPerformance8*	ptPerf8, 
								IN DWORD						dwUnused1,
								IN DWORD						dwUnused2
								)
/*++

Routine Description:

	Valid test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object 
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;
    HRESULT						hr					= S_OK;
	BOOL						failed				= FALSE;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
	DWORD						numValues			= sizeof(dwRepeatValues) / sizeof(DWORD);
    DWORD						i;

    Log(FYILOGLEVEL, "Calling Valid test function Segment8_SetRepeats_Test6_Valid())");

    MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetRep/ShortMIDIAndWave.sgt",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"DMusic/DMTest1/Segment8/SetRep/ShortMIDIAndWave.wav",     "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {"DLS/SonicImplants Live Band.dls",         "T:\\DMTest1\\Segment8\\SetRep\\",    COPY_IF_NEWER},
                                {TERMINATE}
                                };

    CHECKRUN(LoadMedia(MediaFileDesc));	
    CHECKRUN(Music.Init(ptPerf8, "T:\\DMTest1\\Segment8\\SetRep\\ShortMIDIandWave.sgt",
						DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));
	if(FAILED(hr))
	{
		SAFE_RELEASE(ptSegment8);
		return E_FAIL;
	}

    //Try all these repeat values.
    for(i=0; i<numValues; ++i)
    {
		// Set Repeats
		Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
		CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));

		// Play
		CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
		ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);

        //Wait until done
        if(dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
			ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 0xffffffff, NULL, TRUE);
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio loop %u time(s)?", dwRepeatValues[i] != 0 ? dwRepeatValues[i] : 1);
        }
        else
        {
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the audio looping forever?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        }
	}

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_SetRepeats_BVT1
//------------------------------------------------------------------------------
HRESULT 
Segment8_SetRepeats_BVT1(
						 IN CtIDirectMusicPerformance8* ptPerf8
						 )
/*++

Routine Description:

	BVT test for IDirectMusicSegment8::SetRepeats

Arguments:

	IN ptPerf8 -	Performance object

Return Value:

	S_OK on success, any other value on failure

--*/
{
    CICMusic					Music;	
    HRESULT						hr					= S_OK;
    CtIDirectMusicSegment8*		ptSegment8			= NULL;
    CtIDirectMusicAudioPath*	ptPath				= NULL;
    DWORD						dwRepeatValues[]	= {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
    DWORD						i					= 0;
    LPSTR                       szSegmentServer     = "DMusic/DMTest1/Segment8/SetRep/ShortSeg.sgt";
    CHAR                        szDirectory[MAX_PATH] = {0};

    //Copy down the entire directory of files containing ShortSeg.sgt
    CHECKRUN(MediaCopyDirectory(szSegmentServer));
    
    //Get the this stuff was copied too.
    CHECKRUN(ChopPath(MediaServerToLocal(szSegmentServer), szDirectory, NULL));

    //Copy several other needed files into the directory as well.
    MEDIAFILEDESC MediaFileDesc[]=
    {
    {"DLS/Main1.DLS",                     szDirectory,    COPY_IF_NEWER},
    {"DLS/SonicImplants Live Band.DLS",   szDirectory,    COPY_IF_NEWER},
    {"WAV/GuitarClip1.wav",               szDirectory,    COPY_IF_NEWER},
    {"WAV/GuitarStream1.wav",             szDirectory,    COPY_IF_NEWER},
    {TERMINATE}
    };
    CHECKRUN(LoadMedia(MediaFileDesc));



    //Load up and play our segment.  It's really short so we can count the number of times it plays.
    CHECKRUN(Music.Init(ptPerf8, MediaServerToLocal(szSegmentServer), DMUS_APATH_SHARED_STEREOPLUSREVERB));
    CHECKRUN(Music.GetInterface(&ptSegment8));
    CHECKRUN(Music.GetInterface(&ptPath));

    //Try all these repeat values.
    for (i=0; i<AMOUNT(dwRepeatValues); i++)
    {

        //Stop everything and wait a sec.
        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
        Log(FYILOGLEVEL, "Playing and stopping immediately.  Should hear both WAV track and MIDI notes invalidated simultaneously");
        Wait(1000);


        //Set Repeats
        Log(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
        CHECKRUN(ptSegment8->SetRepeats(dwRepeatValues[i]));
         //Play
         CHECKRUN(ptPerf8->PlaySegmentEx( 
		            ptSegment8, 
		            0,
		            NULL,
                    0, 
		            __int64(0),
		            NULL,
		            NULL,
		            ptPath));

        //Wait for segment to start.
        CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL, TRUE));

        //Wait until done
        if (dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            Log(FYILOGLEVEL, "Waiting until segment stops");
            CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment8, NULL, 20000, NULL, TRUE));
        }
        else
        {
            Log(FYILOGLEVEL, "Waiting 5 seconds.");
            Wait(5000);
        }
    }

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetWavePlaybackParams.cpp ===
#include "globals.h"
#include "Help_StatsMemoryUse.h"


/********************************************************************************
Play a wave segment and then send WAVEF_OFF!
/********************************************************************************/
/*
HRESULT Segment8_SetWavePlaybackParams_WAVEF_OFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegment, DWORD dwUnused)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
LPSTR szSegment = (LPSTR)dwSegment;


CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000));
CHECKRUN(Log(FYILOGLEVEL, "Segment %s will play for .5 seconds.", szSegment));
CHECKRUN(Wait(500));
CHECKRUN(ptSegment->SetWavePlaybackParams(DMUS_WAVEF_OFF, DMUS_READAHEAD_MIN));
CHECKRUN(Log(FYILOGLEVEL, "Segment %s should stop immediately", szSegment));
CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, 2000, szSegment));
CHECKRUN(Wait(2000));

//Stop everything anyway.
ptPerf8->StopEx(0, 0, 0);

RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};
*/




struct SETWAVEPLAYBACKPARAMS_TESTCASE
{
    LPSTR szSegment;
    BOOL  bStreaming;
    DWORD dwReadAhead;
    DWORD dwExpectedMemDifference;
};


HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(CtIDirectMusicPerformance8* ptPerf8, SETWAVEPLAYBACKPARAMS_TESTCASE &TestCase);


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingOFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference)
{
    SETWAVEPLAYBACKPARAMS_TESTCASE TestCase = {0};
    TestCase.szSegment = "T:\\DMTest1\\Wav\\Streaming10s.wav";
    TestCase.bStreaming = FALSE;
    TestCase.dwReadAhead = dwReadAhead;
    TestCase.dwExpectedMemDifference = dwExpectedMemDifference;
    return Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(ptPerf8, TestCase);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference)
{
    SETWAVEPLAYBACKPARAMS_TESTCASE TestCase = {0};
    TestCase.szSegment = "T:\\DMTest1\\Wav\\Streaming10s.wav";
    TestCase.bStreaming = TRUE;
    TestCase.dwReadAhead = dwReadAhead;
    TestCase.dwExpectedMemDifference = dwExpectedMemDifference;
    return Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(ptPerf8, TestCase);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingOFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference)
{
    SETWAVEPLAYBACKPARAMS_TESTCASE TestCase = {0};
    TestCase.szSegment = "WAV/CountTo3.wav";
    TestCase.bStreaming = FALSE;
    TestCase.dwReadAhead = dwReadAhead;
    TestCase.dwExpectedMemDifference = dwExpectedMemDifference;
    return Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(ptPerf8, TestCase);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingON(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference)
{
    SETWAVEPLAYBACKPARAMS_TESTCASE TestCase = {0};
    TestCase.szSegment = "WAV/CountTo3.wav";
    TestCase.bStreaming = TRUE;
    TestCase.dwReadAhead = dwReadAhead;
    TestCase.dwExpectedMemDifference = dwExpectedMemDifference;
    return Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(ptPerf8, TestCase);
}



/********************************************************************************
How do we verify whether a segment is streaming or not?
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Generic(CtIDirectMusicPerformance8* ptPerf8, SETWAVEPLAYBACKPARAMS_TESTCASE &TestCase)
{
HRESULT hr = S_OK;
DWORD dwMemDifference = 0;
FLOAT fMaxErrorPercentage = 2.f;
DWORD i = 0;
CtIDirectMusicAudioPath *ptPath = NULL;
CtIDirectMusicSegment *ptSegment = NULL;
BOOL bStabilized = FALSE;
DWORD dwMemBefore = 0;
DWORD dwMemAfter = 0;
CHAR szSegment[MAX_PATH] = {0};
    
CHECKRUN(MediaCopyFile(TestCase.szSegment));
CHECK(strcpy(szSegment, MediaServerToLocal(TestCase.szSegment)));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
CHECKRUN(ptSegment->SetWavePlaybackParams(TestCase.bStreaming ? DMUS_WAVEF_STREAMING : 0, TestCase.dwReadAhead));

//Make sure memory use stays within 1000 bytes for 1 second.  Timeout after 5 seconds.
CHECKRUN(ExpectMemoryToStabilize(MEM_NORMAL, 1000, 1000, 5000, &bStabilized, &dwMemBefore));
CHECKRUN(ExpectMemoryToStabilize(MEM_NORMAL, 1000, 1000, 5000, &bStabilized, &dwMemAfter));
CHECK   (dwMemDifference = dwMemAfter - dwMemBefore);
RELEASE(ptSegment);
RELEASE(ptPath);


if (SUCCEEDED(hr))
{
    double fErrorFactor = CalculateErrorPercentage((double)TestCase.dwExpectedMemDifference, (double)dwMemDifference);        
    Log(FYILOGLEVEL, "Downloading %s wave %s (dwReadAhead = %u) increased memory by %u bytes",
                     TestCase.bStreaming ? "streaming" : "non-streaming",
                     szSegment,
                     TestCase.dwReadAhead,
                     dwMemDifference);
    Log(FYILOGLEVEL, "Expected memory increase was %u bytes.", TestCase.dwExpectedMemDifference);
    Log(FYILOGLEVEL, "Error factor = %g; Max allowed = %g", fErrorFactor, fMaxErrorPercentage);
    if (fErrorFactor > fMaxErrorPercentage)
    {
        Log(ABORTLOGLEVEL, "Error factor = %g exceeded the maximum allowed of %g", fErrorFactor, fMaxErrorPercentage);
        hr = E_FAIL;
    }
}

//Stop everything no mattah what.
ptPerf8->StopEx(0, 0, 0);
return hr;
};


/*
STDMETHOD(SetWavePlaybackParams)    (THIS_ DWORD dwFlags, DWORD dwReadAhead) PURE;

#define DMUS_WAVEF_OFF              0x01       // If wave is playing and this is the off message. 
#define DMUS_WAVEF_STREAMING        0x02       // If wave is streaming. 
#define DMUS_WAVEF_NOINVALIDATE     0x04       // Don't invalidate this wave. 
#define DMUS_WAVEF_NOPREROLL        0x08       // Don't preroll any wave data.   
#define DMUS_WAVEF_IGNORELOOPS      0x20       // Ignore segment looping. 
*/


/********************************************************************************
Play a wave segment and then verify that calling Performance8::Invalidate doesn't turn it off.
/********************************************************************************/
HRESULT Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE(CtIDirectMusicPerformance8* ptPerf8, DWORD bNoInvalidate, DWORD dwUnused2)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
LPSTR szSegment = "T:\\WAV\\Streaming10s.wav";
CHECKRUN(MediaCopyFile("WAV/Streaming10s.wav"));
CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000, szSegment));
CHECKRUN(ptSegment->SetWavePlaybackParams(bNoInvalidate ? DMUS_WAVEF_NOINVALIDATE : 0, DMUS_READAHEAD_MIN));


if (bNoInvalidate)
{
    CHECKRUN(Log(FYILOGLEVEL, "Segment %s will play for 8 seconds", szSegment));
}
else 
{
    CHECKRUN(Log(FYILOGLEVEL, "Segment %s will play for 4 seconds, then be Invalidated", szSegment));
}

CHECKRUN(Wait(4000));
CHECKRUN(ptPerf8->Invalidate(0, 0));
CHECKRUN(Log(FYILOGLEVEL, "Invalidate() has been called %s", bNoInvalidate ? "But wave should continue playing" : "and wave should have stopped"));
CHECKRUN(Wait(4000));

/* THIS PART IS NOT A VALID TEST, BECAUSE IF EVEN IF THE WAVE WERE INVALIDATED, THE SEGMENT WOULD STILL RETURN ISPLAYING.
if (SUCCEEDED(hr))
{
    HRESULT hrPlaying = E_FAIL;
    Wait(4000);
    hrPlaying = ptPerf8->IsPlaying(ptSegment, NULL);

    //Verify we're still playing.
    if (bNoInvalidate)
    {
        if (hrPlaying != S_OK)
        {
            Log(ABORTLOGLEVEL, "ERROR: IsPlaying(%s) returned %s but should have returned S_OK.", szSegment, tdmXlatHRESULT(hrPlaying));
            hr = E_FAIL;        
        }       
    }
    //Verify we've stopped.
    else
    {
        if (hrPlaying != S_FALSE)
        {
            Log(ABORTLOGLEVEL, "ERROR: IsPlaying(%s) returned %s but should have returned S_FALSE.", szSegment, tdmXlatHRESULT(hrPlaying));
            hr = E_FAIL;        
        }       
    }
}
*/

//Stop everything anyway.
ptPerf8->StopEx(0, 0, 0);

RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};




/********************************************************************************
/********************************************************************************/
#define CUTOFF 0
#define NOCUT 1
#define NOCHANGE 2
HRESULT Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS(CtIDirectMusicPerformance8* ptPerf8, DWORD dwBehavior, DWORD dwChange)
{
HRESULT hr = S_OK;
CtIDirectMusicSegment *ptSegment = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
LPSTR szSegment[2] = {"T:\\DMTest1\\Segment8\\SetWavePlaybackParams\\LpWavInLpSegCUTOFF.sgt", "T:\\DMTest1\\Segment8\\SetWavePlaybackParams\\LpWavInLpSegCUTOFF.sgt"};
DWORD dwWaitSeconds = 10;
DWORD dwExpectedBehavior = 0xFFFFFFFF;
MEDIAFILEDESC MediaFileDesc[] = {
                                {"DMusic/DMTest1/Segment8/SetWavePlaybackParams/LpWavInLpSeg/LpWavInLpSegCUTOFF.sgt",  "T:\\DMTest1\\Segment8\\SetWavePlaybackParams\\", COPY_IF_NEWER},
                                {"DMusic/DMTest1/Segment8/SetWavePlaybackParams/LpWavInLpSeg/LpWavInLpSegNOCUT.sgt",  "T:\\DMTest1\\Segment8\\SetWavePlaybackParams\\", COPY_IF_NEWER},
                                {TERMINATE}
                                };

if (NOCHANGE == dwChange)
    dwExpectedBehavior = dwBehavior;
else
    dwExpectedBehavior = dwChange;

CHECKRUN(LoadMedia(MediaFileDesc));
CHECKRUN(dmthLoadSegment(szSegment[dwBehavior], &ptSegment));
if (NOCHANGE != dwChange)
{
    CHECKRUN(ptSegment->SetWavePlaybackParams( (NOCUT == dwChange ) ? DMUS_WAVEF_IGNORELOOPS: 0, DMUS_READAHEAD_MIN));
}
CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));
CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, NULL, NULL, 0, 0, NULL, NULL, ptPath));
CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000, NULL));
CHECKRUN(Log(FYILOGLEVEL, "Wave file should %sbe cut off when the segment loops.", (CUTOFF == dwExpectedBehavior) ? "" : "NOT "));
CHECKRUN(Log(FYILOGLEVEL, "Waiting %d seconds", dwWaitSeconds));
CHECKRUN(Wait(dwWaitSeconds * 1000));
ptPerf8->StopEx(0, 0, 0);
RELEASE(ptSegment);
RELEASE(ptPath);
return hr;
};

#undef NOCHANGE
#undef CUTOFF
#undef NOCUT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_SetStartPoint.cpp ===
#include "globals.h"

#define SEGMENTLENGTH 6  //Both measures and seconds.
#define REPEATS 2


HRESULT Segment8_SetStartPoint_Generic(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegment, MUSIC_TIME mtStartPoint, MUSIC_TIME mtLoopPoint1, MUSIC_TIME mtLoopPoint2);

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_DLS_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtDLS.sgt", DMUS_PPQ*4, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_DLS_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtDLS.sgt", DMUS_PPQ*4 * 2, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_DLS_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtDLS.sgt", DMUS_PPQ*4 * 5, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_DLS_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtDLS.sgt", DMUS_PPQ*4*SEGMENTLENGTH-1, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_DLS_End(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtDLS.sgt", DMUS_PPQ*4*SEGMENTLENGTH, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}



/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_WaveSeg_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtWaveTrack.sgt", DMUS_PPQ*4, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_WaveSeg_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtWaveTrack.sgt", DMUS_PPQ*4 * 2, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_WaveSeg_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtWaveTrack.sgt", DMUS_PPQ*4 * 5, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_WaveSeg_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtWaveTrack.sgt", DMUS_PPQ*4*SEGMENTLENGTH-1, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_WaveSeg_End(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/SegCountMtWaveTrack.sgt", DMUS_PPQ*4*SEGMENTLENGTH, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}



/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Wave_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav", DMUS_PPQ*4, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Wave_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav", DMUS_PPQ*4 * 2, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}

/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Wave_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav", DMUS_PPQ*4 * 5, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Wave_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav", DMUS_PPQ*4*SEGMENTLENGTH-1, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}


/********************************************************************************
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Wave_End(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2)
{
    return Segment8_SetStartPoint_Generic(ptPerf8, "DMusic/DMTest1/Segment8/GetSetStartPoint/CountTo6.wav", DMUS_PPQ*4*SEGMENTLENGTH, (MUSIC_TIME)dwLoopPoint1, (MUSIC_TIME)dwLoopPoint2);
}



/********************************************************************************
A variation of the SetClockTimeLoopPoints test.  Slightly more complex, however.
/********************************************************************************/
HRESULT Segment8_SetStartPoint_Generic(CtIDirectMusicPerformance8* ptPerf8, LPSTR szSegmentServer, MUSIC_TIME mtStartPoint, MUSIC_TIME mtLoopPoint1, MUSIC_TIME mtLoopPoint2)
{
    HRESULT         hr = S_OK;
    DWORD           dwExpectedPlayingTime = 0;
    REFERENCE_TIME  rtExpectedPlayingTime = 0;
    MUSIC_TIME      mtExpectedPlayingTime = 0;
    MUSIC_TIME      mtLoopPoint[2] = {mtLoopPoint1, mtLoopPoint2};
    BOOL            bUsingLoopPoints = (!(-1 == mtLoopPoint[0] && -1 == mtLoopPoint[1]));
    DWORD dwStartTime = 0;
    DWORD dwStopTime  = 0;
    DWORD dwPlayingTime = 0;
    CtIDirectMusicSegment *ptSegment = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    FLOAT fErrorPercent = 0.f;
    FLOAT fMaxErrorPercent = 5.f;
    BOOL bClockTimeSegment = FALSE;
    REFERENCE_TIME rtDummy = 0;
    CHAR szSegment[MAX_PATH] = {0};

    ASSERT(szSegmentServer);
    strcpy(szSegment, MediaServerToLocal(szSegmentServer));    
    CHECKRUN(MediaCopyDirectory(szSegmentServer));

    CHECKRUN(dmthLoadSegment(szSegment, &ptSegment));
    CHECKRUN(ptSegment->GetClockTimeLength(&rtDummy, &bClockTimeSegment));

    //Validate that whatever we loaded is 6 measures long (= 6 seconds).
    if (SUCCEEDED(hr))
    {
        if (bClockTimeSegment)
        {
            ASSERT(rtDummy == SEGMENTLENGTH * 10000000);
        }
        else
        {
            MUSIC_TIME mtLength = 0;
            CHECKRUN(ptSegment->GetLength(&mtLength));
            if (SUCCEEDED(hr))
            {
                ASSERT(mtLength == SEGMENTLENGTH * 4 * DMUS_PPQ);
            }
        }
    }

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath));    
    CHECKRUN(ptSegment->SetRepeats(REPEATS));


    //If we're not using loop points, then they are at the beginning and end of the segment.  Set the data appropriately.
    if (!bUsingLoopPoints)
    {
        mtLoopPoint[0] = 0;
        mtLoopPoint[1] = SEGMENTLENGTH * 4 * DMUS_PPQ;
    }

    if (bUsingLoopPoints)
    {
        CHECKRUN(ptSegment->SetLoopPoints(mtLoopPoint[0], mtLoopPoint[1]));
    }
    CHECKRUN(ptSegment->SetStartPoint(mtStartPoint));
    CHECK   (dwStartTime = timeGetTime());
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment, 0, 0, 0, 0, 0, 0, ptPath));
    CHECKRUN(Log(FYILOGLEVEL, "Set loop points to %u and %u", mtLoopPoint[0], mtLoopPoint[1]));
    
    if (SUCCEEDED(hr))
    {
        //If we're a clock-time segment, or we're starting ahead of our loop point, then the length is fixed at 6 seconds minus wherever we started.
        if (bClockTimeSegment || mtStartPoint >= mtLoopPoint[1])
        {
            mtExpectedPlayingTime = SEGMENTLENGTH * 4 * DMUS_PPQ - mtStartPoint;
            ASSERT(mtExpectedPlayingTime >= 0);
        }
        
        //If we're a music-time segment, then the expected playing time varies based on repeats and start point.
        else
        {
            {
                MUSIC_TIME mtLoopRegion = 0;

                if (bUsingLoopPoints)
                    mtLoopRegion = mtLoopPoint[1] - mtLoopPoint[0];
                else
                    mtLoopRegion = SEGMENTLENGTH * 4 * DMUS_PPQ ;

                //Calculate how long the file SHOULD play given these loop points.  6 + (loop2 - loop1) * repeats
                mtExpectedPlayingTime = SEGMENTLENGTH * 4 * DMUS_PPQ +                   //Total segment time plus
                                        mtLoopRegion * REPEATS -                        //Time of looping region minus
                                        mtStartPoint;                                    //Start time.
            }
        }
    }

    //Wait for segment to start, before we can calculate ms (needs tempo).
    CHECKRUN(ExpectSegmentStart(ptPerf8, ptSegment, NULL, 1000, szSegment));

    //Validate that the tempo is 240 if we're a music_time segment.
    if (SUCCEEDED(hr))
    {
        if (!bClockTimeSegment)
        {
            double pfTempo = 0;
            CHECKRUN(GetTempo(ptPerf8, &pfTempo));
            if (SUCCEEDED(hr))
            {
                if (pfTempo != 240)
                {
                    Log(ABORTLOGLEVEL, "Error: Tempo is %g instead of 240", pfTempo);
                    hr = E_FAIL;
                }
            }
            else
            {
                Log(ABORTLOGLEVEL, "Error: Couldn't get the tempo!!!");
            }
        }
    }

    //Calculate expected milliseconds from MUSIC_TIME.
//    CHECKRUN(ptPerf8->MusicToReferenceTime(mtExpectedPlayingTime, &rtExpectedPlayingTime));
    CHECKRUN(MusicToReferenceTime(ptPerf8, mtExpectedPlayingTime, &rtExpectedPlayingTime));
    if (SUCCEEDED(hr))
    {
        ASSERT(rtExpectedPlayingTime < 0xFFFFFFFF);
        dwExpectedPlayingTime = DWORD(rtExpectedPlayingTime / 10000);        
    }


    CHECKRUN(ExpectSegmentStop(ptPerf8, ptSegment, NULL, dwExpectedPlayingTime * 4, szSegment));
    CHECK   (dwStopTime = timeGetTime());
    
    if (SUCCEEDED(hr))
    {
        dwPlayingTime = dwStopTime - dwStartTime;
        fErrorPercent = 100.f * FLOAT(fabs(LONG(dwPlayingTime - dwExpectedPlayingTime) / FLOAT(dwExpectedPlayingTime)));
        Log(FYILOGLEVEL, "Segment stopped at %ums, expected to stop at %ums.", dwPlayingTime, dwExpectedPlayingTime);
        Log(FYILOGLEVEL, "Error = %.2f%%, maximum allowed error is %.2f%%", fErrorPercent, fMaxErrorPercent);
        if (fErrorPercent > fMaxErrorPercent)
        {
            Log(ABORTLOGLEVEL, "FAILURE!!  %.2f%% exceeds maximum allowed error of %.2f%%!!!", fErrorPercent, fMaxErrorPercent);
            hr = E_FAIL;
        }
    }

    ptPerf8->StopEx(0, 0, 0);    
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegment);

    return hr;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Segment8_Unload.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Segment8_Unload.cpp

Abstract:

	Performs all tests for the IDirectMusicSegment8 api's

Author:

	Dan Haffner (danhaff) 

Revision History:

	16-Mar-2001 robheit
		Added all valid tests

--*/

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "globals.h"

//------------------------------------------------------------------------------
//	Segment8_Unload_BVT
//------------------------------------------------------------------------------
HRESULT 
Segment8_Unload_BVT(
					IN CtIDirectMusicPerformance8*	ptPerf8, 
					DWORD							dwUnused1, 
					DWORD							dwUnused2
					)
/*++

Routine Description:

	BVT tests for IDirectMusicSegment8::Unload

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function Segment8_Unload_BVT())");

    Log(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN Segment8_Download ---");

    return hr;
}

//------------------------------------------------------------------------------
//	Segment8_Unload_Test1_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Unload_Test1_Valid(
						    IN CtIDirectMusicPerformance8*	ptPerf8,
						    DWORD							dwUnused1, 
						    DWORD							dwUnused2
						    )
/*++

Routine Description:

	Tests the unloading of a wave while playing produces silence

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName		= "T:\\DMTest1\\Segment8\\MIDIandWave\\WaveSegment.sgt";

    Log(FYILOGLEVEL, "Calling main test function Segment8_Unload_Test1_Valid())");

	CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

	//Try downloading to both the performance and the audiopath.
	for (downloadToPerf = 0; downloadToPerf < 2 && SUCCEEDED(hr); downloadToPerf++)
	{
		//Load up the media file.
		hr = dmthLoadSegment(szFileName, &ptSegment8);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		// Download the segment
		Log(FYILOGLEVEL, "Downloading to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		hr = ptSegment8->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: Download failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
			continue;
		}

		//Play the segment.
		hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
		}

		// Prompt the user
		else
		{
			Log(FYILOGLEVEL, "You should hear the entire wave file (about 28 seconds)");
			ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);
			Wait(2000);
		    Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			dmthPromptUserTestResults(hr, EXPECT_YES, "Is the wave file still playing?");

			Log(FYILOGLEVEL, "Replaying the segment (you should hear silence)");
			CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath));
			ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);
			dmthPromptUserTestResults(hr, EXPECT_NO, "Do you hear anything?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
		}

		SAFE_RELEASE(ptSegment8);            
	}
	SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_Unload_Test2_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Unload_Test2_Valid(
							IN CtIDirectMusicPerformance8*	ptPerf8,
						    DWORD							dwUnused1, 
						    DWORD							dwUnused2
							)
/*++

Routine Description:

	Verify that playing a MIDI+DLS segment with a wave track and then unloading
	results in silence.

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName		= "T:\\DMTest1\\Segment8\\MIDIandWave\\MIDIandWave.sgt";

    Log(FYILOGLEVEL, "Calling main test function Segment8_Unload_Test2_Valid())");

	CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

	//Try downloading to both the performance and the audiopath.
	for (downloadToPerf = 0; downloadToPerf < 2; downloadToPerf++)
	{
		//Load up the media file.
		hr = dmthLoadSegment(szFileName, &ptSegment8);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		// Download the segment
		Log(FYILOGLEVEL, "Downloading to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		hr = ptSegment8->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: Download failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
			continue;
		}

		//Play the segment.
		hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
		}

		// Prompt the user
		else
		{
			Log(FYILOGLEVEL, "You should hear 2 seconds of audio then the MIDI track should go silent.");
			ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);
			Wait(2000);
		    Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));

			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the MIDI stop and the Wave continue?");
	        CHECKRUN(ptPerf8->StopEx(0, __int64(0), 0));
		}

		SAFE_RELEASE(ptSegment8);            
	}
	SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_Unload_Test3_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Unload_Test3_Valid(
							IN CtIDirectMusicPerformance8*	ptPerf8,
						    DWORD							dwUnused1, 
						    DWORD							dwUnused2
							)
/*++

Routine Description:

	Verify that playing a MIDI+DLS segment and then unloading results in silence

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
	CtIDirectMusicSegment8*		ptSegment8		= NULL;
	CtIDirectMusicAudioPath*	ptPath			= NULL;
	UINT						downloadToPerf	= 0;
    HRESULT						hr				= S_OK;
	BOOL						failed			= FALSE;
	CHAR*						szFileName		= "T:\\DMTest1\\Segment8\\MIDIandWave\\MIDI.sgt";

    Log(FYILOGLEVEL, "Calling main test function Segment8_Unload_Test3_Valid())");

	CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath));

	//Try downloading to both the performance and the audiopath.
	for (downloadToPerf = 0; downloadToPerf < 2; downloadToPerf++)
	{
		//Load up the media file.
		hr = dmthLoadSegment(szFileName, &ptSegment8);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: dmthLoadSegment failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
			continue;
		}

		// Download the segment
		Log(FYILOGLEVEL, "Downloading to %s interface", downloadToPerf ? "Performance8" : "AudioPath");
		hr = ptSegment8->Download(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: Download failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			failed = TRUE;
		    Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			continue;
		}

		//Play the segment.
		hr = ptPerf8->PlaySegmentEx(ptSegment8, 0, NULL, 0, __int64(0), NULL, NULL, ptPath);
		if(FAILED(hr))
		{
			Log(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			failed = TRUE;
		}

		// Prompt the user
		else
		{
			Log(FYILOGLEVEL, "You should hear 2 second of audio then silence");
			ExpectSegmentStart(ptPerf8, ptSegment8, NULL, 5000, NULL);
			Wait(2000);
		    Log(FYILOGLEVEL, "Unloading original segment from %s interface", downloadToPerf ? "Performance8" : "AudioPath");
			CHECKRUN(ptSegment8->Unload(downloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath));
			dmthPromptUserTestResults(hr, EXPECT_YES, "Did the audio stop after 2 seconds?");
		}

		SAFE_RELEASE(ptSegment8);            
	}
	SAFE_RELEASE(ptPath);

    return failed ? E_FAIL : S_OK;
}

//------------------------------------------------------------------------------
//	Segment8_Unload_Test4_Valid
//------------------------------------------------------------------------------
HRESULT 
Segment8_Unload_Test4_Valid(
							IN CtIDirectMusicPerformance8*	ptPerf8,
						    DWORD							dwUnused1, 
						    DWORD							dwUnused2
							)
/*++

Routine Description:

	Verify via timing that unload requires that download reload the instruments 
	(hence they're not cached anywhere)

Arguments:

	IN ptPerf8 -	Performance object
	IN dwUnused1 -	Unused
	IN dwUnused2 -	Unused

Return Value:

	S_OK on success, any other value on failure

--*/
{
    Log(FYILOGLEVEL, "Calling main test function Segment8_Unload_Test4_Valid())");

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\SegmentState8_GetSegment.cpp ===
#include "globals.h"

//BVT
HRESULT SegmentState_GetSegment_BVT1(CtIDirectMusicPerformance8* ptPerf8);

//Valid
HRESULT SegmentState_GetSegment_OldSegmentReturnsNotFound(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT SegmentState_GetSegment_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function SegmentState_GetSegment_BVT())");

    DMTEST_EXECUTE(SegmentState_GetSegment_BVT1(ptPerf8));
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT SegmentState_GetSegment_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Valid test function SegmentState_GetSegment_Valid())");

    DMTEST_EXECUTE(SegmentState_GetSegment_OldSegmentReturnsNotFound(ptPerf8));

    return hr;
};


/********************************************************************************
Simply make sure the segment pointer obtained from a segmentstate matches the original
segment.
********************************************************************************/
HRESULT SegmentState_GetSegment_BVT1(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;

    CtIDirectMusicAudioPath             *ptPath          = NULL;
    CtIDirectMusicSegment               *ptSegment[2]       = {NULL};
    IDirectMusicSegment                 *pSegment[2]       = {NULL};
    CtIDirectMusicSegmentState            *ptSegmentState   = NULL;
    DWORD i = 0;

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&ptPath));
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment[0]));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0],0,0,0,0,&ptSegmentState,0,ptPath));
    CHECKRUN(ptSegmentState->GetSegment(&ptSegment[1]));


    for (i=0; i<2; i++)
    {
        CHECKRUN(ptSegment[i]->GetRealObjPtr(&pSegment[i]));
    }

    if (pSegment[0] != pSegment[1])
    {
        hr = E_FAIL;
        Log(ABORTLOGLEVEL, "SegmentState_GetSegment_BVT1 ERROR: ");
        Log(ABORTLOGLEVEL, "GetSegment returned %08X, original segment was %08X", pSegment[0], pSegment[1]);
    }

   
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
        SAFE_RELEASE(pSegment[i]);
    }

    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptPath);
    return hr;
};



/********************************************************************************
Wait until a segment is done, then get the segment state from it.  Make sure it 
matches the original segment pointer.
********************************************************************************/
HRESULT SegmentState_GetSegment_OldSegmentReturnsNotFound(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;

    CtIDirectMusicAudioPath             *ptPath          = NULL;
    CtIDirectMusicSegment               *ptSegment[2]       = {NULL};
    CtIDirectMusicSegmentState            *ptSegmentState   = NULL;
    DWORD i = 0;
    LPSTR szFilename = "T:\\DMTest1\\Perf8\\SendPMsg\\OnePitch.sgt";
    HRESULT hrCall = S_OK;

    CHECKRUN(MediaCopyFile("DMusic/DMTest1/Perf8/SendPMsg/OnePitch.sgt", "T:\\DMTest1\\Perf8\\SendPMsg\\"));
    CHECKRUN(MediaCopyFile("DLS/Main1.dls",              "T:\\DMTest1\\Perf8\\SendPMsg\\"));

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&ptPath));
    CHECKRUN(dmthLoadSegment(szFilename, &ptSegment[0]));
    CHECKRUN(ptSegment[0]->SetRepeats(0)); 
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment[0],0,0,0,0,&ptSegmentState,0,ptPath));
    
    //Wait til this stops.
    CHECKRUN(ExpectSegmentStart(ptPerf8, NULL, ptSegmentState, 2000, szFilename));
    CHECKRUN(ExpectSegmentStop (ptPerf8, NULL, ptSegmentState, 5000, szFilename));
    //Wait 2 more seconds.
    Log(FYILOGLEVEL, "The music should have stopped by now.");
    Log(FYILOGLEVEL, "Waiting 2 more seconds before getting its SegmentState");
    CountDown(2000, 1000);
       
    if (SUCCEEDED(hr))
    {
        hrCall = ptSegmentState->GetSegment(&ptSegment[1]);
        if (DMUS_E_NOT_FOUND != hrCall)
        {
            hr = E_FAIL;
            Log(ABORTLOGLEVEL, "SegmentState_GetSegment returned %s instead of DMUS_E_NOT_FOUND after segment finished.", tdmXlatHRESULT(hrCall));
        }
    }

    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment[i]);
    }

    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptPath);
    return hr;
};







/********************************************************************************
Simply make sure the segment pointer obtained from a segmentstate matches the original
segment.
********************************************************************************/
HRESULT SegmentState_GetSegment_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD bFull, DWORD dwUnused2)
{
    HRESULT hr = S_OK;

    IDirectMusicPerformance           *pPerf8       = NULL;
    IDirectMusicAudioPath             *pPath          = NULL;
    IDirectMusicSegment               *pSegment[2]       = {NULL};
    IDirectMusicSegmentState            *pSegmentState   = NULL;
    DWORD dwStartTime = 0;
    DWORD dwTimePassed = 0;
    DWORD dwCounter = 0;

    CHECKRUN(ptPerf8->GetRealObjPtr(&pPerf8));
    
    if (!bFull)
    {
        CHECKRUN(pPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&pPath));
        CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &pSegment[0]));
        CHECKRUN(pSegment[0]->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
        CHECKRUN(pPerf8->PlaySegmentEx(pSegment[0],0,0,0,0,&pSegmentState,0,pPath));
    }
    
    dwStartTime = timeGetTime();
    do
    {
        //Allocate stuff inside loop.
        if (bFull)
        {
            CHECKRUN(pPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&pPath));
            CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &pSegment[0]));
            CHECKRUN(pSegment[0]->SetRepeats(DMUS_SEG_REPEAT_INFINITE));
            CHECKRUN(pPerf8->PlaySegmentEx(pSegment[0],0,0,0,0,&pSegmentState,0,pPath));
        }

        CHECKRUN(pSegmentState->GetSegment(&pSegment[1]));
        SAFE_RELEASE(pSegment[1]);

        //Release all the stuff inside the loop.
        if (bFull)
        {
            SAFE_RELEASE(pSegment[0]);
            SAFE_RELEASE(pSegmentState);
            SAFE_RELEASE(pPath);
        }


        dwTimePassed = timeGetTime() - dwStartTime;
        if (dwTimePassed / 1000 > dwCounter)
        {
            Log(FYILOGLEVEL, "%d/%d seconds...", dwCounter, g_TestParams.dwPerfWait);
            dwCounter++;
        }
    }
    while ((dwTimePassed < g_TestParams.dwPerfWait * 1000) && SUCCEEDED(hr));


    //Final release.
    SAFE_RELEASE(pSegment[0]);
    SAFE_RELEASE(pSegmentState);
    SAFE_RELEASE(pPath);
    SAFE_RELEASE(pPerf8);


    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\SegmentState8_GetStartTime.cpp ===
#include "globals.h"

HRESULT SegmentState_GetStartTime_CompareStartTimes(CtIDirectMusicPerformance8* ptPerf8, DWORD dwMaxError);

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT SegmentState_GetStartTime_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function SegmentState_GetStartTime_BVT())");
    DMTEST_EXECUTE(SegmentState_GetStartTime_CompareStartTimes(ptPerf8, 1000));
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT SegmentState_GetStartTime_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling valid test function SegmentState_GetStartTime_Valid())");
    DMTEST_EXECUTE(SegmentState_GetStartTime_CompareStartTimes(ptPerf8, 10));
    return hr;
};



/********************************************************************************
Simply play a segment and make sure it started around the time you called play.
********************************************************************************/
HRESULT SegmentState_GetStartTime_CompareStartTimes(CtIDirectMusicPerformance8* ptPerf8, DWORD dwMaxError)
{
    HRESULT hr = S_OK;

    CtIDirectMusicAudioPath             *ptPath          = NULL;
    CtIDirectMusicSegment               *ptSegment       = {NULL};
    CtIDirectMusicSegmentState          *ptSegmentState   = NULL;
    MUSIC_TIME mtBase = 0;
    MUSIC_TIME mtStartTime = 0;
    MUSIC_TIME mtDiff = 0;
    DWORD dwMS = 0;
    double dblTempo = 0;

    CHECKRUN(ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,64,TRUE,&ptPath));
    CHECKRUN(dmthLoadSegment(g_TestParams.szDefaultMedia, &ptSegment));
    CHECKRUN(ptPerf8->GetTime(NULL, &mtBase));
    CHECKRUN(ptPerf8->PlaySegmentEx(ptSegment,0,0,0,__int64(0),&ptSegmentState,0,ptPath));
    Wait(500);
    CHECKRUN(ptSegmentState->GetStartTime(&mtStartTime));
    CHECKRUN(Log(FYILOGLEVEL, "Time obtained before PlaySegmentEx=%u; SegmentState::StartTime=%u", mtBase, mtStartTime));
    mtDiff = mtStartTime - mtBase;
    CHECKRUN(Log(FYILOGLEVEL, "Difference is %u MUSIC_TIME units", mtDiff));
    CHECKRUN(GetTempo(ptPerf8, &dblTempo));
    dwMS = DWORD(mtDiff * 60 * 1000 / dblTempo / DMUS_PPQ);
    CHECKRUN(Log(FYILOGLEVEL, "Difference is %d ms", dwMS));
    //fError = CalculateErrorPercentage(mtBase, mtStartTime);
    CHECKRUN(Log(FYILOGLEVEL, "Error is %d ms; Maximum allowed is %d ms", dwMS, dwMaxError));
    if (dwMS > dwMaxError)
    {
        Log(ABORTLOGLEVEL, "Exceeded maximum error factor!");
        hr = E_FAIL;
    }


    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptPath);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\SegmentState8_GetObjectInPath1.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "AudioPath_GetObjectInPath1.hpp"




HRESULT SegmentState_GetObjectInPath_BVT1(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface);



/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT SegmentState_GetObjectInPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function SegmentState8_GetObjectInPath())");
    DMTEST_EXECUTE(SegmentState_GetObjectInPath_BVT1(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_SEGMENT,     (GUID *)&GUID_All_Objects, (GUID *)&IID_IDirectMusicSegment8));
    DMTEST_EXECUTE(SegmentState_GetObjectInPath_BVT1(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_PERFORMANCE, (GUID *)&CLSID_DirectMusicPerformance, (GUID *)&IID_IDirectMusicPerformance8));                                             
    DMTEST_EXECUTE(SegmentState_GetObjectInPath_BVT1(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    DMTEST_EXECUTE(SegmentState_GetObjectInPath_BVT1(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    DMTEST_EXECUTE(SegmentState_GetObjectInPath_BVT1(ptPerf8, DMUS_APATH_DYNAMIC_MONO,            DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    return hr;
};

/********************************************************************************
Valid test function.
********************************************************************************/
HRESULT SegmentState_GetObjectInPath_Valid (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling Valid test function Segment8_GetObjectInPath_Valid())");
    return hr;
};


/********************************************************************************
UNIT TEST
IDirectMusicAudioPath::GetObjectInPath()

HISTORY:

PARAMS:
    dwParam3:
        Which test scenario will be run.  Currently there are i scenarios, each
        with different standard paths, objects to retrieve, etc...
    dwParam4         Not used
********************************************************************************/
HRESULT SegmentState_GetObjectInPath_BVT1(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface)
{
    return tmplGetObjectInPath<CtIDirectMusicSegmentState8>(ptPerf8, dwPathType, dwStage, pguidObject, pguidInterface);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\SegmentState8_SetPitch.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
FILE:
    SegmentState_SetPitch.cpp

PURPOSE:
    Contains SegmentState test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "AudioPath_SetPitch.hpp"


#define INTERFACE_NAME CtIDirectMusicSegmentState

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT SegmentState_SetPitch_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling BVT test function SegmentState_SetPitch()");
    DMTEST_EXECUTE(tmplSetPitch_BVT_Direct<INTERFACE_NAME>(ptPerf8, 0, 0));
    return hr;
};



/********************************************************************************
Valid test function.
*******************************************************************************/
HRESULT SegmentState_SetPitch_Valid_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwRange)
{
    HRESULT hr = S_OK;
    Log(FYILOGLEVEL, "Calling main test function SegmentState_SetPitch())");
    DMTEST_EXECUTE(tmplSetPitch_Ramp<INTERFACE_NAME>(ptPerf8, dwTime, dwRange));
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\SegmentState8_SetVolume.cpp ===
#include "globals.h"
#include "AudioPath_SetVolume.hpp"

//lint -e767
#define INTERFACE_NAME CtIDirectMusicSegmentState

/********************************************************************************
BVT test function.
********************************************************************************/
HRESULT SegmentState_SetVolume_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2)
{
    return tmplSetVolume_Direct<INTERFACE_NAME>(ptPerf8);
};



/********************************************************************************
Valid test function.
*******************************************************************************/
HRESULT SegmentState_SetVolume_Valid_Ramp(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwAudioPath)
{
    return tmplSetVolume_Ramp<INTERFACE_NAME>(ptPerf8, dwTime, dwAudioPath);
};

#undef INTERFACE_NAME
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\toolecho.h ===
//-----------------------------------------------------------------------------
// File: ToolEcho.h
//
// Desc: Implements an object based on IDirectMusicTool
//       that provides echoing effects.
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
//lint -e1510
#pragma once

#include <globals.h>


// Maximum echoes is 4 (the number of extra groups opened
// on the port in helper.cpp)
#define MAX_ECHOES	4

class CEchoTool : public IDirectMusicTool
{
public:
	CEchoTool();
    ~CEchoTool();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTool
	HRESULT STDMETHODCALLTYPE Init( IDirectMusicGraph* pGraph );
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType( DWORD* pdwDeliveryType );
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize( DWORD* pdwNumElements );
	HRESULT STDMETHODCALLTYPE GetMediaTypes( DWORD** padwMediaTypes, DWORD dwNumElements) ;
	HRESULT STDMETHODCALLTYPE ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG );
	HRESULT STDMETHODCALLTYPE Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt );
private:
	long	m_cRef;			    // Reference counter
	DWORD	m_dwEchoNum;	    // Number of echoes to generate
	MUSIC_TIME	m_mtDelay;	    // Delay time between echoes
	CRITICAL_SECTION m_CrSec;	// To make SetEchoNum() and SetDelay() thread-safe

public:
// Public class methods
	void	SetEchoNum( DWORD dwEchoNum );
	void	SetDelay( MUSIC_TIME mtDelay );
};

//lint +e1510
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\shlwapiLocal.cpp ===
//===========================================================================
// SHLWAPILOCAL.CPP
//
//  Because there are no good path functions in SHLWAPI, and because
//  that DLL isn't on Win95, and because we have to run our tests on Win95,
//  I have no choice but to copy that code in here and statically link it.
//
//===========================================================================
//#include "dmcs.h"
#include "globals.h"
#include "shlwapilocal.h"



#define TEXTW(quote) L##quote      

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

//danhaff - guessed this myself.
#define CH_WHACK TEXT('\\')

#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#define DBNotNULL(p)    (p)

void NearRootFixups (LPTSTR lpszPath, BOOL fUNC);

#define OFFSETOF(x)     ((UINT)(x))

/*
LPTSTR StrChr (LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

*/


/*
LPTSTR StrChr(LPTSTR lpsz, TCHAR ch)
{
    LPTSTR p = NULL;
    while (*lpsz)
    {
        if (*lpsz == ch)
        {
            p = lpsz;
            break;
        }
        lpsz = CharNext(lpsz);
    }
    return p;
}


BOOL ChrCmp(WORD w1, WORD wMatch)
{
  // Most of the time this won't match, so test it first for speed.
   //
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
        {
          return(w1 != wMatch);
        }
      return FALSE;
    }
  return TRUE;
}



LPSTR FAR PASCAL StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlen(lpStart);

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmp(*(WORD FAR *)lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}


LPCTSTR GetPCEnd(LPCTSTR lpszStart)
{
    LPCTSTR lpszEnd;

    lpszEnd = StrChr((char *)lpszStart, CH_WHACK);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }

    return lpszEnd;
}




//
// Given a pointer to the end of a path component, return a pointer to
// its begining.
// ie return a pointer to the previous backslash (or start of the string).
//
LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd)
{
    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, CH_WHACK);
    if (!lpszBegin)
    {
        lpszBegin = lpszStart;
    }
    return lpszBegin;
}





static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}


BOOL PathIsUNC(LPCTSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}

__inline BOOL PathIsUNC(
    LPWSTR psz)
{
    return (psz[0] == L'\\' && psz[1] == L'\\');
}




BOOL PathIsUNCServer(LPCTSTR pszPath)
{
    if (DBL_BSLASH(pszPath))
    {
        int i = 0;
        LPTSTR szTmp;

        for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = CharNext(szTmp) )
        {
            if (*szTmp==TEXT('\\'))
            {
                i++;
            }
        }

       return (i == 2);
    }

    return FALSE;
}



BOOL PathIsDirectory(LPCTSTR pszPath)
{
    DWORD dwAttribs;

    // SHELL32's PathIsDirectory also handles server/share
    // paths, but calls WNet APIs, which we cannot call.

    if (PathIsUNCServer(pszPath))
    {
        return FALSE;
    }
    else
    {
        dwAttribs = GetFileAttributes(pszPath);
        if (dwAttribs != (DWORD)-1)
            return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
    }

    return FALSE;
}















STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath)
{
//    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsRelative: caller passed bad lpszPath");

    if (!lpszPath || *lpszPath == 0)
    {
        // The NULL path is assumed relative
        return TRUE;
    }


    if (lpszPath[0] == CH_WHACK)
    {
        // Does it begin with a slash ?
        return FALSE;
    }
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':'))
    {
        // Does it begin with a drive and a colon ?
        return FALSE;
    }
    else
    {
        // Probably relative.
        return TRUE;
    }
}














STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath)
{

    if (lpszPath)
    {
        LPTSTR lpszEnd;

        // perf: avoid lstrlen call for guys who pass in ptr to end
        // of buffer (or rather, EOB - 1).
        // note that such callers need to check for overflow themselves.
        int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

        // try to keep us from tromping over MAX_PATH in size.
        // if we find these cases, return NULL.  Note: We need to
        // check those places that call us to handle their GP fault
        // if they try to use the NULL!
        if (ichPath >= (MAX_PATH - 1))
        {
            return(NULL);
        }

        lpszEnd = lpszPath + ichPath;

        // this is really an error, caller shouldn't pass
        // an empty string
        if (!*lpszPath)
            return lpszEnd;

        // Get the end of the source directory
        switch(*CharPrev(lpszPath, lpszEnd))
        {
            case CH_WHACK:
                break;

            default:
                *lpszEnd++ = CH_WHACK;
                *lpszEnd = TEXT('\0');
        }

        return lpszEnd;
    }

    return NULL;
}





STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot)
{
    if (szRoot)
    {
        while(!PathIsRoot(szRoot))
        {
            if (!PathRemoveFileSpec(szRoot))
            {
                // If we didn't strip anything off,
                // must be current drive
                return(FALSE);
            }
        }

        return(TRUE);
    }
    return(FALSE);
}







STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile)
{

    if (lpszDest && (lpszDir || lpszFile))
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR pszT;

        if (!lpszFile || *lpszFile==TEXT('\0'))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty
        }
        else if (lpszDir && *lpszDir && PathIsRelative(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                int iLen = lstrlen(szTemp);

                if ((iLen + lstrlen(lpszFile)) < ARRAYSIZE(szTemp))
                    lstrcpy(pszT, lpszFile);
                else
                    return NULL;
            }
            else
            {
                return NULL;
            }
        }
        else if (lpszDir && *lpszDir && *lpszFile == CH_WHACK && !PathIsUNC(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            // Note that we do not check that an actual root is returned;
            // it is assumed that we are given valid parameters
            PathStripToRoot(szTemp);

            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                // Skip the backslash when copying
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                lstrcpyn(pszT, lpszFile+1, ARRAYSIZE(szTemp) - 1 - (int)(pszT-szTemp));
            }
            else
            {
                return NULL;
            }

        }
        else 
        {
            lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part
        }

        PathCanonicalize(lpszDest, szTemp); // this deals with .. and . stuff
    }

    return lpszDest;
}




STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath)
{

    if (!pPath || !*pPath)
    {
        return FALSE;
    }

    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, TEXT(":\\")))
        {
            // "X:\" case
            return TRUE;
        }
    }

    if ((*pPath == CH_WHACK) && (*(pPath + 1) == 0))
    {
        // "/" or "\" case
        return TRUE;
    }

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = FAST_CharNext(p))
        {
            if (*p == TEXT('\\') && (++cBackslashes > 1))
            {
               // not a bare UNC name, therefore not a root dir 
               return FALSE;
            }
        }
        return TRUE;    // end of string with only 1 more backslash 
                        // must be a bare UNC, which looks like a root dir 
    }
    return FALSE;
}




STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = FAST_CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}



//----------------------------------------------------------
Purpose: Canonicalize a path.

Returns:
Cond:    --
//
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc)
{
    LPCTSTR lpchSrc;
    LPCTSTR lpchPCEnd;      // Pointer to end of path component.
    LPTSTR lpchDst;
    BOOL fUNC;
    int cbPC;


    if (!lpszDst || !lpszSrc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //DEBUGWhackPathBuffer(lpszDst, MAX_PATH);
    
    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
    {
        // REVIEW: this should just return the count
        lpchPCEnd = GetPCEnd(lpchSrc);
        cbPC = (int) (lpchPCEnd - lpchSrc)+1;

        if (cbPC == 1 && *lpchSrc == CH_WHACK)                                      // Check for slashes.
        {
            // Just copy them.
            *lpchDst = CH_WHACK;
            lpchDst++;
            lpchSrc++;
        }
        else if (cbPC == 2 && *lpchSrc == TEXT('.'))                                // Check for dots.
        {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == TEXT('\0'))
            {
                lpchDst--;
                lpchSrc++;
            }
            else
            {
                lpchSrc += 2;
            }
        }
        else if (cbPC == 3 && *lpchSrc == TEXT('.') && *(lpchSrc + 1) == TEXT('.')) // Check for dot dot.
        {
            // make sure we aren't already at the root
            if (!PathIsRoot(lpszDst))
            {
                // Go up... Remove the previous path component.
                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1);
            }
            else
            {
                // When we can't back up, remove the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == CH_WHACK)
                {
                    lpchSrc++;
                }
            }

            // skip ".."
            lpchSrc += 2;       
        }
        else                                                                        // Everything else
        {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cbPC);
            lpchDst += cbPC - 1;
            lpchSrc += cbPC - 1;
        }

        // Keep everything nice and tidy.
        *lpchDst = TEXT('\0');
    }

    // Check for weirdo root directory stuff.
    NearRootFixups(lpszDst, fUNC);

    return TRUE;
}



//
// Fix up a few special cases so that things roughly make sense.
//
void NearRootFixups (LPTSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[0] = CH_WHACK;
        lpszPath[1] = TEXT('\0');
    }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':') && lpszPath[2] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[2] = TEXT('\\');
        lpszPath[3] = TEXT('\0');
    }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == TEXT('\\') && lpszPath[1] == TEXT('\0'))
    {
        // Fix up.
        //lpszPath[0] = TEXT('\\'); // already checked in if guard
        lpszPath[1] = TEXT('\\');
        lpszPath[2] = TEXT('\0');
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolGraph_GetTool.cpp ===
#include <globals.h>

HRESULT ToolGraph_GetTool( CtIDirectMusicPerformance8* ptPerf8, LPDWORD pdwPChannels, DWORD cPChannels, LONG lIndex, DWORD dwNum )
{
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	IDirectMusicTool** ppTools = NULL;

	IDirectMusicTool* pTool = NULL;

	ppTools = new IDirectMusicTool*[dwNum];

	if ( NULL == ppTools )
		return E_OUTOFMEMORY;

	CHECKRUN( dmthCreateToolGraph( ptPerf8, &pGraph ) );
	CHECKALLOC( pGraph );

	for ( DWORD i = 0; i < dwNum && SUCCEEDED( hr ); i++ )
	{
		CHECKRUN( CreateTestTool( ppTools + i ) );
		CHECKALLOC( ppTools + i );

		CHECKRUN( pGraph->InsertTool( ppTools[i], pdwPChannels, cPChannels, lIndex ) );
	}

	for (i = 0; i < dwNum && SUCCEEDED( hr ); i++ )
	{
		CHECKRUN( pGraph->GetTool( 0, &pTool ) );
		CHECKALLOC( pTool );
	}

	for (i = 0; i < dwNum; i++ )
	{
		SAFE_RELEASE( ppTools[i] );
	}

	delete [] ppTools;

	RELEASE( pTool );
	RELEASE( pGraph );

	return hr;
}




HRESULT ToolGraph_GetTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

//	return hr;
	return E_NOTIMPL;
}



HRESULT ToolGraph_GetTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, 0, 1 ) );
	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, 1, 1 ) );
	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, -1,1 ) );

	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, 0, 10 ) );
	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, 1, 10 ) );
	DMTEST_EXECUTE( ToolGraph_GetTool( ptPerf8, NULL, 0, -1,10 ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\tests.h ===
#pragma once



//BVT tests

    //DANHAFF
    HRESULT AudioPath_Activate_BVT(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_GetObjectInPath_BVT           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_SetVolume_BVT                 (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_SetPitch_BVT                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_AddNotificationType_BVT    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_AllocPMsg_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_ClonePMsg_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_CloseDown_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_CreateStandardAudioPath_BVT(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_SendPMsg_BVT               (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_FreePMsg_BVT               (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetParamEx_BVT             (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetGlobalParam_BVT         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetNotificationPMsg_BVT    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetSegmentState_BVT        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_GetTime_BVT_ReferenceTime  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwErrorMargin, DWORD dwUnused2);
    HRESULT Performance8_GetTime_BVT_MusicTime      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwErrorMargin, DWORD dwUnused2);
    HRESULT Performance8_GetTime_Valid_InOrder      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_GetTime_BVT                (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetSetDefaultAudioPath_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_IsPlaying_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_InitAudio_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_MusicToReferenceTime_BVT   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_ReferenceToMusicTime_BVT   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_BVT          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_Release_BVT                (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_RemoveNotificationType_BVT (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_SetGlobalParam_BVT         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_StopEx_BVT                 (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_RelativeVolume(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


    HRESULT Segment8_Download_BVT                   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_SetRepeats_BVT                 (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Unload_BVT                     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_GetLength_BVT                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_SetLength_BVT                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Compose_BVT                    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


    HRESULT SegmentState_GetObjectInPath_BVT       (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_GetSegment_BVT             (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_GetStartTime_BVT           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_SetVolume_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime, DWORD dwUnused2);
    HRESULT SegmentState_SetPitch_BVT               (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT SegmentState_GetSegment_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD bFull, DWORD dwUnused2);


    HRESULT Script_InitBVT                     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                              
    HRESULT Script_CallRoutineBVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                     
    HRESULT Script_SetVariableNumberBVT        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                 
    HRESULT Script_GetVariableNumberBVT        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                               
    HRESULT Script_SetVariableObjectBVT        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                        
    HRESULT Script_GetVariableObjectBVT        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    
    
    HRESULT Loader_ClearCache_BVT              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_GetObject_BVT               (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_SetObject_BVT               (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_SetSearchDirectory_BVT      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_ReleaseObjectByUnknown_BVT  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_LoadObjectFromFile_BVT      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

// ToolGraph tests
	HRESULT ToolGraph_InsertTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_StampPMsg_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_RemoveTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_GetTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);




//Valid Tests
    //DANHAFF
    HRESULT SampleTest                              (void);


    //ADPCM
    HRESULT ADPCM_TestWaveSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwDirName, DWORD dwBaseName);
    HRESULT ADPCM_TestMusicSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwDirName, DWORD dwBaseName);


    //HRESULT AudioPath_Activate_Valid                (CtIDirectMusicPerformance8* ptPerf8);
    HRESULT AudioPath_Activate_Valid_Many(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwPathType, DWORD dwCount);
    HRESULT AudioPath_Activate_Valid_Sharing(CtIDirectMusicPerformance8 *ptPerf8, DWORD bShared, DWORD dwUnused2);
    HRESULT AudioPath_Activate_Valid_OnAndOff(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


    //HRESULT AudioPath_GetObjectInPath_Valid         (CtIDirectMusicPerformance8* ptPerf8);
    HRESULT AudioPath_GetObjectInPath_Valid_GetAll(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_GetObjectInPath_Valid_Traverse(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPathType, DWORD dwPathDefinition);
    HRESULT AudioPath_GetObjectInPath_Valid_SimplyGetBuffer(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


    //BUFFER Tests for GetObjectInPath.
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetPosition_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetAllParameters(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeAngles(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOrientation_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetConeOutsideVolume(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetMaxDistance_InsideSource(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetMinDistance_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetMinDistance_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetMode(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetPosition_BoundaryCases(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetPosition_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetVelocity(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_INFINITY_Bug(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetFrequency_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetFrequency_Range(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetVolume_Listening(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_GetObjectInPath_3DBuf_SetVolume_Range(CtIDirectMusicPerformance8* ptPerf8, DWORD dwPath, DWORD dwBuffer);
    HRESULT AudioPath_SetVolume_Valid_Ramp          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime,    DWORD dwRange);
    HRESULT AudioPath_SetVolume_Valid_Ind           (CtIDirectMusicPerformance8* ptPerf8, DWORD bWave, DWORD dwUnused2);

    HRESULT AudioPath_SetPitch_Valid_Ramp           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_SetPitch_Valid_Immediate      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT DLS_TestSegment(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentName, DWORD dwUnused2);

    ////////////// PERFORMANCE8 ///////////////
    HRESULT Performance8_AddNotificationType_NoRestart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes);
    HRESULT Performance8_AddNotificationType_Restart  (CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes);

    HRESULT Performance8_AllocPMsg_Valid            (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_ClonePMsg_Valid            (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_CloseDown_WhilePlaying(CtIDirectMusicPerformance8* ptPerf8, DWORD dwScenario, DWORD dwUnused2);

    HRESULT Performance8_CloseDown_Valid            (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_CreateStandardAudioPath_AllCombos      (CtIDirectMusicPerformance8* ptPerf8, DWORD bAllCombos, DWORD dwUnused2);
    HRESULT Performance8_Play2AudioPaths                        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_CreateStandardAudioPath_Wait           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_CreateStandardAudioPath_LimitPChannels (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    
    HRESULT Performance8_PMsg_Valid_Tempos                      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PMsg_Valid_Transpose                   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PMsg_Valid_PitchBend(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PMsg_Valid_Transpose_ChangeSong(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PMsg_Crossfade(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);



    HRESULT Performance8_FreePMsg_Valid             (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetParamEx_Valid           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetGlobalParam_Valid       (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetNotificationPMsg_Valid  (CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetSegmentState_Valid      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetTime_Valid              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_GetSetDefaultAudioPath_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_IsPlaying_Valid            (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_InitAudio_Valid            (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_MusicToReferenceTime_Repeat     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_MusicToReferenceTime_TempoChange(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_PlaySegmentEx_Valid        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_PlaySegment_StartTime_Start(CtIDirectMusicPerformance8      *ptPerf8, DWORD mtRel, DWORD rtRel);
    HRESULT Performance8_PlaySegment_StartTime_Transition(CtIDirectMusicPerformance8 *ptPerf8, DWORD mtRel, DWORD rtRel);
    HRESULT Performance8_PlaySegment_TransitionType(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwFlags, DWORD dwUnused2);
    HRESULT Performance8_PlaySegment_TransPreAlign(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwFlags, DWORD dwUnused2);



    HRESULT Performance8_PlaySegmentEx_Valid_Play   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime);
    HRESULT Performance8_PlaySegmentEx_Valid_PlayBeforeDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime);
    HRESULT Performance8_PlaySegment_Latency        (CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegment_Latency_Interactive(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_Valid_DelayDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwDelay);
    HRESULT Performance8_PlaySegmentEx_Valid_SetFrequency(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime);
    HRESULT Performance8_PlaySegmentEx_QuickStartStop(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_QuickStartStopOneFile(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    
    //Allow you to set repeats.
    HRESULT Performance8_PlaySegmentEx_Segment_WaitForEnd      (CtIDirectMusicPerformance8 *ptPerf8, DWORD dwSegmentName, DWORD dwRepeats);
    HRESULT Performance8_PlaySegmentEx_Segment_WaitFor10Seconds(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwSegmentName, DWORD dwRepeats);
    HRESULT Performance8_PlaySegmentEx_Multiple_NoRepeats(CtIDirectMusicPerformance *ptPerf8, DWORD szSegmentName, DWORD dwCount);
    HRESULT Performance8_PlaySegmentEx_Multiple_OneRepeat(CtIDirectMusicPerformance *ptPerf8, DWORD szSegmentName, DWORD dwCount);
    HRESULT Performance8_PlaySegmentEx_QuickStartStop_ADPCM(CtIDirectMusicPerformance *ptPerf8,        DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_QuickStartStop_WaveFiles(CtIDirectMusicPerformance *ptPerf8,    DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_QuickStartStop_WaveSegments(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_CompareWithDSound(CtIDirectMusicPerformance *ptPerf8,           DWORD dwPath,    DWORD dwWave);
    HRESULT Performance8_PlaySegmentEx_Timing(CtIDirectMusicPerformance *ptPerf8,                      DWORD dwSegment, DWORD dwExpectedTime);

    HRESULT Performance8_PlaySegmentEx_StartStopStreaming_PerfMem(CtIDirectMusicPerformance *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_ClockTime_Looping(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSuffix, DWORD dwType);

    HRESULT Performance8_PlaySegmentEx_Leak         (CtIDirectMusicPerformance *ptPerf8, DWORD dwSegment1, DWORD dwSegment2);
    HRESULT Performance8_PlaySegmentEx_AudioPath    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwUnused2);

    HRESULT Performance8_PlaySegmentEx_AudioPath_1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback);
    HRESULT Performance8_PlaySegmentEx_AudioPath_2(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback);
    HRESULT Performance8_PlaySegmentEx_AudioPath_4(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback);
    HRESULT Performance8_PlaySegmentEx_AudioPath_6(CtIDirectMusicPerformance8* ptPerf8, DWORD dwType, DWORD dwContentPlayback);
    HRESULT Performance8_PlaySegmentEx_MunchPerf(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_AntzLooping(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


    HRESULT Performance8_ReferenceToMusicTime_TempoChange (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_Release_Valid              (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_RemoveNotificationType_Valid(CtIDirectMusicPerformance8* ptPerf8,DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_SetGlobalParam_Valid       (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_StopEx_NoSegments(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_StopEx_1Segment_DLS  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1,   DWORD dwUnused2);
    HRESULT Performance8_StopEx_1Segment_Wave (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1,   DWORD dwUnused2);
    HRESULT Performance8_StopEx_2Segments_DLS (CtIDirectMusicPerformance8* ptPerf8, DWORD bSinglePath, DWORD bSingleSegment);
    HRESULT Performance8_StopEx_2Segments_Wave(CtIDirectMusicPerformance8* ptPerf8, DWORD bSinglePath, DWORD bSingleSegment);
    HRESULT Performance8_StopEx_TimePast  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_StopEx_TimeFuture(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_StopEx_NoDoWork(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    //////////////// SEGMENT ///////////////////////

    HRESULT Segment8_AddNotificationType_NoRestart(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes);
    HRESULT Segment8_AddNotificationType_Restart  (CtIDirectMusicPerformance8 *ptPerf8, DWORD dwAddNotificationTypes, DWORD dwRemNotificationTypes);

    HRESULT Segment8_Download_Test1_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
    HRESULT Segment8_Download_Test2_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
    HRESULT Segment8_Download_Test3_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
    HRESULT Segment8_Download_Test4_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
    HRESULT Segment8_Download_PreCache(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFile1, DWORD dwFile2);
    HRESULT Segment8_Download_PreCache_Multiple01(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Download_PreCache_Multiple02(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Unload_Test1_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Unload_Test2_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Unload_Test3_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_Unload_Test4_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
	HRESULT Segment8_SetRepeats_Test1_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
	HRESULT Segment8_SetRepeats_Test2_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
	HRESULT Segment8_SetRepeats_Test3_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
	HRESULT Segment8_SetRepeats_Test4_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
	HRESULT Segment8_SetRepeats_Test5_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
	HRESULT Segment8_SetRepeats_Test6_Valid(CtIDirectMusicPerformance8*, DWORD, DWORD);
    HRESULT Segment8_GetLength_Valid                (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_SetLength_Test1_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_SetLength_Range(CtIDirectMusicPerformance8* ptPerf8, DWORD dwMusicTimeLength, DWORD dwUnused2);
    HRESULT Segment8_Compose_Valid                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_GetObjectInPath_Valid     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_GetStartTime_Valid         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_GetSegment_Valid           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT SegmentState_SetVolume_Valid_Ramp       (CtIDirectMusicPerformance8* ptPerf8, DWORD dwTime   , DWORD dwRange);
    HRESULT SegmentState_SetPitch_Valid_Ramp        (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Segment8_GetClockTimeLength_VerifySegmentLength(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentName, DWORD dwExpectedLength);
    HRESULT Segment8_GetClockTimeLength_GetSet(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegmentName, DWORD dwExpectedLength);
    
//    HRESULT Segment8_SetClockTimeLoopPoints_SetsClockTimeMode(CtIDirectMusicPerformance8* ptPerf8,  DWORD dwUnused1, DWORD dwUnused2);
//    HRESULT Segment8_SetClockTimeLoopPoints_KeepsLength(CtIDirectMusicPerformance8* ptPerf8,        DWORD dwUnused1, DWORD dwUnused2);
//    HRESULT Segment8_SetClockTimeLoopPoints_DLS     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
//    HRESULT Segment8_SetClockTimeLoopPoints_WaveSeg (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
//    HRESULT Segment8_SetClockTimeLoopPoints_Wave    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);

    //HRESULT Segment8_GetClockTimeLoopPoints_SetAndGet(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    
    HRESULT Segment8_SetStartPoint_DLS_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_DLS_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_DLS_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_DLS_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1,DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_DLS_End     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);

    HRESULT Segment8_SetStartPoint_WaveSeg_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_WaveSeg_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_WaveSeg_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_WaveSeg_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1,DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_WaveSeg_End     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);

    HRESULT Segment8_SetStartPoint_Wave_1Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_Wave_2Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_Wave_5Measure(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_Wave_EndMinus1(CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1,DWORD dwLoopPoint2);
    HRESULT Segment8_SetStartPoint_Wave_End     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwLoopPoint1, DWORD dwLoopPoint2);

    HRESULT Segment8_GetStartPoint_Generic(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegment, DWORD dwStartPointExpected);

    HRESULT Segment8_SetWavePlaybackParams_WAVEF_OFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwSegment, DWORD dwUnused);
    HRESULT Segment8_GetRepeats_Programmatic(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingOFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference);
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_Streaming10s_StreamingON (CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference);
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingOFF(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference);
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_STREAMING_CountTo3_StreamingON(CtIDirectMusicPerformance8* ptPerf8, DWORD dwReadAhead, DWORD dwExpectedMemDifference);
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_NOINVALIDATE(CtIDirectMusicPerformance8* ptPerf8, DWORD bNoInvalidate, DWORD dwUnused2);
    HRESULT Segment8_SetWavePlaybackParams_WAVEF_IGNORELOOPS(CtIDirectMusicPerformance8* ptPerf8, DWORD bIgnoreLoops, DWORD dwUnused2);

    HRESULT Segment8_GetRepeats_Content(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRepeats, DWORD dwUnused2);





    ////////////// SCRIPT ///////////////
    HRESULT Script_Init_Valid                       (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                              
    HRESULT Script_CallRoutine_Valid                (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                     
    HRESULT Script_CallRoutine_Valid_TransitionTempo(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_SetVariableNumber_Valid          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                 
    HRESULT Script_GetVariableNumber_Valid          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                               
    HRESULT Script_SetVariableObject_Valid          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);                                                        
    HRESULT Script_GetVariableObject_Valid          (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_CallRoutine_Valid_TestScript           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected);
    HRESULT Script_CallRoutine_Valid_TestScript_Transition(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected);
    HRESULT Script_CallRoutine_Valid_TestScript_TransSimple(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected);
    HRESULT Script_CallRoutine_Valid_TestScript_SegBoundaries(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected);
    HRESULT Script_CallRoutine_Invalid_TestScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD hrExpected);
    HRESULT Script_CallRoutine_Valid_PlayOneScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwScript, DWORD dwRoutine);
    HRESULT Script_SetVariableString_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_GetVariableString_Valid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    ////////////// LOADER ///////////////
    HRESULT Loader_CollectGarbage_Valid             (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_ClearCache_Valid                 (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_GetObject_Valid                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_GetObject_IStream_Test           (CtIDirectMusicPerformance8* ptPerf8, DWORD dwFileName, DWORD dwUnused2);
    HRESULT Loader_GetObject_IStream_Streaming      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwFileName, DWORD dwUnused2);

    HRESULT Loader_SetObject_Valid                  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_SetSearchDirectory_Valid         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_ReleaseObjectByUnknown_Valid     (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_LoadObjectFromFile_Valid         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_LoadObjectFromFile_Valid_AbsolutePath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2);
    HRESULT Loader_LoadObjectFromFile_Valid_Bug7707(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader_LoadObjectFromFile_Container_ByFileName(CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwFileName);
    HRESULT Loader_LoadObjectFromFile_Container_ByName    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwName);
    HRESULT Loader_LoadObjectFromFile_Container_ByGUID    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwGUID);
    HRESULT Loader_LoadObjectFromFile_Container_ByFileName_Script(CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwFileName);
    HRESULT Loader_LoadObjectFromFile_Container_ByName_Script    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwName);
    HRESULT Loader_LoadObjectFromFile_Container_ByGUID_Script    (CtIDirectMusicPerformance8* ptPerf8, DWORD dwContainer, DWORD dwGUID);


    ////////////// TOOLGRAPH ///////////////
	HRESULT ToolGraph_InsertTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_StampPMsg_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_RemoveTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
	HRESULT ToolGraph_GetTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Sleep_Zero(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwTime);



//Invalid Tests
    //DANHAFF
    HRESULT AudioPath_GetObjectInPath_Invalid   (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT AudioPath_SetVolume_Invalid         (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader8_LoadObjectFromFile_Invalid  (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader8_LoadObjectFromFile_Invalid_GMRef(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2);
    HRESULT Loader8_LoadObjectFromFile_TooLongPath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Loader8_LoadObjectFromFile_Invalid_Content(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_AllocPMsg_Invalid      (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Performance8_IsPlaying_Invalid(CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Performance8_InitAudio_Fatal (CtIDirectMusicPerformance8* ptPerf8, DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_CallRoutine_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_GetVariableNumber_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_GetVariableObject_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_Init_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_SetVariableObject_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);
    HRESULT Script_SetVariableNumber_Fatal( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2);

    HRESULT Script_CallRoutine_Invalid_NoAudioPath(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD dwUnused);
    HRESULT Fail_On_Purpose(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwUnused1, DWORD dwUnused2);


//Performance (memory) tests
    HRESULT Loader_GetObject_PerfMem_DownloadWaveLeak(CtIDirectMusicPerformance8* ptPerf8, DWORD bStreaming, DWORD dwUnused2);
    HRESULT Loader_GetObject_PerfMem_Type_Full(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2);
    HRESULT Loader_GetObject_PerfMem_Type_Partial(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD dwUnused2);
    HRESULT Performance8_PlaySegmentEx_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD dwFilename, DWORD bFull);
    HRESULT Performance8_CreateStandardAudioPath_PerfMem_Bug10385(CtIDirectMusicPerformance8* ptPerf8, DWORD dwTempoFactor, DWORD dwAudioPath);

    HRESULT Script_CallRoutine_PerfMem1_Partial( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptName, DWORD dwRoutineIndex);
    HRESULT Script_CallRoutine_PerfMem1_Full( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwScriptName, DWORD dwRoutineIndex);
    HRESULT Script_CallRoutine_PerfMem_TestScript(CtIDirectMusicPerformance8* ptPerf8, DWORD dwRoutineNumber, DWORD bFull);
    HRESULT Performance8_CreateStandardAudioPath_PerfMem(CtIDirectMusicPerformance8* ptPerf8, DWORD bFull, DWORD dwUnused2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolEcho.cpp ===
//-----------------------------------------------------------------------------
// File: ToolEcho.cpp
//-----------------------------------------------------------------------------

#include <globals.h>



//-----------------------------------------------------------------------------
// Name: CEchoTool::CEchoTool()
// Desc: 
//-----------------------------------------------------------------------------
CEchoTool::CEchoTool()
{
    m_cRef = 1;                 // Set to 1 so one call to Release() will free this
    m_dwEchoNum = 3;            // Default to 3 echoes per note
    m_mtDelay = DMUS_PPQ / 2;   // Default to 8th note echoes
    InitializeCriticalSection(&m_CrSec);
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::~CEchoTool()
// Desc: 
//-----------------------------------------------------------------------------
CEchoTool::~CEchoTool()
{
    DeleteCriticalSection(&m_CrSec);
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::QueryInterface()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP CEchoTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::AddRef()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEchoTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::Release()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEchoTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::Init()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::Init( IDirectMusicGraph* pGraph )
{
    // This tool has no need to do any type of initialization.
    return E_NOTIMPL;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::GetMsgDeliveryType()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::GetMsgDeliveryType( DWORD* pdwDeliveryType )
{
    // This tool wants messages immediately.
    // This is the default, so returning E_NOTIMPL
    // would work. The other method is to specifically
    // set *pdwDeliveryType to the delivery type, DMUS_PMSGF_TOOL_IMMEDIATE,
    // DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
    
    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::GetMediaTypeArraySize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::GetMediaTypeArraySize( DWORD* pdwNumElements )
{
    // This tool only wants note messages, patch messages, sysex, and MIDI messages, so set
    // *pdwNumElements to 4.
    
    *pdwNumElements = 4;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::GetMediaTypes()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::GetMediaTypes( DWORD** padwMediaTypes, 
                                                    DWORD dwNumElements )
{
    // Fill in the array padwMediaTypes with the type of
    // messages this tool wants to process. In this case,
    // dwNumElements will be 3, since that is what this
    // tool returns from GetMediaTypeArraySize().
    
    if( dwNumElements == 4 )
    {
        // Set the elements in the array to DMUS_PMSGT_NOTE,
        // DMUS_PMSGT_MIDI, and DMUS_PMSGT_PATCH
        (*padwMediaTypes)[0] = DMUS_PMSGT_NOTE;
        (*padwMediaTypes)[1] = DMUS_PMSGT_MIDI;
        (*padwMediaTypes)[2] = DMUS_PMSGT_PATCH;
        (*padwMediaTypes)[3] = DMUS_PMSGT_SYSEX;
        return S_OK;
    }
    else
    {
        // This should never happen
        return E_FAIL;
    }
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::ProcessPMsg()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    DWORD dwCount;
    DWORD dwEchoNum;
    MUSIC_TIME mtDelay;
    
    // SetEchoNum() and SetDelay() use these member variables,
    // so use a critical section to make them thread-safe.
    EnterCriticalSection(&m_CrSec);
    dwEchoNum = m_dwEchoNum;
    mtDelay = m_mtDelay;
    LeaveCriticalSection(&m_CrSec);
    
    // Returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(( NULL == pPMsg->pGraph ) ||
        FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
    {
        return DMUS_S_FREE;
    }

  
    // The Tool is set up to only receive messages of types
    // DMUS_PMSGT_NOTE, DMUS_PMSGT_MIDI, DMUS_PMSGT_SYSEX, or DMUS_PMSGT_PATCH
    // We use the DX8 ClonePMsg method to make a copy of the pmsg and
    // send it to a pchannel in the next pchannel group. 
    // If it's a note, we also doctor the velocity.
    IDirectMusicPerformance8 *pPerf8;
    if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
    {
        for( dwCount = 1; dwCount <= dwEchoNum; dwCount++ )
        {
            DMUS_PMSG *pClone;
            if( SUCCEEDED( pPerf8->ClonePMsg( pPMsg,&pClone)))
            {
                // Add to the time of the echoed note
                pClone->mtTime += (dwCount * mtDelay);
                if (pPMsg->dwType == DMUS_PMSGT_NOTE )
                {
                    DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG*)pPMsg;
                    DMUS_NOTE_PMSG *pCloneNote = (DMUS_NOTE_PMSG*)pClone;
                    // Reduce the volume of the echoed note
                    // percentage of reduction in velocity increases with each echo
                    pCloneNote->bVelocity = (BYTE) (pNote->bVelocity - 
                        ((pNote->bVelocity * (dwCount * 15))/100));
                }
                // Set the note so only MUSIC_TIME is valid.
                // REFERENCE_TIME will be recomputed inside
                // SendPMsg()
                pClone->dwFlags = DMUS_PMSGF_MUSICTIME;
                pClone->dwPChannel = pPMsg->dwPChannel + 
                    (16*dwCount);
                // Queue the echoed PMsg
                pPerf->SendPMsg(pClone );
            }
        }
        pPerf8->Release();
    }


    // Return DMUS_S_REQUEUE so the original message is requeued
    return DMUS_S_REQUEUE;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::Flush()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CEchoTool::Flush( IDirectMusicPerformance* pPerf, 
                                            DMUS_PMSG* pDMUS_PMSG,
                                            REFERENCE_TIME rt)
{
    // This tool does not need to flush.
    return E_NOTIMPL;
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::SetEchoNum()
// Desc: 
//-----------------------------------------------------------------------------
void CEchoTool::SetEchoNum( DWORD dwEchoNum )
{
    // ProcessPMsg() uses m_dwEchoNum, so use a critical
    // section to make it thread-safe.
    if( dwEchoNum <= MAX_ECHOES )
    {
        EnterCriticalSection(&m_CrSec);
        m_dwEchoNum = dwEchoNum;
        LeaveCriticalSection(&m_CrSec);
    }
}




//-----------------------------------------------------------------------------
// Name: CEchoTool::SetDelay()
// Desc: 
//-----------------------------------------------------------------------------
void CEchoTool::SetDelay( MUSIC_TIME mtDelay )
{
    // ProcessPMsg() uses m_mtDelay, so use a critical
    // section to make it thread-safe.
    EnterCriticalSection(&m_CrSec);
    m_mtDelay = mtDelay;
    LeaveCriticalSection(&m_CrSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolGraph_StampPMsg.cpp ===
#include <globals.h>



HRESULT ToolGraph_StampPMsg_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
HRESULT hr = S_OK;

//return hr;
return E_NOTIMPL;
};


HRESULT ToolGraph_StampPMsg_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	IDirectMusicGraph* pGraph = NULL;
	IDirectMusicTool* pTool = NULL;

    CICMusic Music;

    CHECKRUN(Music.Init(ptPerf8, g_TestParams.szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB));


	CHECKRUN( dmthCreateToolGraph( ptPerf8, &pGraph ) );
	CHECKALLOC( pGraph );

    pTool = new CEchoTool;

//	CHECKRUN( CreateTestTool( &pTool ) );
	CHECKALLOC( pTool );

	CHECKRUN( pGraph->InsertTool( pTool, NULL, 0, 0 ) );

/*
    MUSIC_TIME mtTime = 0;
    CHECKRUN(ptPerf8->GetTime(NULL, &mtTime));
    DMUS_TEMPO_PMSG* pTempo = NULL;
	CHECKRUN( ptPerf8->AllocPMsg( sizeof( DMUS_TEMPO_PMSG), (DMUS_PMSG**)&pTempo ) );
	CHECKALLOC( pTempo );
    pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
    pTempo->dblTempo = 120; 
    pTempo->mtTime = mtTime;
    pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
    pTempo->dwType = DMUS_PMSGT_TEMPO;
	CHECKRUN( pGraph->StampPMsg( (DMUS_PMSG*)pTempo ) );
	CHECKRUN( ptPerf8->SendPMsg( (DMUS_PMSG*)pTempo ) );
*/


	Wait( 5000 );

//	CHECKRUN( ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo ) );

	ptPerf8->SetDefaultAudioPath(NULL);
    if (pGraph && pTool)
    {
        pGraph->RemoveTool(pTool);
    }
	SAFE_RELEASE( pTool );
	SAFE_RELEASE( pGraph );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolGraph_InsertTool.cpp ===
#include <globals.h>

HRESULT ToolGraph_InsertTool( CtIDirectMusicPerformance8* ptPerf8, LPDWORD pdwPChannels, DWORD cPChannels, LONG lIndex, DWORD dwNum )
{
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	IDirectMusicTool** ppTools = NULL;

	ppTools = new IDirectMusicTool*[dwNum];

	if ( NULL == ppTools )
		return E_OUTOFMEMORY;

	CHECKRUN( dmthCreateToolGraph( ptPerf8, &pGraph ) );
	CHECKALLOC( pGraph );

	for ( DWORD i = 0; i < dwNum && SUCCEEDED( hr ); i++ )
	{
		CHECKRUN( CreateTestTool( ppTools + i ) );
		CHECKALLOC( ppTools + i );

		CHECKRUN( pGraph->InsertTool( ppTools[i], pdwPChannels, cPChannels, lIndex ) );
	}

	for (i = 0; i < dwNum; i++ )
	{
		SAFE_RELEASE( ppTools[i] );
	}

	delete [] ppTools;
	SAFE_RELEASE( pGraph );
    
    //Remove any allocated audiopath configs.
    ptPerf8->SetDefaultAudioPath(NULL);

	return hr;
}


HRESULT ToolGraph_InsertTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

//	return hr;
	return E_NOTIMPL;
}


HRESULT ToolGraph_InsertTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, 0, 1 ) );
	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, 1, 1 ) );
	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, -1,1 ) );

	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, 0, 10 ) );
	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, 1, 10 ) );
	DMTEST_EXECUTE( ToolGraph_InsertTool( ptPerf8, NULL, 0, -1,10 ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolGraph_RemoveTool.cpp ===
#include <globals.h>

HRESULT ToolGraph_RemoveTool( CtIDirectMusicPerformance8* ptPerf8, LPDWORD pdwPChannels, DWORD cPChannels, LONG lIndex, DWORD dwNum )
{
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	IDirectMusicTool** ppTools = NULL;

	ppTools = new IDirectMusicTool*[dwNum];

	if ( NULL == ppTools )
		return E_OUTOFMEMORY;

	CHECKRUN( dmthCreateToolGraph( ptPerf8, &pGraph ) );
	CHECKALLOC( pGraph );

	for ( DWORD i = 0; i < dwNum && SUCCEEDED( hr ); i++ )
	{
		CHECKRUN( CreateTestTool( ppTools + i ) );
		CHECKALLOC( ppTools + i );

		CHECKRUN( pGraph->InsertTool( ppTools[i], pdwPChannels, cPChannels, lIndex ) );
	}

	for (i = 0; i < dwNum && SUCCEEDED( hr ); i++ )
	{
		CHECKRUN( pGraph->RemoveTool( ppTools[i] ) );
	}

	for (i = 0; i < dwNum; i++ )
	{
		SAFE_RELEASE( ppTools[i] );
	}

	delete [] ppTools;

	SAFE_RELEASE( pGraph );

	return hr;
}

HRESULT ToolGraph_RemoveTool_BVT( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;
//	return hr;
	return E_NOTIMPL;
}


HRESULT ToolGraph_RemoveTool_Valid( CtIDirectMusicPerformance8* ptPerf8 , DWORD dwUnused1, DWORD dwUnused2)
{
	HRESULT hr = S_OK;

	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, 0, 1 ) );
	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, 1, 1 ) );
	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, -1,1 ) );

	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, 0, 10 ) );
	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, 1, 10 ) );
	DMTEST_EXECUTE( ToolGraph_RemoveTool( ptPerf8, NULL, 0, -1,10 ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolTest.cpp ===
#include <globals.h>

CTestTool::CTestTool( void )
	: m_ulRefCount( 1 )
{
}

CTestTool::~CTestTool( void )
{
}

HRESULT STDMETHODCALLTYPE CTestTool::QueryInterface( REFIID iid, LPVOID* ppVoid )
{
	return E_NOTIMPL;
}

ULONG STDMETHODCALLTYPE CTestTool::AddRef( void )
{
	return ++m_ulRefCount;
}

ULONG STDMETHODCALLTYPE CTestTool::Release( void )
{
	if ( 0 == --m_ulRefCount )
	{
		delete this;
	}
	
	return m_ulRefCount;
}

HRESULT STDMETHODCALLTYPE CTestTool::Init( IDirectMusicGraph* pGraph )
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTestTool::GetMsgDeliveryType(LPDWORD pdwDeliveryType )
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTestTool::GetMediaTypeArraySize( LPDWORD pdwNumElements )
{
	*pdwNumElements = 0;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CTestTool::GetMediaTypes( LPDWORD* padwMediaTypes, DWORD dwNumElements )
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTestTool::ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG )
{
	Log(FYILOGLEVEL, "Got PMSG!\n" );
	return S_OK;
//	return DMUS_S_REQUEUE;
}

HRESULT STDMETHODCALLTYPE CTestTool::Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime )
{
	return S_OK;
}

HRESULT CreateTestTool( IDirectMusicTool** ppTool )
{

	if ( NULL == ppTool )
		return E_POINTER;

	HRESULT hr = S_OK;
	IDirectMusicTool* pTool = NULL;

	pTool = new CTestTool();

	if ( NULL == pTool )
	{
		hr = E_OUTOFMEMORY;
	}

	if ( SUCCEEDED( hr ) )
	{
		*ppTool = pTool;
		pTool->AddRef();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolTrace.h ===
//-----------------------------------------------------------------------------
// File: ToolEcho.h
//
// Desc: Implements an object based on IDirectMusicTool
//       that provides echoing effects.
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
//lint -e1510
#pragma once

#include <globals.h>


// Maximum echoes is 4 (the number of extra groups opened
// on the port in helper.cpp)
//#define MAX_ECHOES	4

class CToolTrace : public IDirectMusicTool
{
public:
	CToolTrace();
    ~CToolTrace();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTool
	HRESULT STDMETHODCALLTYPE Init( IDirectMusicGraph* pGraph );
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType( DWORD* pdwDeliveryType );
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize( DWORD* pdwNumElements );
	HRESULT STDMETHODCALLTYPE GetMediaTypes( DWORD** padwMediaTypes, DWORD dwNumElements) ;
	HRESULT STDMETHODCALLTYPE ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG );
	HRESULT STDMETHODCALLTYPE Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt );
private:
	long	m_cRef;			    // Reference counter
	CRITICAL_SECTION m_CrSec;	// To make SetEchoNum() and SetDelay() thread-safe

};


HRESULT InsertToolTrace(CtIDirectMusicPerformance *ptPerf8);
HRESULT InsertToolTrace(CtIDirectMusicAudioPath *ptAudioPath);
void RemoveToolTrace(CtIDirectMusicPerformance *ptPerf8);
void RemoveToolTrace(CtIDirectMusicAudioPath *ptAudioPath);
//lint +e1510
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolTest.h ===
//lint -e1510
#pragma once

#include <globals.h>

class CTestTool : public IDirectMusicTool
{
public:

	CTestTool( void );
	~CTestTool( void );

    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID iid, LPVOID* ppVoid );
    ULONG STDMETHODCALLTYPE AddRef( void );
    ULONG STDMETHODCALLTYPE Release( void );

    /*  IDirectMusicTool */
    HRESULT STDMETHODCALLTYPE Init( IDirectMusicGraph* pGraph );
    HRESULT STDMETHODCALLTYPE GetMsgDeliveryType(LPDWORD pdwDeliveryType );
    HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize( LPDWORD pdwNumElements );
    HRESULT STDMETHODCALLTYPE GetMediaTypes( LPDWORD* padwMediaTypes, DWORD dwNumElements );
    HRESULT STDMETHODCALLTYPE ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG );
    HRESULT STDMETHODCALLTYPE Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime );

private:
	ULONG m_ulRefCount;


};

HRESULT CreateTestTool( IDirectMusicTool** ppTool );
//lint +e1510
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\ToolTrace.cpp ===
//-----------------------------------------------------------------------------
// File: ToolEcho.cpp
//-----------------------------------------------------------------------------

#include <globals.h>

//-----------------------------------------------------------------------------
// Name: CreateToolTrace
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreateToolTrace( IDirectMusicTool** ppTool )
{

	if ( NULL == ppTool )
		return E_POINTER;

	HRESULT hr = S_OK;
	IDirectMusicTool* pTool = NULL;

	pTool = new CToolTrace();

	if ( !pTool )
	{
		hr = E_OUTOFMEMORY;
	}

	if ( SUCCEEDED( hr ) )
	{
		*ppTool = pTool;
		pTool->AddRef();
	}

	return hr;
}


static IDirectMusicTool *pToolTrace = NULL;

//-----------------------------------------------------------------------------
// Name: InsertToolTrace
// Desc: Causes all lyric pMsgs to be displayed.
//-----------------------------------------------------------------------------
HRESULT InsertToolTrace(CtIDirectMusicPerformance *ptPerf8)
{
HRESULT hr = S_OK;
CtIDirectMusicAudioPath *ptPath = NULL;

CHECKRUN(ptPerf8->GetDefaultAudioPath(&ptPath));
if (!ptPath)
    Log(ABORTLOGLEVEL, "InsertToolTrace error: ptPerf8 doesn't have a default audiopath!");
CHECKRUN(InsertToolTrace(ptPath));
SAFE_RELEASE(ptPath);
return hr;
}



//-----------------------------------------------------------------------------
// Name: InsertToolTrace
// Desc: Causes all lyric pMsgs to be displayed.
//-----------------------------------------------------------------------------
HRESULT InsertToolTrace(CtIDirectMusicAudioPath *ptPath)
{
IDirectMusicGraph *pGraph = NULL;
HRESULT hr = S_OK;

    if (pToolTrace)
    {
        Log(ABORTLOGLEVEL, "InsertToolTrace Error: Tool is already allocated!!");
        return E_FAIL;
    }

CHECKRUN(CreateToolTrace(&pToolTrace));
CHECKRUN( ptPath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE_GRAPH, 0, CLSID_DirectMusicGraph, 0, IID_IDirectMusicGraph, (LPVOID*) &pGraph ) );
CHECKALLOC( pGraph );
CHECKRUN(pGraph->InsertTool(pToolTrace, NULL, NULL, 0));
SAFE_RELEASE(pGraph);
return hr;
};

//-----------------------------------------------------------------------------
// Name: RemoveToolTrace
// Desc: Causes all lyric pMsgs to be displayed.
//-----------------------------------------------------------------------------
void RemoveToolTrace(CtIDirectMusicPerformance *ptPerf8)
{
HRESULT hr = S_OK;
CtIDirectMusicAudioPath *ptPath = NULL;

CHECKRUN(ptPerf8->GetDefaultAudioPath(&ptPath));
if (!ptPath)
    Log(ABORTLOGLEVEL, "RemoveToolTrace error: ptPerf8 doesn't have a default audiopath!");
CHECK(RemoveToolTrace(ptPath));
SAFE_RELEASE(ptPath);
if (FAILED(hr))
{
    Log(ABORTLOGLEVEL, "ERROR (POSSIBLE LEAK): RemoveToolTrace(CtIDirectMusicPerformance) failed!  HR = %s (%08X)", tdmXlatHRESULT(hr), hr);
}

}


//-----------------------------------------------------------------------------
// Name: RemoveToolTrace
// Desc: 
//-----------------------------------------------------------------------------
void RemoveToolTrace(CtIDirectMusicAudioPath *ptPath)
{
IDirectMusicGraph *pGraph = NULL;
HRESULT hr = S_OK;

    if (!pToolTrace)
    {
        Log(ABORTLOGLEVEL, "RemoveToolTrace Error: Tool has not been allocated!!");
        return;
    }

    CHECKRUN(ptPath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE_GRAPH, 0, CLSID_DirectMusicGraph, 0, IID_IDirectMusicGraph, (LPVOID*) &pGraph ));
    CHECKALLOC(pGraph);
    CHECKRUN(pGraph->RemoveTool(pToolTrace));
    SAFE_RELEASE(pGraph);
    SAFE_RELEASE(pToolTrace);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "ERROR (POSSIBLE LEAK): RemoveToolTrace(CtIDirectMusicAudioPath) failed!  HR = %s (%08X)", tdmXlatHRESULT(hr), hr);
    }

};


//-----------------------------------------------------------------------------
// Name: CToolTrace::CToolTrace()
// Desc: 
//-----------------------------------------------------------------------------
CToolTrace::CToolTrace()
{
    m_cRef = 1;                 // Set to 1 so one call to Release() will free this
//    m_dwEchoNum = 3;            // Default to 3 echoes per note
//    m_mtDelay = DMUS_PPQ / 2;   // Default to 8th note echoes
    InitializeCriticalSection(&m_CrSec);
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::~CToolTrace()
// Desc: 
//-----------------------------------------------------------------------------
CToolTrace::~CToolTrace()
{
    DeleteCriticalSection(&m_CrSec);
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::QueryInterface()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP CToolTrace::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::AddRef()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CToolTrace::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::Release()
// Desc: 
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CToolTrace::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::Init()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::Init( IDirectMusicGraph* pGraph )
{
    // This tool has no need to do any type of initialization.
    return E_NOTIMPL;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::GetMsgDeliveryType()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::GetMsgDeliveryType( DWORD* pdwDeliveryType )
{
    // This tool wants messages immediately.
    // This is the default, so returning E_NOTIMPL
    // would work. The other method is to specifically
    // set *pdwDeliveryType to the delivery type, DMUS_PMSGF_TOOL_IMMEDIATE,
    // DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
    
    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::GetMediaTypeArraySize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::GetMediaTypeArraySize( DWORD* pdwNumElements )
{
    *pdwNumElements = 2;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::GetMediaTypes()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::GetMediaTypes( DWORD** padwMediaTypes, 
                                                    DWORD dwNumElements )
{
    if( dwNumElements == 2 )
    {
        (*padwMediaTypes)[0] = DMUS_PMSGT_SCRIPTLYRIC;
        (*padwMediaTypes)[1] = DMUS_PMSGT_LYRIC;
        return S_OK;
    }
    else
    {
        // This should never happen
        return E_FAIL;
    }
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::ProcessPMsg()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    DMUS_LYRIC_PMSG *pLyricPMsg = (DMUS_LYRIC_PMSG *)pPMsg;
    CHAR szString[1000] = {0};

  //  wcstombs(szString, pLyricPMsg->wszString, 999); 
    sprintf(szString, "%ls", pLyricPMsg->wszString); 
    Log(FYILOGLEVEL, szString);
    return DMUS_S_FREE;
}




//-----------------------------------------------------------------------------
// Name: CToolTrace::Flush()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CToolTrace::Flush( IDirectMusicPerformance* pPerf, 
                                            DMUS_PMSG* pDMUS_PMSG,
                                            REFERENCE_TIME rt)
{
    // This tool does not need to flush.
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\Utils.hpp ===
#pragma once

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\AudioPath_Activate.cpp ===
#include "globals.h"
#include "cicmusicx.h"


DWORD AudioPath_Activate_BVT(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_Activate (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function AudioPath_Activate())");
    CALLDMTEST(AudioPath_Activate_BVT(ptPerf8, 0, 0, 0, 0));                                                    
    return hr;
};

/********************************************************************************
//Later we'll go through the entire audiopath and make sure we can get everything
//  out of it.  For now though we'll just play a bunch of stuff on them.

//TESTPARAMS are unused except for ptPerf8
********************************************************************************/
DWORD AudioPath_Activate_BVT(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath     = NULL;
BOOL bDownloaded = FALSE;


    //Load default segment.
    hr = dmthLoadSegment(g_szDefaultMedia, &ptSegment8);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment function returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    //Create an inactive audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          16,
                                          FALSE,
                                          &ptPath);
    if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath(%s, %d, %d) returned %s (%08Xh) instead of S_OK",
                              "DMUS_APATH_SHARED_STEREOPLUSREVERB",
                              16,
                              FALSE,
                              tdmXlatHRESULT(hr),
                              hr);
		goto TEST_END;
	}


    //Activate(FALSE) on inactive path.
    hr = ptPath->Activate(FALSE);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Activate (FALSE) on already-inactive audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling Activate(FALSE) on inactive path, should hear no sound for 3 seconds.");
    Sleep(100);

    //Activate(TRUE) on inactive path.
    hr = ptPath->Activate(TRUE);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Activate (TRUE) on inactive audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling Activate(TRUE) on inactive path, should hear sound for 3 seconds.");
    Sleep(100);

    //Download to the active path.
    hr = ptSegment8->Download(ptPath);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Download on inactive audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    Sleep(100);
    bDownloaded = TRUE;


    //Try to play a segment on it; verify you don't hear any sound.
	hr = ptPerf8->PlaySegmentEx( 
		ptSegment8, 
		0,
		NULL,
        0, 
		0,
		NULL,
		NULL,
		ptPath);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx function returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Playing segment on active path, should hear sound for 3 seconds.");
    Sleep(3000);


    //Activate(TRUE) on active path.
    hr = ptPath->Activate(TRUE);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Activate (TRUE) on active audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling Activate(TRUE) on active path, should hear sound for 3 seconds.");
    Sleep(3000);

    //Activate(FALSE) on active path.
    hr = ptPath->Activate(FALSE);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Activate (FALSE) on active audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling Activate(FALSE) on active path, should hear no sound for 3 seconds.");
    Sleep(3000);

    //Activate(TRUE) on deactivated path.
    hr = ptPath->Activate(TRUE);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** Activate (TRUE) on deactivated audiopath returned",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling Activate(TRUE) on deactivated path, no sound expected.");
    Sleep(3000);


    dwRes = FNS_PASS;


TEST_END:
    if (bDownloaded && ptSegment8 && ptPath)
    {
        hr = ptSegment8->Unload(ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** Unload failed!!!  May incur memory leaks",tdmXlatHRESULT(hr), hr);
	    }
    }

    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\CICMusicX.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       CICMusic.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// CICMusic.cpp
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//
// Functions:
//
//
//	History:
//		03/09/2000 - danhaff/ruswoods - created
//      03/27/2000 - danhaff - Made Init call UnInit first, fixed bugs
//      08/29/2000 - danhaff - Removed instances of DYNAMIC_APATH_ENV3D
//
/////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "cicmusicx.h"
#include "dmthcom.h"


//--------------------------------------------------------------------------;
// Description: <nl>
// Constructor for CICMusic
//
//
// Parameters: <nl>
//   hWnd: hWnd of our window.
//
// Notes:
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
CICMusic::CICMusic(void)
:
m_ptLoader8 (NULL),
m_ptPerformance8 (NULL),
m_ptAudioPath (NULL),
m_ptAudioPathEnv (NULL),
m_ptUnkAudioPathConfig (NULL),
m_ptSegment8(NULL),
m_ptSegmentState8(NULL)
{
    //What are you looking at?
};


//--------------------------------------------------------------------------;
// Description: <nl>
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init
(
CtIDirectMusicPerformance8 *ptPerf8,
LPCSTR szSegment,
DWORD dwDefaultPathType,
DWORD dwPChannelCount)
{
    HRESULT hr = E_FAIL;

    __try
    {
        //Copy our performance in.
        if (!ptPerf8)
            __leave;
        m_ptPerformance8 = ptPerf8;
            
        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;
        
        //Now perform our initialization.
        hr = PrivateInitialize(szSegment, NULL, dwDefaultPathType, /*dwUseAPathEnv,*/ dwPChannelCount);
        if (S_OK != hr)
            __leave;
    }
    __finally
    {
    }

    return hr;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init(
CtIDirectMusicPerformance8 *ptPerf8,
LPCSTR szSegment,
LPCSTR szConfig)
{
    HRESULT hr;
    __try
    {
        //Copy our performance in.
        if (!ptPerf8)
            __leave;
        m_ptPerformance8 = ptPerf8;

        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;

        //Now perform our initialization.
        hr = PrivateInitialize(szSegment,              //Specified segment.
                               szConfig,               //Specified AP config file.
                               NULL,                    //Don't use a standard path type.
                               //dwUseAPathEnv,    //Whether to create teh APATH_ENV
                               0);                      //pChannels don't matter cuz we're using file.
        if (S_OK != hr)
            __leave;

    }
    __finally
    {
    }
    return hr;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//   Shutdowns the class, just like the destructor.  I added this
//   because sometimes you want to shut it down early.
//
// Notes:
//
// History: <nl>
//		03/27/2000 - danhaff - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Shutdown(void)
{
    HRESULT hr;
    hr = PrivateUninitialize();
    return hr;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Destructor for CICMusic
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
CICMusic::~CICMusic ()
{
    PrivateUninitialize();
}



//--------------------------------------------------------------------------;
// Description: <nl>
// Initialization function for CICMusic, called by both constructors.
//
//
// Parameters: <nl>
//
// Notes:
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateInitialize(
LPCSTR szSegment,
LPCSTR szConfig,
DWORD dwDefaultPathType,
//DWORD dwUseAPathEnv,
DWORD dwPChannelCount
)
{
HRESULT hr;
IDirectMusicPerformance8 *pPerformance8 = NULL;
char szConfigPath[MAX_PATH]          = {0};
char szConfigFile[MAX_PATH]         = {0};
char szSegmentPath[MAX_PATH]         = {0};
char szSegmentFile[MAX_PATH]        = {0};


    __try
    {
        //Verify that one of the correct types of standardpaths was passed, if any.
        if (dwDefaultPathType != 0                                  &&
            dwDefaultPathType != DMUS_APATH_SHARED_STEREOPLUSREVERB &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_3D              &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_STEREO          &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_MONO            
            )
        {
            fnsLog(ABORTLOGLEVEL, "**** TEST APP ERROR:  Someone passed an invalid value for dwDefaultPathType!!");
            __leave;
        }


	    //Create a new Loader8.
        hr = dmthCreateLoader(IID_IDirectMusicLoader8, &m_ptLoader8);
	    if (S_OK != hr)
	    {
            fnsLog(ABORTLOGLEVEL, "**** ERROR: CICMusic: dmthCreateLoader returned (%s == %08Xh)",
                    tdmXlatHRESULT(hr), hr);
            __leave;
	    }

        //Parse out the path and the file.
        hr = ChopPath(szSegment, szSegmentPath, szSegmentFile);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, "**** ERROR parsing full path to Segment file: %s", szSegment);
            __leave;
        }
        
        //Keep all info, we don't want GM.DLS to be unfound.
        hr = m_ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, (char *)szSegmentPath, FALSE);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetSearchDirectory(%s) failed!!", szSegmentPath);
            __leave;
        }

        //If we pass in an audiopath config file, make that the default path, otherwise choose
        //  and standard default path.  This decision was made by which constructor to use.
        if (szConfig)
        {

            //Parse out the Path and file.
            hr = ChopPath(szConfig, szConfigPath, szConfigFile);
            if (FAILED(hr))
            {
                fnsLog(ABORTLOGLEVEL, "**** ERROR parsing full path to config file: %s", szConfig);
                __leave;
            }

            //Stack this on top the other info.
            hr = m_ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, szConfigPath, FALSE);
            if (FAILED(hr))
            {
                fnsLog(ABORTLOGLEVEL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetSearchDirectory(%s) failed!!", szConfigPath);
                __leave;
            }


            //Load up the audiopath config.
            //There is no actual interface for this; we use the IUnknown interface
            //  for this object.
            hr = m_ptLoader8->LoadObjectFromFile(CLSID_DirectMusicAudioPathConfig,
                                                 CTIID_IUnknown,
                                                 (CHAR *)szConfigFile,
                                                 (void **)&m_ptUnkAudioPathConfig);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
    			TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load audiopath config %s!! (%s == %08Xh)"),
			    PathFindFileName((char *)szConfigFile),
                tdmXlatHRESULT(hr), hr);
                __leave;
            }

            //Make that audiopath config into a real audiopath
            hr = m_ptPerformance8->CreateAudioPath(m_ptUnkAudioPathConfig, TRUE, &m_ptAudioPath);
    	    if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
			    TEXT("**** ABORT:  CICMusic: Perf8->CreateAudioPath failed from loaded config file %s!! (%s == %08Xh)"),
			    szConfig, tdmXlatHRESULT(hr), hr);
                __leave;
            }

        }
        else
        {
            //Call CreateStandardAudioPath.
            hr = m_ptPerformance8->CreateStandardAudioPath(dwDefaultPathType, dwPChannelCount, TRUE, &m_ptAudioPath);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
			    TEXT("**** ABORT:  CICMusic: Perf8->CreateStandardAudioPath returned (%s == %08Xh)"),
			    tdmXlatHRESULT(hr), hr);
                __leave;
            }            
        }

/*
        //Set the audiopath we created as the default.
        hr = m_ptPerformance8->SetDefaultAudioPath(m_ptAudioPath);
    	if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: Perf8->SetDefaultAudioPath failed from file %s!! (%s == %08Xh)"),
			szConfig, tdmXlatHRESULT(hr), hr);
            __leave;
        }

*/

        // Load the segment.
        hr = m_ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment,
                                        CTIID_IDirectMusicSegment8,
                                        (CHAR *)szSegmentFile,
                                        (void **)&m_ptSegment8);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load segment %s!! (%s == %08Xh)"),
            PathFindFileName((char *)szSegmentFile),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Tell the segment to repeat forever.
        hr = m_ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE) returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Get the real Performance8 ptr from the performance, so we can pass it to SetParam.
        hr = m_ptPerformance8->GetRealObjPtr(&pPerformance8);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: CtIDirectMusicPerformance8->GetRealObjPtr returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Cause the correct instruments to be downloaded.
//        hr = m_ptSegment8->Download((CtIUnknown *)m_ptAudioPath);
        hr = m_ptSegment8->Download((CtIUnknown *)m_ptPerformance8);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicSegment8->Download returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }


        //Play the segment on the default audio path, and get the segment state.
        hr = m_ptPerformance8->PlaySegmentEx((CtIUnknown *)m_ptSegment8,
                                            NULL,                   //no segment id, this isn't a song
                                            NULL,                   //no transition to compose
                                            NULL,                   //no DMUS_SEGF flags
                                            0,                      //time to start playback (right away)
                                            &m_ptSegmentState8,     //returned segment state
                                            NULL,                   //no segstate to replace
                                            (CtIUnknown *)m_ptAudioPath);                  //play on default audiopath.
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicPerformance8->PlaySegmentEx returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

    }
    __finally
    {
        //Release the only thing we allocated locally during this function.
        SAFE_RELEASE(pPerformance8);

        //If init failed, release all members.
        if (S_OK != hr)
            PrivateUninitialize();
    }

return hr;
};






//--------------------------------------------------------------------------;
// Description: <nl>
//  Frees up everything in the object.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateUninitialize(void)
{
    //Might as well have the return value somewhere.
    HRESULT hr = S_OK;

    //Stop Everything.
    hr = m_ptPerformance8->StopEx(NULL, NULL, NULL);  //Uncomment this to repro bug 2967

    //Unload what we downloaded.
    if (m_ptAudioPath && m_ptSegment8)
    {
        hr = m_ptSegment8->Unload((CtIUnknown *)m_ptAudioPath);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
		    TEXT("**** WARNING!!! POSSIBLE MEMORY LEAK, CONTACT KCRAVEN OR DANHAFF:  CICMusic: IDirectMusicSegment8->Unload returned (%s == %08Xh)"),
		    tdmXlatHRESULT(hr), hr);
        }
    }

    //Release all the interfaces we've stashed, except the performance which must be Closed down and
    //  released last.
	SAFE_RELEASE (m_ptSegmentState8);
    SAFE_RELEASE (m_ptSegment8);
    SAFE_RELEASE (m_ptAudioPath);
    SAFE_RELEASE (m_ptAudioPathEnv);
    SAFE_RELEASE (m_ptUnkAudioPathConfig);
	SAFE_RELEASE (m_ptLoader8);


//BUGBUG: Don't do this!!!  We can't close down an XBox app!!
/*
	if (m_ptPerformance8)
    {
		hr = m_ptPerformance8->CloseDown();
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
		    TEXT("**** WARNING!!! CONTACT KCRAVEN OR DANHAFF:  CICMusic: IDirectMusicPerformance8->CloseDown() returned (%s == %08Xh)"),
    		    tdmXlatHRESULT(hr), hr);
        }
    }

    //Finally release the performance.
	SAFE_RELEASE (m_ptPerformance8);
*/ 



    return hr;
};



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetLoader8
//
// Parameters: <nl>
//      pptLoader8: contains address of pointer to contain wrapped IDirectMusicLoader8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicLoader8** pptDirectMusicLoader8)
{
    if (pptDirectMusicLoader8 && m_ptLoader8)
    {
        *pptDirectMusicLoader8 = m_ptLoader8;
        m_ptLoader8->AddRef();
        return S_OK;
    }
    else if (!pptDirectMusicLoader8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Gets the performance object, which must be created upon initialization.
//
// Parameters: <nl>
//      pptPerformance8: contains address of pointer to contain wrapped IDirectMusicPerformance8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicPerformance8 **pptPerformance8 )
{
    if (pptPerformance8 && m_ptPerformance8)
    {
        *pptPerformance8 = m_ptPerformance8;
        m_ptPerformance8->AddRef();
        return S_OK;
    }
    else if (!pptPerformance8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;

};




//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped IDirectMusicAudioPath.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicAudioPath** pptAudioPath)
{
    if (pptAudioPath && m_ptAudioPath)
    {
        *pptAudioPath= m_ptAudioPath;
        m_ptAudioPath->AddRef();
        return S_OK;
    }
    else if (!pptAudioPath)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPathConfig
//
// Parameters: <nl>
//      pptUnkAudioPathConfig: contains address of pointer to contain wrapped IDirectMusicAudioPathConfig.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIUnknown ** pptUnkAudioPathConfig)
{
    if (pptUnkAudioPathConfig && m_ptUnkAudioPathConfig)
    {
        *pptUnkAudioPathConfig= m_ptUnkAudioPathConfig;
        m_ptUnkAudioPathConfig->AddRef();
        return S_OK;
    }
    else if (!pptUnkAudioPathConfig)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegment8
//
// Parameters: <nl>
//      pptSegment8: contains address of pointer to contain wrapped IDirectMusicSegment8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicSegment8** pptSegment8)
{
    if (pptSegment8 && m_ptSegment8)
    {
        *pptSegment8 = m_ptSegment8;
        m_ptSegment8->AddRef();
        return S_OK;
    }
    else if (!pptSegment8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegmentState8
//
// Parameters: <nl>
//      pptSegmentState8: contains address of pointer to contain wrapped IDirectMusicSegmentState8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(CtIDirectMusicSegmentState8** pptSegmentState8)
{
    if (pptSegmentState8 && m_ptSegmentState8)
    {
        *pptSegmentState8 = m_ptSegmentState8;
        m_ptSegmentState8->AddRef();
        return S_OK;
    }
    else if (!pptSegmentState8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetEnvironmentPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped
//      IDirectMusicAudioPath.
//
// History: <nl>
//		05/06/2000 - danhaff - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetAudioPathEnv(CtIDirectMusicAudioPath **pptAudioPathEnv)
{
    if (pptAudioPathEnv && m_ptAudioPathEnv)
    {
        *pptAudioPathEnv = m_ptAudioPathEnv;
        m_ptAudioPathEnv->AddRef();
        return S_OK;
    }
    else if (!pptAudioPathEnv)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\AudioPath_SetVolume.cpp ===
/********************************************************************************
FILE:
    AUDIOPATH8.cpp

PURPOSE:
    Contains AudioPath test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

DWORD AudioPath_SetVolume_Direct(CtIDirectMusicPerformance8* ptPerf8);
DWORD AudioPath_SetVolume_Ramp  (CtIDirectMusicPerformance8* ptPerf8);





/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_SetVolume (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function AudioPath_SetVolume())");
    CALLDMTEST(AudioPath_SetVolume_Direct(ptPerf8));
    CALLDMTEST(AudioPath_SetVolume_Ramp(ptPerf8));
    return hr;
};


/********************************************************************************
IDirectMusicAudioPath::SetVolume()

HISTORY:
    Updated     04/05/00      danhaff - created.
********************************************************************************/
DWORD AudioPath_SetVolume_Direct(CtIDirectMusicPerformance8* ptPerf8)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    CtIDirectMusicAudioPath     *ptAudioPath     = NULL;
    LONG                        lValues[] = {DSBVOLUME_MIN, DSBVOLUME_MAX, -1, -1000, -5000, -9999};
    DWORD                       i = 0;


    //Start the music playing.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_DYNAMIC_STEREO);
    if (S_OK != hr)
        goto TEST_END;

    //Get the IDirectMusicAudioPath interface.
    hr = Music.GetInterface(&ptAudioPath);
    if (S_OK != hr)
        goto TEST_END;

    //MIN
    for (i=0; i<AMOUNT(lValues); i++)
    {
        Log(FYILOGLEVEL, "Calling SetVolume(%d), playing for 2 seconds", lValues[i]);
        hr = ptAudioPath->SetVolume(lValues[i], 0);
        if (S_OK != hr)
        {
            dwRes = FNS_FAIL;
            goto TEST_END;
        }
	    Sleep (2000);
    }

    dwRes = FNS_PASS;

TEST_END:
   SAFE_RELEASE(ptAudioPath);

    return dwRes;
    
};




/********************************************************************************
IDirectMusicAudioPath::SetVolume()

HISTORY:
    Updated     04/05/00      danhaff - created.

//Ramp from 
********************************************************************************/
struct VOLUMERAMP
{
LONG lVolFrom;
LONG lVolTo;
DWORD dwTime;
};

DWORD AudioPath_SetVolume_Ramp(CtIDirectMusicPerformance8* ptPerf8)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    CtIDirectMusicAudioPath     *ptAudioPath     = NULL;
    DWORD                       i = 0;

    VOLUMERAMP vRamp[] = {
                          
                          //Long range, no time.
                          {DSBVOLUME_MIN, DSBVOLUME_MAX, 0},  
                          {DSBVOLUME_MAX, DSBVOLUME_MIN, 0},  

                          //Long range, short time.
                          {DSBVOLUME_MIN, DSBVOLUME_MAX, 1},  
                          {DSBVOLUME_MAX, DSBVOLUME_MIN, 1},  

                          //Long range, avg time.
                          {DSBVOLUME_MIN, DSBVOLUME_MAX, 1000},  
                          {DSBVOLUME_MAX, DSBVOLUME_MIN, 1000},  

                          //Long range, long time.
                          {DSBVOLUME_MIN, DSBVOLUME_MAX, 10000},  //Use these 2 to repro 2904.
                          {DSBVOLUME_MAX, DSBVOLUME_MIN, 10000},  

                          //Long range, INFINITE time.
                          {DSBVOLUME_MIN, DSBVOLUME_MAX, ULONG_MAX},   //Use these 2 to repro 2905.
                          {DSBVOLUME_MAX, DSBVOLUME_MIN, ULONG_MAX},  

                          //Short range, no time
                          {DSBVOLUME_MIN, DSBVOLUME_MIN + 1, 0},  
                          {DSBVOLUME_MAX, DSBVOLUME_MAX - 1, 0},  

                          //Short range, ININITE time.
                          {DSBVOLUME_MIN, DSBVOLUME_MIN + 1, ULONG_MAX},  
                          {DSBVOLUME_MAX, DSBVOLUME_MAX - 1, ULONG_MAX},  


                          //no range, no time
                          {DSBVOLUME_MIN, DSBVOLUME_MIN, 0},  
                          {DSBVOLUME_MAX, DSBVOLUME_MAX, 0},  
                          {5000,          5000,          0},  

                          //no range, INFINITE time
                          {DSBVOLUME_MIN, DSBVOLUME_MIN, ULONG_MAX},  
                          {DSBVOLUME_MAX, DSBVOLUME_MAX, ULONG_MAX},  
                          {5000,          5000,          ULONG_MAX}
                          };


    //Start the music playing.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_DYNAMIC_STEREO);
    if (S_OK != hr)
        goto TEST_END;

    //Get the IDirectMusicAudioPath interface.
    hr = Music.GetInterface(&ptAudioPath);
    if (S_OK != hr)
        goto TEST_END;

    
    for (i=0; i<AMOUNT(vRamp); i++)
    {
        Log(FYILOGLEVEL, "Test %d/%d", i, AMOUNT(vRamp));
        Log(FYILOGLEVEL, "Playing at %d for 2 seconds, ramping from %d -> %d over %dms for 5 seconds, playing at %d for 5 seconds.",
                          vRamp[i].lVolFrom,
                          vRamp[i].lVolFrom,
                          vRamp[i].lVolTo,
                          vRamp[i].dwTime,
                          vRamp[i].lVolTo
                          );
        
        Log(FYILOGLEVEL, "SetVolume(%d, IMMEDIATE), waiting 2s", vRamp[i].lVolFrom);
        hr = ptAudioPath->SetVolume(vRamp[i].lVolFrom, 0);
        if (S_OK != hr)
        {
            dwRes = FNS_FAIL;
            goto TEST_END;
        }
	    Sleep (2000);


        Log(FYILOGLEVEL, "SetVolume(%d, %u), waiting 5s during ramp", vRamp[i].lVolTo, vRamp[i].dwTime);
        hr = ptAudioPath->SetVolume(vRamp[i].lVolTo, vRamp[i].dwTime);
        if (S_OK != hr)
        {
            dwRes = FNS_FAIL;
            goto TEST_END;
        }
	    Sleep (5000);

        Log(FYILOGLEVEL, "SetVolume(%d, IMMEDIATE), waiting 5s", vRamp[i].lVolTo);
        hr = ptAudioPath->SetVolume(vRamp[i].lVolTo, 0);
        if (S_OK != hr)
        {
            dwRes = FNS_FAIL;
            goto TEST_END;
        }
	    Sleep (5000);
    }

    dwRes = FNS_PASS;


TEST_END:
   SAFE_RELEASE(ptAudioPath);

    return dwRes;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\AudioPath_SetVolume_Invalid.cpp ===
/********************************************************************************
FILE:
    AUDIOPATH8.cpp

PURPOSE:
    Contains AudioPath test functions.

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_SetVolume_Invalid(CtIDirectMusicPerformance8* ptPerf8)
{

    HRESULT hr = S_OK;
    CICMusic Music;
    CtIDirectMusicAudioPath *ptPath = NULL;

    //Start the music playing.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_DYNAMIC_STEREO);
    if (S_OK != hr)
        goto TEST_END;

    hr = Music.GetInterface(&ptPath);

    hr = ptPath->SetVolume(-10001, 0);
    Log(FYILOGLEVEL, "ERROR!!!!!  Should have int3'd");


    hr = ptPath->SetVolume(1, 0);
    Log(FYILOGLEVEL, "ERROR!!!!!  Should have int3'd");


TEST_END:

    SAFE_RELEASE(ptPath);
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\AudioPath_GetObjectInPath1.hpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows

// History:
//  03/11/2000  danhaff     created.
//  05/04/2000 - danhaff - split into separate file.
//===========================================================================
#pragma once
 
#include "globals.h"

/********************************************************************************
********************************************************************************/
template <class T>
HRESULT tmplGetObjectInPath(CtIDirectMusicPerformance8 *ptPerf8,                          
                          DWORD dwPathType,
                          DWORD dwStage,
                          GUID *pguidObject,
                          GUID *pguidInterface,
                          T* pDoNotUseDoNotRemove = NULL)
{
	HRESULT						hr				    = S_OK;
    void                        *pVoid              = NULL;    
    IUnknown                    *pUnknown           = NULL;
    IUnknown                    *pUnkVerify         = NULL;
    T                           *ptTestInterface    = NULL;
    CICMusic                     Music;   
    DWORD                        dwBuffer           = 0;

    CHECKRUN(Music.Init(ptPerf8, g_szDefaultMedia, dwPathType));
    CHECKRUN(Music.GetInterface(&ptTestInterface));
    dwBuffer = 0;
    
    // Get the object out of the audio path.
    CHECKRUN(ptTestInterface->GetObjectInPath(
            IgnorePChannel(dwStage),   
            dwStage,           
            dwBuffer,          
            *pguidObject,    
            0,               //dwIndex
            *pguidInterface, 
            (void **)&pVoid));

    //Wait a sec, to catch any mixer problems.
    CHECK(Sleep(1000));

  
    //TODO: Call the last method on each interface.  This test sucks, write another one.


    //Verify it's the correct type by QI'ing
    CHECK(pUnknown = (IUnknown *)pVoid);

    // Cleanup objects and uninitialize and Return results
    SAFE_RELEASE(pUnkVerify);
    SAFE_RELEASE(pUnknown);
    SAFE_RELEASE(ptTestInterface);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\AudioPath_GetObjectInPath1.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "AudioPath_GetObjectInPath1.hpp"




HRESULT AudioPath_GetObjectInPath_BVT(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface);



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT AudioPath_GetObjectInPath (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function AudioPath_GetObjectInPath())");
//    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, TEST_SEGMENT8_FROM_STEREOPLUSREVERB));                                             
//    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_SEGMENT,     (GUID *)&GUID_All_Objects, (GUID *)&IID_IDirectMusicSegment8));
//    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_PERFORMANCE, (GUID *)&CLSID_DirectMusicPerformance, (GUID *)&IID_IDirectMusicPerformance8));                                             
    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_MONO,            DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    CHECKEXECUTE(AudioPath_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_STEREO,          DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    return hr;
};



/********************************************************************************
UNIT TEST
IDirectMusicAudioPath::GetObjectInPath()

HISTORY:

PARAMS:
    dwParam3:
        Which test scenario will be run.  Currently there are i scenarios, each
        with different standard paths, objects to retrieve, etc...
    dwParam4         Not used
********************************************************************************/
HRESULT AudioPath_GetObjectInPath_BVT(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface)
{
    return tmplGetObjectInPath<CtIDirectMusicAudioPath>(ptPerf8, dwPathType, dwStage, pguidObject, pguidInterface);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\CICMusicX.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       CICMusic.h
//
//--------------------------------------------------------------------------

//===========================================================================
//	CICMusic.h
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//	History:
//		03/09/2000 - danhaff/ruswoods - created
//      04/25/2000 - danhaff - added another Init() to specify whether we
//                             create an APATH_SHARED_ENV before
//                             creating the user-specified path.
//===========================================================================

#pragma once

#define GF_AUDIOPATH        1
#define GF_SEGMENT8         2
#define GF_SEGMENTSTATE8    4

#include "dmth.h"


class CICMusic
{

protected:
    CtIDirectMusicLoader8           *m_ptLoader8;
    CtIDirectMusicPerformance8      *m_ptPerformance8;
    CtIUnknown                      *m_ptUnkAudioPathConfig;
    CtIDirectMusicAudioPath         *m_ptAudioPath;
    CtIDirectMusicAudioPath         *m_ptAudioPathEnv;
    CtIDirectMusicSegment8          *m_ptSegment8;
    CtIDirectMusicSegmentState8     *m_ptSegmentState8;

public :
    // *************************************************************
    CICMusic(void);

    // *************************************************************
	~CICMusic(void);

    // *************************************************************
	HRESULT Init      (CtIDirectMusicPerformance8 *ptPerf8,
                       LPCSTR szSegment,
                      DWORD dwDefaultPathType,
                      DWORD dwPChannelCount = 16);

    // *************************************************************
    HRESULT Init      (CtIDirectMusicPerformance8 *ptPerf8,
                       LPCSTR szSegment,
                      LPCSTR szConfig);

    // *************************************************************
    HRESULT Shutdown(void);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicLoader8 **pptLoader8);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicPerformance8 **pptPerformance8);

    // *************************************************************
	HRESULT GetInterface(CtIUnknown **pptUnkAudioPathConfig);

    // *************************************************************
	HRESULT GetInterface(CtIDirectMusicAudioPath **pptAudioPath);

    // *************************************************************
    HRESULT GetInterface(CtIDirectMusicSegment8** pptSegment8);
    
    // *************************************************************
    HRESULT GetInterface(CtIDirectMusicSegmentState8** pptSegmentState8);

    // *************************************************************
    HRESULT GetAudioPathEnv(CtIDirectMusicAudioPath **pptAudioPathEnv);


private:
    // *************************************************************
    HRESULT PrivateInitialize(LPCSTR wszSegment,
                                 LPCSTR wszConfig,
                                 DWORD dwDefaultPathType,
                                 DWORD dwPChannelCount
                                 );
    // *************************************************************
    HRESULT PrivateUninitialize(void);



};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\loader8.h ===
#pragma once
#include "globals.h"

HRESULT Loader_CollectGarbage( CtIDirectMusicPerformance8* ptPerf8 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\FakeStuff.h ===
/******************************************************************************************
Used to ease porting tests from Windows.


******************************************************************************************/

#pragma once



#define CALLDMTEST( func )                                          \
{                                                                   \
    if (SUCCEEDED(hr))                                              \
    {                                                               \
        dwRes = func;                                               \
        if (dwRes == FNS_PASS)                                      \
            hr = S_OK;                                              \
        else                                                        \
            hr = E_FAIL;                                            \
    }                                                               \
}                                                                   



#define fnsIncrementIndent LogIncrementIndent
#define fnsDecrementIndent LogDecrementIndent

#define FNS_PASS                        0x00000000
#define FNS_FAIL                        0x00000001
#define FNS_ABORTED                     0x00000002
#define FNS_PENDING                     0x00000003


#define ghWnd NULL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\globals.h ===
#pragma once

#undef UNICODE  //Ugh, UNICODE on XBox is like tar on pancakes.

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdlib.h>
#include <malloc.h>
#include <malloc.h>
#include <float.h>
#include <dmusicc.h>
#include <dmusici.h>

#include <dmth.h>

#ifdef NOLOG
    #include "nakedmacros.h"
#else
    #include <macros.h>
#endif 

#include <stdio.h>
#include "logging.h"
#include "fakestuff.h"
#pragma warning( disable : 4056 4756 4005)

#include "helpers.h"

extern "C" HANDLE g_hLog;
extern "C" LPSTR g_szComponent;
extern "C" LPSTR g_szSubComp;
extern "C" LPSTR g_szFunction;
extern "C" LPSTR g_szVariation;

// Disable warning messages about floating point overflow.
#pragma warning( disable : 4056 4756)
#define INFINITY (FLT_MAX * FLT_MAX)       
#define ALMOST_FLT_MAX (FLT_MAX * 0.99f) //so we don't run up against MAXDISTANCE.


//BUGBUG: This can go away.
#define TESTPARAMS CtIDirectMusicPerformance8 *ptPerf8, DWORD dwParam1, DWORD dwParam2, LPARAM dwParam3, LPARAM dwParam4

extern CHAR *g_szDefaultMedia;  //defined in DMTEST1.CPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\DMTEST1.cpp ===
/********************************************************************************
FILE: DMTEST1.CPP

PURPOSE:    
    Contains the "main code segment" for DANROSE's set of DMusic tests
    from which all the subfunctions (individual test cases) are called.  
********************************************************************************/

#include "globals.h"
#include "tests.h"

CHAR *g_szDefaultMedia = "T:\\Media\\test.sgt";

//BUGBUG: Remove this eventually.
HRESULT Loader8_LoadObjectTwice(CtIDirectMusicPerformance8* ptPerf8);


/******************************************************************************************
******************************************************************************************/
HRESULT DanHaff_Tests(HANDLE LogHandle, CtIDirectMusicPerformance8 *ptPerf8)
{
DWORD dwRes;
HRESULT hr = S_OK;


    //Call some functions, yo.
    LogSetDbgLevel(PARAMLOGLEVEL);

	//SETLOG( LogHandle, "danhaff", "DMusic", "Sample Test", "Regression" );
    //CHECKEXECUTE(SampleTest());

    //Audiopath Tests
//	SETLOG( LogHandle, "danhaff", "DMusic", "AudioPath_Activate", "Regression" );         //PASSES.
//    CHECKEXECUTE(AudioPath_Activate(ptPerf8));                

	SETLOG( LogHandle, "danhaff", "DMusic", "AudioPath_GetObjectInPath", "Regression" );  //PASSES
    CHECKEXECUTE(AudioPath_GetObjectInPath(ptPerf8));
	//SETLOG( LogHandle, "danhaff", "DMusic", "AudioPath_SetVolume", "Regression" );        //FAILs due to 2904 and 2905.
//    CHECKEXECUTE(AudioPath_SetVolume(ptPerf8));                 
    
    //Performance8 Tests
//    CHECKEXECUTE(Performance8_AddNotificationType(ptPerf8));                                //FAILS due to 2918
//    CHECKEXECUTE(Performance8_AllocPMsg(ptPerf8));                                          //NA, Covered in SendPMsg
//    CHECKEXECUTE(Performance8_CloseDown(ptPerf8));                                          //N/A has been removed for February.
//    CHECKEXECUTE(Performance8_CreateStandardAudioPath(ptPerf8));                               //FAILS due to 2762, 2987
//    CHECKEXECUTE(Performance8_FreePMsg(ptPerf8));                                           //NA, Covered in SendPMsg
//    CHECKEXECUTE(Performance8_GetGlobalParam(ptPerf8));                                     //FAILS due to 2921
//    CHECKEXECUTE(Performance8_GetNotificationPMsg(ptPerf8));                                //NA, Covered in SendPMsg
//    CHECKEXECUTE(Performance8_GetSegmentState(ptPerf8));                                    //PASSES, but sounds crappy.  TODO: figure this out.
//    CHECKEXECUTE(Performance8_GetTime(ptPerf8));                                            //PASSES!
//    CHECKEXECUTE(Performance8_IsPlaying(ptPerf8));                                          //FAILS due to 2953
//    CHECKEXECUTE(Performance8_PlaySegmentEx(ptPerf8));                                      //FAILS on ported tests, but they look wrong.  Passes under normal conditions.
//    CHECKEXECUTE(Performance8_RemoveNotificationType(ptPerf8));                             //NA, covered in AddNotificationType.
//    CHECKEXECUTE(Performance8_SendPMsg(ptPerf8));                                           //FAILS due to 2968
//    CHECKEXECUTE(Performance8_SetGlobalParam(ptPerf8));                                     //PASSES!
//    CHECKEXECUTE(Performance8_StopEx(ptPerf8));                                             //FAILS due to 2987

    //Segment8 Tests
//    CHECKEXECUTE(Segment8_Download(ptPerf8));                                               //PASSES
//    CHECKEXECUTE(Segment8_SetRepeats(ptPerf8));                                             //PASSES
//    CHECKEXECUTE(Segment8_Unload(ptPerf8));                                                 //NA, covered in download.

    //SegmentState8 Tests
    CHECKEXECUTE(SegmentState8_GetObjectInPath(ptPerf8));                                      //PASSES


//  Loader Tests
//      CHECKEXECUTE(Loader8_LoadObjectTwice(ptPerf8));

    return hr;


}




/******************************************************************************************
CALLDMTEST calls CHECKEXECUTE and also translates a DMTest return code into an hr.

DanRose is HUGE!!!!  Grrr.
******************************************************************************************/
HRESULT DanRose_Tests( HANDLE LogHandle, CtIDirectMusicPerformance8 *ptPerf8 )
{
	HRESULT hr = S_OK;

	// Script Tests

	SETLOG( LogHandle, "danrose", "DMusic", "Script_Init", "Regression" );
    CHECKEXECUTE( Script_Init             ( ptPerf8 ) );   
	
	SETLOG( LogHandle, "danrose", "DMusic", "Script_CallRoutine", "Regression" );
    CHECKEXECUTE( Script_CallRoutine      ( ptPerf8 ) );                  
	
	SETLOG( LogHandle, "danrose", "DMusic", "Script_SetVariableNumber", "Regression" );
    CHECKEXECUTE( Script_SetVariableNumber( ptPerf8 ) );                  
	
	SETLOG( LogHandle, "danrose", "DMusic", "Script_GetVariableNumber", "Regression" );
    CHECKEXECUTE( Script_GetVariableNumber( ptPerf8 ) );                  

	SETLOG( LogHandle, "danrose", "DMusic", "Script_SetvariableObject", "Regression" );
    CHECKEXECUTE( Script_SetVariableObject( ptPerf8 ) );                  
	
	SETLOG( LogHandle, "danrose", "DMusic", "Script_GetVariableObject", "Regression" );
    CHECKEXECUTE( Script_GetVariableObject( ptPerf8 ) );       
                                                                              
	return hr;
}

/******************************************************************************************
These tests must be called on their own test runs, by themselves
******************************************************************************************/
HRESULT Fatal_Tests(HANDLE LogHandle, CtIDirectMusicPerformance8 *ptPerf8)
{
HRESULT hr = S_OK;
//    CHECKEXECUTE(Performance8_Release(ptPerf8));
//    CHECKEXECUTE(Performance8_IsPlaying_Invalid(ptPerf8));

//    CHECKEXECUTE(AudioPath_SetVolume_Invalid(ptPerf8));

//    CALLDMTEST(Performance8_InitAudio(ptPerf8, 0, 0, 0, 0));                               
//    CALLDMTEST(Performance8_InitAudio_Invalid_Feb1(ptPerf8, 0, 0, 0, 0));

return hr;
};

/********************************************************************************
Main code segment for the dmusic tests.
********************************************************************************/
VOID WINAPI DMTest1StartTest(HANDLE LogHandle)
{
	DWORD dwRes = 0;
    HRESULT hr = S_OK;
    CtIDirectMusicPerformance8 *ptPerf8 = NULL;

    //We create and init a performance up front and then use it in all our tests.
    CHECKEXECUTE(CreateAndInitPerformance(&ptPerf8));
    if (FAILED(hr))
        Log(ABORTLOGLEVEL, "CreateAndInitPerformance returned %s (%08X)", dmthXlatHRESULT(hr), hr);

	CHECKEXECUTE(Fatal_Tests  (LogHandle, ptPerf8));
    CHECKEXECUTE(DanHaff_Tests(LogHandle, ptPerf8));
    CHECKEXECUTE( DanRose_Tests( LogHandle, ptPerf8 ) );

    //Closedown and release the performance.
    
    //TODO: Add these calls back in when bug 2642 is fixed.
    //hr = ptPerf8->CloseDown();
    //SAFE_RELEASE(ptPerf8);

}


/********************************************************************************
Placeholder fuunction - does nothing.
********************************************************************************/
VOID WINAPI DMTest1EndTest( VOID )
{
}


/********************************************************************************
Export function pointers of StartTest and EndTest
********************************************************************************/
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DMTest1 )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DMTest1 )
    EXPORT_TABLE_ENTRY( "StartTest", DMTest1StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DMTest1EndTest )
END_EXPORT_TABLE( DMTest1 )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\loader8.cpp ===
/********************************************************************************
FILE:
    LOADER8.cpp

PURPOSE:
    Contains loader test functions.

BY:
    DANROSE
********************************************************************************/
#include "globals.h"



/********************************************************************************
********************************************************************************/
HRESULT Loader8_LoadObjectTwice(CtIDirectMusicPerformance8* ptPerf8)
{
	HRESULT						hr				= 0;
	HRESULT						hrCall          = S_OK;
	CtIDirectMusicSegment8		*ptSegment		= NULL;
	CHAR						*szSegmentFile	= "T:\\MEDIA\\Perf8\\GetSegSt\\DSegTst3.sgt";
	CHAR						*szSegmentPath	= "T:\\MEDIA\\Perf8\\GetSegSt";
    CtIDirectMusicLoader8       *ptLoader8      = NULL;
    BOOL bFailed = FALSE;
    DWORD i;

    // **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &ptLoader8);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
                TEXT("failed (%s === %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Load the Segment Object
    // **********************************************************************
    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize         = sizeof(DMUS_OBJECTDESC);
    desc.guidClass      = CLSID_DirectMusicSegment;
    desc.dwValidData    |= (DMUS_OBJ_CLASS | DMUS_OBJ_FULLPATH);


    // Get the Segment object
    mbstowcs(desc.wszFileName, szSegmentFile, strlen(szSegmentFile) + 1);

    for (i=0; i<2; i++)
    {
        hr = ptLoader8->GetObject(&desc, CTIID_IDirectMusicSegment, (void **)&ptSegment);
        fnsLog(ABORTLOGLEVEL, "dmthLoadSegment(%s) returned %s (%08Xh)", szSegmentFile, tdmXlatHRESULT(hr), hr);
        if(FAILED(hr))
        {
            hrCall = hr;
        }

        SAFE_RELEASE(ptSegment);
    }

    TEST_END:


    SAFE_RELEASE(ptSegment);
    SAFE_RELEASE(ptLoader8);
    return hrCall;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Helpers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       helpers.h
//
//--------------------------------------------------------------------------
#pragma once


#include "globals.h"
#include "dmthcom.h"    // logging implementations of common COM functions
//---------------------------------------------------------------------------

// symbolic constants
#define SZAPPFRIENDLYNAME   "DMTest1"

// minimum logging level
#ifndef MINLOGLEVEL
#define MINLOGLEVEL         0
#endif
// logging level for "test aborting" messages
#ifndef ABORTLOGLEVEL
#define ABORTLOGLEVEL       0
#endif
// logging level for "bug found" messages
#ifndef BUGLOGLEVEL
#define BUGLOGLEVEL         0
#endif
// logging level for "for your information" messages
#ifndef WARNLOGLEVEL
#define WARNLOGLEVEL        1
#endif
// logging level for "for your information" messages
#ifndef FYILOGLEVEL
#define FYILOGLEVEL         2
#endif
// logging level for parameter data
#ifndef PARAMLOGLEVEL
#define PARAMLOGLEVEL       5           
#endif
// logging level for structure contents
#ifndef STRUCTLOGLEVEL
#define STRUCTLOGLEVEL      6
#endif
// maximum logging level
#ifndef MAXLOGLEVEL
#define MAXLOGLEVEL         10
#endif
// max length of a logging string
#ifndef MAX_LOGSTRING
#define MAX_LOGSTRING       256
#endif
// max length of a string
#ifndef MAX_STRING
#define MAX_STRING          256
#endif

//MIDI helpers
#define MAKEPATCH(msb,lsb,patch) (((msb) << 16) | ((lsb) << 8) | (patch))
#define MAKEDRUMS(patch) ((patch) | 0x80000000)

// MIDI EVENT TYPE DEFINES
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define CC_MODWHEEL		0x01
#define CC_VOLUME		0x07
#define CC_PAN			0x0A
#define CC_EXPRESSION	0x0B
#define CC_SUSTAIN		0x40

// Macros to make better use of a dword parameter
#define DMTH_PACK_2WORD(word1,word2) ( (DWORD)( ( (word1) << 16 ) | (word2) ) )
#define DMTH_EXTR_WORD1(dword) ( (dword) >> 16 )
#define DMTH_EXTR_WORD2(dword) ( (dword) & 0x0000FFFF )

// Macros to help handling HRESULTs
#define HR_SUCCESS(hr, f) (SUCCEEDED(hr = f))
#define HR_FAIL(hr, f) (FAILED(hr = f))
#define HR_SOK(hr, f) ((hr = f) == S_OK)
#define HR_FALSE(hr, f) ((hr = f) == S_FALSE)
#define HR_NOTSOK(hr, f) !((hr = f) == S_OK)



HRESULT dmthLoadSegment(CHAR *pSegmentFile, CtIDirectMusicSegment8 **ppwSegment); //dx8
HRESULT dmthCreatePerformance(REFIID riid, CtIDirectMusicPerformance8 **pwPerformance); //dx8

//The following 3 functions are generic helper functions that do the grunt work
//of the Get/Set/Parse Descriptor tests.  They return FNS_<result> code
//For usage, see the Collection Unit tests
DWORD  dmthObject_GetDescriptorTest( CtIUnknown* pCtUnk );
DWORD  dmthObject_SetDescriptorTest( CtIUnknown* pCtUnk );
DWORD  dmthObject_ParseDescriptorTest(IStream* pIStream, CtIUnknown* pCtUnk);


LPVOID TDMGetBogusPointer(void);
void TDMFreeBogusPointer(LPVOID lpv);

DWORD tdmPackDWORD(WORD wHigh, WORD wLow);
BOOL tdmEnableBreakOnDMAssert(BOOL fBreak);

//Make sure you pass the REAL object ptr into these functions!
HRESULT dmthTestQI(IUnknown *pIU_Src, REFIID IID_Src, char *szSrcName, REFIID IID_Dst, char *szDstName); 
HRESULT dmthTestAddRefRelease(IUnknown *pIU_Src, REFIID IID_Src, char *szSrcName);  

BOOL FillBufferWithSineWave(
 LPVOID			    pBuffer, 
 DWORD				dwBufferBytes,
 DWORD              dwFrequency,
 LPWAVEFORMATEX		pWfx,
 DOUBLE				fFactor
 );

DWORD IgnorePChannel(DWORD dwStage);
void CleanUpIUnknown(HRESULT hr, LPUNKNOWN &pUnk);
LPCSTR PathFindFileName(LPCSTR pPath);
HRESULT dmthPlayMidiFile(CtIDirectMusicPerformance8 *pwPerformance8,
						 REFIID riid,
						 CtIDirectMusicSegment8 **ppwSegment8,
						 CtIDirectMusicSegmentState **ppwSegmentState,
                         CHAR *pMidiFile);
HRESULT CreateAndInitPerformance(CtIDirectMusicPerformance8 **ppPerf8);
HRESULT ChopPath(const char *szFullString, char *szPathOut, char *szFileOut);


// **********************************************************************
// **********************************************************************
template <class T>
T* SafeRelease (T* pT)
{
    if (pT)
    {
        pT->Release ();
    }

    return (NULL);
}


// **********************************************************************
//Added by danhaff 08-07-00
//
//PURPOSE:
//Given an array, finds the index of the value you pass.
// **********************************************************************
template <class T> 
DWORD FindIndex(T *pArray, DWORD dwCount, T Target)
{
DWORD i;

for (i=0; i<dwCount; i++)
{
    if (pArray[i] == Target)
    {
        return i;
    }
}
return 0xFFFFFFFF;
};


//===========================================================================
// dmthCreateTestWrappedObject
//
// template for making object creation easier
//
// Parameters:
//  REALOBJECT  *pObj   - pointer to the real object
//  TESTOBJECT  *pptObj - ptr to return newly created test object
//
// Returns: HRESULT
//===========================================================================
template <class REALOBJECT, class TESTOBJECT>
HRESULT _stdcall dmthCreateTestWrappedObject(REALOBJECT *pObj, TESTOBJECT **pptObj)
{
    HRESULT hRes    = E_FAIL;

    // validate pObj
    if(!helpIsValidPtr((void*)pObj, sizeof(REALOBJECT), FALSE))
    {
        fnsLog(MINLOGLEVEL, "Invalid ptr (Arg 1) passed to "
                "dmthCreateTestWrappedObject (%08Xh)",
                pObj);
        return E_POINTER;
    }

    // validate pptObj
    if(!helpIsValidPtr((void*)pptObj, sizeof(TESTOBJECT*), FALSE))
    {
        fnsLog(MINLOGLEVEL, "Invalid ptr (Arg 2) passed to dmthCreateTestWrappedObject (%08Xh)", pptObj);
        return E_POINTER;
    }

    // create the test object
    *pptObj = new TESTOBJECT();
    if(NULL != *pptObj)
    {
        // initialize the test class
        hRes = (*pptObj)->InitTestClass(pObj);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to initalize XXXXX test class (%s == %08Xh)",tdmXlatHRESULT(hRes), hRes);
            delete (*pptObj);
            *pptObj = NULL; 
        }
    }

    // done
    return hRes;

} //*** end dmthCreateTestWrappedObject()


#define AMOUNT(a) (sizeof(a) / sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Helpers.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       Helpers.cpp
//
//--------------------------------------------------------------------------

#define INITGUID
#include "globals.h"

//==========================================================================
// dmthCreatePerformance
//==========================================================================
HRESULT dmthCreatePerformance(REFIID riid, CtIDirectMusicPerformance8 **pwPerformance)
{
    HRESULT                     hr = E_NOTIMPL;
    IDirectMusicPerformance8    *pdmPerformance = NULL;

    if(!pwPerformance)
    {
        return E_INVALIDARG;
    }
    // CoCreate Loader object
    hr = dmthCoCreateInstance(CLSID_DirectMusicPerformance,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          riid,
                          (LPVOID*)&pdmPerformance);
    if(SUCCEEDED(hr) && pdmPerformance)
    {
        // Wrap the Performance object
        *pwPerformance = new CtIDirectMusicPerformance8();
        if(NULL != *pwPerformance)
        {
            hr = (*pwPerformance)->InitTestClass(pdmPerformance);
            if(FAILED(hr))
            {
                (*pwPerformance)->Release();
                (*pwPerformance) = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    // clean up
    if (pdmPerformance)
    {
        pdmPerformance->Release();
        pdmPerformance = NULL;
    }

    return hr;
}



//==========================================================================
// dmthLoadSegment
//
// Does all the leg work for creating a Segment for you.
//==========================================================================
HRESULT dmthLoadSegment(CHAR *pSegmentFile,
                      CtIDirectMusicSegment8 **ppwSegment)
{
    if(pSegmentFile == NULL)
        pSegmentFile = "T:\\Media\\Perf8\\GetSegSt\\DSegTst3.SGT";

    HRESULT                     hr              = E_NOTIMPL;
    CtIDirectMusicLoader8        *pwLoader       = NULL;
    char szSegmentName[MAX_PATH];
    char szSegmentPath[MAX_PATH];


    //Take this path 
    hr = ChopPath(pSegmentFile, szSegmentPath, szSegmentName);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment's ChopPath(%s) failed with %s (%08Xh)", pSegmentFile, tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Load the Segment Object
    // **********************************************************************
    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize         = sizeof(DMUS_OBJECTDESC);
    desc.guidClass      = CLSID_DirectMusicSegment;
    desc.dwValidData    |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);

    hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szSegmentPath, FALSE);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
                TEXT("failed (%s === %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // Get the Segment object
    mbstowcs(desc.wszFileName, szSegmentName, strlen(szSegmentName) + 1);
    hr = pwLoader->GetObject(&desc, CTIID_IDirectMusicSegment8, (void **)ppwSegment);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(Segment) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

TEST_END:
    if(pwLoader)
    {
        pwLoader->Release();
        pwLoader = NULL;
    }
    return hr; //end dmthLoadSegment
}


//===========================================================================
// TDMGetBogusPointer
//
// Creates a bad pointer.
//
// Parameters: none
//
// Returns: LPVOID
//
// History:
//  12/22/1997 - a-llucar - taken from tdinput sources
//===========================================================================
LPVOID TDMGetBogusPointer(void)
{

    // allocate some memory and mark it not accessable
    return VirtualAlloc(NULL, 8, MEM_COMMIT, PAGE_NOACCESS);

} // *** end dihelpGetBogusPointer()


//===========================================================================
// TDMFreeBogusPointer
//
// Frees bad pointer created by helpGetBogusPointer.
//
// Parameters:
//  LPVOID lpv  - pointer to free
//
// Returns: nothing
//
// History:
//  12/22/1997 - a-llucar - taken from tdinput sources
//  1/22/1998 - a-kellyc - added VirtualProtect
//===========================================================================
void TDMFreeBogusPointer(LPVOID lpv)
{
    DWORD   dwOld;

	if(lpv)
	{
		// set the access rights back to read/write
		VirtualProtect(lpv, 8, PAGE_READWRITE, &dwOld);

		// release memory pointed to by lpv
		VirtualFree(lpv, 0, MEM_RELEASE);

		// set it to NULL
		lpv = NULL;
	}
} 


//===========================================================================
// tdmPackDWORD
//
// Packs two WORDs into a DWORD.
//
// Parameters:
//
// Returns: The packed DWORD
//
// History:
//  10/13/1998 - davidkl - created
//===========================================================================
DWORD tdmPackDWORD(WORD wHigh, WORD wLow)
{
    DWORD dw    = 0;

    // start with the high word
    dw = wHigh;
    dw = dw << 16;

    // or in the low word
    dw |= wLow;

    return dw;

} // *** end tdmPackDWORD()


//===========================================================================
// tdmEnableBreakOnDMAssert
//
// Turns on/off the DebugBreak in DirectMusic assertions by adding the
//  AssertBreak and setting the value to 1 (on) or 0 (off)
//
// Parameters:
//
// Returns: BOOL (return code from WriteProfileString)
//
// History:
//  10/22/1998 - davidkl - created
//===========================================================================
BOOL tdmEnableBreakOnDMAssert(BOOL fBreak)
{
    return WriteProfileStringA(TEXT("Debug"),
                    TEXT("AssertBreak"),
                    (fBreak) ? TEXT("1") : TEXT("0"));

} // *** end tdmEnableBreakOnDMAssert()

/*
//Types of data for loader to scan.
static GUID* g_ScanTypes[] = {
                    (GUID*)&CLSID_DirectMusicAudioPathConfig,
                    (GUID*)&CLSID_DirectMusicBand,
                    (GUID*)&CLSID_DirectMusicContainer,
                    (GUID*)&CLSID_DirectMusicCollection,
//                    (GUID*)&CLSID_DirectMusicChordMap,
                    (GUID*)&CLSID_DirectMusicScript,
//                    (GUID*)&CLSID_DirectMusicSong,
//                    (GUID*)&CLSID_DirectMusicStyle,
                    (GUID*)&CLSID_DirectMusicSegment,
//                    (GUID*)&CLSID_DirectMusicGraph,
//                    (GUID*)&CLSID_DirectSoundWave,
                    };
static DWORD g_dwScanTypes = AMOUNT(g_ScanTypes);
*/



/**********************************************************************
**********************************************************************/
BOOL FillBufferWithSineWave 
(
 LPVOID             pBuffer,
 DWORD              dwBufferBytes,
 DWORD              dwFrequency,
 LPWAVEFORMATEX     pWfx,
 DOUBLE             fFactor
 )
{
    int                 i       = 0;
    double              lfPhase = 0;
    const double        pi      = 3.14159265;
    ASSERT(pBuffer);
    if (dwBufferBytes != 0)
    {
        switch (pWfx->wBitsPerSample)
        {
        case 8:
            while (i < (LONG) dwBufferBytes)
            {
                int    nMag;
                int j;
                lfPhase = 2.0*pi*((double)dwFrequency)*i
                          /pWfx->nSamplesPerSec/pWfx->nBlockAlign;
                nMag = (int)(255*sin(lfPhase)+128);

                nMag = (int) (nMag * fFactor);
                for (j=0;j<pWfx->nChannels;j++)
                {
                    ((char*)pBuffer)[i++] = (char)nMag;
                }
            }
            break;
        case 16:
            while (i*2 < (LONG) dwBufferBytes)
            {
                int    nMag;
                int j;
                lfPhase = 2.0*pi*((double)dwFrequency)*i*2
                          /pWfx->nSamplesPerSec/pWfx->nBlockAlign;
                nMag = (int)(((double)0x7fff)*sin(lfPhase));

                nMag = (int) (nMag * fFactor);
                for (j=0;j<pWfx->nChannels;j++)
                {
                    ((short *)pBuffer)[i++] = (short)nMag;
                }
            }
            break;
        default:
            fnsLog(ABORTLOGLEVEL, "FillBufferWithSinWave: Unsupported Format");
            Log(4, "FillBufferWithSinWave: Unsupported Format, filling with silence.");
            memset(pBuffer, 0, dwBufferBytes);
            return TRUE;
        }
    }

    return TRUE;
};




/**********************************************************************
Added by danhaff 07-17-00

PURPOSE:
    For each stage, lists whether the dwPChannel parameter is used or not.
    If it's used, then one should pass DMUS_PCHANNEL_ALL.  Otherwise
    they should pass 0.
**********************************************************************/
struct STAGEDATA
{
    DWORD dwStage;
    BOOL  bPChannelUsed;
};

STAGEDATA g_StageData[] = 
{
    {DMUS_PATH_SEGMENT          , FALSE},
//    {DMUS_PATH_SEGMENT_TRACK    , FALSE},
//    {DMUS_PATH_SEGMENT_GRAPH    , FALSE},
//    {DMUS_PATH_SEGMENT_TOOL     , TRUE},
    {DMUS_PATH_AUDIOPATH        , FALSE},
//    {DMUS_PATH_AUDIOPATH_GRAPH  , FALSE},
//    {DMUS_PATH_AUDIOPATH_TOOL   , TRUE},
    {DMUS_PATH_PERFORMANCE      , FALSE},
//    {DMUS_PATH_PERFORMANCE_GRAPH, FALSE},
//    {DMUS_PATH_PERFORMANCE_TOOL , TRUE},
//    {DMUS_PATH_PORT             , TRUE},
    {DMUS_PATH_BUFFER           , TRUE},
//    {DMUS_PATH_BUFFER_DMO       , TRUE},
    {DMUS_PATH_MIXIN_BUFFER     , FALSE},
//    {DMUS_PATH_MIXIN_BUFFER_DMO , FALSE},
//    {DMUS_PATH_PRIMARY_BUFFER   , FALSE}
};



/**********************************************************************
Added by danhaff 07-17-00

PURPOSE:
    Based on the stage, returns a value that says to GetObjectInPath,
    "Ignore the PChannel".
**********************************************************************/
DWORD IgnorePChannel(DWORD dwStage)
{
    DWORD i=0;

    for (i=0; i<AMOUNT(g_StageData); i++)
    {
        if (dwStage == g_StageData[i].dwStage)
        {
            if (g_StageData[i].bPChannelUsed)
                return DMUS_PCHANNEL_ALL;
            else
                return 0;
        }
    }

    //If we made it through, we were passed an invalid value.
    fnsLog(ABORTLOGLEVEL, 
           TEXT("**** ABORT:  TEST_APP ERROR!!!  dwPChannelIgnore passed invalid stage %s (%08Xh)"),  dmthXlatDMUS_STAGE(dwStage), dwStage);
    
    //This should NEVER EVER EVER HAPPEN!!!
    return -1;
};




/**********************************************************************
Added by danhaff 08-02-00

PURPOSE:
    Releases an IUnknown if a call succeeded, otherwise just NULLs it
    out again.  Prints error if API didn't do it's job.
**********************************************************************/
void CleanUpIUnknown(HRESULT hr, LPUNKNOWN &pUnk)
{
    //Make sure we got rid of pUnk if this succeeded unexpectedly.
    if (SUCCEEDED(hr))
    {
        SAFE_RELEASE(pUnk);
    }

    if (FAILED(hr))
    {
        if (pUnk)
        {
            fnsLog(ABORTLOGLEVEL,"**** FYI:  GetObjectInPath didn't zero out *ppUnkObject");
            pUnk = NULL;
        }
    }
};



/**********************************************************************
Added by danhaff 08-08-00

PURPOSE:
    What it says.

NOTES:
    Copied out of the shell code on index 2 because this isn't on 
    @#$@% Windows 95.
**********************************************************************/
#define TEXTW(quote) L##quote      
LPCWSTR PathFindFileNameW(LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}



/**********************************************************************
**********************************************************************/
LPWSTR PathFindFileNameW(LPWSTR pPath)
{
    LPWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/**********************************************************************
**********************************************************************/
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}






//==========================================================================
//==========================================================================
// dmthPlayMidiFile
// 
// Creates all the objects necessary to create a MIDI event, Loads the Midi
// Event, and plays the MIDI segment.  Standard helper for many tests.

// Parameters:
//	REFIID to Graph
//  pointer to wrapped Graph object
//
//	NOTE:  This returns a Segment Object containing a sequence track.
//
//         DOES NOT SUPPORT UNWRAPPED OBJECTS
//==========================================================================
HRESULT dmthPlayMidiFile(CtIDirectMusicPerformance8 *pwPerformance8,
						 REFIID riid,
						 CtIDirectMusicSegment8 **ppwSegment8,
						 CtIDirectMusicSegmentState **ppwSegmentState,
                         CHAR *pMidiFile)

{		
	if (pMidiFile == NULL)
		pMidiFile = g_szDefaultMedia;

    HRESULT hr = S_OK;
	DMUS_OBJECTDESC DESC = {0};					// Descriptor to use to find it.
    CtIDirectMusicLoader8 *ptLoader8 = NULL;
    CtIDirectMusicSegment8 *ptSegment8 = NULL;
    CtIDirectMusicSegmentState8 *ptSegmentState = NULL;
    CtIDirectMusicAudioPath  *ptPath = NULL;

/*BUGBUG: Performance already init'd.
    hr = pwPerformance8->InitAudio(NULL, NULL, NULL, DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, NULL, NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT:  pwPerformance->InitAudio failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }
*/

    hr = pwPerformance8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, TRUE, &ptPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: CreateStandardAudioPath failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &ptLoader8);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: dmthCreateLoader failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


    hr = ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment8, pMidiFile, (void **)&ptSegment8);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: pLoader8->LoadObjectFromFile failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptSegment8->Download(pwPerformance8);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: ptSegment8->Download failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = pwPerformance8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, 0, &ptSegmentState, NULL, ptPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: pwPerformance->PlaySegmentEx failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    *ppwSegment8        = ptSegment8;
    if (ppwSegmentState)
    {
        *ppwSegmentState   = ptSegmentState;
    }
    else
    {
        ptSegmentState->Release();
        *ppwSegmentState = NULL;
    }
	
TEST_END:

    SAFE_RELEASE(ptLoader8);
    SAFE_RELEASE(ptPath);
    return hr;


} // end dmthPlayMidiFile()



/********************************************************************************
********************************************************************************/
HRESULT CreateAndInitPerformance(CtIDirectMusicPerformance8 **pptPerf8)
{
HRESULT hr = S_OK;
CtIDirectMusicPerformance8 *ptPerf8 = NULL;

hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &ptPerf8);
if (FAILED(hr))
    goto END;

hr = ptPerf8->InitAudioX(NULL, NULL);
if (FAILED(hr))
{
    SAFE_RELEASE(ptPerf8);
    goto END;
}

END:
    *pptPerf8 = ptPerf8;
    return hr;

};


/********************************************************************************
********************************************************************************/
HRESULT ChopPath(const char *szFullString, char *szPathOut, char *szFileOut)
{
char *szFile = NULL;
char *szPath = NULL;
DWORD dwLength;

if (!szFullString)
{
    *szFile = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (char *)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

strcpy(szFileOut, szFile);

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szPathOut, szFullString, dwLength);
szPathOut[dwLength] = NULL;

return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\nakedmacros.h ===
#pragma once

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}

#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Logging.h ===
#define DEBUG 1
#define FILE 2
#define CONSOLE 4
#define ALL 7


#define ABORTLOGLEVEL 1
#define FYILOGLEVEL 2


void Log
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags,
    LPSTR                   szFormat,
    ...
);

//Logs everywhere.
void Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
);


//So the test logging will still work.  Grrr.
void fnsLog
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags, 
    LPSTR                   szFormat,
    ...
);

void fnsLog
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
);



void LogSetDbgLevel(DWORD dwLevel);
void LogIncrementIndent();
void LogDecrementIndent();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Logging.cpp ===
#include "globals.h"
DWORD g_dwDebugLevel = 5;
DWORD g_dwIndentLevel = 0;


/********************************************************************************
********************************************************************************/
void LogSetDbgLevel(DWORD dwLevel)
{
    g_dwDebugLevel = dwLevel;
}


void LogIncrementIndent()
{
    g_dwIndentLevel++;
};


void LogDecrementIndent()
{
    g_dwIndentLevel--;
};


/********************************************************************************
********************************************************************************/
void LogConsole
(
    LPSTR                   szFormat,
    ...
)
{
    //FOR NOW, SINCE WE DON'T HAVE CONSOLE OUTPUT!!
    return;
    
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    //A carriage return goes here when we've decided not to output to VC anymore!!
    DbgPrint("CONSOLE:%s\n",szBuffer);

};


/********************************************************************************
********************************************************************************/
void Log
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
    if (dwDestinationFlags & DEBUG)
        DbgPrint("%s\n", szBuffer);
/*
    if (dwDestinationFlags & FILE)
        xLog(g_hLog, XLL_PASS, szBuffer);
*/
    if (dwDestinationFlags & CONSOLE)
        LogConsole(szBuffer);
};

/********************************************************************************
********************************************************************************/
void Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
        DbgPrint("%s\n", szBuffer);
        LogConsole(szBuffer);
};

/********************************************************************************
********************************************************************************/
void fnsLog
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
    if (dwDestinationFlags & DEBUG)
        DbgPrint("%s\n", szBuffer);
    if (dwDestinationFlags & FILE)
        xLog(g_hLog, XLL_PASS, szBuffer);
    if (dwDestinationFlags & CONSOLE)
        LogConsole(szBuffer);
};

/********************************************************************************
********************************************************************************/
void fnsLog
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
)
{

    va_list va;
    if (dwLevel > g_dwDebugLevel)
        return;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);
    
        DbgPrint("%s\n", szBuffer);
//        xLog(g_hLog, XLL_PASS, szBuffer);
        LogConsole(szBuffer);
};



/*
void Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
)
{
    char szBuffer[1000];
    va_list va;
    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);

    Log(dwLevel, ALL, szFormat, va);

    va_end(va);
}


void fnsLog
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags, 
    LPSTR                   szFormat,
    ...
)
{
    char szBuffer[1000];
    va_list va;
    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);

    Log(dwLevel, dwDestinationFlags, szFormat, va);
    va_end(va);
}


void fnsLog
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
)
{
    char szBuffer[1000];
    va_list va;
    va_start(va, szFormat);

    vsprintf(szBuffer, szFormat, va);

    fnsLog(dwLevel, ALL, szFormat, va);
    va_end(va);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_AddNotificationType.cpp ===
#include "globals.h"
#include "cicmusicx.h"



DWORD Performance8_AddRemoveNotifications(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwParam1, DWORD dwParam2);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_AddNotificationType (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_AddNotificationType())");

    //These tests take care of Add, Remove, and GetNotificationPMsg.
    //These are called first.
    //dwParam3.  bit 1 = AddNotification(MeasureAndBeat)
    //dwParam3.  bit 2 = AddNotification(Performance)
    //dwParam3.  bit 3 = AddNotification(Segment)

    //These are called second.
    //dwParam4.  bit 1 = RemoveNotification(MeasureAndBeat)
    //dwParam4.  bit 2 = RemoveNotification(Performance)
    //dwParam4.  bit 3 = RemoveNotification(Segment)    

    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 1, 0));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 2, 0));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 4, 0));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 7, 0));       

    //Make sure that each Removal cancels the other ones ou
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 1, 1));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 2, 2));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 4, 4));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 7, 7));       

    //Make sure that each removal.is the correct one.
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 1, 2));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 2, 4));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 4, 1));

    //Make sure that duplicate removals don't hurt anything
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 0, 1));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 0, 2));       
    CALLDMTEST(Performance8_AddRemoveNotifications(ptPerf8, 0, 4));
    return hr;
};



/********************************************************************************


guidNotificationType
--------------------
Which of these are pertinent to XBox:


GUID_NOTIFICATION_MEASUREANDBEAT 
Measure and beat event. 
GUID_NOTIFICATION_PERFORMANCE 
Performance event, further defined in dwNotificationOption. 
GUID_NOTIFICATION_SEGMENT 
Segment event, further defined in dwNotificationOption. 
YES


dwNotificationOption 
--------------------
There are all pertinent to XBox.

Identifier of the notification subtype. 
If the notification type is GUID_NOTIFICATION_SEGMENT, this member can contain one of the following values: 
DMUS_NOTIFICATION_SEGABORT 
The segment was stopped prematurely, or was removed from the primary segment queue. 
DMUS_NOTIFICATION_SEGALMOSTEND 
The segment has reached the end minus the prepare time. 
DMUS_NOTIFICATION_SEGEND 
The segment has ended. 
DMUS_NOTIFICATION_SEGLOOP 
The segment has looped. 
DMUS_NOTIFICATION_SEGSTART 
The segment has started. 


If the notification type is GUID_NOTIFICATION_PERFORMANCE, this member can contain one of the following values: 
DMUS_NOTIFICATION_MUSICALMOSTEND 
The currently playing primary segment has reached the end minus the prepare time, and no more primary segments are cued to play. 
DMUS_NOTIFICATION_MUSICSTARTED 
Playback has started. 
DMUS_NOTIFICATION_MUSICSTOPPED 
Playback has stopped. 


********************************************************************************/


/********************************************************************************
IDirectMusicPerformance8::AddNotificationType()

//One piece of code can test both addage and removal.

HISTORY:
    Updated     04/05/00      danhaff - created.

//TODO: Since we're not looping yet, we don't get any loop messages.  We need
/       to write another test to check for these.
********************************************************************************/
struct PMSG_COUNTER
{
    DMUS_NOTIFICATION_PMSG * pMsg[48];
    DWORD                    dwCount;
    DWORD                    dwExpected;
};

DWORD Performance8_AddRemoveNotifications(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwParam1, DWORD dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT						hr				= S_OK;
    CICMusic                    Music;
    CtIDirectMusicAudioPath     *ptAudioPath     = NULL;
    CtIDirectMusicSegment8      *ptSegment8        = NULL;
    DWORD                       i = 0;
    HANDLE hNotify            = NULL;

    DMUS_NOTIFICATION_PMSG *    pMsg = NULL;

    PMSG_COUNTER PMsgCounter[3] = { 
                                    {{0}, 0, 48}, //Should have 3 x 16 notifications (3 because of the tracks)
                                    {{0}, 0, 3},
                                    {{0}, 0, 3}
                                  };

    BOOL bAdd[3] = {0};
    BOOL bRem[3] = {0};
    GUID *pGuid[3] = {(GUID *)&GUID_NOTIFICATION_MEASUREANDBEAT,
                      (GUID *)&GUID_NOTIFICATION_PERFORMANCE,
                      (GUID *)&GUID_NOTIFICATION_SEGMENT
                      };
    char *pszName[3] = {"GUID_NOTIFICATION_MEASUREANDBEAT",
                      "GUID_NOTIFICATION_PERFORMANCE",
                      "GUID_NOTIFICATION_SEGMENT"
                      };

    
    //We should get 16 of these.
    DMUS_NOTIFICATION_PMSG *    pMsgNotificationMeasureAndBeat[16] = {0};

    //Should get 3 of these.
    DMUS_NOTIFICATION_PMSG *    pMsgNotificationPerformance[3] = {0};

    //Should get 3 of these, even though there's a total of 5.
    //  We'll test for those later.
    DMUS_NOTIFICATION_PMSG *    pMsgNotificationSegment[3] = {0};

    DWORD dwAddNotificationTypes = dwParam1;
    DWORD dwRemNotificationTypes = dwParam2;

    DWORD dwStartTime;
    DWORD dwDeltaTime;
    DWORD j;

    /*
    #define TEST_MEASUREANDBEAT 0
    #define TEST_PERFORMANCE    1
    #define TEST_SEGMENT        2
*/


    //Create a handle.
    hNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hNotify)
        goto TEST_END;
    
    //Start the music playing.
    hr = Music.Init(ptPerf8, "T:\\Media\\Perf8\\AddNot\\Notify.sgt", DMUS_APATH_DYNAMIC_STEREO);
    if (S_OK != hr)
        goto TEST_END;

    //Get the IDirectMusicAudioPath interface.
    hr = Music.GetInterface(&ptAudioPath);
    if (S_OK != hr)
        goto TEST_END;

    //Get the IDirectMusicSegment interface.
    hr = Music.GetInterface(&ptSegment8);
    if (S_OK != hr)
        goto TEST_END;


    //Stop the music for the moment.
    hr = ptPerf8->StopEx(ptSegment8, 0, 0);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


    //Tell the segment to repeat twice.
    hr = ptSegment8->SetRepeats(2);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: SetRepeats() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //Set up the array of Booleans.
    for (i=0; i<3; i++)
    {
        bAdd[i] = dwAddNotificationTypes & (1 << i);
        bRem[i] = dwRemNotificationTypes & (1 << i);
    }


    //Add notification types.
    for (i=0; i<3; i++)
    {
        if (bAdd[i])
        {
            hr = ptPerf8->AddNotificationType(*pGuid[i]);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: AddNotificationType(%s) returned %s (%08Xh)",pszName[i],tdmXlatHRESULT(hr), hr);
                goto TEST_END;
            }
        }
    }

    //Remove notification types.
    for (i=0; i<3; i++)
    {
        if (bRem[i])
        {
            hr = ptPerf8->RemoveNotificationType(*pGuid[i]);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: RemNotificationType(%s) returned %s (%08Xh)",pszName[i],tdmXlatHRESULT(hr), hr);
                goto TEST_END;
            }
        }
    }


    //Play on the audiopath.
    hr = ptPerf8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, NULL, NULL, NULL, ptAudioPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //Wait for segment to start playing.
    fnsLog(FYILOGLEVEL, "Waiting for segment to start playing");
    while (ptPerf8->IsPlaying(ptSegment8, NULL) != S_OK);

    //Time to start recording the events that come in.   Do this for 10 seconds.
    dwStartTime = timeGetTime();
    dwDeltaTime = 0;
    do
    {
        pMsg = NULL;
        hr = ptPerf8->GetNotificationPMsg(&pMsg);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: GetNotificationPMsg() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }


        //If we got one, then store it somewhere.
        if (S_OK == hr)
        {
            for (i=0; i<3; i++)
            {
                if (memcmp((void *)&pMsg->guidNotificationType, (void *)&pGuid[i], sizeof(GUID)))
                {
                    fnsLog(FYILOGLEVEL, "Got notification %d for %s", PMsgCounter[i].dwCount, pszName[i]);
                    if (PMsgCounter[i].dwCount == PMsgCounter[i].dwExpected)
                    {
                        fnsLog(ABORTLOGLEVEL, "**** ABORT: Got more than %d notifications for GUID_NOTIFICATION_MEASUREANDBEAT", PMsgCounter[i].dwExpected);
                        goto TEST_END;
                    }

                    PMsgCounter[i].pMsg[PMsgCounter[i].dwCount] = pMsg;
                    PMsgCounter[i].dwCount++;

                    break;
                }
            }        
        }
        dwDeltaTime = timeGetTime() - dwStartTime;
    }
    //while (dwDeltaTime < 10000);
    while (ptPerf8->IsPlaying(ptSegment8, NULL) == S_OK);


    //TODO: Go through all the PMsgs and analyze them.


    //Analyze the counts of each type according to the flags that were passed in.
    for (i=0; i<3; i++)
    {
        if (bAdd[i] && !bRem[i])
        {
            if (PMsgCounter[i].dwCount != PMsgCounter[i].dwExpected)
            {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Got %d notifications for %s instead of %d",
                                      PMsgCounter[i].dwCount, pszName[i], PMsgCounter[i].dwExpected);
                goto TEST_END;
            }
        }
        else
        {
            if (PMsgCounter[i].dwCount !=  0)
            {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Got %d notifications for %s instead of 0", PMsgCounter[i].dwCount, pszName[i]);
                goto TEST_END;
            }
        }
    }



    for (i=0; i<3; i++)
    {
        //Release all the NotificationMeasureAndBeat pMsgs.
        for (j=0; j<16; j++)
        {
            if (PMsgCounter[i].pMsg[j])
            {
                hr = ptPerf8->FreePMsg((DMUS_PMSG*)PMsgCounter[i].pMsg[j]);
                if (S_OK != hr)
                {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: FreePMsg() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
                    goto TEST_END;
                }
                PMsgCounter[i].pMsg[j] = NULL;
            }
        }
    }

    dwRes = FNS_PASS;

TEST_END:
   SAFE_RELEASE(ptAudioPath);
   SAFE_RELEASE(ptSegment8);
   if (hNotify)
        CloseHandle(hNotify);

    return dwRes;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_CloseDown.cpp ===
/********************************************************************************
FILE:
    Performance8_CloseDown.cpp

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_CloseDown(TESTPARAMS);

/********************************************************************************
Main test function.
********************************************************************************/
/*
HRESULT Performance8_CloseDown (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_CloseDown())");

    CALLDMTEST(Performance8_CloseDown(ptPerf8, 0, 0, 0, 0));

    return hr;
};
*/
/********************************************************************************
********************************************************************************/
/*
DWORD Performance8_CloseDown(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;

    //Attempt to closedown the global performance.
    hr = ptPerf8->CloseDown();
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "**** ABORT: Closedown returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //Start it up again.  This is critical!!
    hr = ptPerf8->InitAudioX(NULL, NULL);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "**** ABORT: InitAudio returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        Log(ABORTLOGLEVEL, "**** ABORT: Testing will NOT be able to continue!!!!");
        goto TEST_END;
    }


    dwRes = FNS_PASS;

TEST_END:
    return dwRes;
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_AllocPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_AllocPMsg (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_AllocPMsg())");

    fnsLog(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN SendPMsg ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Loader_CollectGarbage.cpp ===
/********************************************************************************
	FILE:
		Loader_CollectGarbage.cpp

	PURPOSE:
		CollectGarbage Tests for Loader

	BY:
		DANROSE
********************************************************************************/

#include <loader8.h>

static const LPSTR MEDIA_ROOT = "T:\\media";

static GUID* guids[] = {
	(GUID*) &CLSID_DirectMusicSegment,
	(GUID*) &CLSID_DirectMusicBand,
	(GUID*) &CLSID_DirectMusicScript,
	(GUID*) &CLSID_DirectMusicAudioPathConfig
};

static GUID* interfaces[] = { 
	(GUID*) &CTIID_IDirectMusicSegment,
	(GUID*) &CTIID_IDirectMusicBand,
	(GUID*) &CTIID_IDirectMusicScript,
	(GUID*) &CTIID_IUnknown 
};

struct ListNode {
	ListNode* pNext;
	CtIUnknown* pUnk;
};

static ListNode* g_pList = NULL;

void Insert( CtIUnknown* pUnk )
{
	ListNode* pTemp = new ListNode();
	pTemp->pUnk = pUnk;
	pTemp->pNext = g_pList;
	g_pList = pTemp;
}

void Delete()
{
	for( ListNode* pNode = g_pList; pNode != NULL; pNode = g_pList )
	{
		g_pList = pNode->pNext;
		RELEASE( pNode->pUnk );
		delete pNode;
		pNode = NULL;
	}
}

HRESULT dmthLoadFile( LPSTR szFileName, CtIDirectMusicLoader8* pLoader, CtIUnknown** ppUnk )
{
	if ( NULL == szFileName || NULL == pLoader || NULL == ppUnk )
		return E_POINTER;

	HRESULT hr = S_OK;

	for ( ULONG i = 0; i < NUMELEMS( interfaces ); i++ )
	{

		CHECKRUN( pLoader->LoadObjectFromFile( *guids[i], *interfaces[i], szFileName, (LPVOID*) ppUnk ) );
	
		if ( SUCCEEDED( hr ) )
		{
			break;
		} else {
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT LoadOneFile( LPSTR szFile, CtIDirectMusicLoader8* pLoader )
{
	HRESULT hr = S_OK;

	CtIUnknown* pUnk = NULL;

	CHECKRUN( dmthLoadFile( szFile, pLoader, &pUnk ) );

	if ( pUnk && SUCCEEDED( hr ) )
	{
		Insert( pUnk );

		DbgPrint( "********************* %s\n", szFile );
	}

	RELEASE( pUnk );

	return hr;
}

HRESULT RecurseDirectory( LPSTR szDir, CtIDirectMusicLoader8* pLoader  )
{
	HRESULT hr = S_OK;

	WIN32_FIND_DATA findData;
	BOOL bMore = TRUE;
	HANDLE hFiles;

	CHAR szFullPath[MAX_PATH];
	CHAR szFiles[MAX_PATH];

	sprintf( szFiles, "%s\\*", szDir ); 

	hFiles = FindFirstFile( szFiles, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore && SUCCEEDED( hr ) )
	{
		sprintf( szFullPath, "%s\\%s", szDir, findData.cFileName );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CHECKRUN( RecurseDirectory( szFullPath, pLoader ) );
		}

		else
		{
			CHECKRUN( LoadOneFile( szFullPath, pLoader ) );
		}

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}

HRESULT Loader_CollectGarbage( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );

	CHECKRUN( RecurseDirectory( MEDIA_ROOT, pLoader ) );
//	CHECKRUN( LoadOneFile( "T:\\media\\old\\SonicImplants Live Band.sgt", pLoader ) );

	for ( ListNode* pNode = g_pList; pNode != NULL && SUCCEEDED( hr ); pNode = pNode->pNext )
	{
		CHECKRUN( pLoader->ReleaseObjectByUnknown( pNode->pUnk ) );
	}

	pLoader->CollectGarbage();

	Delete();

	RELEASE( pLoader );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_CreateStandardAudioPath.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_CreateStandardAudioPath_BVT(TESTPARAMS);
DWORD Performance8_Play2AudioPaths(TESTPARAMS);
HRESULT Performance8_CreateStandardAudioPath_Sleep(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_CreateStandardAudioPath())");

    CALLDMTEST(Performance8_CreateStandardAudioPath_BVT(ptPerf8, 0, 0, 0, 0));  //Fails due to 2762
    CALLDMTEST(Performance8_Play2AudioPaths(ptPerf8, 0, 0, 0, 0));              //PASSES!
    CALLDMTEST(Performance8_CreateStandardAudioPath_Sleep(ptPerf8));         //Fails due to 2987

    return hr;
};



/********************************************************************************
//Later we'll go through the entire audiopath and make sure we can get everything
//  out of it.  For now though we'll just play a bunch of stuff on them.

********************************************************************************/
DWORD Performance8_CreateStandardAudioPath_BVT(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath     = NULL;
DWORD dwStandardPaths[] = {DMUS_APATH_SHARED_STEREOPLUSREVERB, 
                         DMUS_APATH_DYNAMIC_MONO,
                         DMUS_APATH_DYNAMIC_STEREO,
                         DMUS_APATH_DYNAMIC_3D};
DWORD dwPChannelValues[] = {1, 16, 17, 999, 1000};
BOOL bActivateValues[] = {0, 1, 2, 0xFFFFFFFF};
DWORD dwStandardPath = 0;
DWORD dwPChannelValue = 0;
DWORD dwActivateValue = 0;


    //Load Default Media.
    hr = dmthLoadSegment(g_szDefaultMedia, &ptSegment8);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment function returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    for (dwStandardPath = 0; dwStandardPath<AMOUNT(dwStandardPaths); dwStandardPath++)
    {
        for (dwPChannelValue=0; dwPChannelValue<AMOUNT(dwPChannelValues); dwPChannelValue++)
        {
            for (dwActivateValue=0; dwActivateValue<AMOUNT(bActivateValues); dwActivateValue++)
            {
                //Create the audiopath.
                fnsLog(FYILOGLEVEL, "dwStandardPath = %s", dmthXlatDMUS_APATH(dwStandardPaths[dwStandardPath]));
                fnsLog(FYILOGLEVEL, "dwPChannels    = %d", dwPChannelValues[dwPChannelValue]);
                fnsLog(FYILOGLEVEL, "Activate       = %s", bActivateValues[dwActivateValue] ? "TRUE " : "FALSE");
                hr = ptPerf8->CreateStandardAudioPath(dwStandardPaths[dwStandardPath],
                                                      dwPChannelValues[dwPChannelValue],
                                                      bActivateValues[dwActivateValue],
                                                      &ptPath);
                if (S_OK != hr)
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath(%s, %d, %d) returned %s (%08Xh) instead of S_OK",
                                          dmthXlatDMUS_APATH(dwStandardPaths[dwStandardPath]),
                                          dwPChannelValues[dwPChannelValue],
                                          bActivateValues[dwActivateValue],
                                          tdmXlatHRESULT(hr),
                                          hr);
		            goto TEST_END;
	            }
                
                //If it's an active audiopath, download to and try to play the segment.
                if (bActivateValues[dwActivateValue])
                {

                    hr = ptSegment8->Download(ptPath); 
                    //hr = ptSegment8->Download(ptPerf8);  //BUGBUG
	                if(FAILED(hr))
	                {
                        fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		                goto TEST_END;
	                }

	                hr = ptPerf8->PlaySegmentEx( 
		                ptSegment8, 
		                0,
		                NULL,
                        0, 
		                //DMUS_SEGF_QUEUE,
		                0,
		                NULL,
		                NULL,
		                ptPath);

	                if(FAILED(hr))
	                {
                        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx function returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		                goto TEST_END;
	                }

                    fnsLog(FYILOGLEVEL, "Playing segment on active audiopath for 3 seconds.");
                    Sleep(3000);

                    //Unload - necessary to counteract all downloads!
                    hr = ptSegment8->Unload(ptPath);
	                if(FAILED(hr))
	                {
                        fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		                goto TEST_END;
	                }

                    //Stop the segment (is this necessary?)
	                hr = ptPerf8->StopEx(ptSegment8, 0, 0);
                    if(FAILED(hr))
	                {
                        fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		                goto TEST_END;
	                }

                }
                
                //Release the audiopath.  The segment should stop playing.
                SAFE_RELEASE(ptPath);
            }
        }
    }


    dwRes = FNS_PASS;


TEST_END:
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return dwRes;
};



/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
DWORD Performance8_Play2AudioPaths(TESTPARAMS)
{
DWORD dwRes                                             = FNS_FAIL;
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath[2]          = {NULL};
CtIDirectMusicSegmentState         *ptSegmentState[2] = {NULL};
CtIDirectMusicSegment8              *ptSegment8[2]      = {NULL};
//CHAR *szFileName[2]               = {g_szDefaultMedia, "T:\\Media\\Sample\\lfive.sgt"};
CHAR *szFileName[2]               = {g_szDefaultMedia, "T:\\Media\\Sample\\lfive.sgt"};
BOOL bDownloaded[2] = {0};
DWORD i, dwIteration;


    for (dwIteration = 0; dwIteration < 2; dwIteration++)
    {

        //Create the audiopath.
        for (i=0; i<2; i++)
        {
            hr = ptPerf8->CreateStandardAudioPath(i ? DMUS_APATH_DYNAMIC_MONO : DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                                  i ? 32 :                      64,
                                                  TRUE,
                                                  &ptPath[i]);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath(%d) returned %s (%08Xh) instead of S_OK",i, tdmXlatHRESULT(hr),hr);
	            goto TEST_END;
            }

            //Load a segment.
            dmthLoadSegment(szFileName[i], &ptSegment8[i]);
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName[i], tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }



            //Download our segment to both audiopaths or single audiopath (depending on test parameters)
            hr = ptSegment8[i]->Download(ptPath[i]); 
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
            bDownloaded[i] = TRUE;

            //PlaySegment.
	        hr = ptPerf8->PlaySegmentEx(ptSegment8[i],
                                        0,
                                        0,
                                        i ? DMUS_SEGF_SECONDARY : 0,
                                        0,
                                        &ptSegmentState[i],
                                        0,
                                        ptPath[i]);

	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx(%s) function returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
            fnsLog(FYILOGLEVEL, " Playing %s as %s segment for 4 seconds.", szFileName, i ? "secondary " : "primary ");
        }

        //Moment of silence.
        Sleep(4000);

        //Stop everything anyway.
        hr = ptPerf8->StopEx(0, 0, 0);
        if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }

        fnsLog(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop");
        Sleep(1000);

        //Cleanup
        for (i=0; i<2; i++)
        {

            if (ptSegment8[i] && ptPath[i] && bDownloaded[i])
            {
                hr = ptSegment8[i]->Unload(ptPath[i]);
	            if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                bDownloaded[i] = FALSE;
            }
        }

        //Release all items that might have been allocated.
        for (i=0; i<2; i++)
        {
            SAFE_RELEASE(ptSegment8[i]);
            SAFE_RELEASE(ptPath[i]);
            SAFE_RELEASE(ptSegmentState[i]);
        }

    }//end for dwIteration.


    dwRes = FNS_PASS;

TEST_END:

    //Unload - necessary to counteract all downloads!
    for (i=0; i<2; i++)
    {

        if (ptSegment8[i] && ptPath[i] && bDownloaded[i])
        {
            hr = ptSegment8[i]->Unload(ptPath[i]);
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
        }
    }

    //Release all items that might have been allocated.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment8[i]);
        SAFE_RELEASE(ptPath[i]);
        SAFE_RELEASE(ptSegmentState[i]);
    }

    return dwRes;

};









/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
DWORD Performance8_CreateStandardAudioPath_Sleep1(TESTPARAMS)
{
DWORD dwRes                                             = FNS_FAIL;
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName               = g_szDefaultMedia;
BOOL bDownloaded = {0};
DWORD i = 0;


    //Create the audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	    goto TEST_END;
    }


    //Load up media file.
    dmthLoadSegment(szFileName, &ptSegment8);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}


    hr = ptSegment8->Download(ptPath); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    bDownloaded = TRUE;


    //Play our segments.
    fnsLog(FYILOGLEVEL, "Playing Segment:");
	hr = ptPerf8->PlaySegmentEx(ptSegment8,
                                0,
                                0,
                                0,
                                0,
                                NULL,
                                0,
                                ptPath);

	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx(%s) function returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, " Playing %s as %s segment.", szFileName, i ? "secondary " : "primary ");


    //Now both segments are playing.
    fnsLog(FYILOGLEVEL, "Should hear music playing for 2 seconds.");
    Sleep(2000);


    hr = ptPerf8->StopEx(NULL, 0, 0);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL)");


    //Moment of silence.
    fnsLog(FYILOGLEVEL, "Waiting 4 seconds");
    Sleep(4000);


    dwRes = FNS_PASS;

TEST_END:

    //Unload - necessary to counteract all downloads!
    if (ptSegment8 && ptPath && bDownloaded)
    {
        hr = ptSegment8->Unload(ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
    }

    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return dwRes;

};




/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
DWORD Performance8_CreateStandardAudioPath_Sleep2(TESTPARAMS)
{
DWORD dwRes                                             = FNS_FAIL;
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName               = g_szDefaultMedia;
BOOL bDownloaded = {0};
DWORD i = 0;


    //Create the audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	    goto TEST_END;
    }


    //Load up media file.
    dmthLoadSegment(szFileName, &ptSegment8);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}


    hr = ptSegment8->Download(ptPath); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    bDownloaded = TRUE;


    //Play our segments.
    fnsLog(FYILOGLEVEL, "Playing Segment:");
	hr = ptPerf8->PlaySegmentEx(ptSegment8,
                                0,
                                0,
                                0,
                                0,
                                NULL,
                                0,
                                ptPath);

	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx(%s) function returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, " Playing %s as %s segment.", szFileName, i ? "secondary " : "primary ");


    //Now both segments are playing.
    fnsLog(FYILOGLEVEL, "Should hear music playing for 5 seconds.");
    Sleep(5000);


    hr = ptPerf8->StopEx(NULL, 0, 0);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    fnsLog(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 4 seconds");


    dwRes = FNS_PASS;

TEST_END:

    //Unload - necessary to counteract all downloads!

    if (ptSegment8 && ptPath && bDownloaded)
    {
        hr = ptSegment8->Unload(ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
    }

    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);

    return dwRes;

};




/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_CreateStandardAudioPath_Sleep(CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_StopEx())");
    CALLDMTEST(Performance8_CreateStandardAudioPath_Sleep1(ptPerf8, 0,  0,0, 0));  //SCREWS UP MUSIC FOR NEXT TESTS.
    CALLDMTEST(Performance8_CreateStandardAudioPath_Sleep2(ptPerf8, 0,  0,0, 0));  

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_GetNotificationPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_GetNotificationPMsg (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_GetNotificationPMsg())");

    fnsLog(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN SendPMsg ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_GetGlobalParam.cpp ===
#include "globals.h"
#include "cicmusicx.h"


#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_GetGlobalParam_Groove_BVT(TESTPARAMS);
DWORD Performance8_GetGlobalParam_Tempo_BVT(TESTPARAMS);
DWORD Performance8_GetGlobalParam_Volume_BVT(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_GetGlobalParam (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_GetGlobalParam())");

    CALLDMTEST(Performance8_GetGlobalParam_Groove_BVT(ptPerf8, 0, 0, 0, 0));
    CALLDMTEST(Performance8_GetGlobalParam_Tempo_BVT (ptPerf8, 0, 0, 0, 0));
    CALLDMTEST(Performance8_GetGlobalParam_Volume_BVT(ptPerf8, 0, 0, 0, 0));

    return hr;
};


/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_GetGlobalParam_Groove_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    char bOldMasterGrooveLevel                               = 0;
    char bNewMasterGrooveLevel                            = 0;
    CHAR *szSegment = "T:\\Media\\Perf8\\SetGlob\\Groove.sgt";
    char i = 0;


    //Set the groove level to 1.
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bOldMasterGrooveLevel, sizeof(bOldMasterGrooveLevel));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    

    //Start music playing.
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }


    //Go through all the groove levels.
    for (i=0; i<=100; i++)
    {
    
        bNewMasterGrooveLevel = i;
        fnsLog(FYILOGLEVEL, "Setting bNewMasterGrooveLevel to %d", i);
        hr = ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&i, sizeof(i));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        hr = ptPerf8->GetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bNewMasterGrooveLevel, sizeof(bNewMasterGrooveLevel));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        if (bNewMasterGrooveLevel != i)
        {
            fnsLog(ABORTLOGLEVEL, "Error: We set a groove level of %d and retrieved %d", i, bNewMasterGrooveLevel);
	        goto TEST_END;
        }
    }

    //Set the old one again.
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&bOldMasterGrooveLevel, sizeof(bOldMasterGrooveLevel));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    


    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};





/********************************************************************************
********************************************************************************/
DWORD Performance8_GetGlobalParam_Tempo_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    FLOAT fOldTempo                               = 0;
    FLOAT fNewTempo                            = 0;
    CHAR *szSegment = g_szDefaultMedia;
    FLOAT f = 0;

    //Set the groove level to 1.
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    

    //Start music playing.
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }
    Sleep(2000);


    //Set the tempo up way high.
    for (f = DMUS_MASTERTEMPO_MIN; f < DMUS_MASTERTEMPO_MAX; f+= (DMUS_MASTERTEMPO_MAX - DMUS_MASTERTEMPO_MIN) / 10)
    {
        fnsLog(ABORTLOGLEVEL, "Setting fNewTempo to %g.", f);
        hr = ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&f, sizeof(f));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        hr = ptPerf8->GetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempo, sizeof(fNewTempo));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        if (fNewTempo != f)
        {
            fnsLog(ABORTLOGLEVEL, "Error: We set a tempo of %d and retrieved %d", f, fNewTempo);
	        goto TEST_END;
        }
    }

    //Set the old one again.
    fnsLog(ABORTLOGLEVEL, "Setting tempo back to %d", fOldTempo);
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    Sleep(1000);



    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};



/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_GetGlobalParam_Volume_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    long  lOldVolume                               = 0;
    long lNewVolume                            = 0;
    CHAR *szSegment = g_szDefaultMedia;
    long i = 0;

    //Set the groove level to 1.
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    

    //Start music playing.
    fnsLog(FYILOGLEVEL, "Playing %s normally.", szSegment);
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }


    //Set the Volume up way high.
    for (i = -200; i<=20; i++)
    {
        fnsLog(ABORTLOGLEVEL, "Setting Volume to %d", i);
        hr = ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&i, sizeof(i));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        hr = ptPerf8->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lNewVolume, sizeof(lNewVolume));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        if (i != lNewVolume)
        {
            fnsLog(ABORTLOGLEVEL, "Error: We set a volume level of %d and retrieved %d", i, lNewVolume);
	        goto TEST_END;
        }
    }


    //Set the old one again.
    fnsLog(ABORTLOGLEVEL, "Setting Volume back to %d", lOldVolume);
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    Sleep(1000);



    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_FreePMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_FreePMsg (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_FreePMsg())");

    fnsLog(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN SendPMsg ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_IsPlaying_Invalid.cpp ===
/********************************************************************************

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_IsPlaying_Invalid(CtIDirectMusicPerformance8* ptPerf8)
{

    HRESULT hr = S_OK;
    CICMusic Music;

    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, NULL);
    Log(FYILOGLEVEL, "INT3 INT3 INT3 INT3 INT3 ON DEBUG!!!!");

    hr = ptPerf8->IsPlaying(NULL, NULL);
    Log(FYILOGLEVEL, "INT3 INT3 INT3 INT3 INT3 ON DEBUG!!!!");


    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_InitAudio.cpp ===
#include "globals.h"
#include "cicmusicx.h"



DWORD Performance8_InitAudio_Params(TESTPARAMS);
DWORD Performance8_InitAudio_Invalid_Feb1(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_InitAudio (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_InitAudio())");

    CALLDMTEST(Performance8_InitAudio_Params       (ptPerf8, 0, 0, 0, 0));                               

    return hr;
};




/********************************************************************************
********************************************************************************/
DWORD Performance8_InitAudio_Params(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CtIDirectMusicSegment8  *ptSegment8 = NULL;

DWORD dwDefaultPath             = dwParam1;
DWORD dwPChannels               = dwParam2;
DWORD dwFlags                   = dwParam3;
//DMUS_AUDIOPARAMS *pAudioParams  = (DMUS_AUDIOPARAMS *)dwParam4;
CHAR *szSegment               = (CHAR *)dwParam4;

    
    if (dwFlags != 0)
    {
        Log(ABORTLOGLEVEL, "**** ABORT: TEST APP ERROR, SOMEBODY IS PASSING %d for dwFlags, it should be zero!!", dwFlags);
        goto TEST_END;
    }
    
    //Start up the performance.
    hr = ptPerf8->InitAudioX(NULL, NULL);//pAudioParams);
    if (FAILED(hr))
    {
        Log(ABORTLOGLEVEL, "**** ABORT: InitAudio(NULLs) returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //Play your content!
	hr = dmthPlayMidiFile(ptPerf8,CTIID_IDirectMusicSegment,&ptSegment8, NULL, szSegment);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlayMidiFile convienence function failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    
    fnsLog(FYILOGLEVEL, "Should hear %s playing for 3 seconds.", szSegment);
    Sleep(3000);


    dwRes = FNS_PASS;

TEST_END:
    if (ptSegment8)
    {
        ptSegment8->Unload(ptPerf8);
        SAFE_RELEASE(ptSegment8);
    }
    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_IsPlaying.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"


DWORD tdmperfIsPlayingSame(TESTPARAMS);

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_IsPlaying (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_IsPlaying())");

    CALLDMTEST(tdmperfIsPlayingSame(ptPerf8, 0, 0, 0, 0));                               

    return hr;
};



/********************************************************************************
********************************************************************************/
DWORD tdmperfIsPlayingSame(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegmentState8 *ptSegmentState8 = NULL;
CtIDirectMusicSegment8 *ptSegment8 = NULL;


    //Load up and play our segment.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Music.Init returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    //Get our segment and segment state.
    hr = Music.GetInterface(&ptSegment8);
    hr = Music.GetInterface(&ptSegmentState8);

    hr = ptPerf8->IsPlaying(ptSegment8, NULL);
    if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(ptSegment8, NULL) returned returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->IsPlaying(NULL, ptSegmentState8);
    if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(NULL, ptSegmentState8) returned returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->IsPlaying(ptSegment8, ptSegmentState8);
    if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(ptSegment8, ptSegmentState8) returned returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    fnsLog(ABORTLOGLEVEL, "Waiting 4 seconds, you should hear music playing");
    Sleep(4000);

    //Stop immediately.
    hr = ptPerf8->StopEx(ptSegment8, 0, 0);
    if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: returned returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->IsPlaying(ptSegment8, NULL);
    if (S_FALSE != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(ptSegment8, NULL) returned returned %s (%08Xh) instead of S_FALSE",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->IsPlaying(NULL, ptSegmentState8);
    if (S_FALSE != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(NULL, ptSegmentState8) returned returned %s (%08Xh) instead of S_FALSE",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->IsPlaying(ptSegment8, ptSegmentState8);
    if (S_FALSE != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IsPlaying(ptSegment8, ptSegmentState8) returned returned %s (%08Xh) instead of S_FALSE",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    Log(ABORTLOGLEVEL, "Waiting 4 seconds, you should hear no music because we just called StopEx(ptSegment8)");
    Sleep(4000);

    dwRes = FNS_PASS;


TEST_END:
    SAFE_RELEASE(ptSegmentState8);
    SAFE_RELEASE(ptSegment8);

    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_Release.cpp ===
/********************************************************************************
FILE:
    Performance8_Release.cpp

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_Release_Feb(CtIDirectMusicPerformance8* ptPerf8);

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_Release (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_Release())");

    hr = Performance8_Release_Feb(ptPerf8);

    return hr;
};


/********************************************************************************
THIS SHOUDLD ASSERT!!!!
********************************************************************************/
DWORD Performance8_Release_Feb(CtIDirectMusicPerformance8* ptPerf8)
{
    //Attempt to Release the global performance.  This should assert for February!!
    ptPerf8->Release();
    return FNS_FAIL;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_GetTime.cpp ===
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_GetTime_ReferenceTime(TESTPARAMS);
DWORD Performance8_GetTime_MusicTime(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_GetTime (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_GetTime())");

    CALLDMTEST(Performance8_GetTime_ReferenceTime(ptPerf8, 0, 0, 0, 0));  //BUGBUG
    CALLDMTEST(Performance8_GetTime_MusicTime(ptPerf8, 0, 0, 0, 0));

    return hr;
};



/********************************************************************************
We measure reference time in real time.
********************************************************************************/
DWORD Performance8_GetTime_ReferenceTime(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CICMusic Music;

REFERENCE_TIME rtStart, rtEnd, rtDiff;
REFERENCE_TIME rtExpected = 50000000;    
FLOAT fErrorMargin = 2.f; //Allow 2% error.
FLOAT fError = 0.f;         //
DWORD dwStartTime = 0;
DWORD dwEndTime = 0;

    //Play some music just to get things going.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", g_szDefaultMedia, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }

    hr = ptPerf8->GetTime(&rtStart , NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetTime failed");
	    goto TEST_END;
    }

    dwStartTime = timeGetTime();
    fnsLog(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", rtStart >> 32, rtStart & 0xFFFFFFFF);
    fnsLog(FYILOGLEVEL, "Waiting 5s from call.");
    
    //Wait 5s.
    while (timeGetTime() - dwStartTime < 5000);

    hr = ptPerf8->GetTime(&rtEnd, NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetTime failed");
	    goto TEST_END;
    }


    //Calculate the results and pass or fail the test.
    rtDiff = abs(int(rtStart - rtEnd));
    //rtDiffAllowed = (REFERENCE_TIME)(FLOAT(rtExpected) * fErrorMargin);
    fnsLog(FYILOGLEVEL, "%d reference units passed; %d were expected to pass.", (DWORD)rtDiff, (DWORD)rtExpected);    
    fError = (FLOAT)fabs(FLOAT(rtDiff - rtExpected) / FLOAT(rtExpected) * 100.f);
    fnsLog(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fError, fErrorMargin);
    if (fError > fErrorMargin)
    {
        goto TEST_END;
    }
    

    dwRes = FNS_PASS;

TEST_END:
    return dwRes;
};



/********************************************************************************
We measure music time in notes.  This segment has 16 quarter notes, so it should
last DMUS_PPQ * 16 units in music time.
********************************************************************************/
DWORD Performance8_GetTime_MusicTime(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CICMusic Music;
CtIDirectMusicSegment8      *ptSegment8       = NULL;
CtIDirectMusicSegmentState  *ptSegmentState   = NULL;
CtIDirectMusicAudioPath     *ptPath           = NULL;

MUSIC_TIME mtStart, mtEnd, mtDiff, mtError;
MUSIC_TIME mtExpected = DMUS_PPQ * 16;    
FLOAT fErrorMargin = 2.f; //Allow 2% error.
FLOAT fError = 0.f;
DWORD dwStartTime = 0;
DWORD dwEndTime   = 0;

    //Play some music just to get things going.
    hr = Music.Init(ptPerf8, "T:\\Media\\Perf8\\GetTime\\16Notes.sgt", DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", g_szDefaultMedia, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }

    //Get some interfaces.
    hr = Music.GetInterface(&ptSegment8);
    hr = Music.GetInterface(&ptSegmentState);
    hr = Music.GetInterface(&ptPath);

    //Stop the music.  We'll use the length of a segment to measure time.
    hr = ptPerf8->StopEx(0, 0, 0);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "StopEx failed with %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }

    //Tell it not to repeat.
    hr = ptSegment8->SetRepeats(0);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats failed with %s (%08Xh)", tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //Play the segment
	hr = ptPerf8->PlaySegmentEx( 
		ptSegment8, 
		0,
		NULL,
        0, 
		//DMUS_SEGF_QUEUE,
		0,
		&ptSegmentState,
		NULL,
		ptPath);

	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx function returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    
    //Wait for the segment to start
    do
    {
        hr = ptPerf8->IsPlaying(NULL, ptSegmentState);
        if (FAILED(hr))
            goto TEST_END;
    }
    while (S_FALSE == hr);

    //Get the time.
    hr = ptPerf8->GetTime(NULL, &mtStart);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetTime failed");
	    goto TEST_END;
    }

    dwStartTime = timeGetTime();
    fnsLog(FYILOGLEVEL, "Pre-playback MUSIC_TIME is %08X", mtStart);
    fnsLog(FYILOGLEVEL, "Waiting 5s from call.");

    
    //Wait for the segment to finish.
    do
    {
        hr = ptPerf8->IsPlaying(NULL, ptSegmentState);
        if (FAILED(hr))
            goto TEST_END;
    }
    while (S_OK == hr);

    hr = ptPerf8->GetTime(NULL, &mtEnd);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetTime failed");
	    goto TEST_END;
    }


    //Calculate the results and pass or fail the test.
    fnsLog(FYILOGLEVEL, "Post-playback MUSIC_TIME is %08X", mtEnd);
    mtDiff = abs(mtStart - mtEnd);
//    mtError = (MUSIC_TIME)(FLOAT(mtExpected) * fErrorMargin);
    fnsLog(FYILOGLEVEL, "%d MUSIC_TIME units passed; %d were expected", (DWORD)mtDiff, (DWORD)mtExpected);    
    fError = (FLOAT)fabs(FLOAT(mtDiff - mtExpected) / FLOAT(mtExpected) * 100.f);
    fnsLog(FYILOGLEVEL, "Error is %6.2f percent, maximum allowed is %6.2f percent.", fError, fErrorMargin);
    if (fError > fErrorMargin)
    {
        goto TEST_END;
    }
    

    dwRes = FNS_PASS;

TEST_END:
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptSegmentState);
    SAFE_RELEASE(ptPath);
    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_GetSegmentState.cpp ===
/********************************************************************************
FILE:

PURPOSE:

BY:
    DANHAFF
********************************************************************************/
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_GetSegmentState_BVT(CtIDirectMusicPerformance8* ptPerf8);
DWORD Performance8_GetSegmentState_1(CtIDirectMusicPerformance8* ptPerf8);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_GetSegmentState (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_GetSegmentState())");

    CALLDMTEST(Performance8_GetSegmentState_BVT(ptPerf8));                                            
    CALLDMTEST(Performance8_GetSegmentState_1(ptPerf8));                                              

    return hr;
};






/********************************************************************************
Main test function.
********************************************************************************/
DWORD Performance8_GetSegmentState_BVT(CtIDirectMusicPerformance8* ptPerf8)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment8		*pwSegment			= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState2	= NULL;
	MUSIC_TIME					mt					= 1024;

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(ptPerf8,CTIID_IDirectMusicSegment,&pwSegment, &pwSegmentState, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call GetTime() and check results
    // **********************************************************************
	hr = ptPerf8->GetTime( NULL, &mt );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call GetSegmentState and check resutls
    // **********************************************************************
	hr = ptPerf8->GetSegmentState( &pwSegmentState2, mt);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->GetSegmentState")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call Stop and check results
    // **********************************************************************
	Sleep(3000);
	hr = ptPerf8->StopEx(NULL, NULL, 0);
    if(FAILED(hr))
	{
        fnsLog(FYILOGLEVEL, TEXT("**** FYI: IDirectMusicPerformance->Stop ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
	}

TEST_END:
    if (pwSegment && ptPerf8)
    {
        hr = pwSegment->Unload(ptPerf8);
        if(FAILED(hr))
            Log(ABORTLOGLEVEL, "ERROR!!  Unload returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
    }

	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;

}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetSegmentState()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetSegmentState().
//			Get a SegmentState that's set way into the future <nl>
//
// Test Function: <nl>
// tdmperfvGetSegmentStateValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object<nl>
// 3) Get the Segment object <nl>
// 4) Add the port <nl>
// 5) Call GetTime to get the current time and check results <nl>
// 6) Call PlaySegment way into the future and check results <nl>
// 7) Call ReferenceToMusicTime and check results <nl>
// 8) Call GetSegmentState way in the future <nl>
// 9) Release objects, CoUninitilalize, and return results <nl>
//
// History: <nl>
//  05/18/1998 - a-llucar - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD Performance8_GetSegmentState_1(CtIDirectMusicPerformance8* ptPerf8)
{
	HRESULT						hr				= E_NOTIMPL;
	DWORD						dwRes			= FNS_PASS;
	CtIDirectMusicSegment8		*pwSegment		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState	= NULL;
    CtIDirectMusicAudioPath     *pwAudioPath    = NULL;
	MUSIC_TIME					mt				= 0;

	CHAR						*pSegmentFile	= "T:\\Media\\Perf8\\GetSegSt\\DSegTst3.sgt";
    BOOL                        bDownloaded     = FALSE;

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Create an audiopath to play on.
    // **********************************************************************
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, TRUE, &pwAudioPath);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwAudioPath")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    //Download stuff to the path.
    hr = pwSegment->Download(pwAudioPath); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    bDownloaded = TRUE;



    // **********************************************************************
    // 5) Call GetTime to get the current time and check results
    // **********************************************************************
	hr = ptPerf8->GetTime(NULL, &mt);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    fnsLog(FYILOGLEVEL, "MUSIC_TIME is         %d.", mt);
    mt = mt + 1000000;
    fnsLog(FYILOGLEVEL, "Queuing segment for   %d.", mt);


    // **********************************************************************
    // 6) Call PlaySegment way into the future and check results
    // **********************************************************************
	// Set PlaySegment to play at time 1 billion after now
	hr = ptPerf8->PlaySegmentEx(pwSegment, NULL, NULL, DMUS_SEGF_BEAT, mt, NULL, NULL, pwAudioPath);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ptPerf8->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

 	
    // **********************************************************************
    // 8) Call GetSegmentState way in the future
    // **********************************************************************
    fnsLog(FYILOGLEVEL, "Getting segment state at %d.", mt);
	hr = ptPerf8->GetSegmentState(&pwSegmentState, mt);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: ptPerf8->GetSegmentState(way in the future) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(5000);
		
TEST_END:
    // **********************************************************************
    // 9) Release objects, CoUninitilalize, and return results
    // **********************************************************************

    if (bDownloaded)
    {
        hr = pwSegment->Unload(pwAudioPath); 
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh). TEST APP LEAK!!",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
    }


    SAFE_RELEASE(pwSegment);
	SAFE_RELEASE(pwSegmentState);
    SAFE_RELEASE(pwAudioPath);
	return dwRes; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_RemoveNotificationType.cpp ===
#include "globals.h"
#include "cicmusicx.h"

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_RemoveNotificationType (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_RemoveNotificationType())");

    fnsLog(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN AddNotificationType ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_PlaySegmentEx.cpp ===
#include "globals.h"
#include "cicmusicX.h"

DWORD tdmperv8PlaySegmentEx(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwTestType);
DWORD tdmperv8PlaySegmentExFrom(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwTestType);
DWORD Performance8_PlaySegment_NoStop(CtIDirectMusicPerformance8 *ptPerf8);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_PlaySegmentEx (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_PlaySegmentEx())");

    CALLDMTEST(Performance8_PlaySegment_NoStop(ptPerf8));   //See what happens if we don't stop the music.

/*

    CALLDMTEST(tdmperv8PlaySegmentEx(ptPerf8, 1));  //PlaySegmentEx                                      //PASSING
    CALLDMTEST(tdmperv8PlaySegmentEx(ptPerf8, 2));  //Manual Download    (wave track - audiopath)        //FAILS DUE TO BUG 2684 (download)

    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  1));  //To Self(BEAT)",                                //PASSING
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  2));  //To Self(MEASURE)",                             //PASSING
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  3));  //To Self(QUEUE)",                               //PASSING
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  4));  //AutoTransition(BEAT)",                         //FAILS DUE TO IsPlaying succeeding (see mail to Kelly)
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  5));  //AutoTransition(MEASURE)",                    //""
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  6));  //AutoTransition(QUEUE)",                      //""
    CALLDMTEST(tdmperv8PlaySegmentExFrom(ptPerf8,  7));  //Secondary(QUEUE)",                           //""

*/
    return hr;
};

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx()<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentEx(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwTestType)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

    CtIDirectMusicAudioPath     *ptPath     = NULL;

	CtIDirectMusicLoader8		*pwLoader		= NULL;
	CtIDirectMusicSegment8		*pwSegment		= NULL;

	DMUS_OBJECTDESC 			desc            = {0};    

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;
    char *                      pszFile         = NULL;

	switch(dwTestType)
	{
		case 1:
			pszFile = "T:\\Media\\test.sgt";
			break;
		case 2:
			pszFile = "T:\\Media\\Perf8\\PlaySeg\\WaveEmb.sgt";
			break;
		default:
			return FNS_PENDING;
	}

	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}


	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
    mbstowcs(desc.wszFileName,pszFile, strlen(pszFile) + 1);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &ptPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: ptPerf8->CreateStandardAudioPath(pwSegment) failed with %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	hr = pwSegment->Download(ptPerf8); // needs real object - no need to release - no addref done 
	if(dwTestType == 3)
	{
		if(hr != E_NOTIMPL)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
					TEXT("did not return E_NOTIMPL (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	else if(FAILED(hr)) // 3 == downloading was
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;

	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	hr = ptPerf8->PlaySegmentEx( 
		pwSegment,			// Segment to play 
		0,NULL, 			// Optional stuff NULL. 
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,ptPath);	// Optional stuff is NULL. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: ptPerf8->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = ptPerf8->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}


	fnsLog(FYILOGLEVEL, "Should hear %s playing for 4 seconds", pszFile);
	Sleep(4000);
	dwRes = FNS_PASS;

TEST_END:
	if(pwSegment)
	{
		if(ptPerf8)
		{            
    		pwSegment->Unload(ptPerf8); //don't case about the return code at this point
		}
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	return dwRes;
}	













//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx(from)_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx(from)<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentExFrom()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	05/22/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentExFrom(CtIDirectMusicPerformance8 *ptPerf8, DWORD dwTestType)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState1	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState2	= NULL;
	CtIDirectMusicSegment8*		pwPSegment		= NULL;
	CtIDirectMusicSegment8*		pwTSegment		= NULL;
	CtIDirectMusicSegment8*		pwSSegment		= NULL;
	CtIDirectMusicSegment8*		pwWSegment		= NULL;
	CtIDirectMusicAudioPath*	pwPath			= NULL;
	CtIDirectMusicAudioPath*	pwPath2			= NULL;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	CHAR*						pPMidiFile 		= "T:\\Media\\test.sgt";
	CHAR*						pSMidiFile 		= "T:\\Media\\test.sgt";
	CHAR*						pWMidiFile 		= "T:\\Media\\Perf8\\PlaySeg\\rdrum.sgt";
	CHAR*						pTemplateFile 	= "T:\\Media\\Perf8\\PlaySeg\\Seg8STC.sgt";
	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	BOOL						fActivate		= TRUE;
	DWORD						dwFlags			= NULL;

	// which type of test to do
	switch(dwTestType)
	{
	case 1: // self beat
	case 2: // self measure
	case 3: // self queue
	case 4: // autotransition beat
	case 5: // autotransition measure
	case 6: // autotransition queue
		break;
	case 7: // autotransition to second segment
		pPMidiFile 		= "T:\\Media\\Perf8\\PlaySeg\\synctest.sgt";
		break;
	default: // not null - not supported
		return FNS_PENDING;
		break;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
/*
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicCollection, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(dls) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicChordMap, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(chordmap) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicStyle, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(style) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
*/
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pPMidiFile,(void **)&pwPSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	switch(dwTestType)
	{
	case 4: // autotransition
	case 5: // autotransition
	case 6: // autotransition
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pTemplateFile,(void **)&pwTSegment);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwTSegment->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Segment->SetRepeats() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 7: // secondary segment
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pWMidiFile,(void **)&pwWSegment);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwWSegment->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Segment->SetRepeats() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pSMidiFile,(void **)&pwSSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	hr = ptPerf8->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ptPerf8->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(pwPSegment)
	{
		hr = pwPSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	if(pwSSegment)
	{
		hr = pwSSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	if(pwWSegment)
	{
		hr = pwWSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	// **********************************************************************
	hr = ptPerf8->PlaySegmentEx( 
		pwPSegment, 
		0,
		NULL,
		DMUS_SEGF_QUEUE,
		0,
		&pwSegmentState1,
		NULL,
		pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: ptPerf8->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 300;
	while ((hr = ptPerf8->IsPlaying(pwPSegment,NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 1) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	switch(dwTestType)
	{
	case 1: // from self
		dwFlags = DMUS_SEGF_BEAT;
		break;
	case 2: // from self
		dwFlags = DMUS_SEGF_MEASURE;
		break;
	case 3: // from self
		dwFlags = DMUS_SEGF_QUEUE;
		break;
	case 4: // autotransition
		dwFlags = DMUS_SEGF_BEAT | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 5: // autotransition
		dwFlags = DMUS_SEGF_MEASURE | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 6: // autotransition
		dwFlags = DMUS_SEGF_QUEUE | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 7: // autotransition second segment
		dwFlags = DMUS_SEGF_MEASURE | DMUS_SEGF_SECONDARY;
		break;
	}
	switch(dwTestType)
	{
	default: // from self
		hr = ptPerf8->PlaySegmentEx( 
			pwSSegment, 
			NULL,
			pwTSegment,
			dwFlags,
			NULL,
			&pwSegmentState2,
			pwSegmentState1,
			pwPath);
		break;
	case 7: // from self
		hr = ptPerf8->PlaySegmentEx( 
			pwSSegment, 
			NULL,
			NULL,
			dwFlags,
			NULL,
			&pwSegmentState2,
			NULL,
			pwPath);
		break;
	}
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: ptPerf8->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	switch(dwTestType)
	{
	case 4:
	case 5:
	case 6:
		hr = ptPerf8->IsPlaying(pwSSegment,NULL);
		if(SUCCEEDED(hr) && (S_FALSE != hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: Performance->IsPlaying ")
					TEXT("succeeded and should not have (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 7:
		dwFlags = DMUS_SEGF_QUEUE | DMUS_SEGF_SECONDARY;
		hr = ptPerf8->PlaySegmentEx( 
			pwWSegment, 
			NULL,
			NULL,
			dwFlags,
			NULL,
			NULL,
			pwSegmentState2,
			pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: ptPerf8->PlaySegmentEx ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = ptPerf8->IsPlaying(NULL,pwSegmentState2)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segstate) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = ptPerf8->IsPlaying(NULL,pwSegmentState2)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 2) timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	if(pwWSegment)
	{
		counter = 0;
		SleepTime = 3000;
		while ((hr = ptPerf8->IsPlaying(pwWSegment,NULL)) == S_OK)	
		{
			Sleep(SleepTime);
			if(counter++ > TimeOutValue)
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 3) timed out\n")
					TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPSegment)
	{
		if(pwPath)
		{
			pwPSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwPSegment->Release();
		pwPSegment = NULL;
	}
	if(pwSegmentState1)
	{
		pwSegmentState1->Release();
		pwSegmentState1 = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwTSegment)
	{
		pwTSegment->Release();
		pwTSegment = NULL;
	}
	if(pwSSegment)
	{
		if(pwPath)
		{
			pwSSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwSSegment->Release();
		pwSSegment = NULL;
	}
	if(pwWSegment)
	{
		if(pwPath)
		{
			pwWSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwWSegment->Release();
		pwWSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwPath)
	{
		pwPath->Release();
		pwPath = NULL;
	}
	if(pwPath2)
	{
		pwPath2->Release();
		pwPath2 = NULL;
	}

	return dwRes;
}	





/********************************************************************************
Need to uncomment a line in CICMusic::PrivateUninitialize to repro bug 2967.
********************************************************************************/
DWORD Performance8_PlaySegment_NoStop(CtIDirectMusicPerformance8 *ptPerf8)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CICMusic Music;

    //Play some music whose tempo we're gonna change.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", g_szDefaultMedia, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }


    dwRes = FNS_PASS;

TEST_END:
    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\sample.h ===
#pragma once
#include "globals.h"



HRESULT SampleTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_SetGlobalParam.cpp ===
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_SetGlobalParam_Groove_BVT(TESTPARAMS);
DWORD Performance8_SetGlobalParam_Tempo_BVT(TESTPARAMS);
DWORD Performance8_SetGlobalParam_Volume_BVT(TESTPARAMS);
/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_SetGlobalParam (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_SetGlobalParam())");

    //THESE ALL PASS!
    CALLDMTEST(Performance8_SetGlobalParam_Groove_BVT(ptPerf8, 0, 0, 0, 0));
    CALLDMTEST(Performance8_SetGlobalParam_Tempo_BVT (ptPerf8, 0, 0, 0, 0));  
    CALLDMTEST(Performance8_SetGlobalParam_Volume_BVT(ptPerf8, 0, 0, 0, 0));

    return hr;
};



/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_SetGlobalParam_Groove_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    char dwOldMasterGrooveLevel                               = 0;
    char dwNewMasterGrooveLevel                            = 0;
    CHAR *szSegment = "T:\\Media\\Perf8\\SetGlob\\Groove.sgt";
    char i = 0;


    //Set the groove level to 1.
/*
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&dwOldMasterGrooveLevel, sizeof(dwOldMasterGrooveLevel));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
*/

    //BUGBUG: Remove when 2921 is fixed.
    dwOldMasterGrooveLevel = 0;

    //Start music playing.
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }
    fnsLog(FYILOGLEVEL, "Playing %s normally for 2 seconds.", szSegment);
    Sleep(2000);


    //Go through 5 groove levels.
    for (i=0; i<=4; i++)
    {
        dwNewMasterGrooveLevel = i;
        hr = ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&dwNewMasterGrooveLevel, sizeof(dwNewMasterGrooveLevel));
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	        goto TEST_END;
        }    

        fnsLog(FYILOGLEVEL, "Setting dwNewMasterGrooveLevel to %d.  Should switch to ""%d"" being spoken at next measure break.", i, i+1);
        Sleep(5000);
    }

    //Set the old one again.
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterGrooveLevel, (void *)&dwOldMasterGrooveLevel, sizeof(dwOldMasterGrooveLevel));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    



    dwRes = FNS_PASS;

TEST_END:
    SAFE_RELEASE(ptSegment8);
    return  dwRes;
};





/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_SetGlobalParam_Tempo_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    FLOAT fOldTempo                               = 0;
    FLOAT fNewTempo                            = 0;
    CHAR *szSegment = g_szDefaultMedia;
    DWORD i = 0;

/*
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
*/

    //BUGBUG: Remove when 2921 is fixed.
    fOldTempo = 1.f;


    //Start music playing.
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }
    fnsLog(FYILOGLEVEL, "Playing %s normally for 2 seconds.", szSegment);
    Sleep(2000);


    //Set the tempo up way high.
    fNewTempo = 2.0;
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fNewTempo, sizeof(fNewTempo));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    fnsLog(ABORTLOGLEVEL, "Setting fNewTempo to %g, will hear music at %g times normal for 5 seconds.", fNewTempo, fNewTempo);
    Sleep(5000);


    //Set the old one again.
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fOldTempo, sizeof(fOldTempo));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    fnsLog(ABORTLOGLEVEL, "Setting tempo back to %g, will hear normal music for 3 seconds.", fOldTempo);
    Sleep(3000);



    dwRes = FNS_PASS;

TEST_END:
    SAFE_RELEASE(ptSegment8);
    return  dwRes;
};



/********************************************************************************
********************************************************************************/
DWORD Performance8_SetGlobalParam_Volume_BVT(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8  *ptSegment8                     = NULL;
    long  lOldVolume                               = 0;
    long lNewVolume                                = 0;
    CHAR *szSegment = g_szDefaultMedia;
    DWORD i = 0;

/*
    hr = ptPerf8->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "GetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
*/

    //BUGBUG: Remove when 2921 is fixed.
    lOldVolume = 0;


    //Start music playing.
    hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }        
    Music.GetInterface(&ptSegment8);
    hr = ptSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetRepeats returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }
    fnsLog(FYILOGLEVEL, "Playing %s normally for 2 seconds.", szSegment);
    Sleep(2000);


    //Set the Volume down way low.
    lNewVolume = -1000;  //10 decibels.
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lNewVolume, sizeof(lNewVolume));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    fnsLog(ABORTLOGLEVEL, "Setting lNewVolume to %d, will hear quiet music for 5 seconds.", lNewVolume);
    Sleep(5000);


    //Set the old one again.
    hr = ptPerf8->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lOldVolume, sizeof(lOldVolume));
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "SetGlobalParam returned %s (%08Xh)", szSegment, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }    
    fnsLog(ABORTLOGLEVEL, "Setting Volume back to %d, will hear normal-volume music for 3 seconds", lOldVolume);
    Sleep(3000);

    dwRes = FNS_PASS;

TEST_END:
    SAFE_RELEASE(ptSegment8);
    return  dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_StopEx.cpp ===
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_StopEx_NoSegments(TESTPARAMS);
DWORD Performance8_StopEx_1Segment(TESTPARAMS);
DWORD Performance8_StopEx_2Segments(TESTPARAMS);
DWORD Performance8_StopEx_TimePast(TESTPARAMS);
DWORD Performance8_StopEx_TimeFuture(TESTPARAMS);

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_StopEx (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_StopEx())");

    CALLDMTEST(Performance8_StopEx_NoSegments (ptPerf8, TRUE, TRUE, 0, 0)); // PASSES!
    CALLDMTEST(Performance8_StopEx_1Segment   (ptPerf8, TRUE, TRUE, 0, 0)); // PASSES!

    CALLDMTEST(Performance8_StopEx_2Segments(ptPerf8, TRUE,  TRUE, 0, 0));  //1 Path, 1 Segment  PASSES!
    CALLDMTEST(Performance8_StopEx_2Segments(ptPerf8, TRUE,  FALSE,0, 0));  //1 Path, 2 Segments FAILS due to 2987
    CALLDMTEST(Performance8_StopEx_2Segments(ptPerf8, FALSE, TRUE, 0, 0));  //2 Paths,1 Segment  FAILS due to 2987
    CALLDMTEST(Performance8_StopEx_2Segments(ptPerf8, FALSE, FALSE, 0, 0)); //2 Paths,2 Segments FAILS due to 2987
    
    CALLDMTEST(Performance8_StopEx_TimePast(ptPerf8,   0, 0, 0, 0));        //Passes
    CALLDMTEST(Performance8_StopEx_TimeFuture(ptPerf8, 0, 0, 0, 0));        //Fails due to 2992

    return hr;
};



/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_StopEx_NoSegments(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;

    //Nothing's playing - This call should be fine.
    hr = ptPerf8->StopEx(NULL, NULL, NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx() returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	    goto TEST_END;
    }

    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};




/********************************************************************************
A simpler test for a simpler time.  Like Feb release.  This is all that needs
to work for that.
********************************************************************************/
DWORD Performance8_StopEx_1Segment(TESTPARAMS)
{
DWORD dwRes                                             = FNS_FAIL;
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath          = {NULL};
CtIDirectMusicSegmentState         *ptSegmentState = {NULL};
CtIDirectMusicSegment8              *ptSegment8      = {NULL};
CHAR *szFileName                    = g_szDefaultMedia;
BOOL bDownloaded                    = FALSE;
DWORD dwScenario                    = 0;

    //Create the audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	    goto TEST_END;
    }


    //Load up the media file.
    dmthLoadSegment(szFileName, &ptSegment8);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    //Download everything.
    hr = ptSegment8->Download(ptPath); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    bDownloaded = TRUE;

    for (dwScenario = 0; dwScenario<4; dwScenario++)
    {    
    

        //Play our segments.
	    hr = ptPerf8->PlaySegmentEx(ptSegment8,0,0,0,0,&ptSegmentState,0,ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx(%s) function returned %s (%08Xh)",szFileName, tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }


        //Now both segments are playing.
       fnsLog(FYILOGLEVEL, " Playing %s as segment.", szFileName);
       fnsLog(FYILOGLEVEL, "Should hear music playing for 4 seconds.");
       Sleep(4000);



        switch (dwScenario)
        {
            //StopEx(global)
            case 0:	            
                hr = ptPerf8->StopEx(NULL, 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(segment)
            case 1:	            
                hr = ptPerf8->StopEx(ptSegment8, 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptSegment8, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptSegment8, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(SegmentState)
            case 2:	            
                hr = ptPerf8->StopEx(ptSegmentState, 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptSegmentState, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptSegmentState, NULL, NULL), all sound should stop for 2 seconds");
                break;

            //StopEx(AudioPath)
            case 3:	            
                hr = ptPerf8->StopEx(ptPath, 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptPath, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptPath, NULL, NULL), all sound should stop for 2 seconds");
                break;
            
            default:
                fnsLog(ABORTLOGLEVEL, "**** ABORT: TEST ERROR!!!!!!!");
		        goto TEST_END;
                break;                
        };

        //Moment of silence.
        Sleep(2000);

        //Stop everything anyway.
        hr = ptPerf8->StopEx(0, 0, 0);
        if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }

        fnsLog(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop");
        Sleep(1000);


        //Release the segstates we aquired.
        SAFE_RELEASE(ptSegmentState);

    }

    dwRes = FNS_PASS;
TEST_END:

    //Unload - necessary to counteract all downloads!
    if (ptSegment8 && ptPath && bDownloaded)
    {
        hr = ptSegment8->Unload(ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
    }


    //Release all items that might have been allocated.
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    SAFE_RELEASE(ptSegmentState);

    return dwRes;
};

/********************************************************************************
By NULL, Segment

Nothing playing: Works with (NULL, Segment, SegmentState, AudioPath)
One Segment:     Stops same (NULL, Segment, SegmentState, AudioPath);


Two Segments:
variables:
    AudioPath: Single / Separate
    Segments:  Same / Separate
    SegmentStates: There will be 2 segmentstates anyway.

 //There are 4 scenarios:
    Stop(NULL): Everything stops.
    Stop(Segment);
    Stop(SegmentState);
    Stop(AudioPath);

********************************************************************************/
DWORD Performance8_StopEx_2Segments(TESTPARAMS)
{
DWORD dwRes                                             = FNS_FAIL;
HRESULT hr                                              = S_OK;
CtIDirectMusicAudioPath             *ptPath[2]          = {NULL};
CtIDirectMusicSegmentState         *ptSegmentState[2] = {NULL};
CtIDirectMusicSegment8              *ptSegment8[2]      = {NULL};
CHAR *szFileName[2]               = {g_szDefaultMedia, "T:\\Media\\Sample\\lfive.sgt"};
BOOL bDownloaded[2] = {0};
BOOL bSinglePath    = dwParam1;
BOOL bSingleSegment = dwParam2;
DWORD dwSegment = 0;
DWORD dwPath = 0;
DWORD i = 0;
DWORD dwScenario = 0; 


    fnsLog(FYILOGLEVEL, "");
    fnsLog(FYILOGLEVEL, "================= STOPEX TEST: %d AudioPath(s), %d Segment(s)", bSinglePath ? 1 : 2, bSingleSegment ? 1 : 2);
    fnsLog(FYILOGLEVEL, "");

    //Create the audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB,
                                          64,
                                          TRUE,
                                          &ptPath[0]);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	    goto TEST_END;
    }

    //Create another different audiopath if required.
    if (!bSinglePath)
    {
        hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_DYNAMIC_MONO,
                                              32,
                                              TRUE,
                                              &ptPath[1]);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh) instead of S_OK",tdmXlatHRESULT(hr),hr);
	        goto TEST_END;
        }
    }

    //Load up 1 or 2 segments.
    for (i=0; i<2; i++)
    {
        if (bSingleSegment && i==1)
            break;

        //Load up media file.
        dmthLoadSegment(szFileName[i], &ptSegment8[i]);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName[i], tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
    }


    //Download our stuff to audiopaths or single audiopath (depending on test parameters)
    for (i=0; i<2; i++)
    {
        //Bail if we don't have 2 segments.
        if (bSingleSegment && i==1)
            break;

        //Download both segments to path one if there's only one path, otherwise download each seg to respective path.
        dwPath = i;
        if (bSinglePath)
            dwPath = 0;


        hr = ptSegment8[i]->Download(ptPath[dwPath]); 
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
        bDownloaded[i] = TRUE;
    }

    for (dwScenario = 0; dwScenario<4; dwScenario++)
    {    
    

        //Play our segments.
        fnsLog(FYILOGLEVEL, "Playing Segments:");
        for (i=0; i<2; i++)
        {

            dwPath = i;
            if (bSinglePath)
                dwPath = 0;

            dwSegment = i;
            if (bSingleSegment)
                dwSegment = 0;


	        hr = ptPerf8->PlaySegmentEx(ptSegment8[dwSegment],
                                        0,
                                        0,
                                        i ? DMUS_SEGF_SECONDARY : 0,
                                        0,
                                        &ptSegmentState[i],
                                        0,
                                        ptPath[dwPath]);

	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx(%s) function returned %s (%08Xh)",szFileName[i], tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
            fnsLog(FYILOGLEVEL, " Playing %s as %s segment.", szFileName[i], i ? "secondary " : "primary ");
        }


        //Now both segments are playing.
        fnsLog(FYILOGLEVEL, "Should hear music playing for 5 seconds.");
        Sleep(5000);


        switch (dwScenario)
        {
            //StopEx(global)
            case 0:	            
                hr = ptPerf8->StopEx(NULL, 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(NULL, NULL, NULL), all sound should stop for 4 seconds");
                break;

            //StopEx(segment)
            case 1:	            
                hr = ptPerf8->StopEx(ptSegment8[0], 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptSegment8[0], NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptSegment8[0], NULL, NULL), %sSegment should Stop for 4 seconds.", bSingleSegment ? "" : "first ");
                break;

            //StopEx(SegmentState)
            case 2:	            
                hr = ptPerf8->StopEx(ptSegmentState[0], 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptSegmentState[0], NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptSegmentState[0], NULL, NULL), SegmentState[0] should Stop for 4 seconds.");
                break;

            //StopEx(AudioPath)
            case 3:	            
                hr = ptPerf8->StopEx(ptPath[0], 0, 0);
                if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(ptPath[0], NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		            goto TEST_END;
	            }
                fnsLog(FYILOGLEVEL, "Calling StopEx(ptPath[0], NULL, NULL),%s should Stop for 4 seconds.", bSinglePath ? "All Music" : "Segment on Path 1");
                break;
            
            default:
                fnsLog(ABORTLOGLEVEL, "**** ABORT: TEST ERROR!!!!!!!");
		        goto TEST_END;
                break;                
        };

        //Moment of silence.
        Sleep(4000);

        //Stop everything anyway.
        hr = ptPerf8->StopEx(0, 0, 0);
        if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx(NULL, NULL, NULL) returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }

        fnsLog(FYILOGLEVEL, "Called StopEx(NULL, NULL, NULL), all sound should stop");
        Sleep(1000);

        //Release the segstates we aquired.
        for (i=0; i<2; i++)
        {
            SAFE_RELEASE(ptSegmentState[i]);
        }

    }

    dwRes = FNS_PASS;

TEST_END:

    //Unload - necessary to counteract all downloads!
    for (i=0; i<2; i++)
    {

        dwPath = i;
        if (bSinglePath)
            dwPath = 0;

        if (ptSegment8[i] && ptPath[dwPath] && bDownloaded[i])
        {
            hr = ptSegment8[i]->Unload(ptPath[dwPath]);
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
        }
    }

    //Release all items that might have been allocated.
    for (i=0; i<2; i++)
    {
        SAFE_RELEASE(ptSegment8[i]);
        SAFE_RELEASE(ptPath[i]);
        SAFE_RELEASE(ptSegmentState[i]);
    }

    return dwRes;

};




/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_StopEx_TimeFuture(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic    Music;
    CHAR *szSegment = "T:\\Media\\Perf8\\StopEx\\16Notes.sgt";
    REFERENCE_TIME rt;
    MUSIC_TIME mt;
    DWORD i;


    for (i=0; i<2; i++)
    {

        //Load up and play the media.
        hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.Init %s failed", szSegment);
	        goto TEST_END;
        }

        //Get the time.
        hr = ptPerf8->GetTime(&rt, &mt);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "GetTime failed");
	        goto TEST_END;
        }

        if (i==0)
        {
            fnsLog(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", DWORD(rt >> 32), DWORD(rt & 0xFFFFFFFF));
            rt += 50000000;
            //Run our test.
            hr = ptPerf8->StopEx(0,rt,DMUS_SEGF_REFTIME);
            fnsLog(FYILOGLEVEL, "Stopping in 5 seconds, or at %08X%08X.", DWORD(rt >> 32), DWORD(rt & 0xFFFFFFFF));
            fnsLog(FYILOGLEVEL, "You should hear music stop in 5 seconds.");
        }
        else
        {
            fnsLog(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
            mt += DMUS_PPQ * 8;
            hr = ptPerf8->StopEx(0,mt,0);
            fnsLog(FYILOGLEVEL, "Stopping in 8 quarter-notes, or at mt = %08X.", mt);
            fnsLog(FYILOGLEVEL, "You should hear music stop in 8 quarter notes.");


        }
        //Check the result of StopEx.
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "StopEx failed");
	        goto TEST_END;
        }


        //Wait 6 seconds.
        Sleep(6000);

        fnsLog(FYILOGLEVEL, "Music should be stopped now.  Waiting 5 more second.");
        Sleep(5000);


        hr = Music.Shutdown();
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.ShutDown failed");
	        goto TEST_END;
        }

    }

    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};



/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
DWORD Performance8_StopEx_TimePast(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic    Music;
    CHAR *szSegment = "T:\\Media\\Perf8\\StopEx\\16Notes.sgt";
    REFERENCE_TIME rt;
    MUSIC_TIME mt;
    DWORD i;


    for (i=0; i<2; i++)
    {

        //Load up and play the media.
        hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.Init %s failed", szSegment);
	        goto TEST_END;
        }

        fnsLog(FYILOGLEVEL, "Playing for 2 seconds.");
        Sleep(2000);

        //Get the time.
        hr = ptPerf8->GetTime(&rt, &mt);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "GetTime failed");
	        goto TEST_END;
        }

        if (i==0)
        {
            fnsLog(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", DWORD(rt >> 32), DWORD(rt & 0xFFFFFFFF));
            rt -= 50000000;
            hr = ptPerf8->StopEx(0,rt, DMUS_SEGF_REFTIME);
            fnsLog(FYILOGLEVEL, "Stopping 5 seconds ago, or at %08X%08X.", DWORD(rt >> 32), DWORD(rt & 0xFFFFFFFF));
            fnsLog(FYILOGLEVEL, "You should hear music stop immediately.");
        }
        else
        {
            fnsLog(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
            mt -= DMUS_PPQ * 8;
            hr = ptPerf8->StopEx(0,mt, 0);
            fnsLog(FYILOGLEVEL, "Stopping 8 quarter-notes ago, or at mt = %08X.", mt);
            fnsLog(FYILOGLEVEL, "You should hear music stop immediately");


        }

        //Check the results of StopEx.
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "StopEx failed");
	        goto TEST_END;
        }

        Sleep(4000);


        hr = Music.Shutdown();
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.ShutDown failed");
	        goto TEST_END;
        }

    }

    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};



//TODO:!!!!  Post-feb release.
/********************************************************************************
Call StopEx when nothing is playing.
********************************************************************************/
/* 
DWORD Performance8_StopEx_BoundaryFlags(TESTPARAMS)
{
    DWORD dwRes                                             = FNS_FAIL;
    HRESULT hr                                              = S_OK;
    CICMusic    Music;
    CHAR *szSegment = "T:\\Media\\Perf8\\StopEx\\Boundary.sgt';
    REFERENCE_TIME rt;
    MUSIC_TIME mt;


    for (i=0; i<2; i++)
    {

        //Load up and play the media.
        hr = Music.Init(ptPerf8, szSegment, DMUS_APATH_SHARED_STEREOPLUSREVERB);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.Init %s failed", g_wszSegment);
	        goto TEST_END;
        }

        fnsLog(FYILOGLEVEL, "Playing for a second.");
        Sleep(1000);

        //Get the time.
        hr = ptPerf8->GetTime(&rt, &mt);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "GetTime failed");
	        goto TEST_END;
        }

        if (i==0)
        {
            fnsLog(FYILOGLEVEL, "Current REFERENCE_TIME is %08X%08X", rt >> 32, rt & 0xFFFFFFFF);
            rt -= 50000000;
            fnsLog(FYILOGLEVEL, "Stopping 5 seconds ago, or at %08X%08X.", rt >> 32, rt & 0xFFFFFFFF);
            fnsLog(FYILOGLEVEL, "You should hear music stop immediately.");
        }
        else
        {
            fnsLog(FYILOGLEVEL, "Current MUSIC_TIME is %08X", mt);
            mt -= DMUS_PPQ * 8;
            fnsLog(FYILOGLEVEL, "Stopping 8 quarter-notes ago, or at mt = %08X.", mt);
            fnsLog(FYILOGLEVEL, "You should hear music stop immediately");


        }

        //Run our test.
        hr = ptPerf8->StopEx(0,
                             i==0 ? rt : mt,
                             i==0 ? DMUS_SEGF_REFTIME : 0);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "StopEx failed");
	        goto TEST_END;
        }

        fnsLog(FYILOGLEVEL, "Music should be stopped.  Waiting 1 second.");
        Sleep(1000);


        hr = Music.Shutdown();
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL, "Music.ShutDown failed");
	        goto TEST_END;
        }

    }

    dwRes = FNS_PASS;

TEST_END:
    return  dwRes;
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Performance8_SendPMsg.cpp ===
#include "globals.h"
#include "cicmusicx.h"

DWORD Performance8_PMsg_Generic(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Performance8_SendPMsg (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Performance8_SendPMsg())");

    CALLDMTEST(Performance8_PMsg_Generic(ptPerf8, 0, 0, 0, 0));

    return hr;
};




/********************************************************************************
********************************************************************************/
DWORD Performance8_PMsg_Generic(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CICMusic Music;
DMUS_TEMPO_PMSG* pTempo = NULL;

    //Play some music whose tempo we're gonna change.
    hr = Music.Init(ptPerf8, g_szDefaultMedia, DMUS_APATH_SHARED_STEREOPLUSREVERB);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL, "Music.Init %s failed with %s (%08Xh)", g_szDefaultMedia, tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }

    fnsLog(FYILOGLEVEL, "Playing at default tempo for 2s.");
    Sleep(2000);
    //Create your PMsg.  I copied this from the sample
    if( SUCCEEDED( ptPerf8->AllocPMsg(
            sizeof(DMUS_TEMPO_PMSG),
            (DMUS_PMSG**)&pTempo )))
    {
        pTempo->dwSize = sizeof(DMUS_TEMPO_PMSG);
        pTempo->dblTempo = 500;
        pTempo->rtTime = 0;
        pTempo->dwFlags = DMUS_PMSGF_REFTIME;
        pTempo->dwType = DMUS_PMSGT_TEMPO;
        if (FAILED(ptPerf8->SendPMsg( (DMUS_PMSG*)pTempo )))
        {
            ptPerf8->FreePMsg( (DMUS_PMSG*)pTempo );
        }
    }


    fnsLog(FYILOGLEVEL, "Just sent a temp=500 pMsg, should notic a tempo change.  Playing at tempo=500 for 5s.");
    Sleep(5000);

    dwRes = FNS_PASS;

TEST_END:
    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\script.cpp ===
#include "script.h"

HRESULT dmthCreateScript( LPSTR szScriptName, CtIDirectMusicLoader8* pLoader, CtIDirectMusicScript** ppScript )
{
	if ( NULL == ppScript || NULL == szScriptName )
		return E_POINTER;

	HRESULT hr = S_OK;

	CHECKRUN( pLoader->LoadObjectFromFile( CLSID_DirectMusicScript, CTIID_IDirectMusicScript, szScriptName, (LPVOID*) ppScript ) );

	return hr;
}

HRESULT dmthInitScriptErrorInfo( DMUS_SCRIPT_ERRORINFO* pInfo )
{
	if ( NULL == pInfo )
		return S_OK;

	HRESULT hr = S_OK;

	ZeroMemory( pInfo, sizeof( DMUS_SCRIPT_ERRORINFO ) );
	pInfo->dwSize = sizeof( DMUS_SCRIPT_ERRORINFO );

	return hr;
}

void dmthVerifyScriptError( DMUS_SCRIPT_ERRORINFO* pInfo )
{
	if ( NULL == pInfo )
		return;

	if ( FAILED( pInfo->hr ) )
	{
		DbgPrint( "DMUS_SCRIPT_ERROR_INFO:\n" );
		DbgPrint( "   hr = 0x%x\n", pInfo->hr );
		DbgPrint( "   Line Number = %u\n", pInfo->ulLineNumber );
		DbgPrint( "   Char Position = %i\n", pInfo->ichCharPosition );
		DbgPrint( "   Source file = %S\n", pInfo->wszSourceFile );
		DbgPrint( "   Source component = %S\n", pInfo->wszSourceComponent );
		DbgPrint( "   Description = %S\n", pInfo->wszDescription );
		DbgPrint( "   Text = %S\n", pInfo->wszSourceLineText );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\sample.cpp ===
/********************************************************************************
FILE:
    SAMPLE.CPP

PURPOSE:
    Contains an example test function for DMusic.

BY:
    DANROSE
********************************************************************************/
#include "globals.h"


extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);


/********************************************************************************
********************************************************************************/
HRESULT SampleTest() {
	HRESULT hr = S_OK;
	IDirectMusicLoader8*      pLoader         = NULL;
	IDirectMusicPerformance8* pPerformance    = NULL;
	IDirectMusicSegment8*     pMusic        = NULL;
	IDirectMusicSegment8*     pSound        = NULL;
	IDirectMusicSegment8*     pSound2        = NULL;

    // Create loader object
    DbgPrint("About to create DirectMusicLoader.\n");
    CHECKRUN(DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader8,
		(void**)&pLoader ));

    // Create performance object
    DbgPrint("About to create DirectMusicPerformance.\n");
    CHECKRUN(DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
		IID_IDirectMusicPerformance8, (void**)&pPerformance ));

    // Initialize the performance with the standard audio path.
    // This initializes both DirectMusic and DirectSound and 
    // sets up the synthesizer. 
    DbgPrint("About to initialize audio.\n");
    CHECKRUN(pPerformance->InitAudioX(DMUS_APATH_SHARED_STEREOPLUSREVERB, 64));


    // Tell DirectMusic where the default search path is
    DbgPrint("SetSearchDirectory.\n");
	CHECKRUN(pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
	                               "T:\\Media\\Sample", FALSE ));
    
    // Set the GM DLS Collection so we can load midi files.
    DbgPrint("Install GM.DLS.\n");
	{
		DMUS_OBJECTDESC DESC;					// Descriptor to use to find it.
		memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
		DESC.dwSize = sizeof (DMUS_OBJECTDESC);
		DESC.guidClass = CLSID_DirectMusicCollection;  
		wcscpy(DESC.wszFileName,L"gm.dls");
		DESC.guidObject = GUID_DefaultGMCollection;
		DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_OBJECT;
		hr = pLoader->SetObject(&DESC);
	}
    // Load the segment from the file
    DbgPrint("LoadObjectFromFile.\n");
  
	CHECKRUN(pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "lfive.sgt",
											   (LPVOID*) &pMusic ));
	pSound = NULL;
	CHECKRUN(pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "tmsound.wav",
											   (LPVOID*) &pSound ));
	pSound2 = NULL;
	CHECKRUN(pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "ricochet.wav",
											   (LPVOID*) &pSound2 ));
	DbgPrint("Load sound returned %lx, %lx\n",hr,pSound);
    // Download the segment's instruments to the synthesizer
    DbgPrint("Download instruments.\n");
    CHECKRUN(pMusic->Download( pPerformance ));
    CHECKRUN(pMusic->SetRepeats(100));
	CHECKRUN(pSound->Download( pPerformance ));
	CHECKRUN(pSound2->Download( pPerformance ));
    // Play segment on the default audio path
    DbgPrint("Play segment.\n"); 
    CHECKRUN(pPerformance->PlaySegmentEx( pMusic, NULL, NULL, 0, 
                                   0, NULL, NULL, NULL ));

    // Now DirectMusic will play in the background, 
    // so continue on with our task

    for (;SUCCEEDED(hr);)
    {
        Sleep(5000);
        REFERENCE_TIME rtNow,rtLatency,rtQueue;
        MUSIC_TIME mtNow;
		if (rand() % 3)
		{
			CHECKRUN(pPerformance->PlaySegmentEx( pSound2, NULL, NULL, DMUS_SEGF_SECONDARY, 
								   0, NULL, NULL, NULL ));
			DbgPrint("Play sound effect returned %lx\n",hr);
		}
		else
		{
			CHECKRUN(pPerformance->PlaySegmentEx( pSound, NULL, NULL, DMUS_SEGF_SECONDARY, 
								   0, NULL, NULL, NULL ));
			DbgPrint("Play sound effect returned %lx\n",hr);
		}
        CHECKRUN(pPerformance->GetTime(&rtNow,&mtNow));
//        CHECKRUN(pPerformance->GetLatencyTime(&rtLatency));
//        CHECKRUN(pPerformance->GetQueueTime(&rtQueue));
//        DbgPrint("Timenow: %ld, Latency: %ld, Queue: %ld, or %ld, %ld\n",
//            (long) rtNow / 10000, (long) rtLatency / 10000, (long) rtQueue / 10000,
//            (long)(rtQueue - rtLatency)/10000,(long)( rtLatency - rtNow)/10000);
        DbgPrint("Timenow: %ld\n",
            (long) rtNow / 10000);
    }

    // Stop the music, and close down 
    CHECKRUN(pPerformance->StopEx( NULL, NULL, 0));
//    CHECKRUN(pPerformance->CloseDown());

    // Cleanup all interfaces
    RELEASE(pLoader); 
//    RELEASE(pPerformance);
    RELEASE(pSound);
    RELEASE(pMusic);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_CallRoutine.cpp ===
/********************************************************************************
	FILE:
		Script_CallRoutine.cpp

	PURPOSE:
		CallRoutine tests for script

	BY:
		DANROSE
********************************************************************************/

#include "script.h"
 
HRESULT Script_CallRoutine( LPSTR szRoutine, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( CALLROUTINE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( szRoutine, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_CallRoutine( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

//	CHECKEXECUTE( Script_CallRoutine( NULL, ptPerf8, NULL ) );
//	CHECKEXECUTE( Script_CallRoutine( NULL, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( Script_CallRoutine( ROUTINE_GOOD, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_CallRoutine( ROUTINE_GOOD, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_EMPTY, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ROUTINE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_NO_EXIST, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ROUTINE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_CallRoutine( ROUTINE_RUNTIME_ERROR, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ERROR_IN_SCRIPT ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_GetVariableNumber.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableNumber.cpp

	PURPOSE:
		GetVariableNumber tests for script

	BY:
		DANROSE
********************************************************************************/
 
#include "script.h"
 
HRESULT Script_GetVariableNumber( LPSTR szVariableName, LONG* plValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableNumber( szVariableName, plValue, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( NUMBER_VALUE == *plValue ? S_OK : E_FAIL );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_GetVariableNumber( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	LONG lValue = 0;
	
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, &lValue, ptPerf8, NULL ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NULL, &lValue, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NUMBER_GOOD, NULL, ptPerf8, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( NUMBER_GOOD, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( Script_GetVariableNumber( NUMBER_GOOD, &lValue, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_GetVariableNumber( NUMBER_GOOD, &lValue, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( VARIABLE_EMPTY, &lValue, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableNumber( VARIABLE_NO_EXIST, &lValue, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\script.h ===
#pragma once

#include "globals.h"
#include "cicmusicx.h"

static const LPSTR INIT_SCRIPT           = "T:\\Media\\script\\init.spt";
static const LPSTR INIT_SCRIPT_NOEXIST   = "T:\\Media\\script\\haha.spt";
static const LPSTR INIT_SCRIPT_BAD       = "T:\\Media\\script\\bad.spt";
static const LPSTR INIT_SCRIPT_SYNTAX    = "T:\\Media\\script\\syntax.spt";
static const LPSTR INIT_SCRIPT_RUNTIME   = "T:\\Media\\script\\runtime.spt";
static const LPSTR CALLROUTINE_MASTER    = "T:\\Media\\script\\master.spt";
static const LPSTR VARIABLE_MASTER       = "T:\\Media\\script\\variables.spt";

static const LPSTR ROUTINE_GOOD          = "NoError";
static const LPSTR ROUTINE_NO_EXIST      = "Bingo";
static const LPSTR ROUTINE_RUNTIME_ERROR = "BadObject";
static const LPSTR ROUTINE_EMPTY         = "";

static const LPSTR VARIABLE_INIT         = "Init";
static const LPSTR NUMBER_GOOD           = "Number";
static const LPSTR VARIABLE_EMPTY        = "";
static const LPSTR VARIABLE_NO_EXIST     = "Bingo";
static const LONG NUMBER_VALUE           = 100;
static const LONG NEW_VALUE              = 200;

static const LPSTR SEGMENT_GOOD          = "PlayingSegment1";

HRESULT dmthCreateScript( LPSTR szScriptName, CtIDirectMusicLoader8* pLoader, CtIDirectMusicScript** ppScript );
HRESULT dmthInitScriptErrorInfo( DMUS_SCRIPT_ERRORINFO* pInfo );
void dmthVerifyScriptError( DMUS_SCRIPT_ERRORINFO* pInfo );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_GetVariableObject.cpp ===
/********************************************************************************
	FILE:
		Script_GetVariableObject.cpp

	PURPOSE:
		GetVariableObject tests for script

	BY:
		DANROSE
********************************************************************************/

#include "script.h"
 
HRESULT Script_GetVariableObject( LPSTR szVariableName, REFIID riid, LPVOID* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableObject( szVariableName, riid, ppv, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( NULL != *((IDirectMusicSegment**)ppv) ? S_OK : E_FAIL );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_GetVariableObject( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	IDirectMusicSegmentState8* pSeg = NULL;
	
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, GUID_NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, GUID_NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, IID_IDirectMusicSegment, &pVoid, ptPerf8, NULL ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( NULL, IID_IDirectMusicSegment, &pVoid, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( SEGMENT_GOOD, GUID_NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( SEGMENT_GOOD, GUID_NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( Script_GetVariableObject( SEGMENT_GOOD, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_GetVariableObject( SEGMENT_GOOD, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( VARIABLE_EMPTY, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_GetVariableObject( VARIABLE_NO_EXIST, IID_IDirectMusicSegment, (LPVOID*) &pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	RELEASE( pSeg );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_SetVariableObject.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableObject.cpp

	PURPOSE:
		SetVariableObject tests for script

	BY:
		DANROSE
********************************************************************************/

#include "script.h"
 
HRESULT Script_SetVariableObject( LPSTR szVariableName, IUnknown* ppv, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->SetVariableObject( szVariableName, ppv, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_SetVariableObject( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	IDirectMusicSegmentState8* pSeg = NULL;
	
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, NULL, ptPerf8, NULL ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, pSeg, ptPerf8, NULL ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( NULL, pSeg, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( SEGMENT_GOOD, NULL, ptPerf8, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( SEGMENT_GOOD, NULL, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( Script_SetVariableObject( SEGMENT_GOOD, pSeg, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_SetVariableObject( SEGMENT_GOOD, pSeg, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( VARIABLE_EMPTY, pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableObject( VARIABLE_NO_EXIST, pSeg, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	RELEASE( pSeg );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_SetVariableNumber.cpp ===
/********************************************************************************
	FILE:
		Script_SetVariableNumber.cpp

	PURPOSE:
		SetVariableNumber tests for script

	BY:
		DANROSE
********************************************************************************/

#include "script.h"
 
HRESULT Script_SetVariableNumber( LPSTR szVariableName, LONG lValue, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	LONG lVal = 0;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( VARIABLE_MASTER, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->CallRoutine( VARIABLE_INIT, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->SetVariableNumber( szVariableName, lValue, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( pScript->GetVariableNumber( szVariableName, &lVal, pInfo ) );
	dmthVerifyScriptError( pInfo );

	CHECKRUN( lVal == lValue ? S_OK : E_FAIL );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_SetVariableNumber( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;
	
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, NULL ), E_POINTER ) );
//	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( NULL, NEW_VALUE, ptPerf8, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_SetVariableNumber( NUMBER_GOOD, NEW_VALUE, ptPerf8, &dmScriptError ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_EMPTY, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_SetVariableNumber( VARIABLE_NO_EXIST, NEW_VALUE, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_VARIABLE_NOT_FOUND ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Script_Init.cpp ===
/********************************************************************************
	FILE:
		Script_Init.cpp

	PURPOSE:
		Init tests for script

	BY:
		DANROSE
********************************************************************************/

#include "script.h"

HRESULT Script_Init( LPSTR szScript, CtIDirectMusicPerformance8* pPerf, DMUS_SCRIPT_ERRORINFO* pInfo )
{
	HRESULT hr = S_OK;
	
	CtIDirectMusicScript* pScript = NULL;
	CtIDirectMusicLoader8* pLoader = NULL;

	CHECKRUN( dmthCreateLoader( IID_IDirectMusicLoader8, &pLoader ) );
	CHECKALLOC( pLoader );
	CHECKRUN( dmthInitScriptErrorInfo( pInfo ) );
	CHECKRUN( dmthCreateScript( szScript, pLoader, &pScript ) );
	CHECKALLOC( pScript );
	CHECKRUN( pScript->Init( pPerf, pInfo ) );
	dmthVerifyScriptError( pInfo );

	RELEASE( pScript );
	RELEASE( pLoader );

	return hr;
}

HRESULT Script_Init( CtIDirectMusicPerformance8* ptPerf8 )
{
	HRESULT hr = S_OK;

	DMUS_SCRIPT_ERRORINFO dmScriptError;

	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, NULL ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT, NULL, &dmScriptError ), E_POINTER ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_NOEXIST, ptPerf8, &dmScriptError ), E_OUTOFMEMORY ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_BAD, ptPerf8, &dmScriptError ), E_OUTOFMEMORY ) );
	CHECKEXECUTE( SUCCEED_ON_FAIL( Script_Init( INIT_SCRIPT_SYNTAX, ptPerf8, &dmScriptError ), DMUS_E_SCRIPT_ERROR_IN_SCRIPT ) );

	CHECKEXECUTE( Script_Init( INIT_SCRIPT, ptPerf8, NULL ) );
	CHECKEXECUTE( Script_Init( INIT_SCRIPT, ptPerf8, &dmScriptError ) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Segment8_Download.cpp ===
#include "globals.h"

DWORD Segment8_DownloadUnload_BVT(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Segment8_Download (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Segment8_Download())");

    CALLDMTEST(Segment8_DownloadUnload_BVT(ptPerf8, 0, 0, 0, 0));           //PASSES

    return hr;
};


/********************************************************************************
********************************************************************************/
DWORD Segment8_DownloadUnload_BVT(TESTPARAMS)
{
DWORD dwRes = FNS_FAIL;
HRESULT hr = S_OK;
CHAR *szFileName[2] = {"T:\\Media\\Segment8\\Download\\One.sgt",
                       "T:\\Media\\Segment8\\Download\\Two.sgt"};

CtIDirectMusicSegment8 *ptSegment8 = NULL;
CtIDirectMusicAudioPath *ptPath = NULL;
BOOL bDownloadToPerf = 0;
DWORD dwSegment = 0;


    //Create a audiopath.
    hr = ptPerf8->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 32, TRUE, &ptPath);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: CreateStandardAudioPath returned %s (%08Xh)", tdmXlatHRESULT(hr), hr);
	    goto TEST_END;
    }
    
    //Try downloading to both the performance and the audiopath.
    for (bDownloadToPerf = 0; bDownloadToPerf < 2; bDownloadToPerf++)
    {
        //Play both the segments.
        for (dwSegment=0; dwSegment<2; dwSegment++)
        {
            //Load up the media file.
            hr = dmthLoadSegment(szFileName[dwSegment], &ptSegment8);
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment(%s) returned %s (%08Xh)",szFileName[dwSegment], tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }


            //Download everything.
            fnsLog(FYILOGLEVEL, "Downloading to %s interface", bDownloadToPerf ? "Performance8" : "AudioPath");
            hr = ptSegment8->Download(bDownloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath); 
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Download() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
		        goto TEST_END;
	        }
            //bDownloaded = TRUE;

            //Play the segment.
	        hr = ptPerf8->PlaySegmentEx( 
		        ptSegment8,
		        0,
                NULL, 			
		        0, 	
		        0,
                NULL,
                NULL,
                ptPath
                );
	        if(FAILED(hr))
	        {
		        fnsLog(ABORTLOGLEVEL, "!!!! BUG: pwPerformance->PlaySegmentEx failed (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
                hr = ptSegment8->Unload(bDownloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);
	            if(FAILED(hr))
	            {
                    fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
                    fnsLog(ABORTLOGLEVEL, "**** TEST ERROR: Could not unload - Test case is leaving a segment downloaded!!!!!!");
		            goto TEST_END;
	            }
		        goto TEST_END;
	        }
            fnsLog(FYILOGLEVEL, "Playing segment for 5 seconds, you should hear the phrase ""%d"" being spoken", dwSegment+1);
            Sleep(5000);

            fnsLog(FYILOGLEVEL, "Unloading from %s interface", bDownloadToPerf ? "Performance8" : "AudioPath");
            hr = ptSegment8->Unload(bDownloadToPerf ? (CtIUnknown *)ptPerf8 : (CtIUnknown *)ptPath);
	        if(FAILED(hr))
	        {
                fnsLog(ABORTLOGLEVEL, "**** ABORT: Unload() returned %s (%08Xh)",tdmXlatHRESULT(hr), hr);
                fnsLog(ABORTLOGLEVEL, "**** TEST ERROR: Could not unload - Test case is leaving a segment downloaded!!!!!!");
		        goto TEST_END;
	        }

            SAFE_RELEASE(ptSegment8);            
        }
    };




    dwRes = FNS_PASS;

TEST_END:
    SAFE_RELEASE(ptSegment8);
    SAFE_RELEASE(ptPath);
    return dwRes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Segment8_SetRepeats.cpp ===
#include "globals.h"
#include "CICMusicX.h"

DWORD Segment8_SetRepeats_BVT(TESTPARAMS);


/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Segment8_SetRepeats (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Segment8_SetRepeats())");

    CALLDMTEST(Segment8_SetRepeats_BVT    (ptPerf8, 0, 0, 0, 0));

    return hr;
};


/********************************************************************************
********************************************************************************/
DWORD Segment8_SetRepeats_BVT(TESTPARAMS)
{
    DWORD dwRes = FNS_FAIL;
    HRESULT hr = S_OK;
    CICMusic Music;
    CtIDirectMusicSegment8 *ptSegment8 = NULL;
    CtIDirectMusicAudioPath *ptPath = NULL;
    DWORD dwRepeatValues[] = {0, 1, 2, 5, DMUS_SEG_REPEAT_INFINITE };
    DWORD i=0;


    //Load up and play our segment.  It's really short so we can count the number of times it plays.
    hr = Music.Init(ptPerf8, "T:\\Media\\Segment8\\SetRep\\ShortSeg.sgt", DMUS_APATH_SHARED_STEREOPLUSREVERB);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Music.Init returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    hr = Music.GetInterface(&ptSegment8);
    hr = Music.GetInterface(&ptPath);

    //Try all these repeat values.
    for (i=0; i<AMOUNT(dwRepeatValues); i++)
    {

        //Stop everything and wait a sec.
        hr = ptPerf8->StopEx(0, 0, 0);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: StopEx returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }
        Sleep(1000);


        //Set Repeats
        fnsLog(FYILOGLEVEL, "Calling SetRepeats(%u)",dwRepeatValues[i]);
        hr = ptSegment8->SetRepeats(dwRepeatValues[i]);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: SetRepeats(%u) returned (%s == %08Xh)",dwRepeatValues[i], tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }

         //Play
         hr = ptPerf8->PlaySegmentEx( 
		            ptSegment8, 
		            0,
		            NULL,
                    0, 
		            0,
		            NULL,
		            NULL,
		            ptPath);
	    if(FAILED(hr))
	    {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegmentEx() returned (%s == %08Xh)",tdmXlatHRESULT(hr), hr);
		    goto TEST_END;
	    }

        //Wait for segment to start.
        while (ptPerf8->IsPlaying(ptSegment8, NULL) == S_FALSE);


        //Wait until done
        if (dwRepeatValues[i] != DMUS_SEG_REPEAT_INFINITE)
        {
            fnsLog(FYILOGLEVEL, "Waiting until segment stops");
            while (ptPerf8->IsPlaying(ptSegment8, NULL) == S_OK);
        }
        else
        {
            fnsLog(FYILOGLEVEL, "Waiting 5 seconds.");
            Sleep(5000);
        }
    }

    dwRes = FNS_PASS;

TEST_END:

    SAFE_RELEASE(ptSegment8);
    return dwRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\SegmentState8_GetObjectInPath1.cpp ===
#include "globals.h"
#include "cicmusicx.h"
#include "AudioPath_GetObjectInPath1.hpp"




HRESULT SegmentState8_GetObjectInPath_BVT(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface);



/********************************************************************************
Main test function.
********************************************************************************/
HRESULT SegmentState8_GetObjectInPath (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function AudioPath_GetObjectInPath())");
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_SEGMENT,     (GUID *)&GUID_All_Objects, (GUID *)&IID_IDirectMusicSegment8));
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_SHARED_STEREOPLUSREVERB, DMUS_PATH_PERFORMANCE, (GUID *)&CLSID_DirectMusicPerformance, (GUID *)&IID_IDirectMusicPerformance8));                                             
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_3D,              DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_MONO,            DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    CHECKEXECUTE(SegmentState8_GetObjectInPath_BVT(ptPerf8, DMUS_APATH_DYNAMIC_STEREO,          DMUS_PATH_BUFFER,      (GUID *)&GUID_All_Objects, (GUID *)&GUID_NULL));                                             
    return hr;
};



/********************************************************************************
UNIT TEST
IDirectMusicAudioPath::GetObjectInPath()

HISTORY:

PARAMS:
    dwParam3:
        Which test scenario will be run.  Currently there are i scenarios, each
        with different standard paths, objects to retrieve, etc...
    dwParam4         Not used
********************************************************************************/
HRESULT SegmentState8_GetObjectInPath_BVT(CtIDirectMusicPerformance8 *ptPerf8,
                                      DWORD dwPathType,
                                      DWORD dwStage,
                                      GUID *pguidObject,
                                      GUID *pguidInterface)
{
    return tmplGetObjectInPath<CtIDirectMusicSegmentState8>(ptPerf8, dwPathType, dwStage, pguidObject, pguidInterface);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tdmperf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tdmperf.h
//
//--------------------------------------------------------------------------

//===========================================================================
// tdmperf.h
//
// History:
//  01/05/1998 - markburt - created
//  03/10/1998 - jimmo    - Merged tdmperfi.h and tdmperfb.h
//                          Added C-Style declarations where needed
//  06/09/1998 - jimmo    - Added tdmperfAddPortNoInitInvalTest
//  07/31/1998 - a-llucar - added GetResolvedTime tests
//===========================================================================

#ifndef _TDMPERF_H
#define _TDMPERF_H


//===========================================================================
// Unit test prototypes
//===========================================================================
#ifdef __cplusplus

// tests
DWORD tdmperfInitTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfPlaySegmentTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetSegmentStateTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfSetPrepareTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfSetBumperLengthTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfSendPMsgTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfMusicToReferenceTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfReferenceToMusicTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetGraphTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfSetNotificationHandleTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetNotificationPMsgTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfAddNotificationTypeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfRemovePortTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfAssignPChannelBlockTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfAssignPChannelTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfPChannelInfoTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfDownloadInstrumentTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfInvalidateTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetParamTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfSetParamTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetGlobalParamTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetLatencyTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetQueueTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfAdjustTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfCloseDownTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfGetResolvedTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfQueryInterfaceTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfRhythmToTimeTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);

// dx7 tests (perf2)
DWORD tdmperf2QueryInterfaceTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);

// dx8 tests
DWORD tdmperf8ClonePMsg(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8CreateAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8CreateStandardAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8GetDefaultAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8GetParamEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8InitAudio(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8PlaySegmentEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8SetDefaultAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
//PHOOPHOO
//DWORD tdmperf8SetParamHook(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperf8StopEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);


#endif // __cplusplus

//===========================================================================
// Invalid test prototypes
//===========================================================================
#ifdef __cplusplus
DWORD tdmperfiInitInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiPlaySegmentInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiStopInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetSegmentStateInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetPrepareTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetBumperLengthInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiSendPMsgInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiSendPMsgWithCOMToolTest(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiAllocPMsgInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiMusicToReferenceTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiReferenceToMusicTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiIsPlayingInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiFreePMsgInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiFreePMsgWithdwSize0(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetGraphInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetNotificationPMsgInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiSetGraphInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiAddPortInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiRemovePortInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiAssignPChannelBlockInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiAssignPChannelInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiPChannelInfoInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiDownloadInstrumentInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetParamInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiSetParamInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiSetGlobalParamInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetGlobalParamInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetLatencyTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetQueueTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);

DWORD tdmperfAddPortNoInitInvalTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmPerfiQIInvalidTest1( BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2 );

DWORD tdmperfiPlaySegmentInvalTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiPlaySegmentInvalidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiGetResolvedTimeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfiAddNotificationTypeInvalidTest1(BOOL fUseNULL, BOOL fParamNum, LPARAM dwParam1, LPARAM dwParam2);
//dx8
DWORD tdmperi8ClonePMsg(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8CreateAudioPath(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8CreateStandardAudioPath(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8GetDefaultAudioPath(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8InitAudio(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8PlaySegmentEx(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8SetDefaultAudioPath(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8GetParamEx(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8StopEx(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperi8AudioPathWithBandSends(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperfiInitAudioWithDSoundOne(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperfiInitAudioWithDSoundNoInit(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperfiInitAudioWithDSoundNoSetCoop(BOOL,BOOL,LPARAM, LPARAM);
DWORD tdmperfiInitAudioWithDSoundSetCoopNorm(BOOL,BOOL,LPARAM, LPARAM);

#endif // __cplusplus

//===========================================================================
// Valid test prototypes
//===========================================================================
#ifdef __cplusplus
DWORD tdmperfvAdjustTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAddPortValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAddPortValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvCloseDownValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvCloseDownValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAssignPChannelValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAssignPChannelValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAssignPChannelBlockValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAssignPChannelBlockValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAddNotificationTypeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetNotificationHandleValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAddNotificationTypeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetLatencyTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest4(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest5(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPlaySegmentValidTest6(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);

DWORD tdmperfvStopValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvStopValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvStopValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInitValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvMusicToReferenceTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvAllocPMsgValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetBumperLengthValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetBumperLengthValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvFreePMsgValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSendPMsgWithCOMToolTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvReferenceToMusicTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvRemovePortValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvDownloadInstrumentValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvFreePMsgValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvFreePMsgValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetSegmentStateValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInvalidateValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwFlags, LPARAM mtTime);
DWORD tdmperfvGetSegmentStateValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetParamValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetGlobalParamValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvQIValidTest1( BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2 );

DWORD tdmperfvSetPrepareTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetResolvedTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetResolvedTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetParamValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvMusicToReferenceTimeValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvRhythmToTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvMIDIToMusicValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvMIDIToMusicValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);

// dx8 tests
DWORD tdmperv8AddNotificationTypeValidTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8ClonePMsg(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8AllocPMsgChannelGroup(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8CloseDownTwiceTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8CreateAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8CreateStandardAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8GetDefaultAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8GetParamEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8InitAudio(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentTypeEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentExFrom(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentExRPN(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentExSynthLeak(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8SetDefaultAudioPath(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
//DWORD tdmperv8SetParamHook(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8StopEx(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlaySegmentNoPiano(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInitAudioPlayWave(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInitAudioPlayWaveLoop(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInitAudioWithDSound(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PChannelInfo(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperv8PlayWaveAsSegment(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);


// CAP tests
DWORD tdmperfvStopCAPTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetGraphValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSendPMsgValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetQueueTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetQueueTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvInitValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetLatencyTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetGlobalParamValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPChannelInfoValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvPChannelInfoValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetPrepareTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvIsPlayingValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetParamValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvRemoveNotificationTypeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvReferenceToMusicTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvMusicToReferenceTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvSetGraphValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmPerfvMultipleToolsValidTest(BOOL fIndexFromEnd, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetGlobalParamValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);
DWORD tdmperfvGetGlobalParamValidTest4(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2);

#endif // __cplusplus

#endif // _TDMPERF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\Segment8_Unload.cpp ===
#include "globals.h"

/********************************************************************************
Main test function.
********************************************************************************/
HRESULT Segment8_Unload (CtIDirectMusicPerformance8* ptPerf8)
{
    HRESULT hr = S_OK;
    DWORD dwRes = FNS_FAIL;
    fnsLog(FYILOGLEVEL, "Calling main test function Segment8_Unload())");

    fnsLog(FYILOGLEVEL, "--- CURRENT TESTING IS IMPLEMENTED IN Segment8_Download ---");

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tdmperf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tdmperf.cpp
//
//--------------------------------------------------------------------------


#include "globals.h"


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SendPMsg()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SendPMsg().
//
// Test Function: <nl>
// tdmperfSendPMsgTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg and check result <nl>
// 5) Set pNote with a bunch of particulars <nl>
// 6) Call SendPMsg and check result <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//	The same test is used for AllocPMsg() and SendPMsg() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfSendPMsgTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	CtIDirectMusicPerformance8		*pwPerformance	= NULL;
    CtIDirectMusicLoader8             *ptLoader8      = NULL;
    CtIDirectMusicSegment8             *ptSegment8      = NULL;
	DMUS_OBJECTDESC DESC = {0};					// Descriptor to use to find it.
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}


    hr = pwPerformance->InitAudio(NULL, NULL, NULL, DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, 0, NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: pwPerformance->InitAudio failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


    hr = dmthCreateLoader(IID_IDirectMusicLoader8, &ptLoader8);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: dmthCreateLoader failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


    hr = ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, gwszMediaPath, FALSE);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ERROR: IDirectMusicLoader8::SetSearchDirectory failed!!");
        goto TEST_END;
    }

    // Set the GM DLS Collection so we can load midi files.
    Log(FYILOGLEVEL, "Installing GM.DLS.\n");
	memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
	DESC.dwSize = sizeof (DMUS_OBJECTDESC);
	DESC.guidClass = CLSID_DirectMusicCollection;  
	wcscpy(DESC.wszFileName,L"gm.dls");
	DESC.guidObject = GUID_DefaultGMCollection;
	DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_OBJECT;
	hr = ptLoader8->SetObject(&DESC);
	if (S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetObject returned (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
	}


    hr = ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment, CTIID_IDirectMusicSegment8, g_wszDefaultMedia, (void **)&ptSegment8);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: pLoader8->LoadObjectFromFile failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptSegment8->Download(pwPerformance);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: ptSegment8->Download failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }


	// **********************************************************************
    // 4) Call AllocPMsg and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pNote correctly, \n"),
                TEXT("pNote == %08Xh"),
                pNote);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // **********************************************************************
    // 5) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6) Call SendPMsg and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}


//I verified this works.
/*
    hr = pwPerformance->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if (S_OK != hr)
    {
        fnsLog(ABORTLOGLEVEL,"**** ABORT: pwPerformance->PlaySegmentEx failed with %s (%08X)",tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

*/
    Log(FYILOGLEVEL, "Should hear a note play");
    Sleep(5000);

TEST_END:

    SAFE_RELEASE(ptLoader8);
    SAFE_RELEASE(ptSegment8);

    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AllocPMsg()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AllocPMsg().
//
// Test Function: <nl>
// tdmperfSendPMsgTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call Init on performance <nl>
// 4) Call AllocPMsg and check result <nl>
// 5) Set pNote with a bunch of particulars <nl>
// 6) Call SendPMsg and check result <nl>
// 7) Call FreePMsg and check results <nl>
// 8) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//	The same test is used for AllocPMsg() and SendPMsg() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
//  !!!!!!!!!! Test Case removed (uses tdmperfSendPMsgTest) !!!!!!!!!!!!!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MusicToReferenceTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::MusicToReferenceTime(). <nl>
//
// Test Function: <nl>
// tdmperfMusicToReferenceTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call MusicToReferenceTime and check results<nl>
// 5) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
/*
DWORD tdmperfMusicToReferenceTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusic				*pwMusic		= NULL;
	REFERENCE_TIME				rt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call MusicToReferenceTime and check results
    // **********************************************************************
	hr = pwPerformance->MusicToReferenceTime( 1000, &rt );

	// Test the function
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusicToReference ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
	// Test to make sure that rt was populated
	if(!rt)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: ReferenceTime rt was not properly populated \n")
                TEXT("rt == %ul"), rt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
        pwMusic = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::ReferenceToMusicTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::ReferenceToMusicTime(). <nl>
//
// Test Function: <nl>
// tdmperfReferenceToMusicTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call GetTime to try to get a time after that <nl>
// 5) Call ReferenceToMusicTime and check results<nl>
// 6) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfReferenceToMusicTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusic				*pwMusic		= NULL;
	MUSIC_TIME					mt				= NULL;
	REFERENCE_TIME				rt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime to try to get a time after that
    // **********************************************************************
	hr = pwPerformance->GetTime(&rt, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->GetTime ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) Call MusicToReferenceTime and check results
    // **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime(rt + 300000, &mt);

	// Test the function
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusicToReference ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that rt was populated
	if(!mt)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: ReferenceTime rt was not properly populated \n")
                TEXT("mt == %ul"), mt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
        pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::IsPlaying()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::IsPlaying().
//
// Test Function: <nl>
// tdmperfPlaySegmentTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object) <nl>
// 4) Loader->EnableCache(GUID_DirectMusicAllTypes) <nl>
// 5) Load the Style Object <nl>
// 6) Load the ChordMap Object <nl>
// 7) Get two segments by calling ComposeSegmentFromShape <nl>
// 8) Create CtIDirectMusicPerformance object (wrapped IDirectMusicPerformance object) <nl>
// 9) Init the Performance <nl>
// 10) Add a port to the Performance (Synth port) <nl>
// 11) Activate the Performance <nl>
// 12) Play the Segment, check the results <nl>
// 13) Wait for IsPlaying to return favorably (or time out) <nl>
// 14) Stop the segment, check the results <nl>
// 15) Wait for IsPlaying to return favorably (or time out) <nl>
// 16) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//	This same test is used for PlaySegment(), IsPlaying(), and Stop() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!  Test case removed (uses PlaySegment() test) !!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetTime(). <nl>
//
// Test Function: <nl>
// tdmperfGetTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Init the Performance <nl>
// 4) Call GetTime() and check Results<nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusic				*pwMusic		= NULL;
	MUSIC_TIME					mt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call GetTime() and check results
    // **********************************************************************
	hr = pwPerformance->GetTime( NULL, &mt );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
        pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::FreePMsg()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::FreePMsg(). <nl>
//
// Test Function: <nl>
// tdmperfGetNotificationPMsgTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Call Stop and check results <nl>
// 11) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//  NOTE: Same test used for GetNotificationPMsg() and FreePMsg()
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!!!!!!! Test has been removed (uses GetNotificationPMsgTest) !!!!!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGraph()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetGraph(). <nl>
//
// Test Function: <nl>
// tdmperfGetGraphTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create CtIDirectMusicGraph object <nl>
// 4) Call SetGraph() and check the results <nl>
// 5) Call SetGraph() and check the results <nl>
// 6) Get real Graph objects to compare <nl> 
// 7) Compare the two Graphs to make sure they're the same <nl>
// 8) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//  Note: This is the same test for GetGraph() and SetGraph() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetGraphTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicGraph				*pwGraph		= NULL;
	CtIDirectMusicGraph				*pwGraph2		= NULL;
	IDirectMusicGraph				*pGraph			= NULL;
	IDirectMusicGraph				*pGraph2		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicGraph object 
    // **********************************************************************
	hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call SetGraph() and check the results 
    // **********************************************************************
	hr = pwPerformance->SetGraph(pwGraph);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGraph ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call SetGraph() and check the results 
    // **********************************************************************
	hr = pwPerformance->GetGraph(&pwGraph2);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGraph ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Get real Graph objects to compare 
    // **********************************************************************
	hr = pwGraph2->GetRealObjPtr(&pGraph2);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetRealObjPtr (Graph2) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwGraph->GetRealObjPtr(&pGraph);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetRealObjPtr (Graph) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Compare the two Graphs to make sure they're the same
    // **********************************************************************
	if(pGraph != pGraph2)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pGraph != pGraph2 \n")
                TEXT("pGraph == %08Xh\n")
                TEXT("pGraph2 == %08Xh"),
				pGraph, pGraph2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
TEST_END:
    // **********************************************************************
    // 8) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pGraph)
	{
		pGraph->Release();
        pGraph = NULL;
	}
	if(pGraph2)
	{
		pGraph2->Release();
        pGraph2 = NULL;
	}
	if(pwGraph)
	{
		pwGraph->Release();
        pwGraph = NULL;
	}
	if(pwGraph2)
	{
		pwGraph2->Release();
        pwGraph2 = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetGraph()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SetGraph(). <nl>
//
// Test Function: <nl>
// tdmperfGetGraphTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create CtIDirectMusicGraph object <nl>
// 4) Call SetGraph() and check the results <nl>
// 5) Call SetGraph() and check the results <nl>
// 6) Get real Graph objects to compare <nl> 
// 7) Compare the two Graphs to make sure they're the same <nl>
// 8) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//  Note: This is the same test for GetGraph() and SetGraph() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!  Test case removed (uses GetGraph() test) !!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetNotificationHandle()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SetNotificationHandle(). <nl>
//
// Test Function: <nl>
// tdmperfSetNotificationHandleTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create an hNotify Event <nl>
// 4) Call SetNotificationHandle and check results <nl>
// 5) Call SetNotificationHandle and check results (to clear it out) <nl>
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfSetNotificationHandleTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	HANDLE							hNotify			= NULL;
	HANDLE							hNotifyClear	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create an hNotify Event
    // **********************************************************************
	hNotify = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotify )
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: hNotify Event ")
                TEXT("failed (hNotify == %08Xh)"),
                hNotify);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call SetNotificationHandle and check results
    // **********************************************************************
	hr = pwPerformance->SetNotificationHandle( hNotify, 0 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetNotificationHandle (valid event)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call SetNotificationHandle and check results (to clear it out)
    // **********************************************************************
	hr = pwPerformance->SetNotificationHandle( hNotifyClear, 0 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetNotificationHandle (NULL event)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if( hNotify )
	{
		CloseHandle(hNotify);
	}
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetNotificationPMsg()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetNotificationPMsg(). <nl>
//
// Test Function: <nl>
// tdmperfGetNotificationPMsgTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Call Stop and check results <nl>
// 11) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//  NOTE: Same test used for GetNotificationPMsg() and FreePMsg()
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetNotificationPMsgTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	DMUS_NOTIFICATION_PMSG		*pEvent				= NULL;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	HANDLE						hNotification       = NULL;
	GUID						guidNotification	= GUID_NOTIFICATION_SEGMENT;
	DWORD						dwResult            = 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create an Event for hNotification
    // **********************************************************************
	hNotification = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotification )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Unable to Create an hNotificationEvent \n")
		    TEXT("(%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
	// 4) Create an Event for hNotification and check results
	// **********************************************************************
    hr = pwPerformance->SetNotificationHandle( hNotification, 0 );
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->SetNotificationHandle  ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
		
	// **********************************************************************
	// 5) AddNotificationType and check results 
	// **********************************************************************
    hr = pwPerformance->AddNotificationType( guidNotification );
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddNotificationType ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

   	// **********************************************************************
    // 6) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, NULL );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

   	// **********************************************************************
    // 7) Wait for a single object to know that things should be fine
    // **********************************************************************
	dwResult = WaitForSingleObject( hNotification, 1000 );
	if( dwResult != WAIT_OBJECT_0 )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: WaitForSingleObject "));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// **********************************************************************
    // 8) Call GetNotificationPMsg and check results
    // **********************************************************************
	hr = pwPerformance->GetNotificationPMsg(&pEvent);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
	// Check to make sure that pEvent was populated
	if(!pEvent)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("pEvent wasn't properly populated\n")
                TEXT("pEvent == %08Xh\n"),
                pEvent);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Call FreePMsg and check results
    // **********************************************************************
    hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->FreePMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

		
    // **********************************************************************
    // 10) Call Stop and check results
    // **********************************************************************
	Sleep(3000);
	hr = pwPerformance->Stop(NULL, NULL, 0, 0);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Stop ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
	}

TEST_END:
    // **********************************************************************
    // 11) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(hNotification)
	{
		CloseHandle(hNotification);
		hNotification = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddNotificationType()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AddNotificationType(). <nl>
//
// Test Function: <nl>
// tdmperfAddNotificationTypeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Call AddNotificationType() and check results <nl>
// 4) Call RemoveNotificationType() and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note:  Same test for AddNotificationType() and RemoveNotificationType(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfAddNotificationTypeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						         LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	GUID							guid			= { 0, 0, 0, 0 };	
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call AddNotificationType and check results
    // **********************************************************************
	hr = pwPerformance->AddNotificationType(guid);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AddNotificationType ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call RemoveNotificationType and check results
    // **********************************************************************
	hr = pwPerformance->RemoveNotificationType(guid);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->RemoveNotificationType ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RemoveNotificationType()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::RemoveNotificationType(). <nl>
//
// Test Function: <nl>
// tdmperfAddNotificationTypeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Call AddNotificationType() and check results <nl>
// 4) Call RemoveNotificationType() and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note:  Same test for AddNotificationType() and RemoveNotificationType(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!  Test case removed (uses AddNotificationType() test) !!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddPort()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AddPort(). <nl>
//
// Test Function: <nl>
// tdmperfRemovePortTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call RemovePort and check results <nl>
// 8) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note:  Same test for AddPort() and RemovePort(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!  Test case removed (uses RemovePort() test) !!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RemovePort()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::RemovePort(). <nl>
//
// Test Function: <nl>
// tdmperfRemovePortTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call RemovePort and check results <nl>
// 8) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note:  Same test for AddPort() and RemovePort(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfRemovePortTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	GUID						NullGUID		= {00000000-0000-0000-0000-000000000000};
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTCAPS				dmpc;
	GUID				        guidPort		= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	ZeroMemory(&dmpc, sizeof(DMUS_PORTCAPS));
	dmpc.dwSize = sizeof(DMUS_PORTCAPS);
	hr = pwMusic->GetDefaultPort(&guidPort);
  	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->GetDefaultPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	DMUS_PORTPARAMS dmos;
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
		&dmos, 
		&pwPort, 
		NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}    
	
	// **********************************************************************
    // 7) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->RemovePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 8) Release objects, CoUninitialize, and check results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
        pwMusic = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
        pwPort = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannelBlock()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AssignPChannelBlock(). <nl>
//
// Test Function: <nl>
// tdmperfAssignPChannelBlockTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call AssignPChannelBlock and check results <nl>
// 8) Call RemovePort and check results <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfAssignPChannelBlockTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	GUID						NullGUID		= {00000000-0000-0000-0000-000000000000};
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTCAPS				dmpc;
	GUID				        guidPort			= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	ZeroMemory(&dmpc, sizeof(DMUS_PORTCAPS));
	dmpc.dwSize = sizeof(DMUS_PORTCAPS);

	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->GetDefaultPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	DMUS_PORTPARAMS dmos;
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}    
	
    // **********************************************************************
    // 7) Call AssignPChannelBlock and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannelBlock( 0, pwPort, 1 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannelBlock ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 8) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->RemovePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
	}

TEST_END:
	// **********************************************************************
    // 9) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
        pwMusic = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
        pwPort = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannel()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AssignPChannel(). <nl>
//
// Test Function: <nl>
// tdmperfAssignPChannelTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call AssignPChannel and check results <nl>
// 8) Call RemovePort and check results <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfAssignPChannelTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTCAPS				dmpc;
	GUID				        guidPort		= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	ZeroMemory(&dmpc, sizeof(DMUS_PORTCAPS));
	dmpc.dwSize = sizeof(DMUS_PORTCAPS);

	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, "**** ABORT: GetDefaultPort failed! "
                "(%s == %08Xh)",
                dmthXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	DMUS_PORTPARAMS dmos;
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}    
	
    // **********************************************************************
    // 7) Call AssignPChannel and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannel( 0, pwPort, 1, 0 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannel ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 8) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->RemovePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
	}

TEST_END:
	// **********************************************************************
    // 9) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
        pwMusic = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
        pwPort = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PChannelInfo()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::PChannelInfo(). <nl>
//
// Test Function: <nl>
// tdmperfPChannelInfoTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Call AddPort (Synth) and check results <nl>
// 4) Call PChannelInfo and check results <nl>
// 5) Check to make sure that PChannelInfo returned the right info <nl>
// 6) Release object, CoUninitialize, and return results <nl>
// 7) Call AssignPChannel and check results <nl>
// 8) Call RemovePort and check results <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfPChannelInfoTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPort				*pwPort			= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	DWORD							dwGroup			= 0;
	DWORD							dwChannel		= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init(NULL) and AddPort(NULL)
    // **********************************************************************	
	hr = pwPerformance->Init(NULL,NULL,ghWnd); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call PChannelInfo and check results
    // **********************************************************************
	hr = pwPerformance->PChannelInfo( 0, &pwPort, &dwGroup, &dwChannel );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->PChannelInfo ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
    
	// **********************************************************************
    // 5) Check to make sure that PChannelInfo returned the right info
    // **********************************************************************
	if((NULL == pwPort) || (1 != dwGroup) || (0 != dwChannel))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->PChannelInfo ")
                TEXT("Did not return the right information\n")
				TEXT("pwPort -- Expected NULL, Returned %08Xh\n")
				TEXT("dwGroup -- Expected 1, Returned %ld\n")
				TEXT("dwChannel -- Expected 0, Returned %ld\n"),
                pwPort, dwGroup, dwChannel);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release object, CoUninitialize, and return results
    // **********************************************************************
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::DownloadInstrumentTest()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::DownloadInstrument(). <nl>
//
// Test Function: <nl>
// tdmperfDownloadInstrumentTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create CtIDirectMusicLoader object<nl>
// 4) Get the Object from the loader<nl>
// 5) Do QI on the object for the collection <nl>
// 6) Create a wrapped Instrument Collection <nl>
// 7) Create a wrapper for IDirectMusicCollection Object <nl>
// 8) Get an instrument collection and release the collection <nl>
// 9) Call Perf->AddPort(NULL) to set everything up for downloading <nl>
// 10) Call Download and check results <nl>
// 11) Release object, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  04/08/1998 - jimmo    - clean up autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfDownloadInstrumentTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD								dwRes			= FNS_PASS;
	HRESULT								hr				= S_OK;
	GUID								NullGUID		= {00000000-0000-0000-0000-000000000000};
	CtIDirectMusicLoader				*pIDMLoader		= NULL;
	CtIDirectMusicCollection			*pwCollection	= NULL;
	CtIDirectMusicInstrument			*pwInstrument	= NULL;
	CtIDirectMusicDownloadedInstrument  *pwDownloaded	= NULL;
	CtIDirectMusicPerformance			*pwPerformance	= NULL;
	CtIDirectMusicPort					*pwPort			= NULL;
	DMUS_OBJECTDESC						desc; 
	DMUS_NOTERANGE						pNoteRanges;
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize											= sizeof(DMUS_OBJECTDESC);
	DWORD								dwGroup			= 0;
	DWORD								dwMChannel		= 0;

	dmthSetPath(NULL);
	WCHAR								*wchPath		= gwszMediaPath;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicLoader object 
    // **********************************************************************	
	hr = dmthCreateLoader(IID_IDirectMusicLoader,&pIDMLoader);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicLoader object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Get the Object from the loader
    // **********************************************************************	
	hr = pIDMLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s === %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	desc.guidClass = CLSID_DirectMusicCollection;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME );
	MultiByteToWideChar(CP_ACP, NULL, (LPCSTR)"gmts.dls", -1, desc.wszFileName, DMUS_MAX_FILENAME);

	hr = pIDMLoader->GetObject(&desc,CTIID_IDirectMusicCollection,(void**)&pwCollection);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 8) Get an instrument collection and release the collection
    // **********************************************************************	
	hr = pwCollection->GetInstrument( 0, &pwInstrument );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Collection->GetInstrument ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Init(NULL) and AddPort(NULL)
    // **********************************************************************	
	hr = pwPerformance->Init(NULL,NULL,ghWnd); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); //pCtDM is NULL at this point
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 10) Call Download and check results
    // **********************************************************************	
	hr = pwPerformance->DownloadInstrument( pwInstrument, 
											0, 
											&pwDownloaded, 
											&pNoteRanges,
											5,
											&pwPort, 
											&dwGroup,
											&dwMChannel );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->DownloadInstrument ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	

TEST_END:
    // **********************************************************************
    // 11) Release object, CoUninitialize, and return results
    // **********************************************************************
	if(pwDownloaded)
	{
		if(pwPort)
		{
			hr = pwPort->UnloadInstrument(pwDownloaded);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, 
					"!!!! BUG: pwPort->UnloadInstrument() failed! "
					"(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
				dwRes = FNS_FAIL;
			}
		}
		pwDownloaded->Release();
		pwDownloaded = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pIDMLoader )
	{
		pIDMLoader->Release();
        pIDMLoader = NULL;
	}
	if( pwCollection )
	{
		pwCollection->Release();
        pwCollection = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
        pwPort = NULL;
	}
	if( pwInstrument )
	{
		pwInstrument->Release();
        pwInstrument = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Invalidate()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::Invalidate(). <nl>
//
// Test Function: <nl>
// tdmperfInvalidateTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call Invalidate and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfInvalidateTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call Invalidate and check results
    // **********************************************************************
	hr = pwPerformance->Invalidate( 0, 0 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Invalidate ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 4) Release objects, CoUnInitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetParam()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetParam(). <nl>
//
// Test Function: <nl>
// tdmperfGetParamTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Get Midi file (call GetMidiFile())  <nl>
// 4) Call AddPort (synth port) and check results <nl>
// 5) Set up a wrapped Segment object <nl>
// 6) Call PlaySegment and check results <nl>
// 7) Get the start time of the segment <nl>
// 8) Call GetParam (get the tempo clock after the start of the segState) <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetParamTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;	
	CtIDirectMusicSegment*		pwSegment		= NULL;
	CtIDirectMusicPerformance*	pwPerformance	= NULL;
	MUSIC_TIME					pmtNext			= NULL;
	MUSIC_TIME					mt				= NULL;
	GUID						guid			= GUID_TempoParam;
	DMUS_TEMPO_PARAM			tempo;

	int							tempoexpected	= (int)dwParam1;
	WCHAR*						pszMidiFile		= (WCHAR*)dwParam2;


    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pszMidiFile);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime() to get the Start Time and check results
    // **********************************************************************
	hr = pwPerformance->GetTime( NULL, &mt );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// Check to make sure that mt is something other than 0
	if(!mt)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (MUSIC_TIME mt==%ul, expected Non-Zero.)"),
				mt);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// add 3 measures of 4/4
	// this is necessary when using onestop2.mid
	// because there are tempo changes at the beginning of the file
	// The tempo near measure 4 will be found
	mt += (768 * 12);

    // **********************************************************************
    // 5) Call GetParam (get the tempo clock after the start of the segState)
    // **********************************************************************
	hr = pwPerformance->GetParam( guid, 0xffffffff, 0, mt, &pmtNext, (void*)&tempo ); 
	if( FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Make sure that it get's the right tempo
	// tempoexpected is DEPENDENT ON THE MIDI FILE!!!!!
	if ((int)tempo.dblTempo != tempoexpected)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetParam ")
                TEXT("tempo.dblTempo did not return correctly\n")
                TEXT("Expected: tempo.dblTempo == %d\n")
                TEXT("Returned: tempo.dblTempo == %d\n"),
                tempoexpected,(int)tempo.dblTempo);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 6) Stop the segment, check the results 
    // **********************************************************************

	// wait another half second - for absolutely no good reason
	Sleep(500);

	hr = pwPerformance->Stop(NULL, NULL, 0, 0);
	if(FAILED(hr))
	{
		fnsLog(FYILOGLEVEL, TEXT("**** FYI: Performance->Stop")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
	}

TEST_END:
    // **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pwSegment )
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetParam()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SetParam(). <nl>
//
// Test Function: <nl>
// tdmperfSetParamTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)  <nl>
// 4) Loader->EnableCache(GUID_DirectMusicAllTypes) <nl>
// 5) Load the Style Object <nl>
// 6) Load the ChordMap Object <nl>
// 7) Get the segment by calling ComposeSegmentFromShape <nl>
// 8) Create CtIDirectMusicPerformance object (wrapped IDirectMusicPerformance object) <nl>
// 9) Init the Performance <nl>
// 10) Add a port to the Performance (Synth port) <nl>
// 11) Activate the Performance <nl>
// 12) Play the Segment, check the results <nl>
// 13) Wait for IsPlaying to return favorably (or time out) <nl>
// 14) Get the start time of the segment, check results <nl>
// 15) Call SetParam, check the results <nl>
// 16) Stop the segment, check the results  <nl>
// 17) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfSetParamTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	MUSIC_TIME					mt				= NULL;
	GUID						guid			= GUID_TempoParam;
	MUSIC_TIME					pmtNext			= NULL;
	DMUS_TEMPO_PARAM			tempo;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, NULL );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime() to get the Start Time and check results
    // **********************************************************************
	hr = pwPerformance->GetTime( NULL, &mt );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// Check to make sure that mt is something other than 0
	if(!mt)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (MUSIC_TIME mt==%ul, expected Non-Zero.)"),
				mt);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) Call SetParam, check the results 
    // **********************************************************************
	hr = pwPerformance->SetParam( guid, 0xffffffff, 0, mt, (void*)&tempo ); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

	// **********************************************************************
    // 6) Stop the segment, check the results 
    // **********************************************************************
	Sleep(3000);
	hr = pwPerformance->Stop(NULL, NULL, 0, 0);
	if(FAILED(hr))
	{
		fnsLog(FYILOGLEVEL, TEXT("**** FYI: Performance->Stop")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if (pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if (pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}	// End SetParam() Test

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGlobalParam()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetGlobalParam(). <nl>
//
// Test Function: <nl>
// tdmperfGetGlobalParamTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetGlobalParam, check results<nl>
// 4) Call GetGlobalParam, check results (make sure dw and dw2 are equal) <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note - GetGlobalParam() and SetGlobalParam() both use the same test.
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetGlobalParamTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	GUID						guid			= CLSID_DirectMusicPerformance; // use this for a global data guid. arbitrary.;
	DWORD						dw				= 53;
	DWORD						dw2				= 0;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call SetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->SetGlobalParam( guid, (void*)&dw, sizeof(DWORD)); 
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->GetGlobalParam( guid, (void*)&dw2, sizeof(DWORD));
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
	// Check to make sure that the DWORD was properly populated
	if(dw != dw2)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam\n ")
                TEXT("pData was not properly populated\n")
                TEXT("Expected -- dw == %ld\n")
				TEXT("Received -- dw2 == %ld\n"),
				dw, dw2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
TEST_END:
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetGlobalParam()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SetGlobalParam(). <nl>
//
// Test Function: <nl>
// tdmperfGetGlobalParamTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetGlobalParam, check results<nl>
// 4) Call GetGlobalParam, check results (make sure dw and dw2 are equal) <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note - GetGlobalParam() and SetGlobalParam() both use the same test.
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
//!!!!!!  Test case removed (now uses GetGlobalParam() test) !!!!!!!!!!!!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetLatencyTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetLatencyTime(). <nl>
//
// Test Function: <nl>
// tdmperfGetLatencyTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call GetLatencyTime, check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
//	Note - GetGlobalParam() and SetGlobalParam() both use the same test.
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetLatencyTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	REFERENCE_TIME				rt				= 0;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetLatencyTime, check results
    // **********************************************************************
	hr = pwPerformance->GetLatencyTime(&rt);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetLatencyTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
    //  Check to make sure that REFERENCE_TIME pointer was populated
	if(!rt)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetLatencyTime ")
                TEXT("rt was not set correctly (rt == %08Xh)"), rt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUnitialize, Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetQueueTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetQueueTime(). <nl>
//
// Test Function: <nl>
// tdmperfGetQueueTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Initialize the performance <nl>
// 4) call GetQueueTime and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetQueueTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	REFERENCE_TIME					rt              = 0;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetQueueTime and check results
    // **********************************************************************
	hr = pwPerformance->GetQueueTime(&rt);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetQueueTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    //  Check to make sure that REFERENCE_TIME pointer was populated
	if(!rt)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetQueueTime ")
                TEXT("rt was not set correctly (rt == %08Xh)"), rt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AdjustTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::AdjustTime(). <nl>
//
// Test Function: <nl>
// tdmperfAdjustTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call Invalidate and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - Created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfAdjustTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call AdjustTime and check results
    // **********************************************************************
	hr = pwPerformance->AdjustTime( 1000 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AdjustTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 4) Release objects, dmthCoUnInitialize, and return results
    // **********************************************************************
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::CloseDown()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::CloseDown().
//
// Test Function: <nl>
// tdmperfCloseDownTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call CloseDown() and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/17/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfCloseDownTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;	
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call Closedown() and check results
    // **********************************************************************
	hr = pwPerformance->CloseDown();
	if(FAILED(hr))     
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->CloseDown ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return result
    // **********************************************************************
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	
	dmthCoUninitialize();	

	return dwRes;
}	// End IDirectMusicPerformance->CloseDown() Test


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicComposer::QueryInterface()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::QueryInterface().  QI's for
// IID_IDirectMusicPerformance.
//
// Test Function: <nl>
// tdmperfQueryInterfaceTest
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMCOMP.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped version of IDirectMusicComposer) <nl>
// 3) Call CtIDirectMusicComposer::QueryiInterface() to request an IID_IDirectMusicComposer 
// inteface object. <nl>
// 4) Cleanup objects, uninitialize COM, return test results <nl>
//
// History:
//  03/26/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfQueryInterfaceTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, 
						  LPARAM dwParam2)
{
	HRESULT						hRes				= E_NOTIMPL;
	DWORD						dwRes				= FNS_PASS;
	CtIDirectMusicPerformance	*pwPerformance      = NULL;
	IDirectMusicPerformance		*pPerformance		= NULL;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hRes = dmthCoInitialize(NULL);
    if(FAILED(hRes))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        fnsLog(ABORTLOGLEVEL, TEXT("**** Test case aborting."));
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusic object (wrapped version of IDirectMusic)
    // **********************************************************************
    hRes = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
    if(FAILED(hRes))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Base DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Call CtIDirectMusic::QueryiInterface() to request an IID_IDirectMusic 
    // inteface object.
    // **********************************************************************
    hRes = pwPerformance->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerformance);
    if(FAILED(hRes))
    {
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: QueryInterface(IID_IDirectMusicPerformance) failed! ")
                TEXT("(%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

TEST_END:
    // **********************************************************************
    // 4) Cleanup objects, uninitialize COM, Return test result
    // **********************************************************************
    if(pwPerformance)
    {
        pwPerformance->Release();
        pwPerformance = NULL;
    }
    if(pPerformance)
    {
        pPerformance->Release();
        pPerformance = NULL;
    }

    dmthCoUninitialize();

    return dwRes;

} 
 
//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetResolvedTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetResolvedTime().
//
// Test Function: <nl>
// tdmperfGetResolvedTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load a segment <nl>
// 4) PrePlay <nl>
// 5) Call GetResolvedTime and check results <nl>
// 6) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  07/31/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfGetResolvedTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	REFERENCE_TIME				rtResolved		= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(L"test.mid", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetResolvedTime and check results
    // **********************************************************************
	hr = pwPerformance->GetResolvedTime(2000, &rtResolved, DMUS_SEGF_BEAT);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetResolvedTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that dwSet and dwGet are the same
	if(!rtResolved)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetResolvedTime not set correctly, ")
                TEXT("rtResolved == %u)"), 
                rtResolved);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
TEST_END:
    // **********************************************************************
    // 6) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	// Clean up the wrapper
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RhythmToTime()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::RhythmToTime().
//		Compares RhythmToTime and TimeToRhythm using Style->GetTimeSig().
//
// Test Function: <nl>
// tdmperfRhythmToTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a Performance Object <nl>
// 3) Create a Composer Object <nl>
// 4) Load the media <nl>
// 5) Compose the segment <nl>
// 6) Set up the performance to play <nl>
// 7) Play the Segment <nl>
// 8) Get the current MUSIC_TIME <nl>
// 9) Get the current Time Signature <nl>
// 10)Call GetStartTime to get the start of the segment <nl>
// 11)Call TimeToRhythm <nl>
// 12)Call RhythmToTime and compare mtTime with mtTime2 <nl>
// 13)Clean up objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  11/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfRhythmToTimeTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicStyle			*pwStyle		= NULL;
	CtIDirectMusicChordMap		*pwChordMap		= NULL;
	CtIDirectMusicComposer		*pwComposer		= NULL;
	CtIDirectMusicSegmentState	*pwSegState		= NULL;

	MUSIC_TIME					mtTime			= 0;
	MUSIC_TIME					mtTime2			= 0;
	MUSIC_TIME					mtStartTime		= 0;
	WORD						wMeasure		= 0;
	BYTE						bBeat			= 0;
	BYTE						bGrid			= 0;
	SHORT						nOffset			= 0;
	DMUS_TIMESIGNATURE			TimeSig;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicComposer object (wrapped IDMComposer object)
    // **********************************************************************
	hr = dmthCreateComposer(IID_IDirectMusicComposer,&pwComposer);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Composer Object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Load the media
    // **********************************************************************
	hr = dmthLoadStyle(L"Jazz.sty", &pwStyle);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadStyle ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = dmthLoadChordMap(NULL, &pwChordMap);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadChordMap ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Compose the segment
    // **********************************************************************
	hr = pwComposer->ComposeSegmentFromShape(pwStyle, 8, DMUS_SHAPET_FALLING, 0, FALSE, FALSE, pwChordMap, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ComposeSegmentFromShape ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 6) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, &pwSegState);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->PlaySegment() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(2000);

    // **********************************************************************
    // 8) Get the current MusicTime
    // **********************************************************************
	hr = pwPerformance->GetTime(NULL, &mtTime);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Get the Time Signature
    // **********************************************************************
	hr = pwStyle->GetTimeSignature(&TimeSig);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicStyle->GetTimeSignature() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 10) Get the StartTime of the Segment
    // **********************************************************************
	hr = pwSegState->GetStartTime(&mtStartTime);
	if(FAILED(hr) || !mtStartTime)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicSegmentState->GetStartTime() ")
                TEXT("failed (%s == %08Xh), mtStartTime = %d"),
                tdmXlatHRESULT(hr), hr, mtStartTime);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	TimeSig.mtTime = mtStartTime;

    // **********************************************************************
    // 11) Now we'll call TimeToRhythm to populate the TimeSignature
    // **********************************************************************
	hr = pwPerformance->TimeToRhythm(mtTime, &TimeSig, &wMeasure, &bBeat, &bGrid, &nOffset);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  IDirectMusicPerformance->TimeToRhythm() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	fnsLog(FYILOGLEVEL, TEXT("FYI:  \nwMeasures==%d\nbBeat == %d\nbGrid == %d\nnOffset == %d"),
				wMeasure, bBeat, bGrid, nOffset);

	if(!wMeasure && !bBeat && !bGrid && !nOffset)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  TimeSignature was not set correctly")
				TEXT("wMeasure == %d\nbBeat == %d\nbGrid == %d\nnOffset == %d"),
				wMeasure, bBeat, bGrid, nOffset);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 12) Call RhythmToTime and check results
    // **********************************************************************
	hr = pwPerformance->RhythmToTime(wMeasure, bBeat, bGrid, nOffset, &TimeSig, &mtTime2);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  IDirectMusicPerformance->RhythmToTime() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if(mtTime != mtTime2)
	{
		fnsLog(BUGLOGLEVEL, TEXT("mtTime and mtTime2 are not equal\n ")
				TEXT("mtTime == %d\nmtTime2 == %d"),
				mtTime, mtTime2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 13) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthReleaseStyle(pwStyle);
	dmthReleaseChordMap(pwChordMap);
	dmthReleaseComposer(pwComposer);
	dmthReleaseSegmentState(pwSegState);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance2::QueryInterface()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::QueryInterface().  QI's for
// IID_IDirectMusicPerformance2.
//
// Test Function: <nl>
// tdmperf2QueryInterfaceTest
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMCOMP.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped version of IDirectMusicComposer) <nl>
// 3) Call CtIDirectMusicComposer::QueryiInterface() to request an IID_IDirectMusicComposer 
// inteface object. <nl>
// 4) Cleanup objects, uninitialize COM, return test results <nl>
//
// History:
//  03/26/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperf2QueryInterfaceTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, 
						  LPARAM dwParam2)
{
	HRESULT						hRes				= E_NOTIMPL;
	DWORD						dwRes				= FNS_PASS;
	CtIDirectMusicPerformance	*pwPerformance      = NULL;
	IDirectMusicPerformance		*pPerformance		= NULL;

	IUnknown					*pInterface			= NULL;
	IUnknown					*pIUnknown1			= NULL;
	IUnknown					*pIUnknown2			= NULL;
	GUID						*pIID				= (GUID *)dwParam2;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hRes = dmthCoInitialize(NULL);
    if(FAILED(hRes))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        fnsLog(ABORTLOGLEVEL, TEXT("**** Test case aborting."));
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusic object (wrapped version of IDirectMusic)
    // **********************************************************************
    hRes = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
    if(FAILED(hRes))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Base DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Call CtIDirectMusic::QueryiInterface() to request an IID_IDirectMusic 
    // inteface object.
    // **********************************************************************
    hRes = pwPerformance->QueryInterface(IID_IDirectMusicPerformance2, (void**)&pPerformance);
    if(FAILED(hRes))
    {
        fnsLog(BUGLOGLEVEL, TEXT("!!!! PENDING: QueryInterface(IID_IDirectMusicPerformance2) failed! ")
                TEXT("Do you have the right headers???"),
				TEXT("(%s == %08Xh)"),
                tdmXlatHRESULT(hRes), hRes);
        dwRes = FNS_PENDING;
        goto TEST_END;
    }

	// **********************************************************************
	// 4) QI the interface for the IID given to us.
    // **********************************************************************
	hRes = pPerformance->QueryInterface( *pIID, (void **)(&pInterface) );
    if ( FAILED(hRes) )
    {
        fnsLog( ABORTLOGLEVEL, "**** ABORT: pPerformance2::QI failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hRes), hRes);
        dwRes = FNS_ABORTED;
		goto TEST_END;
    }

    // **********************************************************************
	// 5) QI the newly obtained interface for IUnknown.
    // **********************************************************************
    fnsLog( FYILOGLEVEL, "---- FYI: QI'ing obtained interface for IUnknown " );
	hRes = pInterface->QueryInterface( IID_IUnknown, 
								(void **)(&pIUnknown1) );
    if ( FAILED(hRes) )
    {
        fnsLog( BUGLOGLEVEL, "!!!! BUG: IDMPerformance::QI for IUnknown failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hRes), hRes );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }

    // **********************************************************************
	// 5) QI the original IDMBand for IUnknown.
    // **********************************************************************
	hRes = pwPerformance->QueryInterface( IID_IUnknown, 
								(void **)(&pIUnknown2) );
    if ( FAILED(hRes) )
    {
        fnsLog( BUGLOGLEVEL, "!!!! BUG: pwPerformance::QI for IUnknown failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hRes), hRes );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }

    // **********************************************************************
	// 6) Compare their pointers.  Report a bug if they differ.
    // **********************************************************************
	if ( pIUnknown1 != pIUnknown2 )
	{
        fnsLog( BUGLOGLEVEL, "!!!! BUG: IUnknown pointers are different! "
			"(%s == %08Xh)", dmthXlatHRESULT(hRes), hRes );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }

TEST_END:
    // **********************************************************************
    // 4) Cleanup objects, uninitialize COM, Return test result
    // **********************************************************************
    if(pwPerformance)
    {
        pwPerformance->Release();
        pwPerformance = NULL;
    }
    if(pPerformance)
    {
        pPerformance->Release();
        pPerformance = NULL;
    }
	if ( pInterface )
	{
		pInterface->Release();
        pInterface = NULL;
	}

    dmthCoUninitialize();

    return dwRes;

} 
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\shlwapiLocal.cpp ===
//===========================================================================
// SHLWAPILOCAL.CPP
//
//  Because there are no good path functions in SHLWAPI, and because
//  that DLL isn't on Win95, and because we have to run our tests on Win95,
//  I have no choice but to copy that code in here and statically link it.
//
//===========================================================================
//#include "dmcs.h"
#include "globals.h"
#include "shlwapilocal.h"



#define TEXTW(quote) L##quote      

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

//danhaff - guessed this myself.
#define CH_WHACK TEXT('\\')

#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#define DBNotNULL(p)    (p)

void NearRootFixups (LPTSTR lpszPath, BOOL fUNC);

#define OFFSETOF(x)     ((UINT)(x))

/*
LPTSTR StrChr (LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

*/


/*
LPTSTR StrChr(LPTSTR lpsz, TCHAR ch)
{
    LPTSTR p = NULL;
    while (*lpsz)
    {
        if (*lpsz == ch)
        {
            p = lpsz;
            break;
        }
        lpsz = CharNext(lpsz);
    }
    return p;
}


BOOL ChrCmp(WORD w1, WORD wMatch)
{
  // Most of the time this won't match, so test it first for speed.
   //
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
        {
          return(w1 != wMatch);
        }
      return FALSE;
    }
  return TRUE;
}



LPSTR FAR PASCAL StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlen(lpStart);

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmp(*(WORD FAR *)lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}


LPCTSTR GetPCEnd(LPCTSTR lpszStart)
{
    LPCTSTR lpszEnd;

    lpszEnd = StrChr((char *)lpszStart, CH_WHACK);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }

    return lpszEnd;
}




//
// Given a pointer to the end of a path component, return a pointer to
// its begining.
// ie return a pointer to the previous backslash (or start of the string).
//
LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd)
{
    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, CH_WHACK);
    if (!lpszBegin)
    {
        lpszBegin = lpszStart;
    }
    return lpszBegin;
}





static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}


BOOL PathIsUNC(LPCTSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}

__inline BOOL PathIsUNC(
    LPWSTR psz)
{
    return (psz[0] == L'\\' && psz[1] == L'\\');
}




BOOL PathIsUNCServer(LPCTSTR pszPath)
{
    if (DBL_BSLASH(pszPath))
    {
        int i = 0;
        LPTSTR szTmp;

        for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = CharNext(szTmp) )
        {
            if (*szTmp==TEXT('\\'))
            {
                i++;
            }
        }

       return (i == 2);
    }

    return FALSE;
}



BOOL PathIsDirectory(LPCTSTR pszPath)
{
    DWORD dwAttribs;

    // SHELL32's PathIsDirectory also handles server/share
    // paths, but calls WNet APIs, which we cannot call.

    if (PathIsUNCServer(pszPath))
    {
        return FALSE;
    }
    else
    {
        dwAttribs = GetFileAttributes(pszPath);
        if (dwAttribs != (DWORD)-1)
            return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
    }

    return FALSE;
}















STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath)
{
//    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsRelative: caller passed bad lpszPath");

    if (!lpszPath || *lpszPath == 0)
    {
        // The NULL path is assumed relative
        return TRUE;
    }


    if (lpszPath[0] == CH_WHACK)
    {
        // Does it begin with a slash ?
        return FALSE;
    }
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':'))
    {
        // Does it begin with a drive and a colon ?
        return FALSE;
    }
    else
    {
        // Probably relative.
        return TRUE;
    }
}














STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath)
{

    if (lpszPath)
    {
        LPTSTR lpszEnd;

        // perf: avoid lstrlen call for guys who pass in ptr to end
        // of buffer (or rather, EOB - 1).
        // note that such callers need to check for overflow themselves.
        int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

        // try to keep us from tromping over MAX_PATH in size.
        // if we find these cases, return NULL.  Note: We need to
        // check those places that call us to handle their GP fault
        // if they try to use the NULL!
        if (ichPath >= (MAX_PATH - 1))
        {
            return(NULL);
        }

        lpszEnd = lpszPath + ichPath;

        // this is really an error, caller shouldn't pass
        // an empty string
        if (!*lpszPath)
            return lpszEnd;

        // Get the end of the source directory
        switch(*CharPrev(lpszPath, lpszEnd))
        {
            case CH_WHACK:
                break;

            default:
                *lpszEnd++ = CH_WHACK;
                *lpszEnd = TEXT('\0');
        }

        return lpszEnd;
    }

    return NULL;
}





STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot)
{
    if (szRoot)
    {
        while(!PathIsRoot(szRoot))
        {
            if (!PathRemoveFileSpec(szRoot))
            {
                // If we didn't strip anything off,
                // must be current drive
                return(FALSE);
            }
        }

        return(TRUE);
    }
    return(FALSE);
}







STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile)
{

    if (lpszDest && (lpszDir || lpszFile))
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR pszT;

        if (!lpszFile || *lpszFile==TEXT('\0'))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty
        }
        else if (lpszDir && *lpszDir && PathIsRelative(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                int iLen = lstrlen(szTemp);

                if ((iLen + lstrlen(lpszFile)) < ARRAYSIZE(szTemp))
                    lstrcpy(pszT, lpszFile);
                else
                    return NULL;
            }
            else
            {
                return NULL;
            }
        }
        else if (lpszDir && *lpszDir && *lpszFile == CH_WHACK && !PathIsUNC(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            // BUGBUG: Note that we do not check that an actual root is returned;
            // it is assumed that we are given valid parameters
            PathStripToRoot(szTemp);

            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                // Skip the backslash when copying
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                lstrcpyn(pszT, lpszFile+1, ARRAYSIZE(szTemp) - 1 - (int)(pszT-szTemp));
            }
            else
            {
                return NULL;
            }

        }
        else 
        {
            lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part
        }

        PathCanonicalize(lpszDest, szTemp); // this deals with .. and . stuff
    }

    return lpszDest;
}




STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath)
{

    if (!pPath || !*pPath)
    {
        return FALSE;
    }

    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, TEXT(":\\")))
        {
            // "X:\" case
            return TRUE;
        }
    }

    if ((*pPath == CH_WHACK) && (*(pPath + 1) == 0))
    {
        // "/" or "\" case
        return TRUE;
    }

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = FAST_CharNext(p))
        {
            if (*p == TEXT('\\') && (++cBackslashes > 1))
            {
               // not a bare UNC name, therefore not a root dir 
               return FALSE;
            }
        }
        return TRUE;    // end of string with only 1 more backslash 
                        // must be a bare UNC, which looks like a root dir 
    }
    return FALSE;
}




STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = FAST_CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}



//----------------------------------------------------------
Purpose: Canonicalize a path.

Returns:
Cond:    --
//
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc)
{
    LPCTSTR lpchSrc;
    LPCTSTR lpchPCEnd;      // Pointer to end of path component.
    LPTSTR lpchDst;
    BOOL fUNC;
    int cbPC;


    if (!lpszDst || !lpszSrc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //DEBUGWhackPathBuffer(lpszDst, MAX_PATH);
    
    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
    {
        // REVIEW: this should just return the count
        lpchPCEnd = GetPCEnd(lpchSrc);
        cbPC = (int) (lpchPCEnd - lpchSrc)+1;

        if (cbPC == 1 && *lpchSrc == CH_WHACK)                                      // Check for slashes.
        {
            // Just copy them.
            *lpchDst = CH_WHACK;
            lpchDst++;
            lpchSrc++;
        }
        else if (cbPC == 2 && *lpchSrc == TEXT('.'))                                // Check for dots.
        {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == TEXT('\0'))
            {
                lpchDst--;
                lpchSrc++;
            }
            else
            {
                lpchSrc += 2;
            }
        }
        else if (cbPC == 3 && *lpchSrc == TEXT('.') && *(lpchSrc + 1) == TEXT('.')) // Check for dot dot.
        {
            // make sure we aren't already at the root
            if (!PathIsRoot(lpszDst))
            {
                // Go up... Remove the previous path component.
                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1);
            }
            else
            {
                // When we can't back up, remove the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == CH_WHACK)
                {
                    lpchSrc++;
                }
            }

            // skip ".."
            lpchSrc += 2;       
        }
        else                                                                        // Everything else
        {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cbPC);
            lpchDst += cbPC - 1;
            lpchSrc += cbPC - 1;
        }

        // Keep everything nice and tidy.
        *lpchDst = TEXT('\0');
    }

    // Check for weirdo root directory stuff.
    NearRootFixups(lpszDst, fUNC);

    return TRUE;
}



//
// Fix up a few special cases so that things roughly make sense.
//
void NearRootFixups (LPTSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[0] = CH_WHACK;
        lpszPath[1] = TEXT('\0');
    }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':') && lpszPath[2] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[2] = TEXT('\\');
        lpszPath[3] = TEXT('\0');
    }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == TEXT('\\') && lpszPath[1] == TEXT('\0'))
    {
        // Fix up.
        //lpszPath[0] = TEXT('\\'); // already checked in if guard
        lpszPath[1] = TEXT('\\');
        lpszPath[2] = TEXT('\0');
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tdmperf8.cpp ===
//+-------------------------------------------------------------------------
//
//	Microsoft Windows
//
//	Copyright (C) Microsoft Corporation, 1998 - 1999
//
//	File:		tdmperf8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// tdmperf8.cpp
//
// Test case functions for IDirectMusicPerformance8 methods (unit parameters)
//
// Functions:
//	 tdmperf8ClonePMsg()
//	 tdmperf8CreateAudioPath()
//	 tdmperf8CreateStandardAudioPath()
//	 tdmperf8GetDefaultAudioPath()
//	 tdmperf8InitAudio()
//	 tdmperf8PlaySegmentEx()
//	 tdmperf8SetDefaultAudioPath()
//	 tdmperf8SetParamHook()
//	 tdmperf8StopEx()
//
// History:
//	01/27/2000 - kcraven  - created
//===========================================================================

#include "tdmusic.h"
#include "tdmperf.h"

#include "RecTake.h"

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::ClonePMsg()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::ClonePMsg()<nl>
//
// Test Function: <nl>
// tdmperf8ClonePMsg()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance<nl>
//  3) CoCreateLoader<nl>
//  4) Loader->GetObject(segment)<nl>
//  5) Performance->InitAudio<nl>
//  6) Performance->CreateStandardAudioPath<nl>
//  7) Create Test Tool<nl>
//  8) CoCreateGraph<nl>
//  9) Performance->SetGraph<nl>
//  10) Segment->SetParam(GUID_Download)<nl>
//  11) Performance->PlaySegmentEx<nl>
//  12) Wait for IsPlaying to be true<nl>
//  13) SegState->QueryInterface(IID_IDirectMusicGraph)<nl>
//  14) Performance->AllocPMsg<nl>
//  15) Set psg values<nl>
//  16) Performance->ClonePMsg<nl>
//  17) Compare Two PMsgs<nl>
//  18) Change cloned pmsg<nl>
//  19) Graph->StampPMsg(both)<nl>
//  20) Performance->SendPMsg(both)<nl>
//  21) Wait for IsPlaying to be false <nl>
//  22) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8ClonePMsg(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath		= NULL;
	CtIDirectMusicLoader*		pwLoader		= NULL;
	CtIDirectMusicSegment*		pwSegment		= NULL;
	CtIDirectMusicSegmentState* pwSegState		= NULL;
	CtIDirectMusicGraph*		pwGraph 		= NULL;
	IDirectMusicGraph*			pGraph			= NULL;

	DMUS_CURVE_PMSG* pCurve;
	DMUS_CURVE_PMSG* pClone;

	MUSIC_TIME mtTimeNow;
	REFERENCE_TIME rtTimeNow;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc; 

	MUSIC_TIME					mtLength;
	REFERENCE_TIME				rtLength;
	REFERENCE_TIME				rtMeasure;

	// gets intialized below
	int 						counter;
	int 						SleepTime;
	int 						iCheckPlaying; 

    CRecTake*					pTake			= NULL;

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader->GetObject(segment)
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
//	fnsIncrementIndent();
//	fnsLog(FYILOGLEVEL, TEXT("**** FYI: Loader->GetObject(pwSegment) ")
//				TEXT("returned (%s == %08Xh)"),
//				tdmXlatHRESULT(hr), hr);
//	fnsDecrementIndent();
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->InitAudio
	// **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,0,0,0,NULL); // don't create and audiopath 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Performance->CreateStandardAudioPath
	// **********************************************************************
	hr = pwPerformance->CreateStandardAudioPath(
		dwType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		TRUE,
		&pNewPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->CreateStandardAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pNewPath)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pNewPath is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Create Test Tool
	// **********************************************************************
	pTake = CRecTake::Create();
	if(!pTake)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pTake is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 8) CoCreateGraph
	// **********************************************************************
	hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Performance->SetGraph
	// **********************************************************************
	hr = pwPerformance->SetGraph(pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->SetGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 10) Segment->SetParam(GUID_Download)
	// **********************************************************************	
	hr = pwPerformance->GetRealObjPtr(&pPerformance);
	if (FAILED( hr ))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
				"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 11) Performance->PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,		// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		DMUS_SEGF_BEAT, // DMUS_SEGF_ flags.
		0,				// Time to start playback. 
		&pwSegState,	// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		pNewPath);		// Optional audioPath to play on. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 12) Wait for IsPlaying to be true
	// **********************************************************************
	// Set counter back to zero
	counter = 0;
	SleepTime = 20; // 20 msecs - very fast
	iCheckPlaying = 100; // check faster because we expect this be true almost immediately - time out after 2 seconds
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment (first Segment) timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//
	////////////////////////////////////////////////////////////////////////////////
	// length of song in reference time
//	hr = pwSegment->GetLength(&mtLength);
	//BUGBUG error check
//	hr = pwPerformance->MusicToReferenceTime(mtLength,&rtLength);
	//BUGBUG error check

	// time of measure in 1/10 nanoseconds divided by the number of times to check IsPlaying
//	iCheckPlaying = 10;
//	rtMeasure = rtLength / iCheckPlaying;

	// time of measure in milleseconds
//	REFERENCE_TIME rtTmp;
//	rtTmp = (rtMeasure / 10000) / 10000;
//	SleepTime = (int)(rtTmp);
//	iCheckPlaying += 2; // two extra times because IsPlaying may not be false until just a little after the segment actually stops
	////////////////////////////////////////////////////////////////////////////////
	//
	//
	////////////////////////////////////////////////////////////////////////////////

	// **********************************************************************
	// 13) SegState->QueryInterface(IID_IDirectMusicGraph)
	// **********************************************************************
	hr = pwSegState->QueryInterface(IID_IDirectMusicGraph,(void **) &pGraph);
	if(FAILED(hr) || !pGraph)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDMSegmentState::QueryInterface(IID_IDirectMusicGraph) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 14) Performance->AllocPMsg
	// **********************************************************************
	hr = pwPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pCurve );
	if(FAILED(hr) || !pCurve)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDMPerformance::AllocPMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	// fail from here on out
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 15) Set psg values
	// **********************************************************************
	pwPerformance->GetLatencyTime(&rtTimeNow);
	pwPerformance->ReferenceToMusicTime(rtTimeNow,&mtTimeNow);

	// Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
	pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;
	pCurve->mtTime = mtTimeNow; 	// about 4 beats from now.
	pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
	pCurve->dwVirtualTrackID = 0;	// This isn't a track, so default to 0.
	pCurve->dwType = DMUS_PMSGT_CURVE;
	pCurve->mtDuration = 768 * 4;		// Curve lasts two beats.
	pCurve->mtResetDuration = 0;	// No reset.
	pCurve->nStartValue = 0;		// ignored
	pCurve->nEndValue = 100;		// fade to full volume.
	pCurve->nResetValue = 0;		// No reset.
	pCurve->bType = DMUS_CURVET_CCCURVE;
	pCurve->bCurveShape = DMUS_CURVES_LINEAR;
	pCurve->bCCData = 7;		// MIDI Volume controller.
	// Set bFlags to indicatge that this is a curve that starts from the current playing value, not nStartValue.
	pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT; 
	pCurve->wParamType = 0; 	// This is for NRPN and RPN only.
	pCurve->wMergeIndex = 1;		// This will be added to the regular volume, not override it.
	pCurve->dwGroupID = -1; 	// Since this isn't a track, just say all groups.
	// **********************************************************************
	// 16) Performance->ClonePMsg
	// **********************************************************************
	hr = pwPerformance->ClonePMsg((DMUS_PMSG*)pCurve,(DMUS_PMSG**)&pClone);
	if(FAILED(hr) || !pClone)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::ClonePMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 17) Compare Two PMsgs
	// **********************************************************************
	hr = pTake->CompareTwoPMsgs((DMUS_PMSG*)pCurve,(DMUS_PMSG*)pClone);
	if(FAILED(hr) || (hr == S_FALSE))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: CRecTake::CompareTwoPMsgs failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 18) Change cloned pmsg
	// **********************************************************************
	//change cloned pmsg to fade out in stead of in
	pClone->mtTime += (768 * 8);	// 8 beats past the first pmsg.
	pClone->nEndValue = 0;			// fade out.
	// **********************************************************************
	// 19) Graph->StampPMsg(both)
	// **********************************************************************
	hr = pGraph->StampPMsg((DMUS_PMSG*)pCurve);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMToolGraph::StampPMsg(Curve) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pGraph->StampPMsg((DMUS_PMSG*)pClone);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMToolGraph::StampPMsg(Clone) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 20) Performance->SendPMsg(both)
	// **********************************************************************
	hr = pwPerformance->SendPMsg((DMUS_PMSG*)pCurve);
	if(FAILED(hr))
	{
		pwPerformance->FreePMsg((DMUS_PMSG*)pCurve);
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::SendPMsg(Curve) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->SendPMsg((DMUS_PMSG*)pClone);
	if(FAILED(hr))
	{
		pwPerformance->FreePMsg((DMUS_PMSG*)pClone);
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::SendPMsg(Clone) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 21) Wait for IsPlaying to be false 
	// **********************************************************************
	counter = 0;
	SleepTime = 1000; // once a second
	iCheckPlaying = 30; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::IsPlaying did not return false (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	// we got this far we must have passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 22) Cleanup objects and uninitialize and Return results
	// *********************************************************************

	delete pTake;

	if(pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pGraph)
	{
		pGraph->Release();
		pGraph = NULL;
	}
	if(pwGraph)
	{
		pwGraph->Release();
		pwGraph = NULL;
	}
	if(pNewPath)
	{
		pNewPath->Release();
		pNewPath = NULL;
	}
	if(pwSegState)
	{
		pwSegState->Release();
		pwSegState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::CreateAudioPath()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::CreateAudioPath(). <nl>
//
// Test Function: <nl>
// tdmperf8CreateAudioPath() <nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp <nl>
//
// Steps: <nl>
//	 1)   Initialize<nl>
//	 2.0) Create CtIDirectMusicLoader8 object <nl>
//	 2.1) SetSearchDirectory<nl>
//	 2.3) ScanDirectory<nl>
//	 3)   Get the AudioPath and Segment8<nl>
//	 4.0) Create CtIDirectMusicPerformance8 object <nl>
//	 4.1) Init the performance<nl>
//	 5.0) CreateAudioPath - the test method<nl>
//	 5.1) Verify the results - the path is not NULL<nl>
//	 5.2) Verify the results - at least one object<nl>
//		  that should be in the path is in the path<nl>
//	 5.3) varify the path - play something on the audio path<nl>
//	 5.4) Wait for IsPlaying to return true (or time out)<nl>
//	 6)   Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	03/02/2000 - kcraven - completed<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8CreateAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
//	CtIUnknown* 				pAudioPathConfig	= NULL;
	CtIDirectMusicObject*		pAudioPathConfig	= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	DMUS_OBJECTDESC 			desc;
	DMUS_PORTCAPS				caps;

	int 						counter 			= 0;
	int 						SleepTime			= 3000;
	int 						TimeOutValue		= 10;

	DWORD						dwIndex 			= 0;
	IDirectMusicPort*			pDMPort 			= NULL;

	WCHAR	wszAudioPath[]	=	L"Standard.aud";
	WCHAR	wszSegment[]	=	L"test.mid";
	dmthSetPath(NULL);
	WCHAR	*wchPath		= gwszBasePath;
	WCHAR	*wchFile		= gwszMediaPath;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.0) Create CtIDirectMusicLoader8 object
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicLoader object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.3) ScanDirectory
	// **********************************************************************
	hr = pwLoader8->ScanDirectory(CLSID_DirectMusicCollection, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(dls) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	hr = pwLoader8->ScanDirectory(CLSID_DirectMusicStyle, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(style) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3) Get the AudioPath and Segment8
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicAudioPathConfig;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,wszAudioPath);

	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicObject,(void **)&pAudioPathConfig);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pAudioPathConfig) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,wszSegment);

	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Create CtIDirectMusicPerformance8 object
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Init the performance
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		NULL,	// Can be NULL, pointer to NULL, or valid
		NULL,	// Can be NULL, pointer to NULL, or valid
		ghWnd,	// HWND for initializing DSound.
		0,		// Requested standard audio path or 0.
		0,		// Number of PChannels, if default audio path to be created.
		0,		// ?????? Not Sample rate for all ports and DSound sink
		NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) CreateAudioPath - the test method
	// **********************************************************************
	hr = pwPerformance8->CreateAudioPath(pAudioPathConfig,TRUE,&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.1) Verify the results - the path is not NULL
	// **********************************************************************
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.2) Verify the results - at least one object that should be in the path is in the path
	// **********************************************************************
	dwIndex = 0;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_PORT,
		0, //dwBuffer //BUGBUG - Index?
		GUID_All_Objects,dwIndex,IID_IDirectMusicPort,(void**)&pDMPort)))
	{
		// Go on to the next port in the audio path
		dwIndex++;

		if(pDMPort)
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s)"),dwIndex,tdmXlatHRESULT(hr));
			ZeroMemory(&caps, sizeof(DMUS_PORTCAPS));
			caps.dwSize = sizeof(DMUS_PORTCAPS);
			hr = pDMPort->GetCaps(&caps);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPort->GetCaps ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			}
			else
			{
				fnsIncrementIndent();
				tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL,&caps);
				fnsDecrementIndent();
			}
			// Release the port
			pDMPort->Release();
			pDMPort = NULL;
		}
		else
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT NOT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s) but pPort is NULL"),dwIndex,tdmXlatHRESULT(hr));
		}

	}
	if(FAILED(hr) && (DMUS_E_NOT_FOUND != hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.3) varify the path - play something on the audio path
	// **********************************************************************
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	hr = pwPerformance8->PlaySegmentEx(
		pwSegment8, 	// Segment to play. Alternately, could be an IDirectMusicSong.
		0,				// If song, which segment in the song.
		NULL,			// Optional template segment to compose transition with.
		NULL,			// DMUS_SEGF_ flags.
		0,				// Time to start playback.
		NULL,			// Returned Segment State.
		NULL,			// Optional segmentstate or audiopath to replace.
		pAudioPath);	// Optional audioPath to play on.
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.4) Wait for IsPlaying to return true (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	fnsIncrementIndent();
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: IsPlaying(true) Sleeping...\n"));
	fnsDecrementIndent();
	Sleep(2000);

TEST_END:
	// **********************************************************************
	// 6) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8 && pwSegment8)
	{
		pwSegment8->Unload(pwPerformance8); //we don't care if this fails at the moment
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pDMPort)
	{
		pDMPort->Release();
		pDMPort = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPathConfig)
	{
		pAudioPathConfig->Release();
		pAudioPathConfig = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::CreateStandardAudioPath()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::CreateStandardAudioPath().<nl>
//
// Test Function: <nl>
// tdmperf8CreateStandardAudioPath()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create CtIDirectMusicPerformance8 object<nl>
//	 3.0) Create CtIDirectMusicLoader object <nl>
//	 3.3) Get a Segment<nl>
//	 4) InitAudio the performance<nl>
//	 5) Call CreateStandardAudioPath - the function to be tested<nl>
//	 6.0.0) Verify the results - the audio path is no NULL<nl>
//	 6.1.0) Play the segment - Download the band<nl>
//	 6.1.1) PlaySegmentEx<nl>
//	 6.1.2) Wait for IsPlaying to return true (or time out)<nl>
//	 6.3) Verification - Get a known object (port) out of the audio path.<nl>
//	 6.4) Verification - Call QI for the same type object to Verify it's what we think it is<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	02/09/2000 - kcraven - added InitAudio<nl>
//	03/02/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8CreateStandardAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance8	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath		= NULL;
	CtIDirectMusicLoader		*pwLoader		= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;

	IUnknown*					pUnknown		= NULL;
	IUnknown*					pUnkQI			= NULL;
	DWORD						dwStage;
	GUID						guidObject;
	GUID						guidInterface;
	int 						index			= 0;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create CtIDirectMusicPerformance8 object
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create CtIDirectMusicLoader object
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.3) Get a Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
   
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
	fnsIncrementIndent();
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: Loader->GetObject(pwSegment) ")
				TEXT("returned (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
	fnsDecrementIndent();
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4) InitAudio the performance
	// **********************************************************************
	hr = pwPerformance8->InitAudio(NULL,NULL,ghWnd,0,0,0,0); // don't create and audiopath
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Call CreateStandardAudioPath - the function to be tested
	// **********************************************************************
	hr = pwPerformance8->CreateStandardAudioPath(
		dwType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		TRUE,
		&pNewPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateStandardAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.0.0) Verify the results - the audio path is no NULL
	// **********************************************************************
	if(!pNewPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pNewPath is NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.1.0) Play the segment - Download the band
	// **********************************************************************
	BOOL fAuto;
	fAuto = TRUE; // use true to regress autodownloading bug
//	fAuto = FALSE;
	if(fAuto)
	{
		hr = pwPerformance8->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
	else
	{
		hr = pwPerformance8->GetRealObjPtr(&pPerformance);
		if (FAILED( hr ))
		{
			fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
					"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
		hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 6.1.1) PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx(
		pwSegment,		// Segment to play. Alternately, could be an IDirectMusicSong.
		0,				// If song, which segment in the song.
		NULL,			// Optional template segment to compose transition with.
		DMUS_SEGF_BEAT, // DMUS_SEGF_ flags.
		0,				// Time to start playback.
		NULL,			// Returned Segment State.
		NULL,			// Optional segmentstate or audiopath to replace.
		pNewPath);		// Optional audioPath to play on.
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: ptPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.1.2) Wait for IsPlaying to return true (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	fnsIncrementIndent();
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: IsPlaying(true) Sleeping...\n"));
	fnsDecrementIndent();
	Sleep(2000);
	// **********************************************************************
	// 6.3) Verification - Get a known object (port) out of the audio path.
	// **********************************************************************
	dwStage 		= DMUS_PATH_PORT;
	guidObject		= CLSID_DirectMusicSynth; //GUID_NULL;
	guidInterface	= IID_IDirectMusicPort;
	index			= 0;
	hr = pNewPath->GetObjectInPath(
		DMUS_PCHANNEL_ALL,		//dwPChannel
		dwStage,				//dwStage
		0,
		guidObject, 			//guidObject
		index,					//dwIndex
		guidInterface,			//idInterface
		(void **)&pUnknown);	//pinterface
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.4) Verification - Call QI for the same type object to Verify it's what we think it is
	// **********************************************************************
	hr = pUnknown->QueryInterface(guidInterface, (void **)&pUnkQI);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IUnknown->QueryInterface ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(2000);

TEST_END:
	// **********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pUnknown)
	{
		pUnknown->Release();
		pUnknown = NULL;
	}
	if(pUnkQI)
	{
		pUnkQI->Release();
		pUnkQI = NULL;
	}
	if((!fAuto) && pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pNewPath)
	{
		pNewPath->Release();
		pNewPath = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::GetDefaultAudioPath()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::GetDefaultAudioPath().<nl>
//
// Test Function: <nl>
// tdmperf8GetDefaultAudioPath()
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create CtIDirectMusicPerformance8 object <nl>
//	 3.0) Create CtIDirectMusicLoader8 object <nl>
//	 3.1) Get a segment <nl>
//	 4) InitAudio the performance for a STANDARD MUSIC PATH<nl>
//	 5.0) Call GetDefaultAudioPath - the function to be tested<nl>
//	 5.1) Verify the results - AudioPath is not NULL<nl>
//	 6.0) Verify the results - Play a segment - Download<nl>
//	 6.1) Verify the results - Play a segment - PlaySegmentEx<nl>
//	 6.2) Verify the results - Wait for IsPlaying to return true (or time out)<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	03/02/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8GetDefaultAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
	DMUS_OBJECTDESC 			desc;
	DWORD						dwDefaultPathType	= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount 	= 8;
	DWORD						dwSampleRate		= 11025;
	int 						counter 			= 0;
	int 						SleepTime			= 3000;
	int 						TimeOutValue		= 10;

	dmthSetPath(L"test.mid");
	WCHAR	*wchFile	= gwszMediaPath;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create CtIDirectMusicPerformance8 object
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create CtIDirectMusicLoader8 object
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicLoader8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) Get a segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);

	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4) InitAudio the performance for a STANDARD MUSIC PATH
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		NULL,NULL,ghWnd,
		dwDefaultPathType,	// Requested standard audio path or 0.
		dwPChannelCount,	// Number of PChannels, if default audio path to be created.
		0,		//BUGBUG // Sample rate for all ports and DSound sink
		NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) Call GetDefaultAudioPath - the function to be tested
	// **********************************************************************
	hr = pwPerformance8->GetDefaultAudioPath(&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.1) Verify the results - AudioPath is not NULL
	// **********************************************************************
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.0) Verify the results - Play a segment - Download
	// **********************************************************************
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.1) Verify the results - Play a segment - PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx(
		pwSegment8, 				// Segment to play. Alternately, could be an IDirectMusicSong.
		0,NULL,NULL,0,NULL,NULL,	// Optional stuff all NULL
		pAudioPath);				// Optional audioPath to play on.
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6.2) Verify the results - Wait for IsPlaying to return true (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	Sleep(2000);

TEST_END:
	// **********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8 && pwSegment8)
	{
		pwSegment8->Unload(pwPerformance8); //we don't care if this fails at the moment
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::GetParamEx()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::GetParamEx()<nl>
//
// Test Function: <nl>
// tdmperf8GetParamEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance<nl>
//  3) CoCreateLoader<nl>
//  4) Loader->GetObject<nl>
//  5) Performance->InitAudio<nl>
//  6) Segment->SetParam(GUID_Download)<nl>
//  7) Performance->PlaySegmentEx<nl>
//  8) Wait for IsPlaying to be true<nl>
//  9) Performance->GetParamEx(GUID_TimeSignature)<nl>
//  10) Wait for IsPlaying to be false<nl>
//  11) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8GetParamEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath		= NULL;
	CtIDirectMusicLoader*		pwLoader		= NULL;
	CtIDirectMusicSegment*		pwSegment		= NULL;
	CtIDirectMusicSegmentState* pwSegState		= NULL;

	MUSIC_TIME mtTimeNow;
	REFERENCE_TIME rtTimeNow;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc; 
	DMUS_TIMESIGNATURE			timesig;

	// gets intialized below
	int 						counter;
	int 						SleepTime;
	int 						iCheckPlaying; 

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader->GetObject
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
//	fnsIncrementIndent();
//	fnsLog(FYILOGLEVEL, TEXT("**** FYI: Loader->GetObject(pwSegment) ")
//				TEXT("returned (%s == %08Xh)"),
//				tdmXlatHRESULT(hr), hr);
//	fnsDecrementIndent();
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->InitAudio
	// **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,dwType,dwPChannelCount,0,NULL); // create standard audiopath w/defaults 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Segment->SetParam(GUID_Download)
	// **********************************************************************	
	hr = pwPerformance->GetRealObjPtr(&pPerformance);
	if (FAILED( hr ))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
				"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Performance->PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,		// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		DMUS_SEGF_BEAT, // DMUS_SEGF_ flags.
		0,				// Time to start playback. 
		&pwSegState,	// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		NULL);		// Optional audioPath to play on. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 8) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 20; // 20 msecs - very fast
	iCheckPlaying = 100; // check faster because we expect this be true almost immediately - time out after 2 seconds
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment (first Segment) timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	// fail from here on out
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 9) Performance->GetParamEx(GUID_TimeSignature)
	// **********************************************************************
	/*
	typedef struct _DMUS_TIMESIGNATURE {
		MUSIC_TIME mtTime;
		BYTE  bBeatsPerMeasure;
		BYTE  bBeat;
		WORD  wGridsPerBeat;
	} DMUS_TIMESIGNATURE;
	*/
	ZeroMemory((void*)&timesig,sizeof(DMUS_TIMESIGNATURE));
	hr = pwPerformance->GetParamEx( 
							GUID_TimeSignature, 
							0,
							0xFFFFFFFF,
							0, 
							0,
							NULL,
							&timesig
	);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->GetParamEx(time sig) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("        DMUS_TIMESIGNATURE :"));
	fnsLog(FYILOGLEVEL, TEXT("        ntTime             : %016X"), timesig.mtTime);
	fnsLog(FYILOGLEVEL, TEXT("        bBeatsPerMeasure   : %d"), timesig.bBeatsPerMeasure);
	fnsLog(FYILOGLEVEL, TEXT("        bBeat              : %d"), timesig.bBeat);
	fnsLog(FYILOGLEVEL, TEXT("        wGridsPerBeat      : %d"), timesig.wGridsPerBeat);
	// **********************************************************************
	// 10) Wait for IsPlaying to be false
	// **********************************************************************
	counter = 0;
	SleepTime = 1000; // once a second
	iCheckPlaying = 30; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::IsPlaying did not return false (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	// we got this far we must have passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 11) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegState)
	{
		pwSegState->Release();
		pwSegState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::InitAudio()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::InitAudio()<nl>
//
// Test Function: <nl>
// tdmperf8InitAudio()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance<nl>
//  3) Performance8->InitAudio<nl>
//  4) Performance8->GetDefaultAudioPath<nl>
//  5) AudioPath->GetObjectInPath(ports)<nl>
//  6) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	02/02/2000 - kcraven - add test code<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8InitAudio(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	CtIDirectMusic* 			pwMusic 			= NULL;
	DWORD						dwDefaultPathType	= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount 	= 16;

	DWORD						dwIndex 			= 0;
	IDirectMusicPort*			pDMPort 			= NULL;
	DMUS_PORTCAPS				caps;

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 3) Performance8->InitAudio
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		&pwMusic,			// Can be NULL, pointer to NULL, or valid
		NULL,				// Can be NULL, pointer to NULL, or valid
		ghWnd,				// HWND for initializing DSound.
		dwDefaultPathType,	// Requested standard audio path or 0.
		dwPChannelCount,	// Number of PChannels, if default audio path to be created.
		0,					// Sample rate for all ports and DSound sink
		NULL);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwMusic)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwMusic is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Performance8->GetDefaultAudioPath
	// **********************************************************************
	hr = pwPerformance8->GetDefaultAudioPath(&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) AudioPath->GetObjectInPath(ports)
	// **********************************************************************
	// get all the port there are - just for the heck of it - if the path is good this should not fail
	dwIndex = 0;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_PORT,0,GUID_All_Objects,dwIndex,IID_IDirectMusicPort,(void**)&pDMPort)))
	{
		// Go on to the next port in the audio path
		dwIndex++;
		if(pDMPort)
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s)"),dwIndex,tdmXlatHRESULT(hr));
			ZeroMemory(&caps, sizeof(DMUS_PORTCAPS));
			caps.dwSize = sizeof(DMUS_PORTCAPS);
			hr = pDMPort->GetCaps(&caps);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPort->GetCaps ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			}
			else
			{
				fnsIncrementIndent();
				tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL,&caps);
				fnsDecrementIndent();
			}
			// Release the port
			pDMPort->Release();
			pDMPort = NULL;
		}
		else
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT NOT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s) but pPort is NULL"),dwIndex,tdmXlatHRESULT(hr));
		}

	}
	if(FAILED(hr) && (DMUS_E_NOT_FOUND != hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 6) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	if(pDMPort)
	{
		pDMPort->Release();
		pDMPort = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::PlaySegmentEx()<nl>
//
// Test Function: <nl>
// tdmperf8PlaySegmentEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	02/02/2000 - kcraven - add test<nl>
//	03/02/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8PlaySegmentEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT 					hr				= S_OK;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;

	CtIDirectMusicLoader		*pwLoader		= NULL;
	CtIDirectMusicPerformance8	*ptPerformance	= NULL;
	IDirectMusicPerformance8	*pPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;

	DMUS_OBJECTDESC 			desc;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &ptPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,pMidiFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************
	hr = ptPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ptPerformance->Init(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Add the Port
	// **********************************************************************
	hr = ptPerformance->AddPort( NULL );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ptPerformance->AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************
	BOOL fAuto;
	fAuto = TRUE;  // autodl doesn't work with audiopaths -- should work here
//	  fAuto = FALSE;
	if(fAuto)
	{
		hr = ptPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
	else
	{
		hr = ptPerformance->GetRealObjPtr(&pPerformance);
		if (FAILED( hr ))
		{
			fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
					"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
		hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object - no need to release - no addref done
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	hr = ptPerformance->PlaySegmentEx(
		pwSegment,			// Segment to play
		0,NULL, 			// Optional stuff NULL.
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff is NULL.
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAIL: ptPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = ptPerformance->IsPlaying(pwSegment, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! FAIL: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
//	fnsIncrementIndent();
//	fnsLog(FYILOGLEVEL, TEXT("**** FYI: IsPlaying(true) Sleeping...\n"));
//	fnsDecrementIndent();
	Sleep(2000);

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(ptPerformance)
	{
		ptPerformance->CloseDown();
		ptPerformance->Release();
		ptPerformance = NULL;
	}
	if(pwSegment)
	{
		if((!fAuto) && pPerformance)
		{
			pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't case about the return code at this point
		}
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::SetDefaultAudioPath()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::SetDefaultAudioPath()<nl>
//
// Test Function: <nl>
// tdmperf8SetDefaultAudioPath()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//	 1)   Initialize<nl>
//	 2.0) Create Loader<nl>
//	 2.1) Get the Segment<nl>
//	 2.2) Get the AudioPath<nl>
//	 3.0) Create CtIDirectMusicPerformance8 object <nl>
//	 3.1) InitAudio the performance witha standard audio path that plays silent<nl>
//	 4.0) Create an AudioPath from the audiopathconfig file to be set later<nl>
//	 4.1) Verify the results<nl>
//	 5.0) Play the segment - Download<nl>
//	 5.1) PlaySegmentEx<nl>
//	 5.2) Verify silent playback - Wait for IsPlaying - NO SOUND EXPECTED<nl>
//	 5.3) Quickly unload - if there had been sound (bug) it should stop <nl>
//	 6)   Call SetDefaultAudioPath - the function to be tested<nl>
//	 7.0) Verification - Play a segment - Download<nl>
//	 7.1) Verification - PlaySegmentEx<nl>
//	 7.2) Verification - Wait for IsPlaying - should make sound this time<nl>
//	 8)   Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	03/02/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8SetDefaultAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
	CtIUnknown* 				pAudioPathConfig	= NULL;
//	CtIDirectMusicObject*		pAudioPathConfig	= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	DMUS_OBJECTDESC 			desc;

	int 						counter 			= 0;
	int 						SleepTime			= 3000;
	int 						TimeOutValue		= 10;

	WCHAR						pMidiFile[] 		= L"test.mid";
	WCHAR						pAudPathFile[]		= L"StandardReverbShared.aud";

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.1) Get the Segment with fullpath
	// **********************************************************************
	dmthSetPath(pMidiFile);
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,gwszMediaPath);
	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2.2) Get the AudioPath wih fullpath
	// **********************************************************************
	dmthSetPath(pAudPathFile);
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicAudioPathConfig;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,gwszMediaPath);
	// can be IID_IUnknown or IID_IDirectMusicObject
	hr = pwLoader8->GetObject(&desc,CTIID_IUnknown,(void **)&pAudioPathConfig);
//	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicObject,(void **)&pAudioPathConfig);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pAudioPathConfig) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create CtIDirectMusicPerformance8 object
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) InitAudio the performance witha standard audio path that plays silent
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		NULL,NULL,ghWnd,
		DMUS_APATH_DYNAMIC_MONO, // Requested standard audio path or 0.
		64, 							// Number of PChannels
		0,							// Sample rate
		NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Create an AudioPath from the audiopathconfig file to be set later
	// **********************************************************************
	hr = pwPerformance8->CreateAudioPath(pAudioPathConfig,TRUE,&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Verify the results
	// **********************************************************************
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) Play the segment - Download
	// **********************************************************************
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.1) PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx(
		pwSegment8, 		// Segment to play
		0,NULL, 			// Optional stuff NULL
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff NULL - use default audiopath
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAIL: ptPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.2) Verify silent playback - Wait for IsPlaying - NO SOUND EXPECTED
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! FAIL: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) == S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! FAIL: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 5.3) Quickly unload - if there had been sound (bug) it should stop
	// **********************************************************************
	hr = pwSegment8->Unload(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Unload ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Call SetDefaultAudioPath - the function to be tested<nl>
	// **********************************************************************
	hr = pwPerformance8->SetDefaultAudioPath(pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->SetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 7.0) Verification - Play a segment - Download
	// **********************************************************************
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 7.1) Verification - PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx(
		pwSegment8, 		// Segment to play
		0,NULL, 			// Optional stuff NULL
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff NULL - use default audio path
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAIL: ptPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 7.2) Verification - Wait for IsPlaying - should make sound this time
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! FAIL: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) == S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! FAIL: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}

TEST_END:
	// **********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwSegment8 && pwPerformance8)
	{
		pwSegment8->Unload(pwPerformance8); // don't care about return code
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPathConfig)
	{
		pAudioPathConfig->Release();
		pAudioPathConfig = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::SetParamHook()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::SetParamHook()<nl>
//
// Test Function: <nl>
// tdmperf8SetParamHook()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
// 1) Initialize <nl>
// 2) Clean up Objects, uninitialize, and return results <nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
/*
//PHOOPHOO
DWORD tdmperf8SetParamHook(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT 					hr				= S_OK;

	dmthSetPath(NULL);
	WCHAR	*wchPath	= gwszBasePath;
	WCHAR	*wchFile	= gwszMediaPath;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	fnsLog(ABORTLOGLEVEL,
		TEXT("**** PENDING: IDirectMusicPerformance8::SetParamHook() Test is not implemented."));
	dwRes = FNS_PENDING;

TEST_END:
	// **********************************************************************
	// 18) Cleanup objects and uninitialize and Return results
	// *********************************************************************

	dmthCoUninitialize();
	return dwRes;
}
*/




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::StopEx()_Unit_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance8::StopEx()<nl>
//
// Test Function: <nl>
// tdmperf8StopEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperf8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create a Performance8<nl>
//	 3.0) Create a Loader<nl>
//	 3.1) Get the Segment object with fullpath<nl>
//	 4.0) Init the Performance8 as level 1<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Turn on AutoDownload<nl>
//	 5.0) Play the segment - PlaySegmentEx<nl>
//	 5.1) Wait for IsPlaying to return true (or time out)<nl>
//	 6) Call StopEx - the method we are testing<nl>
//	 7) Verification - Wait for IsPlaying to return false (or time out)<nl>
//	 8) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	01/27/2000 - kcraven - created<nl>
//	02/02/2000 - kcraven - add test<nl>
//	03/02/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperf8StopEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT 					hr				= S_OK;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
//	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusicLoader		*pwLoader		= NULL;
	CtIDirectMusicPerformance8	*pwPerformance8 = NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;

	DMUS_OBJECTDESC 			desc;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create a Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create a Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) Get the Segment object with fullpath
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance8 as level 1
	// **********************************************************************
	hr = pwPerformance8->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance8->Init(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Add the default Port
	// **********************************************************************
	hr = pwPerformance8->AddPort( NULL );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance8->AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Turn on AutoDownload
	// **********************************************************************
	BOOL fAuto;
	fAuto = TRUE;
	hr = pwPerformance8->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance8->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) Play the segment - PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx(pwSegment,0,NULL,DMUS_SEGF_BEAT,0,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: Performance8->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5.1) Wait for IsPlaying to return true (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment, NULL)) != S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: PlaySegment() timed out\n")
				TEXT("Segment did not start playing in the time speciied (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
	Sleep(1000);
	// **********************************************************************
	// 6) Call StopEx - the method we are testing
	// **********************************************************************
	hr = pwPerformance8->StopEx(
		pwSegment,			// Segstate, AudioPath, Segment, or Song to stop.
		0,					// Optional time.
		DMUS_SEGF_MEASURE); // Standard SEGF flags for setting time.
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** BUG: Performance8->StopEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Verification - Wait for IsPlaying to return false (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment, NULL)) == S_OK)
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("**** BUG: Performance8->IsPlaying() is true\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}

TEST_END:
	// *********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}

	dmthCoUninitialize();
	return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tests.h ===
#pragma once

HRESULT SampleTest                              (void);
HRESULT AudioPath_Activate                      (CtIDirectMusicPerformance8* ptPerf8);
HRESULT AudioPath_GetObjectInPath               (CtIDirectMusicPerformance8* ptPerf8);
HRESULT AudioPath_SetVolume                     (CtIDirectMusicPerformance8* ptPerf8);

HRESULT Performance8_AddNotificationType        (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_AllocPMsg                  (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_CloseDown                  (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_CreateStandardAudioPath    (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_SendPMsg                   (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_FreePMsg                   (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetGlobalParam             (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetNotificationPMsg        (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetSegmentState            (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_GetTime                    (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_IsPlaying                  (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_InitAudio                  (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_PlaySegmentEx              (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_Release                    (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_RemoveNotificationType     (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_SetGlobalParam             (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_StopEx                     (CtIDirectMusicPerformance8* ptPerf8);

HRESULT Segment8_Download                       (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Segment8_SetRepeats                     (CtIDirectMusicPerformance8* ptPerf8);
HRESULT Segment8_Unload                         (CtIDirectMusicPerformance8* ptPerf8);

HRESULT SegmentState8_GetObjectInPath           (CtIDirectMusicPerformance8* ptPerf8);


HRESULT Script_Init                             (CtIDirectMusicPerformance8* ptPerf8);                                                              
HRESULT Script_CallRoutine                      (CtIDirectMusicPerformance8* ptPerf8);                                                     
HRESULT Script_SetVariableNumber                (CtIDirectMusicPerformance8* ptPerf8);                                                 
HRESULT Script_GetVariableNumber                (CtIDirectMusicPerformance8* ptPerf8);                                               
HRESULT Script_SetVariableObject                (CtIDirectMusicPerformance8* ptPerf8);                                                        
HRESULT Script_GetVariableObject                (CtIDirectMusicPerformance8* ptPerf8);

HRESULT Loader_CollectGarbage                   (CtIDirectMusicPerformance8* ptPerf8);


HRESULT AudioPath_SetVolume_Invalid(CtIDirectMusicPerformance8* ptPerf8);
HRESULT Performance8_IsPlaying_Invalid(CtIDirectMusicPerformance8* ptPerf8);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tdmperv8.cpp ===
//+-------------------------------------------------------------------------
//
//	Microsoft Windows
//
//	Copyright (C) Microsoft Corporation, 1998 - 1999
//
//	File:		tdmperv8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// tdmperv8.cpp 
//
// Test case functions for IDirectMusicPerformance8 methods (valid parameters)
//
// Functions:
//	 tdmperv8ClonePMsg()
//	 tdmperv8CreateAudioPath()
//	 tdmperv8CreateStandardAudioPath()
//	 tdmperv8GetDefaultAudioPath()
//	 tdmperv8InitAudio()
//	 tdmperv8PlaySegmentEx()
//	 tdmperv8SetDefaultAudioPath()
//	 tdmperv8SetParamHook()
//	 tdmperv8StopEx()
//
// History:
//	01/27/2000 - kcraven  - created
//  08/29/2000 - danhaff - Removed instances of DYNAMIC_APATH_ENV3D
//===========================================================================

#include "tdmusic.h"
#include "tdmperf.h"
//PHOOPHOO
//#include "tdmhook.h"

#include <RecTool.h>
#include <factory.h>
#include <limits.h>
#include "RecTake.h"

#include "tdmapthHelpDefs.h"

BOOL HasDSOne(CtIDirectMusic* pMusic);
BOOL HasDSOne(CtIDirectMusic* pMusic)
{
	HRESULT hr = S_OK;
	DMUS_PORTCAPS portcaps;
	int index;

	if (pMusic)
	{
		for(index = 0;;index++)
		{
			ZeroMemory(&portcaps, sizeof(DMUS_PORTCAPS));
			portcaps.dwSize = sizeof(DMUS_PORTCAPS);
			hr = pMusic->EnumPort(index,&portcaps);
			if(SUCCEEDED(hr) && hr != S_FALSE)
			{
				if(DMUS_PC_OUTPUTCLASS == portcaps.dwClass)
				{
					if(portcaps.dwFlags & DMUS_PC_DLS)
					{
						if((
							!(portcaps.dwFlags & DMUS_PC_SOFTWARESYNTH)) &&
							(DMUS_PORT_KERNEL_MODE == portcaps.dwType) &&
							!wcscmp(portcaps.wszDescription,L"Yamaha DMusic"))
						{
							return TRUE;
						}
					}
				}
			}
			else
			{
				break;
			}
		}
	}
	return FALSE;
}

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::AddNotificationType()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::AddNotificationType(). <nl>
//
// Test Function: <nl>
// tdmperv8AddNotificationTypeValidTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : tdmperv8.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType(All Types) and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - created <nl>
//  06/08/2000 - kcraven - convrted to dx8 <nl>
//
//
// @index topic | IDIRECTMUSICPERFORMANCE8_CASES
//--------------------------------------------------------------------------;
DWORD tdmperv8AddNotificationTypeValidTest(BOOL fCoCreate, 
											BOOL fMaxDebug, 
											LPARAM dwParam1, 
											LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	DMUS_NOTIFICATION_PMSG		*pEvent				= NULL;
	CtIDirectMusicPerformance8	*pwPerformance		= NULL;
	CtIDirectMusicLoader8		*pwLoader			= NULL;
	CtIDirectMusicSegment8		*pwSegment			= NULL;

	HANDLE						hNotification;
	DWORD						dwResult;

	GUID						*guidNotification	= (GUID*)dwParam1;
	WCHAR						*pMidiFile			= (WCHAR*)dwParam2;
    char                        szGuid[MAX_LOGSTRING];

	if (pMidiFile == NULL)
	{
		pMidiFile = L"test.mid";
	}	
	dmthSetPath(pMidiFile);
	char						*chPath			= gszMediaPath;
	WCHAR						*wchPath		= gwszBasePath;
	LPWSTR                      wszFilename     = pMidiFile; 

	int							counter			= 0;
	int							SleepTime		= 1000;
	int							TimeOutValue	= 10;
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }
    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // **********************************************************************
    // 3) Create an Event for hNotification
    // **********************************************************************
	hNotification = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotification )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Unable to Create an hNotificationEvent \n")
		    TEXT("(%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Create an Event for hNotification and check results
	// *********************************************************************
    hr = pwPerformance->SetNotificationHandle( hNotification, 0 );
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->SetNotificationHandle  ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5) AddNotificationType and check results 
	// **********************************************************************
    hr = pwPerformance->AddNotificationType(*guidNotification);
	if(FAILED(hr))
	{
	    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->AddNotificationType ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
    // 1) Create CtIDirectMusicLoader object (wrapped IDirectMusicLoader object)
    // **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        goto TEST_END;
	}
	// **********************************************************************
    // 3.1) SetSearchDirectory
    // **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
    // 4) Get the Segment object
    // **********************************************************************
	DMUS_OBJECTDESC desc; 
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	MultiByteToWideChar(CP_ACP, NULL, (LPCSTR)chPath, -1, desc.wszFileName, DMUS_MAX_FILENAME);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment);
	if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
        goto TEST_END;
    }

    // **********************************************************************
    // 6) Add the Port
    // **********************************************************************	
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,DMUS_APATH_SHARED_STEREOPLUSREVERB,64,NULL,NULL);
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CtIDirectMusicBase creation ")
	            TEXT("failed (%s == %08Xh)"),
	            tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
    // set autodownload on
	// **********************************************************************
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
    // set autodownload on
	// **********************************************************************
//	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT, 0,NULL);
	hr = pwPerformance->PlaySegmentEx(pwSegment,0,NULL,DMUS_SEGF_QUEUE,0,NULL,NULL,NULL); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    // **********************************************************************
    // 10) Wait for IsPlaying to return favorably (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** FYI: PlaySegment() timed out\n")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
   	// **********************************************************************
    // 7) Wait for a single object to know that things should be fine
    // **********************************************************************
	dwResult = WaitForSingleObject( hNotification, 10000 );
	if( dwResult != WAIT_OBJECT_0 )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: WaitForSingleObject ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
    // 8) Call GetNotificationPMsg and check results
    // **********************************************************************
	hr = pwPerformance->GetNotificationPMsg(&pEvent);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if(!pEvent)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("pEvent was not set"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
    //**********************************************************************
    // Validate the Members of the PMsg
    //**********************************************************************
    fnsLog(FYILOGLEVEL,"!!!! FYI: pEvent->dwSize = %d",pEvent->dwSize);
    if (pEvent->dwSize != sizeof(DMUS_NOTIFICATION_PMSG))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pEvent->dwSize incorrect.");
        fnsLog(BUGLOGLEVEL, "           Is: %d", pEvent->dwSize);
        fnsLog(BUGLOGLEVEL, "    Should be: %d", sizeof(DMUS_NOTIFICATION_PMSG));
		dwRes = FNS_FAIL;
		goto TEST_END;
    }
    //guidNotificationType
    dmthGUIDtoString(pEvent->guidNotificationType, szGuid);
    fnsLog(FYILOGLEVEL,"!!!! FYI: pEvent->guidNotificationType = %s (%s)",
        szGuid, dmthXlatGUID(pEvent->guidNotificationType));
    if (pEvent->guidNotificationType != (*guidNotification))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pEvent->guidNotificationType incorrect.");
        fnsLog(BUGLOGLEVEL, "           Is: %s (%s)",
                pEvent->guidNotificationType, 
                szGuid);
        fnsLog(BUGLOGLEVEL, "    Should be: %s (%s)",
                pEvent->guidNotificationType,
                dmthXlatGUID(*guidNotification));
		dwRes = FNS_FAIL;
		goto TEST_END;
    }
    // **********************************************************************
    // 9) Call FreePMsg and check results
    // **********************************************************************
    hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->FreePMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(1000);
		
TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
        if (pEvent)
        {
        	pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
        }

        pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(hNotification)
	{
		CloseHandle(hNotification);
		hNotification = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::ClonePMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::ClonePMsg()<nl>
//
// Test Function: <nl>
// tdmperv8ClonePMsg()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance <nl>
//  3) CoCreateLoader<nl>
//  4) Loader->GetObject(Segment)<nl>
//  5) Performance->InitAudio<nl>
//  6) Performance->CreateStandardAudioPath<nl>
//  7) Create Test Tool<nl>
//  8) CoCreateGraph<nl>
//  9) Performance->SetGraph<nl>
//  10) Segment->SetParam(GUID_Download)<nl>
//  11) Performance->AllocPMsg<nl>
//  12) Set PMsg values<nl>
//  13) Performance->ClonePMsg<nl>
//  14) Compare PMsgs<nl>
//  15) Change cloned pmsg<nl>
//  16) Performance->PlaySegmentEx<nl>
//  17) Performance->GetLatencyTime<nl>
//  18) Performance->ReferenceToMusicTime<nl>
//  19) SegState->QueryInterface(IID_IDirectMusicGraph<nl>
//  20) Graph->StampPMsgs<nl>
//  21) Wait for IsPlaying to be true<nl>
//  22) Performance->SendPMsg(both)<nl>
//  23) Wait for IsPlaying to be false<nl>
//  24) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//	04/18/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8ClonePMsg(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath		= NULL;
	CtIDirectMusicLoader*		pwLoader		= NULL;
	CtIDirectMusicSegment*		pwSegment		= NULL;
	CtIDirectMusicSegmentState* pwSegState		= NULL;
	CtIDirectMusicGraph*		pwGraph 		= NULL;
	IDirectMusicGraph*			pGraph			= NULL;

	DWORD						dwPMsgType		= dwParam1;
	DWORD						dwPMsgFlags		= dwParam2;			// additional flags to set	
	ULONG 						ulPMsgSize;

	// generic pointer
	DMUS_PMSG**					ppPMsg;
	DMUS_PMSG**					ppPMsgClone;

//	DMUS_PMSG*					pBase;
//	DMUS_PMSG*					pBaseClone;
//	DMUS_CHANNEL_PRIORITY_PMSG*	pChanPri;
//	DMUS_CHANNEL_PRIORITY_PMSG*	pChanPriClone;
	DMUS_CURVE_PMSG*			pCurve;
	DMUS_CURVE_PMSG*			pCurveClone;
	DMUS_MIDI_PMSG*				pMidi;
	DMUS_MIDI_PMSG*				pMidiClone;
	DMUS_NOTE_PMSG*				pNote;
	DMUS_NOTE_PMSG*				pNoteClone;
//	DMUS_NOTIFICATION_PMSG*		pNotify;
//	DMUS_NOTIFICATION_PMSG*		pNotifyClone;
	DMUS_PATCH_PMSG*			pPatch;
	DMUS_PATCH_PMSG*			pPatchClone;
//	DMUS_SYSEX_PMSG*			pSysex;
//	DMUS_SYSEX_PMSG*			pSysexClone;
	DMUS_TEMPO_PMSG*			pTempo;
	DMUS_TEMPO_PMSG*			pTempoClone;
//	DMUS_TIMESIG_PMSG*			pTimeSig;
//	DMUS_TIMESIG_PMSG*			pTimeSigClone;
	DMUS_TRANSPOSE_PMSG*		pTrans;
	DMUS_TRANSPOSE_PMSG*		pTransClone;

	/*
	struct
	{
		WORD octave : 4;
		WORD chord : 4;
		WORD scale : 4;
		WORD accident : 4;
	} wMusicValue;

	wMusicValue.octave = 0;
	wMusicValue.chord = 0;
	wMusicValue.scale = 0;
	wMusicValue.accident = 0;
	*/

	MUSIC_TIME					mtTimeNow;
	REFERENCE_TIME				rtTimeNow;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc; 

//	MUSIC_TIME					mtLength;
//	REFERENCE_TIME				rtLength;
//	REFERENCE_TIME				rtMeasure;
//	REFERENCE_TIME				rtTmp;

	// gets intialized below
	int 						counter;
	int 						SleepTime;
	int 						iCheckPlaying; 

    CRecTake*					pTake			= NULL;

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader->GetObject(Segment)
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
//	fnsIncrementIndent();
//	fnsLog(FYILOGLEVEL, TEXT("**** FYI: Loader->GetObject(pwSegment) ")
//				TEXT("returned (%s == %08Xh)"),
//				tdmXlatHRESULT(hr), hr);
//	fnsDecrementIndent();
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->InitAudio
	// **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,0,0,0,NULL); // don't create and audiopath 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Performance->CreateStandardAudioPath
	// **********************************************************************
	hr = pwPerformance->CreateStandardAudioPath(
		dwType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		TRUE,
		&pNewPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->CreateStandardAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pNewPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pNewPath is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Create Test Tool
	// **********************************************************************
	pTake = CRecTake::Create();
	if(!pTake)
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pTake is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 8) CoCreateGraph
	// **********************************************************************
	hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Performance->SetGraph
	// **********************************************************************
	hr = pwPerformance->SetGraph(pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->SetGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 10) Segment->SetParam(GUID_Download)
	// **********************************************************************	
	hr = pwPerformance->GetRealObjPtr(&pPerformance);
	if (FAILED( hr ))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
				"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 11) Performance->AllocPMsg
	// **********************************************************************
	switch(dwPMsgType)
	{
	case DMUS_PMSGT_CURVE:
		ulPMsgSize = sizeof(DMUS_CURVE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pCurve;
		ppPMsgClone = (DMUS_PMSG**)&pCurveClone;
		break;
	case DMUS_PMSGT_MIDI:
		ulPMsgSize = sizeof(DMUS_MIDI_PMSG);
		ppPMsg = (DMUS_PMSG**)&pMidi;
		ppPMsgClone = (DMUS_PMSG**)&pMidiClone;
		break;
	case DMUS_PMSGT_NOTE:
		ulPMsgSize = sizeof(DMUS_NOTE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pNote;
		ppPMsgClone = (DMUS_PMSG**)&pNoteClone;
		break;
//	case DMUS_PMSGT_NOTIFICATION:
//		ulPMsgSize = sizeof(DMUS_NOTIFICATION_PMSG);
//		ppPMsg = (DMUS_PMSG**)&pNotify;
//		ppPMsgClone = (DMUS_PMSG**)&pNotifyClone;
//		break;
	case DMUS_PMSGT_PATCH:
		ulPMsgSize = sizeof(DMUS_PATCH_PMSG);
		ppPMsg = (DMUS_PMSG**)&pPatch;
		ppPMsgClone = (DMUS_PMSG**)&pPatchClone;
		break;
//	case DMUS_PMSGT_SYSEX:
//		ulPMsgSize = sizeof(DMUS_SYSEX_PMSG);
//		ppPMsg = (DMUS_PMSG**)&pSysex;
//		ppPMsgClone = (DMUS_PMSG**)&pSysexClone;
//		break;
	case DMUS_PMSGT_TEMPO:
		ulPMsgSize = sizeof(DMUS_TEMPO_PMSG);
		ppPMsg = (DMUS_PMSG**)&pTempo;
		ppPMsgClone = (DMUS_PMSG**)&pTempoClone;
		break;
//	case DMUS_PMSGT_TIMESIG:
//		ulPMsgSize = sizeof(DMUS_TIMESIG_PMSG);
//		ppPMsg = (DMUS_PMSG**)&pTimeSig;
//		ppPMsgClone = (DMUS_PMSG**)&pTimeSigClone;
//		break;
	case DMUS_PMSGT_TRANSPOSE:
		ulPMsgSize = sizeof(DMUS_TRANSPOSE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pTrans;
		ppPMsgClone = (DMUS_PMSG**)&pTransClone;
		break;
//	case DMUS_PMSGT_CHANNEL_PRIORITY:
//		ulPMsgSize = sizeof(DMUS_CHANNEL_PRIORITY_PMSG);
//		ppPMsg = (DMUS_PMSG**)&pChanPri;
//		ppPMsgClone = (DMUS_PMSG**)&pChanPriClone;
//		break;
	default:
		//not tested at the moment
			//DMUS_PMSGT_STOP
			//DMUS_PMSGT_DIRTY
			//DMUS_PMSGT_WAVE
			//DMUS_PMSGT_LYRIC
			//DMUS_PMSGT_SCRIPTLYRIC
			//DMUS_PMSGT_USER
		fnsLog(ABORTLOGLEVEL, TEXT("**** PENDING: PMsg type unsupported in this test case"));
		dwRes = FNS_PENDING;
		goto TEST_END;
	}
	hr = pwPerformance->AllocPMsg(ulPMsgSize,(DMUS_PMSG**)ppPMsg);
	if(FAILED(hr) || !(*ppPMsg))
	{
		fnsLog(BUGLOGLEVEL,TEXT("**** ABORT: IDMPerformance::AllocPMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 12) Set PMsg values
	// **********************************************************************
	/*
		// common to all pmsgs

			#define DMUS_PMSG_PART                                                                              
			DWORD               dwSize;
			REFERENCE_TIME      rtTime;             //  real time (in 100 nanosecond increments)
			MUSIC_TIME          mtTime;             //  music time
			DWORD               dwFlags;            //  various bits (see DMUS_PMSGF_FLAGS enumeration)
			DWORD               dwPChannel;         //  Performance Channel. The Performance can
													//  use this to determine the port/channel.
			DWORD               dwVirtualTrackID;   //  virtual track ID
			IDirectMusicTool*   pTool;              //  tool interface pointer
			IDirectMusicGraph*  pGraph;             //  tool graph interface pointer
			DWORD               dwType;             //  PMSG type (see DMUS_PMSGT_TYPES defines)
			DWORD               dwVoiceID;          //  unique voice id which allows synthesizers to
													//  identify a specific event. For DirectX 6.0,
													//  this field should always be 0.
			DWORD               dwGroupID;          //  Track group id
			IUnknown*           punkUser;           //  user com pointer, auto released upon PMSG free
	*/
	(*ppPMsg)->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8 | dwPMsgFlags;
	(*ppPMsg)->dwPChannel = 0; //DMUS_PCHANNEL_BROADCAST_SEGMENT;
	(*ppPMsg)->dwVirtualTrackID = 0;
	(*ppPMsg)->dwGroupID = -1;

	(*ppPMsg)->dwType = dwPMsgType;

	switch(dwPMsgType)
	{
	case DMUS_PMSGT_CURVE:
		//DMUS_CURVE_PMSG
		((DMUS_CURVE_PMSG*)*ppPMsg)->mtDuration			= 768 * 4;		// Curve lasts four beats.
		((DMUS_CURVE_PMSG*)*ppPMsg)->mtResetDuration	= 0;			// No reset.
		((DMUS_CURVE_PMSG*)*ppPMsg)->nStartValue		= 0;			// ignored
		((DMUS_CURVE_PMSG*)*ppPMsg)->nEndValue			= 127;			// fade to full volume.
		((DMUS_CURVE_PMSG*)*ppPMsg)->nResetValue		= 0;			// No reset.
		((DMUS_CURVE_PMSG*)*ppPMsg)->bType				= DMUS_CURVET_CCCURVE;
		((DMUS_CURVE_PMSG*)*ppPMsg)->bCurveShape		= DMUS_CURVES_LINEAR;
		((DMUS_CURVE_PMSG*)*ppPMsg)->bCCData			= 7;			// MIDI Volume controller.
		((DMUS_CURVE_PMSG*)*ppPMsg)->bFlags				= DMUS_CURVE_START_FROM_CURRENT; 
		((DMUS_CURVE_PMSG*)*ppPMsg)->wParamType			= 0; 			// This is for NRPN and RPN only.
		((DMUS_CURVE_PMSG*)*ppPMsg)->wMergeIndex		= 1;			// This will be added to the regular volume, not override it.
		break;
	case DMUS_PMSGT_MIDI:
		//DMUS_MIDI_PMSG
		((DMUS_MIDI_PMSG*)*ppPMsg)->bStatus				= MIDI_CCHANGE;
		((DMUS_MIDI_PMSG*)*ppPMsg)->bByte1				= 10;			// pan
		((DMUS_MIDI_PMSG*)*ppPMsg)->bByte2				= 0;			// left
		((DMUS_MIDI_PMSG*)*ppPMsg)->bPad[0]				= 0;
		break;
	case DMUS_PMSGT_NOTE:
		//DMUS_NOTE_PMSG
		((DMUS_NOTE_PMSG*)*ppPMsg)->mtDuration			= 768 * 8;		// duration
		((DMUS_NOTE_PMSG*)*ppPMsg)->wMusicValue			= 0;			// Description of note in chord and key
		((DMUS_NOTE_PMSG*)*ppPMsg)->wMeasure			= 0;			// Measure in which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->nOffset				= 0;			// Offset from grid at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bBeat				= 0;			// Beat (in measure) at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bGrid				= 0;			// Grid offset from beat at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bVelocity			= 127;			// Note velocity
		((DMUS_NOTE_PMSG*)*ppPMsg)->bFlags				= DMUS_NOTEF_NOTEON;	// see DMUS_NOTEF_FLAGS
		((DMUS_NOTE_PMSG*)*ppPMsg)->bTimeRange			= 0;			// Range to randomize time
		((DMUS_NOTE_PMSG*)*ppPMsg)->bDurRange			= 0;			// Range to randomize duration
		((DMUS_NOTE_PMSG*)*ppPMsg)->bVelRange			= 0;			// Range to randomize velocity
		((DMUS_NOTE_PMSG*)*ppPMsg)->bPlayModeFlags		= DMUS_PLAYMODE_FIXED;	// Play mode
		((DMUS_NOTE_PMSG*)*ppPMsg)->bSubChordLevel		= 0;			// Which subchord level this note uses
		((DMUS_NOTE_PMSG*)*ppPMsg)->bMidiValue			= 36;			// The MIDI note value, converted from wMusicValue
		((DMUS_NOTE_PMSG*)*ppPMsg)->cTranspose			= 0;			// Transposition to add to midi note value after converted from wMusicValue
		break;
	case DMUS_PMSGT_NOTIFICATION:
		//DMUS_NOTIFICATION_PMSG
		//GUID    guidNotificationType;
		//DWORD   dwNotificationOption;
		//DWORD   dwField1;
		//DWORD   dwField2;
		br