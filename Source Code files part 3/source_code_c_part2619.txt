sToAlloc)
				cHandlesToAlloc = cRowsInSet - lRowsOffset;
			if (iStepSize == -1 && lRowsOffset < cHandlesToAlloc)
				cHandlesToAlloc = lRowsOffset;

			rghRowsAllocated.Allocate(cHandlesToAlloc);
			if(rghRowsAllocated == NULL)
				return E_OUTOFMEMORY;			
			*prghRows = rghRowsAllocated;
		}

		while ((lRowsOffset >= 0 && cRows != 0) &&
			((lRowsOffset < cRowsInSet) || (lRowsOffset <= cRowsInSet && iStepSize < 0))) 
		{
			// cRows > cRowsInSet && iStepSize < 0
			if (lRowsOffset == 0 && cRows > 0 && iStepSize < 0)
				break;

			// in the case where we have iStepSize < 0, move the row back
			// further because we want the previous row
			DBROWOFFSET lRow = lRowsOffset;
			if ((lRowsOffset == 0) && (lTmpRows == 0) && (iStepSize < 0))
				lRow = cRowsInSet;

			if (iStepSize < 0)
				lRow += iStepSize;

			hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);

			if (FAILED(hr))
			{
				RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
				for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
					*prghRows[iRowDel] = NULL;
				*pcRowsObtained = 0; 
				return hr;
			}

			__if_exists(T::Fire_OnRowsetChange)
			{
				if (!m_bExternalFetch)
					pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
			}

			cRows--;
			lRowsOffset += iStepSize;
		}

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (size_t ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// REVIEW: This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					if( m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow ) &&
						(pActiveRow != NULL && pActiveRow->m_dwRef == 1) )
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
				}
			}
		}

		m_iRowset = lRowsOffset;
		if ((lRowsOffset >= cRowsInSet && cRows) || (lRowsOffset < 0 && cRows)  ||
			(lRowsOffset == 0 && cRows > 0 && iStepSize < 0))
			hr = DB_S_ENDOFROWSET;

		if (SUCCEEDED(hr))
			rghRowsAllocated.Detach();
		return hr;
	}

	STDMETHOD(ReleaseRows)(DBCOUNTITEM cRows,
						   const HROW rghRows[],
						   DBROWOPTIONS rgRowOptions[],
						   DBREFCOUNT rgRefCounts[],
						   DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::ReleaseRows\n"));

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*) this;

			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		if (cRows == 0)
			return S_OK;
		rgRowOptions;
		return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, FALSE);
	}

	STDMETHOD(RestartPosition)(HCHAPTER /*hReserved*/)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::RestartPosition\n"));
		
		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowsetChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();


			bool bNeedEvents = ((m_iRowset != 0 || !m_bReset)) ? true : false;

			// Only fire the events iff. we are actually causing a reset
			if (bNeedEvents)
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT, 
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}

			}
		}

		// Check to see if DBPROP_CANHOLDROWS is set to false.  In this case,
		// return a DB_E_ROWSNOTRELEASED.
		CComVariant varHoldRows;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANHOLDROWS, 
			&varHoldRows);

		if (FAILED(hr) || varHoldRows.boolVal == ATL_VARIANT_FALSE)
		{
			if (m_rgRowHandles.GetCount() > 0)
			{
				RowClass* pRow = NULL;
				POSITION pos = pT->m_rgRowHandles.GetStartPosition();
	
				while (pos != NULL)
				{
					MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
					ATLASSERT( pPair != NULL );
					HROW hRow = pPair->m_key;
					bool bFound = pT->m_rgRowHandles.Lookup(hRow, pRow);
				
					if (bFound && pRow != NULL && 
						pRow->m_status != DBPENDINGSTATUS_UNCHANGED)
					{
						__if_exists(T::Fire_OnRowsetChange)
						{
							if (bNeedEvents)
							{
								pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE, 
										DBEVENTPHASE_FAILEDTODO, TRUE); 
							}
						}

						return DB_E_ROWSNOTRELEASED;
					}
				}
			}
		}

		m_iRowset = 0;
		m_bReset = true;
		__if_exists(T::Fire_OnRowsetChange)
		{
			// listener must comply so blow off ret val.
			if (bNeedEvents)
				pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE, 
						DBEVENTPHASE_DIDEVENT, TRUE); 
		}
		return S_OK;
	}

	MapClass  m_rgRowHandles;
	DBROWOFFSET m_iRowset; // cursor
	unsigned  m_bCanScrollBack:1;
	unsigned  m_bCanFetchBack:1;
	unsigned  m_bRemoveDeleted:1; // DBPROP_REMOVEDELETED
	unsigned  m_bIRowsetUpdate:1; // DBPROP_IRowsetUpdate
	unsigned  m_bReset:1;
	unsigned  m_bExternalFetch:1;
};


template <class T, class RowsetInterface, 
		  class RowClass = CSimpleRow, 
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* >,
		  class BookmarkKeyType = LONG, class BookmarkType = LONG,
		  class BookmarkMapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetLocateImpl : public IRowsetImpl<T, RowsetInterface, RowClass, MapClass> 
{
public:
	STDMETHOD (Compare)(HCHAPTER /*hReserved*/, DBBKMARK cbBookmark1, 
		const BYTE * pBookmark1, DBBKMARK cbBookmark2, const BYTE * pBookmark2,
		DBCOMPARE * pComparison)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Compare\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}


		// Validate input parameters
		if (pComparison == NULL)
			return E_INVALIDARG;

		// ValidateBookmark catches the cbBookmark == 0 and the 
		//		pBookmark == NULL -- E_INVALIDARG cases
		HRESULT hr = ValidateBookmark(cbBookmark1, pBookmark1);
		if (hr != S_OK)
			return hr;

		hr = ValidateBookmark(cbBookmark2, pBookmark2);
		if (hr != S_OK)
			return hr;

		// Return the value based on the bookmark values.  Be sure that
		// they are not specials in which case go below
		if ((*pBookmark1 == *pBookmark2) && (cbBookmark1 != 1) && (cbBookmark2 != 1))
		{
			*pComparison = DBCOMPARE_EQ;
			return S_OK;
		}

		// Determine if we are using ordered or unorder bookmarks
		CComVariant varOrdered;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_ORDEREDBOOKMARKS, 
			&varOrdered);

		if ((*pBookmark1 == DBBMK_FIRST && cbBookmark1 == 1) || 
			(*pBookmark1 == DBBMK_LAST  && cbBookmark1 == 1) ||
			(*pBookmark2 == DBBMK_FIRST && cbBookmark2 == 1) ||
			(*pBookmark2 == DBBMK_LAST  && cbBookmark2 == 1) ||
			(FAILED(hrProps)) || 
			(varOrdered.boolVal == ATL_VARIANT_FALSE))
		{
			// If the bookmarks are 'specials' DBBMK_FIRST or DBBMK_LAST or the
			// bookmarks are unordered, then we return NE instead of GT or LT.
			if (*pBookmark1 == *pBookmark2)
				*pComparison = DBCOMPARE_EQ;
			else
				*pComparison = DBCOMPARE_NE;
		}
		else
		{
			//@todo: review the code below.  
			// this might be a bug - we may have to cast these pointers to DBBKMARK* before comparing them.

			// We have valid bookmarks which are not special values.  
			// Since we assume that bookmarks are ordered, we'll return
			// the 
			if (*(DBBKMARK*)pBookmark1 < *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_LT;
			else if (*(DBBKMARK*)pBookmark1 > *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_GT;
			else
				*pComparison = DBCOMPARE_EQ;
		}

		return S_OK;
	}

	STDMETHOD (GetRowsAt)(HWATCHREGION /*hReserved1*/, HCHAPTER hReserved2,
		DBBKMARK cbBookmark, const BYTE * pBookmark, DBROWOFFSET lRowsOffset,
		DBROWCOUNT cRows, DBCOUNTITEM * pcRowsObtained, HROW ** prghRows)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsAt\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// TODO: Change this to a regular CComCriticalSection call
		T::ObjectLock cab(pT);

		// Check input parameters
		if (pcRowsObtained == NULL)
			return E_INVALIDARG;

		*pcRowsObtained = 0;

		if (cbBookmark == 0 || pBookmark == NULL || prghRows == NULL)
			return E_INVALIDARG;

		// Check bookmark
		HRESULT hr = ValidateBookmark(cbBookmark, pBookmark);
		if (hr != S_OK)
			return hr;

		// Set the current row position to the bookmark.  Handle any
		// normal values

		// We need to handle the offset as the start position is defined
		// as the bookmark + offset.  If the offset is negative, and we
		// do not have m_bCanScrollBack then return an error.  The 
		// GetNextRows function handles the case where cRows is negative
		// and we don't have m_bCanFetchBack set.
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;

		DBROWOFFSET iRowsetTemp = m_iRowset;  // Cache the current rowset 

		// Determine if this row is deleted or not.
		size_t lBookmarkIndex = (size_t)(*pBookmark);

		// -1 is uniform value for a deleted bookmark
		if( cbBookmark != 1 )
		{
			if (m_rgBookmarks[lBookmarkIndex] == -1)
			{
				m_iRowset = iRowsetTemp;
				return DB_E_BADBOOKMARK;
			}
			else
			{
				m_iRowset = m_rgBookmarks[lBookmarkIndex];
			}
		}

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_FIRST))
			m_iRowset = 1;

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_LAST))
			m_iRowset = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		// Set the start position to m_iRowset + lRowsOffset
		m_iRowset += lRowsOffset;
		
		if (lRowsOffset >= 0)
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
		else
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
//		(lRowsOffset >= 0) ? m_iRowset -= 1 : m_iRowset += 1;

		// BUG: If we get DBBMK_FIRST and lRowsOffset == -1, then we set
		// m_iRowset to 0xFFFFFFFF.

		if (m_iRowset < 0 || m_iRowset > (DBROWOFFSET)pT->m_rgRowData.GetCount())
		{
			m_iRowset = iRowsetTemp;
			return DB_S_ENDOFROWSET;
		}

		// Call IRowsetImpl::GetNextRows to actually get the rows.
		m_bExternalFetch = true;
		hr = GetNextRows(hReserved2, 0, cRows, pcRowsObtained, prghRows);
		m_bExternalFetch = false;

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (ULONG ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// REVIEW: This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					bool bFound = m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow);
					if ( bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
				}
			}
		}

		m_iRowset = iRowsetTemp;
		return hr;
	}

	STDMETHOD (GetRowsByBookmark)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows,
		const DBBKMARK rgcbBookmarks[], const BYTE * rgpBookmarks[],
		HROW rghRows[], DBROWSTATUS rgRowStatus[])
	{
		HRESULT hr = S_OK;
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsByBookmark\n"));
		bool bErrors = false;
		bool bSuccess = false;

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		T::ObjectLock cab(pT);
		if (rgcbBookmarks == NULL || rgpBookmarks == NULL || rghRows == NULL)
			return E_INVALIDARG;

		if (cRows == 0)
			return S_OK;	// No rows fetched in this case.

		memset(rghRows, 0, sizeof(HROW)*cRows);
		for (size_t l=0; l<cRows; l++)
		{
			// Validate each bookmark before fetching the row.  Note, it is
			// an error for the bookmark to be one of the standard values
			const BYTE* pBookmark = rgpBookmarks[l];
			hr = ValidateBookmark(rgcbBookmarks[l], pBookmark);
			if ((hr != S_OK) ||
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[l] == 1) ||
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[l] == 1))
			{
				bErrors |= true;
				if (rgRowStatus != NULL)
				{
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;
					continue;
				}
			}

			//@todo: review the line below
			// Determine if this row is deleted or not by first looking in our cache
			DBROWCOUNT lBookmarkIndex = *(DBROWCOUNT*)pBookmark;
			if (m_rgBookmarks[lBookmarkIndex] == -1) // Uniform value for invalid row
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;

				bErrors |= true;
				continue;
			}

			// Fetch the row, we now that it is a valid row after validation.
			DBCOUNTITEM ulRowsObtained = 0;
			DBROWCOUNT lRow = m_rgBookmarks[lBookmarkIndex] - 1;
//			if (((long)*rgpBookmarks[l]) != 0)
//				lRow = ((long)*rgpBookmarks[l]) - 1;

			// Attempt to create the row
			if (CreateRow(lRow, ulRowsObtained, &rghRows[l]) != S_OK)
			{
				bErrors |= true;
			}
			else
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_S_OK;

				bSuccess |= true;
			}
		}

		__if_exists(T::Fire_OnRowsetChange)
		{
			CAtlArray<HROW> rgActivated;
			for (size_t ulActivated = 0; ulActivated < cRows; ulActivated++)
			{
				// REVIEW: This is a bit of an assumption that all newly activated
				// rows would have the ref count as 1.  Another way to solve this
				// problem would be to modify the signature of CreateRow to take
				// a CAtlArray<HROW> as a parameter and store the activated rows.
				RowClass* pActiveRow;
				bool bFound = m_rgRowHandles.Lookup(rghRows[ulActivated], pActiveRow);
				if (bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
				{
					_ATLTRY
					{
						rgActivated.Add(rghRows[ulActivated]);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_OUTOFMEMORY;
					}
				}
			}
			if (rgActivated.GetCount() > 0)
			{
				pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
					DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
			}
		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return hr;
	}

	STDMETHOD (Hash)(HCHAPTER /*hReserved*/, DBBKMARK cBookmarks,
		const DBBKMARK rgcbBookmarks[], const BYTE * rgpBookmarks[],
		DBHASHVALUE rgHashedValues[], DBROWSTATUS rgBookmarkStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Hash\n"));

		bool bSuccess = false;
		bool bErrors = false;

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*)this;
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		HRESULT hr = E_FAIL;
		// validate parameters
		if (cBookmarks != 0 && (rgcbBookmarks == NULL || rgpBookmarks == NULL ||
			rgHashedValues == NULL))
			return E_INVALIDARG;

		// hash values
		for (size_t i=0; i<cBookmarks; i++)
		{
			// Check the bookmarks
			const BYTE* pBookmark = rgpBookmarks[i];
			hr = ValidateBookmark(rgcbBookmarks[i], pBookmark);
			if (FAILED(hr) || 
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[i] == 1) || 
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[i] == 1))
			{
				if (rgBookmarkStatus != NULL)
					rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;
				bErrors |= true;
				continue;
			}

			rgHashedValues[i] = (DBHASHVALUE)(*(rgpBookmarks[i]));

			if (rgBookmarkStatus != NULL)
				rgBookmarkStatus[i] = DBROWSTATUS_S_OK;
			bSuccess |= true;

		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return S_OK;
	}

	// Data members
	CAtlArray<DBROWCOUNT> m_rgBookmarks;

	// Implementation
	protected:
	HRESULT ValidateBookmark(DBBKMARK cbBookmark, const BYTE* pBookmark)
	{
		T* pT = (T*)this;
		if (cbBookmark == 0 || pBookmark == NULL)
			return E_INVALIDARG;

		// All of our bookmarks are DBBKMARKs, if they are anything other than 
		// sizeof(DBBKMARK) then we have an invalid bookmark
		if ((cbBookmark != sizeof(DBBKMARK)) && (cbBookmark != 1))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmarks are invalid length, should be DBBKMARKs"));
			return DB_E_BADBOOKMARK;
		}

		// If our bookmark is a special (i.e. cbBookmark == 1), then it should
		// be one of the accepted values. 
		if ((cbBookmark == 1) && (*pBookmark != DBBMK_FIRST && *pBookmark != DBBMK_LAST))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmark is invalid"));
			return DB_E_BADBOOKMARK;
		}

		// If the contents of our bookmarks are less than 0 or greater than
		// rowcount, then they are invalid
		DBCOUNTITEM nRows = (ULONG_PTR)pT->m_rgBookmarks.GetCount();
		DBROWOFFSET lBookmarkIndex = (DBROWOFFSET)(*pBookmark);
		if (lBookmarkIndex <= -1 || lBookmarkIndex > (DBROWOFFSET)nRows )
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Bookmark has invalid range"));
			return DB_E_BADBOOKMARK;
		}

		return S_OK;
	}
};

///////////////////////////////////////////////////////////////////////////
// IRowsetIdentityImpl 
template <class T, class RowClass = CSimpleRow>
class ATL_NO_VTABLE IRowsetIdentityImpl : public IRowsetIdentity
{
public:
	STDMETHOD(IsSameRow)(HROW hThisRow, HROW hThatRow)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetIdentityImpl::IsSameRow\n"));		
		T* pT = (T*)this;

		// Validate row handles
		RowClass* pRow1;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThisRow, pRow1) )
			return DB_E_BADROWHANDLE;

		RowClass* pRow2;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThatRow, pRow2) )
			return DB_E_BADROWHANDLE;

		if (pRow1->m_status == DBPENDINGSTATUS_DELETED ||
			pRow2->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		HRESULT hr = pRow1->Compare(pRow2);
__if_not_exists(T::InsertRow)
{
		return hr;
}

__if_exists(T::InsertRow)
{
		if (hr != S_OK)
			return hr;

		// Add one more test for providers who support IRowsetChange or Update.
		// It is possible for a series of inserts & deletes to occur to make
		// CSimpleRow appear as if it were equivalent (when it is not).  To
		// fix this, we've added an m_iOriginalRowset variable that never gets
		// changed.
		return (pRow1->m_iOriginalRowset == pRow2->m_iOriginalRowset) ? S_OK : S_FALSE;
}
    };
};

template <class T>
class ATL_NO_VTABLE IInternalConnectionImpl : public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cSessionsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cSessionsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IInternalCommandConnectionImpl : public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cRowsetsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cRowsetsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IObjectWithSiteSessionImpl : public IObjectWithSiteImpl< T > 
{
public:
	
	~IObjectWithSiteSessionImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}
	STDMETHOD(SetSite)(IUnknown* pCreator)
	{
		HRESULT hr = S_OK;
		T* pT = (T*)this;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			hr = pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn);
			if (SUCCEEDED(hr))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cSessionsOpen;

};

template <class T>
class ATL_NO_VTABLE IRowsetCreatorImpl : public IObjectWithSiteImpl< T >
{
public:

	~IRowsetCreatorImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}

	STDMETHOD(SetSite)(IUnknown* pCreator)
	{
		T* pT = (T*)this;
		HRESULT hr = S_OK;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComVariant varPropScroll, varPropFetch, varPropRemove, varPropUpdate;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &varPropScroll);
		if (SUCCEEDED(hrProps))
			pT->m_bCanScrollBack = (varPropScroll.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANFETCHBACKWARDS, &varPropFetch);
		if (SUCCEEDED(hrProps))
			pT->m_bCanFetchBack = (varPropFetch.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_REMOVEDELETED, &varPropRemove);
		if (SUCCEEDED(hrProps))
			pT->m_bRemoveDeleted = (varPropRemove.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, &varPropUpdate);
		if (SUCCEEDED(hrProps))
			pT->m_bIRowsetUpdate = (varPropUpdate.boolVal != ATL_VARIANT_FALSE);
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			if (SUCCEEDED(pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cRowsetsOpen;

};

// IRowsetInfoImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE IRowsetInfoImpl : 
	public IRowsetInfo, 
	public CUtlProps<PropClass>
{
public:
	static UPROPSET* _GetPropSet(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet = NULL, GUID* pguidSet = NULL)
	{
		return PropClass::_GetPropSet(pNumPropSets, pcElemPerSupported, pSet, pguidSet);
	}
	STDMETHOD(GetProperties)(const ULONG cPropertyIDSets,
							 const DBPROPIDSET rgPropertyIDSets[],
							 ULONG *pcPropertySets,
							 DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetProperties\n"));
		T* pT = (T*)this;
		// Prevent Level 4 warning
		pT;

		// IRowsetInfo can't return PROPERTIESINERROR.  Therefore, disable
		// checking for it.  Instead, treat it as any normal property set.
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, 
			pcPropertySets, prgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			pSetA = (UPROPSET*)_alloca(sizeof(UPROPSET)*cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			PCGUID* ppGuid = (PCGUID*)_alloca(sizeof(PCGUID)*ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			return CUtlProps<PropClass>::GetProperties(cPropertyIDSets, 
					rgPropertyIDSets, pcPropertySets, prgPropertySets, 
					ulPropInits, ppGuid);
		}
		else
			return hr;
	}

	OUT_OF_LINE ATLCOLUMNINFO* InternalGetColumnInfo(DBORDINAL* pcCols)
	{
		return T::GetColumnInfo((T*)this, pcCols);
	}

	STDMETHOD(GetReferencedRowset)(DBORDINAL iOrdinal,
								   REFIID riid,
								   IUnknown **ppReferencedRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetReferencedRowset\n"));
		DBORDINAL cCols=0;

		// Check Arguments
		if( ppReferencedRowset == NULL )
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetInfoImpl::GetReferencedRowset : Error NULL IUnk output Param\n"));
			return E_INVALIDARG;
		}
		*ppReferencedRowset = NULL;

		// Check to see if column in question is a bookmark
		ATLCOLUMNINFO* pColInfo = InternalGetColumnInfo(&cCols);
		DBORDINAL iColInfo;
		for (iColInfo = 0; 
			 iColInfo < cCols && iOrdinal != pColInfo[iColInfo].iOrdinal;
			 iColInfo++);
		if (iColInfo == cCols)
			return DB_E_BADORDINAL;
		ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);

		if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
			return DB_E_NOTAREFERENCECOLUMN;

		// Query for requested interface
		return QueryInterface(riid, (void**)ppReferencedRowset);
	}

	STDMETHOD(GetSpecification)(REFIID riid,
								IUnknown **ppSpecification)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetSpecification\n"));

		if (ppSpecification == NULL)
			return E_INVALIDARG;
		T* pT = (T*) this;
		T::ObjectLock cab(pT);
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**)ppSpecification);
	}
};

/*
template <class Storage, class ContainedArray = CAtlArray<Storage> >
class CUpdateArray : public ContainedArray
{
public:

	void RemoveAll()
	{
		ContainedArray::RemoveAll();
		m_rgRowLink.RemoveAll();
	}

	BOOL Add(Storage& rStorage)
	{
		if (ContainedArray::Add(rStorage))
		{
			if (!m_rgRowLink.Add(GetCount() - 1))
			{
				RemoveAt(GetCount() - 1);
				return FALSE;
			}
			return TRUE;
		}
		return FALSE;
	}

	BOOL RemoveAt(int nIndex)
	{
		if (ContainedArray::RemoveAt(m_rgRowLink[nIndex]))
		{
			// Decrement any links following the current row
			for (long l=nIndex+1; l<m_rgRowLink.GetCount(); l++)
			{
				long* pElem = &(m_rgRowLink.m_aT[l]);
				ATLASSERT(pElem != NULL);
				(*pElem)--;
			}
			return m_rgRowLink.RemoveAt(nIndex);
		}
		return FALSE;
	}

	ContainedArray::_ArrayElementType& operator[] (int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	const ContainedArray::_ArrayElementType& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	CSimpleValArray<long> m_rgRowLink;
};
*/

class CComSharedMutex
{
public:
	CComSharedMutex()
	{
		m_lInterlockedVariable = -1;
	};

	inline bool IncrementMutex() 
	{ 
		long lAvailable = ::InterlockedIncrement(&m_lInterlockedVariable);
		if (lAvailable > 0)
		{
			// Mutex is held, decrement and return false
			DecrementMutex();
			return false;
		}
		else
			return true;
	};
	inline void DecrementMutex() 
	{
		::InterlockedDecrement(&m_lInterlockedVariable);
	};

	long m_lInterlockedVariable;
};


template <class T, class ReentrantEventSync = CComSharedMutex>
class IRowsetNotifyCP : public IConnectionPointImpl<T, &__uuidof(IRowsetNotify), CComDynamicUnkArray>,
	public ReentrantEventSync
{
public:
	HRESULT Fire_OnFieldChange(IRowset * pRowset, HROW hRow, DBORDINAL cColumns, 
				DBORDINAL* rgColumns, DBREASON eReason, DBEVENTPHASE ePhase, 
				BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnFieldChange\n"));
		
		IncrementMutex();	// Lock the event handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnFieldChange(pRowset, hRow, cColumns,
					rgColumns, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE  && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> sp = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnFieldChange(pRowset, hRow, cColumns, rgColumns, 
								eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnFieldChange(pRowset, hRow, cColumns, rgColumns,
						eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnFieldChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}	
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;
	
	}
	HRESULT Fire_OnRowChange(IRowset * pRowset, DBCOUNTITEM cRows, const HROW rghRows[], 
		DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowChange\n"));
		IncrementMutex();  // Lock the handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
			{
				ret = pIRowsetNotify->OnRowChange(pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
			}
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> sp = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowChange(pRowset, cRows, rghRows, eReason,
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_SYNCHAFTER:
			case DBEVENTPHASE_ABOUTTODO:
				if (ret	== S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowChange(pRowset, cRows, rghRows, eReason,
						DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}	
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;
	
	}
	HRESULT Fire_OnRowsetChange(IRowset* pRowset, DBREASON eReason, 
		DBEVENTPHASE ePhase, BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowsetChange\n"));
		IncrementMutex(); // Lock the handler so others can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnRowsetChange(pRowset, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> sp = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowsetChange(pRowset, eReason, 
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified. 
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowsetChange(pRowset, eReason, DBEVENTPHASE_FAILEDTODO, 
						FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;
	
	}
};


template <class T, class Storage, 
		  class ArrayType = CAtlArray<Storage>, 
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CRowsetBaseImpl :
	public IAccessorImpl<T>,
	public IRowsetIdentityImpl<T>,
	public IRowsetCreatorImpl<T>,
	public IColumnsInfoImpl<T>,
	public IConvertTypeImpl<T>,
	public RowsetInterface
{
public:
	HRESULT NameFromDBID(DBID* pDBID, CComBSTR& bstr, bool bIndex)
	{

		if (pDBID->uName.pwszName != NULL)
		{
			bstr = pDBID->uName.pwszName;
			if (bstr == (BSTR)NULL)
				return E_OUTOFMEMORY;
			return S_OK;
		}

		return (bIndex) ? DB_E_NOINDEX : DB_E_NOTABLE;
	}
	
	HRESULT GetCommandFromID(DBID* pTableID, DBID* pIndexID)
	{
		USES_CONVERSION;
		HRESULT hr;

		if (pTableID == NULL && pIndexID == NULL)
			return E_INVALIDARG;

		if (pTableID != NULL && pTableID->eKind == DBKIND_NAME)
		{
			hr = NameFromDBID(pTableID, m_strCommandText, true);
			if (FAILED(hr))
				return hr;
			if (pIndexID != NULL)
			{
				if (pIndexID->eKind == DBKIND_NAME)
				{
					hr = NameFromDBID(pIndexID, m_strIndexText, false);
					if (FAILED(hr))
					{
						m_strCommandText.Empty();
						return hr;
					}
				}
				else
				{
					m_strCommandText.Empty();
					return DB_E_NOINDEX;
				}
			}
			return S_OK;
		}
		if (pIndexID != NULL && pIndexID->eKind == DBKIND_NAME)
			return NameFromDBID(pIndexID, m_strIndexText, false);

		return S_OK;
	}

	HRESULT ValidateCommandID(DBID* pTableID, DBID* pIndexID)
	{
		HRESULT hr = S_OK;
		
		if (pTableID != NULL)
		{
			hr = CUtlProps<T>::IsValidDBID(pTableID);

			if (hr != S_OK)
				return hr;

			// Check for a NULL TABLE ID (where its a valid pointer but NULL)
			if ((pTableID->eKind == DBKIND_GUID_NAME || 
				pTableID->eKind == DBKIND_NAME ||
				pTableID->eKind == DBKIND_PGUID_NAME)
				&& pTableID->uName.pwszName == NULL)
				return DB_E_NOTABLE;
		}

		if (pIndexID != NULL)
			hr = CUtlProps<T>::IsValidDBID(pIndexID);

		return hr;
	}

	HRESULT SetCommandText(DBID* pTableID, DBID* pIndexID)
	{
		T* pT = (T*)this;
		HRESULT hr = pT->ValidateCommandID(pTableID, pIndexID);
		if (FAILED(hr))
			return hr;
		hr = pT->GetCommandFromID(pTableID, pIndexID);
		return hr;
	}

	static ATLCOLUMNINFO* GetColumnInfo(T* pv, DBORDINAL* pcCols)
	{
		return Storage::GetColumnInfo(pv,pcCols);
	}

	CComBSTR m_strCommandText;
	CComBSTR m_strIndexText;

	ArrayType m_rgRowData;
};


template <class T, class Storage, class CreatorClass, 
		  class ArrayType = CAtlArray<Storage>, 
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CRowsetImpl : 
	public CComObjectRootEx<CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface>,
	public IRowsetInfoImpl<T, CreatorClass::_PropClass>
{
public:
	typedef CRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;

BEGIN_COM_MAP(CRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <class T, class Storage, class CreatorClass, 
		  class ArrayType = CAtlArray<Storage>, 
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CSchemaRowsetImpl : 
	public CComObjectRootEx<CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface>,
	public IRowsetInfoImpl<T>
{
public:
	typedef CSchemaRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;
	
BEGIN_COM_MAP(CSchemaRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <const GUID* pguidProvider>
class CErrorReporterHelper
{
public:

	HRESULT PostError(HRESULT hrErr, IID* piid)
	{
		HRESULT	hr = S_OK;
		if (piid == NULL)
			return E_INVALIDARG;

		CComPtr<ICreateErrorInfo>	spCrtErrInfo;
		CComPtr<IErrorInfo>			spIErrorInfo;
		CComPtr<IErrorRecords>		spIErrorRecords;

		hr = CreateErrorInfo(&spCrtErrInfo);
		if (SUCCEEDED(hr))
		{
			ERRORINFO		errorinfo;
			memset(&errorinfo, 0, sizeof(ERRORINFO));
			errorinfo.clsid		= *pguidProvider;
			errorinfo.dispid	= NULL;
			errorinfo.dwMinor	= 0;
			errorinfo.hrError	= hrErr;
			errorinfo.iid		= *piid;

			spCrtErrInfo->SetGUID(errorinfo.iid)
			spCrtErrInfo->SetSource(OLESTR("Provider PROGID"));
			spCrtErrInfo->SetDescription(OLESTR("Error Description"));
			spCrtErrInfo->SetHelpFile(OLESTR("provider.hlp"));
			spCrtErrInfo->SetHelpContext(1);

			//Obtain the error object or create a new one if none exists
			GetErrorInfo(0, &spIErrorInfo);
			if( spIErrorInfo == NULL )
			{
				hr = spIErrorInfo->CoCreateInstance(CLSID_EXTENDEDERRORINFO);
				if( FAILED(hr))
					return hr;
			}

			// Obtain the IErrorRecord Interface
			hr = spIErrorInfo->QueryInterface(__uuidof(IErrorRecords), &spIErrorRecords));
			if( SUCCEEDED(hr))
			{
				hr = spIErrorRecords->AddErrorRecord(&errorinfo, 0, NULL, &spICrtErrInfo, 0);
				if( FAILED(hr))
					return hr;
			}
		}

		if( spIErrorInfo != NULL)
			SetErrorInfo(0, &spIErrorInfo);

		return hr;
	}


};

struct ATLERRORINFO
{
	ERRORINFO*		  pInfo;
	DISPPARAMS		  dispparams;
	CComPtr<IUnknown> spCustError;
	DWORD			  dwLookupID;
	
};

template <class T, class RecordClass = ATLERRORINFO>
class IErrorRecordsImpl : public IErrorRecords
{
public:
    STDMETHOD(AddErrorRecord)( ERRORINFO *pErrorInfo, DWORD dwLookupID, DISPPARAMS *pdispparams, IUnknown *punkCustomError, DWORD)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::AddErrorRecord\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		ATLERRORINFO err;

		err.pInfo = pErrorInfo;
		err.dispparams = *pdispparams;
		err.spCustError = punkCustomError;
		err.dwLookupID = dwLookupID;

		//if (!m_rgErrors.Add(err)) 
		//	return E_OUTOFMEMORY;
		_ATLTRY
		{
			m_rgErrors.Add(err);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}
    
    STDMETHOD(GetBasicErrorInfo)( ULONG ulRecordNum, ERRORINFO *pErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetBasicErrorInfo\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pErrorInfo = *(m_rgErrors[ulRecordNum].pInfo);
		return S_OK;
	}
    
    STDMETHOD(GetCustomErrorObject)( ULONG ulRecordNum, REFIID riid, IUnknown **ppObject)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetCustomErrorObject\n"));
		if (ppObject == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		CComPtr<IUnknown> spUnkCust;
		spUnkCust = m_rgErrors[ulRecordNum].spCustError;
		return spUnkCust->QueryInterface(riid, (void**)ppObject);

	}
    
    STDMETHOD(GetErrorInfo)( ULONG ulRecordNum, LCID, IErrorInfo **ppErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorInfo\n"));

		if (ppErrorInfo == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;


		CComPtr<ICreateErrorInfo> spErrorInfo;

		if (FAILED(CreateErrorInfo(&spErrorInfo)))
			return E_OUTOFMEMORY;

		ERRORINFO& rInfo = *(m_rgErrors[ulRecordNum].pInfo);
		T* pT = (T*)this;
		spErrorInfo->SetDescription(pT->GetErrorDescriptionString(rInfo));
		spErrorInfo->SetGUID(pT->GetErrorGUID(rInfo)); 
		spErrorInfo->SetHelpContext(pT->GetErrorHelpContext(rInfo));
		spErrorInfo->SetHelpFile(pT->GetErrorHelpFile(rInfo));
		spErrorInfo->SetSource(pT->GetErrorSource(rInfo));
		return spErrorInfo->QueryInterface(__uuidof(IErrorInfo), (void**)ppErrorInfo);

	}
    
    STDMETHOD(GetErrorParameters)( ULONG ulRecordNum, DISPPARAMS *pdispparams)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::AddErrorRecord\n"));
		if (pdispparams == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pdispparams = m_rgErrors[ulRecordNum].dispparams;
		return S_OK;
	}
    
    STDMETHOD(GetRecordCount)(ULONG *pcRecords)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorParameters\n"));
		if (pcRecords == NULL)
			return E_INVALIDARG;
		*pcRecords = m_rgErrors.GetCount();
		return S_OK;
	}

	LPOLESTR GetErrorDescriptionString(ERRORINFO&)
	{
		return OLESTR("The Error Description String");
	}

	REFGUID GetErrorGUID(ERRORINFO&)
	{
		return GUID_NULL;
	}

	DWORD GetErrorHelpContext(ERRORINFO&)
	{
		return 0;
	}

	LPOLESTR GetErrorHelpFile(ERRORINFO&)
	{
		return OLESTR("The Error Help File");
	}

	LPOLESTR GetErrorSource(ERRORINFO&)
	{
		return OLESTR("The ErrorInfo");
	}

	CAtlArray<RecordClass> m_rgErrors;
};



class CTABLESRow
{
public:

	WCHAR m_szCatalog[129];
	WCHAR m_szSchema[129];
	WCHAR m_szTable[129];
	WCHAR m_szType[129];
	WCHAR m_szDesc[129];
	GUID  m_guid;
	ULONG m_ulPropID;
	DATE m_DateCreated;
	DATE m_DateModified;

	CTABLESRow()
	{
		wcscpy(&m_szCatalog[0], L"");
		wcscpy(&m_szSchema[0], L"");
		wcscpy(&m_szTable[0], L"");
		wcscpy(&m_szType[0], L"");
		wcscpy(&m_szDesc[0], L"");
		m_guid = GUID_NULL;
		m_ulPropID = 0;
		m_DateCreated = 0.0;
		m_DateModified = 0.0;
	}

BEGIN_PROVIDER_COLUMN_MAP(CTABLESRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTable)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_TYPE", 4, m_szType)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_GUID", 5, 0xFF, 0xFF, m_guid)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 6, m_szDesc)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_PROPID", 7, 10, 0xFF, m_ulPropID)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_CREATED", 8, DBTYPE_DATE, 0xFF, 0xFF, m_DateCreated)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_MODIFIED", 9, DBTYPE_DATE, 0xFF, 0xFF, m_DateModified)
END_PROVIDER_COLUMN_MAP()

};


class CCOLUMNSRow
{
public:

	WCHAR   m_szTableCatalog[129];
	WCHAR   m_szTableSchema[129];
	WCHAR   m_szTableName[129];
	WCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_ulColumnPropID;
	ULONG   m_ulOrdinalPosition;
	VARIANT_BOOL    m_bColumnHasDefault;
	WCHAR   m_szColumnDefault[129];
	ULONG   m_ulColumnFlags;
	VARIANT_BOOL    m_bIsNullable;
	USHORT  m_nDataType;
	GUID    m_guidType;
	ULONG   m_ulCharMaxLength;
	ULONG   m_ulCharOctetLength;
	USHORT  m_nNumericPrecision;
	short   m_nNumericScale;
	ULONG   m_ulDateTimePrecision;
	WCHAR   m_szCharSetCatalog[129];
	WCHAR   m_szCharSetSchema[129];
	WCHAR   m_szCharSetName[129];
	WCHAR   m_szCollationCatalog[129];
	WCHAR   m_szCollationSchema[129];
	WCHAR   m_szCollationName[129];
	WCHAR   m_szDomainCatalog[129];
	WCHAR   m_szDomainSchema[129];
	WCHAR   m_szDomainName[129];
	WCHAR   m_szDescription[129];

	CCOLUMNSRow()
	{
		ClearMembers();
	}

	void ClearMembers()
	{
		m_szTableCatalog[0] = NULL;
		m_szTableSchema[0] = NULL;
		m_szTableName[0] = NULL;
		m_szColumnName[0] = NULL;
		m_guidColumn = GUID_NULL;
		m_ulColumnPropID = 0;
		m_ulOrdinalPosition = 0;
		m_bColumnHasDefault = ATL_VARIANT_FALSE;
		m_szColumnDefault[0] = NULL;
		m_ulColumnFlags = 0;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_nDataType = 0;
		m_guidType = GUID_NULL;
		m_ulCharMaxLength = 0;
		m_ulCharOctetLength = 0;
		m_nNumericPrecision = 0;
		m_nNumericScale = 0;
		m_ulDateTimePrecision = 0;
		m_szCharSetCatalog[0] = NULL;
		m_szCharSetSchema[0] = NULL;
		m_szCharSetName[0] = NULL;
		m_szCollationCatalog[0] = NULL;
		m_szCollationSchema[0] = NULL;
		m_szCollationName[0] = NULL;
		m_szDomainCatalog[0] = NULL;
		m_szDomainSchema[0] = NULL;
		m_szDomainName[0] = NULL;
		m_szDescription[0] = NULL;
	}


BEGIN_PROVIDER_COLUMN_MAP(CCOLUMNSRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szTableCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szTableSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTableName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLUMN_NAME", 4, m_szColumnName)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_GUID", 5, 0xFF, 0xFF, m_guidColumn)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_PROPID",6, 10, 0xFF, m_ulColumnPropID)
	PROVIDER_COLUMN_ENTRY_PS("ORDINAL_POSITION",7, 10, 0xFF, m_ulOrdinalPosition)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("COLUMN_HASDEFAULT",8, DBTYPE_BOOL, 0xFF, 0xFF, m_bColumnHasDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_DEFAULT",9, 0xFF, 0xFF, m_szColumnDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_FLAGS",10, 10, 0xFF, m_ulColumnFlags)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE",11, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE",12, DBTYPE_UI2, 5, 0xFF, m_nDataType)
	PROVIDER_COLUMN_ENTRY_PS("TYPE_GUID",13, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_MAXIMUM_LENGTH",14, 10, 0xFF, m_ulCharMaxLength)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_OCTET_LENGTH",15, 10, 0xFF, m_ulCharOctetLength)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_PRECISION",16, 5, 0xFF, m_nNumericPrecision)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_SCALE",17, 5, 0xFF, m_nNumericScale)
	PROVIDER_COLUMN_ENTRY_PS("DATETIME_PRECISION",18, 10, 0xFF, m_ulDateTimePrecision)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_CATALOG", 19, m_szCharSetCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_SCHEMA", 20, m_szCharSetSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_NAME", 21, m_szCharSetName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_CATALOG", 22, m_szCollationCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_SCHEMA", 23, m_szCollationSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_NAME", 24, m_szCollationName)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_CATALOG", 25, m_szDomainCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_SCHEMA", 26, m_szDomainSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_NAME", 27, m_szDomainName)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 28, m_szDescription)
END_PROVIDER_COLUMN_MAP()
};

template <class ArrayClass>
HRESULT InitFromRowset(ArrayClass& rgData, DBID* pTableID, DBID* pIndexID, IUnknown* pSession, LONG* pcRowsAffected)
{
	CComQIPtr<IOpenRowset> spOpenRowset = pSession;
	if (spOpenRowset == NULL)
		return E_FAIL;
	CComPtr<IColumnsInfo> spColInfo;
	HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, __uuidof(IColumnsInfo), 0, NULL, (IUnknown**)&spColInfo);
	if (FAILED(hr))
		return hr;
	LPOLESTR szColumns = NULL;
	ULONG cColumns = 0;
	DBCOLUMNINFO* pColInfo = NULL;
	hr = spColInfo->GetColumnInfo(&cColumns, &pColInfo, &szColumns);
	if (FAILED(hr))
		return hr;
	*pcRowsAffected = 0;
	for (ULONG iCol = 0; iCol < cColumns;  iCol++)
	{
		CCOLUMNSRow crData;
		DBCOLUMNINFO& rColCur = pColInfo[iCol];
		lstrcpynW(crData.m_szTableName, pTableID->uName.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szTableName));
		lstrcpynW(crData.m_szColumnName, rColCur.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szColumnName));
		lstrcpynW(crData.m_szDescription, rColCur.pwszName, SIZEOF_MEMBER(CCOLUMNSRow, m_szColumnName));
		GUID* pGuidCol = CDBIDOps::GetDBIDpGuid(rColCur.columnid);
		if (pGuidCol)
			crData.m_guidColumn = *pGuidCol;
		else
			crData.m_guidColumn = GUID_NULL;
		crData.m_ulColumnPropID = CDBIDOps::GetPropIDFromDBID(rColCur.columnid);
		crData.m_ulOrdinalPosition = rColCur.iOrdinal;
		crData.m_ulColumnFlags = rColCur.dwFlags;					
		crData.m_bIsNullable = (rColCur.dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		crData.m_nDataType = rColCur.wType;
		crData.m_ulCharMaxLength = rColCur.ulColumnSize;
		crData.m_nNumericPrecision = rColCur.bPrecision;
		crData.m_nNumericScale = rColCur.bScale;
		//if (!rgData.Add(crData))
		//{
		//	CoTaskMemFree(pColInfo);
		//	CoTaskMemFree(szColumns);
		//	return E_OUTOFMEMORY;
		//}
		_ATLTRY
		{
			rgData.Add(crData);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			CoTaskMemFree(pColInfo);
			CoTaskMemFree(szColumns);
			return E_OUTOFMEMORY;
		}

		(*pcRowsAffected)++;
	}

	CoTaskMemFree(pColInfo);
	CoTaskMemFree(szColumns);
	return S_OK;
}

class CPROVIDER_TYPERow
{
public:
// Attributes
	WCHAR           m_szName[129];
	USHORT          m_nType;
	ULONG           m_ulSize;
	WCHAR           m_szPrefix[129];
	WCHAR           m_szSuffix[129];
	WCHAR           m_szCreateParams[129];
	VARIANT_BOOL    m_bIsNullable;
	VARIANT_BOOL    m_bCaseSensitive;
	ULONG			m_ulSearchable;
	VARIANT_BOOL    m_bUnsignedAttribute;
	VARIANT_BOOL    m_bFixedPrecScale;
	VARIANT_BOOL    m_bAutoUniqueValue;
	WCHAR           m_szLocalTypeName[129];
	short           m_nMinScale;
	short           m_nMaxScale;
	GUID            m_guidType;
	WCHAR           m_szTypeLib[129];
	WCHAR           m_szVersion[129];
	VARIANT_BOOL    m_bIsLong;
	VARIANT_BOOL    m_bBestMatch;
	VARIANT_BOOL	m_bIsFixedLength;


	CPROVIDER_TYPERow()
	{
		m_szName[0] = NULL;
		m_nType = 0;
		m_ulSize = 0;
		m_szPrefix[0] = NULL;
		m_szSuffix[0] = NULL;
		m_szCreateParams[0] = NULL;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_bCaseSensitive = ATL_VARIANT_FALSE;
		m_ulSearchable = DB_UNSEARCHABLE;
		m_bUnsignedAttribute = ATL_VARIANT_FALSE;
		m_bFixedPrecScale = ATL_VARIANT_FALSE;
		m_bAutoUniqueValue = ATL_VARIANT_FALSE;
		m_szLocalTypeName[0] = NULL;
		m_nMinScale = 0;
		m_nMaxScale = 0;
		m_guidType = GUID_NULL;
		m_szTypeLib[0] = NULL;
		m_szVersion[0] = NULL;
		m_bIsLong = ATL_VARIANT_FALSE;
		m_bBestMatch = ATL_VARIANT_FALSE;
		m_bIsFixedLength = ATL_VARIANT_FALSE;
	}
// Binding Maps
BEGIN_PROVIDER_COLUMN_MAP(CPROVIDER_TYPERow)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPE_NAME", 1, m_szName)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE", 2, DBTYPE_UI2, 5, 0xFF, m_nType)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_SIZE", 3, 10, 0xFF, m_ulSize)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_PREFIX", 4, m_szPrefix)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_SUFFIX", 5, m_szSuffix)
	PROVIDER_COLUMN_ENTRY_WSTR("CREATE_PARAMS", 6, m_szCreateParams)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE", 7, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("CASE_SENSITIVE", 8, DBTYPE_BOOL, 0xFF, 0xFF, m_bCaseSensitive)
	PROVIDER_COLUMN_ENTRY_PS("SEARCHABLE", 9, 10, 0xFF, m_ulSearchable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("UNSIGNED_ATTRIBUTE", 10, DBTYPE_BOOL, 0xFF, 0xFF, m_bUnsignedAttribute)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("FIXED_PREC_SCALE", 11, DBTYPE_BOOL, 0xFF, 0xFF, m_bFixedPrecScale)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("AUTO_UNIQUE_VALUE", 12, DBTYPE_BOOL, 0xFF, 0xFF, m_bAutoUniqueValue)
	PROVIDER_COLUMN_ENTRY_WSTR("LOCAL_TYPE_NAME", 13, m_szLocalTypeName)
	PROVIDER_COLUMN_ENTRY_PS("MINIMUM_SCALE", 14, 5, 0xFF, m_nMinScale)
	PROVIDER_COLUMN_ENTRY_PS("MAXIMUM_SCALE", 15, 5, 0xFF, m_nMaxScale)
	PROVIDER_COLUMN_ENTRY_PS("GUID", 16, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPELIB", 17, m_szTypeLib)
	PROVIDER_COLUMN_ENTRY_WSTR("VERSION", 18, m_szVersion)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_LONG", 19, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsLong)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("BEST_MATCH", 20, DBTYPE_BOOL, 0xFF, 0xFF, m_bBestMatch)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_FIXEDLENGTH", 21, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsFixedLength)
END_PROVIDER_COLUMN_MAP()
};


class CEnumRowsetImpl
{
public:

	WCHAR m_szSourcesName[256];
	WCHAR m_szSourcesParseName[256];
	WCHAR m_szSourcesDescription[256];
	unsigned short m_iType;
	VARIANT_BOOL m_bIsParent;

BEGIN_PROVIDER_COLUMN_MAP(CEnumRowsetImpl)
	PROVIDER_COLUMN_ENTRY("SOURCES_NAME", 1, m_szSourcesName)
	PROVIDER_COLUMN_ENTRY("SOURCES_PARSENAME", 2, m_szSourcesParseName)
	PROVIDER_COLUMN_ENTRY("SOURCES_DESCRIPTION", 3, m_szSourcesDescription)
	PROVIDER_COLUMN_ENTRY("SOURCES_TYPE", 4, m_iType)
	PROVIDER_COLUMN_ENTRY("SOURCES_ISPARENT", 5, m_bIsParent)
END_PROVIDER_COLUMN_MAP()

};


///////////////////////////////////////////////////////////////////////////
// class IRowsetUpdateImpl

template <class T, class Storage, 
			class UpdateArray = CAtlArray<Storage>, 
			class RowClass = CSimpleRow, 
			class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class IRowsetUpdateImpl : public IRowsetChangeImpl<T, Storage, IRowsetUpdate, RowClass, MapClass>
{
public:
	// Destructor
	~IRowsetUpdateImpl()
	{
		m_mapCachedData.RemoveAll();
	}

	// IRowsetChange Methods
	STDMETHOD (SetData)(HROW hRow, HACCESSOR hAccessor, void* pSrcData)
	{
		T* pT = (T*)this;

		__if_exists(T::Fire_OnFieldChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// We provide this implementation for use as it adds more 
		// complexity to the SetData function to handle both 
		// immediate and deferred processing.  It also allows us to 
		// cache the original data w/o increasing the size of 
		// IRowsetChangeImpl
		RowClass* pRow;
		HRESULT hr; 

		// Determine if we are in immediate or deferred mode, if we are in
		// immediate mode call FlushData.  Otherwise, add the orginal data
		// to the cache
		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, 
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;
		
		if( ! pT->m_rgRowHandles.Lookup(hRow, pRow) )
			return DB_E_BADROWHANDLE;

		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If we've deleted the row (or are pending) then SetData should fail
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		if (bDeferred)
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED && 
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;
				}
			}

			// If a row is soft inserted (i.e. haven't called update yet)
			// then ignore this section.  An undo will cause the row to
			// delete.
			if (pRow->m_status != DBPENDINGSTATUS_NEW)
			{
				// See if row is already cached, don't make any changes
				//void* pData = (void*)m_mapCachedData.Lookup(hRow, pTemp);
				Storage* pData;
				if (! m_mapCachedData.Lookup(hRow, pData) )
				{
					Storage* pam = NULL;
					ATLTRY(pam = new Storage);
					if (pam == NULL)
						return E_OUTOFMEMORY;
					memcpy(pam, &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));

					_ATLTRY
					{
						m_mapCachedData.SetAt(hRow, pam);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_FAIL;
					}
				}
			}
		}

		// NOTE: TransferData will send the SYNCHAFTER phase of the FIRSTCHANGE
		// notification message.  It will handle a veto internally.
		hr = TransferData<T, RowClass, MapClass>
						(pT, false, pSrcData, pRow, &(pT->m_rgRowHandles), hAccessor);
		if (FAILED(hr))
			return hr;

		// Flush Users Data, if in immediate mode
		if (!bDeferred)
		{
			HRESULT hrFlush = pT->FlushData(hRow, hAccessor);
			if (hrFlush == S_OK)
				return hr;  // TransferData may have returned DB_S_ERRORSOCCURRED
			else
				return hrFlush;
		}
		else
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED && 
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_DIDEVENT, TRUE);
				}
			}

			if (pRow->m_status != DBPENDINGSTATUS_NEW)
				pRow->m_status = DBPENDINGSTATUS_CHANGED;
			return hr;	// TransferData may have returned DB_S_ERRORSOCCURRED
		}
	}


	// IRowsetUpdate Methods
    STDMETHOD (GetOriginalData)(HROW hRow, HACCESSOR hAccessor, void* pData)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetOriginalData\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// Validate input parameters
		T::_BindType* pBinding;
		bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
		if (!bFound || pBinding == NULL)
			return DB_E_BADACCESSORHANDLE;

		if (pData == NULL && pBinding->cBindings != 0)
			return E_INVALIDARG;		

		RowClass* pRow;
		if (! pT->m_rgRowHandles.Lookup(hRow, pRow))
			return DB_E_BADROWHANDLE;
		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If the status is DBPENDINGSTATUS_INVALIDROW, the row has been
		// deleted and the change transmitted to the data source.  In 
		// this case, we can't get the original data so return
		// DB_E_DELETEDROW.
		if (pRow->m_status == DBPENDINGSTATUS_INVALIDROW)
			return DB_E_DELETEDROW;

		// Note, need to determine if accessor is not a row accessor


		// Determine if we have a pending insert. In this case, the
		// spec says revert to default values, and if defaults,
		// are not available, then NULLs.

		if (pRow->m_status == DBPENDINGSTATUS_NEW)
		{
			ATLCOLUMNINFO* pInfo;
			bool bSucceeded = true;
			bool bFailed = false;
			DBORDINAL ulColumns;
			Storage temp;
			memcpy(&temp, &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));
			
			pInfo = T::GetColumnInfo(pT, &ulColumns);

			for (ULONG lBind=0; lBind<pBinding->cBindings; lBind++)
			{
				DBBINDING* pBindCur = &(pBinding->pBindings[lBind]);
				ULONG lColInfo;
				for (lColInfo=0; lColInfo<ulColumns && 
					pBindCur->iOrdinal != pInfo[lColInfo].iOrdinal; lColInfo++);
				if (lColInfo == ulColumns)
					return DB_E_BADORDINAL;

				ATLCOLUMNINFO* pColCur = &(pInfo[lColInfo]);
				DBSTATUS dbStat = DBSTATUS_S_DEFAULT;

				// Try to get the default value.  if that doesn't work, then
				// attempt to do a NULL value
				if (FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
				{
					if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ||
						(pColCur->dwFlags & DBCOLUMNFLAGS_MAYBENULL))
					{
						BYTE* pDstTemp = (BYTE*)(&(pT->m_rgRowData[pRow->m_iRowset]) + pColCur->cbOffset);
						*pDstTemp = NULL;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_ISNULL;
						bSucceeded |= true;
						continue;
					}
					else
					{
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_E_UNAVAILABLE;
						bFailed = true;
						continue;
					}
				}
				else
				{
					if (pBindCur->dwPart & DBPART_STATUS)
						*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_OK;
					bSucceeded |= true;
					continue;
				}
			}

			TransferData<T, RowClass, MapClass>
					(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

			memcpy(&pT->m_rgRowData[pRow->m_iRowset], &temp, sizeof(Storage));
			if (!bFailed)
				return S_OK;
			else
				return (bSucceeded ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED);
		}

		// Determine if the row is cached, if so, we'll temporarily replace
		// it in m_rgRowData and call TransferData to handle the accessor.
		// It is kind of strange but it saves us from having to reimplement
		// TransferData					

		// REVIEW: Make the map a pointer based map or will this work?
		Storage* pam;
		bFound = m_mapCachedData.Lookup(hRow, pam);
		Storage temp;

		if (bFound && pam != NULL)
		{
			memcpy(&temp, &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));
			memcpy(&pT->m_rgRowData[pRow->m_iRowset], pam, sizeof(Storage));
		}

		// We need to trick TransferData to thinking a non-transmitted 
		// deleted row is still alive.  This will be its final state after
		// we return anyway.
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
			
		HRESULT hr = TransferData<T, RowClass, MapClass>
						(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

		if (bFound && pam != NULL)
		{
			memcpy(&pT->m_rgRowData[pRow->m_iRowset], &temp, sizeof(Storage));
		}

		pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
		return hr;
	}

	STDMETHOD (GetPendingRows)(HCHAPTER /*hReserved*/, DBPENDINGSTATUS dwRowStatus,
            DBCOUNTITEM * pcPendingRows, HROW **prgPendingRows, 
			DBPENDINGSTATUS **prgPendingStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetPendingRows\n"));
		T* pT = (T*)this;
		bool bPending = false;
		RowClass* pRow = NULL;
		//DBROWCOUNT ulRowHandles = (DBROWCOUNT)pT->m_rgRowHandles.GetCount();

		if (pcPendingRows != NULL)
		{
			*pcPendingRows = 0;

			if (prgPendingRows != NULL)
				*prgPendingRows = NULL;

			if (prgPendingStatus != NULL)
				*prgPendingStatus = NULL;
		}

		// Validate input parameters
		if ((dwRowStatus & 
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Validate input parameters
		if ((dwRowStatus & 
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Determine how many rows we'll need to return

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		while( pos != NULL )
		{
			MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
			ATLASSERT( pPair != NULL );

			// Check to see if a row has a pending status
			pRow = pPair->m_value;

			if (pRow->m_status & dwRowStatus)
			{
				if (pcPendingRows != NULL)
					(*pcPendingRows)++;
				bPending = true;
			}
		}
		/*
		for (ULONG iRowset = 0; iRowset < ulRowHandles; iRowset++)
		{
			// Check to see if a row has a pending status
			pRow = pT->m_rgRowHandles.GetValueAt(iRowset);
			if (pRow->m_status & dwRowStatus)
			{
				if (pcPendingRows != NULL)
					(*pcPendingRows)++;
				bPending = true;
			}
		}
		*/

		// In this case, there are no pending rows that match, just exit out
		if (!bPending)
		{
			// There are no pending rows so exit immediately
			return S_FALSE;
		}
		else
		{
			// Here' the consumer just wants to see if there are pending rows
			// we know that so we can exit
			if (pcPendingRows == NULL)
				return S_OK;
		}

		// Allocate arrays for pending rows
		if (prgPendingRows != NULL)
		{
			*prgPendingRows = (HROW*)CoTaskMemAlloc(*pcPendingRows * sizeof(HROW));
			if (*prgPendingRows == NULL)
			{
				*pcPendingRows = 0;
				return E_OUTOFMEMORY;
			}
		}

		if (prgPendingStatus != NULL)
		{
			*prgPendingStatus = (DBPENDINGSTATUS*)CoTaskMemAlloc(*pcPendingRows * sizeof(DBPENDINGSTATUS));
			if (*prgPendingStatus == NULL)
			{
				*pcPendingRows = 0;
				CoTaskMemFree(*prgPendingRows);
				*prgPendingRows = NULL;
				return E_OUTOFMEMORY;
			}
			memset(*prgPendingStatus, 0, *pcPendingRows * sizeof(DBPENDINGSTATUS));
		}

		if (prgPendingRows || prgPendingStatus)
		{
			ULONG ulRows = 0;
			pos = pT->m_rgRowHandles.GetStartPosition();
			while( pos != NULL )
			{
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
				ATLASSERT( pPair != NULL );

				pRow = pPair->m_value;
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = /*(HROW)*/pPair->m_key;
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			/*
			for (iRowset = 0; iRowset < ulRowHandles; iRowset++)
			{
				pRow = pT->m_rgRowHandles.GetValueAt(iRowset);
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = (HROW)pT->m_rgRowHandles.GetKeyAt(iRowset);
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			*/
			if (pcPendingRows != NULL)
				*pcPendingRows = ulRows;
		}

		// Return code depending on
		return S_OK;
	}
        
	STDMETHOD (GetRowStatus)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows, 
		const HROW rghRows[], DBPENDINGSTATUS rgPendingStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetRowStatus\n"));
		T* pT = (T*)this;

		bool bSucceeded = true;
		ULONG ulFetched = 0;

		if (cRows != 0)
		{
			// check for correct pointers
			if (rghRows == NULL || rgPendingStatus == NULL)
				return E_INVALIDARG;

			for (ULONG ulRows=0; ulRows < cRows; ulRows++)
			{
				RowClass* pRow;
				bool bFound = pT->m_rgRowHandles.Lookup(rghRows[ulRows], pRow);
				if ((! bFound || pRow == NULL) || (pRow->m_status == DBPENDINGSTATUS_INVALIDROW))
				{
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_INVALIDROW;
					bSucceeded = false;
					continue;
				}
				if (pRow->m_status != 0)
					rgPendingStatus[ulRows] = pRow->m_status;
				else
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_UNCHANGED;

				ulFetched++;
			}
		}

		if (bSucceeded)
		{
			return S_OK;
		}
		else
		{
			if (ulFetched > 0)
				return DB_S_ERRORSOCCURRED;
			else
				return DB_E_ERRORSOCCURRED;
		}
	}
        
	STDMETHOD (Undo)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows, const HROW rghRows[ ],
		DBCOUNTITEM *pcRowsUndone, HROW **prgRowsUndone, 
		DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Undo\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this up above as we may inadvertantly 
				// step on the pcRowsUndone variable.
				if (pcRowsUndone != NULL)
					*pcRowsUndone = NULL;			
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		DBCOUNTITEM ulRows = 0;
		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulUndone = 0;	

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky 
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRowsUndone;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		__if_exists(T::Fire_OnRowChange)
		{
			HRESULT hrNotify = S_OK;
			int nReason = 0;
		}

		// Ignore prgRowsUndone/prgRowStatus if pcRowsUndone is NULL and
		// cRows == 0.
		if (pcRowsUndone != NULL || cRows != 0)
		{
			if (prgRowsUndone != NULL)
				*prgRowsUndone = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;		
		}
		else
		{
			bIgnore = true;		// Don't do status or row arrays
		}

		// Check to see how many changes we'll undo 
		if (pcRowsUndone != NULL)
		{
			*pcRowsUndone = NULL;
			 if (prgRowsUndone == NULL)
				 return E_INVALIDARG;
		}


		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRows = cRows;
		}
		else
			ulRows = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRowsUndone != NULL && ulRows != 0 && bIgnore == false)
		{
			// Make a temporary buffer as we may not fill up everything
			// in the case where cRows == 0
			if (cRows != 0)
				*prgRowsUndone = (HROW*)CoTaskMemAlloc(ulRows * sizeof(HROW));
			else
			{
				//*prgRowsUndone = (HROW*)_alloca(ulRows * sizeof(HROW));
				spTempRowsUndone.Allocate(ulRows);
				*prgRowsUndone = spTempRowsUndone;
			}

			if (*prgRowsUndone == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRowsUndone != NULL && bIgnore == false)
				*prgRowsUndone = NULL;
		}

		if (prgRowStatus != NULL && ulRows != 0 && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)CoTaskMemAlloc(ulRows * sizeof(DBROWSTATUS));
			else
			{
				//*prgRowStatus = (DBROWSTATUS*)_alloca(ulRows * sizeof(DBROWSTATUS));
				spTempRowStatus.Allocate(ulRows);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);
				*prgRowsUndone = NULL;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		RowClass* pRow = NULL;
		for (ULONG ulUndoRow = 0; ulUndoRow < ulRows; ulUndoRow++)
		{
			HROW hRowUndo = NULL;
			ULONG ulCurrentRow = ulUndone;

			if (rghRows != NULL && cRows != 0)
			{
				hRowUndo = rghRows[ulUndoRow];
			}
			else
			{
				ATLASSERT(ulUndoRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				hRowUndo = pPair->m_key;
			}

			if (prgRowsUndone != NULL && bIgnore == false)
				(*prgRowsUndone)[ulCurrentRow] = hRowUndo;
			
			// Fetch the RowClass and determine if it is valid
			bool bFound = pT->m_rgRowHandles.Lookup(hRowUndo, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulUndone++;
				continue;
			}

			// If cRows is zero we'll go through all rows fetched.  We shouldn't
			// increment the count for rows that haven't been modified.

			if (cRows != 0 || (pRow != NULL &&
				pRow->m_status != 0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulUndone++;
			else
				continue;


			// AddRef the row if cRows is zero (we will be returning it to the
			// consumer)
			if (cRows == 0)
				pRow->AddRefRow();

			// Fetch the data, note, this may be NULL in several cases
			Storage* pData;
			if(! m_mapCachedData.Lookup(hRowUndo, pData) )
				pData = NULL;

//			long l = 0;

			switch (pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:	// Row has already been hard deleted
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_NEW:			// Row has been soft inserted
				// If the row is newly inserted, go ahead and mark its
				// row as INVALID (according to the specification).

				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_SYNCHAFTER, FALSE);
					
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pT->m_rgRowData.RemoveAt(pRow->m_iRowset);

				// Move any other subsequent rows up in the chain
//				for (l=0; l<pT->m_rgRowHandles.GetCount(); l++)
//				{
				{
					POSITION pos = pT->m_rgRowHandles.GetStartPosition();
					while(pos != NULL)
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
						ATLASSERT( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL && 
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}
				}

				pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				bSucceeded = true;

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOINSERT,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				continue;
				break;

			case 0:								// Row has just been fetched
			case DBPENDINGSTATUS_DELETED:		// Row has been soft deleted
			case DBPENDINGSTATUS_UNCHANGED:		// Row is not changed
				__if_exists(T::Fire_OnRowChange)
				{
					if (pRow->m_status == DBPENDINGSTATUS_DELETED)
					{
						nReason = 1;
						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_OKTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_ABOUTTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_SYNCHAFTER, FALSE);
						
						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}
					}
				}

				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				// Somebody set, then deleted a row most likely
				if (pData != NULL)
					memcpy(&pT->m_rgRowData[pRow->m_iRowset], pData, sizeof(Storage));

				__if_exists(T::Fire_OnRowChange)
				{
					if (nReason == 1)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDODELETE,
							DBEVENTPHASE_DIDEVENT, TRUE);
						nReason = 0;
					}
				}
				continue;
				break;

			default:							// Row has been changed
				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_SYNCHAFTER, FALSE);
					
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
							DBEVENTPHASE_FAILEDTODO, FALSE);
					}

					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// Copy data back
				memcpy(&pT->m_rgRowData[pRow->m_iRowset], pData, sizeof(Storage));
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				bSucceeded = true;

				// Remove undo buffer
				m_mapCachedData.RemoveKey(hRowUndo);

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUndo, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				break;
			}
		}
			
			
		// Set the output for rows undone.
		if (pcRowsUndone)
			*pcRowsUndone = ulUndone;

		// In the case where cRows == 0, we need to allocate the final
		// array of data.
		if (cRows == 0)
		{
			HROW* prowTemp = NULL;
			DBROWSTATUS* prowStatus = NULL;

			if (prgRowsUndone != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)CoTaskMemAlloc(ulUndone * sizeof(HROW));
				if (prowTemp == NULL)
				{
					// Free prgRowsUndone
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				memcpy(prowTemp, *prgRowsUndone, (sizeof(HROW)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);  // we're finished w/ the temp array
				*prgRowsUndone = prowTemp;
			}
			else
			{
				if (prgRowsUndone != NULL && bIgnore == false)
					*prgRowsUndone = NULL;
			}

			if (prgRowStatus != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)CoTaskMemAlloc(ulUndone * sizeof(DBROWSTATUS));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (prgRowStatus != NULL && cRows != 0)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				memcpy(prowStatus, *prgRowStatus, (sizeof(DBROWSTATUS)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}
        
	STDMETHOD (Update)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows,
		const HROW rghRows[], DBCOUNTITEM *pcRows, HROW **prgRows,
		DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Update\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				if (pcRows != NULL)
					*pcRows = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulCount = 0;
		DBCOUNTITEM ulRowUpdate = 0;

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky 
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRows;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		if (pcRows != NULL || cRows != NULL)
		{
			if (prgRows != NULL)
				*prgRows = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;
		}
		else
		{
			bIgnore = true;
		}

		if (pcRows != NULL)
		{
			*pcRows = NULL;
			if (prgRows == NULL)
				return E_INVALIDARG;
		}

		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRowUpdate = cRows;
		}
		else
			ulRowUpdate = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRows != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRows = (HROW*)CoTaskMemAlloc(ulRowUpdate * sizeof(HROW));
			else
			{
				//*prgRows = (HROW*)_alloca(ulRowUpdate * sizeof(HROW));
				spTempRows.Allocate(ulRowUpdate);
				*prgRows = spTempRows;
			}

			if (*prgRows == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRows != NULL && bIgnore == false)
				*prgRows = NULL;
		}

		if (prgRowStatus != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)CoTaskMemAlloc(ulRowUpdate * sizeof(DBROWSTATUS));
			else
			{
				//*prgRowStatus = (DBROWSTATUS*)_alloca(ulRowUpdate * sizeof(DBROWSTATUS));
				spTempRowStatus.Allocate(ulRowUpdate);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				CoTaskMemFree(*prgRows);
				*prgRows = NULL;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		// NOTE:  If cRows is zero, then we should ignore rghRows and 
		// update all of the rows in the cached map.
		RowClass* pRow = NULL;
		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		for (ULONG ulRow = 0; ulRow < ulRowUpdate; ulRow++)
		{
			void* pData = NULL;
			HROW hRowUpdate = NULL;
			ULONG ulAlreadyProcessed = 0;
			bool bDupRow = false;
			LONG ulCurrentRow = ulCount;

			// Fetch the HROW, RowClass, and Data for the row.  Perform
			// Validation as necessiary
			if (rghRows != NULL)
			{
				hRowUpdate = rghRows[ulRow];

				for (ULONG ulCheckDup = 0; ulCheckDup < ulRow; ulCheckDup++)
				{
					if (pT->IsSameRow(hRowUpdate, rghRows[ulCheckDup]) == S_OK)
					{
						ulAlreadyProcessed = ulCheckDup;
						bDupRow = true;
						break;
					}
				}
			}
			else
			{
				ATLASSERT(ulRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				hRowUpdate = pPair->m_key;
			}

			if (prgRows != NULL && bIgnore == false)
				(*prgRows)[ulCurrentRow] = hRowUpdate;


			if (bDupRow != false)
			{
				// We've already set the row before, just copy status and
				// continue processing
				//__if_exists(T::Fire_OnRowChange)
				//{
				//	pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
				//		DBEVENTPHASE_DIDEVENT, TRUE); 
				//}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = (*prgRowStatus)[ulAlreadyProcessed];

				ulCount++;
				continue;
			}

			bool bFound = pT->m_rgRowHandles.Lookup(hRowUpdate, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL  && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulCount++;
				continue;
			}

			// If the row is not UNCHANGED, send preliminary notifications before beginning processing
			if( pRow->m_status != 0 &&
				pRow->m_status != DBPENDINGSTATUS_UNCHANGED )
			{
				__if_exists(T::Fire_OnRowChange)
				{

					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_OKTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_ABOUTTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}
			}

			// If cRows is zero we'll go through all rows fetched.  We
			// shouldn't increment the attempted count for rows that are
			// not changed
			if (cRows != 0 || (pRow != NULL && 
				pRow->m_status !=0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulCount++;
			else
				continue;


			switch(pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:		// Row is bad or deleted
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
						DBEVENTPHASE_FAILEDTODO, TRUE); 
				}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_UNCHANGED:
			case 0:
				// If the row's status is not changed, then just put S_OK
				// and continue.  The spec says we should not transmit the
				// request to the data source (as nothing would change).
				//__if_exists(T::Fire_OnRowChange)
				//{
				//	pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
				//		DBEVENTPHASE_DIDEVENT, TRUE); 
				//}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;
				continue;
				break;

			default:
				pData = &pT->m_rgRowData[pRow->m_iRowset]; 

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// If the rghRows variable is NULL, we now add the row to 
				// prgRows.  We do this because we have determined that the
				// row has changed. AddRef the row as it may not be held by 
				// the consumer.
				if (rghRows == NULL)
					pRow->AddRefRow();

				// Ask the provider if it is OK to change this row.
				DBROWSTATUS status = DBROWSTATUS_S_OK;
				if (FAILED(IsUpdateAllowed(pRow->m_status, hRowUpdate, &status)))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = status;
					bFailed = true;
					continue;
				}

				if (pRow->m_status == DBPENDINGSTATUS_DELETED)
				{
					pT->m_rgRowData.RemoveAt(pRow->m_iRowset);
					// Need to update any outstanding pRow->m_iRowset
					// variables
					POSITION pos = pT->m_rgRowHandles.GetStartPosition();
					while( pos != NULL )
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
						ATLASSERT( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL && 
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}

					// Per the specification, deleted rows transmitted
					// to the data source are set to 
					// DBPENDINGSTATUS_INVALIDROW
					pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				}

				// Copy data back
				if (FAILED(pT->FlushData(hRowUpdate, NULL)))
				{
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_FAIL;
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					bFailed = true;
					continue;
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				if (pRow->m_status != DBPENDINGSTATUS_DELETED)
				{
					if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
						pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				}

				// Remove undo buffer.  
				if (m_mapCachedData.Lookup(hRowUpdate) != NULL)
					m_mapCachedData.RemoveKey(hRowUpdate);

				// remove the ref count if the consumer didn't have a handle.
//				if (rghRows == NULL)
//					pRow->ReleaseRow();

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUpdate, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
						DBEVENTPHASE_DIDEVENT, TRUE); 
				}

				break;

			}
		}

		// Set the output for rows undone.
		if (pcRows)
		{
			if( cRows==0 )
				*pcRows = ulCount;
			else
				*pcRows = cRows;
		}

		// In the case where cRows == 0, we need to allocate the final
		// array of HROWs and status values.
		if (cRows == 0)
		{
			HROW* prowTemp;
			DBROWSTATUS* prowStatus;

			if (prgRows != NULL && ulCount != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)CoTaskMemAlloc(ulCount * sizeof(HROW));
				if (prowTemp == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				memcpy(prowTemp, *prgRows, sizeof(HROW) * ulCount);
				if (cRows != 0)
					CoTaskMemFree(*prgRows);
				*prgRows = prowTemp;
			}
			else
			{
				if (prgRows != NULL && bIgnore == false)
					*prgRows = NULL;
			}

			if (prgRowStatus != NULL && ulCount != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)CoTaskMemAlloc(ulCount * sizeof(DBROWSTATUS));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				memcpy(prowStatus, *prgRowStatus, (sizeof(DBROWSTATUS)*ulCount));
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}


	// Callback functions
	HRESULT IsUpdateAllowed(DBPENDINGSTATUS /* [in] *//*status*/, 
				/*[in] */ HROW /*hRowUpdate*/, 
				/* [out] */ DBROWSTATUS* /*pRowStatus*/)
	{
		// If you need to perform any checks for security, integrity
		// violations, etc. as a result of an update, override this
		// method.

		// Make sure you put the appropriate status in the pRowStatus
		// as it will be returned to the user.
		return S_OK;
	}

	// Map containing original data for deferred operation
	CAtlMap<HROW, Storage*> m_mapCachedData;
};

}; //namespace ATL

#pragma warning(pop)

#endif //__ATLDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atldbgmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#if defined(__AFX_H__) || defined(__ATLBASE_H__)
#error atldbgmem.h must be included before other atl or mfc headers
#endif

#ifndef __ATLDBGMEM_H__
#define __ATLDBGMEM_H__

#pragma once

#pragma warning(push)

#pragma warning(disable: 4273)
#pragma warning(disable: 4127) // conditional expression is constant

#define _MFC_OVERRIDES_NEW
#define _CRTDBG_MAP_ALLOC
#include <new.h>
#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>
#include <stddef.h>
#include <tchar.h>
#include <atltrace.h>

namespace ATL
{

const DWORD atlDbgMemTrackIndividualAllocations = 0x1;
const DWORD atlDbgMemTrackAggregateStats        = 0x2;
const DWORD atlDbgMemTrackAll                   = 0x3;

struct AtlAllocRecord
{
	char szPath[_MAX_PATH];
	int nLine;
	int nSize;
	int nAllocations;
};

__declspec(selectany) DWORD g_dwFlags = atlDbgMemTrackIndividualAllocations;
__declspec(selectany) HANDLE g_hReportFile = NULL;
__declspec(selectany) HANDLE g_hMemMutex = NULL;
__declspec(selectany) AtlAllocRecord* g_pMemStats = NULL;
__declspec(selectany) int g_nAllocedRecords = 0;
__declspec(selectany) int g_nRecords = 0;

inline int __cdecl AtlNewHandler(size_t /* nSize */)
{
	return 0;
}

__declspec(selectany) _PNH _atlNewHandler = &AtlNewHandler;

inline _PNH AtlGetNewHandler(void)
{
	return _atlNewHandler;
}

inline _PNH AtlSetNewHandler(_PNH pfnNewHandler)
{
	_PNH pfnOldHandler = _atlNewHandler;
	_atlNewHandler = pfnNewHandler;
	return pfnOldHandler;
}

extern __declspec(selectany) const _PNH _pfnUninitialized = (_PNH)-1;

}; // namespace ATL

inline void* __cdecl operator new(size_t nSize)
{
	void* pResult;
	for (;;)
	{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		pResult = _malloc_dbg(nSize, _NORMAL_BLOCK, NULL, 0);
#else
		pResult = malloc(nSize);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
}

inline void __cdecl operator delete(void* p)
{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, _NORMAL_BLOCK);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](size_t nSize)
{
	return ::operator new(nSize);
}

inline void __cdecl operator delete[](void* p)
{
	::operator delete(p);
}

inline void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
#ifdef _ATL_NO_DEBUG_CRT
	UNUSED_ALWAYS(nType);
	UNUSED_ALWAYS(lpszFileName);
	UNUSED_ALWAYS(nLine);
	return ::operator new(nSize);
#else
	void* pResult;
	for (;;)
	{
		pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
#endif // _ATL_NO_DEBUG_CRT
}

inline void __cdecl operator delete(void* p, int nType, LPCSTR /* lpszFileName */, int /* nLine */)
{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, nType);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, nType, lpszFileName, nLine);
}

inline void __cdecl operator delete[](void* p, int nType, LPCSTR lpszFileName, int nLine)
{
	::operator delete(p, nType, lpszFileName, nLine);
}

inline void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new[](nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void __cdecl operator delete(void* pData, LPCSTR /* lpszFileName */, int /* nLine */)
{
	::operator delete(pData);
}

inline void __cdecl operator delete[](void* pData, LPCSTR /* lpszFileName */, int /* nLine */)
{
	::operator delete(pData);
}

namespace ATL
{

inline void* AtlAllocMemoryDebug(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void AtlFreeMemoryDebug(void* pbData)
{
	_free_dbg(pbData, _NORMAL_BLOCK);
}

#define new new(__FILE__, __LINE__)

/////////////////////////////////////////////////////////////////////////////
// allocation failure hook, tracking turn on

inline void _AtlDbgMemTrace(LPCSTR szBuf, int nLen)
{
	ATLTRACE(atlTraceAllocation, 0, szBuf);

	if (g_hReportFile && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		DWORD bytes;
		WriteFile(g_hReportFile, szBuf, nLen, &bytes, NULL);
		ReleaseMutex(g_hMemMutex);
	}
}

inline void _AtlRecordAllocation(LPCSTR szFileName, int nLine, LPCSTR szAllocType, int nSize, int nRequest = 0)
{
	char szBuf[512];
	int nLen;

	if (szFileName)
		nLen = _snprintf(szBuf, 512, "%s(%d): Memory operation: %s a %d-byte block (# %ld)\r\n",
			szFileName, nLine, szAllocType, nSize, nRequest);
	else
		nLen = _snprintf(szBuf, 512, "Memory operation: %s a %d-byte block (# %ld)\r\n", szAllocType, nSize, nRequest);

	if (g_dwFlags & atlDbgMemTrackIndividualAllocations)
		_AtlDbgMemTrace(szBuf, nLen);

	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		if (!szFileName)
			szFileName = "(null)";
		int nIndex = 0;
		while (nIndex < g_nRecords)
		{
			if (strncmp(g_pMemStats[nIndex].szPath, szFileName, _MAX_PATH) == 0 && g_pMemStats[nIndex].nLine == nLine && g_pMemStats[nIndex].nSize == nSize)
			{
				g_pMemStats[nIndex].nAllocations++;
				break;
			}
			nIndex++;
		}

		if (nIndex == g_nRecords)
		{
			if (g_nAllocedRecords == g_nRecords)
			{
				int nNewAllocSize = g_nAllocedRecords * 2;
				AtlAllocRecord* p = (AtlAllocRecord*) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_pMemStats, nNewAllocSize*sizeof(AtlAllocRecord));
				if (p == NULL)
				{
					ATLASSERT(FALSE);
					ReleaseMutex(g_hMemMutex);
					return; // out of memory
				}
				g_pMemStats = p;
				g_nAllocedRecords = nNewAllocSize;
			}
			strncpy(g_pMemStats[nIndex].szPath, szFileName, _MAX_PATH);
			g_pMemStats[nIndex].szPath[_MAX_PATH-1] = 0;
			g_pMemStats[nIndex].nLine = nLine;
			g_pMemStats[nIndex].nSize = nSize;
			g_pMemStats[nIndex].nAllocations = 1;
			g_nRecords++;
		}

		ReleaseMutex(g_hMemMutex);
	}
}

inline int __cdecl _AtlAllocReportHook(int nAllocType, void* /* pvData */, size_t nSize, int nBlockUse, long lRequest,
	const unsigned char* szFileName, int nLine)
{
	char *operation[] = { "", "allocating", "re-allocating", "freeing" };

	if (nBlockUse == _CRT_BLOCK)   // Ignore internal C runtime library allocations
		return TRUE;

#pragma warning(disable: 4127)
	_ASSERTE((nAllocType > 0) && (nAllocType < 4));
	_ASSERTE((nBlockUse >= 0) && (nBlockUse < 5));

	_AtlRecordAllocation((LPCSTR) szFileName, nLine, operation[nAllocType], nSize, lRequest);

	return TRUE;         // Allow the memory operation to proceed
}

extern __declspec(selectany) _CRT_ALLOC_HOOK pfnCrtAllocHook = NULL;

inline void AtlSetAllocHook()
{
	if (pfnCrtAllocHook == NULL)
		pfnCrtAllocHook = _CrtSetAllocHook(_AtlAllocReportHook);
}

inline void AtlSetReportFile(HANDLE hReportFile)
{
	if (g_hMemMutex == NULL)
		g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

	if (g_hMemMutex != NULL)
		g_hReportFile = hReportFile;
}

inline void AtlEnableAllocationTracking(DWORD dwFlags = atlDbgMemTrackAll)
{
	g_dwFlags = dwFlags;
	
	if (dwFlags & atlDbgMemTrackAggregateStats)
	{
		if (g_hMemMutex == NULL)
			g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

		if (g_pMemStats == NULL && g_hMemMutex != NULL)
		{
			g_pMemStats = (AtlAllocRecord*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 128*sizeof(AtlAllocRecord));
			g_nAllocedRecords = 128;
			g_nRecords = 0;
		}
	}
}

inline BOOL AtlDumpMemoryStats()
{
	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		char szBuf[512];

		int nLen = _snprintf(szBuf, 512, "%d records in dump:\r\n", g_nRecords);
		_AtlDbgMemTrace(szBuf, nLen);

		for (int n=0; n<g_nRecords; n++)
		{
			int nLen = _snprintf(szBuf, 512, "%s(%d): %d operations of size %d\r\n",
				g_pMemStats[n].szPath,
				g_pMemStats[n].nLine,
				g_pMemStats[n].nAllocations,
				g_pMemStats[n].nSize);
			_AtlDbgMemTrace(szBuf, nLen);
		}
		ReleaseMutex(g_hMemMutex);
	}

	return TRUE;
}

// This can be set to TRUE to override all AtlEnableMemoryTracking calls,
// allowing all allocations to be tracked.
BOOL _atlMemoryLeakOverride = FALSE;

inline BOOL AtlEnableMemoryTracking(BOOL bTrack)
{
	if (_atlMemoryLeakOverride)
		return TRUE;

	int nOldState = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	if (bTrack)
		_CrtSetDbgFlag(nOldState | _CRTDBG_ALLOC_MEM_DF);
	else
		_CrtSetDbgFlag(nOldState & ~_CRTDBG_ALLOC_MEM_DF);
	return nOldState & _CRTDBG_ALLOC_MEM_DF;
}

/////////////////////////////////////////////////////////////////////////////
// stop on a specific memory request

// Obsolete API
inline void AtlSetAllocStop(LONG lRequestNumber)
{
	_CrtSetBreakAlloc(lRequestNumber);
}

// check all of memory (look for memory tromps)
inline BOOL AtlCheckMemory()
{
	return _CrtCheckMemory();
}

// -- true if block of exact size, allocated on the heap
// -- set *plRequestNumber to request number (or 0)
inline BOOL AtlIsMemoryBlock(const void* pData, UINT nBytes,
		LONG* plRequestNumber)
{
	return _CrtIsMemoryBlock(pData, nBytes, plRequestNumber, NULL, NULL);
}

inline BOOL AtlDumpMemoryLeaks()
{
	return _CrtDumpMemoryLeaks();
}

/////////////////////////////////////////////////////////////////////////////

inline HANDLE __stdcall _AtlHeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapCreate", 0);
	return HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

inline BOOL __stdcall _AtlHeapDestroy(HANDLE hHeap, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapDestroy", 0);
	return HeapDestroy(hHeap);
}

inline LPVOID __stdcall _AtlHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T nSize, LPCSTR lpszFileName, int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapAlloc(hHeap, dwFlags, nSize);
#endif
	_AtlRecordAllocation(lpszFileName, nLine, "HeapAlloc", nSize);
	return p;
}

inline LPVOID __stdcall _AtlHeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T nSize, LPCSTR lpszFileName, int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _realloc_dbg(lpMem, nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapReAlloc(hHeap, dwFlags, lpMem, nSize);
#endif

	_AtlRecordAllocation(lpszFileName, nLine, "HeapReAlloc", nSize);
	return p;
}

inline BOOL __stdcall _AtlHeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapFree", 0);
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	_free_dbg(lpMem, _NORMAL_BLOCK);
	return TRUE;
#else
	return HeapFree(hHeap, dwFlags, lpMem);
#endif
}

inline DWORD __stdcall _AtlHeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapSize", 0);
	return HeapSize(hHeap, dwFlags, lpMem);
}

inline BOOL __stdcall _AtlHeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapValidate", 0);
	return HeapValidate(hHeap, dwFlags, lpMem);
}

inline LPVOID __stdcall _AtlVirtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualAlloc", dwSize);
	return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

inline BOOL __stdcall _AtlVirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualFree", 0);
	return VirtualFree(lpAddress, dwSize, dwFreeType);
}

inline DWORD __stdcall _AtlVirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualQuery", 0);
	return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

#define HeapCreate(flOptions, dwInitialSize, dwMaximumSize) ATL::_AtlHeapCreate(flOptions, dwInitialSize, dwMaximumSize, __FILE__, __LINE__)
#define HeapDestroy(hHeap) ATL::_AtlHeapDestroy(hHeap, __FILE__, __LINE__)
#define HeapAlloc(hHeap, dwFlags, nSize) ATL::_AtlHeapAlloc(hHeap, dwFlags, nSize, __FILE__, __LINE__)
#define HeapReAlloc(hHeap, dwFlags, lpMem, nSize) ATL::_AtlHeapReAlloc(hHeap, dwFlags, lpMem, nSize, __FILE__, __LINE__)
#define HeapFree(hHeap, dwFlags, lpMem) ATL::_AtlHeapFree(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapSize(hHeap, dwFlags, lpMem) ATL::_AtlHeapSize(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapValidate(hHeap, dwFlags, lpMem) ATL::_AtlHeapValidate(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect) ATL::_AtlVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect, __FILE__, __LINE__)
#define VirtualFree(lpAddress,  dwSize, dwFreeType) ATL::_AtlVirtualFree(lpAddress,  dwSize, dwFreeType, __FILE__, __LINE__)
#define VirtualQuery(lpAddress, lpBuffer, dwLength) ATL::_AtlVirtualQuery(lpAddress, lpBuffer, dwLength, __FILE__, __LINE__)

}; // namespace ATL

#pragma warning(pop)

#endif // __ATLDBGMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atldebugapi.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.


#ifndef __ATLDEBUGAPI_H__
#define __ATLDEBUGAPI_H__

#pragma once

#ifdef __cplusplus
namespace ATL
{
extern "C" {
#endif
#define ATL_TRACE_MAX_NAME_SIZE 64

typedef enum ATLTRACESTATUS
{
	ATLTRACESTATUS_INHERIT, ATLTRACESTATUS_ENABLED, ATLTRACESTATUS_DISABLED
} ATLTRACESTATUS;

DWORD_PTR __stdcall AtlTraceOpenProcess( DWORD idProcess );
void __stdcall AtlTraceCloseProcess( DWORD_PTR dwProcess );
void __stdcall AtlTraceSnapshotProcess( DWORD_PTR dwProcess );

DWORD_PTR __stdcall AtlTraceRegister(HINSTANCE hInst,
	int (__cdecl *fnCrtDbgReport)(int,const char *,int,const char *,const char *,...));
BOOL __stdcall AtlTraceUnregister(DWORD_PTR dwModule);

DWORD_PTR __stdcall AtlTraceRegisterCategoryA(DWORD_PTR dwModule, const CHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);
DWORD_PTR __stdcall AtlTraceRegisterCategoryU(DWORD_PTR dwModule, const WCHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);

BOOL __stdcall AtlTraceModifyProcess(DWORD_PTR dwProcess, UINT nLevel, BOOL bEnabled, BOOL bFuncAndCategoryNames, BOOL bFileNameAndLineNo);
BOOL __stdcall AtlTraceModifyModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT nLevel, ATLTRACESTATUS eStatus);
BOOL __stdcall AtlTraceModifyCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory, UINT nLevel, ATLTRACESTATUS eStatus);
BOOL __stdcall AtlTraceGetProcess(DWORD_PTR dwProcess, UINT *pnLevel, BOOL *pbEnabled, BOOL *pbFuncAndCategoryNames, BOOL *pbFileNameAndLineNo);
BOOL __stdcall AtlTraceGetModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT *pnLevel, ATLTRACESTATUS *pStatus);
BOOL __stdcall AtlTraceGetCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory, UINT *pnLevel, ATLTRACESTATUS *pStatus);

void __stdcall AtlTraceGetUpdateEventNameA(CHAR *pszEventName);
void __stdcall AtlTraceGetUpdateEventNameU(WCHAR *pszEventName);

/*void __cdecl AtlTraceA(HINSTANCE hInst, UINT nCategory, UINT nLevel, const CHAR *pszFormat, ...);
void __cdecl AtlTraceU(HINSTANCE hInst, UINT nCategory, UINT nLevel, const WCHAR *pszFormat, ...);*/

void __cdecl AtlTraceVA(DWORD_PTR dwModule, const char *pszFileName, int nLineNo,
						DWORD_PTR dwCategory, UINT nLevel, const CHAR *pszFormat, va_list ptr);
void __cdecl AtlTraceVU(DWORD_PTR dwModule,const char *pszFileName, int nLineNo,
						DWORD_PTR dwCategory, UINT nLevel, const WCHAR *pszFormat, va_list ptr);

BOOL __stdcall AtlTraceLoadSettingsA(const CHAR *pszFileName, BOOL bForceLoad);
BOOL __stdcall AtlTraceLoadSettingsU(const WCHAR *pszFileName, BOOL bForceLoad);
BOOL __stdcall AtlTraceSaveSettingsA(const CHAR *pszFileName);
BOOL __stdcall AtlTraceSaveSettingsU(const WCHAR *pszFileName);

typedef struct ATLTRACESETTINGS
{
	UINT nLevel;
	ATLTRACESTATUS eStatus;
} ATLTRACESETTINGS;

typedef struct ATLTRACEPROCESSSETTINGS
{
	UINT nLevel;
	BOOL bEnabled, bFuncAndCategoryNames, bFileNameAndLineNo;
} ATLTRACEPROCESSSETTINGS;

typedef struct ATLTRACEPROCESSINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE], szPath[MAX_PATH];
	DWORD dwId;
	ATLTRACEPROCESSSETTINGS settings;
	int nModules;
} ATLTRACEPROCESSINFO;

typedef struct ATLTRACEMODULEINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE], szPath[MAX_PATH];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwModule;
	int nCategories;
} ATLTRACEMODULEINFO;

typedef struct ATLTRACECATEGORYINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwCategory;
} ATLTRACECATEGORYINFO;

BOOL __stdcall AtlTraceGetProcessInfo(DWORD_PTR dwProcess, ATLTRACEPROCESSINFO* pProcessInfo);
void __stdcall AtlTraceGetModuleInfo(DWORD_PTR dwProcess, int iModule, ATLTRACEMODULEINFO* pModuleInfo);
void __stdcall AtlTraceGetCategoryInfo(DWORD_PTR dwProcess, DWORD_PTR dwModule, int iCategory, ATLTRACECATEGORYINFO* pAtlTraceCategoryInfo);

#ifdef UNICODE
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryU
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameU
#define AtlTrace AtlTraceU
#define AtlTraceV AtlTraceVU
#define AtlTraceLoadSettings AtlTraceLoadSettingsU
#define AtlTraceSaveSettings AtlTraceSaveSettingsU

#else
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryA
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameA
#define AtlTrace AtlTraceA
#define AtlTraceV AtlTraceVA
#define AtlTraceLoadSettings AtlTraceLoadSettingsA
#define AtlTraceSaveSettings AtlTraceSaveSettingsA

#endif

#ifdef __cplusplus
};

};  // namespace ATL
#endif

#endif  // __ATLDEBUGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#pragma once

#include <atlres.h>

#ifndef RC_INVOKED

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
	#error ATL not currently supported for CE
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef _WIN64
#define _ATL_SUPPORT_VT_I8  // Always support VT_I8 on Win64.
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLVERIFY
#ifdef _DEBUG
#define ATLVERIFY(expr) ATLASSERT(expr)
#else
#define ATLVERIFY(expr) (expr)
#endif // DEBUG
#endif // ATLVERIFY

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DISABLE_NOTHROW
#define ATL_NOTHROW
#else
#define ATL_NOTHROW __declspec(nothrow)
#endif

#ifdef _ATL_DISABLE_FORCEINLINE
#define ATL_FORCEINLINE
#else
#define ATL_FORCEINLINE __forceinline
#endif

#ifdef _ATL_DISABLE_NOINLINE
#define ATL_NOINLINE
#else
#define ATL_NOINLINE __declspec( noinline )
#endif

//#define _ATL_DISABLE_DEPRECATED  //REVIEW: Waiting for recent compiler

#ifdef _ATL_DISABLE_DEPRECATED
#define ATL_DEPRECATED
#else
#define ATL_DEPRECATED __declspec( deprecated )
#endif

// If ATL70.DLL is being used then _ATL_STATIC_REGISTRY doesn't really make sense
#ifdef _ATL_DLL
#undef _ATL_STATIC_REGISTRY
#else
// If not linking to ATL70.DLL, use the static registrar and not building atl.dll
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#endif
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _DEBUG
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" inline HRESULT __stdcall
	#define ATLAPI_(x) extern "C" inline x __stdcall
	#define ATLINLINE
#else
	#define ATLAPI ATL_NOTHROW HRESULT __stdcall
	#define ATLAPI_(x) ATL_NOTHROW x __stdcall
	#define ATLINLINE inline
#endif

#ifdef _ATL_NO_EXCEPTIONS
	#ifdef _AFX
	#error MFC projects cannot define _ATL_NO_EXCEPTIONS
	#endif
#else
	#ifndef _CPPUNWIND
	#define _ATL_NO_EXCEPTIONS
	#endif
#endif

#ifdef _CPPUNWIND

#ifndef ATLTRYALLOC

#ifdef _AFX
#define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
#else
#define ATLTRYALLOC(x) try{x;} catch(...){}
#endif	//__AFX

#endif	//ATLTRYALLOC

// If you define _ATLTRY before including this file, then
// you should define _ATLCATCH and _ATLRETHROW as well.
#ifndef _ATLTRY
#define _ATLTRY try
#ifdef _AFX
#define _ATLCATCH( e ) catch( CException* e )
#else
#define _ATLCATCH( e ) catch( CAtlException e )
#endif

#define _ATLCATCHALL() catch( ... )

#ifdef _AFX
#define _ATLDELETEEXCEPTION(e) e->Delete();
#else
#define _ATLDELETEEXCEPTION(e) e;
#endif

#define _ATLRETHROW throw
#endif	// _ATLTRY

#else //_CPPUNWIND

#ifndef ATLTRYALLOC
#define ATLTRYALLOC(x) x;
#endif	//ATLTRYALLOC

// if _ATLTRY is defined before including this file then 
// _ATLCATCH and _ATLRETHROW should be defined as well.
#ifndef _ATLTRY
#define _ATLTRY
#define _ATLCATCH( e ) __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLDELETEEXCEPTION(e)
#define _ATLRETHROW
#endif	// _ATLTRY

#endif	//_CPPUNWIND

#ifndef ATLTRY
#define ATLTRY(x) ATLTRYALLOC(x)
#endif	//ATLTRY

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0700 // Active Template Library version 7.0

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

// UUIDOF
#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#endif // RC_INVOKED

#define ATLAXWIN_CLASS	"AtlAxWin7"
#define ATLAXWINLIC_CLASS "AtlAxWinLic7"

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlenc.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLENC_H__
#define __ATLENC_H__

#pragma once

#include <atlbase.h>
#include <stdio.h>

namespace ATL {

//Not including CRLFs
//NOTE: For BASE64 and UUENCODE, this actually
//represents the amount of unencoded characters
//per line
#define ATLSMTP_MAX_QP_LINE_LENGTH       76
#define ATLSMTP_MAX_BASE64_LINE_LENGTH   57
#define ATLSMTP_MAX_UUENCODE_LINE_LENGTH 45



//=======================================================================
// Base64Encode/Base64Decode
// compliant with RFC 2045
//=======================================================================
//
#define ATL_BASE64_FLAG_NONE	0
#define ATL_BASE64_FLAG_NOPAD	1
#define ATL_BASE64_FLAG_NOCRLF  2

inline int Base64EncodeGetRequiredLength(int nSrcLen, DWORD dwFlags=ATL_BASE64_FLAG_NONE) throw()
{
	int nRet = nSrcLen*4/3;

	if ((dwFlags & ATL_BASE64_FLAG_NOPAD) == 0)
		nRet += nSrcLen % 3;

	int nCRLFs = nRet / 76;
	int nOnLastLine = nRet % 76;
	if (nOnLastLine)
	{
		nCRLFs++;
		if (nOnLastLine % 4)
			nRet += 4-(nOnLastLine % 4);
	}
	nCRLFs *= 2;

	if ((dwFlags & ATL_BASE64_FLAG_NOCRLF) == 0)
		nRet += nCRLFs;

	return nRet+1;
}

inline int Base64DecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}

inline BOOL Base64Encode(
	const BYTE *pbSrcData,
	int nSrcLen,
	LPSTR szDest,
	int *pnDestLen,
	DWORD dwFlags=ATL_BASE64_FLAG_NONE) throw()
{
	static const char s_chBase64EncodingTable[64] = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',	'h',
		'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
		'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= Base64EncodeGetRequiredLength(nSrcLen, dwFlags));

	int nWritten( 0 );
	int nLen1( (nSrcLen/3)*4 );
	int nLen2( nLen1/76 );
	int nLen3( 19 );

	for (int i=0; i<=nLen2; i++)
	{
		if (i==nLen2)
			nLen3 = (nLen1%76)/4;

		for (int j=0; j<nLen3; j++)
		{
			DWORD dwCurr(0);
			for (int n=0; n<3; n++)
			{
				dwCurr |= *pbSrcData++;
				dwCurr <<= 8;
			}
			for (int k=0; k<4; k++)
			{
				BYTE b = (BYTE)(dwCurr>>26);
				*szDest++ = s_chBase64EncodingTable[b];
				dwCurr <<= 6;
			}
		}
		nWritten+= nLen3*4;

		if ((dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
		{
			*szDest++ = '\r';
			*szDest++ = '\n';
			nWritten+= 2;
		}
	}

	nLen2 = nSrcLen%3 ? nSrcLen%3 + 1 : 0;
	if (nLen2)
	{
		if ((dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
		{
			szDest-= 2;
			nWritten-= 2;
		}
		DWORD dwCurr(0);
		for (int n=0; n<3; n++)
		{
			if (n<(nSrcLen%3))
				dwCurr |= *pbSrcData++;
			dwCurr <<= 8;
		}
		for (int k=0; k<nLen2; k++)
		{
			BYTE b = (BYTE)(dwCurr>>26);
			*szDest++ = s_chBase64EncodingTable[b];
			dwCurr <<= 6;
		}
		nWritten+= nLen2;
		if ((dwFlags & ATL_BASE64_FLAG_NOPAD)==0)
		{
			nLen3 = nLen2 ? 4-nLen2 : 0;
			for (int j=0; j<nLen3; j++)
			{
				*szDest++ = '=';
			}
			nWritten+= nLen3;
		}
		if ((dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
		{
			*szDest++ = '\r';
			*szDest++ = '\n';
			nWritten+= 2;
		}
	}

	*pnDestLen = nWritten;
	return TRUE;
}

inline int DecodeBase64Char(unsigned int ch) throw()
{
	// returns -1 if the character is invalid
	// or should be skipped
	// otherwise, returns the 6-bit code for the character
	// from the encoding table
	if (ch >= 'A' && ch <= 'Z')
		return ch - 'A' + 0;	// 0 range starts at 'A'
	if (ch >= 'a' && ch <= 'z')
		return ch - 'a' + 26;	// 26 range starts at 'a'
	if (ch >= '0' && ch <= '9')
		return ch - '0' + 52;	// 52 range starts at '0'
	if (ch == '+')
		return 62;
	if (ch == '/')
		return 63;
	return -1;
}

inline BOOL Base64Decode(LPCSTR szSrc, int nSrcLen, BYTE *pbDest, int *pnDestLen) throw()
{
	// walk the source buffer
	// each four character sequence is converted to 3 bytes
	// CRLFs and =, and any characters not in the encoding table
	// are skiped

	if (!szSrc || !pbDest || !pnDestLen)
	{
		return FALSE;
	}

	LPCSTR szSrcEnd = szSrc + nSrcLen;
	int nWritten = 0;
	while (szSrc < szSrcEnd)
	{
		DWORD dwCurr = 0;
		int i;
		int nBits = 0;
		for (i=0; i<4; i++)
		{
			if (szSrc >= szSrcEnd)
				break;
			int nCh = DecodeBase64Char(*szSrc);
			szSrc++;
			if (nCh == -1)
			{
				// skip this char
				i--;
				continue;
			}
			dwCurr <<= 6;
			dwCurr |= nCh;
			nBits += 6;
		}
		// dwCurr has the 3 bytes to write to the output buffer
		// left to right
		dwCurr <<= 24-nBits;
		for (i=0; i<nBits/8; i++)
		{
			*pbDest = (BYTE) ((dwCurr & 0x00ff0000) >> 16);
			dwCurr <<= 8;
			pbDest++;
			nWritten++;
		}
	}

	*pnDestLen = nWritten;
	return TRUE;
}


//=======================================================================
// UUEncode/UUDecode
// compliant with POSIX P1003.2b/D11
//=======================================================================
//
//Flag to determine whether or not we should encode the header
#define ATLSMTP_UUENCODE_HEADER 1

//Flag to determine whether or not we should encode the end
#define ATLSMTP_UUENCODE_END    2

//Flag to determine whether or not we should do data stuffing
#define ATLSMTP_UUENCODE_DOT    4

//The the (rough) required length of the uuencoded stream based
//on input of length nSrcLen
inline int UUEncodeGetRequiredLength(int nSrcLen) throw()
{
	int nRet = nSrcLen*4/3;
	nRet += 3*(nSrcLen/ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
	nRet += 12+_MAX_FNAME;
	nRet += 8;
	return nRet;
}

//Get the decode required length
inline int UUDecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}


//encode a chunk of data
inline BOOL UUEncode(
	const BYTE* pbSrcData,
	int nSrcLen,
	LPSTR szDest,
	int* pnDestLen,
	LPCTSTR lpszFile = _T("file"),
	DWORD dwFlags = 0) throw()
{	
	//The UUencode character set
	static const char s_chUUEncodeChars[64] = {
		'`','!','"','#','$','%','&','\'','(',')','*','+',',',
		'-','.','/','0','1','2','3','4','5','6','7','8','9',
		':',';','<','=','>','?','@','A','B','C','D','E','F',
		'G','H','I','J','K','L','M','N','O','P','Q','R','S',
		'T','U','V','W','X','Y','Z','[','\\',']','^','_'
	};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= UUEncodeGetRequiredLength(nSrcLen));

	BYTE ch1 = 0, ch2 = 0, ch3 = 0;
	int nTotal = 0, nCurr = 0, nWritten = 0, nCnt = 0;

	//if ATL_UUENCODE_HEADER
	//header
	if (dwFlags & ATLSMTP_UUENCODE_HEADER)
	{
		//default permission is 666
		nWritten = sprintf(szDest, "begin 666 %s\r\n", (LPCSTR)(CT2CAEX<MAX_PATH+1>( lpszFile )));
		szDest += nWritten;
	}

	//while we haven't reached the end of the data
	while (nTotal < nSrcLen)
	{
		//If the amount of data is greater than MAX_UUENCODE_LINE_LENGTH
		//cut off at MAX_UUENCODE_LINE_LENGTH
		if (nSrcLen-nTotal >= ATLSMTP_MAX_UUENCODE_LINE_LENGTH)
			nCurr = ATLSMTP_MAX_UUENCODE_LINE_LENGTH;
		else 
			nCurr = nSrcLen-nTotal+1;

		nCnt = 1;
		if (nCurr < ATLSMTP_MAX_UUENCODE_LINE_LENGTH)
			*szDest = (char)(nCurr+31);
		else
			*szDest = (char)(nCurr+32);
		nWritten++;
		//if we need to stuff an extra dot (e.g. when we are sending via SMTP), do it
		if ((dwFlags & ATLSMTP_UUENCODE_DOT) && *szDest == '.')
		{
			*(++szDest) = '.';
			nWritten++;
		}
		szDest++;
		while (nCnt < nCurr)
		{
			//Set to 0 in the uuencoding alphabet
			ch1 = ch2 = ch3 = ' ';
			ch1 = *pbSrcData++;
			nCnt++; 
			nTotal++; 
			if (nTotal < nSrcLen)
			{
				ch2 = *pbSrcData++;
				nCnt++; 
				nTotal++;
			}
			if (nTotal < nSrcLen)
			{
				ch3 = *pbSrcData++;
				nCnt++; 
				nTotal++;
			}

			//encode the first 6 bits of ch1
			*szDest++ = s_chUUEncodeChars[(ch1 >> 2) & 0x3F];
			//encode the last 2 bits of ch1 and the first 4 bits of ch2
			*szDest++ = s_chUUEncodeChars[((ch1 << 4) & 0x30) | ((ch2 >> 4) & 0x0F)];
			//encode the last 4 bits of ch2 and the first 2 bits of ch3
			*szDest++ = s_chUUEncodeChars[((ch2 << 2) & 0x3C) | ((ch3 >> 6) & 0x03)];
			//encode the last 6 bits of ch3
			*szDest++ = s_chUUEncodeChars[ch3 & 0x3F];
			nWritten += 4;
		}
		//output a CRLF
		*szDest++ = '\r'; 
		*szDest++ = '\n'; 
		nWritten += 2;
	}

	//if we need to encode the end, do it
	if (dwFlags & ATLSMTP_UUENCODE_END)
	{
		*szDest++ = '`'; 
		*szDest++ = '\r';
		*szDest++ = '\n';
		nWritten += 3;
		nWritten += sprintf(szDest, "end\r\n");
	}
	*pnDestLen = nWritten;
	return TRUE;
}


inline BOOL UUDecode(
	BYTE* pbSrcData,
	int nSrcLen,
	BYTE* pbDest,
	int* pnDestLen,
	BYTE* szFileName,
	int* pnFileNameLength,
	int* pnPermissions,
	DWORD dwFlags = 0) throw()
{
	if (!pbSrcData || !pbDest || !szFileName ||
		!pnFileNameLength || !pnPermissions || !pnDestLen)
	{
		return FALSE;
	}

	int i = 0, j = 0;
	int nLineLen = 0;
	char ch;
	int nRead = 0, nWritten = 0;

	char tmpBuf[256];
	//get the file name
	//eat the begin statement
	while (*pbSrcData != 'b')
	{
		ATLASSERT( nRead < nSrcLen );
		pbSrcData++;
		nRead++;
	}

	pbSrcData--;
	while ((ch = *pbSrcData) != ' ')
	{
		ATLASSERT( nRead < nSrcLen );
		ATLASSERT( i < 256 );
		pbSrcData++;
		tmpBuf[i++] = ch;
		nRead++;
	}
	nRead++;

	//uuencode block must start with a begin
	if (strncmp(tmpBuf, "begin", 5))
	{
		return FALSE;
	}

	while((ch = *pbSrcData) == ' ')
	{
		ATLASSERT( nRead < nSrcLen );

		pbSrcData++;
		nRead++;
	}

	//get the permissions
	i = 0;
	pbSrcData--;
	while ((ch = *pbSrcData++) != ' ')
	{
		ATLASSERT( nRead < nSrcLen );

		ATLASSERT( i < 256 );
		tmpBuf[i++] = ch;
		nRead++;
	}
	*pnPermissions = atoi(tmpBuf);
	nRead++;

	//get the filename
	i = 0;
	while (((ch = *pbSrcData++) != '\r') && ch != '\n' && i < *pnFileNameLength)
	{
		ATLASSERT( nRead < nSrcLen );
		*szFileName = ch;
		szFileName++;
		nRead++;
		i++;
	}
	*pnFileNameLength = i;
	nRead++;

	char chars[4];

	while (nRead < nSrcLen)
	{
		for (j = 0; j < 4; j++)
		{
			if (nRead < nSrcLen)
			{
				chars[j] = *pbSrcData++;
				nRead++;
				// if the character is a carriage return, skip the next '\n' and continue
				if (chars[j] == '\r')
				{
					nLineLen = 0;
					pbSrcData++;
					nRead++;
					j--;
					continue;
				}
				//if the character is a line-feed, skip it
				if (chars[j] == '\n')
				{
					nLineLen = 0;
					j--;
					continue;
				}
				//if we're at the beginning of a line, or it is an invalid character
				if (nLineLen == 0 || chars[j] < 31 || chars[j] > 96)
				{
					//if we're at the 'end'
					if (chars[j] == 'e')
					{
						//set the rest of the array to ' ' and break
						for (int k = j; k < 4; k++)
						{
							chars[k] = ' ';
							nWritten--;
						}
						nWritten++;
						nRead = nSrcLen+1;
						break;
					}
					if ((dwFlags & ATLSMTP_UUENCODE_DOT) && nLineLen == 0 && chars[j] == '.')
					{
						if ((nRead+1) < nSrcLen)
						{
							pbSrcData++;
							chars[j] = *pbSrcData++;
							nRead++;
						}
						else
						{
							return FALSE;
						}
					}
					else
					{
						j--;
					}
					nLineLen++;
					continue;
				}
			}
			else
			{
				chars[j] = ' ';
			}
		}
		if (nWritten < (*pnDestLen-3))
		{
			//decode the characters

			*pbDest++ = (BYTE)((((chars[0] - ' ') & 0x3F) << 2) | (((chars[1] - ' ') & 0x3F) >> 4));
			*pbDest++ = (BYTE)((((chars[1] - ' ') & 0x3F) << 4) | (((chars[2] - ' ') & 0x3F) >> 2));
			*pbDest++ = (BYTE)((((chars[2] - ' ') & 0x3F) << 6) | ((chars[3] - ' ') & 0x3F));

			nWritten += 3;

			continue;
		}
		break;
	}
	*pnDestLen = nWritten;
	return TRUE;
}

//=======================================================================
// Quoted Printable encode/decode
// compliant with RFC 2045
//=======================================================================
//
inline int QPEncodeGetRequiredLength(int nSrcLen) throw()
{
	int nRet = 3*((3*nSrcLen)/(ATLSMTP_MAX_QP_LINE_LENGTH-8));
	nRet += 3*nSrcLen;
	nRet += 3;
	return nRet;
}

inline int QPDecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}


#define ATLSMTP_QPENCODE_DOT 1
#define ATLSMTP_QPENCODE_TRAILING_SOFT 2

inline BOOL QPEncode(BYTE* pbSrcData, int nSrcLen, LPSTR szDest, int* pnDestLen, DWORD dwFlags = 0) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
	                            'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= QPEncodeGetRequiredLength(nSrcLen));
	
	int nRead = 0, nWritten = 0, nLineLen = 0;
	char ch;
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (nLineLen == 0 && ch == '.' && (dwFlags & ATLSMTP_QPENCODE_DOT))
		{
			*szDest++ = '.';
			nWritten++;
			nLineLen++;
		}
		if ((ch > 32 && ch < 61) || (ch > 61 && ch < 127))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}
		else if ((ch == ' ' || ch == '\t') && (nLineLen < (ATLSMTP_MAX_QP_LINE_LENGTH-12)))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}	
		else
		{
			*szDest++ = '=';
			*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
			*szDest++ = s_chHexChars[ch & 0x0F];
			nWritten += 3;
			nLineLen += 3;
		}
		if (nLineLen >= (ATLSMTP_MAX_QP_LINE_LENGTH-11))
		{
			*szDest++ = '=';
			*szDest++ = '\r';
			*szDest++ = '\n';
			nLineLen = 0;
			nWritten += 3;
		}
	}
	if (dwFlags & ATLSMTP_QPENCODE_TRAILING_SOFT)
	{
		*szDest++ = '=';
		*szDest++ = '\r';
		*szDest++ = '\n';
		nWritten += 3;
	}

	*pnDestLen = nWritten;

	return TRUE;
}


inline BOOL QPDecode(BYTE* pbSrcData, int nSrcLen, LPSTR szDest, int* pnDestLen, DWORD dwFlags = 0) throw()
{
	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	int nRead = 0, nWritten = 0, nLineLen = -1;
	char ch;
	while (nRead <= nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		nLineLen++;
		if (ch == '=')
		{
			//if the next character is a digit or a character, convert
			if (nRead < nSrcLen && (isdigit(*pbSrcData) || isalpha(*pbSrcData)))
			{
				char szBuf[5];
				szBuf[0] = *pbSrcData++;
				szBuf[1] = *pbSrcData++;
				szBuf[2] = '\0';
				char* tmp = '\0';
				*szDest++ = (BYTE)strtoul(szBuf, &tmp, 16);
				nWritten++;
				nRead += 2;
				continue;
			}
			//if the next character is a carriage return or line break, eat it
			if (nRead < nSrcLen && *pbSrcData == '\r' && (nRead+1 < nSrcLen) && *(pbSrcData+1)=='\n')
			{
				pbSrcData++;
				nRead++;
				nLineLen = -1;
				continue;
			}
			return FALSE;
		}
		if (ch == '\r' || ch == '\n')
		{
			nLineLen = -1;
			continue;
		}
		if ((dwFlags & ATLSMTP_QPENCODE_DOT) && ch == '.' && nLineLen == 0)
		{
			continue;
		}
		*szDest++ = ch;
		nWritten++;
	}

	*pnDestLen = nWritten-1;
	return TRUE;
}

//=======================================================================
// Q and B encoding (for encoding MIME header information)
// compliant with RFC 2047
//=======================================================================

inline int IsExtendedChar(char ch) throw()
{
	return ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r');
}

inline int GetExtendedChars(LPCSTR szSrc, int nSrcLen) throw()
{
	ATLASSERT( szSrc );

	int nChars(0);

	for (int i=0; i<nSrcLen; i++)
	{
		if (IsExtendedChar(*szSrc++))
			nChars++;
	}

	return nChars;
}

#ifndef ATL_MAX_ENC_CHARSET_LENGTH
#define ATL_MAX_ENC_CHARSET_LENGTH 50
#endif

//Get the required length to hold this encoding based on nSrcLen
inline int QEncodeGetRequiredLength(int nSrcLen, int nCharsetLen) throw()
{
	return QPEncodeGetRequiredLength(nSrcLen)+7+nCharsetLen;
}

//QEncode pbSrcData with the charset specified by pszCharSet
inline BOOL QEncode(
	BYTE* pbSrcData,
	int nSrcLen,
	LPSTR szDest,
	int* pnDestLen,
	LPCSTR pszCharSet,
	int* pnNumEncoded = NULL) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
	                            'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= QEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH));

	int nRead = 0, nWritten = 0, nEncCnt = 0;
	char ch;
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;

	//output the charset
	while (*pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}
	*szDest++ = '?';
	*szDest++ = 'Q';
	*szDest++ = '?';
	nWritten += 3;

	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (((ch > 32 && ch < 61) || (ch > 61 && ch < 127)) && ch != '?' && ch != '_')
		{
			*szDest++ = ch;
			nWritten++;
			continue;
		}
		//otherwise it is an unprintable/unsafe character
		*szDest++ = '=';
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
		if (ch < 32 || ch > 126)
			nEncCnt++;
		nWritten += 3;
	}
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;

	*pnDestLen = nWritten;

	if (pnNumEncoded)
		*pnNumEncoded = nEncCnt;

	return TRUE;
}


//Get the required length to hold this encoding based on nSrcLen
inline int BEncodeGetRequiredLength(int nSrcLen, int nCharsetLen) throw()
{
	return Base64EncodeGetRequiredLength(nSrcLen)+7+nCharsetLen;
}

//BEncode pbSrcData with the charset specified by pszCharSet
inline BOOL BEncode(BYTE* pbSrcData, int nSrcLen, LPSTR szDest, int* pnDestLen, LPCSTR pszCharSet) throw()
{
	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= BEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH));

	int nWritten = 0;
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;

	//output the charset
	while (*pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}
	*szDest++ = '?';
	*szDest++ = 'B';
	*szDest++ = '?';
	nWritten += 3;

	BOOL bRet = Base64Encode(pbSrcData, nSrcLen, szDest, pnDestLen, ATL_BASE64_FLAG_NOCRLF);
	if (!bRet)
		return FALSE;

	szDest += *pnDestLen;
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;
	*pnDestLen += nWritten;
	return TRUE;
}

//=======================================================================
// AtlUnicodeToUTF8
//
// Support for converting UNICODE strings to UTF8 
// (WideCharToMultiByte does not support UTF8 in Win98)
//
// This function is from the SDK implementation of 
// WideCharToMultiByte with the CP_UTF8 codepage
//
//=======================================================================
//
#define ATL_ASCII                 0x007f

#define ATL_UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define ATL_UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define ATL_UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define ATL_UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define ATL_UTF8_TRAIL            0x80    // 10xx xxxx

#define ATL_HIGHER_6_BIT(u)       ((u) >> 12)
#define ATL_MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define ATL_LOWER_6_BIT(u)        ((u) & 0x003f)


#define ATL_HIGH_SURROGATE_START  0xd800
#define ATL_HIGH_SURROGATE_END    0xdbff
#define ATL_LOW_SURROGATE_START   0xdc00
#define ATL_LOW_SURROGATE_END     0xdfff

ATL_NOINLINE inline 
int AtlUnicodeToUTF8(
    LPCWSTR wszSrc,
    int nSrc,
    LPSTR szDest,
    int nDest)
{
    LPCWSTR pwszSrc = wszSrc;
    int     nU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;

    while ((nSrc--) && ((nDest == 0) || (nU8 < nDest)))
    {
        bHandled = FALSE;
        
		// Check if high surrogate is available
        if ((*pwszSrc >= ATL_HIGH_SURROGATE_START) && (*pwszSrc <= ATL_HIGH_SURROGATE_END))
        {
            if (nDest)
            {
                // Another high surrogate, then treat the 1st as normal Unicode character.
                if (wchHighSurrogate)
                {
                    if ((nU8 + 2) < nDest)
                    {
                        szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
                    }
                    else
                    {
                        // not enough buffer
                        nSrc++;
                        break;
                    }
                }
            }
            else
            {
                nU8 += 3;
            }
            wchHighSurrogate = *pwszSrc;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*pwszSrc >= ATL_LOW_SURROGATE_START) && (*pwszSrc <= ATL_LOW_SURROGATE_END))
            {
                 // valid surrogate pairs
                 if (nDest)
                 {
                     if ((nU8 + 3) < nDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*pwszSrc - 0xDC00) + 0x10000);
                         szDest[nU8++] = (ATL_UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte
                         szDest[nU8++] =  (ATL_UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte
                         szDest[nU8++] = (ATL_UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte
                         szDest[nU8++] = (ATL_UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        nSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     nU8 += 1;
                 }
                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (nDest)
                 {
                     if ((nU8 + 2) < nDest)
                     {
                        szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
                     }
                     else
                     {
                        // not enough buffer
                        nSrc++;
                        break;
                     }
                 }
            }
            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*pwszSrc <= ATL_ASCII)
            {
                //  Found ASCII.
                if (nDest)
                {
                    szDest[nU8] = (char)*pwszSrc;
                }
                nU8++;
            }
            else if (*pwszSrc <= ATL_UTF8_2_MAX)
            {
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                if (nDest)
                {
                    if ((nU8 + 1) < nDest)
                    {
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_2 | (*pwszSrc >> 6));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(*pwszSrc));
                    }
                    else
                    {
                        //  Error - buffer too small.
                        nSrc++;
                        break;
                    }
                }
                else
                {
                    nU8 += 2;
                }
            }
            else
            {
                //  Found 3 byte sequence.
                if (nDest)
                {
                    if ((nU8 + 2) < nDest)
                    {
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(*pwszSrc));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(*pwszSrc));
                        szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(*pwszSrc));
                    }
                    else
                    {
                        //  Error - buffer too small.
                        nSrc++;
                        break;
                    }
                }
                else
                {
                    nU8 += 3;
                }
            }
        }
        pwszSrc++;
    }

    // If the last character was a high surrogate, then handle it as a normal unicode character.
    if ((nSrc < 0) && (wchHighSurrogate != 0))
    {
        if (nDest)
        {
            if ((nU8 + 2) < nDest)
            {
                szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
                szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
                szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
            }
            else
            {
                nSrc++;
            }
        }
    }

    //  Make sure the destination buffer was large enough.
    if (nDest && (nSrc >= 0))
    {
        return 0;
    }

    //  Return the number of UTF-8 characters written.
    return nU8;
}


//=======================================================================
// EscapeHTML, EscapeXML
//
// Support for escaping strings for use in HTML and XML documents
//=======================================================================
//

#define ATL_ESC_FLAG_NONE 0
#define ATL_ESC_FLAG_ATTR 1 // escape for attribute values
#define ATL_ESC_FLAG_HTML 2 // escape for HTML -- special case of XML escaping

inline int EscapeXML(const char *szIn, int nSrcLen, char *szEsc, int nDestLen, DWORD dwFlags = ATL_ESC_FLAG_NONE) throw()
{
	ATLASSERT( szIn != NULL );

	int nCnt(0);
	int nCurrLen(nDestLen);
	int nInc(0);

	while (nSrcLen--)
	{
		switch (*szIn)
		{
		case '<': case '>':
			if ((szEsc != NULL) && (3 < nCurrLen))
			{
				*szEsc++ = '&';
				*szEsc++ = (*szIn=='<' ? 'l' : 'g');
				*szEsc++ = 't';	
				*szEsc++ = ';';	
			}
			nInc = 4;
			break;

		case '&':
			if ((szEsc != NULL) && (4 < nCurrLen))
			{
				memcpy(szEsc, "&amp;", 5);
				szEsc+= 5;
			}
			nInc = 5;
			break;

		case '\'': case '\"': // escaping for attribute values
			if ((dwFlags & ATL_ESC_FLAG_ATTR) && (*szIn == '\"' || (dwFlags & ATL_ESC_FLAG_HTML)==0))
			{
				if ((szEsc != NULL) && (5 < nCurrLen))
				{
					memcpy(szEsc, (*szIn == '\'' ? "&apos;" : "&quot;"), 6);
					szEsc+= 6;
				}
				nInc = 6;
				break;
			}
			// fall through

		default:
			if (((unsigned char)*szIn) > 31 || *szIn == '\r' || *szIn == '\n' || *szIn == '\t')
			{
				if (szEsc && 0 < nCurrLen)
				{
					*szEsc++ = *szIn;
				}
				nInc = 1;
			}
			else
			{
				if ((szEsc != NULL) && (5 < nCurrLen))
				{
					char szHex[7];
					sprintf(szHex, "&#x%2X;", (unsigned char)*szIn);
					memcpy(szEsc, szHex, 6);
					szEsc+= 6;
				}
				nInc = 6;
			}
		}

		nCurrLen -= nInc;
		nCnt+= nInc;

		szIn++;
	}

	if ((szEsc != NULL) && (nCurrLen < 0))
	{
		return 0;
	}

	return nCnt;
}

// wide-char version
inline int EscapeXML(const wchar_t *szIn, int nSrcLen, wchar_t *szEsc, int nDestLen, DWORD dwFlags = ATL_ESC_FLAG_NONE) throw()
{
	ATLASSERT( szIn != NULL );

	int nCnt(0);
	int nCurrLen(nDestLen);
	int nInc(0);

	while (nSrcLen--)
	{
		switch (*szIn)
		{
		case L'<': case L'>':
			if ((szEsc != NULL) && (3 < nCurrLen))
			{
				*szEsc++ = L'&';
				*szEsc++ = (*szIn==L'<' ? L'l' : L'g');
				*szEsc++ = L't';	
				*szEsc++ = L';';	
			}
			nInc = 4;
			break;

		case L'&':
			if ((szEsc != NULL) && (4 < nCurrLen))
			{
				memcpy(szEsc, L"&amp;", 5*sizeof(wchar_t));
				szEsc+= 5;
			}
			nInc = 5;
			break;

		case L'\'': case L'\"': // escaping for attribute values
			if ((dwFlags & ATL_ESC_FLAG_ATTR) && (*szIn == L'\"' || (dwFlags & ATL_ESC_FLAG_HTML)==0))
			{
				if ((szEsc != NULL) && (5 < nCurrLen))
				{
					memcpy(szEsc, (*szIn == L'\'' ? L"&apos;" : L"&quot;"), 6*sizeof(wchar_t));
					szEsc+= 6;
				}
				nInc = 6;
				break;
			}
			// fall through

		default:
			if ((*szIn < 0x0020) || (*szIn > 0x007E))
			{
				if ((szEsc != NULL) && (8 < nCurrLen))
				{
					wchar_t szHex[9];
					wsprintfW(szHex, L"&#x%04X;", *szIn);
					memcpy(szEsc, szHex, 8*sizeof(wchar_t));
					szEsc+= 8;
				}
				nInc = 8;
			}
			else
			{
				if ((szEsc != NULL) && (0 < nCurrLen))
				{
					*szEsc++ = *szIn;
				}
				nInc = 1;
			}
		}

		nCurrLen -= nInc;
		nCnt+= nInc;

		szIn++;
	}

	if ((szEsc != NULL) && (nCurrLen < 0))
	{
		return 0;
	}

	return nCnt;
}

inline int EscapeHTML(const char *szIn, int nSrcLen, char *szEsc, int nDestLen, DWORD dwFlags = ATL_ESC_FLAG_NONE) throw()
{
	return EscapeXML(szIn, nSrcLen, szEsc, nDestLen, dwFlags | ATL_ESC_FLAG_HTML);
}

} // namespace ATL

#endif // __ATLENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlecb.h ===
#pragma once


#include <httpext.h>
#include <atlutil.h>

#define ATLSV_IS_TRANSFERRED_REQUEST "ATLSV_IS_TRANSFERRED_REQUEST"

// ECB used for transferring request on the server.
class CTransferECB : 
	public EXTENSION_CONTROL_BLOCK
{
public:
	CTransferECB()
	{
		m_pFromECB = NULL;
	}

	BOOL Initialize(EXTENSION_CONTROL_BLOCK *pFromECB,
					LPCSTR szNewURL)
	{
		ATLASSERT(pFromECB != NULL);
		ATLASSERT(szNewURL != NULL);
		m_pFromECB = pFromECB;
		m_TransferUrl.CrackUrl(szNewURL);
		ConnID = (HCONN)this;
		cbSize = pFromECB->cbSize;
		dwVersion = pFromECB->dwVersion;
		dwHttpStatusCode = pFromECB->dwHttpStatusCode;
		if (pFromECB->lpszLogData)
			strcpy(lpszLogData, pFromECB->lpszLogData);
		lpszMethod = pFromECB->lpszMethod;

		ReTranslatePath();
		
		lpszQueryString = (char*)(m_TransferUrl.GetExtraInfo()+1);
		lpszPathInfo = (LPSTR)m_TransferUrl.GetUrlPath();
		lpszPathTranslated = (LPSTR)m_szPathTranslated; // path translated's are the same.
												// this restricts transfer urls to the same vroot.
		cbTotalBytes = pFromECB->cbTotalBytes;;
		cbAvailable = pFromECB->cbAvailable;
		lpbData = pFromECB->lpbData;
		lpszContentType = pFromECB->lpszContentType;

		GetServerVariable = CTransferECB::GetServerVariableImpl;
		WriteClient = CTransferECB::WriteClientImpl;
		ReadClient = CTransferECB::ReadClientImpl;
		ServerSupportFunction = CTransferECB::ServerSupportFunctionImpl;
		return TRUE;
	}

    static BOOL WINAPI GetServerVariableImpl(
										HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize)
	{
		EXTENSION_CONTROL_BLOCK *pECB = ((CTransferECB*)hConn)->m_pFromECB;
		ATLASSERT(pECB != NULL);

		// must special case some server variables to make the transfer work right.
		if (!strcmp(lpszVariableName, ATLSV_IS_TRANSFERRED_REQUEST ))
		{
			if (*lpdwSize != sizeof(int))
				return FALSE;
			*lpdwSize = sizeof(int);
			*((int*)lpvBuffer) = 1;
			return TRUE;
		}

		return pECB->GetServerVariable(
										pECB->ConnID,
										lpszVariableName,
										lpvBuffer,
										lpdwSize);
	}

    static BOOL WINAPI WriteClientImpl( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved )
	{
		EXTENSION_CONTROL_BLOCK *pECB = ((CTransferECB*)ConnID)->m_pFromECB;
		ATLASSERT(pECB != NULL);
		DWORD dwErr = 0;
		BOOL bRet =  pECB->WriteClient(
								 pECB->ConnID,
								 Buffer,
								 lpdwBytes,
								 dwReserved
								 );

		if (!bRet)
			dwErr = GetLastError();
		return bRet;

	}

    static BOOL WINAPI ReadClientImpl( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize )
	{
  		EXTENSION_CONTROL_BLOCK *pECB = ((CTransferECB*)ConnID)->m_pFromECB;
		ATLASSERT(pECB != NULL);
		return pECB->ReadClient(
								pECB->ConnID,
								lpvBuffer,
								lpdwSize
								);
	}


    static BOOL WINAPI ServerSupportFunctionImpl( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType )
	{
		EXTENSION_CONTROL_BLOCK *pECB = ((CTransferECB*)hConn)->m_pFromECB;
		ATLASSERT(pECB != NULL);
		return pECB->ServerSupportFunction(
											pECB->ConnID,
											dwHSERequest,
											lpvBuffer,
											lpdwSize,
											lpdwDataType
											);
	}



	void ReTranslatePath()
	{
		char szNewPath[_MAX_PATH];
		strcpy(szNewPath, m_TransferUrl.GetUrlPath());

		char *pTemp = szNewPath;
		while (*pTemp)
		{
			if (*pTemp == '/')
				*pTemp = '\\';
			pTemp++;
		}

		char drive[_MAX_DRIVE];
		char dir[_MAX_DIR];

		_splitpath(m_pFromECB->lpszPathTranslated, drive, dir, NULL, NULL);
		pTemp = szNewPath + strlen(szNewPath);
		while (pTemp > szNewPath)
		{
			if (*pTemp == '\\')
				break;
			if (pTemp <= szNewPath)
			{
				pTemp = NULL;
				break;
			}
			pTemp--;
		}
		if (!pTemp)
			return;
		pTemp++;
		strcpy(m_szPathTranslated, drive);
		strcat(m_szPathTranslated, dir);
		strcat(m_szPathTranslated, pTemp);
	}


	char m_szPathTranslated[_MAX_PATH];
	CUrl m_TransferUrl;
	EXTENSION_CONTROL_BLOCK *m_pFromECB;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atldbsch.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////////////////////////////////////////
// ATLDBSCH.H : Declarations for OLE DB Schema Rowset Consumer Support
//

#ifndef __ATLDBSCH_H__
#define __ATLDBSCH_H__

#pragma once

namespace ATL
{

template <short nRestrictions>
class _CStoreRestrictions
{
public:
	_CStoreRestrictions()
	{
		m_pvarRestrictions = NULL;
		ATLTRY(m_pvarRestrictions = new CComVariant[nRestrictions]);
	}
	~_CStoreRestrictions()
	{
		delete [] m_pvarRestrictions;
	}
	HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
	{
		ATLASSERT(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetRowset(NULL, guidSchema, nRestrictions,
			m_pvarRestrictions, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}

	CComVariant* m_pvarRestrictions;
};

template <>
class _CStoreRestrictions<0>
{
public:
	HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
	{
		ATLASSERT(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetRowset(NULL, guidSchema, 0,
			NULL, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}
};

///////////////////////////////////////////////////////////////////////////
// class CSchemaRowset
template <class T, short nRestrictions, template <typename T> class TRowset = CRowset>
class CSchemaRowset :
	public CAccessorRowset<T, TRowset>,
	public _CStoreRestrictions<nRestrictions>
{
public:
// Operations
	HRESULT Open(const CSession& session, const GUID& guidSchema, bool bBind = true )
	{
		HRESULT hr;

		hr = GetRowset(session, guidSchema, &m_spRowset);
		if ( SUCCEEDED(hr) && bBind )
			hr = Bind();

		return hr;
	}
};

 ///////////////////////////////////////////////////////////////////////////
// class CRestrictions

template <class T, short nRestrictions, const GUID* pguid>
class CRestrictions : public CSchemaRowset<T, nRestrictions>
{
public:
	HRESULT Open(const CSession& session, LPCTSTR lpszParam1 = NULL, LPCTSTR lpszParam2 = NULL,
			LPCTSTR lpszParam3 = NULL, LPCTSTR lpszParam4 = NULL,
			LPCTSTR lpszParam5 = NULL, LPCTSTR lpszParam6 = NULL,
			LPCTSTR lpszParam7 = NULL, bool bBind = true )
	{
		USES_CONVERSION;
		CComVariant* pVariant;

		if (m_pvarRestrictions == NULL)
			return E_OUTOFMEMORY;

		if (lpszParam1 != NULL)
		{
			m_pvarRestrictions->vt = VT_BSTR;
			m_pvarRestrictions->bstrVal = ::SysAllocString(T2COLE(lpszParam1));
			if (m_pvarRestrictions->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam2 != NULL)
		{
			pVariant = m_pvarRestrictions + 1;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam2));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam3 != NULL)
		{
			pVariant = m_pvarRestrictions + 2;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam3));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam4 != NULL)
		{
			pVariant = m_pvarRestrictions + 3;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam4));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam5 != NULL)
		{
			pVariant = m_pvarRestrictions + 4;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam5));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam6 != NULL)
		{
			pVariant = m_pvarRestrictions + 5;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam6));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam7 != NULL)
		{
			pVariant = m_pvarRestrictions + 6;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE(lpszParam7));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		return CSchemaRowset<T, nRestrictions>::Open(session, *pguid, bBind);
	}
};


///////////////////////////////////////////////////////////////////////////
// CSchemas

class CSchemas
{
public:
	CSchemas()
	{
		m_nSchemas          = 0;
		m_pSchemaGuids      = NULL;
		m_pulRestrictions   = NULL;
	};

	~CSchemas()
	{
		// Clean up allocated memory
		CoTaskMemFree(m_pSchemaGuids);
		CoTaskMemFree(m_pulRestrictions);
	};

// Operations
	HRESULT GetSchemas(const CSession& session)
	{
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		ATLASSERT(session.m_spOpenRowset != NULL);

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset),
			(void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetSchemas(&m_nSchemas, &m_pSchemaGuids,
				&m_pulRestrictions);
	};

// Attributes
	ULONG   m_nSchemas;
	LPGUID  m_pSchemaGuids;
	ULONG*  m_pulRestrictions;
};


///////////////////////////////////////////////////////////////////////////
// CAssertionInfo

class CAssertionInfo
{
public:
	CAssertionInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Map
BEGIN_COLUMN_MAP(CAssertionInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_bIsDeferrable)
	COLUMN_ENTRY(5, m_bInitiallyDeferred)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCatalogInfo

class CCatalogInfo
{
public:
	CCatalogInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szName[129];
	TCHAR   m_szDescription[129];

// Binding Info
BEGIN_COLUMN_MAP(CCatalogInfo)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCharacterSetInfo

class CCharacterSetInfo
{
public:
	CCharacterSetInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szFormOfUse[129];
	LARGE_INTEGER   m_nNumCharacters;
	TCHAR           m_szCollateCatalog[129];
	TCHAR           m_szCollateSchema[129];
	TCHAR           m_szCollateName[129];

// Binding Info
BEGIN_COLUMN_MAP(CCharacterSetInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szFormOfUse)
	COLUMN_ENTRY(5, m_nNumCharacters)
	COLUMN_ENTRY(6, m_szCollateCatalog)
	COLUMN_ENTRY(7, m_szCollateSchema)
	COLUMN_ENTRY(8, m_szCollateName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCheckConstraintInfo

class CCheckConstraintInfo
{
public:
	CCheckConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCheckClause[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CCheckConstraintInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCheckClause)
	COLUMN_ENTRY(5, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCollationInfo

class CCollationInfo
{
public:
// Constructors
	CCollationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCharSetCatalog[129];
	TCHAR   m_szCharSetSchema[129];
	TCHAR   m_szCharSetName[129];
	TCHAR   m_szPadAttribute[10];

// Binding Maps
BEGIN_COLUMN_MAP(CCollationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCharSetCatalog)
	COLUMN_ENTRY(5, m_szCharSetSchema)
	COLUMN_ENTRY(6, m_szCharSetName)
	COLUMN_ENTRY(7, m_szPadAttribute)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnDomainUsageInfo

class CColumnDomainUsageInfo
{
public:
// Constructor
	CColumnDomainUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnDomainUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnPrivilegeInfo

class CColumnPrivilegeInfo
{
public:
// Constructor
	CColumnPrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	TCHAR           m_szPrivilegeType[20];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnPrivilegeInfo)
	COLUMN_ENTRY(1,  m_szGrantor)
	COLUMN_ENTRY(2,  m_szGrantee)
	COLUMN_ENTRY(3,  m_szTableCatalog)
	COLUMN_ENTRY(4,  m_szTableSchema)
	COLUMN_ENTRY(5,  m_szTableName)
	COLUMN_ENTRY(6,  m_szColumnName)
	COLUMN_ENTRY(7,  m_guidColumn)
	COLUMN_ENTRY(8,  m_nColumnPropID)
	COLUMN_ENTRY(9,  m_szPrivilegeType)
	COLUMN_ENTRY(10, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnsInfo

class CColumnsInfo
{
public:
// Constructors and Destructors
	CColumnsInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Operations
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bColumnHasDefault;
	TCHAR           m_szColumnDefault[129];
	ULONG           m_nColumnFlags;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nNumericPrecision;
	SHORT           m_nNumericScale;
	ULONG           m_nDateTimePrecision;
	TCHAR           m_szCharSetCatalog[129];
	TCHAR           m_szCharSetSchema[129];
	TCHAR           m_szCharSetName[129];
	TCHAR           m_szCollationCatalog[129];
	TCHAR           m_szCollationSchema[129];
	TCHAR           m_szCollationName[129];
	TCHAR           m_szDomainCatalog[129];
	TCHAR           m_szDomainSchema[129];
	TCHAR           m_szDomainName[129];
	TCHAR           m_szDescription[129];

BEGIN_COLUMN_MAP(CColumnsInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinalPosition)
	COLUMN_ENTRY(8, m_bColumnHasDefault)
	COLUMN_ENTRY(9, m_szColumnDefault)
	COLUMN_ENTRY(10, m_nColumnFlags)
	COLUMN_ENTRY(11, m_bIsNullable)
	COLUMN_ENTRY(12, m_nDataType)
	COLUMN_ENTRY(13, m_guidType)
	COLUMN_ENTRY(14, m_nMaxLength)
	COLUMN_ENTRY(15, m_nOctetLength)
	COLUMN_ENTRY(16, m_nNumericPrecision)
	COLUMN_ENTRY(17, m_nNumericScale)
	COLUMN_ENTRY(18, m_nDateTimePrecision)
	COLUMN_ENTRY(19, m_szCharSetCatalog)
	COLUMN_ENTRY(20, m_szCharSetSchema)
	COLUMN_ENTRY(21, m_szCharSetName)
	COLUMN_ENTRY(22, m_szCollationCatalog)
	COLUMN_ENTRY(23, m_szCollationSchema)
	COLUMN_ENTRY(24, m_szCollationName)
	COLUMN_ENTRY(25, m_szDomainCatalog)
	COLUMN_ENTRY(26, m_szDomainSchema)
	COLUMN_ENTRY(27, m_szDomainName)
	COLUMN_ENTRY(28, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintColumnUsageInfo
{
public:
// Constructor
	CConstraintColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintColumnUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_szConstraintCatalog)
	COLUMN_ENTRY(8, m_szConstraintSchema)
	COLUMN_ENTRY(9, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintTableUsageInfo
{
public:
// Constructor
	CConstraintTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintTableUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szConstraintCatalog)
	COLUMN_ENTRY(5, m_szConstraintSchema)
	COLUMN_ENTRY(6, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CForeignKeysInfo

class CForeignKeysInfo
{
public:
// Constructor
	CForeignKeysInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szPKTableCatalog[129];
	TCHAR   m_szPKTableSchema[129];
	TCHAR   m_szPKTableName[129];
	TCHAR   m_szPKColumnName[129];
	GUID    m_guidPKColumn;
	ULONG   m_nPKColumnPropID;
	TCHAR   m_szFKTableCatalog[129];
	TCHAR   m_szFKTableSchema[129];
	TCHAR   m_szFKTableName[129];
	TCHAR   m_szFKColumnName[129];
	GUID    m_guidFKColumn;
	ULONG   m_nFKColumnPropID;
	ULONG   m_nOrdinal;
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];

// Binding Info
BEGIN_COLUMN_MAP(CForeignKeysInfo)
	COLUMN_ENTRY(1, m_szPKTableCatalog)
	COLUMN_ENTRY(2, m_szPKTableSchema)
	COLUMN_ENTRY(3, m_szPKTableName)
	COLUMN_ENTRY(4, m_szPKColumnName)
	COLUMN_ENTRY(5, m_guidPKColumn)
	COLUMN_ENTRY(6, m_nPKColumnPropID)
	COLUMN_ENTRY(7, m_szFKTableCatalog)
	COLUMN_ENTRY(8, m_szFKTableSchema)
	COLUMN_ENTRY(9, m_szFKTableName)
	COLUMN_ENTRY(10, m_szFKColumnName)
	COLUMN_ENTRY(11, m_guidFKColumn)
	COLUMN_ENTRY(12, m_nFKColumnPropID)
	COLUMN_ENTRY(13, m_nOrdinal)
	COLUMN_ENTRY(14, m_szUpdateRule)
	COLUMN_ENTRY(15, m_szDeleteRule)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CIndexesInfo

class CIndexesInfo
{
public:
// Constructors
	CIndexesInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szIndexCatalog[129];
	TCHAR           m_szIndexSchema[129];
	TCHAR           m_szIndexName[129];
	VARIANT_BOOL    m_bPrimaryKey;
	VARIANT_BOOL    m_bUnique;
	VARIANT_BOOL    m_bClustered;
	USHORT          m_nType;
	LONG            m_nFillFactor;
	LONG            m_nInitialSize;
	LONG            m_nNulls;
	VARIANT_BOOL    m_bSortBookmarks;
	VARIANT_BOOL    m_bAutoUpdate;
	LONG            m_nNullCollation;
	ULONG           m_nOrdinalPosition;
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	SHORT           m_nCollation;
	LONG            m_nCardinality;
	LONG            m_nPages;
	TCHAR           m_szFilterCondition[129];

// Binding Maps
BEGIN_COLUMN_MAP(CIndexesInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szIndexCatalog)
	COLUMN_ENTRY(5, m_szIndexSchema)
	COLUMN_ENTRY(6, m_szIndexName)
	COLUMN_ENTRY(7, m_bPrimaryKey)
	COLUMN_ENTRY(8, m_bUnique)
	COLUMN_ENTRY(9, m_bClustered)
	COLUMN_ENTRY(10, m_nType)
	COLUMN_ENTRY(11, m_nFillFactor)
	COLUMN_ENTRY(12, m_nInitialSize)
	COLUMN_ENTRY(13, m_nNulls)
	COLUMN_ENTRY(14, m_bSortBookmarks)
	COLUMN_ENTRY(15, m_bAutoUpdate)
	COLUMN_ENTRY(16, m_nNullCollation)
	COLUMN_ENTRY(17, m_nOrdinalPosition)
	COLUMN_ENTRY(18, m_szColumnName)
	COLUMN_ENTRY(19, m_guidColumn)
	COLUMN_ENTRY(20, m_nColumnPropID)
	COLUMN_ENTRY(21, m_nCollation)
	COLUMN_ENTRY(22, m_nCardinality)
	COLUMN_ENTRY(23, m_nPages)
	COLUMN_ENTRY(25, m_szFilterCondition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CKeyColumnUsageInfo

class CKeyColumnUsageInfo
{
public:
// Constructors
	CKeyColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinalPosition;

// Binding Maps
BEGIN_COLUMN_MAP(CKeyColumnUsageInfo)
	COLUMN_ENTRY(1,  m_szConstraintCatalog)
	COLUMN_ENTRY(2,  m_szConstraintSchema)
	COLUMN_ENTRY(3,  m_szConstraintName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szColumnName)
	COLUMN_ENTRY(8,  m_guidColumn)
	COLUMN_ENTRY(9,  m_nColumnPropID)
	COLUMN_ENTRY(10, m_nOrdinalPosition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CPrimaryKeyInfo

class CPrimaryKeyInfo
{
public:
// Constructors
	CPrimaryKeyInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinal;

// Binding Maps
BEGIN_COLUMN_MAP(CPrimaryKeyInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinal)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureColumnInfo

class CProcedureColumnInfo
{
public:
// Constructors
	CProcedureColumnInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nRowsetNumber;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureColumnInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szColumnName)
	COLUMN_ENTRY(5,  m_guidColumn)
	COLUMN_ENTRY(6,  m_nColumnPropID)
	COLUMN_ENTRY(7,  m_nRowsetNumber)
	COLUMN_ENTRY(8,  m_nOrdinalPosition)
	COLUMN_ENTRY(9,  m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_guidType)
	COLUMN_ENTRY(12, m_nMaxLength)
	COLUMN_ENTRY(13, m_nOctetLength)
	COLUMN_ENTRY(14, m_nPrecision)
	COLUMN_ENTRY(15, m_nScale)
	COLUMN_ENTRY(16, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureParameterInfo

class CProcedureParameterInfo
{
public:
// Constructors
	CProcedureParameterInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szParameterName[129];
	USHORT          m_nOrdinalPosition;
	USHORT          m_nType;
	VARIANT_BOOL    m_bHasDefault;
	TCHAR           m_szDefault[129];
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureParameterInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szParameterName)
	COLUMN_ENTRY(5, m_nOrdinalPosition)
	COLUMN_ENTRY(6, m_nType)
	COLUMN_ENTRY(7, m_bHasDefault)
	COLUMN_ENTRY(8, m_szDefault)
	COLUMN_ENTRY(9, m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_nMaxLength)
	COLUMN_ENTRY(12, m_nOctetLength)
	COLUMN_ENTRY(13, m_nPrecision)
	COLUMN_ENTRY(14, m_nScale)
	COLUMN_ENTRY(15, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureInfo

class CProcedureInfo
{
public:
// Constructors
	CProcedureInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	SHORT   m_nType;
	TCHAR   m_szDefinition[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_szDefinition)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProviderTypeInfo

class CProviderTypeInfo
{
public:
// Constructors
	CProviderTypeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTypeName[129];
	USHORT          m_nDataType;
	ULONG           m_nColumnSize;
	TCHAR           m_szLiteralPrefix[129];
	TCHAR           m_szLiteralSuffix[129];
	TCHAR           m_szCreateParams[129];
	VARIANT_BOOL    m_bIsNullable;
	VARIANT_BOOL    m_bCaseSensitive;
	ULONG           m_nSearchable;
	VARIANT_BOOL    m_bUnsignedAttribute;
	VARIANT_BOOL    m_bFixedPrecScale;
	VARIANT_BOOL    m_bAutoUniqueValue;
	TCHAR           m_szLocalTypeName[129];
	SHORT           m_nMinScale;
	SHORT           m_nMaxScale;
	GUID            m_guidType;
	TCHAR           m_szTypeLib[129];
	TCHAR           m_szVersion[129];
	VARIANT_BOOL    m_bIsLong;
	VARIANT_BOOL    m_bBestMatch;
	VARIANT_BOOL    m_bIsFixedLength;

// Binding Maps
BEGIN_COLUMN_MAP(CProviderTypeInfo)
	COLUMN_ENTRY(1, m_szTypeName)
	COLUMN_ENTRY(2, m_nDataType)
	COLUMN_ENTRY(3, m_nColumnSize)
	COLUMN_ENTRY(4, m_szLiteralPrefix)
	COLUMN_ENTRY(5, m_szLiteralSuffix)
	COLUMN_ENTRY(6, m_szCreateParams)
	COLUMN_ENTRY(7, m_bIsNullable)
	COLUMN_ENTRY(8, m_bCaseSensitive)
	COLUMN_ENTRY(9, m_nSearchable)
	COLUMN_ENTRY(10, m_bUnsignedAttribute)
	COLUMN_ENTRY(11, m_bFixedPrecScale)
	COLUMN_ENTRY(12, m_bAutoUniqueValue)
	COLUMN_ENTRY(13, m_szLocalTypeName)
	COLUMN_ENTRY(14, m_nMinScale)
	COLUMN_ENTRY(15, m_nMaxScale)
	COLUMN_ENTRY(16, m_guidType)
	COLUMN_ENTRY(17, m_szTypeLib)
	COLUMN_ENTRY(18, m_szVersion)
	COLUMN_ENTRY(19, m_bIsLong)
	COLUMN_ENTRY(20, m_bBestMatch)
	COLUMN_ENTRY(21, m_bIsFixedLength)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CReferentialConstraintInfo

class CReferentialConstraintInfo
{
public:
// Constructors
	CReferentialConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szUniqueCatalog[129];
	TCHAR   m_szUniqueSchema[129];
	TCHAR   m_szUniqueName[129];
	TCHAR   m_szMatchOption[8];
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CReferentialConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szUniqueCatalog)
	COLUMN_ENTRY(5,  m_szUniqueSchema)
	COLUMN_ENTRY(6,  m_szUniqueName)
	COLUMN_ENTRY(7,  m_szMatchOption)
	COLUMN_ENTRY(8,  m_szUpdateRule)
	COLUMN_ENTRY(9,  m_szDeleteRule)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSchemataInfo

class CSchemataInfo
{
public:
// Constructors
	CSchemataInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szName[129];
	TCHAR   m_szOwner[129];
	TCHAR   m_szCharCatalog[129];
	TCHAR   m_szCharSchema[129];
	TCHAR   m_szCharName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CSchemataInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szName)
	COLUMN_ENTRY(3, m_szOwner)
	COLUMN_ENTRY(4, m_szCharCatalog)
	COLUMN_ENTRY(5, m_szCharSchema)
	COLUMN_ENTRY(6, m_szCharName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSQLLangugageInfo

class CSQLLanguageInfo
{
public:
// Constructors
	CSQLLanguageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szSource[10];
	TCHAR   m_szYear[5];
	TCHAR   m_szConformance[13];
	TCHAR   m_szIntegrity[4];
	TCHAR   m_szImplementation[24];
	TCHAR   m_szBindingStyle[10];
	TCHAR   m_szProgrammingLanguage[10];

// Binding Maps
BEGIN_COLUMN_MAP(CSQLLanguageInfo)
	COLUMN_ENTRY(1, m_szSource)
	COLUMN_ENTRY(2, m_szYear)
	COLUMN_ENTRY(3, m_szConformance)
	COLUMN_ENTRY(4, m_szIntegrity)
	COLUMN_ENTRY(5, m_szImplementation)
	COLUMN_ENTRY(6, m_szBindingStyle)
	COLUMN_ENTRY(7, m_szProgrammingLanguage)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CStatisticInfo

class CStatisticInfo
{
public:
// Constructors
	CStatisticInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	LONG    m_nCardinality;

// Binding Maps
BEGIN_COLUMN_MAP(CStatisticInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_nCardinality)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTableConstraintInfo

class CTableConstraintInfo
{
public:
// Constructors
	CTableConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTableConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szType)
	COLUMN_ENTRY(8,  m_bIsDeferrable)
	COLUMN_ENTRY(9,  m_bInitiallyDeferred)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTablePrivilegeInfo

class CTablePrivilegeInfo
{
public:
// Constructors
	CTablePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CTablePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szCatalog)
	COLUMN_ENTRY(4, m_szSchema)
	COLUMN_ENTRY(5, m_szName)
	COLUMN_ENTRY(6, m_szType)
	COLUMN_ENTRY(7, m_bIsGrantable)
END_COLUMN_MAP()
};



///////////////////////////////////////////////////////////////////////////
// class CTableInfo

class CTableInfo
{
public:
// Constructors
	CTableInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szType[129];
	GUID    m_guidTable;
	TCHAR   m_szDescription[129];


// Binding Map
BEGIN_COLUMN_MAP(CTableInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szType)
	COLUMN_ENTRY(5, m_guidTable)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTranslationInfo

class CTranslationInfo
{
public:
// Constructors
	CTranslationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szSourceCatalog[129];
	TCHAR   m_szSourceSchema[129];
	TCHAR   m_szSourceName[129];
	TCHAR   m_szTargetCatalog[129];
	TCHAR   m_szTargetSchema[129];
	TCHAR   m_szTargetName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTranslationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szSourceCatalog)
	COLUMN_ENTRY(5, m_szSourceSchema)
	COLUMN_ENTRY(6, m_szSourceName)
	COLUMN_ENTRY(7, m_szTargetCatalog)
	COLUMN_ENTRY(8, m_szTargetSchema)
	COLUMN_ENTRY(9, m_szTargetName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CUsagePrivilegeInfo

class CUsagePrivilegeInfo
{
public:
// Constructors
	CUsagePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szGrantor[129];
	TCHAR   m_szGrantee[129];
	TCHAR   m_szObjectCatalog[129];
	TCHAR   m_szObjectSchema[129];
	TCHAR   m_szObjectName[129];
	TCHAR   m_szObjectType[12];
	TCHAR   m_szPrivilegeType[6];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CUsagePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szObjectCatalog)
	COLUMN_ENTRY(4, m_szObjectSchema)
	COLUMN_ENTRY(5, m_szObjectName)
	COLUMN_ENTRY(6, m_szObjectType)
	COLUMN_ENTRY(7, m_szPrivilegeType)
	COLUMN_ENTRY(8, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewColumnUsageInfo

class CViewColumnUsageInfo
{
public:
// Constructors
	CViewColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CViewColumnUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewTableUsageInfo

class CViewTableUsageInfo
{
public:
// Constructors
	CViewTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewTableUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewInfo

class CViewInfo
{
public:
// Constructors
	CViewInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szDefinition[129];
	VARIANT_BOOL    m_bCheckOption;
	VARIANT_BOOL    m_bIsUpdatable;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szDefinition)
	COLUMN_ENTRY(5, m_bCheckOption)
	COLUMN_ENTRY(6, m_bIsUpdatable)
	COLUMN_ENTRY(7, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// typedefs

typedef CRestrictions<CAccessor<CAssertionInfo>,            3, &DBSCHEMA_ASSERTIONS>                CAssertions;
typedef CRestrictions<CAccessor<CCatalogInfo>,              1, &DBSCHEMA_CATALOGS >                 CCatalogs;
typedef CRestrictions<CAccessor<CCharacterSetInfo>,         3, &DBSCHEMA_CHARACTER_SETS>            CCharacterSets;
typedef CRestrictions<CAccessor<CCheckConstraintInfo>,      3, &DBSCHEMA_CHECK_CONSTRAINTS>         CCheckConstraints;
typedef CRestrictions<CAccessor<CCollationInfo>,            3, &DBSCHEMA_COLLATIONS>                CCollations;
typedef CRestrictions<CAccessor<CColumnDomainUsageInfo>,    4, &DBSCHEMA_COLUMN_DOMAIN_USAGE>       CColumnDomainUsage;
typedef CRestrictions<CAccessor<CColumnPrivilegeInfo>,      6, &DBSCHEMA_COLUMN_PRIVILEGES>         CColumnPrivileges;
typedef CRestrictions<CAccessor<CColumnsInfo>,              4, &DBSCHEMA_COLUMNS>                   CColumns;
typedef CRestrictions<CAccessor<CConstraintColumnUsageInfo>,4, &DBSCHEMA_CONSTRAINT_COLUMN_USAGE>   CConstraintColumnUsage;
typedef CRestrictions<CAccessor<CConstraintTableUsageInfo>, 3, &DBSCHEMA_CONSTRAINT_TABLE_USAGE>    CConstraintTableUsage;
typedef CRestrictions<CAccessor<CForeignKeysInfo>,          6, &DBSCHEMA_FOREIGN_KEYS>              CForeignKeys;
typedef CRestrictions<CAccessor<CIndexesInfo>,              5, &DBSCHEMA_INDEXES>                   CIndexes;
typedef CRestrictions<CAccessor<CKeyColumnUsageInfo>,       7, &DBSCHEMA_KEY_COLUMN_USAGE>          CKeyColumnUsage;
typedef CRestrictions<CAccessor<CPrimaryKeyInfo>,           3, &DBSCHEMA_PRIMARY_KEYS>              CPrimaryKeys;
typedef CRestrictions<CAccessor<CProcedureColumnInfo>,      4, &DBSCHEMA_PROCEDURE_COLUMNS>         CProcedureColumns;
typedef CRestrictions<CAccessor<CProcedureParameterInfo>,   4, &DBSCHEMA_PROCEDURE_PARAMETERS>      CProcedureParameters;
typedef CRestrictions<CAccessor<CProcedureInfo>,            4, &DBSCHEMA_PROCEDURES>                CProcedures;
typedef CRestrictions<CAccessor<CProviderTypeInfo>,         2, &DBSCHEMA_PROVIDER_TYPES>            CProviderTypes;
typedef CRestrictions<CAccessor<CReferentialConstraintInfo>,3, &DBSCHEMA_REFERENTIAL_CONSTRAINTS>   CReferentialConstraints;
typedef CRestrictions<CAccessor<CSchemataInfo>,             3, &DBSCHEMA_SCHEMATA>                  CSchemata;
typedef CRestrictions<CAccessor<CSQLLanguageInfo>,          0, &DBSCHEMA_SQL_LANGUAGES>             CSQLLanguages;
typedef CRestrictions<CAccessor<CStatisticInfo>,            3, &DBSCHEMA_STATISTICS>                CStatistics ;
typedef CRestrictions<CAccessor<CTableConstraintInfo>,      7, &DBSCHEMA_TABLE_CONSTRAINTS>         CTableConstraints;
typedef CRestrictions<CAccessor<CTablePrivilegeInfo>,       5, &DBSCHEMA_TABLE_PRIVILEGES>          CTablePrivileges;
typedef CRestrictions<CAccessor<CTableInfo>,                4, &DBSCHEMA_TABLES>                    CTables;
typedef CRestrictions<CAccessor<CTranslationInfo>,          3, &DBSCHEMA_TRANSLATIONS>              CTranslations;
typedef CRestrictions<CAccessor<CUsagePrivilegeInfo>,       6, &DBSCHEMA_USAGE_PRIVILEGES>          CUsagePrivileges;
typedef CRestrictions<CAccessor<CViewColumnUsageInfo>,      3, &DBSCHEMA_VIEW_COLUMN_USAGE>         CViewColumnUsage;
typedef CRestrictions<CAccessor<CViewTableUsageInfo>,       3, &DBSCHEMA_VIEW_TABLE_USAGE>          CViewTableUsage;
typedef CRestrictions<CAccessor<CViewInfo>,                 3, &DBSCHEMA_VIEWS>                     CViews;

///////////////////////////////////////////////////////////////////////////

}; //namespace ATL

#endif // __ATLDBSCH_H__

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlevent.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEVENT_H__
#define __ATLEVENT_H__

#define __ATLEVENT_VER 1

#pragma once

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

struct __EventingCriticalSectionStub {
   void Lock() {}
   void Unlock() {}
};

struct __EventingCriticalSectionAuto {
    void EmitError(char* csError) {
        TCHAR buf[255];
        wsprintf(buf, _T("cannot initialize critical section(Error %s,%s,line %d)\n"),
            csError, __FILE__, __LINE__);
        MessageBox(0, buf, 0, MB_OK | MB_ICONHAND);
    }
    void Lock() {
        __try{
            EnterCriticalSection(&m_sec);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            char* csError = (STATUS_NO_MEMORY == GetExceptionCode()) ? "E_OUTOFMEMORY" : "E_FAIL";
            EmitError(csError);
        }
    }
    void Unlock() {
        LeaveCriticalSection(&m_sec);
    }
    __EventingCriticalSectionAuto() {
        __try {
            InitializeCriticalSection(&m_sec);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            char* csError = (STATUS_NO_MEMORY == GetExceptionCode()) ? "E_OUTOFMEMORY" : "E_FAIL";
            EmitError(csError);
        }
    }
    ~__EventingCriticalSectionAuto() { DeleteCriticalSection(&m_sec); }
    CRITICAL_SECTION m_sec;
};

template <class T>
class __eventingGetAddr {
public:
    typedef void (T::*pmfn_type) ();
    typedef void (*pgfn_type) ();
    union U {
        void *addr;
        void (T::*pmfn)();
        void (*pgfn)();
    };
    static pmfn_type __getMAddr(void *addr) {
        U u;
        u.addr = addr;
        return u.pmfn;
    }
    static void* __getVAddr(pmfn_type pmfn) {
        U u;
        u.pmfn = pmfn;
        return u.addr;
    }
    static pgfn_type __getSMAddr(void *addr) {
        U u;
        u.addr = addr;
        return u.pgfn;
    }
    static void* __getSVAddr(pgfn_type pgfn) {
        U u;
        u.pgfn = pgfn;
        return u.addr;
    }
};

HRESULT __stdcall _com_handle_excepinfo(EXCEPINFO& excepInfo, IErrorInfo** pperrinfo);

namespace ATL {
    inline HRESULT
    __ComInvokeEventHandler(IDispatch* pDispatch, DISPID id, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult) {
        if (pVarResult != 0) {
            VariantInit(pVarResult);
        }
        EXCEPINFO excepInfo;
        memset(&excepInfo, 0, sizeof excepInfo);
        UINT nArgErr = (UINT)-1;
        HRESULT hr = pDispatch->Invoke(id, IID_NULL, LOCALE_USER_DEFAULT, wFlags, pDispParams, pVarResult, &excepInfo, &nArgErr);
        IErrorInfo* perrinfo = 0;
        _com_handle_excepinfo(excepInfo, &perrinfo);
        if (FAILED(hr)) {
            SetErrorInfo(0, perrinfo);
        }
        return hr;
    }
    
    struct __EventHandlerProxy {
        virtual HRESULT __cdecl __eventHandlerProxy(int idx, ...) = 0;
    };
    struct __EventHandlerNodeProxy {
        virtual int __Index(int i) = 0;
    };
    template <typename T /*super*/>
    class __ComEventingImpl : public __EventHandlerProxy {
        enum { __InvalidIndex = -1 };
        struct __ComEventingNode : __EventHandlerNodeProxy {
            __ComEventingNode(T* pThis = 0, IUnknown* pSource = 0, IUnknown* pSink = 0,
                const _GUID* pGuid = 0, int nSize = 0) {
                __pThis = pThis;
                __nHooks = 0;
                __dwAdvise = 0;
                __pSource = pSource;
                __pSink = pSink;
                __pNext = 0;
                __pGuid = const_cast<_GUID*> (pGuid);
                __nArraySize = nSize;
                __proxyIndex = new int[__nArraySize];
                memset(__proxyIndex, 0xff, __nArraySize*sizeof(int));
            }
            int __Index(int i) {
                return __proxyIndex[i];
            }
            T* __pThis;
            int *__proxyIndex;
            int __nArraySize;
            int __nHooks;
            unsigned long __dwAdvise;
            IUnknown* __pSource;
            IUnknown* __pSink;
            _GUID* __pGuid;
            __ComEventingNode* __pNext;
        };
        __ComEventingNode* __pFirst;
        __ComEventingNode* __pLast;
        __ComEventingNode* __pCurrent;
    public:
        __ComEventingImpl() {
            __pCurrent = __pFirst = __pLast = 0;
        }
        ~__ComEventingImpl() {
            if (__pFirst != 0) {
                __pCurrent = __pFirst;
                while (__pCurrent != 0) {
                    __pCurrent->__pSink->Release();
                    delete [] __pCurrent->__proxyIndex;
                    __pFirst = __pCurrent;
                    __pCurrent = __pCurrent->__pNext;
                    delete __pFirst;
                }
            }
        }
        template <typename U /*interface*/>
        HRESULT __WhichThis(IUnknown* pS, T* pThis, int nSize, bool bNext, int idx) {
            if (bNext) {
                 if (__pCurrent != 0) {
                     __pCurrent = __pCurrent->__pNext;
                 }
            } else {
                __pCurrent = __pFirst;
            }
            if (__pCurrent == 0
                || __pCurrent->__pSource != pS
                || __pCurrent->__pThis != pThis
                || !IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
                if (__pCurrent != 0) {
                    __ComEventingNode* pTheOne = 0;
                    while ((__pCurrent = __pCurrent->__pNext) != 0) {
                        if (__pCurrent->__pSource == pS
                            && (__pCurrent->__pThis == pThis)
                            && IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
                            if (nSize > 0 || __pCurrent->__proxyIndex[idx] != __InvalidIndex) {
                                pTheOne = __pCurrent;
                                if (nSize > 0) {
                                    break;
                                }
                            }
                         }
                     }
                     if (pTheOne != 0) {
                         __pCurrent = pTheOne;
                         return S_OK;
                     }
                }
                if (nSize > 0) {
                    CComObject<U>* pSink;
                    HRESULT hr = CComObject<U>::CreateInstance(&pSink);
                    if (FAILED(hr)) {
                        return hr;
                    }
                    pSink->AddRef();
                    pSink->__pThis = pThis;
                    pSink->__pThat = __pCurrent = new __ComEventingNode(pThis, pS, pSink, U::Guid(), nSize);
                    if (__pLast != 0) {
                        __pLast->__pNext = __pCurrent;
                    } else {
                        __pFirst = __pCurrent;
                    }
                    __pLast = __pCurrent;
                }
            }
            return S_OK;
        }
        template <typename U /*interface*/>
        HRESULT __AddHandler(T* pThis, int idxSink, IUnknown* pS, int idx, int nSize) {
            if (pS == 0 || pThis == 0) {
                return E_FAIL;
            }
            bool bNext = false;
            bool bDone = false;
            while (!bDone) {
                HRESULT hr = __WhichThis<U>(pS, pThis, nSize, bNext, idx);
                if (SUCCEEDED(hr)) {
                    if (__pCurrent->__proxyIndex[idx] == __InvalidIndex) {
                        __pCurrent->__proxyIndex[idx] = idxSink;
                        ++__pCurrent->__nHooks;
                        __pCurrent->__pThis = pThis;
                        bDone = true;
                    }
                    if (__pCurrent->__dwAdvise == 0) {
                        return AtlAdvise(pS, __pCurrent->__pSink, *U::Guid(), &__pCurrent->__dwAdvise);
                    }
                    bNext = true;
                } else {
                    return hr;
                }
            }
            return S_OK;
        }
        template <typename U /*interface*/>
        HRESULT __RemoveHandler(T* pThis, IUnknown* pS, int idx) {
            bool bNext = false;
            bool bDone = false;
            while (!bDone) {
                __WhichThis<U>(pS, pThis, 0, bNext, idx);
                if (__pCurrent == 0) {
                    return E_FAIL;
                }
                if (__pCurrent->__proxyIndex[idx] != __InvalidIndex) {
                    __pCurrent->__proxyIndex[idx] = __InvalidIndex;
                    --__pCurrent->__nHooks;
                    bDone = true;
                }
                if (__pCurrent->__dwAdvise != 0 && __pCurrent->__nHooks == 0) {
                    HRESULT hr = AtlUnadvise(pS, *U::Guid(), __pCurrent->__dwAdvise);
                    if (SUCCEEDED(hr)) {
                        __pCurrent->__dwAdvise = 0;
                    }
                    return hr;
                }
                bNext = true;
            }
            return S_OK;
        }
        HRESULT __RemoveAllHandlers(IUnknown* pS, const _GUID* pIID) {
            HRESULT hr = E_FAIL;
            __pCurrent = __pFirst;
            while (1) {
                if (__pCurrent == 0) {
                    return hr;
                } else if ((pS == 0 || __pCurrent->__pSource == pS
                    && (pIID == 0 || IsEqualGUID(*pIID, *__pCurrent->__pGuid)))
                    && __pCurrent->__dwAdvise != 0) {
                    hr = AtlUnadvise(__pCurrent->__pSource, *__pCurrent->__pGuid, __pCurrent->__dwAdvise);
                    if (SUCCEEDED(hr)) {
                        __pCurrent->__dwAdvise = 0;
                        memset(__pCurrent->__proxyIndex, 0xff, __pCurrent->__nArraySize*sizeof(int));
                        __pCurrent->__nHooks = 0;
                    }
                }
                __pCurrent = __pCurrent->__pNext;
            }
        }
    };

    class __ComEventingImpl_LD {
        struct __EventCookieNode {
            __EventCookieNode(IUnknown* pS = 0, const _GUID* pG = 0) {
                __nextCookie = 0;
                __dwAdvise = 0;
                __pSource = pS;
                __pGuid = const_cast<_GUID*> (pG);
            }
            __EventCookieNode* __nextCookie;
            unsigned long __dwAdvise;
            IUnknown* __pSource;
            _GUID* __pGuid;
        } *__EventCookies;
    public:
        HRESULT __Advise(IUnknown* pSrc, IUnknown* pSink, const IID& iid) {
            __EventCookieNode* pRoot = __EventCookies;
            while (pRoot != 0) {
                if (pSrc == pRoot->__pSource
                    && IsEqualGUID(iid, *pRoot->__pGuid)
                    && pRoot->__dwAdvise == 0) {
                    break;
                }
                pRoot = pRoot->__nextCookie;
            }
            if (pRoot == 0) {
                pRoot = new __EventCookieNode(pSrc, &iid);
                pRoot->__nextCookie = __EventCookies;
                __EventCookies = pRoot;
            }
            return AtlAdvise(pSrc, pSink, iid, &pRoot->__dwAdvise);
        }
        HRESULT __Unadvise(IUnknown* pSrc, const IID& iid) {
            __EventCookieNode* pRoot = __EventCookies;
            __EventCookieNode* pTheOne = 0;
            while (pRoot != 0) {
                if (pSrc == pRoot->__pSource
                    && IsEqualGUID(iid, *pRoot->__pGuid)
                    && pRoot->__dwAdvise != 0) {
                    pTheOne = pRoot;
                }
                pRoot = pRoot->__nextCookie;
            }
            HRESULT hr = E_FAIL;
            if (pTheOne != 0) {
                hr = AtlUnadvise(pSrc, iid, pTheOne->__dwAdvise);
                if (SUCCEEDED(hr)) {
                    pTheOne->__dwAdvise = 0;
                }
            }
            return hr;
        }
        __ComEventingImpl_LD() {
            __EventCookies = 0;
        }
        ~__ComEventingImpl_LD() {
            while (__EventCookies != 0) {
                __EventCookieNode* pDead = __EventCookies;
                __EventCookies = __EventCookies->__nextCookie;
                delete pDead;
            }
        }
    };
}

#endif // __ATLEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlexcept.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXCEPT_H__
#define __ATLEXCEPT_H__

#pragma once

#include <atldef.h>
#include <atltrace.h>

namespace ATL
{

class CAtlException
{
public:
	CAtlException() throw() :
		m_hr( E_FAIL )
	{
	}

	CAtlException( HRESULT hr ) throw() :
		m_hr( hr )
	{
	}

	operator HRESULT() const throw()
	{
		return( m_hr );
	}

public:
	HRESULT m_hr;
};

#ifndef _ATL_NO_EXCEPTIONS

// Throw a CAtlException with the given HRESULT
#if defined( AtlThrow ) || defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow to throw a custom exception.
#ifdef _AFX
#error MFC projects must use default implementation of AtlThrow()
#endif
#else
ATL_NOINLINE __declspec(noreturn) inline void AtlThrow( HRESULT hr )
{
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
#ifdef _AFX
	if( hr == E_OUTOFMEMORY )
	{
		AfxThrowMemoryException();
	}
	else
	{
		AfxThrowOleException( hr );
	}
#else
	throw CAtlException( hr );
#endif
};
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE __declspec(noreturn) inline void AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#else  // no exception handling

// Throw a CAtlException with the given HRESULT
#if !defined( AtlThrow ) && !defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow
ATL_NOINLINE inline void AtlThrow( HRESULT hr )
{
	(void)hr;
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
	ATLASSERT( false );
}
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE inline void AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#endif  // no exception handling

};  // namespace ATL

#endif  // __ATLEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atldbcli.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// ATLDBCLI.H : ATL consumer code for OLEDB

#ifndef __ATLDBCLI_H__
#define __ATLDBCLI_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#include <atlbase.inl>

#include <atlsimpstr.h>

#if 0
#ifndef __ATLCOM_H__
#include <atlcom.h>
#endif
#endif

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

#include <oledberr.h>
#include <msdaguid.h>
#include <msdasc.h>

#pragma warning(push)

//REVIEW: remove this pragma once 113526 is resolved
#pragma warning(disable: 4244)

#ifndef _CPPUNWIND
#pragma warning(disable: 4702) // unreachable code
#endif

namespace ATL
{

#define DEFINE_OLEDB_TYPE_FUNCTION(ctype, oledbtype) \
	inline DBTYPE _GetOleDBType(ctype&) throw ()\
	{ \
		return oledbtype; \
	}
	inline DBTYPE _GetOleDBType(BYTE[]) throw ()
	{
		return DBTYPE_BYTES;
	}
	inline DBTYPE _GetOleDBType(CHAR[]) throw ()
	{
		return DBTYPE_STR;
	}
	inline DBTYPE _GetOleDBType(WCHAR[]) throw()
	{
		return DBTYPE_WSTR;
	}

	DEFINE_OLEDB_TYPE_FUNCTION(const WCHAR*, DBTYPE_WSTR | DBTYPE_BYREF)
	DEFINE_OLEDB_TYPE_FUNCTION(const CHAR*, DBTYPE_STR | DBTYPE_BYREF)

	DEFINE_OLEDB_TYPE_FUNCTION(CComBSTR, DBTYPE_BSTR)

	//DEFINE_OLEDB_TYPE_FUNCTION(__int8, DBTYPE_I1)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int16, DBTYPE_I2)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int32, DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(__int64, DBTYPE_I8)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int8, DBTYPE_UI1)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int16, DBTYPE_UI2)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int32, DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int64, DBTYPE_UI8)

	DEFINE_OLEDB_TYPE_FUNCTION(signed char      ,DBTYPE_I1)
	DEFINE_OLEDB_TYPE_FUNCTION(SHORT            ,DBTYPE_I2)     // DBTYPE_BOOL
	DEFINE_OLEDB_TYPE_FUNCTION(int              ,DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(LONG             ,DBTYPE_I4)     // DBTYPE_ERROR (SCODE)
	DEFINE_OLEDB_TYPE_FUNCTION(LARGE_INTEGER    ,DBTYPE_I8)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(CURRENCY		    ,DBTYPE_CY)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(BYTE             ,DBTYPE_UI1)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned short   ,DBTYPE_UI2)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned int     ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned long    ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(ULARGE_INTEGER   ,DBTYPE_UI8)
	DEFINE_OLEDB_TYPE_FUNCTION(float            ,DBTYPE_R4)
	DEFINE_OLEDB_TYPE_FUNCTION(double           ,DBTYPE_R8)     // DBTYPE_DATE
	DEFINE_OLEDB_TYPE_FUNCTION(DECIMAL          ,DBTYPE_DECIMAL)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_NUMERIC       ,DBTYPE_NUMERIC)
	DEFINE_OLEDB_TYPE_FUNCTION(VARIANT          ,DBTYPE_VARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(IDispatch*       ,DBTYPE_IDISPATCH)
	DEFINE_OLEDB_TYPE_FUNCTION(IUnknown*        ,DBTYPE_IUNKNOWN)
	DEFINE_OLEDB_TYPE_FUNCTION(GUID             ,DBTYPE_GUID)
	DEFINE_OLEDB_TYPE_FUNCTION(SAFEARRAY*       ,DBTYPE_ARRAY)
	DEFINE_OLEDB_TYPE_FUNCTION(DBVECTOR         ,DBTYPE_VECTOR)
	DEFINE_OLEDB_TYPE_FUNCTION(DBDATE           ,DBTYPE_DBDATE)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIME           ,DBTYPE_DBTIME)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIMESTAMP      ,DBTYPE_DBTIMESTAMP)
 	DEFINE_OLEDB_TYPE_FUNCTION(FILETIME			,DBTYPE_FILETIME)
	DEFINE_OLEDB_TYPE_FUNCTION(PROPVARIANT		,DBTYPE_PROPVARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_VARNUMERIC	,DBTYPE_VARNUMERIC)

// Internal structure containing the accessor handle and a flag
// indicating whether the data for the accessor is automatically
// retrieved
struct _ATL_ACCESSOR_INFO
{
	HACCESSOR   hAccessor;
	bool        bAutoAccessor;
};

class _CNoOutputColumns
{
public:
	static bool HasOutputColumns() throw ()
	{
		return false;
	}
	static ULONG _GetNumAccessors() throw ()
	{
		return 0;
	}
	static HRESULT _GetBindEntries(LPOLESTR*, DBORDINAL*, DBBINDING*, ULONG, bool*, BYTE* pBuffer = NULL, bool bClearOnly = false) throw ()
	{
		bClearOnly;
		pBuffer;
		return E_FAIL;
	}
};

class _CNoParameters
{
public:
	static bool HasParameters() throw ()
	{
		return false;
	}
	static HRESULT _GetParamEntries(LPOLESTR*, DBORDINAL*, DBBINDING*, BYTE* pBuffer = NULL, bool bClearOnly = false) throw ()
	{
		bClearOnly;
		pBuffer;
		return E_FAIL;
	}
};

class _CNoCommand
{
public:
	static HRESULT GetDefaultCommand(LPCWSTR* /*ppszCommand*/) throw ()
	{
		return S_OK;
	}
};

typedef _CNoOutputColumns   _OutputColumnsClass;
typedef _CNoParameters      _ParamClass;
typedef _CNoCommand         _CommandClass;

#define BEGIN_ACCESSOR_MAP(x, num) \
	public: \
	typedef x _classtype; \
	typedef x _OutputColumnsClass; \
	static ULONG _GetNumAccessors() throw()\
	{ \
		return num;  \
	} \
	static bool HasOutputColumns() throw () { return true; } \
	/* If pBindings == NULL means we only return the column number */ \
	/* If pBuffer != NULL then it points to the accessor buffer and */ \
	/* we release any appropriate memory e.g. BSTR's or interface pointers */ \
	inline static HRESULT _GetBindEntries(LPOLESTR* pColumnNames, \
											DBORDINAL* pColumns, \
											DBBINDING *pBinding, \
											ULONG nAccessor, \
											bool* pAuto, \
											BYTE* pBuffer = NULL, \
											bool bClearOnly = false) throw() \
	{ \
		ATLASSERT(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_NOTPARAM; \
		DBORDINAL nColumns = 0; \
		pBuffer;\

#define BEGIN_ACCESSOR(num, bAuto) \
	if (nAccessor == num) \
	{ \
		if (pBinding != NULL) \
			*pAuto = bAuto;

#define END_ACCESSOR() \
	} \
	else

#define END_ACCESSOR_MAP() \
		; \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define BEGIN_COLUMN_MAP(x) \
	BEGIN_ACCESSOR_MAP(x, 1) \
		BEGIN_ACCESSOR(0, true)

#define END_COLUMN_MAP() \
		END_ACCESSOR() \
	END_ACCESSOR_MAP()

#define offsetbuf(m) offsetof(_classtype, m)
#define _OLEDB_TYPE(data) ATL::_GetOleDBType(((_classtype*)0)->data)
#define _SIZE_TYPE(data) sizeof(((_classtype*)0)->data)

#define _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column ordinal number

#define COLUMN_ENTRY_EX(nOrdinal, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_ENTRY_TYPE(nOrdinal, wType, data) \
	COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, _SIZE_TYPE(data), data)

#define COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, nLength, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_TYPE_STATUS(nOrdinal, wType, status, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_TYPE_PS(nOrdinal, wType, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)
	
// Standard macros where type and size is worked out
#define COLUMN_ENTRY(nOrdinal, data) \
	COLUMN_ENTRY_TYPE(nOrdinal, _OLEDB_TYPE(data), data)

#define COLUMN_ENTRY_LENGTH(nOrdinal, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_STATUS(nOrdinal, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_LENGTH_STATUS(nOrdinal, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_ENTRY_PS(nOrdinal, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_PS_LENGTH(nOrdinal, nPrecision, nScale, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_PS_STATUS(nOrdinal, nPrecision, nScale, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_PS_LENGTH_STATUS(nOrdinal, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column name

#define COLUMN_NAME_EX(pszName, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_NAME_TYPE(pszName, wType, data) \
	COLUMN_NAME_TYPE_SIZE(pszName, wType, _SIZE_TYPE(data), data)

#define COLUMN_NAME_TYPE_SIZE(pszName, wType, nLength, data) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_NAME_TYPE_STATUS(pszName, wType, status, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_TYPE_PS(pszName, wType, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)
	
// Standard macros where type and size is worked out
#define COLUMN_NAME(pszName, data) \
	COLUMN_NAME_TYPE(pszName, _OLEDB_TYPE(data), data)

#define COLUMN_NAME_LENGTH(pszName, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_STATUS(pszName, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_LENGTH_STATUS(pszName, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_NAME_PS(pszName, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_NAME_PS_LENGTH(pszName, nPrecision, nScale, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_PS_STATUS(pszName, nPrecision, nScale, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_PS_LENGTH_STATUS(pszName, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))



#define BOOKMARK_ENTRY(variable) \
	COLUMN_ENTRY_TYPE_SIZE(0, DBTYPE_BYTES, _SIZE_TYPE(variable##.m_rgBuffer), variable##.m_rgBuffer)

#define _BLOB_ENTRY_CODE(nOrdinal, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _BLOB_NAME_CODE(pszName, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define BLOB_ENTRY(nOrdinal, IID, flags, data) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_ENTRY_STATUS(nOrdinal, IID, flags, data, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_ENTRY_LENGTH(nOrdinal, IID, flags, data, length) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_ENTRY_LENGTH_STATUS(nOrdinal, IID, flags, data, length, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BLOB_NAME(pszName, IID, flags, data) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_NAME_STATUS(pszName, IID, flags, data, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_NAME_LENGTH(pszName, IID, flags, data, length) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_NAME_LENGTH_STATUS(pszName, IID, flags, data, length, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BEGIN_PARAM_MAP(x) \
	public: \
	typedef x _classtype; \
	typedef x _ParamClass; \
	static bool HasParameters() throw () { return true; } \
	static HRESULT _GetParamEntries(LPOLESTR* pColumnNames, \
									DBORDINAL* pColumns, \
									DBBINDING *pBinding, \
									BYTE* pBuffer = NULL, \
									bool bClearOnly = false) throw () \
	{ \
		ATLASSERT(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_INPUT; \
		int nColumns = 0; \
		pBuffer;

#define END_PARAM_MAP() \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define SET_PARAM_TYPE(type) \
	eParamIO = type;

#ifdef _UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = szCommand; \
		return S_OK; \
	}
#else // !_UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		static CA2WEX<sizeof(szCommand)> szCmd(szCommand); \
		*ppwszCommand = szCmd; \
		return S_OK; \
	}
#endif // !_UNICODE

#pragma deprecated("DEFINE_COMMAND") // Use DEFINE_COMMAND_EX instead!

#define DEFINE_COMMAND_EX(x, wszCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = wszCommand; \
		return S_OK; \
	}


///////////////////////////////////////////////////////////////////////////
// class CDBErrorInfo

class CDBErrorInfo
{
public:
	// Use to get the number of error record when you want to explicitly check that
	// the passed interface set the error information
	HRESULT GetErrorRecords(IUnknown* pUnk, const IID& iid, ULONG* pcRecords) throw()
	{
		CComPtr<ISupportErrorInfo> spSupportErrorInfo;
		HRESULT hr = pUnk->QueryInterface(&spSupportErrorInfo);
		if (FAILED(hr))
			return hr;

		hr = spSupportErrorInfo->InterfaceSupportsErrorInfo(iid);
		if (FAILED(hr))
			return hr;

		return GetErrorRecords(pcRecords);
	}
	// Use to get the number of error records
	HRESULT GetErrorRecords(ULONG* pcRecords) throw ()
	{
		ATLASSERT(pcRecords != NULL);
		HRESULT hr;
		m_spErrorInfo.Release();
		m_spErrorRecords.Release();
		hr = ::GetErrorInfo(0, &m_spErrorInfo);
		if (hr == S_FALSE)
			return E_FAIL;

		hr = m_spErrorInfo->QueryInterface(__uuidof(IErrorRecords), (void**)&m_spErrorRecords);
		if (FAILED(hr))
		{
			// Well we got the IErrorInfo so we'll just treat that as
			// the one record
			*pcRecords = 1;
			return S_OK;
		}

		return m_spErrorRecords->GetRecordCount(pcRecords);
	}
	// Get the error information for the passed record number. GetErrorRecords must
	// be called before this function is called.
	HRESULT GetAllErrorInfo(ULONG ulRecordNum, LCID lcid, BSTR* pbstrDescription,
		BSTR* pbstrSource = NULL, GUID* pguid = NULL, DWORD* pdwHelpContext = NULL,
		BSTR* pbstrHelpFile = NULL) const throw() 
	{
		CComPtr<IErrorInfo> spErrorInfo;

		// If we have the IErrorRecords interface pointer then use it, otherwise
		// we'll just default to the IErrorInfo we have already retrieved in the call
		// to GetErrorRecords
		if (m_spErrorRecords != NULL)
		{
			HRESULT hr = m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, &spErrorInfo);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			ATLASSERT(m_spErrorInfo != NULL);
			spErrorInfo = m_spErrorInfo;
		}

		if (pbstrDescription != NULL)
			spErrorInfo->GetDescription(pbstrDescription);

		if (pguid != NULL)
			spErrorInfo->GetGUID(pguid);

		if (pdwHelpContext != NULL)
			spErrorInfo->GetHelpContext(pdwHelpContext);

		if (pbstrHelpFile != NULL)
			spErrorInfo->GetHelpFile(pbstrHelpFile);

		if (pbstrSource != NULL)
			spErrorInfo->GetSource(pbstrSource);

		return S_OK;
	}
	// Get the error information for the passed record number
	HRESULT GetBasicErrorInfo(ULONG ulRecordNum, ERRORINFO* pErrorInfo) const throw ()
	{
		return m_spErrorRecords->GetBasicErrorInfo(ulRecordNum, pErrorInfo);
	}
	// Get the custom error object for the passed record number
	HRESULT GetCustomErrorObject(ULONG ulRecordNum, REFIID riid, IUnknown** ppObject) const throw ()
	{
		return m_spErrorRecords->GetCustomErrorObject(ulRecordNum, riid, ppObject);
	}
	// Get the IErrorInfo interface for the passed record number
	HRESULT GetErrorInfo(ULONG ulRecordNum, LCID lcid, IErrorInfo** ppErrorInfo) const throw () 
	{
		return m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, ppErrorInfo);
	}
	// Get the error parameters for the passed record number
	HRESULT GetErrorParameters(ULONG ulRecordNum, DISPPARAMS* pdispparams) const throw () 
	{
		return m_spErrorRecords->GetErrorParameters(ulRecordNum, pdispparams);
	}

// Implementation
	CComPtr<IErrorInfo>     m_spErrorInfo;
	CComPtr<IErrorRecords>  m_spErrorRecords;
};

#ifdef _DEBUG
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK)
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[40];
	USES_CONVERSION;

	// If the user passed in an HRESULT then trace it
	if (hrErr != S_OK)
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr);

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if (FAILED(hr) && ErrorInfo.m_spErrorInfo == NULL)
	{
		ATLTRACE(atlTraceDBClient, 0, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr);
	}
	else
	{
		for (i = 0; i < cRecords; i++)
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceDBClient, 0,
					_T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr);
				return;
			}
			StringFromGUID2(guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR));
			ATLTRACE(atlTraceDBClient, 0,
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
				i, OLE2T(bstrSource), OLE2T(bstrDesc), OLE2T(bstrHelpFile), dwHelpContext, OLE2T(wszGuid));
			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump end\n"));
	}
}
#else
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK) throw() { hrErr; }
#endif


///////////////////////////////////////////////////////////////////////////
// class CDBPropSet

class CDBPropSet : public tagDBPROPSET
{
public:
	CDBPropSet()
	{
		rgProperties    = NULL;
		cProperties     = 0;
	}
	CDBPropSet(const GUID& guid)
	{
		rgProperties    = NULL;
		cProperties     = 0;
		guidPropertySet = guid;
	}
	CDBPropSet(const CDBPropSet& propset)
	{
		InternalCopy(propset);
	}
	~CDBPropSet()
	{
		for (ULONG i = 0; i < cProperties; i++)
			VariantClear(&rgProperties[i].vValue);

		CoTaskMemFree(rgProperties);
	}
	CDBPropSet& operator=(CDBPropSet& propset) throw()
	{
		this->~CDBPropSet();
		InternalCopy(propset);
		return *this;
	}
	// Set the GUID of the property set this class represents.
	// Use if you didn't pass the GUID to the constructor.
	void SetGUID(const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, const VARIANT& var, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		HRESULT hr;
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		hr = ::VariantCopy(&(rgProperties[cProperties].vValue), const_cast<VARIANT*>(&var));
		if (FAILED(hr))
			return false;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, LPCSTR szValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		USES_CONVERSION;
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = SysAllocString(A2COLE(szValue));
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
			return false;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, LPCWSTR szValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		USES_CONVERSION;
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = SysAllocString(W2COLE(szValue));
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
			return false;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, bool bValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BOOL;
		rgProperties[cProperties].vValue.boolVal = (bValue) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, BYTE bValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_UI1;
		rgProperties[cProperties].vValue.bVal   = bValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, short nValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I2;
		rgProperties[cProperties].vValue.iVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, long nValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I4;
		rgProperties[cProperties].vValue.lVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, float fltValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R4;
		rgProperties[cProperties].vValue.fltVal = fltValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, double dblValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R8;
		rgProperties[cProperties].vValue.dblVal = dblValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool AddProperty(DWORD dwPropertyID, CY cyValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_CY;
		rgProperties[cProperties].vValue.cyVal  = cyValue;
		cProperties++;
		return true;
	}
// Implementation
	// Create memory to add a new property
	bool Add(DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		DBPROP* rgTemp = (DBPROP*)CoTaskMemRealloc(rgProperties, (cProperties + 1) * sizeof(DBPROP));
		if (rgTemp == NULL)
			return false;
		rgProperties = rgTemp;
		rgProperties[cProperties].dwOptions = propoptions;
		rgProperties[cProperties].colid     = DB_NULLID;
		rgProperties[cProperties].vValue.vt = VT_EMPTY;
		return true;
	}
	// Copies in the passed value now it this value been cleared
	void InternalCopy(const CDBPropSet& propset) throw()
	{
		cProperties     = propset.cProperties;
		guidPropertySet = propset.guidPropertySet;
		rgProperties    = (DBPROP*)CoTaskMemAlloc(cProperties * sizeof(DBPROP));
		if (rgProperties != NULL)
		{
			for (ULONG i = 0; i < cProperties; i++)
			{
				rgProperties[i].dwPropertyID = propset.rgProperties[i].dwPropertyID;
				if( propset.rgProperties[i].dwOptions == DBPROPOPTIONS_OPTIONAL )
					rgProperties[i].dwOptions = DBPROPOPTIONS_OPTIONAL;
				else
					rgProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
				rgProperties[i].colid        = DB_NULLID;
				rgProperties[i].vValue.vt    = VT_EMPTY;
				VariantCopy(&rgProperties[i].vValue, &propset.rgProperties[i].vValue);
			}
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cProperties = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CDBPropIDSet

class CDBPropIDSet : public tagDBPROPIDSET
{
// Constructors and Destructors
public:
	CDBPropIDSet()
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
	}
	CDBPropIDSet(const GUID& guid)
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
		guidPropertySet = guid;
	}
	CDBPropIDSet(const CDBPropIDSet& propidset)
	{
		InternalCopy(propidset);
	}
	~CDBPropIDSet()
	{
		free(rgPropertyIDs);
	}
	CDBPropIDSet& operator=(CDBPropIDSet& propset) throw()
	{
		this->~CDBPropIDSet();
		InternalCopy(propset);
		return *this;
	}
	// Set the GUID of the property ID set
	void SetGUID(const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add a property ID to the set
	bool AddPropertyID(DBPROPID propid) throw()
	{
		if (!Add())
			return false;
		rgPropertyIDs[cPropertyIDs] = propid;
		cPropertyIDs++;
		return true;
	}
// Implementation
	bool Add() throw()
	{
		DBPROPID* pTempID  = (DBPROPID*)realloc(rgPropertyIDs, (cPropertyIDs + 1) * sizeof(DBPROPID));
		if (pTempID == NULL)
			return false;

		rgPropertyIDs = pTempID;
		return true;
	}
	void InternalCopy(const CDBPropIDSet& propidset) throw()
	{
		cPropertyIDs    = propidset.cPropertyIDs;
		guidPropertySet = propidset.guidPropertySet;
		rgPropertyIDs   = NULL;
		ATLTRY(rgPropertyIDs   = (DBPROPID*)malloc(cPropertyIDs * sizeof(DBPROPID)));
		if (rgPropertyIDs != NULL)
		{
			for (ULONG i = 0; i < cPropertyIDs; i++)
				rgPropertyIDs[i] = propidset.rgPropertyIDs[i];
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cPropertyIDs = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CBookmarkBase

class ATL_NO_VTABLE CBookmarkBase
{
public:
	virtual DBLENGTH GetSize() const = 0;
	virtual BYTE* GetBuffer() const = 0;
};


///////////////////////////////////////////////////////////////////////////
// class CBookmark

template <DBLENGTH nSize = 0>
class CBookmark : public CBookmarkBase
{
public:
	virtual DBLENGTH   GetSize() const throw() { return nSize; }
	virtual BYTE*   GetBuffer() const throw() { return (BYTE*)m_rgBuffer; }

// Implementation
	BYTE m_rgBuffer[nSize];
};


// Size of 0 means that the memory for the bookmark will be allocated
// at run time.
template <>
class CBookmark<0> : public CBookmarkBase
{
public:
	CBookmark()
	{
		m_nSize = 0;
		m_pBuffer = NULL;
	}
	CBookmark(DBLENGTH nSize)
	{
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		m_nSize = (m_pBuffer == NULL) ? 0 : nSize;
	}
	~CBookmark()
	{
		delete [] m_pBuffer;
	}
	CBookmark& operator=(const CBookmark& bookmark) throw()
	{
		SetBookmark(bookmark.GetSize(), bookmark.GetBuffer());
		return *this;
	}
	virtual DBLENGTH GetSize() const throw() { return m_nSize; }
	virtual BYTE* GetBuffer() const throw() { return m_pBuffer; }
	// Sets the bookmark to the passed value
	HRESULT SetBookmark(DBLENGTH nSize, BYTE* pBuffer) throw()
	{
		ATLASSERT(pBuffer != NULL);
		delete [] m_pBuffer;
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		if (m_pBuffer != NULL)
		{
			memcpy(m_pBuffer, pBuffer, nSize);
			m_nSize = nSize;
			return S_OK;
		}
		else
		{
			m_nSize = 0;
			return E_OUTOFMEMORY;
		}
	}
	DBLENGTH  m_nSize;
	BYTE*   m_pBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessorBase

class CAccessorBase
{
public:
	CAccessorBase()
	{
		m_pAccessorInfo  = NULL;
		m_nAccessors     = 0;
		m_pBuffer        = NULL;
	}
	void Close() throw()
	{
		// If Close is called then ReleaseAccessors must have been
		// called first
		ATLASSERT(m_nAccessors == 0);
		ATLASSERT(m_pAccessorInfo == NULL);
	}
	// Get the number of accessors that have been created
	ULONG GetNumAccessors() const throw() { return m_nAccessors; }
	// Get the handle of the passed accessor (offset from 0)
	HACCESSOR GetHAccessor(ULONG nAccessor) const throw() 
	{
		ATLASSERT(nAccessor<m_nAccessors);
		return m_pAccessorInfo[nAccessor].hAccessor;
	};
	// Called during Close to release the accessor information
	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		ATLASSERT(pUnk != NULL);
		HRESULT hr = S_OK;
		if (m_nAccessors > 0)
		{
			CComPtr<IAccessor> spAccessor;
			hr = pUnk->QueryInterface(__uuidof(IAccessor), (void**)&spAccessor);
			if (SUCCEEDED(hr))
			{
				ATLASSERT(m_pAccessorInfo != NULL);
				for (ULONG i = 0; i < m_nAccessors; i++)
					spAccessor->ReleaseAccessor(m_pAccessorInfo[i].hAccessor, NULL);
			}
			m_nAccessors = 0;
			delete [] m_pAccessorInfo;
			m_pAccessorInfo = NULL;
		}
		return hr;
	}
	// Returns true or false depending upon whether data should be
	// automatically retrieved for the passed accessor.
	bool IsAutoAccessor(ULONG nAccessor) const throw() 
	{
		ATLASSERT(nAccessor < m_nAccessors);
		ATLASSERT(m_pAccessorInfo != NULL);
		return m_pAccessorInfo[nAccessor].bAutoAccessor;
	}

// Implementation
	// Used by the rowset class to find out where to place the data
	BYTE* GetBuffer() const throw() 
	{
		return m_pBuffer;
	}
	// Set the buffer that is used to retrieve the data
	void SetBuffer(BYTE* pBuffer) throw()
	{
		m_pBuffer = pBuffer;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return false;
	}

	// Allocate internal memory for the passed number of accessors
	HRESULT AllocateAccessorMemory(int nAccessors) throw()
	{
		// Can't be called twice without calling ReleaseAccessors first
		ATLASSERT(m_pAccessorInfo == NULL);
		m_nAccessors    = nAccessors;
		m_pAccessorInfo = NULL;
		ATLTRY(m_pAccessorInfo = new _ATL_ACCESSOR_INFO[nAccessors]);
		if (m_pAccessorInfo == NULL)
			return E_OUTOFMEMORY;
		else
			return S_OK;
	}
	// BindParameters will be overriden if parameters are used
	HRESULT BindParameters(HACCESSOR*, ICommand*, void**) throw() { return S_OK; }

	// Create an accessor for the passed binding information. The created accessor is
	// returned through the pHAccessor parameter.
	static HRESULT BindEntries(DBBINDING* pBindings, DBORDINAL nColumns, HACCESSOR* pHAccessor,
		DBLENGTH nSize, IAccessor* pAccessor) throw()
	{
		ATLASSERT(pBindings  != NULL);
		ATLASSERT(pHAccessor != NULL);
		ATLASSERT(pAccessor  != NULL);
		HRESULT hr;
		DBORDINAL i;
		DWORD dwAccessorFlags = (pBindings->eParamIO == DBPARAMIO_NOTPARAM) ?
			DBACCESSOR_ROWDATA : DBACCESSOR_PARAMETERDATA;

#ifdef _DEBUG
		// In debug builds we will retrieve the status flags and trace out
		// any errors that may occur.
		CAutoVectorPtr<DBBINDSTATUS> spStatus;
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, spStatus);
		if (FAILED(hr) && (DBBINDSTATUS*)spStatus)
		{
			for (i=0; i<nColumns; i++)
			{
				if (spStatus[i] != DBBINDSTATUS_OK)
					ATLTRACE(atlTraceDBClient, 0, _T("Binding entry %d failed. Status: %d\n"), i, spStatus[i]);
			}
		}
#else
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, NULL);
#endif
		for (i=0; i<nColumns; i++)
			delete pBindings[i].pObject;

		return hr;
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void Bind(DBBINDING* pBinding, DBORDINAL nOrdinal, DBTYPE wType,
		DBLENGTH nLength, BYTE nPrecision, BYTE nScale, DBPARAMIO eParamIO,
		DBBYTEOFFSET nDataOffset, DBBYTEOFFSET nLengthOffset = NULL, DBBYTEOFFSET nStatusOffset = NULL,
		DBOBJECT* pdbobject = NULL) throw()
	{
		ATLASSERT(pBinding != NULL);

		// If we are getting a pointer to the data then let the provider
		// own the memory
		if (wType & DBTYPE_BYREF)
			pBinding->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
		else
			pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

		pBinding->pObject   = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = nDataOffset;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = DBPART_VALUE;
		if (nLengthOffset != NULL)
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != NULL)
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}

	// Free memory if appropriate
	static inline void FreeType(DBTYPE wType, BYTE* pValue, IRowset* pRowset = NULL) throw()
	{
		if (pValue == NULL || *pValue == NULL)
			return;

		if( wType & DBTYPE_ARRAY )
		{
			SAFEARRAY** ppSafeArray = (SAFEARRAY**)pValue;
			if( ppSafeArray != NULL )
				SafeArrayDestroy(*ppSafeArray);
		}
		else
		{
			switch (wType)
			{
				case DBTYPE_BSTR:
					SysFreeString(*((BSTR*)pValue));
				break;
				case DBTYPE_VARIANT:
					VariantClear((VARIANT*)pValue);
				break;
				case DBTYPE_IUNKNOWN:
				case DBTYPE_IDISPATCH:
					(*(IUnknown**)pValue)->Release();
				break;

				case DBTYPE_HCHAPTER:
					CComQIPtr<IChapteredRowset> spChapteredRowset = pRowset;
					if (spChapteredRowset != NULL)
						spChapteredRowset->ReleaseChapter(*(HCHAPTER*)pValue, NULL);
				break;
			}
		}
		if ((wType & DBTYPE_VECTOR) && ~(wType & DBTYPE_BYREF))
			CoTaskMemFree(((DBVECTOR*)pValue)->ptr);
	}

	void FreeRecordMemory(IRowset* /*pRowset*/) throw()
	{
	}

	_ATL_ACCESSOR_INFO* m_pAccessorInfo;
	ULONG               m_nAccessors;
	BYTE*               m_pBuffer;
};

class CXMLAccessor;

///////////////////////////////////////////////////////////////////////////
// class CRowset

template <class TAccessor = CAccessorBase>
class CRowset
{
// Constructors and Destructors
public:
	CRowset()
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = NULL;
	}
	CRowset(IRowset* pRowset)
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = NULL;
		m_spRowset  = pRowset;
	}
	~CRowset()
	{
		Close();
	}

	HRESULT GetXMLColumnInfo( CSimpleStringW& strOutput ) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSERT( m_pXMLAccessor != NULL );

		return m_pXMLAccessor->GetXMLColumnData( strOutput );
	}

	HRESULT GetXMLRow( CSimpleStringW& strOutput, bool bAppend = false ) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_hRow != NULL);

		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSERT( m_pXMLAccessor != NULL );

		hr = m_spRowset->GetData(m_hRow, m_pXMLAccessor->GetHAccessor(0), m_pXMLAccessor->GetBuffer());
		if( FAILED(hr) )
			return hr;

		hr = m_pXMLAccessor->GetXMLRowData( strOutput, bAppend );

		m_pXMLAccessor->FreeRecordMemory( GetInterface() );
		return hr;
	}

	// Release any retrieved row handles and then release the rowset
	void Close() throw()
	{
		if( m_pXMLAccessor != NULL )
		{
			if (m_spRowset != NULL)
				m_pXMLAccessor->ReleaseAccessors( m_spRowset );
			delete m_pXMLAccessor;
			m_pXMLAccessor = NULL;
		}
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
			m_spRowset.Release();
			m_spRowsetChange.Release();
		}
	}
	// Addref the current row
	HRESULT AddRefRows() throw()
	{
		ATLASSERT(m_spRowset != NULL);
		return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
	}
	// Release the current row
	HRESULT ReleaseRows() throw()
	{
		ATLASSERT(m_spRowset != NULL);
		HRESULT hr = S_OK;

		if (m_hRow != NULL)
		{
			hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
			m_hRow = NULL;
		}
		return hr;
	}

	CRowset<>* GetRowsetBase() throw()
	{
		return (CRowset<>*)this;
	}

	// Compare two bookmarks with each other
	HRESULT Compare(const CBookmarkBase& bookmark1, const CBookmarkBase& bookmark2, DBCOMPARE* pComparison) const throw()
	{
		ATLASSERT(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
			bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
	}

	// Compare the passed hRow with the current row
	HRESULT IsSameRow(HROW hRow) const throw() 
	{
		ATLASSERT(m_spRowset != NULL);
		if (m_hRow == hRow)
			return S_OK;

		CComPtr<IRowsetIdentity> spRowsetIdentity;
		HRESULT hr = m_spRowset.QueryInterface(&spRowsetIdentity);
		if (FAILED(hr))
			return hr;

		return spRowsetIdentity->IsSameRow(m_hRow, hRow);
	}

	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}

	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}

	// Move lSkip records forward or backward
	HRESULT MoveNext(LONG lSkip, bool bForward = true) throw()
	{
		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// Get the row handle
		HROW* phRow = &m_hRow;
		hr = m_spRowset->GetNextRows(NULL, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return hr;
	}

	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		HRESULT hr;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext();
	}

	// Move to the last record
	HRESULT MoveLast() throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);

		// Release a row if one is already around
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();

		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;

		// Restart the rowset position and then move backwards

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		m_spRowset->RestartPosition(NULL);
		hr = m_spRowset->GetNextRows(NULL, -1, 1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(const CBookmarkBase& bookmark, LONG lSkip = 0) throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);

		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;
		hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, 1, &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}

	// Get the data for the current record
	HRESULT GetData() throw()
	{
		HRESULT hr = S_OK;
		ATLASSERT(m_pAccessor != NULL);

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			if (m_pAccessor->IsAutoAccessor(i))
			{
				hr = GetData(i);
				if (FAILED(hr))
					return hr;
			}
		}
		return hr;
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetData(int nAccessor) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);
		ATLASSERT(m_hRow != NULL);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetDataHere(int nAccessor, void* pBuffer) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);
		ATLASSERT(m_hRow != NULL);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
	}

	HRESULT GetDataHere(void* pBuffer) throw()
	{
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = GetDataHere(i, pBuffer);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Insert the current record
	HRESULT Insert(int nAccessor = 0, bool bGetHRow = false) throw()
	{
		ATLASSERT(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			HROW* pHRow;
			if (bGetHRow)
			{
				ReleaseRows();
				pHRow = &m_hRow;
			}
			else
				pHRow = NULL;

			hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
					m_pAccessor->GetBuffer(), pHRow);

		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Delete the current record
	HRESULT Delete() const throw() 
	{
		ATLASSERT(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
			hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Update the current record
	HRESULT SetData() const throw()
	{
		ATLASSERT(m_pAccessor != NULL);
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = SetData(i);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Update the current record with the data in the passed accessor
	HRESULT SetData(int nAccessor) const throw()
	{
		ATLASSERT(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
				m_pAccessor->GetBuffer());
		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Get the data most recently fetched from or transmitted to the data source.
	// Does not get values based on pending changes.
	HRESULT GetOriginalData() throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_pAccessor != NULL);

		HRESULT hr = S_OK;
		CComPtr<IRowsetUpdate> spRowsetUpdate;
		hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i = 0; i < nAccessors; i++)
		{
			hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Get the status of the current row
	HRESULT GetRowStatus(DBPENDINGSTATUS* pStatus) const throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(pStatus != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
	}

	// Undo any changes made to the current row since it was last fetched or Update
	// was called for it
	HRESULT Undo(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSERT(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW> sprgRows;
		CComHeapPtr<DBROWSTATUS> spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}

	// Transmits any pending changes made to a row since it was last fetched or Update was
	// called for it. Also see SetData.
	HRESULT Update(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSERT(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW>           sprgRows;
		CComHeapPtr<DBROWSTATUS>    spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}
	// Transmits any pending changes to all rows made since it was last fetched or Update was
	// alled for it.  Differs from Update in that it will do every row (even if we don't hold
	// the handle for it).  
	HRESULT UpdateAll(DBCOUNTITEM* pcRows = NULL, HROW** pphRow = NULL, DBROWSTATUS** ppStatus = NULL) throw()
	{
		ATLASSERT(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		// Create some temporary variables to help with debugging.
		DBCOUNTITEM		cRowsReturned = 0;
		CComHeapPtr<HROW>			sprgRows;
		CComHeapPtr<DBROWSTATUS>	spRowStatus;

		// Passing zero for the 2nd parameter tells the provider to update ALL pending rows.
		// The 3rd parameter, prghRows is ignored.  
		hr =  spRowsetUpdate->Update(NULL, 0, NULL, &cRowsReturned, &sprgRows, &spRowStatus);

		// NOTE, the user must CoTaskMemFree *pphRow and *ppStatus after return, if they 
		// are non-NULL.  Otherwise, we'll CoTaskMemFree if they are NULL.
		if (pcRows != NULL)
			*pcRows = cRowsReturned;

		if (pphRow != NULL)
			*pphRow = sprgRows.Detach();

		if (ppStatus != NULL)
			*ppStatus = spRowStatus.Detach();

		return hr;
	}

	// Get the approximate position of the row corresponding to the passed bookmark
	HRESULT GetApproximatePosition(const CBookmarkBase* pBookmark, DBCOUNTITEM* pPosition, DBCOUNTITEM* pcRows) throw()
	{
		ATLASSERT(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (SUCCEEDED(hr))
		{
			if (pBookmark != NULL)
				hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
						pPosition, pcRows);
			else
				hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);

		}
		return hr;

	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(DBCOUNTITEM nNumerator, DBCOUNTITEM nDenominator, bool bForward = true) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		DBCOUNTITEM nRowsFetched;

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		HROW* phRow = &m_hRow;
		hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
			&nRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr == S_OK)
			hr = GetData();

		return hr;
	}

	HRESULT FindNextRow(DBCOMPAREOP op, BYTE* pData, DBTYPE wType, DBLENGTH nLength,
		BYTE bPrecision, BYTE bScale, BOOL bSkipCurrent = TRUE, CBookmarkBase* pBookmark = NULL) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		DBBINDING   binding;
		HRESULT     hr;
		HACCESSOR   hAccessor;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW*       phRow = &m_hRow;
		DBLENGTH    cbBookmark;
		BYTE*       pBookmarkBuffer;
		CComQIPtr<IAccessor, &__uuidof(IAccessor)>        spAccessor(m_spRowset);
		CComQIPtr<IRowsetFind, &__uuidof(IRowsetFind)>    spRowsetFind(m_spRowset);

		if (spAccessor == NULL || spRowsetFind == NULL)
			return E_NOINTERFACE;

		TAccessor::Bind(&binding, 1, wType, nLength, bPrecision, bScale, DBPARAMIO_NOTPARAM, 0);
		hr = CAccessorBase::BindEntries(&binding, 1, &hAccessor, nLength, spAccessor);
		if (FAILED(hr))
			return hr;

		if (pBookmark == NULL)
		{
			cbBookmark = 0;
			pBookmarkBuffer = NULL;
		}
		else
		{
			cbBookmark = pBookmark->GetSize();
			pBookmarkBuffer = pBookmark->GetBuffer();
		}

		hr = spRowsetFind->FindNextRow(DB_NULL_HCHAPTER, hAccessor, pData, op, cbBookmark, pBookmarkBuffer,
					bSkipCurrent, 1,  &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		spAccessor->ReleaseAccessor(hAccessor, NULL);
		if (FAILED(hr))
		{
			ATLTRACE(_T("ATL: GetData from FindNextRows failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return S_OK;
	}

// Implementation
	static const IID& GetIID() throw()
	{
		return __uuidof(IRowset);
	}
	
	IRowset* GetInterface() const throw() 
	{
		return m_spRowset;
	}
	
	IRowset** GetInterfacePtr() throw()
	{
		return &m_spRowset;
	}
	
	void SetupOptionalRowsetInterfaces() throw()
	{
		// Cache IRowsetChange if available
		if (m_spRowset != NULL)
			m_spRowset->QueryInterface(&m_spRowsetChange);
	}
	
	HRESULT BindFinished() const throw() 
	{ 
		return S_OK; 
	}

	void SetAccessor(TAccessor* pAccessor) throw()
	{
		m_pAccessor = pAccessor;
	}

	CComPtr<IRowset>        m_spRowset;
	CComPtr<IRowsetChange>  m_spRowsetChange;
	TAccessor*				m_pAccessor;
	HROW                    m_hRow;
	CXMLAccessor* m_pXMLAccessor;
};

///////////////////////////////////////////////////////////////////////////
// class CBulkRowset

template <class TAccessor>
class CBulkRowset : public CRowset<TAccessor>
{
public:
	CBulkRowset()
	{
		// Default the number of rows to bulk fetch to 10
		m_nRows = 10;
		m_hr    = S_OK;
		m_phRow = NULL;
	}

	~CBulkRowset()
	{
		Close();
	}

	void Close() throw()
	{
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
		}
		CRowset<TAccessor>::Close();

		delete [] m_phRow;
		m_phRow = NULL;

		m_hr = S_OK;
	}
	// Set the number of row handles that will be retrieved in each
	// bulk row fetch. The default is 10 and this function must be called
	// before Open if you wish to change it.
	void SetRows(DBROWCOUNT nRows) throw()
	{
		if (nRows == 0)
			nRows = 10;
		if (nRows != m_nRows)
		{
			// This function must be called before the memory is allocated
			// during binding or between a Close() and a Open()
			delete m_phRow;
			m_phRow = NULL;
			m_nRows = nRows;
		}
	}
	// AddRef all the currently retrieved row handles
	HRESULT AddRefRows() throw()
	{
		ATLASSERT(m_spRowset != NULL);
		return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
	}
	// Release all the currently retrieved row handles
	HRESULT ReleaseRows() throw()
	{
		ATLASSERT(m_spRowset != NULL);
		// We're going to Release the rows so reset the current row position
		m_nCurrentRow = 0;
		m_hRow        = NULL;
		DBCOUNTITEM nCurrentRows = m_nCurrentRows;
		m_nCurrentRows = 0;
		return m_spRowset->ReleaseRows(nCurrentRows, m_phRow, NULL, NULL, NULL);
	}
	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		ATLASSERT(m_spRowset != NULL);

		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		HRESULT hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext(0);
	}
	// Move to the last record
	HRESULT MoveLast() throw()
	{
		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = S_OK;
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return CRowset<TAccessor>::MoveLast();
	}
	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}
	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}
	// Move lSkip records forward or backward
	HRESULT MoveNext(DBROWOFFSET lSkip, bool bForward = true) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		ATLASSERT(m_phRow    != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);

		// Calculate the record index in the buffer
		DBROWOFFSET nNewRow = m_nCurrentRow + lSkip + (bForward ? 1 : -1);

		bool bFetchNewRows = false;
		// Is the row in the buffer?
		// else adjust the skip value
		if (m_nCurrentRows == 0)
		{
			//lSkip = 0;
			bFetchNewRows = true;
		}
		else if (nNewRow >= (DBROWOFFSET)m_nCurrentRows)
		{
			bFetchNewRows = true;
			lSkip = nNewRow - m_nCurrentRows + (bForward ? 0 : (2 - m_nRows));
		}
		else if (nNewRow < 0)
		{
			lSkip = nNewRow - (m_nCurrentRows - m_nCurrentRow) + (bForward ? 0 : (2 - m_nRows));
			bFetchNewRows = true;
		}

		if (bFetchNewRows)
		{
			nNewRow = 0;
			// If we've reached the end of the buffer and we had a non S_OK HRESULT from
			// the last call to GetNextRows then return that HRESULT now.
			if (m_hr != S_OK && m_hr != DB_S_ROWLIMITEXCEEDED)
				return m_hr;

			// We've finished with these rows so we need some more
			// First release any HROWs that we have
			ReleaseRows();

			// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
			// DBPROP_CANSCROLLBACKWARDS properties have not been set and the lSkip offset is negative.
			m_hr = m_spRowset->GetNextRows(NULL, lSkip, m_nRows, &m_nCurrentRows, &m_phRow);

			// If we have an error HRESULT or we haven't retrieved any rows then return
			// the HRESULT now.
			if (FAILED(m_hr) || m_nCurrentRows == 0)
				return m_hr;
			if (!bForward)
				nNewRow = m_nCurrentRows - 1;
		}

		// Get the data for the current row
		m_hRow = m_phRow[m_nCurrentRow = nNewRow];
		return GetData();
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(const CBookmarkBase& bookmark, DBCOUNTITEM lSkip = 0) throw()
	{
		ATLASSERT(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset->QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
		if( (m_hr != S_OK || m_nCurrentRows == 0 ) && m_hr != DB_S_ENDOFROWSET)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(DBCOUNTITEM nNumerator, DBCOUNTITEM nDenominator) throw()
	{
		ATLASSERT(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
		if (m_hr != S_OK || m_nCurrentRows == 0)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Insert the current record
	HRESULT Insert(int nAccessor = 0, bool bGetHRow = false) throw()
	{
		ReleaseRows();
		return CRowset< TAccessor >::Insert(nAccessor, bGetHRow);
	}

// Implementation
	HRESULT BindFinished() throw()
	{
		// No rows in the buffer yet
		m_nCurrentRows = 0;
		// Cause MoveNext to automatically perform a new bulk fetch the first time
		m_nCurrentRow  = 0;
		m_hr = S_OK;

		// Do not allocate if the buffer has been allocated by a previous call to BindFinished.
		if (m_phRow == NULL)
		{
			ATLTRY(m_phRow = new HROW[m_nRows]);
			if (m_phRow == NULL)
				return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
	HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
	DBROWCOUNT   m_nRows;        // Number of rows that will fit in the buffer
	DBCOUNTITEM  m_nCurrentRows; // Number of rows currently in the buffer
	DBCOUNTITEM  m_nCurrentRow;
};

///////////////////////////////////////////////////////////////////////////
// class CArrayRowset
//
// Allows you to access a rowset with an array syntax. TAccessor must be a
// CAccessor<> type class

template <class TAccessor>
class CArrayRowset :
	public CVirtualBuffer<TAccessor>,
	protected CBulkRowset<TAccessor>
{
public:
	CArrayRowset(int nMax = 100000) : CVirtualBuffer<TAccessor>(nMax)
	{
		m_nRowsRead = 0;
	}
	TAccessor& operator[](int nRow)
	{
		ATLASSERT(nRow >= 0);
		HRESULT hr = S_OK;
		TAccessor* pCurrent = m_pBase + m_nRowsRead;

		// Retrieve the row if we haven't retrieved it already
		while ((ULONG)nRow >= m_nRowsRead)
		{
			// REVIEW: This will change
			m_pAccessor->SetBuffer((BYTE*)pCurrent + sizeof(CAccessorBase));
			__try
			{
				// Get the row
				hr = MoveNext();
				if (hr != S_OK)
					break;
			}
			__except(Except(GetExceptionInformation()))
			{
			}
			m_nRowsRead++;
			pCurrent++;
		}

		if(hr != S_OK)
		{
			ATLASSERT(hr != DB_S_ENDOFROWSET);	// if you're getting this assertion, then
												// most likely you are trying to access an
												// out of bounds element of CArrayRowset
												// (ex. table[100].data where table has only 
												// 50 records)
			AtlThrow(hr);
		}

		return *(m_pBase + nRow);
	}

	HRESULT Snapshot() throw()
	{
		ATLASSERT(m_nRowsRead == 0);
		ATLASSERT(m_spRowset != NULL);
		HRESULT hr = MoveFirst();
		if (FAILED(hr))
			return hr;
		do
		{
			Write(*(TAccessor*)m_pAccessor->GetBuffer());
			m_nRowsRead++;
			hr = MoveNext();
		} while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);

		return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
	}
	ULONG   m_nRowsRead;
};

// Used when you don't need any parameters or output columns
class CNoAccessor
{
public:
	// We don't need any typedef's here as the default
	// global typedef is not to have any parameters and
	// output columns.
	HRESULT BindColumns(IUnknown*) throw() { return S_OK; }
	HRESULT BindParameters(HACCESSOR*, ICommand*, void**) throw() { return S_OK; }
	void    Close() throw() { }
	HRESULT ReleaseAccessors(IUnknown*) throw() { return S_OK; }
	void FreeRecordMemory(IRowset* /*pRowset*/) throw() { }
	void FreeRecordMemory(int /*nAccessor*/, IRowset* /*pRowset*/) throw() { }
	HRESULT GetColumnInfo(IRowset*, DBORDINAL*, DBCOLUMNINFO**) throw() { return E_FAIL; }
	ULONG GetNumAccessors() const throw() { return 0; }
	bool IsAutoAccessor(ULONG /*nAccessor*/) const throw() { return false; }
	HACCESSOR GetHAccessor(ULONG /*nAccessor*/) const throw() { return NULL; }
	BYTE* GetBuffer() const throw() { ATLASSERT(FALSE); return NULL; }
	static void Bind(DBBINDING*, DBORDINAL, DBTYPE, DBLENGTH, BYTE, BYTE, DBPARAMIO,
		DBBYTEOFFSET, DBBYTEOFFSET = NULL, DBBYTEOFFSET = NULL, DBOBJECT* = NULL) throw()
	{ ATLASSERT(FALSE); }
	bool NoBindOnNullRowset() const throw() { return false; }
};

// Used when a rowset will not be returned from the command
template <class TAccessor = CAccessorBase>
class CNoRowset
{
public:
	HRESULT             BindFinished() throw() { return S_OK; }
	void                Close() throw() { }
	static const IID&   GetIID() throw() { return IID_NULL; }
	IRowset*            GetInterface() const throw() { return NULL; }
	IRowset**           GetInterfacePtr() throw() { return NULL; }
	void                SetAccessor(void*) throw() { }
	void                SetupOptionalRowsetInterfaces() throw() { }

};

// Used with SQL Server 2000, a rowset will not be returned from the command, but instead
// we get an ISequentialStream object and use it to read the data.
template <class TAccessor = CAccessorBase>
class CStreamRowset
{
public:
	// Constructors & destructors
	CStreamRowset()
	{
		m_spStream = NULL;
	}

	~CStreamRowset()
	{
		Close();
	}

	// Methods
	void Close()
	{
		if (m_spStream != NULL)
			m_spStream.Release();
	}


	// Implementation
	static const IID& GetIID()
	{
		return IID_ISequentialStream;
	}
	ISequentialStream* GetInterface() const
	{
		return m_spStream;
	}
	ISequentialStream** GetInterfacePtr()
	{
		return &m_spStream;
	}

	HRESULT             BindFinished() throw() { return S_OK; }
	void                SetAccessor(void*) throw() { }
	void                SetupOptionalRowsetInterfaces() throw() { }

	CComPtr<ISequentialStream> m_spStream;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessor

// T is the class that contains the data that will be accessed.
template <class T>
class CAccessor :
	public CAccessorBase,
	public T
{
public:
// Implementation

	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(int nAccessor, IRowset* /* pRowset */) throw() 
	{
		nAccessor;
		__if_exists(_GetBindEntries)
		{
			DBORDINAL nColumns;
			
			// Passing in m_pBuffer tells the column entry maps to free the
			// memory for the types if appropriate
			_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL, m_pBuffer);
		}
	}
	void FreeRecordMemory(IRowset* pRowset) throw()
	{
		for (ULONG i = 0; i < GetNumAccessors(); i++)
			FreeRecordMemory(i, pRowset);
	}

	HRESULT GetColumnInfo(IRowset*, DBORDINAL*, DBCOLUMNINFO**) throw() { return E_FAIL; }

	void ClearRecordMemory() throw()
	{
		__if_exists(_GetBindEntries)
		{
			for (ULONG i = 0; i < _OutputColumnsClass::_GetNumAccessors(); i++)
			{
				DBORDINAL nColumns;
				_GetBindEntries(NULL, &nColumns, NULL, i, NULL, m_pBuffer, true);
			}
		}
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		HRESULT hr;
		ULONG   nAccessors;
		DBLENGTH  nSize;
		nAccessors = _OutputColumnsClass::_GetNumAccessors();

		SetBuffer((BYTE*)(T*)this);
		ClearRecordMemory();

		nSize = sizeof(T);
		hr = BindAccessors(nAccessors, nSize, pUnk);
		return hr;
	}
	HRESULT BindAccessors(ULONG nAccessors, DBLENGTH nSize, IUnknown* pUnk) throw()
	{
		ATLASSERT(pUnk != NULL);
		HRESULT hr;

		CComPtr<IAccessor> spAccessor;
		hr = pUnk->QueryInterface(&spAccessor);
		if (SUCCEEDED(hr))
		{
			// Allocate the accessor memory if we haven't done so yet
			if (m_pAccessorInfo == NULL)
			{
				hr = AllocateAccessorMemory(nAccessors);
				if (FAILED(hr))
					return hr;
			}

			for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
				hr = BindAccessor(spAccessor, i, nSize);
		}

		return hr;
	}

	HRESULT BindAccessor(IAccessor* pAccessor, ULONG nAccessor, DBLENGTH nSize) throw()
	{
		CAutoVectorPtr<DBBINDING>	spBindings;
		CAutoVectorPtr<LPOLESTR>	spColumnNames;
		DBORDINAL					nColumns;
		bool						bAuto = false;
		HRESULT						hr;
		CComHeapPtr<DBCOLUMNINFO>	spColumnInfo;
		DBORDINAL					nColumnInfoCount = 0;
		CComHeapPtr<OLECHAR>		spStringsBuffer;

		// First time just get the number of entries by passing in &nColumns
		_OutputColumnsClass::_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL);

		// Allocate the binding structures
		if( !spBindings.Allocate(nColumns) )
			return E_OUTOFMEMORY;

		for( ULONG i = 0; i < nColumns; i++ )
			spBindings[i].pObject = NULL;

		// Allocate the column names strings array
		if( !spColumnNames.Allocate(nColumns) )
			return E_OUTOFMEMORY;
		
		// Now get the bind entries
		hr = _OutputColumnsClass::_GetBindEntries(spColumnNames, &nColumns, spBindings, nAccessor, &bAuto);
		if (SUCCEEDED(hr))
		{
			// translate the columns names to oridinals if necessary
			for( ULONG i = 0; i < nColumns; i++ )
				if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
				{
					// if necessary, get the column information
					if( spColumnInfo == NULL )
					{
						if( FAILED( GetColumnNames( pAccessor, &spColumnInfo, &spStringsBuffer, &nColumnInfoCount ) ) )
						{
							ATLASSERT( FALSE ); // unable to get columns information
							return E_FAIL;
						}
					}
					if( ! GetOridinalColumnNo(spColumnNames[i], spBindings[i].iOrdinal, spColumnInfo, nColumnInfoCount ) )
					{
						ATLASSERT(FALSE); // unable to match column name to an oridinal !!!
						return E_FAIL;
					}
				}

			m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
			hr = BindEntries(spBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
		}
		else
		{
			// free any DBBINDING::pObject's
			for( ULONG i = 0; i < nColumns; i++ )
				delete spBindings[i].pObject;

		}
		return hr;
	}

	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer) throw()
	{
		HRESULT				hr = S_OK;

		// In the static accessor case, the parameter buffer will be T plus the size of CAccessorBase
		*ppParameterBuffer = static_cast<T*>(this);

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == NULL)
		{
			DBORDINAL					nColumns = 0;
			CAutoVectorPtr<DBBINDING>	spBinding;
			CAutoVectorPtr<LPOLESTR>	spColumnNames;

			CComHeapPtr<DBPARAMINFO>	spParameterInfo;
			DB_UPARAMS					nParameterInfoCount = 0;
			CComHeapPtr<OLECHAR>		spStringsBuffer;

			_ParamClass::_GetParamEntries(NULL, &nColumns, NULL);

			// Allocate the DBPARAMINFO array
			if( !spBinding.Allocate(nColumns) )
				return E_OUTOFMEMORY;

			// Allocate the column names strings array
			if( !spColumnNames.Allocate(nColumns) )
				return E_OUTOFMEMORY;
			
			hr = _ParamClass::_GetParamEntries(spColumnNames, &nColumns, spBinding);
			if (SUCCEEDED(hr))
			{
				// translate the columns names to oridinals if necessary
				for( ULONG i = 0; i < nColumns; i++ )
					if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
					{
						// if necessary, get the column information
						if( spParameterInfo == NULL )
						{
							if( FAILED( GetParameterNames( pCommand, &spParameterInfo, &spStringsBuffer, &nParameterInfoCount ) ) )
							{
								ATLASSERT( FALSE ); // unable to get columns information
								return E_FAIL;
							}
						}
						if( ! GetOridinalParameterNo(spColumnNames[i], spBinding[i].iOrdinal, spParameterInfo, nParameterInfoCount ) )
						{
							ATLASSERT(FALSE); // unable to match parameter name to an oridinal !!!
							return E_FAIL;
						}
					}

				// Get the IAccessor from the passed ICommand
				ATLASSERT(pCommand != NULL);
				CComPtr<IAccessor> spAccessor;
				hr = pCommand->QueryInterface(&spAccessor);
				if (SUCCEEDED(hr))
				{
					hr = BindEntries(spBinding, nColumns, pHAccessor, sizeof(T), spAccessor);
				}
			}
		}
		return hr;
	}

protected:
	bool GetOridinalColumnNo(LPCOLESTR pOleColumnName, DBORDINAL& nColumn, DBCOLUMNINFO* pColumnInfo, DBORDINAL nColumns ) throw()
	{
		ATLASSERT(pOleColumnName != NULL);
		ATLASSERT(pColumnInfo != NULL);

		if( pOleColumnName == NULL || pColumnInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nColumns; i++)
		{
			if (pColumnInfo[i].pwszName != NULL && wcscmp(pColumnInfo[i].pwszName, pOleColumnName) == 0)
			{
				nColumn = pColumnInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}

	HRESULT GetColumnNames( IAccessor* pAccessor, DBCOLUMNINFO** ppColumnInfo, OLECHAR** ppStringsBuffer, DBORDINAL* pnColumns ) throw()
	{
		ATLASSERT( ppColumnInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnColumns != NULL );
		ATLASSERT( pAccessor != NULL );

		if( ppColumnInfo == NULL || ppStringsBuffer == NULL || pnColumns == NULL || pAccessor == NULL )
			return E_FAIL;

		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pAccessor->QueryInterface(&spColumnsInfo);
		if (FAILED(hr))
			return hr;

		hr = spColumnsInfo->GetColumnInfo(pnColumns, ppColumnInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}

	bool GetOridinalParameterNo(LPCOLESTR pOleParameterName, DB_UPARAMS& nParameter, DBPARAMINFO* pParameterInfo, DB_UPARAMS nParameters ) throw()
	{
		ATLASSERT(pOleParameterName != NULL);
		ATLASSERT(pParameterInfo != NULL);

		if( pOleParameterName == NULL || pParameterInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nParameters; i++)
		{
			if (pParameterInfo[i].pwszName != NULL && wcscmp(pParameterInfo[i].pwszName, pOleParameterName) == 0)
			{
				nParameter = pParameterInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}

	HRESULT GetParameterNames( ICommand* pCmd, DBPARAMINFO** ppParameterInfo, OLECHAR** ppStringsBuffer, DB_UPARAMS* pnParameters ) throw()
	{
		ATLASSERT( ppParameterInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnParameters != NULL );
		ATLASSERT( pCmd != NULL );

		if( ppParameterInfo == NULL || ppStringsBuffer == NULL || pnParameters == NULL || pCmd == NULL )
			return E_FAIL;

		CComPtr<ICommandWithParameters> spCommandWithParameters;
		HRESULT hr = pCmd->QueryInterface(&spCommandWithParameters);
		if (FAILED(hr))
			return hr;

		hr = spCommandWithParameters->GetParameterInfo(pnParameters, ppParameterInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}
	
};


enum DBBLOBHANDLINGENUM
{
	DBBLOBHANDLING_DEFAULT,
	DBBLOBHANDLING_NOSTREAMS,
	DBBLOBHANDLING_SKIP
};

///////////////////////////////////////////////////////////////////////////
// CDynamicAccessor

class CDynamicAccessor :
	public CAccessorBase
{
public:
	CDynamicAccessor( DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT, DBLENGTH nBlobSize = 8000 )
	{
		ATLASSERT( eBlobHandling == DBBLOBHANDLING_DEFAULT || 
				   eBlobHandling == DBBLOBHANDLING_NOSTREAMS || 
				   eBlobHandling == DBBLOBHANDLING_SKIP );

		m_nColumns        = 0;
		m_pColumnInfo     = NULL;
		m_pStringsBuffer  = NULL;
		m_eBlobHandling   = eBlobHandling;
		m_nBlobSize       = nBlobSize;
		m_pfClientOwnedMemRef = NULL;
	};

	~CDynamicAccessor()
	{
		Close();
	}

	bool SetBlobHandling( DBBLOBHANDLINGENUM eBlobHandling )
	{
		switch( eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
		case DBBLOBHANDLING_NOSTREAMS:
		case DBBLOBHANDLING_SKIP:
			m_eBlobHandling = eBlobHandling;
			return true;
		default:
			ATLASSERT( FALSE ); // invalid blob handling mode!!!
			return false;
		}
	}

	const DBBLOBHANDLINGENUM GetBlobHandling() const
	{
		return m_eBlobHandling;
	}

	void SetBlobSizeLimit( DBLENGTH nBlobSize )
	{
		m_nBlobSize = nBlobSize;
	}

	const DBLENGTH GetBlobSizeLimit() const
	{
		return m_nBlobSize;
	}

//	void FreeRecordMemory(int , IRowset* ) throw() {}

	void Close() throw()
	{
		CoTaskMemFree(m_pColumnInfo);
		m_pColumnInfo = NULL;

		// Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
		// if necessary
		CoTaskMemFree(m_pStringsBuffer);
		m_pStringsBuffer = NULL;

		delete [] m_pBuffer;
		m_pBuffer = NULL;

		delete [] m_pfClientOwnedMemRef;
		m_pfClientOwnedMemRef = NULL;

		m_nColumns = 0;

		CAccessorBase::Close();
	}

	bool GetColumnType(DBORDINAL nColumn, DBTYPE* pType) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			*pType = m_pColumnInfo[nColumn].wType;
			return true;
		}
		else
			return false;
	}

	bool GetColumnFlags(DBORDINAL nColumn, DBCOLUMNFLAGS* pFlags) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			*pFlags = m_pColumnInfo[nColumn].dwFlags;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(const CHAR* pColumnName, DBORDINAL* pOrdinal) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(const WCHAR* pColumnName, DBORDINAL* pOrdinal) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}

	void* GetValue(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;
	}

	void* GetValue(const CHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	void* GetValue(const WCHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	template <class ctype>
	void _GetValue(DBORDINAL nColumn, ctype* pData) const throw()
	{
		ATLASSERT(pData != NULL);
		ATLASSERT(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pData = *pBuffer;
	}
	template <class ctype>
	void _SetValue(DBORDINAL nColumn, const ctype& data) throw()
	{
		ATLASSERT(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pBuffer = (ctype)data;
	}
	template <class ctype>
	bool GetValue(DBORDINAL nColumn, ctype* pData) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(DBORDINAL nColumn, const ctype& data) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(const CHAR *pColumnName, ctype* pData) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(const WCHAR *pColumnName, ctype* pData) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(const CHAR *pColumnName, const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(const WCHAR *pColumnName, const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	bool GetLength(DBORDINAL nColumn, DBLENGTH* pLength) const throw()
	{
		ATLASSERT(pLength != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(DBORDINAL nColumn, DBLENGTH nLength) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetLength(const CHAR* pColumnName, DBLENGTH* pLength) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetLength(const WCHAR* pColumnName, DBLENGTH* pLength) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(const CHAR* pColumnName, DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool SetLength(const WCHAR* pColumnName, DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(DBORDINAL nColumn, DBSTATUS* pStatus) const throw()
	{
		ATLASSERT(pStatus != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(DBORDINAL nColumn, DBSTATUS status) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(const CHAR* pColumnName, DBSTATUS* pStatus) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetStatus(const WCHAR* pColumnName, DBSTATUS* pStatus) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(const CHAR* pColumnName, DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool SetStatus(const WCHAR* pColumnName, DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}

	// Returns true if a bookmark is available
	HRESULT GetBookmark(CBookmark<>* pBookmark) const throw()
	{
		HRESULT hr;
		if (m_pColumnInfo->iOrdinal == 0)
			hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
		else
			hr = E_FAIL;
		return hr;
	}

	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	LPOLESTR GetColumnName(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return m_pColumnInfo[nColumn].pwszName;
		else
			return NULL;
	}

	ATL_DEPRECATED HRESULT GetColumnInfo(IRowset* pRowset, DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo);

	HRESULT GetColumnInfo(IRowset* pRowset, DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo, OLECHAR** ppStringsBuffer) throw()
	{
		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pRowset->QueryInterface(&spColumnsInfo);
		if (SUCCEEDED(hr))
			hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);

		return hr;
	}

	HRESULT AddBindEntry(const DBCOLUMNINFO& info) throw()
	{
		DBCOLUMNINFO* pTempInfo = (DBCOLUMNINFO*)CoTaskMemRealloc(m_pColumnInfo, (m_nColumns + 1) * sizeof(DBCOLUMNINFO));
		if (pTempInfo == NULL)
			return E_OUTOFMEMORY;
		m_pColumnInfo = pTempInfo;
		m_pColumnInfo[m_nColumns] = info;
		m_nColumns++;

		return S_OK;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return true;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(IRowset* pRowset) throw()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
		{
			if( m_pfClientOwnedMemRef != NULL && m_pfClientOwnedMemRef[i] == true )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) != DBSTATUS_S_ISNULL )
				{
					void* pRef = _GetDataPtr(i);

					if( pRef != NULL && *(void**)pRef != NULL )
						CoTaskMemFree( *(void**)_GetDataPtr(i) );
				}
			}
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN || m_pColumnInfo[i].wType == DBTYPE_IDISPATCH )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) == DBSTATUS_S_OK )
					CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
			else
			{
				CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
		}
	}
	void ClearRecordMemory() throw()
	{
		for (ULONG i = 0; i < m_nColumns; i++)
		{
			DBLENGTH uLength = m_pColumnInfo[i].ulColumnSize;
			switch (m_pColumnInfo[i].wType)
			{
			case DBTYPE_STR :
				uLength += 1;
				break;
			case DBTYPE_WSTR :
				uLength = (uLength + 1) * 2;
				break;
			}
			memset((BYTE*)_GetDataPtr(i), 0, uLength);
		}
	}

	void* _GetDataPtr(DBORDINAL nColumn) const throw()
	{
		return m_pBuffer + (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
	}
	bool GetInternalColumnNo(const CHAR* pColumnName, DBORDINAL* pColumn) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pColumn != NULL);
		USES_CONVERSION;
		ULONG       i;
		size_t      nSize = (lstrlenA(pColumnName) + 1) * sizeof(OLECHAR);
		OLECHAR*    pOleColumnName = A2OLE(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSERT(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, pOleColumnName, nSize) == 0)
				break;
		}
		if (i < m_nColumns)
		{
			*pColumn = i;
			return true;
		}
		else
			return false;   // Not Found
	}
	bool GetInternalColumnNo(const WCHAR* pColumnName, DBORDINAL* pColumn) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		ATLASSERT(pColumn != NULL);
		USES_CONVERSION;
		ULONG       i;
		size_t      nSize = (wcslen(pColumnName) + 1) * sizeof(OLECHAR);
		LPCOLESTR	pOleColumnName = W2COLE(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSERT(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, pOleColumnName, nSize) == 0)
				break;
		}
		if (i < m_nColumns)
		{
			*pColumn = i;
			return true;
		}
		else
			return false;   // Not Found
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void BindEx(DBBINDING* pBinding, DBORDINAL nOrdinal, DBTYPE wType,
		DBLENGTH nLength, BYTE nPrecision, BYTE nScale, DBPARAMIO eParamIO,
		DBBYTEOFFSET nDataOffset, DBBYTEOFFSET nLengthOffset, DBBYTEOFFSET nStatusOffset,
		DBOBJECT* pdbobject, DBMEMOWNER dwMemOwner, bool fSkipData = false ) throw()
	{
		ATLASSERT(pBinding != NULL);

		/*
		// If we are getting a pointer to the data then let the provider
		// own the memory
		if (wType & DBTYPE_BYREF)
			pBinding->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
		else
			pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		*/
		pBinding->dwMemOwner    = dwMemOwner;

		pBinding->pObject       = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = 0;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = 0;

		if ( ! fSkipData ) // skip column data
		{
			pBinding->dwPart |= DBPART_VALUE;
			pBinding->obValue = nDataOffset;
		}
		if (nLengthOffset != NULL) // skip length
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != NULL) // skip status
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}


	HRESULT GetRowsetProperties( IUnknown* pUnk, DBPROPID* prgPropertyIDs, BOOL* pbValues, ULONG nPropCount ) throw()
	{
		ULONG t;

		ATLASSERT(pUnk != NULL);
		ATLASSERT(pbValues != NULL);
		ATLASSERT(prgPropertyIDs != NULL);
		ATLASSERT(nPropCount > 0);

		CComPtr<IRowsetInfo> spRowsetInfo;
		HRESULT hr = pUnk->QueryInterface(&spRowsetInfo);

		for( t = 0; t < nPropCount; t++ )
			pbValues[t] = FALSE;

		if (FAILED(hr))
			ATLASSERT(0); // unable to retrieve IRowsetInfo interface
		else
		{
			DBPROPIDSET            rgPropertyIDSets[1];
			ULONG                  cPropSets        = 0;
			CComHeapPtr<DBPROPSET> rgPropSets;

			// Set up the Property ID Set.
			rgPropertyIDSets[0].rgPropertyIDs       = prgPropertyIDs;
			rgPropertyIDSets[0].cPropertyIDs        = nPropCount;
			rgPropertyIDSets[0].guidPropertySet     = DBPROPSET_ROWSET;

			hr = spRowsetInfo->GetProperties(	1,					// cPropertyIDSets
												rgPropertyIDSets,	// rgPropertyIDSets
												&cPropSets,         // pcPropSets
												&rgPropSets );      // prgPropSets

			if( SUCCEEDED(hr) )
			{
				for( t = 0; t < __min(rgPropSets[0].cProperties, nPropCount); t++ )
					pbValues[t] = V_BOOL(&rgPropSets[0].rgProperties[t].vValue);

				if( rgPropSets[0].rgProperties )
					CoTaskMemFree(rgPropSets[0].rgProperties);
			}
		}

		return hr;
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		IID iidStreamToUse = __uuidof(ISequentialStream);
		//IID iidPersistToUse;
		bool fIStreamSupportTested = false;
		//bool fIPersistSupportTested = false;

		ATLASSERT(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY( pBinding = new DBBINDING[m_nColumns] );
		if( pBinding == NULL )
			return E_OUTOFMEMORY;

		ATLASSERT(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			delete [] pBinding;
			return E_OUTOFMEMORY;
		}

#ifdef _DEBUG
		ATLTRACE( "CDynamicAccessor::BindColumns\n" );
		ATLTRACE( "Number of columns: %d\n", m_nColumns );
		ATLTRACE( "Blob Handling Mode: " );
		switch( m_eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
			ATLTRACE( "DBBLOBHANDLING_DEFAULT\n" );
			break;
		case DBBLOBHANDLING_NOSTREAMS:
			ATLTRACE( "DBBLOBHANDLING_NOSTREAMS\n" );
			break;
		case DBBLOBHANDLING_SKIP:
			ATLTRACE( "DBBLOBHANDLING_SKIP\n" );
			break;
		default:
			ATLTRACE( "IVALID HANDLING MODE!!!\n" );
		}
#endif
		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;
		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			m_pfClientOwnedMemRef[i] = false;
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize && m_pColumnInfo[i].wType != DBTYPE_IUNKNOWN )
			{
				if( m_eBlobHandling == DBBLOBHANDLING_SKIP )
				{
					// Calculate the column data offset
					nDataOffset = 0;
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
					ATLTRACE( "%d. Column ordinal %d: Binding length and status ONLY\n", i, m_pColumnInfo[i].iOrdinal );
#endif
					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED, true );
					pCurrent++;
				}
				else if( m_eBlobHandling == DBBLOBHANDLING_NOSTREAMS )
				{
					// get the value by reference
					m_pColumnInfo[i].wType |= DBTYPE_BYREF;
					m_pColumnInfo[i].ulColumnSize   = sizeof(WCHAR*);
					m_pfClientOwnedMemRef[i] = true;

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
					ATLTRACE( "%d. Column ordinal %d: Binding by reference in provider allocated, consumer owned memory\n", i, m_pColumnInfo[i].iOrdinal );
#endif
					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
					pCurrent++;

				}
				else // if( m_eBlobHandling == DBBLOBHANDLING_DEFAULT )
				{
					// we will try to bind blobs as streams
					// if we have not tested if the rowset supports streams, do it now
					if( ! fIStreamSupportTested )
					{
#ifdef _DEBUG
						ATLTRACE( "Testing streams support... " );
#endif
						DBPROPID rgPropertyIDs[2] = { DBPROP_ISequentialStream, DBPROP_IStream };
						BOOL     rgStreamsSupported[2] = {FALSE, FALSE};

						// check if the rowset supports IStream* interfaces
						hr = GetRowsetProperties( pUnk, rgPropertyIDs, rgStreamsSupported, 2 );
						ATLASSERT( SUCCEEDED( hr ) );

						if( rgStreamsSupported[0] )
						{
							iidStreamToUse = __uuidof(ISequentialStream);
#ifdef _DEBUG
							ATLTRACE( "ISequentialStream is supported\n" );
#endif
						}
						else if( rgStreamsSupported[1] )
						{
							iidStreamToUse = __uuidof(IStream);
#ifdef _DEBUG
						ATLTRACE( "IStream is supported\n" );
#endif
						}
						else
						{
#ifdef _DEBUG
						ATLTRACE( "neither ISequentialStream nor IStream are supported!\n" );
#endif
							ATLASSERT(FALSE); // the stream interfaces are not supported!!!
						}

						fIStreamSupportTested = true;
					}

					pObject = NULL;
					ATLTRY(pObject = new DBOBJECT);
					if (pObject == NULL)
					{
						for( ULONG t = 0; t < i; t++ )
							delete pBinding[t].pObject;
						delete [] pBinding;

						delete [] m_pfClientOwnedMemRef;
						m_pfClientOwnedMemRef = NULL;

						return E_OUTOFMEMORY;
					}
					pObject->dwFlags = STGM_READ;
					pObject->iid     = iidStreamToUse;
					m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
					m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
					if( iidStreamToUse == __uuidof(ISequentialStream) )
						ATLTRACE( "%d. Column ordinal %d: Binding as an ISequentialStream object\n", i, m_pColumnInfo[i].iOrdinal );
					else
						ATLTRACE( "%d. Column ordinal %d: Binding as an IStream object\n", i, m_pColumnInfo[i].iOrdinal );
#endif
					Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
					pCurrent++;

				}
			}
			// else if it's a COM object
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( ULONG t = 0; t < i; t++ )
						delete pBinding[t].pObject;
					delete [] pBinding;

					delete [] m_pfClientOwnedMemRef;
					m_pfClientOwnedMemRef = NULL;

					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(IUnknown); // iidPersistToUse;
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
				ATLTRACE( "%d. Column ordinal %d: Binding a COM object\n", i, m_pColumnInfo[i].iOrdinal );
#endif
				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;

			}
			// else if it's not a BLOB or COM object
			else
			{
				pObject = NULL;

				// Calculate the size needed if it's a string
				// including the NULL terminator.
				if (m_pColumnInfo[i].wType == DBTYPE_STR)
					m_pColumnInfo[i].ulColumnSize += 1;
				
				if (m_pColumnInfo[i].wType == DBTYPE_WSTR)
					m_pColumnInfo[i].ulColumnSize = m_pColumnInfo[i].ulColumnSize*2 + 2;

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
				ATLTRACE( "%d. Column ordinal %d: Binding as native data type\n", i, m_pColumnInfo[i].iOrdinal );
#endif
				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;
			}

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( ULONG t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;
				delete [] pBinding;

				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;

				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( ULONG t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;
			delete [] pBinding;

			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;

			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		if( FAILED(hr))
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		delete [] pBinding;

		return hr;
	}

	// Translate the column number to the index into the column info array
	bool TranslateColumnNo(DBORDINAL& nColumn) const throw()
	{
		ATLASSERT(m_pColumnInfo != NULL);
		// If the user has overriden the binding then we need to search
		// through the column info for the ordinal number
		if (m_bOverride)
		{
			for (ULONG i = 0; i < m_nColumns; i++)
			{
				if (m_pColumnInfo[i].iOrdinal == nColumn)
				{
					nColumn = i;
					return true;
				}
			}
			return false;
		}
		else
		{
			// Note that m_pColumnInfo->iOrdinal will be zero if have bound
			// a bookmark as the first entry, otherwise it will be 1.
			// If the column is out of range then return false
			if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
				return false;

			// otherwise translate the column to an index into our internal
			// binding entries array
			nColumn -= m_pColumnInfo->iOrdinal;
			return true;
		}
	}

	static size_t GetAlignment(DBTYPE bType) throw()
	{
		if( bType & DBTYPE_BYREF )
			return __alignof(void*);
		
		if( bType & DBTYPE_ARRAY )
			return __alignof(SAFEARRAY*);
		
		if( bType & DBTYPE_VECTOR )
			return __alignof(DBVECTOR);

		switch( bType )
		{
		case DBTYPE_I2:
			return __alignof(signed short);
			break;

		case DBTYPE_I4:
			return __alignof(signed int);
			break;

		case DBTYPE_R4:
			return __alignof(float);
			break;

		case DBTYPE_R8:
			return __alignof(double);
			break;

		case DBTYPE_CY:
			return __alignof(__int64);
			break;

		case DBTYPE_DATE:
			return __alignof(DATE);
			break;

		case DBTYPE_BSTR:
			return __alignof(BSTR*);
			break;

		case DBTYPE_IDISPATCH:
			return __alignof(IDispatch*);
			break;

		case DBTYPE_ERROR:
			return __alignof(SCODE);
			break;

		case DBTYPE_BOOL:
			return __alignof(VARIANT_BOOL);
			break;

		case DBTYPE_VARIANT:
			return __alignof(VARIANT);
			break;

		case DBTYPE_IUNKNOWN:
			return __alignof(IUnknown*);
			break;

		case DBTYPE_DECIMAL:
			return __alignof(DECIMAL);
			break;

		case DBTYPE_UI1:
			return __alignof(unsigned char);
			break;

		case DBTYPE_I1:
			return __alignof(signed char);
			break;

		case DBTYPE_UI2:
			return __alignof(unsigned short);
			break;

		case DBTYPE_UI4:
			return __alignof(unsigned int);
			break;

		case DBTYPE_I8:
			return __alignof(signed char);
			break;

		case DBTYPE_UI8:
			return __alignof(unsigned char);
			break;

		case DBTYPE_GUID:
			return __alignof(GUID);
			break;

		case DBTYPE_BYTES:
			return __alignof(BYTE);
			break;

		case DBTYPE_STR:
			return __alignof(char);
			break;

		case DBTYPE_WSTR:
			return __alignof(short);
			break;

		case DBTYPE_NUMERIC:
			return __alignof(DB_NUMERIC);
			break;

		case DBTYPE_DBDATE:
			return __alignof(DBDATE);
			break;

		case DBTYPE_DBTIME:
			return __alignof(DBTIME);
			break;

		case DBTYPE_DBTIMESTAMP:
			return __alignof(DBTIMESTAMP);
			break;

		default:
			return __alignof(__int64);
		}
	}

	inline static DBBYTEOFFSET AlignAndIncrementOffset( DBBYTEOFFSET& nOffset, DBLENGTH nSize, size_t nAlign ) throw()
	{
		DBBYTEOFFSET nResult;

		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
		nResult = nOffset;
		nOffset += nSize;

		return nResult;
	}

	inline static void IncrementAndAlignOffset( DBBYTEOFFSET& nOffset, DBLENGTH nSize, size_t nAlign ) throw()
	{
		nOffset += nSize;
		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
	}

	typedef CDynamicAccessor _OutputColumnsClass;
	static bool HasOutputColumns() throw() { return true; }

	DBORDINAL           m_nColumns;
	bool*				m_pfClientOwnedMemRef;
	DBCOLUMNINFO*       m_pColumnInfo;
	OLECHAR*            m_pStringsBuffer;
	bool                m_bOverride;

	protected:
	DBBLOBHANDLINGENUM  m_eBlobHandling;
	DBLENGTH            m_nBlobSize;
};


template< typename BaseType > 
inline BaseType* strcpyT( BaseType *strDest, const BaseType *strSource )
{
	return NULL;
}

template< typename BaseType > 
inline BaseType* strncpyT( BaseType *strDest, const BaseType *strSource, size_t count )
{
	return NULL;
}

template< typename BaseType > 
inline size_t strlenT( const BaseType *string )
{
	return NULL;
}

template<> 
inline CHAR* strcpyT<CHAR>( CHAR *strDest, const CHAR *strSource )
{
	return strcpy( strDest, strSource );
}
template<> 
inline CHAR* strncpyT<CHAR>( CHAR *strDest, const CHAR *strSource, size_t count )
{
	return strncpy( strDest, strSource, count );
}
template<> 
inline size_t strlenT<CHAR>( const CHAR *string )
{
	return strlen( string );
}

template<> 
inline WCHAR* strcpyT<WCHAR>( WCHAR *strDest, const WCHAR *strSource )
{
	return wcscpy( strDest, strSource );
}
template<> 
inline WCHAR* strncpyT<WCHAR>( WCHAR *strDest, const WCHAR *strSource, size_t count )
{
	return wcsncpy( strDest, strSource, count );
}
template<> 
inline size_t strlenT<WCHAR>( const WCHAR *string )
{
	return wcslen( string );
}

template< typename BaseType, DBTYPEENUM OleDbType >
class CDynamicStringAccessorT : public CDynamicAccessor
{
public:
	explicit CDynamicStringAccessorT(DBLENGTH nBlobSize = 8000)
		: CDynamicAccessor( DBBLOBHANDLING_DEFAULT, nBlobSize )
	{
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLASSERT(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
		DBLENGTH nLength;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		ATLASSERT(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			delete [] pBinding;
			pBinding = NULL;
			return E_OUTOFMEMORY;
		}

		DBBINDING* pCurrent = pBinding;

		for (i = 0; i < m_nColumns; i++)
		{
			m_pfClientOwnedMemRef[i] = false;

			// If it's a IPersist* object or the column size is large enough for us to treat it as
			// a BLOB then we will request references (in client owned memory) to a string
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				m_pColumnInfo[i].wType      = OleDbType | DBTYPE_BYREF;
				m_pColumnInfo[i].ulColumnSize   = sizeof(BaseType*);
				m_pfClientOwnedMemRef[i] = true;
			}
			else // We're treating everything as a string so add 1 for the NULL byte.
			{
				switch (m_pColumnInfo[i].wType)
				{
				case DBTYPE_BOOL:
					nLength = 2;
					break;
				case DBTYPE_BYTES:
					nLength = m_pColumnInfo[i].ulColumnSize * 2;
					break;
				case DBTYPE_BSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_STR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_WSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_I1:
					nLength = 5;
					break;
				case DBTYPE_I2:
					nLength = 7;
					break;
				case DBTYPE_I4:
					nLength = 12;
					break;
				case DBTYPE_I8:
					nLength = 22;
					break;
				case DBTYPE_UI1:
					nLength = 4;
					break;
				case DBTYPE_UI2:
					nLength = 6;
					break;
				case DBTYPE_UI4:
					nLength = 11;
					break;
				case DBTYPE_UI8:
					nLength = 21;
					break;
				case DBTYPE_R4:
					nLength = 13;
					break;
				case DBTYPE_R8:
					nLength = 23;		// maybe 9
					break;
				case DBTYPE_DECIMAL:
					nLength = 23;
					break;
				case DBTYPE_NUMERIC:
					nLength = 23;
					break;
				case DBTYPE_VARIANT:
					nLength = 20;
					break;
				case DBTYPE_IDISPATCH:
					nLength = 32;
					break;
				case DBTYPE_IUNKNOWN:
					nLength = 32;
					break;
				case DBTYPE_GUID:
					nLength = 32;
					break;
				case DBTYPE_ARRAY:
					nLength = 32;
					break;
				case DBTYPE_VECTOR:
					nLength = 32;
					break;
				case DBTYPE_DBDATE:
					nLength = 32;
					break;
				case DBTYPE_DBTIME:
					nLength = 32;
					break;
				case DBTYPE_DBTIMESTAMP:
					nLength = 20;		// was 32
					break;
				case DBTYPE_FILETIME:
					nLength = 32;
					break;
				case DBTYPE_PROPVARIANT:
					nLength = 32;
					break;
				case DBTYPE_VARNUMERIC:
					nLength = 32;
					break;
				case DBTYPE_CY:
					nLength = 32;
					break;
				default:
					ATLASSERT(FALSE); // unhandled column type
					nLength = 32;
				}
				m_pColumnInfo[i].ulColumnSize = (nLength + 1) * sizeof(BaseType);
				m_pColumnInfo[i].wType = OleDbType;
			}

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( OleDbType ) );

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

			BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
				m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);

			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				delete [] pBinding;
				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			delete [] pBinding;
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
			return E_OUTOFMEMORY;
		}

		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		delete [] pBinding;

		if( FAILED(hr) )
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		return hr;
	}

	BaseType* GetString(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;
	}

	BaseType* GetString(const CHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	BaseType* GetString(const WCHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	void _SetLength(DBORDINAL nColumn, DBLENGTH nLength ) throw()
	{
		DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
		IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
		*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
	}

	HRESULT _SetString(DBORDINAL nColumn, BaseType* data) throw()
	{
		DBLENGTH stringLen = (DBLENGTH)strlenT<BaseType>( data );

		if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
		{
			BaseType** pBuffer = (BaseType**)_GetDataPtr(nColumn);
			BaseType* pNewBuffer = (BaseType*)CoTaskMemRealloc( *pBuffer, (stringLen + 1) * sizeof(BaseType) );
			if( pNewBuffer == NULL )
				return E_OUTOFMEMORY;

			*pBuffer = pNewBuffer;
			strcpyT<BaseType>( pNewBuffer, data );
			_SetLength( nColumn, stringLen );
		}
		else
		{
			BaseType* pBuffer = (BaseType*)_GetDataPtr(nColumn);
			if( stringLen >= m_pColumnInfo[nColumn].ulColumnSize )
			{
				strncpyT<BaseType>( pBuffer, data, m_pColumnInfo[nColumn].ulColumnSize - 1 );
				pBuffer[m_pColumnInfo[nColumn].ulColumnSize - 1] = 0;
				_SetLength( nColumn, m_pColumnInfo[nColumn].ulColumnSize - 1 );
				return DBSTATUS_S_TRUNCATED;
			}
			else
			{
				strcpyT<BaseType>( pBuffer, data );
				_SetLength( nColumn, stringLen );
			}
		}
		return S_OK;
	}

	HRESULT SetString(DBORDINAL nColumn, BaseType* data) throw()
	{
		if (TranslateColumnNo(nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(const CHAR* pColumnName, BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(const WCHAR* pColumnName, BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
};


typedef CDynamicStringAccessorT<CHAR, DBTYPE_STR> CDynamicStringAccessorA;
typedef CDynamicStringAccessorT<WCHAR, DBTYPE_WSTR> CDynamicStringAccessorW;

#ifdef _UNICODE
typedef CDynamicStringAccessorW CDynamicStringAccessor;
#else
typedef CDynamicStringAccessorA CDynamicStringAccessor;
#endif

class CXMLAccessor : public CDynamicStringAccessorW
{
public:

	HRESULT GetXMLColumnData(CSimpleStringW& strOutput) throw()
	{
		_ATLTRY
		{
			strOutput = L"<columninfo>\n";
			DBTYPE wType;
			for (ULONG i=1; i<=m_nColumns; i++)
			{
				strOutput += L"<column type=\"";
				if( !GetColumnType(i, &wType) )
					return E_FAIL;

				wType &= ~DBTYPE_BYREF;
				wType &= ~DBTYPE_ARRAY;
				wType &= ~DBTYPE_VECTOR;

				switch (wType)
				{
				case DBTYPE_BOOL:
					strOutput += L"BOOL";
					break;
				case DBTYPE_STR:
				case DBTYPE_WSTR:
					strOutput += L"STRING";
					break;
				case DBTYPE_I1:
					strOutput += L"I1";
					break;
				case DBTYPE_I2:
					strOutput += L"I2";
					break;
				case DBTYPE_I4:
					strOutput += L"I4";
					break;
				case DBTYPE_I8:
					strOutput += L"I8";
					break;
				case DBTYPE_UI1:
					strOutput += L"UI1";
					break;
				case DBTYPE_UI2:
					strOutput += L"UI2";
					break;
				case DBTYPE_UI4:
					strOutput += L"UI4";
					break;
				case DBTYPE_UI8:
					strOutput += L"UI8";
					break;
				case DBTYPE_R4:
					strOutput += L"R4";
					break;
				case DBTYPE_R8:
					strOutput += L"R8";
					break;
				case DBTYPE_DECIMAL:
					strOutput += L"DECIMAL";
					break;
				case DBTYPE_NUMERIC:
					strOutput += L"NUMERIC";
					break;
				case DBTYPE_VARIANT:
					strOutput += L"VARIANT";
					break;
				case DBTYPE_IDISPATCH:
					strOutput += L"DISPATCH";
					break;
				case DBTYPE_IUNKNOWN:
					strOutput += L"IUNKNOWN";
					break;
				case DBTYPE_GUID:
					strOutput += L"GUID";
					break;
				case DBTYPE_DBDATE:
					strOutput += L"DBDATE";
					break;
				case DBTYPE_DBTIME:
					strOutput += L"DBTIME";
					break;
				case DBTYPE_DBTIMESTAMP:
					strOutput += L"DBTIMESTAMP";
					break;
				case DBTYPE_FILETIME:
					strOutput += L"FILETIME";
					break;
				case DBTYPE_PROPVARIANT:
					strOutput += L"PROPVARIANT";
					break;
				case DBTYPE_VARNUMERIC:
					strOutput += L"VARNUMERIC";
					break;
				}
				strOutput += L"\">";
				strOutput += GetColumnName(i);
				strOutput += L"</column>\n";
			}
			strOutput += L"</columninfo>\n";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}

	HRESULT GetXMLRowData(CSimpleStringW& strOutput, bool bAppend = false) throw()
	{
		_ATLTRY
		{
			USES_CONVERSION;
			LPOLESTR pszName;
			if (!bAppend)
				strOutput.Empty();
			strOutput += L"<row>";
			for (ULONG i=1; i<=m_nColumns; i++)
			{
				pszName = GetColumnName(i);
				strOutput += L"<";
				strOutput += pszName;
				strOutput += L">";
				DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
				if( !GetStatus(i, &dbStatus) )
					return E_FAIL;

				if (dbStatus!=DBSTATUS_S_ISNULL)
					strOutput += GetString(i);
				
				strOutput += L"</";
				strOutput += pszName;
				strOutput += L">";
			}
			strOutput += L"</row>";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}
};

// Like CDynamicAccessor but everything is bound as a DBTYPE_VARIANT
class CDynamicVariantAccessor : public CDynamicAccessor
{
public:
	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLASSERT(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;
		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( UINT t = 0; t < i; t++ )
						delete pBinding[t].pObject;
					delete [] pBinding;
					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(ISequentialStream);
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
			}
			else
				pObject = NULL;

			m_pColumnInfo[i].ulColumnSize = sizeof(VARIANT);

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset(nOffset, sizeof(VARIANT), __alignof(VARIANT));

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset(nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH));

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset(nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS));

			Bind(pCurrent, m_pColumnInfo[i].iOrdinal, DBTYPE_VARIANT,
				sizeof(VARIANT), m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( UINT t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;
				delete [] pBinding;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( UINT t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;
			delete [] pBinding;
			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);
		delete [] pBinding;

		return hr;
	}
};

///////////////////////////////////////////////////////////////////////////
// class CDynamicParameterAccessor

class CDynamicParameterAccessor : public CDynamicAccessor
{
// Constructors and Destructors
public:
	typedef CDynamicParameterAccessor _ParamClass;
	CDynamicParameterAccessor( DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT, DBLENGTH nBlobSize = 8000 )
		: CDynamicAccessor( eBlobHandling, nBlobSize )
	{
		m_pParameterEntry       = NULL;
		m_pParameterBuffer      = NULL;
		m_ppParamName           = NULL;
		m_nParameterBufferSize  = 0;
		m_nParams               = 0;
	};

	~CDynamicParameterAccessor()
	{
		delete [] m_pParameterEntry;
		if (m_ppParamName != NULL)
		{
			CoTaskMemFree(*m_ppParamName);
			delete [] m_ppParamName;
		}
		delete m_pParameterBuffer;
	};

	bool GetParamSize(DBORDINAL nParam, DBLENGTH *pLength) const throw()
	{
		ATLASSERT( pLength != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pLength = m_pParameterEntry[nParam].cbMaxLen;
		return true;
	}

	bool GetParamIO(DBORDINAL nParam, DBPARAMIO *pParamIO) const throw()
	{
		ATLASSERT( pParamIO != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pParamIO = m_pParameterEntry[nParam].eParamIO;
		return true;
	}

	bool GetParamType(DBORDINAL nParam, DBTYPE *pType) const throw()
	{
		ATLASSERT( pType != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pType = m_pParameterEntry[nParam].wType;
		return true;
	}
	bool GetParamLength(DBORDINAL nParam, DBLENGTH *pLength)
	{
		ATLASSERT( pLength != NULL );

		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pLength = *pBuffer;
		return true;
	}
	bool SetParamLength(DBORDINAL nParam, DBLENGTH length)
	{
		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = length;
		return true;
	}
	bool GetParamStatus(DBORDINAL nParam, DBSTATUS *pStatus)
	{
		ATLASSERT( pStatus != NULL );

		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pStatus = *pBuffer;
		return true;
	}
	bool SetParamStatus(DBORDINAL nParam, DBSTATUS status)
	{
		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = status;
		return true;
	}
	template <class ctype>
	bool GetParam(DBORDINAL nParam, ctype* pData) const throw()
	{
		ATLASSERT( pData != NULL );
		ctype* pBuffer = (ctype*)GetParam(nParam);
		if (pBuffer == NULL)
			return false;
		*pData = *pBuffer;
		return true;
	}

	bool GetParamString(DBORDINAL nParam, CSimpleStringA& strOutput ) throw()
	{
		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(DBORDINAL nParam, CSimpleStringW& strOutput ) throw()
	{
		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(DBORDINAL nParam, CHAR* pBuffer, size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = strlen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( *pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		strcpy( pBuffer, pData );
		return true;
	}

	bool GetParamString(DBORDINAL nParam, WCHAR* pBuffer, size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = wcslen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( * pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		wcscpy( pBuffer, pData );
		return true;
	}

	template <class ctype>
	bool SetParam(DBORDINAL nParam, const ctype* pData, DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pData != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		//DBLENGTH *pLength = _GetParamLength( nParam );
		//if( pLength != NULL )
		//	*pLength = (DBLENGTH)sizeof(ctype);

		return true;
	}

	bool SetParamString(DBORDINAL nParam, const CHAR* pString, DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		CHAR* pBuffer = (CHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen;
		if( strlen( pString ) >= nMaxLen )
			return false;

		strcpy( pBuffer, pString );

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)(strlen(pBuffer));

		return true;
	}

	bool SetParamString(DBORDINAL nParam, const WCHAR* pString, DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		WCHAR* pBuffer = (WCHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen / 2;
		if( wcslen( pString ) >= nMaxLen )
			return false;

		wcscpy( pBuffer, pString );

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)( sizeof(WCHAR) * wcslen(pBuffer));

		return true;
	}

	template <class ctype>
	bool GetParam(TCHAR* pParamName, ctype* pData) const throw()
	{
		ATLASSERT( pData != NULL );

		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pData = *pBuffer;
		return true;
	}

	template <class ctype>
	bool SetParam(TCHAR* pParamName, const ctype* pData, DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pData != NULL );

		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		//DBLENGTH *pLength = _GetParamLength( nParam );
		//if( pLength != NULL )
		//	*pLength = sizeof(ctype);

		return true;
	}

	void* GetParam(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;
		
		return _GetParam( nParam );
	}

	DBLENGTH* GetParamLength(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;
		
		return _GetParamLength( nParam );
	}

	DBSTATUS* GetParamStatus(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParamStatus( nParam );
	}

	void* GetParam(TCHAR* pParamName) const throw()
	{
		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		return _GetParam( nParam );
	}

	// Get the number of parameters
	DB_UPARAMS GetParamCount() const throw()
	{
		return m_nParams;
	}

	// Get the parameter name for the passed parameter number
	LPOLESTR GetParamName(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return m_ppParamName[nParam];
	}

	bool TranslateParameterNo( DBORDINAL& nParam ) const throw()
	{
		for( DBORDINAL i = 0; i < m_nParams; i++ )
		{
			if( m_pParameterEntry[i].iOrdinal == nParam )
			{
				nParam = i;
				return true;
			}
		}

		return false;
	}

	bool _GetParameterNo( TCHAR* pParamName, DBORDINAL& nParam ) const throw()
	{
		USES_CONVERSION;

		if( pParamName == NULL )
			return false;

		DBORDINAL i;
		size_t    nSize = (lstrlen(pParamName) + 1) * sizeof(OLECHAR);
		OLECHAR*  pOleParamName = T2OLE(pParamName);

		for (i=0; i<m_nParams; i++)
		{
			if (memcmp(m_ppParamName[i], pOleParamName, nSize) == 0)
			{
				nParam = i;
				return true;
			}
		}

		return false;    // Not Found
	}

	void* _GetParam(DBORDINAL nParam) const throw()
	{
		return m_pParameterBuffer + m_pParameterEntry[nParam].obValue;
	}

	DBLENGTH* _GetParamLength(DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obLength == 0 )
			return NULL;
		else
			return (DBLENGTH*)(m_pParameterBuffer + m_pParameterEntry[nParam].obLength);
	}

	DBSTATUS* _GetParamStatus(DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obStatus == 0 )
			return NULL;
		else
			return (DBSTATUS*)(m_pParameterBuffer + m_pParameterEntry[nParam].obStatus);
	}

// Implementation
	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand,
				void** ppParameterBuffer, bool fBindLength = false, bool fBindStatus = false ) throw()
	{
		// If we have already bound the parameters then just return
		// the pointer to the parameter buffer
		if (*pHAccessor != NULL)
		{
			*ppParameterBuffer = m_pParameterBuffer;
			return S_OK;
		}

		CComPtr<IAccessor> spAccessor;
		ATLASSERT(pCommand != NULL);
		HRESULT hr = pCommand->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Try to bind parameters if available
		CComPtr<ICommandWithParameters> spCommandParameters;
		hr = pCommand->QueryInterface(&spCommandParameters);
		if (FAILED(hr))
			return hr;

		DB_UPARAMS ulParams     = 0;
		CComHeapPtr<DBPARAMINFO>    spParamInfo;
		LPOLESTR pNamesBuffer;

		// Get Parameter Information
		hr = spCommandParameters->GetParameterInfo(&ulParams, &spParamInfo,
				&pNamesBuffer);
		if (FAILED(hr))
			return hr;

		// Create the parameter information for binding
		hr = AllocateParameterInfo(ulParams);
		if (FAILED(hr))
		{
			CoTaskMemFree(pNamesBuffer);
			return hr;
		}

		DBBYTEOFFSET nOffset = 0;
		DBBYTEOFFSET nDataOffset = 0;
		DBBYTEOFFSET nLengthOffset = 0;
		DBBYTEOFFSET nStatusOffset = 0;

		DBBINDING* pCurrent = m_pParameterEntry;
		for (ULONG l=0; l<ulParams; l++)
		{
			m_pParameterEntry[l].eParamIO = 0;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISINPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_INPUT;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISOUTPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_OUTPUT;

			// if this is a BLOB, truncate column length to m_nBlobSize (like 8000 bytes)
			if( spParamInfo[l].ulParamSize > m_nBlobSize )
				spParamInfo[l].ulParamSize = m_nBlobSize;

			// if this is a string, recalculate column size in bytes
			DBLENGTH colLength = spParamInfo[l].ulParamSize;
			if (spParamInfo[l].wType == DBTYPE_STR)
				colLength += 1;
			if (spParamInfo[l].wType == DBTYPE_WSTR)
				colLength = colLength*2 + 2;

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, colLength, GetAlignment( spParamInfo[l].wType ) );

			if( fBindLength )
			{
				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
			}

			if( fBindStatus )
			{
				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
			}

			Bind(pCurrent, spParamInfo[l].iOrdinal, spParamInfo[l].wType,
				colLength, spParamInfo[l].bPrecision, spParamInfo[l].bScale,
				m_pParameterEntry[l].eParamIO, nDataOffset, nLengthOffset, nStatusOffset );

			pCurrent++;

			m_ppParamName[l] = pNamesBuffer;
			if (pNamesBuffer && *pNamesBuffer)
			{
				// Search for the NULL termination character
				while (*pNamesBuffer++)
					;
			}
		}

		// Allocate memory for the new buffer
		m_pParameterBuffer = NULL;
		ATLTRY(m_pParameterBuffer = new BYTE[nOffset]);
		if (m_pParameterBuffer == NULL)
		{
			// Note that pNamesBuffer will be freed in the destructor
			// by freeing *m_ppParamName
			return E_OUTOFMEMORY;
		}
		*ppParameterBuffer = m_pParameterBuffer;
		m_nParameterBufferSize = nOffset;
		m_nParams = ulParams;
		BindEntries(m_pParameterEntry, ulParams, pHAccessor, nOffset, spAccessor);

		return S_OK;
	}
	bool HasParameters() const throw()
	{
		return true;
	}
	HRESULT AllocateParameterInfo(DB_UPARAMS nParamEntries) throw()
	{
		// Allocate memory for the bind structures
		m_pParameterEntry = NULL;
		ATLTRY(m_pParameterEntry = new DBBINDING[nParamEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;

		// Allocate memory to store the field names
		m_ppParamName = NULL;
		ATLTRY(m_ppParamName = new OLECHAR*[nParamEntries]);
		if (m_ppParamName == NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

// Data Members
	// Number of parameters
	DB_UPARAMS          m_nParams;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// String names for the parameters
	OLECHAR**           m_ppParamName;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CManualAccessor

class CManualAccessor :
	public CAccessorBase
{
public:
	CManualAccessor()
	{
		// By default we don't have any parameters unless CreateParameterAccessor 
		// is called
		m_pEntry          = NULL;
		m_nParameters     = 0;
		m_pParameterEntry = NULL;
		m_nColumns        = 0;
		m_pParameterBuffer = NULL;
	}
	~CManualAccessor()
	{
		delete [] m_pEntry;
		delete [] m_pParameterEntry;
	}
	HRESULT CreateAccessor(int nBindEntries, void* pBuffer, DBLENGTH nBufferSize) throw()
	{
		m_pBuffer     = (BYTE*)pBuffer;
		m_nBufferSize = nBufferSize;
		m_nColumns    = nBindEntries;
		m_nEntry      = 0;
		memset(pBuffer, 0, nBufferSize);


		// If they've previously created some entries then free them
		delete [] m_pEntry;
		m_pEntry = NULL;

		// Allocate memory for the bind structures
		ATLTRY(m_pEntry = new DBBINDING[nBindEntries]);
		if (m_pEntry == NULL)
			return E_OUTOFMEMORY;
		else
			return S_OK;
	}
	HRESULT CreateParameterAccessor(int nBindEntries, void* pBuffer, DBLENGTH nBufferSize) throw()
	{
		// Should be called only once.  But, if you really insist on doing this...
		if (m_pParameterEntry != NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
		}

		m_pParameterBuffer     = (BYTE*)pBuffer;
		m_nParameterBufferSize = nBufferSize;
		m_nParameters          = nBindEntries;
		m_nCurrentParameter    = 0;

		// Allocate memory for the bind structures
		ATLTRY(m_pParameterEntry = new DBBINDING[nBindEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;
		else
			return S_OK;
	}
	void AddBindEntry(DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			void* pData, void* pLength = NULL, void* pStatus = NULL) throw()
	{
		ATLASSERT(m_nEntry < m_nColumns);
		DBBYTEOFFSET   nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pEntry+m_nEntry, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer, nLengthOffset, nStatusOffset);

		m_nEntry++;
	}
	void AddParameterEntry(DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			void* pData, void* pLength = NULL, void* pStatus = NULL,
			DBPARAMIO eParamIO = DBPARAMIO_INPUT) throw()
	{
		ATLASSERT(m_nCurrentParameter < m_nParameters);
		DBBYTEOFFSET nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pParameterBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pParameterBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pParameterEntry + m_nCurrentParameter, nOrdinal, wType, nColumnSize, 0, 0,
			eParamIO, (BYTE*)pData - m_pParameterBuffer, nLengthOffset, nStatusOffset);

		m_nCurrentParameter++;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(IRowset* pRowset) throw ()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
			CAccessorBase::FreeType(m_pEntry[i].wType, m_pBuffer + m_pEntry[i].obValue, pRowset);
	}

	void ClearRecordMemory() throw()
	{
		memset(m_pBuffer, 0, m_nBufferSize);
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLASSERT(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
				return hr;
			m_pAccessorInfo->bAutoAccessor = true;
		}

		return BindEntries(m_pEntry, m_nColumns, &m_pAccessorInfo->hAccessor, m_nBufferSize, spAccessor);
	}

	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer) throw()
	{
		HRESULT hr;
		*ppParameterBuffer = m_pParameterBuffer;

		// Only bind the parameter if we haven't done so yet
		if (*pHAccessor == NULL)
		{
			// Get the IAccessor from the passed IUnknown
			CComPtr<IAccessor> spAccessor;
			ATLASSERT(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				hr = BindEntries(m_pParameterEntry, m_nParameters, pHAccessor,
						m_nParameterBufferSize, spAccessor);
			}
		}
		else
			hr = S_OK;

		return hr;
	}
	typedef CManualAccessor _ParamClass;
	bool HasParameters() throw() { return (m_nParameters > 0); }
	typedef CManualAccessor _OutputColumnsClass;
	bool HasOutputColumns() throw() { return (m_nColumns > 0); }
	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	// The binding structure for the output columns
	DBBINDING*          m_pEntry;
	// The number of output columns
	DBORDINAL           m_nColumns;
	// The number of the current entry for the output columns
	DBORDINAL           m_nEntry;
	// The size of the data buffer for the output columns
	DBLENGTH            m_nBufferSize;
	// The number of parameters columns
	DBORDINAL           m_nParameters;
	// The number of the parameter column to bind next
	DBORDINAL           m_nCurrentParameter;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};

class _ATL_COLUMN_PARAM_INFO
{
public:
	_ATL_COLUMN_PARAM_INFO()
	{
		m_pParams = NULL;
		m_pBuffer = NULL;
	}
	~_ATL_COLUMN_PARAM_INFO()
	{
		delete m_pParams;
	}
	BOOL AddBinding(DBBINDING& binding)
	{
		return m_rgBinding.Add(binding);
	}

	CSimpleArray<DBBINDING, CSimpleArrayEqualHelperFalse<DBBINDING> >	m_rgBinding;	// The binding for each parameter
	DBPARAMS*				m_pParams;
	BYTE*					m_pBuffer;
};

///////////////////////////////////////////////////////////////////////////
// CColumnAccessor
class CColumnAccessor : public CAccessorBase
{
public:
	CColumnAccessor()
	{
		m_pParamInfo = NULL;
	}
	~CColumnAccessor()
	{
		delete m_pParamInfo;
	}
	// pUnk is the interface the accessor will be created upon
	HRESULT CreateAccessor(IUnknown* pUnk, DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			BYTE nPrecision, BYTE nScale, void* pData) throw()
	{
		nPrecision;
		nScale;
		ATLASSERT(pUnk != NULL);
		DBBINDING binding;
		
		// REVIEW: This will change when we have a separate buffer for each accessor
		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer);

		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Add another accessor info structure
		AddAccessorInfo();
		// REVIEW: I suppose I could add the new accessor at the beginning
		_ATL_ACCESSOR_INFO* pAccessorInfo = m_pAccessorInfo + m_nAccessors - 1;

		pAccessorInfo->bAutoAccessor = true;	// Always auto
		
		// Bind it
		return BindEntries(&binding, 1, &pAccessorInfo->hAccessor, nColumnSize, spAccessor);
	}
	// Bind columns doesn't have to do anything here as we bind each accessor when
	// CreateAccessor is called
	HRESULT BindColumns(IUnknown*) throw()
	{
		return S_OK;
	}
	HRESULT SetParameterBuffer(BYTE* pBuffer) throw()
	{
		// This should only be called once.
		ATLASSERT(m_pParamInfo == NULL);

		ATLTRY(m_pParamInfo = new _ATL_COLUMN_PARAM_INFO);
		if (m_pParamInfo == NULL)
			return E_OUTOFMEMORY;
		
		m_pParamInfo->m_pBuffer = pBuffer;
		return S_OK;
	}
	HRESULT AddParameter(DBPARAMIO paramio, DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			BYTE /* nPrecision*/, BYTE /* nScale */, void* pData) throw()
	{
		ATLASSERT(m_pParamInfo != NULL);
		
		DBBINDING binding;

		// REVIEW: This will change when we have a separate buffer for each accessor
		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, paramio,
			(BYTE*)pData - m_pParamInfo->m_pBuffer);

		if (m_pParamInfo->AddBinding(binding) == FALSE)
			return E_OUTOFMEMORY;

		return S_OK;
	}
	bool HasOutputColumns() throw()
	{
		// REVIEW: This probably won't always be true
		return true;
	}
	bool HasParameters() const throw()
	{
		return (m_pParamInfo != NULL) ? true : false;
	}
	// Called to bind the parameters created
	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer)
	{
		ATLASSERT(m_pParamInfo != NULL);
		HRESULT hr = S_OK;

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == NULL)
		{
			// Get the IAccessor from the passed ICommand
			CComPtr<IAccessor> spAccessor;
			ATLASSERT(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				*ppParameterBuffer = m_pParamInfo->m_pBuffer;
				// REVIEW: size isn't being passed here
				hr = BindEntries(&m_pParamInfo->m_rgBinding[0], m_pParamInfo->m_rgBinding.GetSize(),
					pHAccessor, 4, spAccessor);
			}

		}
		return hr;
	}
// Implementation
	typedef CColumnAccessor _ParamClass;
	typedef CColumnAccessor _OutputColumnsClass;
	HRESULT AddAccessorInfo() throw()
	{
		_ATL_ACCESSOR_INFO* pAccessorInfo = NULL;
		ATLTRY( pAccessorInfo = new _ATL_ACCESSOR_INFO[m_nAccessors + 1]; )
		if (pAccessorInfo == NULL)
			return E_OUTOFMEMORY;

		// Now copy the current accessor information to the new buffer
		memcpy(pAccessorInfo, m_pAccessorInfo, sizeof(_ATL_ACCESSOR_INFO) * m_nAccessors);
		m_nAccessors++;

		// Now delete the old memory and use the new one
		delete [] m_pAccessorInfo;
		m_pAccessorInfo = pAccessorInfo;
		return S_OK;
	}
	_ATL_COLUMN_PARAM_INFO* m_pParamInfo;
};

///////////////////////////////////////////////////////////////////////////
// CAccessorRowset

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CAccessorRowset :
	public TAccessor,
	public TRowset<TAccessor>
{
public:
	CAccessorRowset()
	{
		// Give the rowset a pointer to the accessor
		__if_exists(m_nAccessors)
		{
			SetAccessor(this);
		}
	}
	~CAccessorRowset()
	{
		Close();
	}
	// Used to get the column information from the opened rowset. The user is responsible
	// for freeing the returned column information and string buffer.
	HRESULT GetColumnInfo(DBORDINAL* pulColumns,
		DBCOLUMNINFO** ppColumnInfo, LPOLESTR* ppStrings) const throw()
	{
		if (ppColumnInfo == NULL || pulColumns == NULL || ppStrings == NULL)
			return E_POINTER;

		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		CComPtr<IColumnsInfo> spColumns;
		HRESULT hr = GetInterface()->QueryInterface(&spColumns);
		if (SUCCEEDED(hr))
			hr = spColumns->GetColumnInfo(pulColumns, ppColumnInfo, ppStrings);

		return hr;
	}

	// Used to get the column information when overriding the bindings using CDynamicAccessor
	// The user should CoTaskMemFree the column information pointer that is returned.
	HRESULT GetColumnInfo(DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo) throw()
	{
		// If you get a compilation here, then you are most likely calling this function
		// from a class that is not using CDynamicAccessor.
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		return TAccessor::GetColumnInfo(GetInterface(), pColumns, ppColumnInfo);
	}

	// Call to bind the output columns
	HRESULT Bind() throw()
	{
		// Bind should only be called when we've successfully opened the rowset
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		HRESULT hr = TAccessor::BindColumns(GetInterface());
		if (SUCCEEDED(hr))
			hr = BindFinished();
		return hr;
	}
	// Close the opened rowset and release the created accessors for the output columns
	void Close() throw()
	{
		if (GetInterface() != NULL)
		{
			ReleaseAccessors(GetInterface());
			TAccessor::Close();
			TRowset<TAccessor>::Close();
		}
	}
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory() throw()
	{
		TAccessor::FreeRecordMemory(m_spRowset);
	}
	void FreeRecordMemory(int nAccessor) throw()
	{
		TAccessor::FreeRecordMemory(nAccessor, m_spRowset);
	}
};


///////////////////////////////////////////////////////////////////////////
// class CEnumeratorAccessor

class CEnumeratorAccessor
{
public:
	WCHAR           m_szName[129];
	WCHAR           m_szParseName[129];
	WCHAR           m_szDescription[129];
	USHORT          m_nType;
	VARIANT_BOOL    m_bIsParent;

// Binding Maps
BEGIN_COLUMN_MAP(CEnumeratorAccessor)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szParseName)
	COLUMN_ENTRY(3, m_szDescription)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_bIsParent)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CEnumerator

class CEnumerator : public CAccessorRowset<CAccessor<CEnumeratorAccessor> >
{
public:
	HRESULT Open(LPMONIKER pMoniker) throw()
	{
		if (pMoniker == NULL)
			return E_FAIL;

		// Bind the moniker for the sources rowset
		if (FAILED(BindMoniker(pMoniker, 0, __uuidof(ISourcesRowset),
					(void**)&m_spSourcesRowset)))
			return E_FAIL;

		// Enumerate the data sources
		if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset)))
			return E_FAIL;

		return Bind();
	}
	HRESULT Open(const CEnumerator& enumerator) throw()
	{
		HRESULT hr;
		CComPtr<IMoniker> spMoniker;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		return Open(spMoniker);
	}
	HRESULT Open(const CLSID* pClsid = &CLSID_OLEDB_ENUMERATOR) throw()
	{
		if (pClsid == NULL)
			return E_FAIL;

		HRESULT hr;
		// Create the enumerator
		hr = CoCreateInstance(*pClsid, NULL, CLSCTX_INPROC_SERVER,
				__uuidof(ISourcesRowset), (LPVOID*)&m_spSourcesRowset);
		if (FAILED(hr))
			return hr;

		// Get the rowset so we can enumerate the data sources
		hr = m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset);
		if (FAILED(hr))
			return hr;

		return Bind();
	}

	void Close() throw()
	{
		// Close the rowset pointer
		if (m_spSourcesRowset != NULL)
			m_spSourcesRowset.Release();

		// Close the base class pointers
		CAccessorRowset<CAccessor<CEnumeratorAccessor> >::Close();
	}

	HRESULT GetMoniker(LPMONIKER* ppMoniker) const throw()
	{
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)m_szParseName,
				&chEaten, ppMoniker);
		return hr;
	}

	HRESULT GetMoniker(LPMONIKER* ppMoniker, LPCTSTR lpszDisplayName) const throw()
	{
		USES_CONVERSION;
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL || lpszDisplayName == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)T2COLE(lpszDisplayName),
				&chEaten, ppMoniker);
		return hr;
	}

	bool Find(TCHAR* szSearchName) throw()
	{
		USES_CONVERSION;
		// Loop through the providers looking for the passed name
		while (MoveNext()==S_OK && lstrcmp(W2T(m_szName), szSearchName))
			ATLTRACE(atlTraceDBClient, 2, _T("%s, %s, %d\n"), m_szName, m_szParseName, m_nType);
		if (lstrcmp(W2T(m_szName), szSearchName))
			return false;
		else
			return true;
	}

	CComPtr<ISourcesRowset> m_spSourcesRowset;
};


///////////////////////////////////////////////////////////////////////////
// CDataSource

class CDataSource
{
public:
	HRESULT Open(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;

		m_spInit.Release();
		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(const CLSID& clsid, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		HRESULT   hr;

		m_spInit.Release();
		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(LPCSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		USES_CONVERSION;
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(A2COLE(szProgID), &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(LPCWSTR szProgID, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(LPCWSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(LPCSTR szProgID, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		USES_CONVERSION;
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(A2COLE(szProgID), &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(const CEnumerator& enumerator, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		CComPtr<IMoniker> spMoniker;
		HRESULT   hr;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(const CEnumerator& enumerator, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		CComPtr<IMoniker> spMoniker;
		HRESULT   hr;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	// Invoke the data links dialog and open the selected database
	HRESULT Open(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_WIZARDSHEET) throw()
	{
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
			return hr;

		CComPtr<IDBProperties> spIDBProperties;
		hr = spDBInit->PromptDataSource(NULL, hWnd, dwPromptOptions, 0, NULL, NULL,
			__uuidof(IDBProperties), (IUnknown**)&spIDBProperties);

		if (hr == S_OK)
		{
			hr = spIDBProperties->QueryInterface(&m_spInit);
			if (SUCCEEDED(hr))
				hr = m_spInit->Initialize();
		}
		return hr;
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		CComPtr<IDataInitialize> spDataInit;
		HRESULT hr;
	
		hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER, 
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		hr = spDataInit->CreateDBInstance(clsid, NULL, CLSCTX_INPROC_SERVER, NULL, 
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(LPCTSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		USES_CONVERSION;
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(T2COLE(szProgID), &clsid);
		if (FAILED(hr))
			return hr;

		return OpenWithServiceComponents(clsid, pPropSet, nPropertySets);
	}
	// Bring up the "Organize Dialog" which allows the user to select a previously created data link
	// file (.UDL file). The selected file will be used to open the datbase.
	HRESULT OpenWithPromptFileName(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_NONE,
		LPCOLESTR szInitialDirectory = NULL) throw()
	{
		USES_CONVERSION;
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
			return hr;

		CComPtr<IDBProperties> spIDBProperties;
		LPOLESTR szSelected;

		hr = spDBInit->PromptFileName(hWnd, dwPromptOptions, szInitialDirectory, L"*.udl", &szSelected);

		if (hr == S_OK)
			hr = OpenFromFileName(szSelected);
		else if (hr == S_FALSE)
			hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CANCELLED);  // The user clicked cancel

		return hr;
	}
	// Open the datasource specified by the passed filename, typically a .UDL file
	HRESULT OpenFromFileName(LPCOLESTR szFileName) throw()
	{
		CComPtr<IDataInitialize> spDataInit;
		CComHeapPtr<OLECHAR>     spszInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->LoadStringFromStorage(szFileName, &spszInitString);
		if (FAILED(hr))
			return hr;

		return OpenFromInitializationString(spszInitString);
	}
	// Open the datasource specified by the passed initialization string
	HRESULT OpenFromInitializationString(LPCOLESTR szInitializationString, bool fPromptForInfo = false) throw()
	{
		CComPtr<IDataInitialize> spDataInit;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		CComPtr<IDBProperties> spIDBProperties;
		hr = spDataInit->GetDataSource(NULL, CLSCTX_INPROC_SERVER, szInitializationString,
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		if( fPromptForInfo )
		{
			CComPtr<IDBProperties> spIDBProperties;
			hr = m_spInit->QueryInterface( &spIDBProperties );

			DBPROP rgProperties[1];
			DBPROPSET rgPropertySets[1];

			VariantInit(&rgProperties[1].vValue);
			rgProperties[0].dwOptions = DBPROPOPTIONS_REQUIRED;
			rgProperties[0].colid = DB_NULLID;
			rgProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
			rgProperties[0].vValue.vt = VT_I2;
			rgProperties[0].vValue.lVal = DBPROMPT_COMPLETEREQUIRED;

			rgPropertySets[0].rgProperties = rgProperties;
			rgPropertySets[0].cProperties = 1;
			rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

			hr = spIDBProperties->SetProperties( 1, rgPropertySets );
			if (FAILED(hr))
				return hr;
		}

		return m_spInit->Initialize();
	}
	// Get the initialization string from the currently open data source. The returned string
	// must be CoTaskMemFree'd when finished with.
	HRESULT GetInitializationString(BSTR* pInitializationString, bool bIncludePassword=false) throw()
	{
		// If the datasource isn't open then we're not going to get an init string
		ATLASSERT(m_spInit != NULL);
		CComPtr<IDataInitialize> spDataInit;
		LPOLESTR    szInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->GetInitializationString(m_spInit, bIncludePassword, &szInitString);

		if (SUCCEEDED(hr))
		{
			*pInitializationString = ::SysAllocString(szInitString);
			if (*pInitializationString == NULL && szInitString != NULL)
				hr = E_OUTOFMEMORY;
			CoTaskMemFree(szInitString);
		}

		return hr;
	}
	HRESULT GetProperties(ULONG ulPropIDSets, const DBPROPIDSET* pPropIDSet,
				ULONG* pulPropertySets, DBPROPSET** ppPropsets) const throw()
	{
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSERT(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		hr = spProperties->GetProperties(ulPropIDSets, pPropIDSet, pulPropertySets,
				ppPropsets);
		return hr;
	}

	HRESULT GetProperty(const GUID& guid, DBPROPID propid, VARIANT* pVariant) const throw()
	{
		ATLASSERT(pVariant != NULL);
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSERT(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		CDBPropIDSet set(guid);
		set.AddPropertyID(propid);
		CComHeapPtr<DBPROPSET> spPropSet;
		ULONG ulPropSet = 0;
		hr = spProperties->GetProperties(1, &set, &ulPropSet, &spPropSet);
		if (FAILED(hr))
			return hr;

		ATLASSERT(ulPropSet == 1);
		VariantCopy(pVariant, &(spPropSet->rgProperties[0].vValue));
		VariantClear(&(spPropSet->rgProperties[0].vValue));
		CoTaskMemFree(spPropSet->rgProperties);

		return S_OK;
	}
	void Close() throw()
	{
		m_spInit.Release();
	}

// Implementation
	HRESULT OpenFromIDBProperties(IDBProperties* pIDBProperties) throw()
	{
		CComPtr<IPersist> spPersist;
		CLSID   clsid;
		HRESULT hr;

		hr = pIDBProperties->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
		if (FAILED(hr))
			return hr;

		spPersist->GetClassID(&clsid);

		ULONG       ulPropSets=0;
		CDBPropSet* pPropSets=NULL;
		pIDBProperties->GetProperties(0, NULL, &ulPropSets, (DBPROPSET**)&pPropSets);

		hr = Open(clsid, &pPropSets[0], ulPropSets);

		for (ULONG i=0; i < ulPropSets; i++)
			(pPropSets+i)->~CDBPropSet();
		CoTaskMemFree(pPropSets);

		return hr;
	}

	HRESULT OpenWithNameUserPassword(LPCTSTR pName, LPCTSTR pUserName, LPCTSTR pPassword, long nInitMode = 0) throw()
	{
		ATLASSERT(m_spInit != NULL);
		CComPtr<IDBProperties>  spProperties;
		HRESULT                 hr;

		hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		// Set connection properties
		CDBPropSet propSet(DBPROPSET_DBINIT);

		// Add Datbase name, User name and Password
		if (pName != NULL)
			propSet.AddProperty(DBPROP_INIT_DATASOURCE, pName);

		if (pUserName != NULL)
			propSet.AddProperty(DBPROP_AUTH_USERID, pUserName);

		if (pPassword != NULL)
			propSet.AddProperty(DBPROP_AUTH_PASSWORD, pPassword);

		if (nInitMode)
			propSet.AddProperty(DBPROP_INIT_MODE, nInitMode);

		hr = spProperties->SetProperties(1, &propSet);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return m_spInit->Initialize();
	}
	HRESULT OpenWithProperties(DBPROPSET* pPropSet, ULONG nPropertySets=1) throw()
	{
		ATLASSERT(m_spInit != NULL);

		// Set the properties if there are some to set
		if (pPropSet != NULL)
		{
			CComPtr<IDBProperties>  spProperties;
			HRESULT                 hr;

			hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
			if (FAILED(hr))
				return hr;

			hr = spProperties->SetProperties(nPropertySets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// Initialize the provider
		return m_spInit->Initialize();
	}

	CComPtr<IDBInitialize>  m_spInit;
};


///////////////////////////////////////////////////////////////////////////
// class CSession

class CSession
{
public:
	~CSession()
	{
		Close();
	}

	// Create a session on the passed datasource
	HRESULT Open(const CDataSource& ds, DBPROPSET *pPropSet = NULL, ULONG ulPropSets = 0) throw()
	{
		CComPtr<IDBCreateSession> spSession;

		// Check we have connected to the database
		ATLASSERT(ds.m_spInit != NULL);

		HRESULT hr = ds.m_spInit->QueryInterface(__uuidof(IDBCreateSession), (void**)&spSession);
		if (FAILED(hr))
			return hr;

		hr = spSession->CreateSession(NULL, __uuidof(IOpenRowset), (IUnknown**)&m_spOpenRowset);

		if( pPropSet != NULL && SUCCEEDED(hr) && m_spOpenRowset != NULL )
		{
			// If the user didn't specify the default parameter, use one
			if (pPropSet != NULL && ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ISessionProperties> spSessionProperties;
			hr = m_spOpenRowset->QueryInterface(__uuidof(ISessionProperties), (void**)&spSessionProperties);
			if(FAILED(hr))
				return hr;

			hr = spSessionProperties->SetProperties( ulPropSets, pPropSet );
		}
		return hr;
	}

	// Close the session
	void Close() throw()
	{
		m_spOpenRowset.Release();
	}
	// Start a transaction
	HRESULT StartTransaction(ISOLEVEL isoLevel = ISOLATIONLEVEL_READCOMMITTED, ULONG isoFlags = 0,
		ITransactionOptions* pOtherOptions = NULL, ULONG* pulTransactionLevel = NULL) const throw()
	{
		ATLASSERT(m_spOpenRowset != NULL);
		CComPtr<ITransactionLocal> spTransactionLocal;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransactionLocal);

		if (SUCCEEDED(hr))
			hr = spTransactionLocal->StartTransaction(isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);

		return hr;
	}
	// Abort the current transaction
	HRESULT Abort(BOID* pboidReason = NULL, BOOL bRetaining = FALSE, BOOL bAsync = FALSE) const throw()
	{
		ATLASSERT(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Abort(pboidReason, bRetaining, bAsync);

		return hr;
	}
	// Commit the current transaction
	HRESULT Commit(BOOL bRetaining = FALSE, DWORD grfTC = XACTTC_SYNC, DWORD grfRM = 0) const throw()
	{
		ATLASSERT(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Commit(bRetaining, grfTC, grfRM);

		return hr;
	}
	// Get information for the current transaction
	HRESULT GetTransactionInfo(XACTTRANSINFO* pInfo) const throw()
	{
		ATLASSERT(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->GetTransactionInfo(pInfo);

		return hr;
	}
// Implementation
	CComPtr<IOpenRowset> m_spOpenRowset;
};

///////////////////////////////////////////////////////////////////////////
// class CDataConnection

class CDataConnection
{
public:
	CDataConnection()
	{
	}

	CDataConnection(const CDataConnection &ds)
	{
		Copy(ds);
	}

	// for construction a CDataConnection with NULL
	CDataConnection(int i)
	{
		ATLASSERT(i==NULL);
		i;
	}

	CDataConnection& Copy(const CDataConnection &ds) throw()
	{
		m_source.m_spInit = ds.m_source.m_spInit;
		m_session.m_spOpenRowset = ds.m_session.m_spOpenRowset;
		return *this;
	}

	HRESULT Open(LPCOLESTR szInitString) throw()
	{
		HRESULT hr = E_FAIL;
		hr = m_source.OpenFromInitializationString(szInitString);
		if (hr == S_OK)
		{
			hr = m_session.Open(m_source);
		}
		return hr;
	}

    HRESULT OpenNewSession(CSession &session) throw()
    {
        return session.Open(m_source);
    }

    operator const CSession&() throw()
    {
        return m_session;
    }

	operator const CSession*() throw()
	{
		return &m_session;
	}

	operator const CDataSource&() throw()
	{
		return m_source;
	}

	operator const CDataSource*() throw()
	{
		return &m_source;
	}

	CDataConnection& operator=(const CDataConnection &ds) throw()
	{
		return Copy(ds);
	}
	
	// operator= is used for assignment of NULL to this object.
	// No other integer value can be assigned to this object.
	operator=(int i) throw()
	{
		ATLASSERT(i==NULL);
		if (i == NULL)
			m_session.Close();
	}

	operator BOOL() throw()
	{
		return m_session.m_spOpenRowset != NULL ? TRUE : FALSE;
	}

	operator bool() throw()
	{
		return m_session.m_spOpenRowset != NULL ? true : false;
	}

    void CloseDataSource() throw()
    {
        m_session.Close();
        m_source.Close();
    } 

	CSession m_session;
	CDataSource m_source;
};

///////////////////////////////////////////////////////////////////////////
// CTable

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CTable : public CAccessorRowset<TAccessor, TRowset>
{
public:
	// Open a rowset on the passed name
	HRESULT Open(const CSession& session, LPCWSTR wszTableName, DBPROPSET* pPropSet = NULL, 
				ULONG ulPropSets = 0) throw()
	{
		DBID    idTable;

		idTable.eKind           = DBKIND_NAME;
		idTable.uName.pwszName  = (LPOLESTR)wszTableName;

		return Open(session, idTable, pPropSet, ulPropSets);
	}

	HRESULT Open(const CSession& session, LPCSTR szTableName, DBPROPSET* pPropSet = NULL, 
				ULONG ulPropSets = 0) throw()
	{
		USES_CONVERSION;
		return Open( session, A2COLE(szTableName), pPropSet, ulPropSets );
	}

	// Open the a rowset on the passed DBID
	HRESULT Open(const CSession& session, DBID& dbid, DBPROPSET* pPropSet = NULL,
				ULONG ulPropSets = 0) throw()
	{
		// Check the session is valid
		ATLASSERT(session.m_spOpenRowset != NULL);
		HRESULT hr;

		// If the user didn't specify the default parameter, use one for 
		// backward compatibility
		if (pPropSet != NULL && ulPropSets == 0)
			ulPropSets = 1;

		hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, GetIID(),
			ulPropSets, pPropSet, (IUnknown**)GetInterfacePtr());
		if (SUCCEEDED(hr))
		{
			SetupOptionalRowsetInterfaces();

			// If we have output columns then bind
			if (_OutputColumnsClass::HasOutputColumns())
				hr = Bind();
		}

		return hr;
	}
};

#if (OLEDBVER < 0x0150)
#define DBGUID_DEFAULT DBGUID_DBSQL
#endif


///////////////////////////////////////////////////////////////////////////
// CCommandBase

class CCommandBase
{
public:
	CCommandBase()
	{
		m_hParameterAccessor = NULL;
	}

	~CCommandBase()
	{
		ReleaseCommand();
	}
	// Create the command
	HRESULT CreateCommand(const CSession& session) throw()
	{
		// Before creating the command, release the old one if necessary.
		ReleaseCommand();

		// Check the session is valid
		ATLASSERT(session.m_spOpenRowset != NULL);

		CComPtr<IDBCreateCommand> spCreateCommand;

		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBCreateCommand), (void**)&spCreateCommand);
		if (FAILED(hr))
			return hr;

		return spCreateCommand->CreateCommand(NULL, __uuidof(ICommand), (IUnknown**)&m_spCommand);
	}
	// Prepare the command
	HRESULT Prepare(ULONG cExpectedRuns = 0) throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Prepare(cExpectedRuns);

		return hr;
	}
	// Unprepare the command
	HRESULT Unprepare() throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Unprepare();

		return hr;
	}
	// Create the command and set the command text
	HRESULT Create(const CSession& session, LPCWSTR wszCommand,
		REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		HRESULT hr;

		hr = CreateCommand(session);
		if (SUCCEEDED(hr))
		{
			CComPtr<ICommandText> spCommandText;
			hr = m_spCommand->QueryInterface(&spCommandText);
			if (SUCCEEDED(hr))
				hr = spCommandText->SetCommandText(guidCommand, wszCommand);
		}
		return hr;
	}
	HRESULT Create(const CSession& session, LPCSTR szCommand,
		REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		USES_CONVERSION;
		return Create( session, A2COLE(szCommand), guidCommand );
	}

	// Release the command
	void ReleaseCommand() throw()
	{
		// Release the parameter accessor if necessary, before releasing the command
		if (m_hParameterAccessor != NULL && m_spCommand != NULL )
		{
			CComPtr<IAccessor> spAccessor;
			HRESULT hr = m_spCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				spAccessor->ReleaseAccessor(m_hParameterAccessor, NULL); \
				m_hParameterAccessor = NULL;
			}
		}
		m_spCommand.Release();
	}
	// Get the parameter information from the command
	HRESULT GetParameterInfo(DB_UPARAMS* pParams, DBPARAMINFO** ppParamInfo,
				OLECHAR** ppNamesBuffer) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Get the parameter information
			hr = spCommandParameters->GetParameterInfo(pParams, ppParamInfo,
					ppNamesBuffer);
		}
		return hr;
	}
	// Set the parameter information for the command
	HRESULT SetParameterInfo(DB_UPARAMS ulParams, const DBORDINAL* pOrdinals,
				const DBPARAMBINDINFO* pParamInfo) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Set the parameter information
			hr = spCommandParameters->SetParameterInfo(ulParams, pOrdinals,
				pParamInfo);
		}
		return hr;
	}

	CComPtr<ICommand>   m_spCommand;
	HACCESSOR           m_hParameterAccessor;
};

// Used to turn on multiple result set support in CCommand
class CMultipleResults
{
public:
	bool UseMultipleResults() throw() { return true; }
	IMultipleResults** GetMultiplePtrAddress() throw() { return &m_spMultipleResults.p; }
	IMultipleResults* GetMultiplePtr() throw() { return m_spMultipleResults; }

	CComPtr<IMultipleResults> m_spMultipleResults;
};

// Used to turn off multiple result set support in CCommand
class CNoMultipleResults
{
public:
	bool UseMultipleResults() throw() { return false; }
	IMultipleResults** GetMultiplePtrAddress() throw() { return NULL; }
	IMultipleResults* GetMultiplePtr() throw() { return NULL; }
};


///////////////////////////////////////////////////////////////////////////
// CCommand

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset, 
			class TMultiple = CNoMultipleResults>
class CCommand :
	public CAccessorRowset<TAccessor, TRowset>,
	public CCommandBase,
	public TMultiple
{
public:
	// Create a command on the session and execute it
	HRESULT Open(const CSession& session, LPCWSTR wszCommand,
		DBPROPSET *pPropSet = NULL, LONG* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;
		if (wszCommand == NULL)
		{
			hr = _CommandClass::GetDefaultCommand(&wszCommand);
			if (FAILED(hr))
				return hr;
		}
		hr = Create(session, wszCommand, guidCommand);
		if (FAILED(hr))
			return hr;

		return Open(pPropSet, pRowsAffected, bBind, ulPropSets);
	}

	HRESULT Open(const CSession& session, LPCSTR szCommand,
		DBPROPSET *pPropSet = NULL, LONG* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		USES_CONVERSION;
		if( szCommand == NULL )
			return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
		else
			return Open( session, A2COLE(szCommand), pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
	}

	// this version of Open, takes an INT instead of a string pointer.
	// this is to resolve an ambiguity when calling 
	// Open( session, NULL, ... ) or Open( session )
	HRESULT Open(const CSession& session, INT szCommand = NULL,
		DBPROPSET *pPropSet = NULL, LONG* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		szCommand;
		ATLASSERT( szCommand == NULL );

		return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
	}

	// Used if you have previously created the command
	HRESULT Open(DBPROPSET *pPropSet = NULL, LONG* pRowsAffected = NULL, 
		bool bBind = true, ULONG ulPropSets = 0) throw()
	{
		HRESULT     hr;
		DBPARAMS    params;
		DBPARAMS    *pParams;

		// Bind the parameters if we have some
		if (_ParamClass::HasParameters())
		{
			// Bind the parameters in the accessor if they haven't already been bound
			hr = BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
			if (FAILED(hr))
				return hr;

			// Setup the DBPARAMS structure
			params.cParamSets = 1;
			params.hAccessor = m_hParameterAccessor;
			pParams = &params;
		}
		else
			pParams = NULL;

		return ExecuteAndBind(pParams, pPropSet, pRowsAffected, bBind, ulPropSets);
	}
	// Get the next rowset when using multiple result sets
	HRESULT GetNextResult(LONG* pulRowsAffected, bool bBind = true) throw()
	{
		// This function should only be called if CMultipleResults is being
		// used as the third template parameter
		ATLASSERT(GetMultiplePtrAddress() != NULL);

		// If user calls GetNextResult but the interface is not available
		// return E_FAIL.
		if (GetMultiplePtr() == NULL)
			return E_FAIL;

		// Close the existing rowset in preparation for opening the next one
		Close();

		HRESULT hr = GetMultiplePtr()->GetResult(NULL, 0, GetIID(),
			pulRowsAffected, (IUnknown**)GetInterfacePtr());
		if (FAILED(hr))
			return hr;

		if (bBind && GetInterface() != NULL)
			return Bind();
		else
			return hr;
	}

// Implementation
	HRESULT ExecuteAndBind(DBPARAMS* pParams, DBPROPSET* pPropSet = NULL, 
		LONG* pRowsAffected = NULL, bool bBind = true, ULONG ulPropSets = 0) throw()
	{
		HRESULT hr = Execute((IUnknown**)GetInterfacePtr(), pParams, pPropSet, 
							pRowsAffected, ulPropSets);
		if (FAILED(hr))
			return hr;

		// Only bind if we have been asked to and we have output columns
		if (bBind && _OutputColumnsClass::HasOutputColumns())
		{
			// for dynamic accessors we don't want to automatically call Bind if we got no rowset in return
			if( NoBindOnNullRowset() && GetInterface() == NULL )
				return hr;
			else
				return Bind();
		}
		else
			return hr;

	}

	HRESULT Execute(IRowset** ppRowset, DBPARAMS* pParams, DBPROPSET *pPropSet, 
		LONG* pRowsAffected, ULONG ulPropSets = 0) throw()
	{
		return Execute( (IUnknown**)ppRowset, pParams, pPropSet, pRowsAffected, ulPropSets );
	}

	HRESULT Execute(IUnknown** ppInterface, DBPARAMS* pParams, DBPROPSET *pPropSet, 
		LONG* pRowsAffected, ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;

		// Specify the properties if we have some
		if (pPropSet)
		{
			// For backward compatibility, if the default parameter is not
			// specified, then set it to one if a property set exists
			if (ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ICommandProperties> spCommandProperties;
			hr = m_spCommand->QueryInterface(&spCommandProperties);
			if (FAILED(hr))
				return hr;

			hr = spCommandProperties->SetProperties(ulPropSets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// If the user want the rows affected then return it back, otherwise
		// just point to our local variable here.
		LONG nAffected, *pAffected;
		if (pRowsAffected)
			pAffected = pRowsAffected;
		else
			pAffected = &nAffected;

		if (UseMultipleResults())
		{
			hr = m_spCommand->Execute(NULL, __uuidof(IMultipleResults), pParams,
				pAffected, (IUnknown**)GetMultiplePtrAddress());

			if (SUCCEEDED(hr))
				hr = GetNextResult(pAffected, false);
			else
				// If we can't get IMultipleResults then just try to get IRowset
				hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
					ppInterface);
		}
		else
		{
			hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
				ppInterface);
		}
		if (SUCCEEDED(hr))
			SetupOptionalRowsetInterfaces();

		return hr;
	}
};


// This class can be used to implement the IRowsetNotify interface.
// It is supplied so that if you only want to implement one of the
// notifications you don't have to supply empty functions for the
// other methods.
class ATL_NO_VTABLE IRowsetNotifyImpl : public IRowsetNotify
{
public:
	STDMETHOD(OnFieldChange)(
			/* [in] */ IRowset* /* pRowset */,
			/* [in] */ HROW /* hRow */,
			/* [in] */ DBORDINAL /* cColumns */,
			/* [size_is][in] */ DBORDINAL /* rgColumns*/ [] ,
			/* [in] */ DBREASON /* eReason */,
			/* [in] */ DBEVENTPHASE /* ePhase */,
			/* [in] */ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnFieldChange"));
	}
	STDMETHOD(OnRowChange)(
			/* [in] */ IRowset* /* pRowset */,
			/* [in] */ DBCOUNTITEM /* cRows */,
			/* [size_is][in] */ const HROW /* rghRows*/ [] ,
			/* [in] */ DBREASON /* eReason */,
			/* [in] */ DBEVENTPHASE /* ePhase */,
			/* [in] */ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowChange"));
	}
	STDMETHOD(OnRowsetChange)(
		/* [in] */ IRowset* /* pRowset */,
		/* [in] */ DBREASON /* eReason */,
		/* [in] */ DBEVENTPHASE /* ePhase */,
		/* [in] */ BOOL /* fCantDeny*/)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowsetChange"));
	}
};


}; //namespace ATL

#pragma warning(pop)

#endif // __ATLDBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlfile.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLFILE_H__
#define __ATLFILE_H__

#pragma once

#include <atlbase.h>

namespace ATL
{

class CAtlFile : public CHandle
{
public:
	CAtlFile() throw()
	{
	}
	CAtlFile( CAtlFile& file ) throw() :
		CHandle( file )  // Transfers ownership
	{
	}
	explicit CAtlFile( HANDLE hFile ) throw() :
		CHandle( hFile )  // Takes ownership
	{
	}

	HRESULT Create(
		LPCTSTR szFilename,
		DWORD dwDesiredAccess,
		DWORD dwShareMode,
		DWORD dwCreationDisposition,
		DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		LPSECURITY_ATTRIBUTES lpsa = NULL,
		HANDLE hTemplateFile = NULL) throw()
	{
		ATLASSERT(m_h == NULL);

		HANDLE hFile = ::CreateFile(
			szFilename,
			dwDesiredAccess,
			dwShareMode,
			lpsa,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile);

		if (hFile == INVALID_HANDLE_VALUE)
			return AtlHresultFromLastError();

		Attach(hFile);
		return S_OK;
	}

	HRESULT Read(
		LPVOID pBuffer,
		DWORD nBufSize) throw()
	{
		ATLASSERT(m_h != NULL);

		DWORD nBytesRead = 0;
		BOOL bSuccess = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!bSuccess )
			return AtlHresultFromLastError();
		if (nBytesRead != nBufSize)
			return HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );

		return S_OK;
	}

	HRESULT Read(
		LPVOID pBuffer,
		DWORD nBufSize,
		DWORD& nBytesRead) throw()
	{
		ATLASSERT(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Read(
		LPVOID pBuffer,
		DWORD nBufSize,
		LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSERT(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Read(
		LPVOID pBuffer,
		DWORD nBufSize,
		LPOVERLAPPED pOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSERT(m_h != NULL);

		BOOL b = ::ReadFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Write(
		LPCVOID pBuffer,
		DWORD nBufSize,
		DWORD* pnBytesWritten = NULL) throw()
	{
		ATLASSERT(m_h != NULL);

		DWORD nBytesWritten;
		if (pnBytesWritten == NULL)
			pnBytesWritten = &nBytesWritten;
		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, pnBytesWritten, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Write(
		LPCVOID pBuffer,
		DWORD nBufSize,
		LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSERT(m_h != NULL);

		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Write(
		LPCVOID pBuffer,
		DWORD nBufSize,
		LPOVERLAPPED pOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSERT(m_h != NULL);

		BOOL b = ::WriteFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function returns HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)
	// if bWait is false and the operation is still pending
	HRESULT GetOverlappedResult(
		LPOVERLAPPED pOverlapped,
		DWORD& dwBytesTransferred,
		BOOL bWait) throw()
	{
		BOOL b = ::GetOverlappedResult(m_h, pOverlapped, &dwBytesTransferred, bWait);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Seek(LONGLONG nOffset, DWORD dwFrom = FILE_CURRENT) throw()
	{
		ATLASSERT(m_h != NULL);
		ATLASSERT(dwFrom == FILE_BEGIN || dwFrom == FILE_END || dwFrom == FILE_CURRENT);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = nOffset;
		DWORD nNewPos = ::SetFilePointer(m_h, liOffset.LowPart, &liOffset.HighPart, dwFrom);
		if (nNewPos == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		return S_OK;
	}

	HRESULT GetPosition(ULONGLONG& nPos) const throw()
	{
		ATLASSERT(m_h != NULL);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = 0;
		liOffset.LowPart = ::SetFilePointer(m_h, 0, &liOffset.HighPart, FILE_CURRENT);
		if (liOffset.LowPart == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}
		nPos = liOffset.QuadPart;

		return S_OK;
	}

	HRESULT Flush() throw()
	{
		ATLASSERT(m_h != NULL);

		if (!::FlushFileBuffers(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT LockRange(ULONGLONG nPos, ULONGLONG nCount) throw()
	{
		ATLASSERT(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::LockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT UnlockRange(ULONGLONG nPos, ULONGLONG nCount) throw()
	{
		ATLASSERT(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::UnlockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT SetSize(ULONGLONG nNewLen) throw()
	{
		ATLASSERT(m_h != NULL);

		HRESULT hr = Seek(nNewLen, FILE_BEGIN);
		if (FAILED(hr))
			return hr;

		if (!::SetEndOfFile(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT GetSize(ULONGLONG& nLen) const throw()
	{
		ATLASSERT(m_h != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(m_h, &liFileSize.HighPart);
		if (liFileSize.LowPart == 0xFFFFFFFF)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		nLen = liFileSize.QuadPart;

		return S_OK;
	}
};

// This class allows the creation of a temporary file that is written to.
// When the entire file has been successfully written it will be closed and given
// it's proper file name if required.
class CAtlTemporaryFile
{
public:
	CAtlTemporaryFile() throw()
	{
	}

	~CAtlTemporaryFile() throw()
	{
		// Ensure that the temporary file is closed and deleted,
		// if necessary.
		if (m_file.m_h != NULL)
		{
			Close();
		}
	}
	
	HRESULT Create(LPCTSTR pszDir = NULL, DWORD dwDesiredAccess = GENERIC_WRITE) throw()
	{
		TCHAR szPath[_MAX_DIR+1];
		
		ATLASSERT(m_file.m_h == NULL);
		
		if (pszDir == NULL)
		{
			if (!GetTempPath(_MAX_DIR, szPath))
			{
				// Couldn't find temporary path;
				return AtlHresultFromLastError();
			}
		}
		else
		{
			_tcsncpy(szPath, pszDir, _MAX_DIR);
			szPath[_MAX_DIR] = 0;
		}


		if (!GetTempFileName(szPath, _T("TFR"), 0, m_szTempFileName))
		{
			// Couldn't create temporary filename;
			return AtlHresultFromLastError();
		}

		SECURITY_ATTRIBUTES secatt;
		secatt.nLength = sizeof(secatt);
		secatt.lpSecurityDescriptor = NULL;
		secatt.bInheritHandle = TRUE;

		m_dwAccess = dwDesiredAccess;

		return m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			&secatt);
	}

	HRESULT Close(LPCTSTR szNewName = NULL) throw()
	{
		ATLASSERT(m_file.m_h != NULL);

		// This routine is called when we are finished writing to the 
		// temporary file, so we now just want to close it and copy
		// it to the actual filename we want it to be called.

		// So let's close it first.
		m_file.Close();

		// no new name so delete it
		if (szNewName == NULL)
		{
			::DeleteFile(m_szTempFileName);
			return S_OK;
		}

		// delete any existing file and move our temp file into it's place
		if (!::DeleteFile(szNewName))
		{
			DWORD dwError = GetLastError();
			if (dwError != ERROR_FILE_NOT_FOUND)
				return AtlHresultFromWin32(dwError);
		}

		if (!::MoveFile(m_szTempFileName, szNewName))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT HandsOff() throw()
	{
		m_file.Flush();
		m_file.Close();

		return S_OK;
	}

	HRESULT HandsOn() throw()
	{
		HRESULT hr = m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			OPEN_EXISTING);
		if (FAILED(hr))
			return hr;

		return m_file.Seek(0, FILE_END);
	}

	HRESULT Read(
		LPVOID pBuffer,
		DWORD nBufSize,
		DWORD& nBytesRead) throw()
	{
		return m_file.Read(pBuffer, nBufSize, nBytesRead);
	}

	HRESULT Write(
		LPCVOID pBuffer,
		DWORD nBufSize,
		DWORD* pnBytesWritten = NULL) throw()
	{
		return m_file.Write(pBuffer, nBufSize, pnBytesWritten);
	}

	HRESULT Seek(LONGLONG nOffset, DWORD dwFrom = FILE_CURRENT) throw()
	{
		return m_file.Seek(nOffset, dwFrom);
	}

	HRESULT GetPosition(ULONGLONG& nPos) const throw()
	{
		return m_file.GetPosition(nPos);
	}

	HRESULT Flush() throw()
	{
		return m_file.Flush();
	}

	HRESULT LockRange(ULONGLONG nPos, ULONGLONG nCount) throw()
	{
		return m_file.LockRange(nPos, nCount);
	}

	HRESULT UnlockRange(ULONGLONG nPos, ULONGLONG nCount) throw()
	{
		return m_file.UnlockRange(nPos, nCount);
	}

	HRESULT SetSize(ULONGLONG nNewLen) throw()
	{
		return m_file.SetSize(nNewLen);
	}

	HRESULT GetSize(ULONGLONG& nLen) const throw()
	{
		return m_file.GetSize(nLen);
	}

	operator HANDLE() throw()
	{
		return m_file;
	}

	LPCTSTR TempFileName() throw()
	{
		return m_szTempFileName;
	}

private:
	CAtlFile m_file;
	TCHAR m_szTempFileName[_MAX_FNAME+1];
	DWORD m_dwAccess;
};

class CAtlFileMappingBase
{
public:
	CAtlFileMappingBase() throw()
	{
		m_pData = NULL;
		m_hMapping = NULL;
	}

	~CAtlFileMappingBase() throw()
	{
		Unmap();
	}

	HRESULT MapFile(
		HANDLE hFile,
		DWORD nMappingSize = 0,
		ULONGLONG nOffset = 0,
		DWORD dwMappingProtection = PAGE_READONLY,
		DWORD dwViewDesiredAccess = FILE_MAP_READ) throw()
	{
		ATLASSERT(m_pData == NULL);
		ATLASSERT(m_hMapping == NULL);
		ATLASSERT(hFile != INVALID_HANDLE_VALUE && hFile != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(hFile, &liFileSize.HighPart);
		if (liFileSize.QuadPart < nMappingSize)
			liFileSize.QuadPart = nMappingSize;

		m_hMapping = ::CreateFileMapping(hFile, NULL, dwMappingProtection, liFileSize.HighPart, liFileSize.LowPart, 0);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (nMappingSize == 0)
			m_dwMappingSize = (DWORD) (liFileSize.QuadPart - nOffset);
		else
			m_dwMappingSize = nMappingSize;

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = nOffset;

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_dwMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	HRESULT MapSharedMem(
		DWORD nMappingSize,
		LPCTSTR szName,
		BOOL* pbAlreadyExisted = NULL,
		LPSECURITY_ATTRIBUTES lpsa = NULL,
		DWORD dwMappingProtection = PAGE_READWRITE,
		DWORD dwViewDesiredAccess = FILE_MAP_ALL_ACCESS) throw()
	{
		ATLASSERT(m_pData == NULL);
		ATLASSERT(m_hMapping == NULL);
		ATLASSERT(nMappingSize > 0);
		ATLASSERT(szName != NULL); // if you just want a regular chunk of memory, use a heap allocator

		m_dwMappingSize = nMappingSize;

		m_hMapping = ::CreateFileMapping(NULL, lpsa, dwMappingProtection, 0, m_dwMappingSize, szName);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (pbAlreadyExisted != NULL)
			*pbAlreadyExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = 0;

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_dwMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			return hr;
		}


		return S_OK;
	}

	HRESULT Unmap() throw()
	{
		HRESULT hr = S_OK;

		if (m_pData != NULL)
		{
			if (!::UnmapViewOfFile(m_pData))
				hr = AtlHresultFromLastError();
			m_pData = NULL;
		}
		if (m_hMapping != NULL)
		{
			if (!::CloseHandle(m_hMapping) && SUCCEEDED(hr))
				hr = AtlHresultFromLastError();
			m_hMapping = NULL;
		}
		return hr;
	}

	void* GetData() const throw()
	{
		return m_pData;
	}

	DWORD GetMappingSize() throw()
	{
		return m_dwMappingSize;
	}

	HRESULT CopyFrom(CAtlFileMappingBase& orig) throw()
	{
		ATLASSERT(m_pData == NULL);
		ATLASSERT(m_hMapping == NULL);
		ATLASSERT(orig.m_pData != NULL);
		ATLASSERT(orig.m_hMapping != NULL);

		m_dwViewDesiredAccess = orig.m_dwViewDesiredAccess;
		m_nOffset.QuadPart = orig.m_nOffset.QuadPart;
		m_dwMappingSize = orig.m_dwMappingSize;

		if (!::DuplicateHandle(GetCurrentProcess(), orig.m_hMapping, GetCurrentProcess(),
				&m_hMapping, NULL, TRUE, DUPLICATE_SAME_ACCESS))
			return AtlHresultFromLastError();

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_dwMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	CAtlFileMappingBase(CAtlFileMappingBase& orig)
	{
		m_pData = NULL;
		m_hMapping = NULL;

		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);
	}

	CAtlFileMappingBase& operator=(CAtlFileMappingBase& orig)
	{
		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);

		return *this;
	}

private:
	void* m_pData;
	DWORD m_dwMappingSize;
	HANDLE m_hMapping;
	ULARGE_INTEGER m_nOffset;
	DWORD m_dwViewDesiredAccess;
};

template <typename T = char>
class CAtlFileMapping : public CAtlFileMappingBase
{
public:
	operator T*() const throw()
	{
		return reinterpret_cast<T*>(GetData());
	}
};

}; //namespace ATL

#endif //__ATLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlextmgmt.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXTMGMT_H__
#define __ATLEXTMGMT_H__

#pragma once
#pragma warning(push)
#pragma warning(disable: 4702)
#include <atlsoap.h>
#include <atlutil.h>
#include <atlsrvres.h>
#include <atlsecurity.h>

//
// You can change the local group that is used for authorizing
// site administrators by #define'ing ATL_DEFAULT_AUTH group
// to something else before including this header file. For
// example:
// #define ATL_DEFAULT_AUTHGRP CSid(_T("My Heros"))
//     Verify that the logged on user is a members of
//     the local group 'My Heros' before allowing them to
//     administrate this site.
//
// #define ATL_DEFAULT_AUTHGRP Sids::World
//     Allow everyone access
//
// #define ATL_DEFAULT_AUTHGRP Sids::Null
//     Allow noone access
//
#ifndef ATL_DEFAULT_AUTHGRP
	#define ATL_DEFAULT_AUTHGRP Sids::Admins()
#endif

// If you #define ATL_NO_DEFAULT_AUTHORITY then there will be no authorization
// check before allowing access to management functions. You can also #define
// ATL_NO_DEFAULT_AUTHORITY and then declare you own instance of _Authority
// before #includin'ing atlextmgmt.h to use a different authorization scheme.
#ifndef ATL_NO_DEFAULT_AUTHORITY
	__declspec(selectany) CDefaultAuth _Authority;
#endif

// You can choose which of the management handlers actually get used by
// #defining the following constants before including this header
// _ATL_THREADPOOL_MANAGEMENT (The thread pool manager web service and web based UI)
// _ATL_STENCILCACHE_MANAGEMENT (The stencil cache manager web service and web based UI)
// _ATL_DLLCACHE_MANAGEMENT (The DLL cache manager service and web based UI)

// You can use the following constants to remove the web based UI if you don't
// want to use it.
// _ATL_THREADPOOL_NOUI (removes the thread pool mgr's stencil handler)
// _ATL_STENCILCACHE_NOUI (removes the stencil cache mgr's stencil handler)
// _ATL_DLLCACHE_NOUI (removes the dll cache mgr's stencil handler)

// You can use the following constants to remove the web service management
// components individually
// _ATL_THREADPOOL_NOWEBSERVICE (removes the thread pool mgr's stencil handler)
// _ATL_STENCILCACHE_NOWEBSERVICE (removes the stencil cache mgr's stencil handler)
// _ATL_DLLCACHE_NOWEBSERVICE (removes the dll cache mgr's stencil handler)


// The following constants declare resource names of stencils included
// as resources in the module that uses this header. These stencils are 
// used for the web based UI for the management objects. You can provide
// stencils of your own by including them as resources and redefining these
// constants before including this header.
#ifndef IDR_THREADMGR_SRF
	#define IDR_THREADMGR_SRF "THREADMGR.SRF"
#endif

#ifndef IDR_STENCILMGR_SRF
	#define IDR_STENCILMGR_SRF "STENCILMGR.SRF"
#endif

#ifndef IDR_DLLMGR_SRF
	#define IDR_DLLMGR_SRF "DLLMGR.SRF"
#endif

// A warning so users using the web based UI to manage their extension
// will remember to include the stencil resources n their projects
#if defined(_ATL_THREADPOOL_MANAGEMENT) || defined(_ATL_STENCILCACHE_MANAGEMENT) || defined(_ATL_DLLCACHE_MANAGEMENT)
#ifndef NO_ATL_MGMT_STENCIL_WARNING
	#pragma message("*************** Please Note ***************")
	#pragma message("Your usage of atlextmgmt.h requires you to include management")
	#pragma message("stencil resources in your module's resource file.")
	#pragma message("Please make sure you include atlsrv.rc in your resource file.\r\n")
#endif
#endif

// These constants define the names used for the handler objects for the
// various services. You can change the names by redefining these constants
// before including this header

#ifndef ID_THREADMGR_WEBSERVICE_NAME
	#define ID_THREADMGR_WEBSERVICE_NAME "ThreadPoolManager"
#endif

#ifndef ID_THREADMGR_WEBSERVICE_URL
	#define ID_THREADMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/ThreadPoolManager"
#endif

#ifndef ID_THREADMGR_WEBSERVICE_WSDL
	#define ID_THREADMGR_WEBSERVICE_WSDL "GenThreadPoolManagerWSDL"
#endif

#ifndef ID_THREADMGR_SRFHANDLER_NAME
	#define ID_THREADMGR_SRFHANDLER_NAME "ThreadMgrSrf"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_NAME
	#define ID_STENCILCACHEMGR_WEBSERVICE_NAME "StencilCacheManager"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_URL
	#define ID_STENCILCACHEMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/StencilCacheManager"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_WSDL
	#define ID_STENCILCACHEMGR_WEBSERVICE_WSDL "GenStencilCacheManagerWSDL"
#endif

#ifndef ID_STENCILCACHEMGR_SRFHANDLER_NAME
	#define ID_STENCILCACHEMGR_SRFHANDLER_NAME "StencilMgrSrf"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_NAME
	#define ID_DLLCACHEMGR_WEBSERVICE_NAME "DllCacheManager"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_URL
	#define ID_DLLCACHEMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/DllCacheManager"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_WSDL
	#define ID_DLLCACHEMGR_WEBSERVICE_WSDL "GenDllCacheManagerWSDL"
#endif


#ifndef ID_DLLCACHEMGR_SRFHANDLER_NAME
	#define ID_DLLCACHEMGR_SRFHANDLER_NAME "DllMgrSrf"
#endif

namespace ATL {

[emitidl(restricted)];

#define ATL_COLOR_TR1			RGB(0xd2, 0xff, 0xff)
#define ATL_COLOR_TR2			RGB(0xd2, 0xff, 0xd2)
#define ATL_COLOR_BODYBG		RGB(0xec, 0xf9, 0xec)

// _AtlRedirectToPage builds up a redirect URL from the
// current request plus a Handler= specification and 
// redirects the user's browser to that page.
inline HTTP_CODE _AtlRedirectToPage(
	IHttpServerContext *pContext,
	CHttpRequest& request,
	CHttpResponse& response,
	const char *szHandler) throw()
{
	ATLASSERT(pContext);
	const char *pProto = "http://";
	size_t len = strlen(pProto);
	char buff[ATL_URL_MAX_URL_LENGTH];
	DWORD dwLen;
	dwLen = (DWORD) (ATL_URL_MAX_URL_LENGTH-len);
	strcpy(buff, pProto);
	pContext->GetServerVariable("SERVER_NAME", (char*)(buff + len), &dwLen);
	len += dwLen-1; // The length returned in dwLen includes the NULL

	dwLen = (DWORD) (ATL_URL_MAX_URL_LENGTH-len);
	request.GetUrl((char*)(buff + len), &dwLen); 
	len += dwLen-1; // The length returned in dwLen includes the NULL

	strcpy((char*)(buff + len), szHandler);;
	response.Redirect(buff);

	return HTTP_SUCCESS_NO_PROCESS;

}

#ifdef _ATL_THREADPOOL_MANAGEMENT
///////////////////////////////////////////////////////////////////////
// Thread pool management

[ uuid("44e9962a-5207-4d2a-a466-5f08a76e0e5d"), object ]
__interface IThreadPoolMgr
{
    [id(0)] STDMETHOD(SetSize)([in] int nNumThreads);
    [id(1)] STDMETHOD(GetSize)([out,retval] int *pnNumThreads);

};


class CThreadPoolMgrObject
{
public:
	CThreadPoolMgrObject() throw()
	{
	}

    HRESULT SetSize(int nNumThreads) throw()
	{
		if (!m_spThreadPoolConfig)
			return E_UNEXPECTED;

		return m_spThreadPoolConfig->SetSize(nNumThreads);
	}

	
    HRESULT GetSize(int *pnNumThreads) throw()
	{	
		if (!m_spThreadPoolConfig)
			return E_UNEXPECTED;

		return m_spThreadPoolConfig->GetSize(pnNumThreads);

	}

	HTTP_CODE Initialize(IServiceProvider *pProvider) throw()
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spThreadPoolConfig)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(IThreadPoolConfig), &m_spThreadPoolConfig);
		return m_spThreadPoolConfig ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IThreadPoolConfig> m_spThreadPoolConfig;
};

#ifndef _ATL_THREADPOOL_NOWEBSERVICE
#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(
					name=      ID_THREADMGR_WEBSERVICE_NAME, 
					namespace= ID_THREADMGR_WEBSERVICE_URL,
					protocol=  "soap"
				),
	request_handler(
					name= ID_THREADMGR_WEBSERVICE_NAME,
					sdl=  ID_THREADMGR_WEBSERVICE_WSDL
					)
]
class CThreadPoolManager :
	public IThreadPoolMgr
{
#pragma warning(pop)
public:
	[soap_method]
    STDMETHOD(SetSize)(int nNumThreads)
	{
		return m_PoolMgr.SetSize(nNumThreads);
	}

	[soap_method]
    STDMETHOD(GetSize)(int *pnNumThreads)
	{	
		return m_PoolMgr.GetSize(pnNumThreads);
	}

	// override HandleRequest to Initialize our m_spServiceProvider
	// and to handle authorizing the client.
	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_PoolMgr.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;
		
		// Make sure caller is authorized on this system
__if_exists(_Authority)
{
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}
private:
	CThreadPoolMgrObject m_PoolMgr;
};
#endif //_ATL_THREADPOOL_NOWEBSERVICE

#ifndef _ATL_THREADPOOL_NOUI
#define INVALID_COMMAND_ID -1
#define MAX_COMMAND_ID 64
                       
[request_handler(name=ID_THREADMGR_SRFHANDLER_NAME)]
class CThreadMgrStencil
{
public:
	CThreadMgrStencil() :
		m_nColor(ATL_COLOR_TR1)
	{

	}

	[tag_name("GetSize")]
	HTTP_CODE GetSize()
	{
		int nSize = 0;
		HRESULT hr = m_PoolMgr.GetSize(&nSize);
		if (SUCCEEDED(hr))
		{
			m_HttpResponse << nSize;
		}
		else
			m_HttpResponse << "size not found";
		
		return HTTP_SUCCESS;
	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;
		
		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}


	HTTP_CODE ValidateAndExchange() throw()
	{
		_ATLTRY
		{
			// Initialize the thread pool manager instance. Internally
			// the initialize function will only intialize it's data structures
			// once.
			HTTP_CODE hcErr = m_PoolMgr.Initialize(m_spServiceProvider);
			if (hcErr != HTTP_SUCCESS)
				return hcErr;

__if_exists(_Authority)
{
				// Make sure caller is authorized on this system
				hcErr = HTTP_FAIL;
				ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
				if (hcErr != HTTP_SUCCESS)
					return hcErr;
}

			// load the stencil to render from a resource
			hcErr = LoadStencilResource(m_hInstHandler, IDR_THREADMGR_SRF);
			if (hcErr)
				return hcErr;

			m_HttpResponse.SetContentType("text/html");

			CString strHandler, strOptParam;
			int nCmdToExec = INVALID_COMMAND_ID;

			// check to see if we have a "Method" form variable
			DWORD dwErr = m_HttpRequest.QueryParams.Exchange("Method", &strHandler);
			if (dwErr != VALIDATION_S_OK)
				return HTTP_SUCCESS; // nothing to do.

			if (strHandler != _T("ExecuteCommand"))
				return HTTP_SUCCESS; // Wrong handler was passed

			// get the value of the command parameter so we can execute it
			dwErr = m_HttpRequest.QueryParams.Validate("command", &nCmdToExec, 0, MAX_COMMAND_ID);
			if (dwErr != VALIDATION_S_OK)
				return HTTP_SUCCESS; // Wrong command id, nothing to do.

			// get the optional parameter if it's there.
			m_HttpRequest.QueryParams.Validate("DynValue", &strOptParam, 0, MAX_COMMAND_ID);

			hcErr = ExecCommand(nCmdToExec, strOptParam);
			return hcErr;
		}
		_ATLCATCHALL()
		{
			return HTTP_FAIL;
		}
	}

	HTTP_CODE ExecCommand(int nCmdToExec, CString& strOptParam)
	{
		switch (nCmdToExec)
		{
		case 0:
			TCHAR *pStop = NULL;
			int nValue = _tcstoul(strOptParam, &pStop, 10);
			m_PoolMgr.SetSize(nValue);
		break;
		};

		return _AtlRedirectToPage(
							m_spServerContext,
							m_HttpRequest,
							m_HttpResponse,
							"?Handler=" ID_THREADMGR_SRFHANDLER_NAME
							);
	}
private:
	CThreadPoolMgrObject m_PoolMgr;
	long m_nColor;
	CString m_strUrl;

};


#endif // _ATL_THREADPOOL_NOUI
#endif // _ATL_THREADPOOL_MANAGEMENT

#ifdef _ATL_STENCILCACHE_MANAGEMENT
//////////////////////////////////////////////////////////////////////
// Stencil cache management
class CStencilCacheMgrObject
{
public:
	CStencilCacheMgrObject()
	{

	}

	HRESULT GetCurrentEntryCount(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;
		HRESULT hr = m_spMemCacheStats->GetCurrentEntryCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT ClearStats()
	{
		ATLASSERT(m_spMemCacheStats);
		return m_spMemCacheStats->ClearStats();		
	}

	HRESULT GetHitCount(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;
		HRESULT hr = m_spMemCacheStats->GetHitCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT GetMissCount(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMissCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;	
	}

	HRESULT GetCurrentAllocSize(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetCurrentAllocSize(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT GetMaxAllocSize(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMaxAllocSize(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}


	HRESULT GetMaxEntryCount(__int64 *pdwSize)
	{
		ATLASSERT(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMaxEntryCount(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}


	HRESULT RemoveStencil(__int64 hStencil)
	{
		ATLASSERT(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveStencil((const HCACHEITEM)hStencil);		
	}

	HRESULT RemoveStencilByName(BSTR szStencil) throw()
	{
		ATLASSERT(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveStencilByName(CW2A(szStencil));
	}


	HRESULT RemoveAllStencils() throw()
	{
		ATLASSERT(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveAllStencils();		
	}

	// we show lifespan in milli-seconds in the UI so we have to
	// do the conversion to 100ns intervals here.
	HRESULT SetDefaultLifespan(unsigned __int64 dwdwLifespan) throw()
	{
		ATLASSERT(m_spStencilCacheControl);
		// convert to 100ns intervals
		return m_spStencilCacheControl->SetDefaultLifespan(dwdwLifespan * CFileTime::Millisecond);
	}

	HRESULT GetDefaultLifespan(unsigned __int64 *pdwdwLifespan) throw()
	{
		ATLASSERT(m_spStencilCacheControl);
		*pdwdwLifespan = 0;
		unsigned __int64 dwls = 0;
		HRESULT hr = m_spStencilCacheControl->GetDefaultLifespan(&dwls);

		// convert to milli seconds
		if (SUCCEEDED(hr))
		{
			dwls /= CFileTime::Millisecond;
			*pdwdwLifespan = dwls;
		}
			
		return hr;
	}

	HTTP_CODE Initialize(IServiceProvider *pProvider) throw()
	{

		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);


		if (m_spMemCacheStats && m_spStencilCacheControl)
			return HTTP_SUCCESS; // already initialized

		CComPtr<IStencilCache> spStencilCache;
		pProvider->QueryService(__uuidof(IStencilCache), &spStencilCache);
		if (spStencilCache)
		{
			if (!m_spMemCacheStats)
			{
				spStencilCache->QueryInterface(__uuidof(IMemoryCacheStats), 
					(void**)&m_spMemCacheStats);
			}
			if (!m_spStencilCacheControl)
			{
				spStencilCache->QueryInterface(__uuidof(IStencilCacheControl),
					(void**)&m_spStencilCacheControl);
			}
		}

		return (m_spMemCacheStats && m_spStencilCacheControl)
			? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IMemoryCacheStats> m_spMemCacheStats;
	CComPtr<IStencilCacheControl> m_spStencilCacheControl;
};


#ifndef _ATL_STENCILCACHE_NOWEBSERVICE

[ uuid("3813895C-4C4C-41df-95F4-12220140B164"), object ]
__interface IStencilCacheMgr
{
	// data access
	[id(0)] STDMETHOD(GetCurrentEntryCount)([out,retval] __int64 *pdwSize);
	[id(1)] STDMETHOD(GetHitCount)([out,retval] __int64 *pdwSize);
	[id(2)] STDMETHOD(GetMissCount)([out,retval] __int64 *pdwSize);
	[id(3)] STDMETHOD(GetCurrentAllocSize)([out,retval] __int64 *pdwSize);
	[id(4)] STDMETHOD(GetMaxAllocSize)([out,retval] __int64 *pdwSize);
	[id(5)] STDMETHOD(GetMaxEntryCount)([out,retval] __int64 *pdwSize);
	[id(6)] STDMETHOD(GetDefaultLifespan)([out,retval] unsigned __int64 *pdwdwLifespan);

	// commands
	[id(7)] STDMETHOD(ClearStats)();
	[id(8)] STDMETHOD(RemoveStencil)([in] __int64 hStencil);
	[id(9)] STDMETHOD(RemoveStencilByName)([in] BSTR szStencil);
	[id(10)] STDMETHOD(RemoveAllStencils)();
	[id(11)] STDMETHOD(SetDefaultLifespan)([in] unsigned __int64 dwdwLifespan);
};

#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(	name=		ID_STENCILCACHEMGR_WEBSERVICE_NAME, 
					namespace=	ID_STENCILCACHEMGR_WEBSERVICE_URL,
					protocol=	"soap"
				),
	request_handler(
					name=		ID_STENCILCACHEMGR_WEBSERVICE_NAME,
					sdl=		ID_STENCILCACHEMGR_WEBSERVICE_WSDL )
]
class CStencilCacheManager :
	public IStencilCacheMgr
{
#pragma warning(pop)
public:
	[ soap_method ]
	STDMETHOD(GetCurrentEntryCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetCurrentEntryCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(ClearStats)()
	{
		return m_MgrObj.ClearStats();		
	}

	[ soap_method ]
	STDMETHOD(GetHitCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetHitCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMissCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMissCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetCurrentAllocSize)(__int64 *pdwSize)
	{
		return m_MgrObj.GetCurrentAllocSize(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMaxAllocSize)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMaxAllocSize(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMaxEntryCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMaxEntryCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(RemoveStencil)(__int64 hStencil)
	{
		return m_MgrObj.RemoveStencil(hStencil);		
	}

	[ soap_method ]
	STDMETHOD(RemoveStencilByName)(BSTR bstrStencil)
	{
		return m_MgrObj.RemoveStencilByName(bstrStencil);
	}

	[ soap_method ]
	STDMETHOD(RemoveAllStencils)()
	{
		return m_MgrObj.RemoveAllStencils();		
	}

	// we show lifespan in milli-seconds in the UI so we have to
	// do the conversion to 100ns intervals here.
	[ soap_method ]
	STDMETHOD(SetDefaultLifespan)(unsigned __int64 dwdwLifespan)
	{
		return m_MgrObj.SetDefaultLifespan(dwdwLifespan * CFileTime::Millisecond);
	}

	[ soap_method ]
	STDMETHOD(GetDefaultLifespan)(unsigned __int64 *pdwdwLifespan)
	{
		return m_MgrObj.GetDefaultLifespan(pdwdwLifespan);
	}

	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_MgrObj.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}
private:
	CStencilCacheMgrObject m_MgrObj;
};
#endif //_ATL_STENCILCACHE_NOWEBSERVICE
#ifndef _ATL_STENCILCACHE_NOUI
typedef HRESULT (CStencilCacheMgrObject::*PFNGETDATA)(__int64 *pdwSize);

struct CCache_data
{
	PFNGETDATA m_pfn;
	char m_sz[128];
};

#define INVALID_DATA_PTR ((DWORD_PTR) -1)
#define INVALID_COMMAND_ID -1
#define MAX_COMMAND_ID 64
#define ATL_STENCILCACHECMD_CLEARALLSTATS		0
#define ATL_STENCILCACHECMD_REMOVESTENCIL		1
#define ATL_STENCILCACHECMD_REMOVEALLSTENCILS	2
#define ATL_STENCILCACHECMD_SETDEFLIFESPAN		3

[request_handler(name=ID_STENCILCACHEMGR_SRFHANDLER_NAME)]
class CStencilMgr
{
public:
	CStencilMgr()
	{
		m_pData = (CCache_data*)INVALID_DATA_PTR;
		m_nColor = ATL_COLOR_TR1;
	}

	HTTP_CODE ValidateAndExchange() throw()
	{
		_ATLTRY
		{
			HTTP_CODE hcErr = m_MgrObj.Initialize(m_spServiceProvider);
			if (hcErr != HTTP_SUCCESS)
					return hcErr;

__if_exists(_Authority)
{
				// Make sure caller is authorized on this system
				hcErr = HTTP_FAIL;
				ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
				if (hcErr != HTTP_SUCCESS)
					return hcErr;
}
			hcErr = LoadStencilResource(m_hInstHandler, IDR_STENCILMGR_SRF);
			if (hcErr)
				return hcErr;

			m_HttpResponse.SetContentType("text/html");

			// check to see if we have a "Handler" form variable
			CString strHandler, strOptParam;
			int nCmdToExec;

			DWORD dwErr = m_HttpRequest.QueryParams.Exchange("Method", &strHandler);
			if (dwErr != VALIDATION_S_OK)
				return HTTP_SUCCESS; // nothing to do.

			if (strHandler != _T("ExecuteCommand"))
				return HTTP_SUCCESS; // Wrong handler was passed

			// get the value of the command parameter so we can execute it
			dwErr = m_HttpRequest.QueryParams.Validate("command", &nCmdToExec, 0, MAX_COMMAND_ID);
			if (dwErr != VALIDATION_S_OK)
				return HTTP_SUCCESS; // Wrong command id, nothing to do.

			// get the optional parameter if it's there.
			m_HttpRequest.QueryParams.Validate("DynValue", &strOptParam, 0, MAX_COMMAND_ID);

			hcErr = ExecCommand(nCmdToExec, strOptParam);
			return hcErr;
		}
		_ATLCATCHALL()
		{
			return HTTP_FAIL;
		}
	}

	HTTP_CODE ExecCommand(int nCmdToExec, CString& strOptParam)
	{
		switch (nCmdToExec)
		{
		case ATL_STENCILCACHECMD_CLEARALLSTATS:
			m_MgrObj.ClearStats();
		break;

		case ATL_STENCILCACHECMD_REMOVESTENCIL:
			m_MgrObj.RemoveStencilByName(strOptParam.AllocSysString());
		break;

		case ATL_STENCILCACHECMD_REMOVEALLSTENCILS:
			m_MgrObj.RemoveAllStencils();
		break;

		case ATL_STENCILCACHECMD_SETDEFLIFESPAN:
			TCHAR *pStop = NULL;
			m_MgrObj.SetDefaultLifespan(_tcstoul(strOptParam, &pStop, 10));
		break;
		};

		return _AtlRedirectToPage(
									m_spServerContext,
									m_HttpRequest,
									m_HttpResponse,
									"?Handler=" ID_STENCILCACHEMGR_SRFHANDLER_NAME
								 );

	}

	[tag_name("GetNextStencilCacheStats")]
	HTTP_CODE GetNextStencilCacheStats()
	{
		if (m_pData == (CCache_data*)INVALID_DATA_PTR)
		{
			m_pData = GetCacheData();
			return HTTP_SUCCESS;
		}
		m_pData++;

		if (m_pData->m_pfn != NULL)
			return HTTP_SUCCESS;

		m_pData = (CCache_data*)INVALID_DATA_PTR;
		return HTTP_S_FALSE;

	}

	[tag_name("GetCacheValue")]
	HTTP_CODE GetCacheValue()
	{
		ATLASSERT(m_pData);
		ATLASSERT(m_pData != (CCache_data*)INVALID_DATA_PTR);
		m_HttpResponse << m_pData->m_sz;
		return HTTP_SUCCESS;
	}

	[tag_name("GetCacheQuantity")]
	HTTP_CODE GetCacheQuantity()
	{
		ATLASSERT(m_pData);
		ATLASSERT(m_pData != (CCache_data*)INVALID_DATA_PTR);
		__int64 dwValue = 0;
		PFNGETDATA pfn = m_pData->m_pfn;
		CStencilCacheMgrObject *pMgr = &m_MgrObj;
		(pMgr->*pfn)(&dwValue);

		m_HttpResponse << dwValue;
		return HTTP_SUCCESS;
	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;
	
		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}
private:
	static CCache_data* GetCacheData()
	{
		static CCache_data cache_data[] = 
		{
			{(PFNGETDATA)&CStencilCacheMgrObject::GetCurrentEntryCount, "Current Cache Entry Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetHitCount, "Cache Hit Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMissCount, "Cache Miss Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetCurrentAllocSize, "Cache memory allocation(bytes)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMaxAllocSize, "Cache maximum allocation size(bytes)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMaxEntryCount, "Cache maximum entry count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetDefaultLifespan, "Default stencil lifespan(ms)"},
			{NULL, NULL}
		};
		return cache_data;
	}

	CStencilCacheMgrObject m_MgrObj;
	CCache_data *m_pData;
	long m_nColor;
};
//__declspec(selectany) CComObjectGlobal<CStencilCacheManager> CStencilMgr::m_cachemgr;
#endif // _ATL_STENCILCACHE_NOUI
#endif // _ATL_STENCILCACHE_MANAGEMENT

//////////////////////////////////////////////////////////////////////
// DLL cache management
#ifdef _ATL_DLLCACHE_MANAGEMENT


#ifndef _ATL_DLLCACHE_NOWEBSERVICE
[export]
#endif
struct _DLL_CACHE_ENTRY
{
	DWORD hInstDll;
	DWORD dwRefs;
	BSTR szDllName;
};


class CDllMgrObject
{
public:
	HRESULT GetEntries(DWORD dwCount, _DLL_CACHE_ENTRY *pEntries, DWORD *pdwCopied)
	{
		ATLASSERT(m_spDllCache);
		HRESULT hr = E_FAIL;
		if (!m_spDllCache)
			return E_UNEXPECTED;

		// assume there will never be enough entries in the dll cache
		// to overflow the stack
		DLL_CACHE_ENTRY *pe= new DLL_CACHE_ENTRY[dwCount];
		if (!pe)
			return E_OUTOFMEMORY;

		hr = m_spDllCache->GetEntries(dwCount, pe, pdwCopied);
		if (hr == S_OK && *pdwCopied != 0)
		{
			// SysAllocString our path strings
			for (DWORD i = 0; i<*pdwCopied; i++)
			{
				pEntries[i].hInstDll = (DWORD)(DWORD_PTR)pe[i].hInstDll;
				pEntries[i].dwRefs = pe[i].dwRefs;
				pEntries[i].szDllName = ::SysAllocString(CA2W(pe[i].szDllName));
			}
		}

		delete [] pe;
		return hr;
	}


	HRESULT GetEntryCount(DWORD *pdwCount)
	{
		ATLASSERT(m_spDllCache);
		if (!m_spDllCache)
			return E_UNEXPECTED;

		return m_spDllCache->GetEntries(0, NULL, pdwCount);
	}

	HTTP_CODE Initialize(IServiceProvider *pProvider)
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spDllCache)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(IDllCache), &m_spDllCache);
		return m_spDllCache ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IDllCache> m_spDllCache;

}; // CDllMgrObject


#ifndef _ATL_DLLCACHE_NOWEBSERVICE
// _DLL_CACHE_ENTRY is our own version of DLL_CACHE_ENTRY(atlcache.h) that
// uses a BSTR instead of a fixed length string for the szDllName for compatiblility
// with our SOAP implementation.
[ uuid("A0C00AF8-CEA5-46b9-97ED-FDEE55B583EF"), object ]
__interface IDllCacheMgr
{
	[id(0)] STDMETHOD(GetEntries)([in] DWORD dwCount, [out] _DLL_CACHE_ENTRY *pEntries, [out, retval] DWORD *pdwCopied);
	[id(1)] STDMETHOD(GetEntryCount)([out, retval] DWORD *pdwCount);

};


#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(
					name=		ID_DLLCACHEMGR_WEBSERVICE_NAME, 
					namespace=	ID_DLLCACHEMGR_WEBSERVICE_URL,
					protocol=	"soap"
				),
	request_handler(
					name=		ID_DLLCACHEMGR_WEBSERVICE_NAME,
					sdl=		ID_DLLCACHEMGR_WEBSERVICE_WSDL
					)
]
class CDllCacheManager :
	public IDllCacheMgr
{
#pragma warning(pop)
public:
	[soap_method]
	HRESULT GetEntries(DWORD dwCount, _DLL_CACHE_ENTRY *pEntries, DWORD *pdwCopied)
	{
		return m_MgrObj.GetEntries(dwCount, pEntries, pdwCopied);
	}

	[soap_method]
	STDMETHOD(GetEntryCount)(DWORD *pdwCount)
	{
		return m_MgrObj.GetEntries(0, NULL, pdwCount);
	}

	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_MgrObj.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}

protected:
	CDllMgrObject m_MgrObj;
};
#endif _ATL_DLLCACHE_NOWEBSERVICE

#ifndef _ATL_DLLCACHE_NOUI
#define INVALID_INDEX -1

[
	request_handler(name=ID_DLLCACHEMGR_SRFHANDLER_NAME)
]
class CDllCacheMgr
{
public:
	CDllCacheMgr() : m_nColor(ATL_COLOR_TR1),
		m_nEnumCount(INVALID_INDEX),
		m_nEnumIndex(INVALID_INDEX),
		m_pEntries(NULL)
	{

	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;
		
		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}


	[tag_name("GetNumEntries")]
	HTTP_CODE GetNumEntries()
	{
		DWORD dwEntries = 0;
		m_MgrObj.GetEntryCount(&dwEntries);
		m_HttpResponse << dwEntries;
		return HTTP_SUCCESS;
	}


	[tag_name("EnumEntries")]
	HTTP_CODE EnumEntries()
	{
		// we lock the cache while we enum entries so no entries
		// will be removed during the enumeration request.
		if (m_nEnumIndex == INVALID_INDEX)
		{
			// set up for the iteration
			m_MgrObj.GetEntryCount((DWORD*)&m_nEnumCount);
			if (!m_nEnumCount)
				return HTTP_S_FALSE; // nothing to enum

			m_pEntries = new _DLL_CACHE_ENTRY[m_nEnumCount];
			if (!m_pEntries)
				return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

			DWORD dwFetched = INVALID_INDEX;

			if (S_OK != m_MgrObj.GetEntries(m_nEnumCount, m_pEntries, &dwFetched))
				return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

			m_nEnumIndex = 0;
			return HTTP_SUCCESS;
		}

		m_nEnumIndex++;
		if (m_nEnumIndex < m_nEnumCount)
			return HTTP_SUCCESS; // continue iterating

		else
		{
			// done, clean up
			for (int i = 0; i< m_nEnumCount; i++)
			{
				::SysFreeString(m_pEntries[i].szDllName);
			}
			delete [] m_pEntries;
			m_pEntries = NULL;
			m_nEnumCount = INVALID_INDEX;
			m_nEnumIndex = INVALID_INDEX;
			return HTTP_S_FALSE; // terminate iterations.
		}
	}

	[tag_name("GetDllName")]
	HTTP_CODE GetDllName()
	{
		m_HttpResponse << m_pEntries[m_nEnumIndex].szDllName;
		return HTTP_SUCCESS;
	}

	[tag_name("GetDllReferences")]
	HTTP_CODE GetDllReferences()
	{
		m_HttpResponse << m_pEntries[m_nEnumIndex].dwRefs;
		return HTTP_SUCCESS;
	}

	HTTP_CODE ValidateAndExchange()
	{

		HTTP_CODE hcErr = m_MgrObj.Initialize(m_spServiceProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
		if (hcErr != HTTP_SUCCESS)
			return hcErr;
}
		hcErr = LoadStencilResource(m_hInstHandler, IDR_DLLMGR_SRF);
		m_HttpResponse.SetContentType("text/html");
		return hcErr;

	}

	CDllMgrObject m_MgrObj;
	long m_nColor;
	int m_nEnumCount;
	int m_nEnumIndex;
	_DLL_CACHE_ENTRY *m_pEntries;

};

#endif // _ATL_DLLCACHE_NOUI
#endif // _ATL_DLLCACHE_MANAGEMENT

}; // ATL
#pragma warning(pop)
#endif // __ATLEXTMGMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlhost.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHOST_H__
#define __ATLHOST_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <urlmon.h>
#include <mshtml.h>
#include <mshtmhst.h>
#include <exdisp.h>

#ifndef _ATL_AXHOST
#define _ATL_AXHOST
#endif //_ATL_AXHOST

#include <atlwin.h>
#include <atlcom.h>

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _ATL_NO_HOSTING
	#error atlhost.h requires Hosting support (_ATL_NO_HOSTING is defined)
#endif //_ATL_NO_HOSTING

namespace ATL
{
//AtlAxWinTerm is not exported
inline BOOL AtlAxWinTerm()
{
#ifndef _ATL_DLL //don't unregister DLL's version
	UnregisterClass(CAxWindow::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
	UnregisterClass(CAxWindow2::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
#endif
	return TRUE;
}


// Define this to host SHDOCVW rather than MSHTML
#define SHDOCVW

UINT __declspec(selectany) WM_ATLGETHOST = 0;
UINT __declspec(selectany) WM_ATLGETCONTROL = 0;

typedef HRESULT (__stdcall *typeMkParseDisplayName)(IBindCtx*, LPCWSTR , ULONG*, LPMONIKER*);

static HRESULT CreateNormalizedObject(LPCOLESTR lpszTricsData, REFIID riid, void** ppvObj, bool& bWasHTML, BSTR bstrLicKey)
{
	ATLASSERT(ppvObj);
	if (ppvObj == NULL)
		return E_POINTER;
	*ppvObj = NULL;

	CLSID clsid;
	HRESULT hr = E_FAIL;

	bWasHTML = false;


	if (lpszTricsData == NULL || lpszTricsData[0] == 0)
		return S_OK;

	// Is it HTML ?
	USES_CONVERSION;
	if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
		(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
		(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
		(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
		(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
		(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
		(lpszTricsData[6] == OLECHAR(':')))
	{
		// It's HTML, so let's create mshtml
		hr = CoCreateInstance(__uuidof(HTMLDocument), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
		bWasHTML = true;
	}
	// Is it a URL?
	else if (CAtlModule::FindOneOf(OLE2CT(lpszTricsData), _T(":")))
	{
		// URL so let's create shdocvw
		hr = CoCreateInstance(__uuidof(WebBrowser), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
		bWasHTML = true;
	}
	// assume ProgID or CLSID
	else
	{
		// Can't be clsid, or progid if length is greater than 255
		if (ocslen(lpszTricsData) < 255)
		{
			if (lpszTricsData[0] == '{') // Is it a CLSID?
				hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
			else
				hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
		}
		if (SUCCEEDED(hr))
		{
			// If the license key is present
			// Create using IClassFactory2.
			if (bstrLicKey != NULL)
			{
				CComPtr<IClassFactory2> spClassFactory;
				hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, __uuidof(IClassFactory2), (void**)&spClassFactory);
				if (SUCCEEDED(hr))
					hr = spClassFactory->CreateInstanceLic(NULL, NULL, riid, bstrLicKey, ppvObj);
			}
			else
				hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
		}
	}
	return hr;
}


class ATL_NO_VTABLE CAxFrameWindow : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxFrameWindow>,
	public IOleInPlaceFrame
{
public:
	CAxFrameWindow()
	{
	}
	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxFrameWindow)

	BEGIN_COM_MAP(CAxFrameWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceFrame)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN Frame Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

// IOleInPlaceFrameWindow
	STDMETHOD(InsertMenus)(HMENU /*hmenuShared*/, LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetMenu)(HMENU /*hmenuShared*/, HOLEMENU /*holemenu*/, HWND /*hwndActiveObject*/)
	{
		return S_OK;
	}

	STDMETHOD(RemoveMenus)(HMENU /*hmenuShared*/)
	{
		return S_OK;
	}

	STDMETHOD(SetStatusText)(LPCOLESTR /*pszStatusText*/)
	{
		return S_OK;
	}

	STDMETHOD(EnableModeless)(BOOL /*fEnable*/)
	{
		return S_OK;
	}

	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, WORD /*wID*/)
	{
		return S_FALSE;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


class ATL_NO_VTABLE CAxUIWindow : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxUIWindow>,
	public IOleInPlaceUIWindow
{
public:
	CAxUIWindow()
	{
	}

	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxUIWindow)

	BEGIN_COM_MAP(CAxUIWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN UI Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}

	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


/////////////////////////////////////////////////////////////////////////////
// CAxHostWindow
// This class is not cocreateable

class ATL_NO_VTABLE CAxHostWindow : 
		public CComCoClass<CAxHostWindow , &CLSID_NULL>,
		public CComObjectRootEx<CComSingleThreadModel>,
		public CWindowImpl<CAxHostWindow>,
		public IAxWinHostWindowLic,
		public IOleClientSite,
		public IOleInPlaceSiteWindowless,
		public IOleControlSite,
		public IOleContainer,
		public IObjectWithSiteImpl<CAxHostWindow>,
		public IServiceProvider,
		public IAdviseSink,
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		public IDocHostUIHandler,
#endif
		public IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &LIBID_ATLLib>
{
public:
// ctor/dtor
	CAxHostWindow()
	{
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bMDIApp = FALSE;
		m_bWindowless = FALSE;
		m_bCapture = FALSE;
		m_bHaveFocus = FALSE;

		// Initialize ambient properties
		m_bCanWindowlessActivate = TRUE;
		m_bUserMode = TRUE;
		m_bDisplayAsDefault = FALSE;
		m_clrBackground = NULL;
		m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);
		m_lcidLocaleID = LOCALE_USER_DEFAULT;
		m_bMessageReflect = true;

		m_bReleaseAll = FALSE;

		m_bSubclassed = FALSE;

		m_dwAdviseSink = 0xCDCDCDCD;
		m_dwDocHostFlags = DOCHOSTUIFLAG_NO3DBORDER;
		m_dwDocHostDoubleClickFlags = DOCHOSTUIDBLCLK_DEFAULT;
		m_bAllowContextMenu = true;
		m_bAllowShowUI = false;
		m_hDCScreen = NULL;
		m_bDCReleased = true;

		m_hAccel = NULL;
	}

	~CAxHostWindow()
	{
	}
	void FinalRelease()
	{
		ReleaseAll();
	}

	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		GetControllingUnknown()->Release();
	}

	DECLARE_NO_REGISTRY()
	DECLARE_POLY_AGGREGATABLE(CAxHostWindow)
	DECLARE_GET_CONTROLLING_UNKNOWN()

	BEGIN_COM_MAP(CAxHostWindow)
		COM_INTERFACE_ENTRY2(IDispatch, IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinHostWindow)
		COM_INTERFACE_ENTRY(IAxWinHostWindowLic)
		COM_INTERFACE_ENTRY(IOleClientSite)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
		COM_INTERFACE_ENTRY(IOleInPlaceSite)
		COM_INTERFACE_ENTRY(IOleWindow)
		COM_INTERFACE_ENTRY(IOleControlSite)
		COM_INTERFACE_ENTRY(IOleContainer)
		COM_INTERFACE_ENTRY(IObjectWithSite)
		COM_INTERFACE_ENTRY(IServiceProvider)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatch)
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		COM_INTERFACE_ENTRY(IDocHostUIHandler)
#endif
		COM_INTERFACE_ENTRY(IAdviseSink)
	END_COM_MAP()

	static CWndClassInfo& GetWndClassInfo()
	{
		static CWndClassInfo wc =
		{
			{ sizeof(WNDCLASSEX), 0, StartWindowProc,
			  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T(ATLAXWIN_CLASS), 0 },
			NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
		};
		return wc;
	}

	BEGIN_MSG_MAP(CAxHostWindow)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
		if (m_bWindowless)
		{
			// Mouse messages handled when a windowless control has captured the cursor
			// or if the cursor is over the control
			DWORD dwHitResult = m_bCapture ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			if (dwHitResult == HITRESULT_OUTSIDE && m_spViewObject != NULL)
			{
				POINT ptMouse = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
				m_spViewObject->QueryHitPoint(DVASPECT_CONTENT, &m_rcPos, ptMouse, 0, &dwHitResult);
			}
			if (dwHitResult == HITRESULT_HIT)
			{
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_SETCURSOR, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowlessMouseMessage)
			}
		}
		if (m_bWindowless & m_bHaveFocus)
		{
			// Keyboard messages handled only when a windowless control has the focus
			MESSAGE_HANDLER(WM_KEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_KEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_DEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSDEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_HELP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CANCELMODE, OnWindowMessage)
			MESSAGE_HANDLER(WM_IME_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowMessage)
			MESSAGE_RANGE_HANDLER(WM_IME_SETCONTEXT, WM_IME_KEYUP, OnWindowMessage)
		}
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		if (m_bMessageReflect)
		{
			bHandled = TRUE;
			lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
			if(bHandled)
				return TRUE;
		}
		MESSAGE_HANDLER(WM_ATLGETHOST, OnGetUnknown)
		MESSAGE_HANDLER(WM_ATLGETCONTROL, OnGetControl)
		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	END_MSG_MAP()

	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		ATLASSERT(lParam != 0);
		LPMSG lpMsg = (LPMSG)lParam;
		CComQIPtr<IOleInPlaceActiveObject, &__uuidof(IOleInPlaceActiveObject)> spInPlaceActiveObject(m_spUnknown);
		if(spInPlaceActiveObject)
		{
			if(spInPlaceActiveObject->TranslateAccelerator(lpMsg) == S_OK)
				return 1;
		}
		return 0;
	}

	LRESULT OnGetUnknown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		IUnknown* pUnk = GetControllingUnknown();
		pUnk->AddRef();
		return (LRESULT)pUnk;
	}
	LRESULT OnGetControl(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		IUnknown* pUnk = m_spUnknown;
		if (pUnk)
			pUnk->AddRef();
		return (LRESULT)pUnk;
	}

	void ReleaseAll()
	{
		if (m_bReleaseAll)
			return;
		m_bReleaseAll = TRUE;

		if (m_spViewObject != NULL)
			m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

		if(m_dwAdviseSink != 0xCDCDCDCD)
		{
			AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
			m_dwAdviseSink = 0xCDCDCDCD;
		}

		if (m_spOleObject)
		{
			m_spOleObject->Unadvise(m_dwOleObject);
			m_spOleObject->Close(OLECLOSE_NOSAVE);
			m_spOleObject->SetClientSite(NULL);
		}

		if (m_spUnknown != NULL)
		{
			CComPtr<IObjectWithSite> spSite;
			m_spUnknown->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
			if (spSite != NULL)
				spSite->SetSite(NULL);
		}

		m_spViewObject.Release();
		m_dwViewObjectType = 0;

		m_spInPlaceObjectWindowless.Release();
		m_spOleObject.Release();
		m_spUnknown.Release();

		m_spInPlaceUIWindow.Release();
		m_spInPlaceFrame.Release();

		m_bInPlaceActive = FALSE;
		m_bWindowless = FALSE;
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bCapture = FALSE;
		m_bReleaseAll = FALSE;

		if (m_hAccel != NULL)
		{
			DestroyAcceleratorTable(m_hAccel);
			m_hAccel = NULL;
		}
	}


// window message handlers
	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if (m_spViewObject == NULL)
			bHandled = false;

		return 1;
	}

	LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		if (m_dwMiscStatus & OLEMISC_NOUIACTIVATE)
		{
			if (m_spOleObject != NULL && !m_bInPlaceActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
		}
		else
		{
			BOOL b;
			OnSetFocus(0, 0, 0, b);
		}
		return 0;
	}
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_bHaveFocus = TRUE;
		if (!m_bReleaseAll)
		{
			if (m_spOleObject != NULL && !m_bUIActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
			if (m_bWindowless)
				::SetFocus(m_hWnd);
			else if(!IsChild(::GetFocus()))
				::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_bHaveFocus = FALSE;
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		int nWidth = GET_X_LPARAM(lParam);  // width of client area
		int nHeight = GET_Y_LPARAM(lParam); // height of client area

		m_rcPos.right = m_rcPos.left + nWidth;
		m_rcPos.bottom = m_rcPos.top + nHeight;
		m_pxSize.cx = m_rcPos.right - m_rcPos.left;
		m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
		AtlPixelToHiMetric(&m_pxSize, &m_hmSize);

		if (m_spOleObject)
			m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		if (m_bWindowless)
			InvalidateRect(NULL, TRUE);
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		GetControllingUnknown()->AddRef();
		DefWindowProc(uMsg, wParam, lParam);
		ReleaseAll();
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		LRESULT lRes = 0;
		HRESULT hr = S_FALSE;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			hr = m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		if (hr == S_FALSE)
			bHandled = FALSE;
		return lRes;
	}
	LRESULT OnWindowlessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		LRESULT lRes = 0;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		bHandled = FALSE;
		return lRes;
	}
	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if (m_spViewObject == NULL)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);
			if (hdc == NULL)
				return 0;
			RECT rcClient;
			GetClientRect(&rcClient);
			HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
			if (hbrBack != NULL)
			{
				FillRect(hdc, &rcClient, hbrBack);
				DeleteObject(hbrBack);
			}
			::EndPaint(m_hWnd, &ps);
			return 1;
		}
		if (m_spViewObject && m_bWindowless)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);

			if (hdc == NULL)
				return 0;

			RECT rcClient;
			GetClientRect(&rcClient);

			HBITMAP hBitmap = CreateCompatibleBitmap(hdc, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
			if (hBitmap != NULL)
			{
				HDC hdcCompatible = ::CreateCompatibleDC(hdc);
				if (hdcCompatible != NULL)
				{
					HBITMAP hBitmapOld = (HBITMAP)SelectObject(hdcCompatible, hBitmap); 
					if (hBitmapOld != NULL)
					{
						HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
						if (hbrBack != NULL)
						{
							FillRect(hdcCompatible, &rcClient, hbrBack);
							DeleteObject(hbrBack);

							m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 

							::BitBlt(hdc, 0, 0, rcClient.right, rcClient.bottom,  hdcCompatible, 0, 0, SRCCOPY);
						}
						::SelectObject(hdcCompatible, hBitmapOld); 
					}
					::DeleteDC(hdcCompatible);
				}
				::DeleteObject(hBitmap);
			}
			::EndPaint(m_hWnd, &ps);
		}
		else
		{
			bHandled = FALSE;
			return 0;
		}
		return 1;
	}

// IAxWinHostWindow
	STDMETHOD(CreateControl)(LPCOLESTR lpTricsData, HWND hWnd, IStream* pStream)
	{
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, NULL);
	}
	STDMETHOD(CreateControlEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink)
	{
		return CreateControlLicEx(lpszTricsData, hWnd, pStream, ppUnk, iidAdvise, punkSink, NULL);
	}
	STDMETHOD(AttachControl)(IUnknown* pUnkControl, HWND hWnd)
	{
		HRESULT hr = S_FALSE;

		ReleaseAll();

		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}

			hr = ActivateAx(pUnkControl, true, NULL);

			if (FAILED(hr))
			{
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
					if (bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
						ReleaseWindow();
				}
			}
		}
		return hr;
	}
	STDMETHOD(QueryControl)(REFIID riid, void** ppvObject)
	{
		HRESULT hr = E_POINTER;
		if (ppvObject)
		{
			if (m_spUnknown)
			{
				hr = m_spUnknown->QueryInterface(riid, ppvObject);
			}
			else
			{
				*ppvObject = NULL;
				hr = OLE_E_NOCONNECTION;
			}
		}
		return hr;
	}
	STDMETHOD(SetExternalDispatch)(IDispatch* pDisp)
	{
		m_spExternalDispatch = pDisp;
		return S_OK;
	}
	STDMETHOD(SetExternalUIHandler)(IDocHostUIHandlerDispatch* pUIHandler)
	{
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		m_spIDocHostUIHandlerDispatch = pUIHandler;
#endif
		return S_OK;
	}

	STDMETHOD(CreateControlLic)(LPCOLESTR lpTricsData, HWND hWnd, IStream* pStream, BSTR bstrLic)
	{
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, bstrLic);
	}
	STDMETHOD(CreateControlLicEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink, BSTR bstrLic)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hr = S_FALSE;
		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		ReleaseAll();

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			USES_CONVERSION;
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}
			if (m_clrBackground == NULL)
			{
				if (IsParentDialog())
					m_clrBackground = GetSysColor(COLOR_BTNFACE);
				else
					m_clrBackground = GetSysColor(COLOR_WINDOW);
			}

			bool bWasHTML = false;

			hr = CreateNormalizedObject(lpszTricsData, __uuidof(IUnknown), (void**)ppUnk, bWasHTML, bstrLic);

			if (SUCCEEDED(hr))
				hr = ActivateAx(*ppUnk, false, pStream);

			// Try to hook up any sink the user might have given us.
			m_iidSink = iidAdvise;
			if(SUCCEEDED(hr) && *ppUnk && punkSink)
				AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);

			if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
			{
				if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
					m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
				else
				{
					DWORD dwStyle = GetStyle();
					SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
					SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
				}

				CComPtr<IUnknown> spUnk(*ppUnk);
				// Is it just plain HTML?
				USES_CONVERSION;
				if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
					(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
					(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
					(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
					(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
					(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
					(lpszTricsData[6] == OLECHAR(':')))
				{
					// Just HTML: load the HTML data into the document

					UINT nCreateSize = (ocslen(lpszTricsData) - 7) * sizeof(OLECHAR);
					HGLOBAL hGlobal = GlobalAlloc(GHND, nCreateSize);
					if (hGlobal)
					{
						CComPtr<IStream> spStream;
						BYTE* pBytes = (BYTE*) GlobalLock(hGlobal);
						memcpy(pBytes, lpszTricsData + 7, nCreateSize);
						GlobalUnlock(hGlobal);
						hr = CreateStreamOnHGlobal(hGlobal, TRUE, &spStream);
						if (SUCCEEDED(hr))
						{
							CComPtr<IPersistStreamInit> spPSI;
							hr = spUnk->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spPSI);
							if (SUCCEEDED(hr))
								hr = spPSI->Load(spStream);
						}
					}
					else
						hr = E_OUTOFMEMORY;
				}
				else
				{
					CComPtr<IWebBrowser2> spBrowser;
					spUnk->QueryInterface(__uuidof(IWebBrowser2), (void**)&spBrowser);
					if (spBrowser)
					{
						CComVariant ve;
						CComVariant vurl(lpszTricsData);
						spBrowser->put_Visible(ATL_VARIANT_TRUE);
						spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
					}
				}

			}
			if (FAILED(hr) || m_spUnknown == NULL)
			{
				// We don't have a control or something failed so release
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
					if (FAILED(hr) && bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
						ReleaseWindow();
				}
			}
		}
		return hr;
	}



#ifndef _ATL_NO_DOCHOSTUIHANDLER
// IDocHostUIHandler
	// MSHTML requests to display its context menu
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit)
	{
		HRESULT hr = m_bAllowContextMenu ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowContextMenu(
				dwID,
				pptPosition->x,
				pptPosition->y,
				pCommandTarget,
				pDispatchObjectHit,
				&hr);
		return hr;
	}
	// Called at initialisation to find UI styles from container
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo)
	{
		if (pInfo == NULL)
			return E_POINTER;

		if (m_spIDocHostUIHandlerDispatch != NULL)
			return m_spIDocHostUIHandlerDispatch->GetHostInfo(&pInfo->dwFlags, &pInfo->dwDoubleClick);

		pInfo->dwFlags = m_dwDocHostFlags;
		pInfo->dwDoubleClick = m_dwDocHostDoubleClickFlags;

		return S_OK;
	}
	// Allows the host to replace the IE4/MSHTML menus and toolbars. 
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc)
	{
		HRESULT hr = m_bAllowShowUI ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowUI(
				dwID,
				pActiveObject, 
				pCommandTarget, 
				pFrame, 
				pDoc,
				&hr);
		return hr;
	}
	// Called when IE4/MSHTML removes its menus and toolbars. 
	STDMETHOD(HideUI)()
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->HideUI();
		return hr;
	}
	// Notifies the host that the command state has changed. 
	STDMETHOD(UpdateUI)()
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->UpdateUI();
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::EnableModeless
	STDMETHOD(EnableModeless)(BOOL fEnable)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->EnableModeless(fEnable ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnDocWindowActivate
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnDocWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnFrameWindowActivate. 
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnFrameWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::ResizeBorder.
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->ResizeBorder(
				prcBorder->left,
				prcBorder->top,
				prcBorder->right,
				prcBorder->bottom,
				pUIWindow,
				fFrameWindow ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called by IE4/MSHTML when IOleInPlaceActiveObject::TranslateAccelerator or IOleControlSite::TranslateAccelerator is called. 
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
	{
		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->TranslateAccelerator(
				(DWORD_PTR) lpMsg->hwnd,
				lpMsg->message,
				lpMsg->wParam,
				lpMsg->lParam,
				CComBSTR(*pguidCmdGroup), 
				nCmdID,
				&hr);
		return hr;
	}
	// Returns the registry key under which IE4/MSHTML stores user preferences. 
	// Returns S_OK if successful, or S_FALSE otherwise. If S_FALSE, IE4/MSHTML will default to its own user options.
	STDMETHOD(GetOptionKeyPath)(LPOLESTR* pchKey, DWORD dwReserved)
	{
		HRESULT hr = S_FALSE;
		if (pchKey == NULL)
			return E_POINTER;
		*pchKey = NULL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetOptionKeyPath(pchKey, dwReserved);
			if (FAILED(hr) || *pchKey == NULL)
				hr = S_FALSE;
		}
		else
		{
			if (m_bstrOptionKeyPath.m_str != NULL)
			{
				UINT nByteLength = m_bstrOptionKeyPath.ByteLength();
				LPOLESTR pStr = (LPOLESTR)CoTaskMemAlloc(nByteLength + sizeof(OLECHAR));
				if (pStr == NULL)
					return E_OUTOFMEMORY;
				ocscpy(pStr, m_bstrOptionKeyPath.m_str);
				*pchKey = pStr;
				hr = S_OK;
			}
		}
		return hr;
	}
	// Called by IE4/MSHTML when it is being used as a drop target to allow the host to supply an alternative IDropTarget
	STDMETHOD(GetDropTarget)(IDropTarget* pDropTarget, IDropTarget** ppDropTarget)
	{
		ATLASSERT(ppDropTarget != NULL);
		if (ppDropTarget == NULL)
			return E_POINTER;
		*ppDropTarget = NULL;

		HRESULT hr = E_NOTIMPL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->GetDropTarget(pDropTarget, &spUnk);
			if (spUnk)
				hr = spUnk->QueryInterface(__uuidof(IDropTarget), (void**)ppDropTarget);
			if (FAILED(hr) || *ppDropTarget == NULL)
				hr = S_FALSE;
		}
		return hr;
	}
	// Called by IE4/MSHTML to obtain the host's IDispatch interface
	STDMETHOD(GetExternal)(IDispatch** ppDispatch)
	{
		ATLASSERT(ppDispatch != NULL);
		if (ppDispatch == NULL)
			return E_POINTER;
		*ppDispatch = NULL;

		HRESULT hr = E_NOINTERFACE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetExternal(ppDispatch);
			if (FAILED(hr) || *ppDispatch == NULL)
				hr = E_NOINTERFACE;
		}
		else
		{
			// return the IDispatch we have for extending the object Model
			if (ppDispatch != NULL)
			{
				m_spExternalDispatch.CopyTo(ppDispatch);
				hr = S_OK;
			}
			else
				hr = E_POINTER;
		}
		return hr;
	}
	// Called by IE4/MSHTML to allow the host an opportunity to modify the URL to be loaded
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
	{
		ATLASSERT(ppchURLOut != NULL);
		if (ppchURLOut == NULL)
			return E_POINTER;
		*ppchURLOut = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComBSTR bstrURLOut;
			hr = m_spIDocHostUIHandlerDispatch->TranslateUrl(dwTranslate, CComBSTR(pchURLIn), &bstrURLOut);
			if (SUCCEEDED(hr) && bstrURLOut.m_str != NULL)
			{
				UINT nLen = (bstrURLOut.Length() + 1) * 2;
				*ppchURLOut = (OLECHAR*) CoTaskMemAlloc(nLen);
				if (*ppchURLOut == NULL)
					return E_OUTOFMEMORY;
				memcpy(*ppchURLOut, bstrURLOut.m_str, nLen);
			}
			else
				hr = S_FALSE;
		}
		return hr;
	}
	// Called on the host by IE4/MSHTML to allow the host to replace IE4/MSHTML's data object.
	// This allows the host to block certain clipboard formats or support additional clipboard formats. 
	STDMETHOD(FilterDataObject)(IDataObject* pDO, IDataObject** ppDORet)
	{
		ATLASSERT(ppDORet != NULL);
		if (ppDORet == NULL)
			return E_POINTER;
		*ppDORet = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->FilterDataObject(pDO, &spUnk);
			if (spUnk)
				hr = QueryInterface(__uuidof(IDataObject), (void**)ppDORet);
			if (FAILED(hr) || *ppDORet == NULL)
				hr = S_FALSE;
		}
		return hr;
	}
#endif

	HRESULT FireAmbientPropertyChange(DISPID dispChanged)
	{
		HRESULT hr = S_OK;
		CComQIPtr<IOleControl, &__uuidof(IOleControl)> spOleControl(m_spUnknown);
		if (spOleControl != NULL)
			hr = spOleControl->OnAmbientPropertyChange(dispChanged);
		return hr;
	}

// IAxWinAmbientDispatch

	CComPtr<IDispatch> m_spAmbientDispatch;

	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
	{
		HRESULT hr = IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &LIBID_ATLLib>::Invoke
			(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
		if ((hr == DISP_E_MEMBERNOTFOUND || hr == TYPE_E_ELEMENTNOTFOUND) && m_spAmbientDispatch != NULL)
		{
			hr = m_spAmbientDispatch->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
			if (SUCCEEDED(hr) && (wFlags & DISPATCH_PROPERTYPUT) != 0)
			{
				hr = FireAmbientPropertyChange(dispIdMember);
			}
		}
		return hr;
	}

	STDMETHOD(put_AllowWindowlessActivation)(VARIANT_BOOL bAllowWindowless)
	{
		m_bCanWindowlessActivate = bAllowWindowless;
		return S_OK;
	}
	STDMETHOD(get_AllowWindowlessActivation)(VARIANT_BOOL* pbAllowWindowless)
	{
		ATLASSERT(pbAllowWindowless != NULL);
		if (pbAllowWindowless == NULL)
			return E_POINTER;

		*pbAllowWindowless = m_bCanWindowlessActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_BackColor)(OLE_COLOR clrBackground)
	{
		m_clrBackground = clrBackground;
		FireAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
		InvalidateRect(0, FALSE);
		return S_OK;
	}
	STDMETHOD(get_BackColor)(OLE_COLOR* pclrBackground)
	{
		ATLASSERT(pclrBackground != NULL);
		if (pclrBackground == NULL)
			return E_POINTER;

		*pclrBackground = m_clrBackground;
		return S_OK;
	}
	STDMETHOD(put_ForeColor)(OLE_COLOR clrForeground)
	{
		m_clrForeground = clrForeground;
		FireAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
		return S_OK;
	}
	STDMETHOD(get_ForeColor)(OLE_COLOR* pclrForeground)
	{
		ATLASSERT(pclrForeground != NULL);
		if (pclrForeground == NULL)
			return E_POINTER;

		*pclrForeground = m_clrForeground;
		return S_OK;
	}
	STDMETHOD(put_LocaleID)(LCID lcidLocaleID)
	{
		m_lcidLocaleID = lcidLocaleID;
		FireAmbientPropertyChange(DISPID_AMBIENT_LOCALEID);
		return S_OK;
	}
	STDMETHOD(get_LocaleID)(LCID* plcidLocaleID)
	{
		ATLASSERT(plcidLocaleID != NULL);
		if (plcidLocaleID == NULL)
			return E_POINTER;

		*plcidLocaleID = m_lcidLocaleID;
		return S_OK;
	}
	STDMETHOD(put_UserMode)(VARIANT_BOOL bUserMode)
	{
		m_bUserMode = bUserMode;
		FireAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
		return S_OK;
	}
	STDMETHOD(get_UserMode)(VARIANT_BOOL* pbUserMode)
	{
		ATLASSERT(pbUserMode != NULL);
		if (pbUserMode == NULL)
			return E_POINTER;

		*pbUserMode = m_bUserMode ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DisplayAsDefault)(VARIANT_BOOL bDisplayAsDefault)
	{
		m_bDisplayAsDefault = bDisplayAsDefault;
		FireAmbientPropertyChange(DISPID_AMBIENT_DISPLAYASDEFAULT);
		return S_OK;
	}
	STDMETHOD(get_DisplayAsDefault)(VARIANT_BOOL* pbDisplayAsDefault)
	{
		ATLASSERT(pbDisplayAsDefault != NULL);
		if (pbDisplayAsDefault == NULL)
			return E_POINTER;

		*pbDisplayAsDefault = m_bDisplayAsDefault ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_Font)(IFontDisp* pFont)
	{
		m_spFont = pFont;
		FireAmbientPropertyChange(DISPID_AMBIENT_FONT);
		return S_OK;
	}
	STDMETHOD(get_Font)(IFontDisp** pFont)
	{
		ATLASSERT(pFont != NULL);
		if (pFont == NULL)
			return E_POINTER;
		*pFont = NULL;

		if (m_spFont == NULL)
		{
			USES_CONVERSION;
			HFONT hSystemFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
			if (hSystemFont == NULL)
				hSystemFont = (HFONT) GetStockObject(SYSTEM_FONT);
			if (hSystemFont == NULL)
				return AtlHresultFromLastError();
			LOGFONT logfont;
			GetObject(hSystemFont, sizeof(logfont), &logfont);
			FONTDESC fd;
			fd.cbSizeofstruct = sizeof(FONTDESC);
			fd.lpstrName = T2OLE(logfont.lfFaceName);
			fd.sWeight = (short)logfont.lfWeight;
			fd.sCharset = logfont.lfCharSet;
			fd.fItalic = logfont.lfItalic;
			fd.fUnderline = logfont.lfUnderline;
			fd.fStrikethrough = logfont.lfStrikeOut;

			long lfHeight = logfont.lfHeight;
			if (lfHeight < 0)
				lfHeight = -lfHeight;

			int ppi;
			HDC hdc;
			if (m_hWnd)
			{
				hdc = ::GetDC(m_hWnd);
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(m_hWnd, hdc);
			}
			else
			{
				hdc = ::GetDC(GetDesktopWindow());
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(GetDesktopWindow(), hdc);
			}
			fd.cySize.Lo = lfHeight * 720000 / ppi;
			fd.cySize.Hi = 0;

			OleCreateFontIndirect(&fd, __uuidof(IFontDisp), (void**) &m_spFont);
		}

		return m_spFont.CopyTo(pFont);
	}
	STDMETHOD(put_MessageReflect)(VARIANT_BOOL bMessageReflect)
	{
		m_bMessageReflect = bMessageReflect;
		FireAmbientPropertyChange(DISPID_AMBIENT_MESSAGEREFLECT);
		return S_OK;
	}
	STDMETHOD(get_MessageReflect)(VARIANT_BOOL* pbMessageReflect)
	{

		ATLASSERT(pbMessageReflect != NULL);
		if (pbMessageReflect == NULL)
			return E_POINTER;

		*pbMessageReflect = m_bMessageReflect ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowGrabHandles)(VARIANT_BOOL* pbShowGrabHandles)
	{
		*pbShowGrabHandles = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowHatching)(VARIANT_BOOL* pbShowHatching)
	{
		ATLASSERT(pbShowHatching != NULL);
		if (pbShowHatching == NULL)
			return E_POINTER;

		*pbShowHatching = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DocHostFlags)(DWORD dwDocHostFlags)
	{
		m_dwDocHostFlags = dwDocHostFlags;
		FireAmbientPropertyChange(DISPID_UNKNOWN);
		return S_OK;
	}
	STDMETHOD(get_DocHostFlags)(DWORD* pdwDocHostFlags)
	{
		ATLASSERT(pdwDocHostFlags != NULL);
		if (pdwDocHostFlags == NULL)
			return E_POINTER;

		*pdwDocHostFlags = m_dwDocHostFlags;
		return S_OK;
	}
	STDMETHOD(put_DocHostDoubleClickFlags)(DWORD dwDocHostDoubleClickFlags)
	{
		m_dwDocHostDoubleClickFlags = dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(get_DocHostDoubleClickFlags)(DWORD* pdwDocHostDoubleClickFlags)
	{
		ATLASSERT(pdwDocHostDoubleClickFlags != NULL);
		if (pdwDocHostDoubleClickFlags == NULL)
			return E_POINTER;

		*pdwDocHostDoubleClickFlags = m_dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(put_AllowContextMenu)(VARIANT_BOOL bAllowContextMenu)
	{
		m_bAllowContextMenu = bAllowContextMenu;
		return S_OK;
	}
	STDMETHOD(get_AllowContextMenu)(VARIANT_BOOL* pbAllowContextMenu)
	{
		ATLASSERT(pbAllowContextMenu != NULL);
		if (pbAllowContextMenu == NULL)
			return E_POINTER;

		*pbAllowContextMenu = m_bAllowContextMenu ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_AllowShowUI)(VARIANT_BOOL bAllowShowUI)
	{
		m_bAllowShowUI = bAllowShowUI;
		return S_OK;
	}
	STDMETHOD(get_AllowShowUI)(VARIANT_BOOL* pbAllowShowUI)
	{
		ATLASSERT(pbAllowShowUI != NULL);
		if (pbAllowShowUI == NULL)
			return E_POINTER;

		*pbAllowShowUI = m_bAllowShowUI ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_OptionKeyPath)(BSTR bstrOptionKeyPath)
	{
		m_bstrOptionKeyPath = bstrOptionKeyPath;;
		return S_OK;
	}
	STDMETHOD(get_OptionKeyPath)(BSTR* pbstrOptionKeyPath)
	{
		ATLASSERT(pbstrOptionKeyPath != NULL);
		if (pbstrOptionKeyPath == NULL)
			return E_POINTER;

		*pbstrOptionKeyPath = m_bstrOptionKeyPath;
		return S_OK;
	}

	STDMETHOD(SetAmbientDispatch)(IDispatch* pDispatch)
	{
		m_spAmbientDispatch = pDispatch;
		return S_OK;
	}

// IObjectWithSite
	STDMETHOD(SetSite)(IUnknown* pUnkSite)
	{
		HRESULT hr = IObjectWithSiteImpl<CAxHostWindow>::SetSite(pUnkSite);

		if (SUCCEEDED(hr) && m_spUnkSite)
		{
			// Look for "outer" IServiceProvider
			hr = m_spUnkSite->QueryInterface(__uuidof(IServiceProvider), (void**)&m_spServices);
			ATLASSERT( !hr && "No ServiceProvider!" );
		}

		if (pUnkSite == NULL)
			m_spServices.Release();

		return hr;
	}

// IOleClientSite
	STDMETHOD(SaveObject)()
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));
	}
	STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/)
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));
	}
	STDMETHOD(GetContainer)(IOleContainer** ppContainer)
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::GetContainer\n"));
		ATLASSERT(ppContainer != NULL);

		HRESULT hr = E_POINTER;
		if (ppContainer)
		{
			hr = E_NOTIMPL;
			(*ppContainer) = NULL;
			if (m_spUnkSite)
				hr = m_spUnkSite->QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
			if (FAILED(hr))
				hr = QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
		}
		return hr;
	}
	STDMETHOD(ShowObject)()
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::ShowObject\r\n"));

		HDC hdc = CWindowImpl<CAxHostWindow>::GetDC();
		if (hdc == NULL)
			return E_FAIL;
		if (m_spViewObject)
			m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdc, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 
		CWindowImpl<CAxHostWindow>::ReleaseDC(hdc);
		return S_OK;
	}
	STDMETHOD(OnShowWindow)(BOOL /*fShow*/)
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));
	}
	STDMETHOD(RequestNewObjectLayout)()
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));
	}

// IOleInPlaceSite
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::ContextSensitiveHelp"));
	}
	STDMETHOD(CanInPlaceActivate)()
	{
		return S_OK;
	}
	STDMETHOD(OnInPlaceActivate)()
	{
		m_bInPlaceActive = TRUE;
		OleLockRunning(m_spOleObject, TRUE, FALSE);
		m_bWindowless = FALSE;
		m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		return S_OK;
	}
	STDMETHOD(OnUIActivate)()
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIActivate\n"));
		m_bUIActive = TRUE;
		return S_OK;
	}
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
	{
		if (ppFrame != NULL)
			*ppFrame = NULL;
		if (ppDoc != NULL)
			*ppDoc = NULL;
		if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL)
		{
			ATLASSERT(false);
			return E_POINTER;
		}

		if (!m_spInPlaceFrame)
		{
			CComObject<CAxFrameWindow>* pFrameWindow;
			CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);
			pFrameWindow->QueryInterface(__uuidof(IOleInPlaceFrame), (void**) &m_spInPlaceFrame);
			ATLASSERT(m_spInPlaceFrame);
		}
		if (!m_spInPlaceUIWindow)
		{
			CComObject<CAxUIWindow>* pUIWindow;
			CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);
			pUIWindow->QueryInterface(__uuidof(IOleInPlaceUIWindow), (void**) &m_spInPlaceUIWindow);
			ATLASSERT(m_spInPlaceUIWindow);
		}
		m_spInPlaceFrame.CopyTo(ppFrame);
		m_spInPlaceUIWindow.CopyTo(ppDoc);
		GetClientRect(lprcPosRect);
		GetClientRect(lprcClipRect);

		if (m_hAccel == NULL)
		{
			ACCEL ac = { 0,0,0 };
			m_hAccel = CreateAcceleratorTable(&ac, 1);
		}
		pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
		pFrameInfo->fMDIApp = m_bMDIApp;
		pFrameInfo->hwndFrame = GetParent();
		pFrameInfo->haccel = m_hAccel;
		pFrameInfo->cAccelEntries = (m_hAccel != NULL) ? 1 : 0;

		return S_OK;
	}
	STDMETHOD(Scroll)(SIZE /*scrollExtant*/)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));
	}
	STDMETHOD(OnUIDeactivate)(BOOL /*fUndoable*/)
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIDeactivate\n"));
		m_bUIActive = FALSE;
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivate)()
	{
		m_bInPlaceActive = FALSE;
		m_spInPlaceObjectWindowless.Release();
		return S_OK;
	}
	STDMETHOD(DiscardUndoState)()
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));
	}
	STDMETHOD(DeactivateAndUndo)()
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));
	}
	STDMETHOD(OnPosRectChange)(LPCRECT /*lprcPosRect*/)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnPosRectChange"));
	}

// IOleInPlaceSiteEx
	STDMETHOD(OnInPlaceActivateEx)(BOOL* /*pfNoRedraw*/, DWORD dwFlags)
	{
		m_bInPlaceActive = TRUE;
		OleLockRunning(m_spOleObject, TRUE, FALSE);
		HRESULT hr = E_FAIL;
		if (dwFlags & ACTIVATE_WINDOWLESS)
		{
			m_bWindowless = TRUE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObjectWindowless), (void**) &m_spInPlaceObjectWindowless);
		}
		if (FAILED(hr))
		{
			m_bWindowless = FALSE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		}
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivateEx)(BOOL /*fNoRedraw*/)
	{
		return S_OK;
	}
	STDMETHOD(RequestUIActivate)()
	{
		return S_OK;
	}

// IOleInPlaceSiteWindowless
	HDC m_hDCScreen;
	bool m_bDCReleased;

	STDMETHOD(CanWindowlessActivate)()
	{
		return m_bCanWindowlessActivate ? S_OK : S_FALSE;
	}
	STDMETHOD(GetCapture)()
	{
		return m_bCapture ? S_OK : S_FALSE;
	}
	STDMETHOD(SetCapture)(BOOL fCapture)
	{
		if (fCapture)
		{
			CWindow::SetCapture();
			m_bCapture = TRUE;
		}
		else
		{
			ReleaseCapture();
			m_bCapture = FALSE;
		}
		return S_OK;
	}
	STDMETHOD(GetFocus)()
	{
		return m_bHaveFocus ? S_OK : S_FALSE;
	}
	STDMETHOD(SetFocus)(BOOL fGotFocus)
	{
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD grfFlags, HDC* phDC)
	{
		if (phDC == NULL)
			return E_POINTER;
		if (!m_bDCReleased)
			return E_FAIL;

		*phDC = CWindowImpl<CAxHostWindow>::GetDC();
		if (*phDC == NULL)
			return E_FAIL;

		m_bDCReleased = false;

		if (grfFlags & OLEDC_NODRAW)
			return S_OK;

		RECT rect;
		GetClientRect(&rect);
		if (grfFlags & OLEDC_OFFSCREEN)
		{
			HDC hDCOffscreen = CreateCompatibleDC(*phDC);
			if (hDCOffscreen != NULL)
			{
				HBITMAP hBitmap = CreateCompatibleBitmap(*phDC, rect.right - rect.left, rect.bottom - rect.top);
				if (hBitmap == NULL)
					DeleteDC(hDCOffscreen);
				else
				{
					HGDIOBJ hOldBitmap = SelectObject(hDCOffscreen, hBitmap);
					if (hOldBitmap == NULL)
					{
						DeleteObject(hBitmap);
						DeleteDC(hDCOffscreen);
					}
					else
					{
						DeleteObject(hOldBitmap);
						m_hDCScreen = *phDC;
						*phDC = hDCOffscreen;
					}
				}
			}
		}

		if (grfFlags & OLEDC_PAINTBKGND)
			::FillRect(*phDC, &rect, (HBRUSH) (COLOR_WINDOW+1));
		return S_OK;
	}
	STDMETHOD(ReleaseDC)(HDC hDC)
	{
		m_bDCReleased = true;
		if (m_hDCScreen != NULL)
		{
			RECT rect;
			GetClientRect(&rect);
			// Offscreen DC has to be copied to screen DC before releasing the screen dc;
			BitBlt(m_hDCScreen, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hDC, 0, 0, SRCCOPY);
			DeleteDC(hDC);
			hDC = m_hDCScreen;
		}

		CWindowImpl<CAxHostWindow>::ReleaseDC(hDC);
		return S_OK;
	}
	STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase)
	{
		CWindowImpl<CAxHostWindow>::InvalidateRect(pRect, fErase);
		return S_OK;
	}
	STDMETHOD(InvalidateRgn)(HRGN hRGN, BOOL fErase)
	{
		CWindowImpl<CAxHostWindow>::InvalidateRgn(hRGN, fErase);
		return S_OK;
	}
	STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/)
	{
		return S_OK;
	}
	STDMETHOD(AdjustRect)(LPRECT /*prc*/)
	{
		return S_OK;
	}
	STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
	{
		*plResult = DefWindowProc(msg, wParam, lParam);
		return S_OK;
	}

// IOleControlSite
	STDMETHOD(OnControlInfoChanged)()
	{
		return S_OK;
	}
	STDMETHOD(LockInPlaceActive)(BOOL /*fLock*/)
	{
		return S_OK;
	}
	STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
	{
		if (ppDisp == NULL)
			return E_POINTER;
		return m_spOleObject.QueryInterface(ppDisp);
	}
	STDMETHOD(TransformCoords)(POINTL* /*pPtlHimetric*/, POINTF* /*pPtfContainer*/, DWORD /*dwFlags*/)
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::TransformCoords"));
	}
	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, DWORD /*grfModifiers*/)
	{
		return S_FALSE;
	}
	STDMETHOD(OnFocus)(BOOL fGotFocus)
	{
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(ShowPropertyFrame)()
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::ShowPropertyFrame"));
	}

// IAdviseSink
	STDMETHOD_(void, OnDataChange)(FORMATETC* /*pFormatetc*/, STGMEDIUM* /*pStgmed*/)
	{
	}
	STDMETHOD_(void, OnViewChange)(DWORD /*dwAspect*/, LONG /*lindex*/)
	{
	}
	STDMETHOD_(void, OnRename)(IMoniker* /*pmk*/)
	{
	}
	STDMETHOD_(void, OnSave)()
	{
	}
	STDMETHOD_(void, OnClose)()
	{
	}

// IOleContainer
	STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/)
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::ParseDisplayName"));
	}
	STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		*ppenum = NULL;
		typedef CComObject<CComEnum<IEnumUnknown, &__uuidof(IEnumUnknown), IUnknown*, _CopyInterface<IUnknown> > > enumunk;
		enumunk* p = NULL;
		ATLTRY(p = new enumunk);
		if(p == NULL)
			return E_OUTOFMEMORY;
		IUnknown* pTemp = m_spUnknown;
		// There is always only one object.
		HRESULT hRes = p->Init(reinterpret_cast<IUnknown**>(&pTemp), reinterpret_cast<IUnknown**>(&pTemp + 1), GetControllingUnknown(), AtlFlagCopy);
		if (SUCCEEDED(hRes))
			hRes = p->QueryInterface(__uuidof(IEnumUnknown), (void**)ppenum);
		if (FAILED(hRes))
			delete p;
		return hRes;
	}
	STDMETHOD(LockContainer)(BOOL fLock)
	{
		m_bLocked = fLock;
		return S_OK;
	}

	HRESULT ActivateAx(IUnknown* pUnkControl, bool bInited, IStream* pStream)
	{
		if (pUnkControl == NULL)
			return S_OK;

		m_spUnknown = pUnkControl;

		HRESULT hr = S_OK;
		pUnkControl->QueryInterface(__uuidof(IOleObject), (void**)&m_spOleObject);
		if (m_spOleObject)
		{
			m_spOleObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
			if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			if (!bInited) // If user hasn't initialized the control, initialize/load using IPersistStreamInit or IPersistStream
			{
				CComQIPtr<IPersistStreamInit> spPSI(m_spOleObject);
				if (spPSI)
				{
					if (pStream)
						hr = spPSI->Load(pStream);
					else
						hr = spPSI->InitNew();
				}
				else if (pStream)
				{
					CComQIPtr<IPersistStream> spPS(m_spOleObject);
					if (spPS)
						hr = spPS->Load(pStream);
				}

				if (FAILED(hr)) // If the initialization of the control failed...
				{
					// Clean up and return
					if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
						m_spOleObject->SetClientSite(NULL);

					m_dwMiscStatus = 0;
					m_spOleObject.Release();
					m_spUnknown.Release();

					return hr;
				}
			}

			if (0 == (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			m_dwViewObjectType = 0;
			hr = m_spOleObject->QueryInterface(__uuidof(IViewObjectEx), (void**) &m_spViewObject);
			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject2), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 3;
			} else
				m_dwViewObjectType = 7;

			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 1;
			}
			CComQIPtr<IAdviseSink> spAdviseSink(GetControllingUnknown());
			m_spOleObject->Advise(spAdviseSink, &m_dwOleObject);
			if (m_spViewObject)
				m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, spAdviseSink);
			m_spOleObject->SetHostNames(OLESTR("AXWIN"), NULL);

			if ((m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME) == 0)
			{
				GetClientRect(&m_rcPos);
				m_pxSize.cx = m_rcPos.right - m_rcPos.left;
				m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
				AtlPixelToHiMetric(&m_pxSize, &m_hmSize);
				m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
				m_spOleObject->GetExtent(DVASPECT_CONTENT, &m_hmSize);
				AtlHiMetricToPixel(&m_hmSize, &m_pxSize);
				m_rcPos.right = m_rcPos.left + m_pxSize.cx;
				m_rcPos.bottom = m_rcPos.top + m_pxSize.cy;

				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				hr = m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			}
		}
		CComPtr<IObjectWithSite> spSite;
		pUnkControl->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
		if (spSite != NULL)
			spSite->SetSite(GetControllingUnknown());

		return hr;
	}


// pointers
	CComPtr<IUnknown> m_spUnknown;
	CComPtr<IOleObject> m_spOleObject;
	CComPtr<IOleInPlaceFrame> m_spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow;
	CComPtr<IViewObjectEx> m_spViewObject;
	CComPtr<IOleInPlaceObjectWindowless> m_spInPlaceObjectWindowless;
	CComPtr<IDispatch> m_spExternalDispatch;
#ifndef _ATL_NO_DOCHOSTUIHANDLER
	CComPtr<IDocHostUIHandlerDispatch> m_spIDocHostUIHandlerDispatch;
#endif
	IID m_iidSink;
	DWORD m_dwViewObjectType;
	DWORD m_dwAdviseSink;

// state
	unsigned long m_bInPlaceActive:1;
	unsigned long m_bUIActive:1;
	unsigned long m_bMDIApp:1;
	unsigned long m_bWindowless:1;
	unsigned long m_bCapture:1;
	unsigned long m_bHaveFocus:1;
	unsigned long m_bReleaseAll:1;
	unsigned long m_bLocked:1;

	DWORD m_dwOleObject;
	DWORD m_dwMiscStatus;
	SIZEL m_hmSize;
	SIZEL m_pxSize;
	RECT m_rcPos;

	// Accelerator table
	HACCEL m_hAccel;

	// Ambient property storage
	unsigned long m_bCanWindowlessActivate:1;
	unsigned long m_bUserMode:1;
	unsigned long m_bDisplayAsDefault:1;
	unsigned long m_bMessageReflect:1;
	unsigned long m_bSubclassed:1;
	unsigned long m_bAllowContextMenu:1;
	unsigned long m_bAllowShowUI:1;
	OLE_COLOR m_clrBackground;
	OLE_COLOR m_clrForeground;
	LCID m_lcidLocaleID;
	CComPtr<IFontDisp> m_spFont;
	CComPtr<IServiceProvider>  m_spServices;
	DWORD m_dwDocHostFlags;
	DWORD m_dwDocHostDoubleClickFlags;
	CComBSTR m_bstrOptionKeyPath;

	void SubclassWindow(HWND hWnd)
	{
		m_bSubclassed = CWindowImpl<CAxHostWindow>::SubclassWindow(hWnd);
	}

	void ReleaseWindow()
	{
		if (m_bSubclassed)
		{
			if(UnsubclassWindow(TRUE) != NULL)
				m_bSubclassed = FALSE;
		}
		else
			DestroyWindow();
	}

	// Reflection
	LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		HWND hWndChild = NULL;

		switch(uMsg)
		{
		case WM_COMMAND:
			if(lParam != NULL)	// not from a menu
				hWndChild = (HWND)lParam;
			break;
		case WM_NOTIFY:
			hWndChild = ((LPNMHDR)lParam)->hwndFrom;
			break;
		case WM_PARENTNOTIFY:
			DefWindowProc();
			switch(LOWORD(wParam))
			{
			case WM_CREATE:
			case WM_DESTROY:
				hWndChild = (HWND)lParam;
				break;
			default:
				hWndChild = GetDlgItem(HIWORD(wParam));
				break;
			}
			break;
		case WM_DRAWITEM:
			{
				DRAWITEMSTRUCT* pdis = ((LPDRAWITEMSTRUCT)lParam);
				if (pdis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = pdis->hwndItem;
				else							// Status bar control sends this message with type set to ODT_MENU
					if (::IsWindow(pdis->hwndItem))
						hWndChild = pdis->hwndItem;
			}
			break;
		case WM_MEASUREITEM:
			{
				MEASUREITEMSTRUCT* pmis = ((LPMEASUREITEMSTRUCT)lParam);
				if(pmis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = GetDlgItem(pmis->CtlID);
			}
			break;
		case WM_COMPAREITEM:
				// Sent only by combo or list box
				hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_DELETEITEM:
				// Sent only by combo or list box
				hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_HSCROLL:
		case WM_VSCROLL:
			hWndChild = (HWND)lParam;
			break;
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			hWndChild = (HWND)lParam;
			break;
		default:
			break;
		}

		if(hWndChild == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		if (m_bWindowless)
		{
			LRESULT lRes = 0;
			if (m_bInPlaceActive && m_spInPlaceObjectWindowless)
				m_spInPlaceObjectWindowless->OnWindowMessage(OCM__BASE + uMsg, wParam, lParam, &lRes);
			return lRes;
		}

		ATLASSERT(::IsWindow(hWndChild));
		return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
	}

	STDMETHOD(QueryService)( REFGUID rsid, REFIID riid, void** ppvObj) 
	{
		ATLASSERT(ppvObj != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;

		HRESULT hr = E_NOINTERFACE;
		// Try for service on this object

		// No services currently

		// If that failed try to find the service on the outer object
		if (FAILED(hr) && m_spServices)
			hr = m_spServices->QueryService(rsid, riid, ppvObj);

		return hr;
	}
};

static LRESULT CALLBACK AtlAxWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
		// create control from a PROGID in the title
			// This is to make sure drag drop works
			::OleInitialize(NULL);

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
			::GetWindowText(hWnd, lpstrName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindow* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
			CComPtr<IStream> spStream;
			if (h && nCreateSize)
			{
				BYTE* pBytes = (BYTE*) GlobalLock(h);
				BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
				//Align to DWORD
				//pSource += (((~((DWORD)pSource)) + 1) & 3);
				memcpy(pBytes, pSource, nCreateSize);
				GlobalUnlock(h);
				CreateStreamOnHGlobal(h, TRUE, &spStream);
			}
			
			USES_CONVERSION;
			CComPtr<IUnknown> spUnk;
			HRESULT hRet = AtlAxCreateControlLic(T2COLE(lpstrName), hWnd, spStream, &spUnk, NULL);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), lpstrName);
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation
			
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
			
			// Set the control parent style for the AxWindow
			::SetWindowLong(hWnd, GWL_EXSTYLE, ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CONTROLPARENT);

			// check for control parent style if control has a window
			HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
			if(hWndChild != NULL)
			{
				DWORD dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
				if((dwExStyle & WS_EX_CONTROLPARENT) == 0)
				{
					dwExStyle |= WS_EX_CONTROLPARENT;
					::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
				}
			}
		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			OleUninitialize();
		}
		break;
	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

static LRESULT CALLBACK AtlAxWindowProc2(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
		// create control from a PROGID in the title
			// This is to make sure drag drop works
			::OleInitialize(NULL);

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
			::GetWindowText(hWnd, lpstrName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindowLic* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			// Format of data in lpCreateParams
			//	int nCreateSize;	// size of Create data in bytes
			//	WORD nMsg;			//constant used to indicate type of DLGINIT data. See _DialogSplitHelper for values.
			//	DWORD dwLen;		// Length of data strored for control in DLGINIT format in bytes.
			//	DWORD cchLicKey;	// Length of licence key in OLECHAR's
			//  OLECHAR *szLicKey;	// This will be present only if cchLicKey is greater than 0. This is of variable length and will contain cchLicKey OLECHAR's that represent the licence key.
			//	The following two fields will be present only if nMsg is WM_OCC_LOADFROMSTREAM_EX or WM_OCC_LOADFROMSTORAGE_EX. If present this information will be ignored since databinding is not supported.
			//		ULONG cbDataBinding;	// Lenght of databinding information in bytes.
			//		BYTE *pbDataBindingInfo	// cbDataBinding bytes that contain databinding information
			//	BYTE *pbControlData;	// Actual control data persisted by the control.


			HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
			CComPtr<IStream> spStream;
			if (h && nCreateSize)
			{
				BYTE* pBytes = (BYTE*) GlobalLock(h);
				BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
				//Align to DWORD
				//pSource += (((~((DWORD)pSource)) + 1) & 3);
				memcpy(pBytes, pSource, nCreateSize);
				GlobalUnlock(h);
				CreateStreamOnHGlobal(h, TRUE, &spStream);
			}
			
			CComBSTR bstrLicKey;
			HRESULT hRet = _DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
			if (FAILED(hRet))
				return -1;

			USES_CONVERSION;
			CComPtr<IUnknown> spUnk;
			hRet = AtlAxCreateControlLic(T2COLE(lpstrName), hWnd, spStream, &spUnk, bstrLicKey);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), lpstrName);
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindowLic), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);

			// Set the control parent style for the AxWindow
			::SetWindowLong(hWnd, GWL_EXSTYLE, ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CONTROLPARENT);

			// check for control parent style if control has a window
			HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
			if(hWndChild != NULL)
			{
				DWORD dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
				if((dwExStyle & WS_EX_CONTROLPARENT) == 0)
				{
					dwExStyle |= WS_EX_CONTROLPARENT;
					::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
				}
			}
		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindowLic* pAxWindow = (IAxWinHostWindowLic*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			OleUninitialize();
		}
		break;
	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}



}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLHOST_IMPL
#endif
#endif

#ifdef _ATLHOST_IMPL

//#ifndef _ATL_DLL_IMPL
namespace ATL
{
//#endif

//All exports go here

inline HRSRC AtlFindResource(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
{
	return ::FindResourceA(hModule, lpName, lpType);
}

inline HRSRC AtlFindResource(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
	return ::FindResourceW(hModule, lpName, lpType);
}

class _AtlDialogBoxIndirectParamHelper
{
public :
	typedef INT_PTR ReturnType;
	static ReturnType GetInvalidValue()
	{
		return -1;
	}
	static bool IsValidReturnVal(ReturnType nRet)
	{
		return (nRet != 0 && nRet != -1);
	}
};

class _AtlCreateDialogIndirectParamHelper
{
public :
	typedef HWND ReturnType;
	static ReturnType GetInvalidValue()
	{
		return NULL;
	}
	static bool IsValidReturnVal(ReturnType nRet)
	{
		return (nRet != 0);
	}
};

template <class StringType, class Helper, Helper::ReturnType (WINAPI *pFunc)(HINSTANCE, LPCDLGTEMPLATE, HWND,DLGPROC, LPARAM)>
Helper::ReturnType AtlAxDialogCreateT(HINSTANCE hInstance, StringType lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	AtlAxWinInit();
	Helper::ReturnType nRet = Helper::GetInvalidValue();

	HRSRC hDlg = AtlFindResource(hInstance, lpTemplateName, (StringType)RT_DIALOG);
	if (hDlg != NULL)
	{
		HRSRC hDlgInit = AtlFindResource(hInstance, lpTemplateName, (StringType)_ATL_RT_DLGINIT);
		HGLOBAL hData = NULL;
		BYTE* pInitData = NULL;

		if (hDlgInit)
		{
			hData = ::LoadResource(hInstance, hDlgInit);
			pInitData = (BYTE*) ::LockResource(hData);
		}

		DWORD dwLastError = 0;
		HGLOBAL hResource = LoadResource(hInstance, hDlg);
		if (hResource != NULL)
		{
			DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
			if (pDlg != NULL)
			{
				LPCDLGTEMPLATE lpDialogTemplate;
				
				lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
				
				nRet = (*pFunc)(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
				if (!Helper::IsValidReturnVal(nRet))
				{
					dwLastError = ::GetLastError();
				}
				if (lpDialogTemplate != pDlg)
					GlobalFree(GlobalHandle(lpDialogTemplate));
			}
			else
				dwLastError = ::GetLastError();
		}
		else
			dwLastError = ::GetLastError();

		if (dwLastError != 0)
			SetLastError(dwLastError);
	}
	return nRet;
}

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE INT_PTR __stdcall AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE INT_PTR __stdcall AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamA>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE HWND __stdcall AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE HWND __stdcall AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamA>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

ATLINLINE ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer)
{
	return AtlAxCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLic);
}

ATLINLINE ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink, BSTR bstrLic)
{
	AtlAxWinInit();
	HRESULT hr;
	CComPtr<IUnknown> spUnkContainer;
	CComPtr<IUnknown> spUnkControl;

	hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindowLic> pAxWindow;
		spUnkContainer->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
		CComBSTR bstrName(lpszName);
		hr = pAxWindow->CreateControlLicEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink, bstrLic);
	}
	if (ppUnkContainer != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkContainer = spUnkContainer.p;
			spUnkContainer.p = NULL;
		}
		else
			*ppUnkContainer = NULL;
	}
	if (ppUnkControl != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
			spUnkControl.p = NULL;
		}
		else
			*ppUnkControl = NULL;
	}
	return hr;
}

ATLINLINE ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer)
{
	AtlAxWinInit();
	if (pControl == NULL)
		return E_INVALIDARG;
	CComPtr<IUnknown> spUnkContainer;

	HRESULT hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindow> spAxWindow;
		hr = spUnkContainer->QueryInterface(&spAxWindow);
		if (SUCCEEDED(hr))
			hr = spAxWindow->AttachControl(pControl, hWnd);
	}
	if (ppUnkContainer != NULL)
	{
		*ppUnkContainer = SUCCEEDED(hr) ? spUnkContainer.Detach() : NULL;
	}
	return hr;
}

#ifdef _ATL_DLL_IMPL
// global variable in ATL.DLL to keep track if AtlAxWin window class has been registered in ATL.DLL
bool __declspec(selectany) bAtlAxWinInitialized;
#endif

//This either registers a global class (if AtlAxWinInit is in ATL.DLL)
// or it registers a local class
ATLINLINE ATLAPI_(BOOL) AtlAxWinInit()
{
	CComCritSecLock<CComCriticalSection> lock(_ATLWINMODULE.m_csWindowCreate, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceHosting, 0, _T("ERROR : Unable to lock critical section in AtlAxWinInit\n"));
		ATLASSERT(0);
		return FALSE;
	}
	WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
	WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));
	WNDCLASSEX wc;
// first check if the class is already registered
	wc.cbSize = sizeof(WNDCLASSEX);
	BOOL bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow::GetWndClassName(), &wc);

// register class if not

	if(!bRet)
	{
		wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
		wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
		bAtlAxWinInitialized = true;
#else
		wc.style = CS_DBLCLKS;
#endif
		wc.lpfnWndProc = AtlAxWindowProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 0;
		wc.hInstance = _AtlBaseModule.GetModuleInstance();
		wc.hIcon = NULL;
		wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = CAxWindow::GetWndClassName();
		wc.hIconSm = NULL;

		bRet = (BOOL)::RegisterClassEx(&wc);
	}

	if (bRet)
	{
	// first check if the class is already registered
		memset(&wc, 0, sizeof(WNDCLASSEX));
		wc.cbSize = sizeof(WNDCLASSEX);
		bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow2::GetWndClassName(), &wc);

	// register class if not

		if(!bRet)
		{
			wc.cbSize = sizeof(WNDCLASSEX);
	#ifdef _ATL_DLL_IMPL
			wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
	#else
			wc.style = CS_DBLCLKS;
	#endif
			wc.lpfnWndProc = AtlAxWindowProc2;
			wc.cbClsExtra = 0;
			wc.cbWndExtra = 0;
			wc.hInstance = _AtlBaseModule.GetModuleInstance();
			wc.hIcon = NULL;
			wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
			wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
			wc.lpszMenuName = NULL;
			wc.lpszClassName = CAxWindow2::GetWndClassName();
			wc.hIconSm = NULL;

			bRet = (BOOL)::RegisterClassEx(&wc);
		}
	}
	return bRet;
}


ATLINLINE ATLAPI AtlAxGetControl(HWND h, IUnknown** pp)
{
	ATLASSERT(WM_ATLGETCONTROL != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETCONTROL, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}

ATLINLINE ATLAPI AtlAxGetHost(HWND h, IUnknown** pp)
{
	ATLASSERT(WM_ATLGETHOST != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETHOST, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}

//#ifndef _ATL_DLL_IMPL
}; //namespace ATL
//#endif

//Prevent pulling in second time 
#undef _ATLHOST_IMPL

#endif // _ATLHOST_IMPL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

// Review : Temp
#ifdef _ATL_NO_AUTOMATIC_NAMESPACE
using ATL::AtlAxWinInit;
#endif

#endif  // __ATLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlhtml.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTML_H__
#define __ATLHTML_H__

#pragma once

#include <atlstr.h>
#include <atlsiface.h>
#include <atlconv.h>

namespace ATL {

#define TAGF_NONE 0
#define TAGF_HASEND 1
#define TAGF_BLOCK  2


struct ATL_HTML_TAG
{
	LPCTSTR szTagName;
	UINT uFlags;
};

enum ATL_HTML_TAGS {
	ATL_HTML_TAG_BODY,
	ATL_HTML_TAG_A,
	ATL_HTML_TAG_B,
	ATL_HTML_TAG_I,
	ATL_HTML_TAG_U,
	ATL_HTML_TAG_FONT,
	ATL_HTML_TAG_IMG,
	ATL_HTML_TAG_HR,
	ATL_HTML_TAG_BR,
	ATL_HTML_TAG_DIV,
	ATL_HTML_TAG_BLOCKQUOTE,
	ATL_HTML_TAG_ADDRESS,
	ATL_HTML_TAG_P,
	ATL_HTML_TAG_H1,
	ATL_HTML_TAG_H2,
	ATL_HTML_TAG_H3,
	ATL_HTML_TAG_H4,
	ATL_HTML_TAG_H5,
	ATL_HTML_TAG_H6,
	ATL_HTML_TAG_PRE,
	ATL_HTML_TAG_Q,
	ATL_HTML_TAG_SUB,
	ATL_HTML_TAG_SUP,
	ATL_HTML_TAG_INS,
	ATL_HTML_TAG_DEL,
	ATL_HTML_TAG_EM,
	ATL_HTML_TAG_STRONG,
	ATL_HTML_TAG_DFN,
	ATL_HTML_TAG_CODE,
	ATL_HTML_TAG_SAMP,
	ATL_HTML_TAG_KBD,
	ATL_HTML_TAG_VAR,
	ATL_HTML_TAG_CITE,
	ATL_HTML_TAG_ABBR,
	ATL_HTML_TAG_ACRONYM,
	ATL_HTML_TAG_OL,
	ATL_HTML_TAG_UL,
	ATL_HTML_TAG_LI,
	ATL_HTML_TAG_DL,
	ATL_HTML_TAG_DT,
	ATL_HTML_TAG_DD,
	ATL_HTML_TAG_TABLE,
	ATL_HTML_TAG_TR,
	ATL_HTML_TAG_TD,
	ATL_HTML_TAG_FORM,
	ATL_HTML_TAG_INPUT,
	ATL_HTML_TAG_SELECT,
	ATL_HTML_TAG_OPTION,
	ATL_HTML_TAG_HEAD,
	ATL_HTML_TAG_HTML,
	ATL_HTML_TAG_MAP,
	ATL_HTML_TAG_AREA,
	ATL_HTML_TAG_BASE,
	ATL_HTML_TAG_BDO,
	ATL_HTML_TAG_BIG,
	ATL_HTML_TAG_BUTTON,
	ATL_HTML_TAG_IFRAME,
	ATL_HTML_TAG_LABEL,
	ATL_HTML_TAG_LINK,
	ATL_HTML_TAG_META,
	ATL_HTML_TAG_NOFRAMES,
	ATL_HTML_TAG_NOSCRIPT,
	ATL_HTML_TAG_COL,
	ATL_HTML_TAG_COLGROUP,
	ATL_HTML_TAG_FIELDSET,
	ATL_HTML_TAG_LEGEND,
	ATL_HTML_TAG_TBODY,
	ATL_HTML_TAG_TEXTAREA,
	ATL_HTML_TAG_TFOOT,
	ATL_HTML_TAG_TH,
	ATL_HTML_TAG_TITLE,
	ATL_HTML_TAG_TT,
	ATL_HTML_TAG_SMALL,
	ATL_HTML_TAG_SPAN,
	ATL_HTML_TAG_OBJECT,
	ATL_HTML_TAG_PARAM,
	ATL_HTML_TAG_LAST };

// todo: add th and the rest of the table stuff
__declspec(selectany) ATL_HTML_TAG s_tags[] = 
{
	{ _T("body"),  TAGF_HASEND | TAGF_BLOCK },
	{ _T("a"), TAGF_HASEND },
	{ _T("b"), TAGF_HASEND },
	{ _T("i"), TAGF_HASEND },
	{ _T("u"), TAGF_HASEND },
	{ _T("font"), TAGF_HASEND },
	{ _T("img"), TAGF_NONE },
	{ _T("hr"), TAGF_NONE },
	{ _T("br"), TAGF_NONE },
	{ _T("div"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("blockquote"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("adress"), TAGF_HASEND },
	{ _T("p"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h1"), TAGF_HASEND | TAGF_BLOCK},
	{ _T("h2"), TAGF_HASEND  | TAGF_BLOCK},
	{ _T("h3"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h4"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h5"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h6"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("pre"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("q"), TAGF_HASEND },
	{ _T("sub"), TAGF_HASEND },
	{ _T("sup"), TAGF_HASEND },
	{ _T("ins"), TAGF_HASEND },
	{ _T("del"), TAGF_HASEND },
	{ _T("em"), TAGF_HASEND },
	{ _T("strong"), TAGF_HASEND },
	{ _T("dfn"), TAGF_HASEND },
	{ _T("code"), TAGF_HASEND },
	{ _T("samp"), TAGF_HASEND },
	{ _T("kbd"), TAGF_HASEND },
	{ _T("var"), TAGF_HASEND },
	{ _T("cite"), TAGF_HASEND },
	{ _T("abbr"), TAGF_HASEND },
	{ _T("acronym"), TAGF_HASEND },
	{ _T("ol"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("ul"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("li"), TAGF_HASEND },
	{ _T("dl"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("dt"), TAGF_HASEND },
	{ _T("dd"), TAGF_HASEND },
	{ _T("table"), TAGF_HASEND },
	{ _T("tr"), TAGF_HASEND },
	{ _T("td"), TAGF_HASEND },
	{ _T("form"), TAGF_HASEND },
	{ _T("input"), TAGF_HASEND },
	{ _T("select"), TAGF_HASEND },
	{ _T("option"), TAGF_HASEND },
	{ _T("head"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("html"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("map"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("area"), TAGF_BLOCK },
	{ _T("base"), TAGF_BLOCK },
	{ _T("bdo"), TAGF_HASEND },
	{ _T("big"), TAGF_HASEND },
	{ _T("button"), TAGF_HASEND },
	{ _T("iframe"), TAGF_HASEND },
	{ _T("label"), TAGF_HASEND },
	{ _T("link"), TAGF_NONE },
	{ _T("meta"), TAGF_BLOCK },
	{ _T("noframes"), TAGF_BLOCK },
	{ _T("noscript"), TAGF_BLOCK },
	{ _T("col"), TAGF_BLOCK },
	{ _T("colgroup"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("fieldset"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("legend"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tbody"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("textarea"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tfoot"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("th"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("title"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tt"), TAGF_HASEND },
	{ _T("small"), TAGF_HASEND },
	{ _T("span"), TAGF_HASEND },
	{ _T("object"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("param"), TAGF_NONE },
};

class AtlHtmlAttrs
{
public:
	CString m_strAttrs;

	AtlHtmlAttrs()
	{

	}

	AtlHtmlAttrs(int nCount, ...)
	{
		va_list args;

		va_start(args, nCount);
		for (int i=0; i<nCount; i++)
		{
			LPCTSTR szName = va_arg(args, LPCTSTR);
			LPCTSTR szVal = va_arg(args, LPCTSTR);
			Add(szName, szVal);
		}
		va_end(args);
	}

	AtlHtmlAttrs(LPCTSTR szFormat, ...)
	{
		if (!szFormat || !*szFormat)
			return;

		va_list args;

		va_start(args, szFormat);

		CString strTmp;
		strTmp.FormatV(szFormat, args);
		va_end(args);

		m_strAttrs += _T(" ");
		m_strAttrs += strTmp;
	}

	BOOL Add(LPCTSTR szName, LPCTSTR szValue)
	{
		if (szValue)
			m_strAttrs.AppendFormat(_T(" %s=\"%s\""), szName, szValue);
		else
			m_strAttrs.AppendFormat(_T(" %s"), szName);
		return TRUE;
	}

	void AddFormat(LPCTSTR szFormat, ...)
	{
		va_list args;

		va_start(args, szFormat);

		CString strTmp;
		strTmp.FormatV(szFormat, args);
		va_end(args);

		m_strAttrs += _T(" ");
		m_strAttrs += strTmp;
	}

	void Set(LPCTSTR szAttrs)
	{
		if (szAttrs)
		{
			m_strAttrs.Empty();
			if (!isspace(szAttrs[0]))
				m_strAttrs = _T(" ");
			m_strAttrs += szAttrs;
		}
	}

	operator LPCTSTR()
	{
		return m_strAttrs;
	}

};

class CStreamFormatter
{
protected:
	IStream *m_pStream;
	BOOL m_bAddCRLF;
	BOOL m_bEmitUnicode;
	UINT m_nConversionCodepage;

public:
	CStreamFormatter()
	{
		m_pStream = NULL;
		m_bAddCRLF = TRUE;
		m_bEmitUnicode = FALSE;
		m_nConversionCodepage = _AtlGetConversionACP();
	}

	void Initialize(IStream *pStream, BOOL bAddCRLF=TRUE)
	{
		m_pStream = pStream;
		m_bAddCRLF = bAddCRLF;
	}
	
	void EmitUnicode(BOOL bEmitUnicode)
	{
		m_bEmitUnicode = bEmitUnicode;
	}

	void SetConversionCodepage(UINT nConversionCodepage)
	{
		m_nConversionCodepage = nConversionCodepage;
	}

	void AddCRLF(bool bNewVal)
	{
		m_bAddCRLF = bNewVal;
	}

	HRESULT WriteRaw(LPCTSTR szString, int nCount=-1)
	{
		ATLASSERT(szString != NULL);
		if (!m_pStream)
			return E_FAIL;

		if (m_bEmitUnicode)
		{
#ifdef _UNICODE
			LPCWSTR sz = szString;
			if (nCount == -1)
				nCount = (int) wcslen(szString);
#else
			CA2W sz(szString, m_nConversionCodepage);
			nCount = (int) wcslen(sz);
#endif
			DWORD dwWritten;
			return m_pStream->Write(sz, (DWORD) nCount*sizeof(WCHAR), &dwWritten);
		}
		else
		{
#ifdef _UNICODE
			CW2A sz(szString, m_nConversionCodepage);
			nCount = (int) strlen(sz);
#else
			LPCSTR sz = szString;
			if (nCount == -1)
				nCount = (int) strlen(szString);
#endif
			DWORD dwWritten;
			return m_pStream->Write(sz, (DWORD) nCount, &dwWritten);
		}
	}

	HRESULT StartTag(int nTagIndex, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (nTagIndex < 0 || nTagIndex >= ATL_HTML_TAG_LAST)
			return E_INVALIDARG;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		HRESULT hr = StartTag(s_tags[nTagIndex].szTagName, szContent, szAttrs);
		if (FAILED(hr))
			return hr;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		return S_OK;
	}

	HRESULT StartTag(LPCTSTR szTag, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		HRESULT hr;
		hr = WriteRaw(_T("<"));
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(szTag);
		if (FAILED(hr))
			return hr;
		hr = WriteAttributes(szAttrs);
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(_T(">"));
		if (FAILED(hr))
			return hr;
		if (szContent && *szContent)
		{
			WriteRaw(szContent);
			EndTag(szTag);
		}
		return S_OK;
	}

	HRESULT EndTag(int nTagIndex)
	{
		if (nTagIndex < 0 || nTagIndex >= ATL_HTML_TAG_LAST)
			return E_INVALIDARG;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		HRESULT hr = EndTag(s_tags[nTagIndex].szTagName);
		if (FAILED(hr))
			return hr;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		return S_OK;
	}

	HRESULT EndTag(LPCTSTR szTag)
	{
		HRESULT hr = WriteRaw(_T("</"));
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(szTag);
		if (FAILED(hr))
			return hr;
		return WriteRaw(_T(">"));
	}

	HRESULT WriteAttributes(LPCTSTR szAttrs)
	{
		if (szAttrs && szAttrs[0])
		{
			if (!isspace(szAttrs[0]))
				WriteRaw(_T(" "));
			return WriteRaw(szAttrs);
		}

		return S_OK;
	}
	
	HRESULT WriteFormatted(LPCTSTR szFormat, ...)
	{
		ATLASSERT(szFormat != NULL);
		if (!m_pStream)
			return E_FAIL;

		va_list args;
		va_start(args, szFormat);


		TCHAR buffFixed[1024];
		CTempBuffer<TCHAR> buffHeap;
		TCHAR *szTemp = buffFixed;
		int nCount = _vsntprintf((LPTSTR)szTemp, 1024, szFormat, args);
		if (nCount < 0)
		{
			// we'll have to dynamically allocate the buffer
			nCount = _vsctprintf(szFormat, args);
			if (buffHeap.Allocate(nCount + 1))
			{
				szTemp = (TCHAR*)buffHeap;
				nCount = _vsntprintf(szTemp, nCount+1, szFormat, args);
			}
		}
	
		va_end(args);
		
		if (nCount > 0)
			return WriteRaw(szTemp, (DWORD) nCount);
		return E_UNEXPECTED;
	}
};

template <typename TData, int nMax=64>
class CSimpleStack
{
public:
	int m_nTop;
	TData m_Data[nMax];

	CSimpleStack()
	{
		m_nTop = -1;
	}

	bool IsEmpty()
	{
		return (m_nTop == -1);
	}

	bool Push(const TData *pData)
	{
		if (m_nTop >= nMax)
			return false;

		m_nTop++;

		m_Data[m_nTop] = *pData;
		return true;
	}

	bool Pop(TData *pData)
	{
		if (m_nTop < 0)
			return false;

		*pData = m_Data[m_nTop];
		m_nTop--;
		return true;
	}
};


struct HTML_SCHEME
{
	CString strBgColor;
	CString strLinkColor;
	CString strVLinkColor;
	CString strALinkColor;
	CString strBackground;
	int nTopMargin;
	int nLeftMargin;
	
	CString strTdBgColor;
	CString strTableBgColor;
	CString strTrBgColor;

	HTML_SCHEME()
	{
		nTopMargin = -1;
		nLeftMargin = -1;
	}
};

template <class T>
class CHtmlGenBase : public CStreamFormatter
{
public:
	CString m_strState;
	HTML_SCHEME *m_pScheme;

	T* GetOuter()
	{
		return static_cast<T*>(this);
	}

	struct TableState
	{
		TableState() : m_bRowOpen(false), m_bDataOpen(false)
		{

		}

		void Clear()
		{
			m_bRowOpen = false;
			m_bDataOpen = false;
		}

		bool m_bRowOpen;
		bool m_bDataOpen;
	};

	int m_nWidthPercent;
	int m_nHeightPercent;

	enum ATL_HTML_FORM_METHOD { ATL_HTML_FORM_METHOD_NONE=-1, ATL_HTML_FORM_METHOD_GET, ATL_HTML_FORM_METHOD_POST, ATL_HTML_FORM_METHOD_MULTIPART };
	ATL_HTML_FORM_METHOD m_nFormMethod;

	TableState m_tableState;
	CSimpleStack<TableState> m_RowStack;


	CHtmlGenBase()
	{
		m_nWidthPercent = -1;
		m_nHeightPercent = -1;
		m_nFormMethod = ATL_HTML_FORM_METHOD_NONE;
		m_pScheme = NULL;
	}

	void SetScheme(HTML_SCHEME *pScheme)
	{
		m_pScheme = pScheme;
	}
	HRESULT body(LPCTSTR szBgColor=NULL, LPCTSTR szBackground=NULL, LPCTSTR szTopMargin=NULL, LPCTSTR szLeftMargin=NULL,
		LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szBgColor && *szBgColor)
			Attrs.Add(_T("bgColor"), szBgColor);
		else if (m_pScheme && m_pScheme->strBgColor.GetLength())
			Attrs.Add(_T("bgColor"), m_pScheme->strBgColor);

		if (szBackground && *szBackground)
			Attrs.Add(_T("background"), szBackground);
		else if (m_pScheme && m_pScheme->strBackground.GetLength())
			Attrs.Add(_T("background"), m_pScheme->strBackground);

		if (m_pScheme && m_pScheme->strLinkColor.GetLength())
			Attrs.Add(_T("link"), m_pScheme->strLinkColor);

		if (m_pScheme && m_pScheme->strALinkColor.GetLength())
			Attrs.Add(_T("alink"), m_pScheme->strALinkColor);

		if (m_pScheme && m_pScheme->strVLinkColor.GetLength())
			Attrs.Add(_T("vlink"), m_pScheme->strVLinkColor);

		if (szTopMargin && *szTopMargin)
			Attrs.Add(_T("topmargin"), szTopMargin);
		else if (m_pScheme && m_pScheme->nTopMargin != -1)
			Attrs.AddFormat(_T("topmargin=\"%d\""), m_pScheme->nTopMargin);

		if (szLeftMargin && *szLeftMargin)
			Attrs.Add(_T("leftmargin"), szLeftMargin);
		else if (m_pScheme && m_pScheme->nLeftMargin != -1)
			Attrs.AddFormat(_T("leftmargin=\"%d\""), m_pScheme->nLeftMargin);

		return GetOuter()->StartTag(ATL_HTML_TAG_BODY, NULL, Attrs);

	}

	HRESULT bodyEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BODY);
	}

	HRESULT a(LPCTSTR szHref, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (m_strState.GetLength()==0)
		{
			if (szHref && *szHref)
				Attrs.Add(_T("href"), szHref);
			return GetOuter()->StartTag(ATL_HTML_TAG_A, szContent, Attrs);
		}

		const TCHAR *szQuestion = _tcschr(szHref, '?');
		CString strHref = szHref;
		if (!szQuestion)
			strHref.Append("?");
		else
			strHref.Append("&");

		strHref += m_strState;

		if (szHref && *szHref)
			Attrs.Add(_T("href"), strHref);

		return GetOuter()->StartTag(ATL_HTML_TAG_A, szContent, Attrs);
	}

	HRESULT aEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_A);
	}

	HRESULT b(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_B, szContent, szAttrs);
	}

	HRESULT bEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_B);
	}

	HRESULT i(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_I, szContent, szAttrs);
	}

	HRESULT iEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_I);
	}

	HRESULT u(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_U, szContent, szAttrs);
	}

	HRESULT uEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_U);
	}

	HRESULT font(LPCTSTR szFace, LPCTSTR szSize=NULL, LPCTSTR szColor=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);
		if (szFace && *szFace)
			Attrs.Add(_T("face"), szFace);
		if (szSize && *szSize)
			Attrs.Add(_T("size"), szSize);
		if (szColor && *szColor)
			Attrs.Add(_T("color"), szColor);
		return GetOuter()->StartTag(ATL_HTML_TAG_FONT, NULL, Attrs);
	}

	HRESULT font(COLORREF clrColor, LPCTSTR szAttrs=NULL)
	{
		TCHAR szColor[8];
		_stprintf(szColor, _T("#%02x%02x%02x"), GetRValue(clrColor), GetGValue(clrColor),
			GetBValue(clrColor));
		return GetOuter()->font(NULL, NULL, szColor, szAttrs);
	}

	HRESULT fontEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_FONT);
	}

	HRESULT img(LPCTSTR szSrc, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szSrc && *szSrc);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("src"), szSrc);

		return GetOuter()->StartTag(ATL_HTML_TAG_IMG, NULL, Attrs);
	}

	HRESULT br(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BR, NULL, szAttrs);
	}

	HRESULT hr(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HR, NULL, szAttrs);
	}

	HRESULT div(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DIV, szContent, szAttrs);
	}

	HRESULT divEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DIV);
	}

	HRESULT blockquote(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BLOCKQUOTE, szContent, szAttrs);
	}

	HRESULT blockquoteEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BLOCKQUOTE);
	}

	HRESULT address(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ADDRESS, szContent, szAttrs);
	}

	HRESULT addressEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ADDRESS);
	}

	HRESULT p(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_P, szContent, szAttrs);
	}

	HRESULT pEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_P);
	}

	HRESULT h(int nLevel=1, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (nLevel < 1 || nLevel > 6)
			return E_INVALIDARG;
		return GetOuter()->StartTag(ATL_HTML_TAG_H1+nLevel-1, szContent, szAttrs);
	}

	HRESULT hEnd(int nLevel=1)
	{
		if (nLevel < 1 || nLevel > 6)
			return E_INVALIDARG;
		return GetOuter()->EndTag(ATL_HTML_TAG_H1+nLevel-1);
	}

	HRESULT pre(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_PRE, szContent, szAttrs);
	}

	HRESULT preEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_PRE);
	}

	HRESULT q(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_Q, szContent, szAttrs);
	}

	HRESULT qEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_Q);
	}

	HRESULT sub(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SUB, szContent, szAttrs);
	}

	HRESULT subEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SUB);
	}

	HRESULT sup(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SUP, szContent, szAttrs);
	}

	HRESULT supEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SUP);
	}

	//TODO: should handle the time and date part of this
	HRESULT ins(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_INS, szContent, szAttrs);
	}

	HRESULT insEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_INS);
	}

	HRESULT del(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DEL, szContent, szAttrs);
	}

	HRESULT delEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DEL);
	}


	HRESULT em(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_EM, szContent, szAttrs);
	}

	HRESULT emEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_EM);
	}

	HRESULT strong(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_STRONG, szContent, szAttrs);
	}

	HRESULT strongEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_STRONG);
	}

	HRESULT dfn(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DFN, szContent, szAttrs);
	}

	HRESULT dfnEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DFN);
	}

	HRESULT code(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_CODE, szContent, szAttrs);
	}

	HRESULT codeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_CODE);
	}

	HRESULT samp(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SAMP, szContent, szAttrs);
	}

	HRESULT sampEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SAMP);
	}

	HRESULT kbd(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_KBD, szContent, szAttrs);
	}

	HRESULT kbdEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_KBD);
	}

	HRESULT var(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_VAR, szContent, szAttrs);
	}

	HRESULT varEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_VAR);
	}

	HRESULT cite(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_CITE, szContent, szAttrs);
	}

	HRESULT citeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_CITE);
	}

	HRESULT abbr(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ABBR, szContent, szAttrs);
	}

	HRESULT abbrEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ABBR);
	}

	HRESULT acronym(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ACRONYM, szContent, szAttrs);
	}

	HRESULT acronymEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ACRONYM);
	}


	HRESULT ol(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_OL, NULL, szAttrs);
	}

	HRESULT ul(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_UL, NULL, szAttrs);
	}

	HRESULT olEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OL);
	}
	
	HRESULT ulEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_UL);
	}

	HRESULT li(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_LI, szContent, szAttrs);
	}

	HRESULT liEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LI);
	}

	HRESULT dl(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DL, szContent, szAttrs);
	}

	HRESULT dlEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DL);
	}

	HRESULT dt(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DT, szContent, szAttrs);
	}

	HRESULT dtEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DT);
	}

	HRESULT dd(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DD, szContent, szAttrs);
	}

	HRESULT ddEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DD);
	}

	void SetSizePercent(int nWidth, int nHeight)
	{
		m_nWidthPercent = nWidth;
		m_nHeightPercent = nHeight;
	}

	HRESULT table(int nBorderWidth=0, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		m_RowStack.Push(&m_tableState);
		m_tableState.Clear();

		Attrs.AddFormat(_T("border=\"%d\""), nBorderWidth);
		
		if (m_nWidthPercent != -1)
			Attrs.AddFormat(_T("width=\"%d%%\""), m_nWidthPercent);
		if (m_nHeightPercent != -1)
			Attrs.AddFormat(_T("height=\"%d%%\""), m_nHeightPercent);

		if (m_pScheme && m_pScheme->strTableBgColor.GetLength())
			Attrs.Add(_T("bgcolor"), m_pScheme->strTableBgColor);

		m_nWidthPercent = -1;
		m_nHeightPercent = -1;
		return GetOuter()->StartTag(ATL_HTML_TAG_TABLE, NULL, Attrs);
	}

	HRESULT tableEnd()
	{
		if (m_tableState.m_bRowOpen)
			GetOuter()->trEnd();
		m_RowStack.Pop(&m_tableState);
		return GetOuter()->EndTag(ATL_HTML_TAG_TABLE);
	}

	HRESULT tr(LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (m_RowStack.IsEmpty())
			GetOuter()->table();
		if (m_tableState.m_bRowOpen)
			GetOuter()->trEnd();
		m_tableState.m_bRowOpen = true;

		if (m_pScheme && m_pScheme->strTrBgColor.GetLength())
			Attrs.Add(_T("bgcolor"), m_pScheme->strTrBgColor);
		return GetOuter()->StartTag(ATL_HTML_TAG_TR, NULL, Attrs);
	}

	HRESULT td(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (!m_tableState.m_bRowOpen)
			GetOuter()->tr();
		m_tableState.m_bDataOpen = true;
		if (m_pScheme && m_pScheme->strTdBgColor.GetLength())
			Attrs.Add(_T("bgColor"), m_pScheme->strTdBgColor);

		HRESULT hr = GetOuter()->StartTag(ATL_HTML_TAG_TD, szContent, Attrs);
		if (FAILED(hr))
			return hr;
		if (szContent)
			m_tableState.m_bDataOpen = false;
		return S_OK;
	}

	HRESULT tdEnd()
	{
		if (!m_tableState.m_bDataOpen)
			return S_OK;
		m_tableState.m_bDataOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TD);
	}

	HRESULT trEnd()
	{
		if (!m_tableState.m_bRowOpen)
			return S_OK;
		if (m_tableState.m_bDataOpen)
			GetOuter()->tdEnd();
		m_tableState.m_bRowOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TR);
	}

	// TODO: should do this the other way around, so we don't have to compare strings
	// aka, the one that takes the enum calls the one that takes a string
	HRESULT form(LPCTSTR szAction, ATL_HTML_FORM_METHOD nMethod=ATL_HTML_FORM_METHOD_GET, LPCTSTR szAttrs=NULL)
	{
		static const LPCTSTR s_szFormMethods[] = { _T("get"), _T("post"), _T("multipart-www-url-encoded") };

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szAction && *szAction)
			Attrs.Add(_T("action"), szAction);
		if (nMethod != ATL_HTML_FORM_METHOD_NONE)
			Attrs.Add(_T("method"), s_szFormMethods[nMethod]);

		return GetOuter()->StartTag(ATL_HTML_TAG_FORM, NULL, Attrs);
	}

	HRESULT form(LPCTSTR szAction, LPCTSTR szMethod, LPCTSTR szAttrs=NULL)
	{
		ATL_HTML_FORM_METHOD nMethod;
		if (!_tcsicmp(szMethod, "GET"))
			nMethod = ATL_HTML_FORM_METHOD_GET;
		else if (!_tcsicmp(szMethod, "POST"))
			nMethod = ATL_HTML_FORM_METHOD_POST;
		else if (!_tcsicmp(szMethod, "MULTIPART"))
			nMethod = ATL_HTML_FORM_METHOD_MULTIPART;
		else
			return E_INVALIDARG;
		return GetOuter()->form(szAction, nMethod, szAttrs);
	}

	HRESULT input(LPCTSTR szType, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szType && *szType)
			Attrs.Add(_T("type"), szType);
		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_INPUT, NULL, Attrs);
	}

	HRESULT submit(LPCTSTR szValue=NULL, LPCTSTR szName=NULL, LPCTSTR szAttrs=NULL)
	{
		return input(_T("submit"), szName, szValue, szAttrs);
	}

	HRESULT textarea(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TEXTAREA, szContent, szAttrs);
	}

	HRESULT textareaEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TEXTAREA);
	}

	HRESULT formEnd()
	{
//		if (GetOuter()->m_strState.GetLength())
//		{
//			GetOuter()->WriteFormatted(_T("<input type=\"hidden\" name=\"state\" value=\"%s\">\r\n"),
//				(LPCTSTR) GetOuter()->m_strState);
//		}
		return GetOuter()->EndTag(ATL_HTML_TAG_FORM);
	}


	HRESULT select(LPCTSTR szName, BOOL bMultiple=FALSE, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		if (bMultiple)
			Attrs.Add(_T("multiple"), NULL);
		return GetOuter()->StartTag(ATL_HTML_TAG_SELECT, NULL, Attrs);
	}

	HRESULT option(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_OPTION, szContent, szAttrs);
	}

	HRESULT optionEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OPTION);
	}

	HRESULT selectEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SELECT);
	}


	HRESULT head(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HEAD, NULL, szAttrs);
	}

	HRESULT headEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_HEAD);
	}

	HRESULT html(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HTML, NULL, szAttrs);
	}

	HRESULT htmlEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_HTML);
	}

	HRESULT map(LPCTSTR szName, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		return GetOuter()->StartTag(ATL_HTML_TAG_MAP, NULL, Attrs);
	}

	HRESULT mapEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_MAP);
	}

	HRESULT area(LPCTSTR szAlt, LPCTSTR szHref=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szAlt && *szAlt)
			Attrs.Add(_T("alt"), szAlt);
		if (szHref && *szHref)
			Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_AREA, NULL, Attrs);
	}

	HRESULT base(LPCTSTR szHref, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szHref && *szHref);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_BASE, NULL, Attrs);
	}

	HRESULT bdo(LPCTSTR szDir, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szDir&& *szDir);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("dir"), szDir);
		return GetOuter()->StartTag(ATL_HTML_TAG_BDO, szContent, Attrs);
	}

	HRESULT bdoEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BDO);
	}

	HRESULT big(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BIG, szContent, szAttrs);
	}

	HRESULT bigEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BIG);
	}

	HRESULT button(LPCTSTR szName=NULL, LPCTSTR szValue=NULL, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_BUTTON, szContent, Attrs);
	}

	HRESULT buttonEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BUTTON);
	}

	HRESULT iframe(LPCTSTR szSrc=NULL, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szSrc && *szSrc)
			Attrs.Add(_T("src"), szSrc);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		return GetOuter()->StartTag(ATL_HTML_TAG_IFRAME, NULL, Attrs);
	}

	HRESULT iframeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_IFRAME);
	}

	HRESULT label(LPCTSTR szFor=NULL, LPCTSTR szAccessKey=NULL, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szFor && *szFor)
			Attrs.Add(_T("for"), szFor);
		if (szAccessKey && *szAccessKey)
			Attrs.Add(_T("accesskey"), szAccessKey);
		return GetOuter()->StartTag(ATL_HTML_TAG_LABEL, szContent, Attrs);
	}

	HRESULT labelEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LABEL);
	}

	HRESULT link(LPCTSTR szRel=NULL, LPCTSTR szHref=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szRel && *szRel)
			Attrs.Add(_T("rel"), szRel);
		if (szHref && *szHref)
			Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_LINK, NULL, Attrs);
	}

	HRESULT meta(LPCTSTR szName=NULL, LPCTSTR szContent=NULL, LPCTSTR szHttpEquiv=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szContent && *szContent)
			Attrs.Add(_T("content"), szContent);
		if (szHttpEquiv && *szHttpEquiv)
			Attrs.Add(_T("http-equiv"), szHttpEquiv);
		return GetOuter()->StartTag(ATL_HTML_TAG_META, NULL, Attrs);
	}

	HRESULT metaEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_META);
	}

	HRESULT noframes(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_NOFRAMES, szContent, szAttrs);
	}

	HRESULT noframesEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_NOFRAMES);
	}

	HRESULT noscript(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_NOSCRIPT, szContent, szAttrs);
	}

	HRESULT noscriptEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_NOSCRIPT);
	}

	HRESULT col(int nSpan=1, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szVAlign=NULL,
		LPCTSTR szHAlign=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);


		if (nSpan != 1)
			Attrs.AddFormat(_T("span"), _T("\"%d\""), nSpan);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		if (szVAlign && *szVAlign)
			Attrs.Add(_T("valign"), szVAlign);
		if (szHAlign && *szHAlign)
			Attrs.Add(_T("align"), szHAlign);
		return GetOuter()->StartTag(ATL_HTML_TAG_COL, NULL, Attrs);
	}

	HRESULT colgroup(int nSpan=1, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szVAlign=NULL,
		LPCTSTR szHAlign=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (nSpan != 1)
			Attrs.AddFormat(_T("span"), _T("\"%d\""), nSpan);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		if (szVAlign && *szVAlign)
			Attrs.Add(_T("valign"), szVAlign);
		if (szHAlign && *szHAlign)
			Attrs.Add(_T("align"), szHAlign);
		return GetOuter()->StartTag(ATL_HTML_TAG_COL, NULL, Attrs);
	}

	HRESULT colgroupEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_COLGROUP);
	}

	HRESULT fieldset(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_FIELDSET, NULL, szAttrs);
	}

	HRESULT fieldsetEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_FIELDSET);
	}

	HRESULT legend(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_LEGEND, szContent, szAttrs);
	}

	HRESULT legendEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LEGEND);
	}

	HRESULT tbody(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TBODY, NULL, szAttrs);
	}

	HRESULT tbodyEnd()
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TBODY);
	}

	HRESULT tfoot(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TFOOT, NULL, szAttrs);
	}

	HRESULT tfootEnd()
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TFOOT);
	}

	HRESULT th(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (!m_tableState.m_bRowOpen)
			GetOuter()->tr();
		m_tableState.m_bDataOpen = true;
		return GetOuter()->StartTag(ATL_HTML_TAG_TH, szContent, szAttrs);
	}

	HRESULT thEnd()
	{
		ATLASSERT(m_tableState.m_bDataOpen);
		m_tableState.m_bDataOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TH);
	}

	HRESULT title(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TITLE, szContent, szAttrs);
	}

	HRESULT titleEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TITLE);
	}

	HRESULT tt(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TT, szContent, szAttrs);
	}

	HRESULT ttEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TT);
	}

	// unfortunately, we can't use small since it is defined as char
	// in rpcndr.h!
	HRESULT _small(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SMALL, szContent, szAttrs);
	}

	HRESULT _smallEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SMALL);
	}

	HRESULT span(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SPAN, szContent, szAttrs);
	}

	HRESULT spanEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SPAN);
	}

	HRESULT object(LPCTSTR szClassId, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);
		if (szClassId && *szClassId)
			Attrs.Add(_T("classid"), szClassId);
		return GetOuter()->StartTag(ATL_HTML_TAG_OBJECT, szContent, Attrs);
	}

	HRESULT object(REFCLSID rclsid, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		USES_CONVERSION;
		OLECHAR szClsid[64];
		CString strClassId;
		int i = StringFromGUID2(rclsid, szClsid, 64);
		if (i<3)
			return E_FAIL;
		szClsid[i-2] = 0; // don't want curly braces
		strClassId.Format(_T("clsid:%s"), OLE2T(szClsid+1));
		return object(strClassId, szContent, szAttrs);
	}

	HRESULT objectEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OBJECT);
	}

	HRESULT param(LPCTSTR szName, LPCTSTR szValue, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_PARAM, NULL, Attrs);
	}
};

class CHtmlGen : public CHtmlGenBase<CHtmlGen>
{
public:
};

class CStreamOnWriteStream : public IStream
{
public:
	IWriteStream *m_pWriteStream;

	CStreamOnWriteStream()
	{
		m_pWriteStream = NULL;
	}

	void Init(IWriteStream *pWriteStream)
	{
		m_pWriteStream = pWriteStream;
	}

	// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
	{
		if (!ppv)
			return E_POINTER;

		*ppv = NULL;

		if (IsEqualGUID(riid, IID_IUnknown) ||
			IsEqualGUID(riid, IID_IStream) ||
			IsEqualGUID(riid, IID_ISequentialStream))
		{
			*ppv = (IStream *) this;
		}
		if (!*ppv)
			return E_NOINTERFACE;
		return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		return 1;
	}

	ULONG __stdcall Release()
	{
		return 1;
	}

	// ISequentialStream methods
    HRESULT STDMETHODCALLTYPE Read(void * /*pDest*/, ULONG /*dwMaxLen*/, ULONG * /*pdwRead*/)
	{
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE Write(const void *pv, ULONG cb, ULONG *pcbWritten)
	{
		ATLASSERT(m_pWriteStream);
		HRESULT hr = m_pWriteStream->WriteStream((const char *) pv, cb, pcbWritten);
		return (hr==S_OK) ? S_OK : STG_E_WRITEFAULT;
	}
	
	// IStream methods
    HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER /*dlibMove*/, DWORD /*dwOrigin*/, ULARGE_INTEGER * /*plibNewPosition*/)
	{
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER /*libNewSize*/) 
	{
		return E_NOTIMPL;
	}
    
    HRESULT STDMETHODCALLTYPE CopyTo(IStream * /*pstm*/, ULARGE_INTEGER /*cb*/, ULARGE_INTEGER * /*pcbRead*/, ULARGE_INTEGER * /*pcbWritten*/)
	{
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE Commit(DWORD /*grfCommitFlags*/)
	{
		return E_NOTIMPL;
	}
    
    HRESULT STDMETHODCALLTYPE Revert(void)
	{
		return E_NOTIMPL;
	}
    
    HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
	{
		return E_NOTIMPL;
	}
		
    HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
	{
		return E_NOTIMPL;
	}
    
    HRESULT STDMETHODCALLTYPE Stat(STATSTG * /*pstatstg*/, DWORD /*grfStatFlag*/)
	{
		return E_NOTIMPL;
	}

    
    HRESULT STDMETHODCALLTYPE Clone(IStream ** /*ppstm*/)
	{
		return E_NOTIMPL;
	}
};

} // namespace ATL

#endif // __ATLHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlhttp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTTP_H__
#define __ATLHTTP_H__

#pragma once
#ifndef __CPPUNWIND
#pragma warning(push)
#pragma warning(disable: 4702)
#endif
#ifndef _WINSOCKAPI_
	#include <winsock2.h>
#endif
#include <atlutil.h>
#include <atlcoll.h>
#include <atlfile.h>
#define SECURITY_WIN32
#include <security.h>
#include <atlenc.h>
#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "SECUR32.LIB")
#endif  // !_ATL_NO_DEFAULT_LIBS

#include <atlspriv.h>

namespace ATL {

template <class TSocketClass>
class CAtlHttpClientT;
class CAtlBaseAuthObject;

enum status_headerparse{
				ATL_HEADER_PARSE_COMPLETE=0,
				ATL_HEADER_PARSE_HEADERNOTCOMPLETE,
				ATL_HEADER_PARSE_HEADERERROR
};

enum readstate{rs_init=0, rs_readheader, rs_scanheader, rs_readbody, rs_complete};

#define ATL_DEFAULT_DATA_TYPE _T("application/x-www-form-urlencoded")
#define ATL_HEADER_END "\r\n\r\n"
#define ATL_HEADER_END_LEN 4
#define ATL_DW_HEADER_END 0x0a0d0a0d
#define ATL_FIELDNAME_DELIMITER _T(':')
#define ATL_MAX_FIELDNAME_LEN 1024
#define ATL_MAX_VALUE_LEN 1024
#define ATL_AUTH_HDR_SIZE 1024
#define ATL_READ_BUFF_SIZE 2048
#define ATL_INVALID_STATUS -1
#define ATL_HTTP_HEADER _T(" HTTP/1.1\r\n")
#define ATL_HTTP_HEADER_PROXY _T(" HTTP/1.1\r\n")
#define ATL_HTTP_FOOTER \
					_T("User-Agent: Microsoft-ATL-Native/7.00\r\n")

#define ATL_IS_INVALIDCREDHANDLE(x) ((x.dwLower==0xFFFFFFFF) && (x.dwUpper==0xFFFFFFFF))					
#define ATL_HTTP_AUTHTYPE_NTLM _T("NTLM")
#define ATL_HTTP_AUTHTYPE_BASIC _T("BASIC")
#define ATL_HTTP_METHOD_GET _T("GET")
#define ATL_HTTP_METHOD_POST _T("POST")
#define CHUNK_BUFF_SIZE 2048

#ifndef ATL_MAX_DOMAIN
	#define ATL_MAX_DOMAIN 64
#endif

#ifndef ATL_MAX_USERNAME
	#define ATL_MAX_USERNAME 64
#endif

#ifndef ATL_MAX_PWD
	#define ATL_MAX_PWD 64
#endif

#ifndef MAX_REALM_LEN
	#define MAX_REALM_LEN 1024
#endif

#define ATL_MAX_BASIC_ID_LEN (ATL_MAX_USERNAME + ATL_MAX_PWD + 2)

__interface IAuthInfo;
typedef bool (WINAPI *PFNATLCHUNKEDCB)(BYTE** ppData, DWORD *pdwSize);
typedef bool (WINAPI *PFNATLSTATUSCALLBACK)(DWORD dwBytesSent, DWORD dwCookie);

#define ATL_HTTP_FLAG_AUTO_REDIRECT				0x1
#define ATL_HTTP_FLAG_PROCESS_RESULT			0x2
#define ATL_HTTP_FLAG_SEND_CALLBACK				0x4
#define ATL_HTTP_FLAG_SEND_CHUNKS				0x8
#define ATL_HTTP_FLAG_INVALID_FLAGS				0xFFFFFFFF

#ifndef ATL_HTTP_DEFAULT_CHUNK_SIZE
	#define ATL_HTTP_DEFAULT_CHUNK_SIZE 4096
#endif

struct ATL_NAVIGATE_DATA
{
	LPCTSTR szExtraHeaders;
	LPCTSTR szMethod;
	LPCTSTR szDataType;
	DWORD dwDataLen;
	DWORD dwFlags;
	DWORD dwTimeout;
	DWORD dwSendChunkSize;
	DWORD dwReadChunkSize;
	DWORD m_lParamSend;
	DWORD m_lParamRead;
	short nPort;
	BYTE *pData;
	PFNATLCHUNKEDCB pfnChunkCallback;
	PFNATLSTATUSCALLBACK pfnSendStatusCallback;
	PFNATLSTATUSCALLBACK pfnReadStatusCallback;
};

class CAtlNavigateData : public ATL_NAVIGATE_DATA
{
public:
	CAtlNavigateData() throw(); // public construction
	DWORD SetFlags(DWORD dwNewFlags) throw(); // set all flags
	DWORD GetFlags() throw(); // get value of flags
	DWORD AddFlags(DWORD dwFlagsToAdd) throw(); // add one or more flags to existing flags
	DWORD RemoveFlags(DWORD dwFlagsToRemove) throw(); // remove one or more flags from existing flags
	LPCTSTR SetExtraHeaders(LPCTSTR szNewHeaders) throw(); // set the extra request headers
	LPCTSTR GetExtraHeaders() throw(); // get the extra request headers
	LPCTSTR SetMethod(LPCTSTR szNewMethod) throw(); // set the HTTP request method
	LPCTSTR GetMethod() throw(); // get the HTTP request method
	short SetPort(short newPort) throw(); // set the TCP port for this request
	short GetPort() throw(); // get the TCP port for this request
	void SetData(BYTE *pData, DWORD dwDataLen, LPCTSTR szDataType) throw(); // Set data to be sent as the reqeust entity body
	DWORD SetSocketTimeout(DWORD dwNewTimeout) throw(); // Set the timeout for this socket
	DWORD GetSocketTimeout() throw(); // Get the timeout for this socket
	DWORD SetSendChunkSize(DWORD dwChunkSize) throw(); // Set the size of the chunks used to send data
	DWORD GetSendChunkSize() throw(); // get the size of the chunks used to send data
	DWORD SetReadChunkSize(DWORD dwChunkSize) throw(); // Set the size of the chunks used to send data
	DWORD GetReadChunkSize() throw(); // get the size of the chunks used to send data
	PFNATLCHUNKEDCB SetChunkCallback(PFNATLCHUNKEDCB pfn) throw(); // set the callback function used for sending chunked data
	PFNATLCHUNKEDCB GetChunkCallback() throw(); // get the chunked callback function
	PFNATLSTATUSCALLBACK SetSendStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD dwData) throw(); // sets a function pointer to be called after bytes are sent over the socket
	PFNATLSTATUSCALLBACK GetSendStatusCallback() throw(); // returns current status callback function
	PFNATLSTATUSCALLBACK SetReadStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD dwData) throw();
	PFNATLSTATUSCALLBACK GetReadStatusCallback() throw();
};

template <class TSocketClass>
class CAtlHttpClientT : 
	private TSocketClass
{
public:
	CAtlHttpClientT() throw();

	// Use these functions to send an HTTP request and retrieve
	// the response.
	bool Navigate(
				const CUrl* pUrl,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw();

	bool Navigate(
				LPCTSTR szServer,
				LPCTSTR szPath,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw();

	bool Navigate(
				LPCTSTR szURL,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw();


	// Performs navigation, sending data with Transfer-Coding: chunked
	bool NavigateChunked(
			LPCTSTR szURL,
			PFNATLCHUNKEDCB,
			DWORD dwFlags=ATL_HTTP_FLAG_AUTO_REDIRECT,
			LPCTSTR szExtraHeaders=NULL,
			LPCTSTR szMethod=ATL_HTTP_METHOD_GET,
			short nPort=ATL_URL_DEFAULT_HTTP_PORT,
			LPCTSTR szDataType=NULL,
			bool bProcessResult=true
			) throw();

	// Use to set/retrieve information about the proxy server used
	// when making this request via a proxy server.
	BOOL SetProxy(LPCTSTR szProxy = NULL, short nProxyPort = 0) throw();
	void RemoveProxy() throw();
	LPCTSTR GetProxy() const throw();

	// Use these functions to add/remove/find objects that will 
	// be used to authorize request when a 401 Not Authorized response
	// is received. This class maps these objects by scheme name in map.
	// Override NegotiateAuth to change the way authorization negotiation occurs.
	bool AddAuthObj(LPCTSTR szScheme, CAtlBaseAuthObject *pObject, IAuthInfo *pInfo=NULL) throw();
	const CAtlBaseAuthObject* FindAuthObject(LPCTSTR szScheme) throw();
	bool RemoveAuthObject(LPCTSTR szScheme) throw();
	virtual bool NegotiateAuth(bool bProxy) throw();
	

	// Retrieve the value of a response header
	bool GetHeaderValue(LPCTSTR szName, CString& strValue) const throw(); 
	bool GetHeaderValue(LPCTSTR szName, LPTSTR szBuffer, int *pdwLen) const throw();

	const int GetResponseLength() throw(); // Get the number of bytes in the response
	const BYTE* GetResponse() throw(); // Get the entire response
	DWORD GetBodyLength() const throw(); // Get the length of the body of the response (everything after the \r\n\r\n)
	const BYTE* GetBody() throw(); // Get the body of the response (length is determined by GetBodyLength())
	DWORD GetRawRequestHeaderLength() throw(); // Get the length of the raw request headers
	bool GetRawRequestHeaders(LPBYTE szBuffer, int *pdwLen) throw(); // Get the raw request headers
	LPCURL GetCurrentUrl() const throw(); // Get a pointer to the current URL for this request
	void SetFlags(DWORD dwFlags) throw(); // Set flags used for processing this request
	DWORD GetFlags() const throw(); // Retrieve flags used for processing this request
	int GetStatus() throw(); // Get the HTTP status code that resulted from making this request
	LPCTSTR GetMethod() throw(); // Get the HTTP method used for making this request
	BYTE* GetData() throw(); // Get a pointer to raw data being sent with this request
	DWORD GetDataLen() throw(); // Get the length of the raw data sent with this request
	LPCTSTR GetDataType() throw(); // Get the data type (sent as Content-Type header) for this request
	DWORD GetLastError() throw(); // Retrieves errors from the underlying socket
	const SOCKET& GetSocket() throw(); // Retrieves the underlying socket. Be careful!
	void Close(); // Close the connection
	DWORD SetSocketTimeout(DWORD dwNewTimeout); // Sets a new socket timeout, returns the old timeout.
	DWORD GetSocketTimeout(); // retrieves the current socket timeout
	void AuthProtocolFailed(LPCTSTR szProto); // notifies us of failure to connect with the named protocol

// Implementation
	enum HTTP_RESPONSE_READ_STATUS
	{
		RR_OK = 0, // response was successfully processed
		RR_FAIL, // an unknown error occurred reading the HTTP response
		RR_STATUS_INVALID, // could not parse the status line
		RR_PARSEHEADERS_FAILED, // failed to parse HTTP response headers
		RR_READSOCKET_FAILED, // failed to read response data from socket
		RR_READBODY_FAILED, // failed to successfully read the entity body of the HTTP response
		RR_READCHUNKEDBODY_FAILED // failed to read a 'Transfer-Encoding: chunked' response body
	};
	HTTP_RESPONSE_READ_STATUS ReadHttpResponse() throw();
	void ResetConnection() throw();
	bool ProcessStatus(DWORD dwFlags) throw();
	bool BuildRequest(/*out*/CString *pstrRequest,
						LPCTSTR szMethod,
						LPCTSTR szServer,
						LPCTSTR szPath,
						LPCTSTR szExtraInfo=NULL,
						const BYTE* pData=NULL,
						DWORD dwDataLen=0,
						LPCTSTR szDataType=NULL,
						LPCTSTR szExtraHeaders=NULL) throw();

protected:
	DWORD WriteWithNoData(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithCallback(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithChunks(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithData(LPCSTR pRequest, DWORD dwRequestLen);
	bool SetDefaultUrl(LPCTSTR szUrl, short nPortNumber=ATL_URL_DEFAULT_HTTP_PORT) throw();
	bool SetDefaultUrl(LPCURL pUrl, short nPortNumber=ATL_URL_DEFAULT_HTTP_PORT) throw();
	bool SetDefaultMethod(LPCTSTR szMethod) throw();
	void InitializeObject() throw();
	bool ReadSocket() throw();
	unsigned char* FindHeaderEnd(unsigned char** ppBegin) throw();
	bool LookupRegProxy() throw();
	bool DisconnectIfRequired() throw();
	bool ConnectSocket() throw();

	long GetContentLength() throw();
	LPCSTR NextLine(BYTE* pCurr) throw();
	bool IsMsgBodyChunked() throw();
	LPCSTR FindEndOfHeader(LPCSTR pszStart) throw();
	bool DecodeHeader(LPCSTR pHeaderStart, LPCSTR pHeaderEnd) throw();
	virtual void OnSetCookie(LPCTSTR /*szCookie*/) throw();
	LPCSTR ParseStatusLine(BYTE* pBuffer) throw();
	int CrackResponseHeader(LPCSTR pBuffer, /*out*/ LPCSTR *pEnd) throw();
	bool ReadBody(int nContentLen, int nCurrentBodyLen) throw();
	bool ReadChunkedBody() throw();
	bool ReconnectIfRequired() throw();
	bool CompleteURL(CString& strURL) throw();
	bool ProcessObjectMoved() throw();
	bool _SetDefaultUrl(LPCTSTR szURL, short nPort) throw();

	enum CHUNK_STATE{
		READ_CHUNK_SIZE, // need to read the size of a chunk.
		READ_CHUNK_SIZE_FOOTER,
		READ_CHUNK_DATA, // need to read the actual data
		READ_CHUNK_DATA_FOOTER, // need to read the chunk footer.
		READ_CHUNK_TRAILER, // Read the trailer headers at the end of the chunk data
		READ_CHUNK_TRAILER_FOOTER, // read the final crlf
		CHUNK_READ_DATA_COMPLETE, // done reading chunk data.
	};

	enum CHUNK_LEX_RESULT{
		LEX_OK,
		LEX_OUTOFDATA,
		LEX_ERROR,
		LEX_TRAILER_COMPLETE
	};

	CHUNK_LEX_RESULT get_chunked_size(char *&pBuffStart, char *&pBuffEnd, long* pnChunkSize);
	bool move_leftover_bytes(char *pBufferStart, int nLen, char *&pBuffStart, char *&pBuffEnd);
	CHUNK_LEX_RESULT get_chunked_data(char *&pBufferStart, char *&pBufferEnd, long nChunkSize,
								  char **ppDataStart, long *pnDataLen);
	CHUNK_LEX_RESULT consume_chunk_trailer(char *&pBufferStart, char *pBufferEnd);
	CHUNK_LEX_RESULT consume_chunk_footer(char *&pBufferStart, char *&pBufferEnd);

	typedef CAtlMap< 
				CString,
				CString,
				CStringElementTraitsI<CString>,
				CStringElementTraitsI<CString>
			   > HeaderMapType;

	typedef CAtlMap <
				CString,
				CAtlBaseAuthObject*,
				CStringElementTraitsI<CString>
				> AuthMapType;

	typedef CAtlArray<
				CString,
				CStringElementTraitsI<CString>
				> AuthListType;

	HeaderMapType m_HeaderMap; // Map of response headers
	AuthMapType m_AuthMap; // Map of pointers to authorization objects.
	AuthListType m_AuthTypes; // list of authorization types the server is willing to use.
	CAtlIsapiBuffer<> m_current; // The entire response
	CUrl m_urlCurrent; // URL of current request

	CString m_strMethod; // Current request method.
	CString m_strProxy; // Path to current proxy server.
	CString m_strDataType; // If this is a post, this contains the data type of the data

	long m_nStatus; // Current response status (from status line)
	short m_nProxyPort; // Port used on current proxy server
	DWORD m_dwBodyLen; // Length of body
	DWORD m_dwHeaderLen; // Length of current raw headers
	DWORD m_dwHeaderStart;
	BYTE *m_pData; // Pointer to data sent with request (warning: we don't make our own copy of the data!)
	DWORD m_dwDataLen; // Length of current data in bytes
	DWORD m_dwFlags; // Flags that describe the request.
	BYTE *m_pCurrent;
	ATL_NAVIGATE_DATA *m_pNavData;
	HTTP_RESPONSE_READ_STATUS m_LastResponseParseError;
}; //CAtlHttpClientT
typedef CAtlHttpClientT<ZEvtSyncSocket> CAtlHttpClient;


// Interface used to acquire authentication information from clients
__interface IAuthInfo
{
	bool GetPassword(LPTSTR szPwd, DWORD dwBuffSize);
	bool GetUsername(LPTSTR szUid, DWORD dwBuffSize);
	bool GetDomain(LPTSTR szDomain, DWORD dwBuffSize);
};

// pure virtual class that describes required functions for authoriztion
// objects
class CAtlBaseAuthObject
{
public:
	CAtlBaseAuthObject();
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) = 0;
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo) = 0;
	bool m_bFailed;
};

// strings used for authentication.
__declspec(selectany)const TCHAR *g_pszWWWAuthenticate = _T("www-authenticate");
__declspec(selectany)const TCHAR *g_pszProxyAuthenticate = _T("proxy-authenticate");

// Performs NTLM authentication
class CNTLMAuthObject :
	public CAtlBaseAuthObject
{
public:
	~CNTLMAuthObject() throw();
	CNTLMAuthObject() throw();
	CNTLMAuthObject(IAuthInfo *pAuthInfo) throw();
	void SetAuthInfo(IAuthInfo *pAuthInfo) throw();
	
	// Called by the CAtlHttpClient class to authenticate a user.
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo=NULL) throw();
	
	// Called by the CAtlHttpClient class to initialize this authentication object.
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw();

// Implementation
protected:
	bool AcquireCredHandle() throw();
	// This function creates an NTML Authorization header
	// and sends it to the HTTP server.
	bool SendSecurityInfo(SecBuffer *pSecBuffer, LPSTR *pszBuffer);
	bool DoNTLMAuthenticate() throw();

	IAuthInfo *m_pAuthInfo;
	CAtlHttpClient *m_pSocket;
	CredHandle m_hCredentials;
	int m_nMaxTokenSize;
	TimeStamp m_ts;
	bool m_bProxy;
	static const char *m_pszFmtWWW;
	static const char *m_pszFmtProxy;

}; // CNTLMAuthObject

// Performs BASIC authentication for an CAtlHttpClient
// object. Caller must implement an IAuthInfo interface
// and pass it to this object before this object attempts
// to authenticate or authentication will fail.
class CBasicAuthObject : 
	public CAtlBaseAuthObject
{
public:
	CBasicAuthObject() throw();
	CBasicAuthObject(IAuthInfo *pAuthInfo) throw();
	void SetAuthInfo(IAuthInfo *pAuthInfo) throw();
	LPCTSTR GetRealm() throw(); // Retrieve's the realm being used.

	// Called by the CAtlHttpClient class to authenticate a user.
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw();

	// Called by the CAtlHttpClient class to initialize this authentication object.
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo=NULL) throw();
protected:
	bool DoBasicAuthenticate() throw();
	void CrackRealm(LPTSTR szHeader) throw();

	IAuthInfo *m_pAuthInfo;
	CAtlHttpClient *m_pClient;
	TCHAR m_szRealm[MAX_REALM_LEN];
	bool m_bProxy;
	static const char *m_pszFmtWWW;
	static const char *m_pszFmtProxy;
}; // CBasicAuthObject

__declspec(selectany)const char *CBasicAuthObject::m_pszFmtWWW = "Authorization: Basic ";
__declspec(selectany)const char *CBasicAuthObject::m_pszFmtProxy = "Proxy-Authorization: Basic ";
__declspec(selectany)const char *CNTLMAuthObject::m_pszFmtWWW = "Authorization: NTLM %s\r\n";
__declspec(selectany)const char *CNTLMAuthObject::m_pszFmtProxy = "Proxy-Authorization: NTLM %s\r\n";


//
// Security Service Provider Interface (sspi) Helper classes
// These classes are used as helpers for structures used in 
// SSPI functions.
//
class CSecAuthIdentity : public SEC_WINNT_AUTH_IDENTITY_EX
{
public:
	CSecAuthIdentity() throw()
	{
		Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
		Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EX);
#ifdef _UNICODE
		Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
		Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif
	}

	bool Init(IAuthInfo *pAuthInfo) throw()
	{
		if (!pAuthInfo)
			return false;

		if (!pAuthInfo->GetUsername(szUserName, ATL_MAX_USERNAME))
			return false;

		if (!pAuthInfo->GetPassword(szPassword, ATL_MAX_PWD))
			return false;

		if (!pAuthInfo->GetDomain(szDomain, ATL_MAX_DOMAIN))
			return false;
#ifndef _UNICODE
		User = (unsigned char*)szUserName;
		Domain = (unsigned char*)szDomain;
		Password = (unsigned char*)szPassword;
#else
		// have to cast to unsigned short *, because SEC_WINNT_AUTH_IDENTITY_EXW
		// uses unsigned short instead of wchar_t for some reason
		User = (unsigned short *)szUserName;
		Domain = (unsigned short *)szDomain;
		Password = (unsigned short *)szPassword;
#endif
		UserLength = (DWORD)_tcslen(szUserName);
		DomainLength = (DWORD)_tcslen(szDomain);
		PasswordLength = (DWORD)_tcslen(szPassword);
		return true;
	}

protected:
	TCHAR szUserName[ATL_MAX_USERNAME];
	TCHAR szPassword[ATL_MAX_PWD];
	TCHAR szDomain[ATL_MAX_DOMAIN];
}; // CSecAuthIdentity

class CSecBuffer : public SecBuffer
{
public:
	CSecBuffer() throw()
	{
		cbBuffer = 0;
		BufferType = 0;
		pvBuffer = NULL;
	}

	~CSecBuffer() throw()
	{
		if (pvBuffer)
			delete [] static_cast<unsigned char*>(pvBuffer);
	}

	bool SetSize(unsigned int nSize) throw()
	{
		if (!nSize)
			return false;

		if (pvBuffer)
		{
			delete [] static_cast<unsigned char*>(pvBuffer);
			pvBuffer = NULL;
			cbBuffer = 0;
		}

		ATLTRY(pvBuffer = static_cast<void*>(new unsigned char[nSize]));
		if (pvBuffer)
		{
			cbBuffer = nSize;
			BufferType = SECBUFFER_TOKEN;
			return true;
		}
		return false;
	}

	void ClearBuffer(int nSize) throw()
	{
		ZeroMemory(pvBuffer, min((int)cbBuffer, nSize));
		cbBuffer = nSize;
	}

	unsigned long Size()
	{
		return cbBuffer;
	}

	unsigned char *Buffer() throw()
	{
		return static_cast<unsigned char*>(pvBuffer);
	}

	operator SecBuffer*() throw()
	{
		return (SecBuffer*)this;
	}
}; // CSecBuffer

class CSecBufferDesc : public SecBufferDesc
{
public:
	CSecBufferDesc() throw()
	{
		ulVersion = SECBUFFER_VERSION;
		cBuffers = 0;
		pBuffers = NULL;
	}

	~CSecBufferDesc() throw()
	{
		cBuffers = 0;
		
		if (pBuffers)
		{
			CSecBuffer *psb = (CSecBuffer*)pBuffers;
			delete [] psb;
		}
	}

	CSecBuffer* Buffers(unsigned int i) throw()
	{
		CSecBuffer *pBuffer = (CSecBuffer*)(&pBuffers[i]);
		return pBuffer;
	}

	bool AddBuffers(unsigned int nCount, unsigned int nBufferSize) throw()
	{
		if (!nCount)
			return true;

		if (cBuffers == 0)
		{
			CSecBuffer *pSecBuffer = NULL;
			ATLTRY(pSecBuffer = new CSecBuffer[nCount]);
			if (!pSecBuffer)
				return false;
			for (unsigned int i=0; i<nCount; i++)
			{
				if (!pSecBuffer[i].SetSize(nBufferSize))
					return false;
			}
			cBuffers = nCount;
			pBuffers = (SecBuffer*)pSecBuffer;
		}
		else // realloc
		{
			CSecBuffer *pSecBuffer = NULL;
			ATLTRY(pSecBuffer = new CSecBuffer[nCount + cBuffers]);
			if (!pSecBuffer)
				return false;
			memcpy(pSecBuffer, pBuffers, sizeof(CSecBuffer)*cBuffers);
			delete [] pBuffers;

			// initialize new buffers
			for (unsigned int i=0; i<nCount; i++)
			{
				if (!pSecBuffer[cBuffers+i].SetSize(nBufferSize))
					return false;
			}
			pBuffers = pSecBuffer;
			cBuffers = nCount + cBuffers;
		}
		return true;
	}

	operator PSecBufferDesc() throw()
	{
		return static_cast<PSecBufferDesc>(this);
	}
}; // CSecBufferDesc

#include <atlhttp.inl>
#ifndef __CPPUNWIND
#pragma warning(pop)
#endif
} // ATL

#endif // __ATLHTTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlhttp.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTTP_INL__
#define __ATLHTTP_INL__




/////////////////////////////////////////////////////////////////////////////////
//
// CAtlHttpClient
// Implementation of CAtlHttpClient member functions
//
/////////////////////////////////////////////////////////////////////////////////
template <class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CAtlHttpClientT()
{
    InitializeObject();
}

// Sets this object to a known state.
template <class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::InitializeObject() 
{
    Close(); // will close the socket if it's already open

    // reset all data that has to do with the current request
    m_HeaderMap.RemoveAll();
    m_AuthMap.RemoveAll();
    m_current.Empty();
    m_urlCurrent.Clear();

    m_strMethod.Empty();
    m_strProxy.Empty();
    m_strDataType.Empty();

    m_nStatus = ATL_INVALID_STATUS;
    m_nProxyPort = ATL_URL_INVALID_PORT_NUMBER;
    m_dwBodyLen = 0;
    m_dwHeaderLen = 0;
    m_dwHeaderStart = 0;
    m_pData = NULL;
    m_dwDataLen = 0;
    m_dwFlags = 0;
    m_pCurrent = NULL;
    m_pNavData = NULL;
    m_LastResponseParseError = RR_OK;
}


// Use this function to retrieve an entity from a server via an HTTP
// request. This function will either request a connection from the
// server specified in the szURL parameter or request a connection from
// the proxy server. If a proxy server is to be used, you must call
// SetProxy prior to calling this function to specify the proxy server
// being used. Once the connection is established, an HTTP request 
// is built and sent to the HTTP server. An attempt to read the HTTP
// response is then made. If the response is successfully read, the
// response will be parsed and stored in this class instance. The 
// headers can be parsed via the LookupHeader function and the body
// of the respone can be retrieved using the GetBody function. You
// can also retrieve the contents of the entire response by calling
// GetResponse.
template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(
                const CUrl* pUrl,
                ATL_NAVIGATE_DATA *pNavData
            )
{
    if (!pUrl)
        return false;

    TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
    DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
    if (!pUrl->CreateUrl(szUrl, &dwMaxLen))
        return false;

    // Navigate
    return Navigate(szUrl, pNavData);

}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(
            LPCTSTR szServer,
            LPCTSTR szPath, 
            ATL_NAVIGATE_DATA *pNavData
            )
{
    // Create a URL
    CUrl url;
    url.SetScheme(ATL_URL_SCHEME_HTTP);
    url.SetHostName(szServer);
    url.SetUrlPath(szPath);
    if (pNavData)
        url.SetPortNumber(pNavData->nPort); 
    else
        url.SetPortNumber(ATL_URL_DEFAULT_HTTP_PORT);

    TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
    DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
    if (!url.CreateUrl(szUrl, &dwMaxLen))
        return false;

    // Navigate
    return Navigate(szUrl, pNavData);
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(
            LPCTSTR szURL,
            ATL_NAVIGATE_DATA *pData
            ) 
{
    bool bRet = false;
    CAtlNavigateData default_nav_data;
    if (!pData)
        m_pNavData = &default_nav_data;
    else
        m_pNavData = pData;

    ATLASSERT(m_pNavData);

    m_strMethod = m_pNavData->szMethod;
    m_dwFlags = m_pNavData->dwFlags;
    SetSocketTimeout(m_pNavData->dwTimeout);

    // set m_urlCurrent
    if (!SetDefaultUrl(szURL, m_pNavData->nPort))
        return false;
    DWORD dwSent = 0;
    CString strRequest;
    CString strExtraInfo;

    if (!BuildRequest(&strRequest, 
                    m_pNavData->szMethod,
                    m_urlCurrent.GetHostName(), 
                    m_urlCurrent.GetUrlPath(),
                    m_urlCurrent.GetExtraInfo(),
                    m_pNavData->pData,
                    m_pNavData->dwDataLen,
                    m_pNavData->szDataType,
                    m_pNavData->szExtraHeaders))
    {
        return false;
    }

    // m_dwDataLen is calculated in the previous call to BuildReqeust
    // dwAvailable represents the length in bytes of the data that
    // needs to be sent to the server. After the call to the socket's
    // Write function below, dwSent will contain the actual number of bytes
    // sent to the server
    // connect to either the proxy server or the real server
    if (!ConnectSocket())
        return false;

	LPCTSTR szTRequest = strRequest;
	CT2CA strARequest(szTRequest);
	DWORD dwRequestLen = (DWORD)strlen(strARequest);
	DWORD dwAvailable = dwRequestLen + m_dwDataLen;
	
    if (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK)
    {
        dwSent = WriteWithCallback(strARequest, dwRequestLen);
    }
    else if (!m_pData)
        dwSent = WriteWithNoData(strARequest, dwRequestLen);
    else if (m_pData && (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CHUNKS))
    {
        dwSent = WriteWithChunks(strARequest, dwRequestLen);
    }
    else if(m_pData)
    {
        dwSent = WriteWithData(strARequest, dwRequestLen);
    }

    
    // make sure everything was sent
    if (dwSent == dwAvailable)
    {
        // Read the response
        if (RR_OK == ReadHttpResponse())
        {
            // if navigation isn't complete, try to complete
            // it based on the status code and flags
            if ((m_pNavData->dwFlags & ATL_HTTP_FLAG_PROCESS_RESULT)&&
                !ProcessStatus(m_pNavData->dwFlags))
            {
                bRet = false;
            }
            else
                bRet = true;
        }
        else
            bRet = false;
    }

    if (!bRet)
        Close(); // some kind of failure happened, close the socket.

    m_pNavData = NULL;
    return bRet;

    
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithNoData(LPCSTR pRequest, DWORD dwRequestLen)
{
    ATLASSERT(m_pNavData);
    WSABUF Buffer;
    Buffer.buf = (char*)pRequest;
    Buffer.len = (int)dwRequestLen;
    DWORD dwWritten = 0;
    Write(&Buffer, 1, &dwWritten);
    if (m_pNavData->pfnSendStatusCallback)
        m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend);
    return dwWritten;
}

// The entity body will be retrieved from the client by calling their
// callback function.
template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithCallback(LPCSTR pRequest, DWORD dwRequestLen)
{
    ATLASSERT(m_pNavData);
    if (!(m_pNavData->pfnChunkCallback &&
        (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK)))
        return 0; // error, must have flag set and callback function

    // write the request
    DWORD dwTotalWritten = 0;
    WSABUF Buffer;
    Buffer.buf = (char*)pRequest;
    Buffer.len = (int)dwRequestLen;
    DWORD dwWritten = 0;
    Write(&Buffer, 1, &dwWritten);
    if (m_pNavData->pfnSendStatusCallback)
        if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
            return 0;
    if (!dwWritten)
        return 0; // failure
    dwTotalWritten += dwWritten;

    // start writing data;
    while (m_pNavData->pfnChunkCallback((BYTE**)&Buffer.buf, (DWORD*)&Buffer.len) &&
            Buffer.len > 0 &&
            Buffer.buf != NULL)
    {
        Write(&Buffer, 1, &dwWritten);
        if (dwWritten != Buffer.len)
            return 0;
        if (m_pNavData->pfnSendStatusCallback)
            if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
                return 0;
        dwTotalWritten += dwWritten;
    }
    return dwTotalWritten;
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithChunks(LPCSTR pRequest, DWORD dwRequestLen)
{
    ATLASSERT(m_pNavData);
    if (!(m_pNavData->dwSendChunkSize > 0 && (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CHUNKS)))
        return 0; // error, must have flag set and callback function

    // write the request
    DWORD dwTotalWritten = 0;
    WSABUF Buffer;
    Buffer.buf = (char*)pRequest;
    Buffer.len = (int)dwRequestLen;
    DWORD dwWritten = 0;
    Write(&Buffer, 1, &dwWritten);
    if (m_pNavData->pfnSendStatusCallback)
        if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
            return 0;
    if (!dwWritten)
        return 0; // failure
    dwTotalWritten += dwWritten;

    // start writing data;
    DWORD dwDataWritten = 0;
    DWORD dwDataLeft = m_pNavData->dwDataLen;
    while (dwDataLeft)
    {
        Buffer.buf = (char*)(m_pNavData->pData + dwDataWritten);
        Buffer.len = min(dwDataLeft, m_pNavData->dwSendChunkSize);
        Write(&Buffer, 1, &dwWritten);
        if (dwWritten != Buffer.len)
            return 0;
        if (m_pNavData->pfnSendStatusCallback)
            if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
                return false;
        dwTotalWritten += dwWritten;
        dwDataWritten += dwWritten;
        dwDataLeft -= dwWritten;
    }
    return dwTotalWritten;
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithData(LPCSTR pRequest, DWORD dwRequestLen)
{
    WSABUF Buffers[2];
    Buffers[0].buf = (char*)pRequest;
    Buffers[0].len = dwRequestLen;
    Buffers[1].buf = (char*)m_pNavData->pData;
    Buffers[1].len = m_pNavData->dwDataLen;
    
    DWORD dwWritten = 0;
    Write(Buffers, 2, &dwWritten);
    if (m_pNavData->pfnSendStatusCallback)
        m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend);

    return dwWritten;
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::NavigateChunked(
        LPCTSTR szURL,
        PFNATLCHUNKEDCB pfnCallback,
        DWORD dwFlags,
        LPCTSTR szExtraHeaders,
        LPCTSTR szMethod,
        short nPort,
        LPCTSTR szDataType,
        bool bProcessResult
        )
{
    bool bRet = true;
    if (!pfnCallback)
        return false;
    m_strMethod = szMethod;
    m_dwFlags = dwFlags;

    // set m_urlCurrent
    if (!SetDefaultUrl(szURL, nPort))
        return false;

    DWORD dwSent = 0;
    CString strRequest;
    CString strExtraInfo;
    
    if (!BuildRequest(&strRequest, szMethod,
                    m_urlCurrent.GetHostName(), 
                    m_urlCurrent.GetUrlPath(),
                    m_urlCurrent.GetExtraInfo(),
                    NULL, 0, szDataType,
                    szExtraHeaders))
    {
        return false;
    }

    WSABUF Buffers[3];

    _ATLTRY
    {
        CT2A pRequest(strRequest);

        Buffers[0].buf = (char*)pRequest;
        Buffers[0].len = strRequest.GetLength();

        // send the first buffer which is the request
        if (!Write(Buffers, 1, &dwSent))
        {
            Close();
            return false;
        }
    }
    _ATLCATCHALL()
    {
        Close();
        return false;
    }
    Buffers[0].buf = NULL;
    Buffers[0].len = 0;

    CStringA strChunkSize;

    Buffers[2].buf = "\r\n";
    Buffers[2].len = 2;
    int z = 0;
    
    // start sending the chunks
    do
    {
        z++;
        Buffers[1].buf = NULL;
        Buffers[1].len = 0;
        if (pfnCallback((BYTE**)&Buffers[1].buf, &Buffers[1].len))
        {
            _ATLTRY
            {
                if (Buffers[1].len > 0)
                {
                    // send the chunk
                    strChunkSize.Format("%x\r\n", Buffers[1].len);
                    Buffers[0].buf = (char*)(LPCSTR)strChunkSize;
                    Buffers[0].len = strChunkSize.GetLength();
                    if (!Write(Buffers, 3, &dwSent))
                    {
                        bRet = false;
                        break;
                    }
                }
                else if (Buffers[1].len == 0)
                {
                    strChunkSize = "0\r\n\r\n\r\n";
                    Buffers[0].buf = (char*)(LPCSTR)strChunkSize;
                    Buffers[0].len = strChunkSize.GetLength();
                    if (!Write(Buffers, 1, &dwSent))
                    {
                        bRet = false;
                        break;
                    }
                    break;
                }
            }
            _ATLCATCHALL()
            {
                bRet = false;
                break;
            }
        }
        else
        {
            bRet = false;
            break; // something went wrong in callback
        }
    }while (Buffers[1].len > 0);

    strRequest.ReleaseBuffer();

    if (bRet)
    {
        // Read the response
        if (RR_OK == ReadHttpResponse())
        {
            // if navigation isn't complete, try to complete
            // it based on the status code and flags
            if (bProcessResult && !ProcessStatus(dwFlags))
            {
                bRet = false;
            }
            bRet = true;
        }
        else
            bRet = false;
    }
    
    if (!bRet)
        Close();

    return bRet;
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ConnectSocket()
{
    // connect to the correct server
    if (GetProxy())
    {
        //if we're using a proxy connect to the proxy
        if (!Connect(m_strProxy, m_nProxyPort))
            return false;
    }
    else
        if (!Connect(m_urlCurrent.GetHostName(),
            m_urlCurrent.GetPortNumber())) // connect to the server
            return false;

    return true;
}


template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::BuildRequest(/*out*/CString *pstrRequest,
                                        LPCTSTR szMethod,
                                        LPCTSTR szServer,
                                        LPCTSTR szPath,
                                        LPCTSTR szExtraInfo,
                                        const BYTE* pData,
                                        DWORD dwDataLen,
                                        LPCTSTR szDataType,
                                        LPCTSTR szExtraHeaders) 
{
    _ATLTRY
	{
        // build up the request
        CString strRequest = szMethod;
        strRequest += _T(" ");
        if (GetProxy())
        {
            CUrl urlRequest;
            urlRequest.SetScheme(ATL_URL_SCHEME_HTTP);
            urlRequest.SetHostName(szServer);
            urlRequest.SetUrlPath(szPath);
            urlRequest.SetPortNumber(ATL_URL_DEFAULT_HTTP_PORT);

            TCHAR buffURL[ATL_URL_MAX_URL_LENGTH];
            DWORD dwSize = ATL_URL_MAX_URL_LENGTH;
            urlRequest.CreateUrl(buffURL, &dwSize);
            strRequest += buffURL;
            if (szExtraInfo)
                strRequest += szExtraInfo;

            strRequest += ATL_HTTP_HEADER_PROXY;
            CString strHost;
            strHost.Format(_T("Host: %s\r\n"), szServer);
            strRequest += strHost;

            if (dwDataLen>0)
            {
                CString strCL;
                strCL.Format(_T("Content-Length: %d\r\n"), dwDataLen);
                strRequest += strCL;
            }

            if (szDataType)
            {
                strRequest += _T("Content-Type: ");
                strRequest += szDataType;
                strRequest += _T("\r\n");
            }

            if (szExtraHeaders)
                strRequest += szExtraHeaders;
            strRequest += ATL_HTTP_FOOTER;
        }
        else
        {
            strRequest += szPath;
            if (szExtraInfo)
                strRequest += szExtraInfo;
            strRequest += ATL_HTTP_HEADER;

            if (dwDataLen>0)
            {
                CString strCL;
                strCL.Format(_T("Content-Length: %d\r\n"), dwDataLen);
                strRequest += strCL;
            }

            if (szDataType && *szDataType)
            {
                strRequest += _T("Content-Type: ");
                strRequest += szDataType;
                strRequest += _T("\r\n");
            }

            if (szExtraHeaders)
                strRequest += szExtraHeaders;


            CString strHost;
            strHost.Format(_T("Host: %s\r\n"), szServer);
            strRequest += strHost;
            strRequest += ATL_HTTP_FOOTER;
        }
        strRequest += _T("\r\n");

        if (dwDataLen && pData)
        {
            m_pData = (BYTE*)pData;
            m_dwDataLen = dwDataLen;
            m_strDataType = szDataType;
        }

        *pstrRequest = strRequest;
        return true;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadSocket()
{
    bool bRet = false;
    unsigned char read_buff[ATL_READ_BUFF_SIZE];
    int dwSize = ATL_READ_BUFF_SIZE;

    // read some data
    bRet = Read(read_buff, (DWORD*)&dwSize);
    if (bRet)
    {
        // notify user
        if (m_pNavData)
        {
            if (m_pNavData->pfnReadStatusCallback)
                bRet = m_pNavData->pfnReadStatusCallback(dwSize, m_pNavData->m_lParamRead);
            if (!bRet)
                return bRet;
        }
        if (dwSize > 0)
        {
            // append the data to our internal buffer
            // m_current holds bytes (not UNICODE!)
            m_current.Append((LPCSTR)read_buff, dwSize);
            if (!m_pCurrent)
                m_pCurrent = (BYTE*)(LPCSTR)m_current;
        }
        else
            bRet = false; // nothing was read
    }
    return bRet;
}

// Starts searching for a complete header set at
// m_pCurrent. This function will only move m_pCurrent
// if a complete set is found. Returns the header beginning
// optionally.
template <class TSocketClass>
inline unsigned char* CAtlHttpClientT<TSocketClass>::FindHeaderEnd(unsigned char** ppBegin)
{
    if (!m_pCurrent)
        return NULL;

    BYTE *pCurr = m_pCurrent;
    BYTE *pBegin = m_pCurrent;
    int nLen = m_current.GetLength();

    if (pCurr >= (BYTE*)(LPCSTR)m_current + m_current.GetLength())
        return NULL; // no more chars in buffer
    // look for the end of the header (the \r\n\r\n)
    while (pCurr < (pCurr + nLen - ATL_HEADER_END_LEN - 1))
    {
        if (*((DWORD*)pCurr) == ATL_DW_HEADER_END)
        {
            // set m_pCurrent pointer to the end of the header
            m_pCurrent = pCurr + ATL_HEADER_END_LEN;
            if (ppBegin)
                *ppBegin = pBegin;
            return m_pCurrent;
        }
        pCurr++;
    }
    return NULL;
}

// Call this function after sending an HTTP request over the socket. The complete
// HTTP response will be read. This function will also parse
// response headers into the response header map.
template <class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::HTTP_RESPONSE_READ_STATUS CAtlHttpClientT<TSocketClass>::ReadHttpResponse() 
{
    // Read until we at least have the response headers
    HTTP_RESPONSE_READ_STATUS result = RR_OK;
    readstate state = rs_init;
    unsigned char *pBodyBegin = NULL;
    unsigned char *pHeaderBegin = NULL;
    m_current.Empty();
    m_pCurrent = NULL;
    m_LastResponseParseError = RR_OK;

    while (state != rs_complete)
    {
        switch(state)
        {
        case rs_init:
            m_HeaderMap.RemoveAll();
            m_nStatus = ATL_INVALID_STATUS;
            m_dwHeaderLen = 0;
            m_dwBodyLen = 0;
            state = rs_readheader;
            // fall through

        case rs_readheader:

            // read from the socket until we have a complete set of headers.
            pBodyBegin = FindHeaderEnd(&pHeaderBegin);
            if (!pBodyBegin)
            {
                if (!ReadSocket())
                {
                    // Either reading from the socket failed, or there
                    // was not data to read. Set the nav status to error
                    // and change the state to complete.
                    state = rs_complete;
                    result = RR_READSOCKET_FAILED;
                    break;
                }
                else
                    break; // loop back and FindHeaderEnd again.
            }
            // we have a complete set of headers
            m_dwHeaderLen = (DWORD)(pBodyBegin-pHeaderBegin);
            m_dwHeaderStart = (DWORD)(pHeaderBegin - (BYTE*)(LPCSTR)m_current);
            // fall through
            state = rs_scanheader;

        case rs_scanheader:
            // set m_nStatus and check for valid status
            ParseStatusLine(pHeaderBegin);
            // failed to set m_nStatus;
            if (m_nStatus == ATL_INVALID_STATUS)
            {
                state = rs_complete;
                result = RR_STATUS_INVALID;
                break;
            }

            else if (m_nStatus == 100) // continue
            {
                state = rs_init;
                break;
            }

            // crack all the headers and put them into a header map. We've already
            // done the check to make sure we have a complete set of headers in 
            // rs_readheader above
            if (ATL_HEADER_PARSE_COMPLETE != CrackResponseHeader((LPCSTR)pHeaderBegin, 
                (LPCSTR*)&pBodyBegin))
            {
                // something bad happened while parsing the headers!
                state = rs_complete;
                result = RR_PARSEHEADERS_FAILED;
                break;
            }
            state = rs_readbody;
            // fall through

        case rs_readbody:
            // headers are parsed and cracked, we're ready to read the rest
            // of the response. 
            if (IsMsgBodyChunked())
            {
                if (!ReadChunkedBody())
                {
                    result = RR_READCHUNKEDBODY_FAILED;
                    state = rs_complete;
                    break;
                }
            }
            else
            if (!ReadBody(GetContentLength(), m_current.GetLength()-(m_dwHeaderStart+m_dwHeaderLen)))
                result = RR_READBODY_FAILED;
            state = rs_complete;
            //fall through

        case rs_complete:
            // clean up the connection if the server requested a close;
            DisconnectIfRequired();
            break;
        }
    }
    m_LastResponseParseError = result;
    return result;
}

// Checks to see if the server has closed the connection.
// If it has, we create a new socket and reconnect it to
// the current server. This also clears the contents of the
// current response buffer.
template <class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::ResetConnection() 
{
    ReconnectIfRequired();
    m_HeaderMap.RemoveAll();
    m_current.Empty();
    m_nStatus = ATL_INVALID_STATUS;
    m_AuthTypes.RemoveAll(); // the server will keep sending back www-authenticate
                             // headers until the connection is authorized
}

// Takes action based on the flags passed and the current
// status for this object.
template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ProcessStatus(DWORD dwFlags) 
{
    switch(m_nStatus)
    {
    case 200: // In all these cases there is no further action
    case 201: // to take. Any additional informaion is returned
    case 202: // in the entity body.
    case 203:
    case 204:
    case 205:
    case 206:
    case 304:
    case 305:
        return true;
        break;
    case 301:
    case 302:
    case 303:
        if (dwFlags & ATL_HTTP_FLAG_AUTO_REDIRECT)
            return ProcessObjectMoved();
        break;
    case 401: // auth required
            return NegotiateAuth(false);
        break;
    case 407: // proxy auth required
            return NegotiateAuth(true);
        break;

    }
    return false;
}

// Looks up the value of a response header in the header map. Call with
// NULL szBuffer to have length of the required buffer placed in 
// pdwLen on output.

// szName is the name of the header to look up.
// szBuffer is the buffer that will contain the looked up string.
// pdwLen contains the length of szBuffer in characters on input and the length
// of the string including NULL terminator in characters on output.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetHeaderValue(LPCTSTR szName, CString& strValue) const
{
    return m_HeaderMap.Lookup(szName, strValue);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetHeaderValue(LPCTSTR szName, LPTSTR szBuffer, int *pdwLen) const 
{
    CString strValue;
    bool bRet = GetHeaderValue(szName, strValue);
    int nLen = strValue.GetLength();
    if (!bRet)
        return false;

    if ((pdwLen && *pdwLen < nLen+1) ||
        (!szBuffer && !pdwLen) )
    {
        if (pdwLen)
            *pdwLen = nLen+1;
        return true;
    }

    _tcsncpy(szBuffer, (LPCTSTR)strValue, nLen+1);
    *pdwLen = nLen+1;
    return true;
}

// Adds an authorization object to use for a particular scheme.
// This will overwrite an existing entry if an object for the 
// same scheme has already been set.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::AddAuthObj(LPCTSTR szScheme,
                CAtlBaseAuthObject *pObject, IAuthInfo *pInfo/*=NULL*/) 
{
    if (!pObject)
        return false;

    pObject->Init(this, pInfo);

    _ATLTRY
    {
        POSITION pos = m_AuthMap.SetAt(szScheme, pObject);
        if (!pos)
            return false;
    }
    _ATLCATCHALL()
    {
        return false;
    }

    return true;
}

// Tries to find an authorization object to use for a particular
// scheme
template<class TSocketClass>
inline const CAtlBaseAuthObject* CAtlHttpClientT<TSocketClass>::FindAuthObject(LPCTSTR szScheme)
{
    CAtlBaseAuthObject *pObject = NULL;
    if (m_AuthMap.Lookup(szScheme, pObject))
    {
        return const_cast<const CAtlBaseAuthObject*>(pObject);
    }
    return NULL;
}

// Removes an existing authorization object from the map.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::RemoveAuthObject(LPCTSTR szScheme)
{
    return m_AuthMap.RemoveKey(szScheme);
}

// Sets the current proxy server and port
template<class TSocketClass>
inline BOOL CAtlHttpClientT<TSocketClass>::SetProxy(LPCTSTR szProxy, short nProxyPort) 
{
    if (!szProxy)
    {
        if (!LookupRegProxy())
            return FALSE;
    }
    else
    {
        _ATLTRY
        {
            m_strProxy = szProxy;
            m_nProxyPort = nProxyPort;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }
    return TRUE;
}

// Removes the current proxy settings.
template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::RemoveProxy() 
{
        m_strProxy.Empty();
        m_nProxyPort = 0;
}

// retrieves the current proxy
template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetProxy() const 
{
    if (m_strProxy.GetLength())
        return (LPCTSTR)m_strProxy;
    return NULL;
}

// Gets the contents of the entire response buffer.
template<class TSocketClass>
inline const BYTE* CAtlHttpClientT<TSocketClass>::GetResponse() 
{
    return (const BYTE*)(LPCSTR)m_current;
}

template<class TSocketClass>
inline const int CAtlHttpClientT<TSocketClass>::GetResponseLength()
{
    return m_current.GetLength();
}

// Gets the length in bytes of the body of the
// current response
template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetBodyLength() const 
{
    return m_dwBodyLen;
}

// Gets the contents of the body of the current response. This
// is the response without the headers. 
template<class TSocketClass>
inline const BYTE* CAtlHttpClientT<TSocketClass>::GetBody() 
{
    return (BYTE*)((LPCSTR)m_current+m_dwHeaderStart+m_dwHeaderLen);
}

// Get the length of the header part of the response in bytes.
template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetRawRequestHeaderLength()
{
    return m_dwHeaderLen-2; // m_dwHeaderLen includes the final \r\n
}

// buffer must include space for null terminator.
// on input, pdwLen specifies the size of szBuffer,
// on output, pdwLen holds the number of bytes copied
// to szBuffer, or the required size of szBuffer if 
// szBuffer wasn't big enough
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetRawRequestHeaders(LPBYTE szBuffer, int *pdwLen)
{
    if (!pdwLen)
        return false;

    int header_len = GetRawRequestHeaderLength();
    if (!szBuffer || *pdwLen < header_len+1)
    {
        *pdwLen = header_len+1;
        return false;
    }

    memcpy(szBuffer, (BYTE*)(LPCSTR)m_current, header_len);
    szBuffer[header_len]='\0';

    *pdwLen = header_len+1;
    return true;
}

// Gets the current URL object.
template<class TSocketClass>
inline LPCURL CAtlHttpClientT<TSocketClass>::GetCurrentUrl() const 
{
    return (LPCURL)&m_urlCurrent;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultUrl(  LPCTSTR szUrl, 
                                            short nPortNumber) 
{
    return _SetDefaultUrl(szUrl,nPortNumber);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultUrl(  LPCURL pUrl, 
                                            short nPortNumber) 
{
    m_urlCurrent = *pUrl;
    return _SetDefaultUrl(NULL, nPortNumber);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultMethod(LPCTSTR szMethod) 

{
    _ATLTRY
    {
        m_strMethod = szMethod;
        return true;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::SetFlags(DWORD dwFlags) 
{
    m_dwFlags = dwFlags;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetFlags() const 
{
    return m_dwFlags;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::LookupRegProxy()
{
    // attempt to look it up from the registry
    CRegKey rkProxy;
    ULONG nChars = ATL_URL_MAX_URL_LENGTH+1;
    TCHAR szUrl[ATL_URL_MAX_URL_LENGTH+1] = { 0 };

    DWORD dwErr = rkProxy.Open(HKEY_CURRENT_USER, 
        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"), KEY_READ);
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = rkProxy.QueryStringValue(_T("ProxyServer"), szUrl, &nChars);
    }
    if (dwErr == ERROR_SUCCESS)
    {
        CUrl url;
        if (url.CrackUrl(szUrl))
        {
            if (url.GetScheme()==ATL_URL_SCHEME_UNKNOWN)
            {
                // without the scheme name (e.g. proxy:80)
                m_strProxy = url.GetSchemeName();
                m_nProxyPort = (short)_ttoi(url.GetHostName());
                return true;
            }
            else if (url.GetHostName())
            {
                // with the scheme (e.g. http://proxy:80)
                m_strProxy = url.GetHostName();
                m_nProxyPort = url.GetPortNumber();
                return true;
            }
        }
    }
    return false;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::DisconnectIfRequired()
{
    CString strValue;
    if (GetHeaderValue(_T("Connection"), strValue) && !strValue.CompareNoCase(_T("close")))
    {
        Close();
    }

    return true;
}
    
// Tries to find an authorization object that meets
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::NegotiateAuth(bool bProxy)
{
    // szAuthHeaderValue should contain a comma separated list
    // of authentication types
    CAtlBaseAuthObject *pAuthObj = NULL;
    bool bRet = false;
    for (size_t i = 0; i<m_AuthTypes.GetCount(); i++)
    {
        _ATLTRY
        {
            CString strName = m_AuthTypes[i];
            int nSpace = strName.Find(_T(' '));
            if (nSpace!=-1)
                strName.SetAt(nSpace,0);

            if (m_AuthMap.Lookup(strName, pAuthObj) &&
                !pAuthObj->m_bFailed)
                bRet = pAuthObj->Authenticate(m_AuthTypes[i], bProxy);

            if (bRet)
                return bRet;
        }
        _ATLCATCHALL()
        {
            bRet = false;
        }
    }
    return bRet;
}

template<class TSocketClass>
inline long CAtlHttpClientT<TSocketClass>::GetContentLength() 
{
    CString strValue;
    if (GetHeaderValue(_T("Content-Length"), strValue))
    {
        TCHAR *pStop = NULL;
        return _tcstol(strValue, &pStop, 10);
    }
    else
        return -1;
}

template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::NextLine(BYTE* pCurr) 
{
    if (!pCurr)
        return NULL;

    while ( *pCurr && !(*pCurr == '\r' && *(pCurr+1) == '\n'))
        pCurr++;

    if (!memcmp(pCurr, ATL_HEADER_END, 4))
        return NULL;

    return (LPCSTR)(pCurr+2);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::IsMsgBodyChunked() 
{
    CString strValue;
    return (
            GetHeaderValue(_T("Transfer-Encoding"), strValue) &&
            strValue == _T("chunked") // m_HeaderMap lower cases all values before storing
            );

}

// finds the end of an individual header field pointed to by
// pszStart. Header fields can be multi-line with multi-line 
// header fields being a line that starts with some kind of 
// white space.
template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::FindEndOfHeader(LPCSTR pszStart) 
{
    // move through all the lines until we come to one
    // that doesn't start with white space
    LPCSTR pLineStart = pszStart;
    LPCSTR pHeaderEnd = NULL;

    do 
    {
        pLineStart = NextLine((BYTE*)pLineStart);
    }while (pLineStart && isspace(*pLineStart));

    //if we reach the end of all headers then pLineStart 
    // will be NULL
    if (pLineStart)
        pHeaderEnd = pLineStart-2;
    else // on last header
    {
        pHeaderEnd = strstr(pszStart, ATL_HEADER_END);
    }

    return pHeaderEnd;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::DecodeHeader(LPCSTR pHeaderStart, LPCSTR pHeaderEnd) 
{
    _ATLTRY
    {
        if (!pHeaderStart || !pHeaderEnd)
            return false;
        LPCSTR pTemp = pHeaderStart;
        while (*pTemp != ATL_FIELDNAME_DELIMITER && pTemp < pHeaderEnd)
            pTemp++;
        if (*pTemp == ATL_FIELDNAME_DELIMITER)
        {
            char szName[ATL_MAX_FIELDNAME_LEN];
            char szValue[ATL_MAX_VALUE_LEN];
            int nLen = (int)(pTemp-pHeaderStart) ;
            ATLASSERT(nLen < ATL_MAX_FIELDNAME_LEN);
            memcpy(szName, pHeaderStart, nLen);
            szName[nLen]=0;

            pTemp++; // move past delimiter;
            while (isspace(*pTemp) && pTemp < pHeaderEnd)
                pTemp++;

            nLen = (int)(pHeaderEnd-pTemp);
            ATLASSERT(nLen < ATL_MAX_VALUE_LEN);
            memcpy(szValue, pTemp, nLen);
            szValue[nLen]=0;

            CString strExist;
            CA2T pszName(szName);
            CA2T pszValue(szValue);

            if (!_tcsicmp(pszName, _T("www-authenticate")) ||
                !_tcsicmp(pszName, _T("proxy-authenticate")))
            {
                m_AuthTypes.Add(pszValue);
            }

            if (!m_HeaderMap.Lookup(pszName, strExist))
                m_HeaderMap.SetAt(pszName, pszValue);
            else
            {   
                // field-values for headers with the same name can be appended
                // per rfc2068 4.2, we do the appending so we don't have to
                // store/lookup duplicate keys.
                strExist += ',';
                strExist += pszValue;
                m_HeaderMap.SetAt(pszName, (LPCTSTR)strExist);
            }

            // if it's a set-cookie header notify users so they can do 
            // somthing with it.
            if (!_tcsicmp(pszName, _T("set-cookie")))
                OnSetCookie(pszValue);
        }

        return true;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::OnSetCookie(LPCTSTR)
{
    return;
}

template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::ParseStatusLine(BYTE* pBuffer) 
{
    if (!pBuffer)
        return NULL;
    // find the first space'
    while (!isspace(*pBuffer))
        pBuffer++;

    // move past the space
    while (isspace(*pBuffer))
        pBuffer++;

    // should be pointing at the status code
    LPCSTR pEnd = NULL;
    m_nStatus = strtol((LPSTR)pBuffer, (LPSTR*)&pEnd, 10);

    // move to end of line
    while (*pBuffer !=  '\n')
        pBuffer++;

    // set the return pointing to the first 
    // character after our status line.
    return (LPCSTR)++pBuffer;
}


// pBuffer should start at the first character
// after the status line.
template<class TSocketClass>
inline int CAtlHttpClientT<TSocketClass>::CrackResponseHeader(LPCSTR pBuffer, /*out*/ LPCSTR *pEnd) 
{
    // read up to the double /r/n
    LPCSTR pszStartSearch = pBuffer;
    if (!pEnd)
        return ATL_HEADER_PARSE_HEADERERROR;

    *pEnd = NULL;
    if (pszStartSearch == NULL)
        return ATL_HEADER_PARSE_HEADERERROR;

    // start parsing headers
    LPCSTR pHeaderStart = ParseStatusLine((BYTE*)pBuffer);
    LPCSTR pHeaderEnd = NULL;

    while (pHeaderStart && *pHeaderStart)
    {
        pHeaderEnd = FindEndOfHeader(pHeaderStart);
        if (!pHeaderEnd)
            break;
        DecodeHeader(pHeaderStart, pHeaderEnd);

        if (!strncmp(pHeaderEnd, ATL_HEADER_END, strlen(ATL_HEADER_END)))
        {
            *pEnd = pHeaderEnd + ATL_HEADER_END_LEN;
            break;      // we're done
        }
        else
            pHeaderStart = pHeaderEnd+2;
    }

    return ATL_HEADER_PARSE_COMPLETE;       
}

// Reads the body if the encoding is not chunked.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadBody(int nContentLen, int nCurrentBodyLen) 
{
    // nCurrentBodyLen is the length of the body that has already been read
    // nContentLen is the value of Content-Length
    // current is the buffer that will contain the entire response
    bool bRet = true;
    ATLASSERT(m_pNavData);
    if (!m_pNavData)
        return false;

    CTempBuffer<BYTE, 512> readbuff;
    DWORD dwReadBuffSize = 0;
    DWORD dwRead = 0;
    if (m_pNavData->dwReadChunkSize)
    {
        ATLTRY(readbuff.Allocate(m_pNavData->dwReadChunkSize));
        dwReadBuffSize = m_pNavData->dwReadChunkSize;
    }
    else
    {
        ATLTRY(readbuff.Allocate(ATL_READ_BUFF_SIZE));
        dwReadBuffSize = ATL_READ_BUFF_SIZE;
    }

    if (readbuff.operator BYTE*() == NULL)
        return false;

    if (nContentLen != -1) // We know the content length.
    {
        // read the rest of the body.
        while (nCurrentBodyLen < nContentLen)
        {
            dwRead = dwReadBuffSize;
            if (!Read(readbuff, &dwRead))
                return false;

            // notify user
            if (m_pNavData)
            {
                if (m_pNavData->pfnReadStatusCallback)
                    if (!m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead))
                        return false;
            }

            nCurrentBodyLen += dwRead;
            if (!m_current.Append((LPCSTR)(BYTE*)readbuff, dwRead))
            {
                ATLASSERT(0);
                return false; // error!
            }

        }
        m_dwBodyLen = nCurrentBodyLen;
    }
    else // We don't know content length. All we can do is
    {    // read until there is nothing else to read.
        do
        {
            dwRead = dwReadBuffSize;
            if (Read((BYTE*)readbuff, (DWORD*)&dwRead))
            {
                // notify user
                if (m_pNavData)
                {
                    if (m_pNavData->pfnReadStatusCallback)
                        bRet = m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead);
                    if (!bRet)
                        return bRet;
                }

                nCurrentBodyLen += dwRead;
                m_current.Append((LPCSTR)(BYTE*)readbuff, dwRead);
            }
            else 
            {
                // notify user
                if (m_pNavData)
                {
                    if (m_pNavData->pfnReadStatusCallback)
                        bRet = m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead);
                    if (!bRet)
                        return bRet;
                }

                bRet = true;
                break;
            }
        }while (dwRead);
        m_dwBodyLen = nCurrentBodyLen;
    }
    return bRet;
}


// This function moves pBuffStart only on success. On success, pBuffStart is moved
// to the element past the last element we consumed.
template<class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::get_chunked_size(char *&pBuffStart, char *&pBuffEnd, long* pnChunkSize)
{
    CHUNK_LEX_RESULT result = LEX_ERROR;
    char *pStop = NULL;

    if (pBuffStart >= pBuffEnd)
        result = LEX_OUTOFDATA;
    else
    {
        long nResult = strtoul(pBuffStart, &pStop, 16);
        if (errno != ERANGE &&
            nResult >= 0 &&
            nResult < 0xFFFFFFFF &&
            pStop <= pBuffEnd &&
            *pStop == '\r')
        {
            // move pBuffStart
            // return chunk size
            *pnChunkSize = nResult;
            pBuffStart = pStop;
            result = LEX_OK;
        }
        if (*pStop != '\r')
        {
            result = LEX_OUTOFDATA; // not enough data in the buffer
        }
    }
    return result;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::move_leftover_bytes(char *pBufferStart, int nLen, char *&pBuffStart, char *& /*pBuffEnd*/)
{
    bool bRet = true;
    memcpy(pBufferStart, pBuffStart, nLen);
    return bRet;
}

template<class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::get_chunked_data(char *&pBufferStart,
                                  char *&pBufferEnd,
                                  long nChunkSize,
                                  char **ppDataStart,
                                  long *pnDataLen)
{
    CHUNK_LEX_RESULT result = LEX_ERROR;
    if (pBufferStart + nChunkSize - 1 < pBufferEnd)
    {
        *ppDataStart = pBufferStart;
        *pnDataLen = nChunkSize;
        pBufferStart = pBufferStart + nChunkSize;
        result = LEX_OK;
    }
    else if (pBufferStart + nChunkSize - 1 >= pBufferEnd)
        result = LEX_OUTOFDATA;

    return result;
}

template<class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::consume_chunk_trailer(char *&pBufferStart, char *pBufferEnd)
{
    CHUNK_LEX_RESULT result = LEX_ERROR;
    if (pBufferStart >= pBufferEnd)
        return result;

    char *pHeaderEnd = NULL;
    char *pTemp = pBufferStart;
    // check for empty trailer, this means there are no more trailers
    if ( (pTemp < pBufferEnd && *pTemp == '\r') &&
            (pTemp+1 < pBufferEnd && *(pTemp+1) == '\n'))
    {
        pBufferStart += 2;
        return LEX_TRAILER_COMPLETE;
    }

    while (pTemp <= pBufferEnd)
    {
        if ( (pTemp < pBufferEnd && *pTemp == '\r') &&
             (pTemp+1 < pBufferEnd && *(pTemp+1) == '\n'))
        {
             pHeaderEnd = pTemp; // success case
             result = LEX_OK;
             break;
        }
        pTemp++;
    }

    if (result == LEX_OK)
    {
        DecodeHeader(pBufferStart, pHeaderEnd);
        pBufferStart = pHeaderEnd + 2;
    }
    else if (result != LEX_OK &&
        pTemp > pBufferEnd)
        result = LEX_OUTOFDATA;
    return result;
}

template<class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::consume_chunk_footer(char *&pBufferStart, char *&pBufferEnd)
{
    CHUNK_LEX_RESULT result = LEX_ERROR;
    if (pBufferStart < pBufferEnd &&
        (pBufferStart+1) <= pBufferEnd)
    {
        if ( *pBufferStart == '\r' &&   
             *(pBufferStart+1) == '\n')
        {
            pBufferStart += 2;
            result = LEX_OK;
        }
    }
    else
        result = LEX_OUTOFDATA;
    return result;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadChunkedBody()
{
    // At this point, m_current contains the headers, up to and including the \r\n\r\n,
    // plus any additional data that might have been read off the socket. So, we need
    // to copy off the additional data into our read buffer before we start parsing the
    // chunks.
#ifdef _DEBUG
    // nReadCount, keeps track of how many socket reads we do.
    int nReadCount = 0;
#endif

    // nChunkBuffCarryOver
    // When we run out of data in the input buffer, this is the
    // count of bytes that are left in the input that could not
    // be lexed into anything useful. We copy this many bytes to
    // the top of the input buffer before we fill the input buffer
    // with more bytes from the socket
    long nChunkBuffCarryOver = 0;

    // nChunkSize
    // The size of the next chunk to be read from the input buffer.
    long nChunkSize = 0;

    // A temporary heap pointer that will hold all of the headers we receive.
    CHeapPtr<char> t_header_buffer;

    // t_chunk_buffer
    // The heap allocated buffer that we holds data
    // read from the socket. We will increase the size
    // of this buffer to 2 times the max chunk size we
    // need to read if we have to.
    CHeapPtr<char> t_chunk_buffer;

    // nTChunkBuffSize
    // Keeps track of the allocated size of t_chunk_buffer.
    // This size will change if we need to read chunks bigger
    // than the currently allocated size of t_chunk_buffer.
    long nTChunkBuffSize = CHUNK_BUFF_SIZE;

    // chunk_buffer & chunk_buffer_end
    // Keeps track of the current location
    // in t_chunk_buffer that we are lexing input from.
    // chunk_buffer_end is the end of the input buffer we
    // are lexing from. chunk_buffer_end is used as a marker
    // to make sure we don't read past the end of our input buffer
    char *chunk_buffer, *chunk_buffer_end;

    // cstate
    // The current state of the chunk parsing state machine. We
    // start out reading the size of the first chunk.
    CHUNK_STATE cstate = READ_CHUNK_SIZE;

    // cresult
    // Holds the value of the result of a lexing operation performed
    // on the input buffer.
    CHUNK_LEX_RESULT cresult = LEX_OK;

    // Initialize pointers and allocate the chunk buffer.
    chunk_buffer = chunk_buffer_end = NULL;
    t_chunk_buffer.Allocate(nTChunkBuffSize);

    // copy the headers into a temporary buffer.
    t_header_buffer.Allocate(m_dwHeaderLen);
    memcpy((char*)t_header_buffer, (LPCSTR)m_current, m_dwHeaderLen);

    // calculate number of bytes left in m_current past the headers
    long leftover_in_m_current = m_current.GetLength()- m_dwHeaderLen;

    // copy the extra bytes that might have been read into m_current into the chunk buffer
    if (leftover_in_m_current > 0)
    {
        if (leftover_in_m_current > nTChunkBuffSize)
            t_chunk_buffer.Reallocate(leftover_in_m_current);

        chunk_buffer = (char*)t_chunk_buffer;
        memcpy(chunk_buffer, ((LPCSTR)m_current)+m_dwHeaderLen, leftover_in_m_current);
        chunk_buffer_end = chunk_buffer + leftover_in_m_current;
    }

    // as we start the state machine, we should be either pointing at the first
    // byte of chunked response or nothing, in which case we will need to get 
    // more data from the socket.
    nChunkSize = 0;

	bool bDone = false;
	 
    while(!bDone)
    {
        // if we run out of data during processing, chunk_buffer
        // get set to null
        if (!chunk_buffer ||
            chunk_buffer >= chunk_buffer_end)
        {
            // we ran out of data in our input buffer, we need
            // to read more from the socket.
            DWORD dwReadBuffSize = nTChunkBuffSize - nChunkBuffCarryOver;
            chunk_buffer = t_chunk_buffer;
            if (!Read((const unsigned char*)(chunk_buffer+nChunkBuffCarryOver), &dwReadBuffSize))
            {
                ATLTRACE("ReadChunkedBody: Error reading from socket (%d)\n", GetLastError());
                return false;
            }
            else if(dwReadBuffSize == 0)
            {
                ATLTRACE("ReadChunkedBody: The socket read timed out and no bytes were read from the socket.\n");
                return false;
            }
#ifdef _DEBUG
            ATLTRACE("ReadChunkedBody read %d bytes from socket. Reads %d \n", dwReadBuffSize, ++nReadCount);
#endif
            chunk_buffer_end = chunk_buffer + nChunkBuffCarryOver + dwReadBuffSize;
            nChunkBuffCarryOver = 0;
        }

        switch(cstate)
        {
        case READ_CHUNK_SIZE:
            {
                cresult = get_chunked_size(chunk_buffer, chunk_buffer_end, &nChunkSize);
                switch(cresult)
                {
                case LEX_ERROR:
                    ATLTRACE("ReadChunkedBody Failed retrieving chunk size\n");
                    return false;
                    break;
                case LEX_OUTOFDATA:
                    nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
                    if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
                                        chunk_buffer, chunk_buffer_end))
                    {
                        ATLTRACE("failed to move leftover chunk data to head of buffer\n");
                        return false;
                    }
                    chunk_buffer = chunk_buffer_end = NULL;
                    break;
                case LEX_OK:
                    if (nChunkSize == 0)
                    {
                        cstate = CHUNK_READ_DATA_COMPLETE;
                    }
                    else if (nChunkSize > nTChunkBuffSize)
                    {
                        char *pBuffStart = (char*)t_chunk_buffer;
                        int nReadSoFar = (int)(chunk_buffer - pBuffStart);
                        int nTotal = (int)(chunk_buffer_end - pBuffStart);
                        t_chunk_buffer.Reallocate(nChunkSize * 2);
                        nTChunkBuffSize = nChunkSize*2;
                        pBuffStart = (char*)t_chunk_buffer;
                        chunk_buffer = pBuffStart + nReadSoFar;
                        chunk_buffer_end = pBuffStart + nTotal;
                        cstate = READ_CHUNK_SIZE_FOOTER;
                        m_dwBodyLen += nChunkSize;
                    }
                    else
                    {
                        // everything is OK. move to next state
                        cstate = READ_CHUNK_SIZE_FOOTER;
                        m_dwBodyLen += nChunkSize;
                    }
                    break;
                default:
                    ATLASSERT(0);
                    return false;
                    break;
                }
            }
            break;
        case READ_CHUNK_DATA:
            {
                char *pDataStart = NULL;
                long nDataLen = 0;
                cresult = LEX_OK;
                cresult = get_chunked_data(chunk_buffer, chunk_buffer_end,
                                            nChunkSize, &pDataStart, &nDataLen);
                switch(cresult)
                {
                case LEX_ERROR:
                    ATLTRACE("ReadChunkedBody failed to retrieve chunk data\n");
                    return false;
                    break;
                case LEX_OUTOFDATA:
                    nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
                    if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
                                        chunk_buffer, chunk_buffer_end))
                    {
                        ATLTRACE("failed to move leftover chunk data to head of buffer\n");
                        return false;
                    }
                    chunk_buffer = chunk_buffer_end = NULL;
                    break;
                case LEX_OK:
                    m_current.Append(pDataStart, nDataLen);
                    cstate = READ_CHUNK_DATA_FOOTER;
                    break;
                default:
                    ATLASSERT(0);
                    return false;
                }
            }
            break;
            case READ_CHUNK_SIZE_FOOTER:
            case READ_CHUNK_DATA_FOOTER:
            {
                cresult = consume_chunk_footer(chunk_buffer, chunk_buffer_end);
                switch(cresult)
                {
                case LEX_OK:
                    cstate = (cstate == READ_CHUNK_SIZE_FOOTER) ? READ_CHUNK_DATA : READ_CHUNK_SIZE;
                    break;
                case LEX_ERROR:
                    ATLTRACE("Error consuming chunk footer!\n");
                    return false;
                    break;
                case LEX_OUTOFDATA:
                    nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
                    if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
                                        chunk_buffer, chunk_buffer_end))
                    {
                        ATLTRACE("failed to move leftover chunk data to head of buffer\n");
                        return false;
                    }
                    chunk_buffer = chunk_buffer_end = NULL;
                    break;
                default:
                    ATLASSERT(0);
                    return false;

                }
            }
            break;
            case CHUNK_READ_DATA_COMPLETE:
                // We read the chunk of size 0
                // consume the chunk footer.
                cresult = consume_chunk_footer(chunk_buffer, chunk_buffer_end);
                if (GetHeaderValue((_T("Trailer")), NULL, NULL))
                {
                    cstate = READ_CHUNK_TRAILER; // start reading trailer headers
                    break;
                }
                else
                    bDone = true;
                break;
            case READ_CHUNK_TRAILER:
                cresult = consume_chunk_trailer(chunk_buffer, chunk_buffer_end);
                switch(cresult)
                {
                case LEX_OK:
                    cstate = READ_CHUNK_TRAILER; // keep reading
                    break;
                case LEX_ERROR:
                    ATLTRACE("Error consuming chunk trailers!\n");
                    return false;
                    break;
                case LEX_OUTOFDATA:
                    nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
                    if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
                                        chunk_buffer, chunk_buffer_end))
                    {
                        ATLTRACE("failed to move leftover chunk data to head of buffer\n");
                        return false;
                    }
                    chunk_buffer = chunk_buffer_end = NULL;
                    break;
                case LEX_TRAILER_COMPLETE:
                    return true;
                    break;
                default:
                    ATLASSERT(0);
                    return false;



                }
                break;

        }

    
    }
	return true;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReconnectIfRequired() 
{
    CString strValue;
    // if we have a keep-alive header then return true
    // else we have to close and re-open the connection
    if (GetHeaderValue(_T("Connection"), strValue))
	{
        if (!strValue.CompareNoCase(_T("keep-alive")))
			return true; // server said keep connection open.
	}
	else
		return true; // there was no 'Connection' header

    if (!strValue.CompareNoCase(_T("close")))
    {
        Close();
        if (Create())
        {
            if (GetProxy())
                return Connect(m_strProxy, m_nProxyPort);
            else
                return Connect(m_urlCurrent.GetHostName(), m_urlCurrent.GetPortNumber());
        }
    }   
    return false;
}

// Complete relative URLs and URLs
// that have a missing path. These are common with redirect headers.
// http://www.microsoft.com becomes http://www.microsoft.com/
// localstart.asp becomes whatever our current (m_urlCurrent) 
// path is plus localstart.asp
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::CompleteURL(CString& strURL) 
{
    _ATLTRY
    {
        CString strUrlTemp = strURL;
        CUrl url;
        bool bErr = false;
        if (url.CrackUrl(strUrlTemp))
        {
            return true; // URL is already valid
        }


        // if we have a scheme and a host name but no
        // path, then add the path of '/'
        if (url.GetScheme() == ATL_URL_SCHEME_HTTP &&
            url.GetHostNameLength() > 0 &&
            !url.GetUrlPathLength() )
        {
            url.SetUrlPath(_T("/"));
            bErr = true;
        }
        // if we don't have a scheme or host name or path we derive
        // the url from our current URL (m_urlCurrent) and add
        // our relative paths
        else if (url.GetScheme() == ATL_URL_SCHEME_UNKNOWN &&
            url.GetHostNameLength() == 0 &&
            url.GetUrlPathLength() == 0)
        {
            TCHAR szPath[ATL_URL_MAX_PATH_LENGTH];
            szPath[0]=0;
            url = m_urlCurrent;


            if (!url.GetUrlPathLength())
                _tcscpy(szPath, _T("/")); // current URL has no path!
            else
                _tcscpy(szPath, url.GetUrlPath());

            // back up to the first / and insert our current url
            TCHAR* pBuff = _tcsrchr(szPath,  _T('/'));
            pBuff++;
            if (!(*pBuff))
                _tcscat(szPath, (LPCTSTR)strURL);
            else
                _tcscat(pBuff, (LPCTSTR)strURL);

            url.SetUrlPath(szPath);
            bErr = true;
        }
        if (!bErr)
            return bErr;
        DWORD dwLen = ATL_URL_MAX_PATH_LENGTH;

        return url.CreateUrl(strURL.GetBuffer(ATL_URL_MAX_PATH_LENGTH),
            &dwLen) ? true : false;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ProcessObjectMoved() 
{
    _ATLTRY
    {
        // look for a location header
        CString strValue;
        CString strURLNew;
        if (GetHeaderValue(_T("Location"), strValue))
        {
            ReconnectIfRequired();
            m_HeaderMap.RemoveAll();
            m_current.Empty();


            // create a new URL based on what is in the
            // Location header and set it as this object's 
            // default Url
            strURLNew = strValue;
            CompleteURL(strURLNew);
            SetDefaultUrl((LPCTSTR)strURLNew, m_urlCurrent.GetPortNumber());
            
            // build up a request           
            CString strRequest;
            BuildRequest(&strRequest, m_strMethod, 
                m_urlCurrent.GetHostName(),
                m_urlCurrent.GetUrlPath(), 
                m_urlCurrent.GetExtraInfo(), m_pData, m_dwDataLen, m_strDataType);

            // send the request
            DWORD dwSent = strRequest.GetLength();
            DWORD dwAvailable = dwSent;
            if (!Write((BYTE*)((LPCSTR)CT2A(strRequest.GetBuffer(dwAvailable))), &dwSent))
                return false;
            strRequest.ReleaseBuffer();

            if (dwSent != dwAvailable)
                return false;

            // read the response
            if (RR_OK == ReadHttpResponse())
            {
                ProcessStatus(m_dwFlags);
            }
        }
        return true;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::_SetDefaultUrl(LPCTSTR szURL, short nPort) 
{

    if (szURL)
        if (!m_urlCurrent.CrackUrl(szURL)) // re-inits the field of the CUrl first
            return false;

	ATL_URL_SCHEME currScheme = m_urlCurrent.GetScheme();
    if ( currScheme != ATL_URL_SCHEME_HTTP &&
		 !TSocketClass::SupportsScheme(currScheme) )
        return false; // only support HTTP

    if (!m_urlCurrent.GetUrlPathLength())
    {
        // no path, default to /
        m_urlCurrent.SetUrlPath(_T("/"));
    }

    if (!m_urlCurrent.GetHostNameLength())
    {
        // no server name
        return false;
    }

    if (m_urlCurrent.GetPortNumber() == ATL_URL_INVALID_PORT_NUMBER)
        m_urlCurrent.SetPortNumber(nPort);
    return true;
}

template<class TSocketClass>
inline int CAtlHttpClientT<TSocketClass>::GetStatus()
{
    return m_nStatus;
}

template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetMethod()
{
    return m_strMethod;
}

template<class TSocketClass>
inline BYTE* CAtlHttpClientT<TSocketClass>::GetData()
{
    return m_pData;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetDataLen()
{
    return m_dwDataLen;
}

template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetDataType()
{
    return m_strDataType;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetLastError()
{
    return m_dwLastError;
}

template<class TSocketClass>
inline const SOCKET& CAtlHttpClientT<TSocketClass>::GetSocket()
{
    return const_cast<const SOCKET&>(m_socket);
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::Close()
{
    TSocketClass::Close();
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::SetSocketTimeout(DWORD dwNewTimeout)
{
    return TSocketClass::SetSocketTimeout(dwNewTimeout);
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetSocketTimeout()
{
    return TSocketClass::GetSocketTimeout();
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::AuthProtocolFailed(LPCTSTR szProto)
{
    CAtlBaseAuthObject *pAuthObj = NULL;
    if (m_AuthMap.Lookup(szProto, pAuthObj) && pAuthObj)
    {
        pAuthObj->m_bFailed = true;
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
// CNTLMAuthObject
// NTLM Security Authorization functions 
//
/////////////////////////////////////////////////////////////////////////////////
inline CNTLMAuthObject::CNTLMAuthObject() :
    m_pSocket(NULL),
    m_nMaxTokenSize(0),
    m_pAuthInfo(NULL),
    m_bProxy(false)
{
    SecInvalidateHandle(&m_hCredentials)
}

inline CNTLMAuthObject::CNTLMAuthObject(IAuthInfo *pAuthInfo) :
    m_pSocket(NULL),
    m_nMaxTokenSize(0),
    m_pAuthInfo(pAuthInfo)
{
    SecInvalidateHandle(&m_hCredentials)
}

inline CNTLMAuthObject::~CNTLMAuthObject()
{
    if (!ATL_IS_INVALIDCREDHANDLE(m_hCredentials))
        FreeCredentialsHandle(&m_hCredentials);
}

inline void CNTLMAuthObject::Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo) throw()
{
    m_pSocket = pSocket;
    SetAuthInfo(pAuthInfo);
}

inline void CNTLMAuthObject::SetAuthInfo(IAuthInfo *pAuthInfo)
{
    m_pAuthInfo = pAuthInfo;
}

inline bool CNTLMAuthObject::Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw()
{
    m_bProxy = bProxy;
    if (_tcsstr(szAuthTypes, ATL_HTTP_AUTHTYPE_NTLM))
    {
        if (AcquireCredHandle())
            return DoNTLMAuthenticate();
    }
    return false;
}

inline bool CNTLMAuthObject::AcquireCredHandle()
{
    PSecPkgInfo pPackageInfo = NULL;
    SECURITY_STATUS SecurityStatus = SEC_E_OK;

    // Acquire a credentials handle on the NTLM security package
    SecurityStatus = QuerySecurityPackageInfo(ATL_HTTP_AUTHTYPE_NTLM,
                            &pPackageInfo);

    if (SecurityStatus != SEC_E_OK)
        return false;

    void *pAuthData = NULL;
    CSecAuthIdentity CA;
    if (m_pAuthInfo)
    {
        // if m_pAuthInfo has been set then the caller wants us
        // to get credentials from them.
        if (CA.Init(m_pAuthInfo))
            pAuthData = static_cast<void*>(&CA);
    }

    SecurityStatus = AcquireCredentialsHandle(
                    0,
                    pPackageInfo->Name,
                    SECPKG_CRED_OUTBOUND,
                    0,
                    pAuthData,
                    0,
                    0,
                    &m_hCredentials,
                    &m_ts
                    );

    m_nMaxTokenSize = pPackageInfo->cbMaxToken;
    FreeContextBuffer(pPackageInfo);
    return SecurityStatus == SEC_E_OK ? true : false;
}

inline bool CNTLMAuthObject::DoNTLMAuthenticate()
{
    bool bRet = false;

    // make sure we have a good credentials handle
    ATLASSERT(!ATL_IS_INVALIDCREDHANDLE(m_hCredentials));
    if (ATL_IS_INVALIDCREDHANDLE(m_hCredentials))
        return false;

    SECURITY_STATUS SecurityStatus = SEC_E_OK;

    unsigned long ContextAttributes = 0;
    CSecBufferDesc OutBufferDesc;
    CtxtHandle SecurityContext;
    SecInvalidateHandle(&SecurityContext);

    // Create a SecBufferDesc with one buffer of m_nMaxTokenSize
    if (!OutBufferDesc.AddBuffers(1, m_nMaxTokenSize))
        return false;

    SecurityStatus = InitializeSecurityContext(
                &m_hCredentials,
                0,
                ATL_HTTP_AUTHTYPE_NTLM,
                ISC_REQ_USE_DCE_STYLE | ISC_REQ_DELEGATE |
                ISC_REQ_MUTUAL_AUTH |ISC_REQ_REPLAY_DETECT |
                ISC_REQ_SEQUENCE_DETECT |ISC_REQ_CONFIDENTIALITY |
                ISC_REQ_CONNECTION,
                0,
                0,
                0,
                0,
                &SecurityContext,
                OutBufferDesc,
                &ContextAttributes,
                &m_ts
                );

    if ( (SecurityStatus == SEC_I_COMPLETE_NEEDED) ||
         (SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        SecurityStatus = CompleteAuthToken( &SecurityContext, (PSecBufferDesc)OutBufferDesc);
    }

    if (IS_ERROR(SecurityStatus))
        return false;

    // create an Authentication header with the contents of the
    // security buffer and send it to the HTTP server. The output
    // buffer will be pointing to a buffer that contains the 
    // response from the HTTP server on return.
    LPSTR pszbuff = NULL;
    if (!SendSecurityInfo(OutBufferDesc.Buffers(0), &pszbuff) || !pszbuff)
        return false;

    CString strVal;
    if (!m_pSocket->GetHeaderValue(m_bProxy ? g_pszProxyAuthenticate : g_pszWWWAuthenticate, strVal))
        return false; // wrong authentication type

    LPCTSTR szResponsecode = strVal;
    TCHAR pszcode[ATL_AUTH_HDR_SIZE];
    if (szResponsecode)
    {
        // first four characters better be 'NTLM'
        if (!(
              (*szResponsecode != _T('N') || *szResponsecode != _T('n')) &&
              (*(szResponsecode+1) != _T('T') || *(szResponsecode+1) != _T('t')) &&
              (*(szResponsecode+2) != _T('L') || *(szResponsecode+2) != _T('l')) &&
              (*(szResponsecode+3) != _T('M') || *(szResponsecode+3) != _T('m')) ))
            return false;

        // skip NTLM
        szResponsecode += 4;

        // skip space
        while (*szResponsecode && _istspace(*szResponsecode))
            szResponsecode++;

        // find end of header
        LPCTSTR pszend = szResponsecode;
        while (*pszend && *pszend != _T('\r'))
            pszend++;
        bRet = false;
        if (pszend)
        {
            // copy authentication data to our buffer
            // and base64decode it.
            int nlen = (int)(pszend-szResponsecode);
            memcpy(pszcode, szResponsecode, nlen*sizeof(TCHAR) );
            pszcode[pszend-szResponsecode]=0;

            // re-use OutBufferDesc here since we'll need to need
            // a SecBufferDesc to pass to the next call to InitializeSecurityContext
            // anyways.
            OutBufferDesc.Buffers(0)->ClearBuffer(m_nMaxTokenSize);
            _ATLTRY
            {
                CT2A pszcode_a(pszcode);
                bRet = Base64Decode(pszcode_a,
                                    (int) strlen(pszcode_a), 
                                    (BYTE*)OutBufferDesc.Buffers(0)->pvBuffer,
                                    (int*) &OutBufferDesc.Buffers(0)->cbBuffer) != FALSE;
            }
            _ATLCATCHALL()
            {
                bRet = false;
            }
        }

        if (!bRet)
            return false;
    
        // Create buffers for the challenge data
        CSecBufferDesc *InBufferDesc = &OutBufferDesc;
        CSecBufferDesc OutBufferDesc2;
        if (!OutBufferDesc2.AddBuffers(1, m_nMaxTokenSize))
            return false;

        // Process the challenge response from the server
        SecurityStatus = InitializeSecurityContext(
                    0,
                    &SecurityContext,
                    ATL_HTTP_AUTHTYPE_NTLM,
                    0,
                    0,
                    0 ,
                    InBufferDesc,
                    0,
                    &SecurityContext,
                    OutBufferDesc2,
                    &ContextAttributes,
                    &m_ts
                    );

        if (IS_ERROR(SecurityStatus))
            return false;

        pszbuff = NULL;
        if (SendSecurityInfo(OutBufferDesc2.Buffers(0), &pszbuff))
        {
            // at this point we should be authenticated and either have the page
            // we requested or be getting re-directed to another page under our
            // authorization. Either way, we don't want to go through authorization
            // code again if we are not authorized to prevent recursive authorization
            // so we tell the client not to try this protocol again.
            if (m_pSocket->GetStatus() == 401 ||
                m_pSocket->GetStatus() == 407)
            {
                // Authorization with this protocol failed.
                // don't try it again.
                m_pSocket->AuthProtocolFailed(_T("NTLM"));
            }
            bRet = m_pSocket->ProcessStatus(m_pSocket->GetFlags());
        }
    }

    return bRet;
}

inline bool CNTLMAuthObject::SendSecurityInfo(SecBuffer *pSecBuffer, LPSTR *pszBuffer)
{
    ATLASSERT(pSecBuffer);
    ATLASSERT(m_pSocket);
    ATLASSERT(pszBuffer);

    int nDest = ATL_AUTH_HDR_SIZE;
    char auth_b64encoded[ATL_AUTH_HDR_SIZE];
    char auth_header[ATL_AUTH_HDR_SIZE];
    const char *pszFmtStr = m_bProxy ? m_pszFmtProxy : m_pszFmtWWW;

    if (!pSecBuffer || !pSecBuffer->pvBuffer || !pszBuffer)
        return false;
    *pszBuffer = 0;

    // Base64Encode will fail gracefully if buffer not big enough
    if (Base64Encode((BYTE*)pSecBuffer->pvBuffer, pSecBuffer->cbBuffer,
        auth_b64encoded, &nDest, ATL_BASE64_FLAG_NOCRLF))
    {
        if (nDest < ATL_AUTH_HDR_SIZE)
        {
            auth_b64encoded[nDest]=0;
            // make sure we have enough room in our header buffer
            if ( (strlen(pszFmtStr)-2 + nDest) < ATL_AUTH_HDR_SIZE)
                sprintf(auth_header, pszFmtStr, auth_b64encoded);
            else
                return false;
        }
        else
            return false;
    }
    else
        return false;

    // reset the connection if required
    m_pSocket->ResetConnection();

    // Resend the request with the authorization information
    LPCURL pUrl = m_pSocket->GetCurrentUrl();   
    bool bRet = false;

    TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
    DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
    pUrl->CreateUrl(szUrl, &dwMaxLen);

    _ATLTRY
    {
        CA2T hdr(auth_header);
        CAtlNavigateData navigate_data;
        navigate_data.SetExtraHeaders(hdr);
        navigate_data.SetMethod(m_pSocket->GetMethod());
        navigate_data.SetPort(pUrl->GetPortNumber());
        navigate_data.SetData(m_pSocket->GetData(),
                              m_pSocket->GetDataLen(),
                              m_pSocket->GetDataType());
        navigate_data.RemoveFlags(ATL_HTTP_FLAG_PROCESS_RESULT);
        bRet = m_pSocket->Navigate( szUrl, &navigate_data);
    }
    _ATLCATCHALL()
    {
        bRet = false;
    }
    if (bRet)
        *pszBuffer = (LPSTR)m_pSocket->GetResponse();
    return bRet;
}

/////////////////////////////////////////////////////////////////////////////////
//
// CBasicAuthObject
// BASIC Security Authorization functions 
//
/////////////////////////////////////////////////////////////////////////////////
inline bool CBasicAuthObject::DoBasicAuthenticate()
{
    bool bRet = false;
    ATLASSERT(m_pClient);
    ATLASSERT(m_pAuthInfo);
    // Create an authentication string
    TCHAR auth_string[ATL_MAX_BASIC_ID_LEN];
    TCHAR szUid[ATL_MAX_USERNAME];
    TCHAR szPwd[ATL_MAX_PWD];

    if (!m_pAuthInfo->GetPassword(szPwd, ATL_MAX_PWD) ||
        !m_pAuthInfo->GetUsername(szUid, ATL_MAX_USERNAME))
        return false;
    _tcscpy(auth_string, szUid);
    _tcscat(auth_string, _T(":"));
    _tcscat(auth_string, szPwd);

    _ATLTRY
    {
        // Base64 encode the auth string
        char *auth_string_enc = NULL;
        CTempBuffer<char, 512> auth_string_buff;
        CT2A auth_string_a(auth_string);

        int nLen = Base64EncodeGetRequiredLength((int)strlen((LPSTR)auth_string_a));
        ATLTRY(auth_string_buff.Allocate(nLen+1));
        if (!((char*)auth_string_buff))
            return false;
        auth_string_enc = (char*)auth_string_buff;
        if (!Base64Encode((const BYTE*)(LPSTR)auth_string_a, (int)strlen((LPSTR)auth_string_a),
                          auth_string_enc, &nLen, ATL_BASE64_FLAG_NOCRLF))
            return false;
        auth_string_buff[nLen]=0;

    // Format the Authentication header
    nLen += (m_bProxy ? (int)strlen(m_pszFmtProxy) : (int)strlen(m_pszFmtWWW)) + 2;

        CTempBuffer<char, 512> auth_header_buff;
        ATLTRY(auth_header_buff.Allocate(nLen));
        if (!((char*)auth_header_buff))
            return false;

        char *auth_header = (char*)auth_header_buff;
        strcpy(auth_header, m_bProxy ? m_pszFmtProxy : m_pszFmtWWW);
        strcat(auth_header, auth_string_enc);
        strcat(auth_header, "\r\n");

        // Resend the request with the authorization information
        LPCURL pUrl = m_pClient->GetCurrentUrl();
        TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
        DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
        pUrl->CreateUrl(szUrl, &dwMaxLen);

        // reset the connection if required
        m_pClient->ResetConnection();

        CA2T hdr(auth_header);
        CAtlNavigateData navigate_data;
        navigate_data.SetExtraHeaders(hdr);
        navigate_data.SetMethod(m_pClient->GetMethod());
        navigate_data.SetPort(pUrl->GetPortNumber());
        navigate_data.SetData(m_pClient->GetData(),
                              m_pClient->GetDataLen(),
                              m_pClient->GetDataType());
        navigate_data.RemoveFlags(ATL_HTTP_FLAG_PROCESS_RESULT);
        bRet = m_pClient->Navigate( szUrl,
                                    &navigate_data);
    }
    _ATLCATCHALL()
    {
        bRet = false;
    }

    if (bRet)
    {
        // Request was successfully sent. Process the result.
        if (m_pClient->GetStatus() == 401 ||
            m_pClient->GetStatus() == 407)
        {
            // Authorization with this protocol failed.
            // don't try it again.
            m_pClient->AuthProtocolFailed(_T("basic"));
        }
        bRet = m_pClient->ProcessStatus(m_pClient->GetFlags());
    }
    return bRet;
}

inline CBasicAuthObject::CBasicAuthObject()
{
    m_pClient = NULL;
    m_pAuthInfo = NULL;
    m_szRealm[0] = 0;
    m_bProxy = false;
}

inline CBasicAuthObject::CBasicAuthObject(IAuthInfo *pAuthInfo)
{
    m_pAuthInfo = pAuthInfo;
    m_pClient = NULL;
}

inline void CBasicAuthObject::SetAuthInfo(IAuthInfo *pAuthInfo)
{
    m_pAuthInfo = pAuthInfo;
}

// Called by the CAtlHttpClient class to 
// authenticate a user.
inline bool CBasicAuthObject::Authenticate(LPCTSTR szAuthTypes, bool bProxy)
{
    TCHAR buff[ATL_AUTH_HDR_SIZE];
    _tcscpy(buff, szAuthTypes);
    _tcslwr(buff);

    m_bProxy = bProxy;
    TCHAR *pBasic = _tcsstr(buff, _T("basic"));
    if (pBasic)
    {
        CrackRealm(pBasic);
        return DoBasicAuthenticate();
    }
    return false;
}

inline LPCTSTR CBasicAuthObject::GetRealm()
{
    return const_cast<LPCTSTR>(m_szRealm);
}

// Called by the CAtlHttpClient class to initialize
// this authentication object.
inline void CBasicAuthObject::Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo)
{
    ATLASSERT(pSocket);
    m_pClient = pSocket;
    if (pAuthInfo)
        SetAuthInfo(pAuthInfo);
}

inline void CBasicAuthObject::CrackRealm(LPTSTR szHeader)
{
    // szHeader is pointing at the
    // "basic" in the header
    // see if realm is available
    TCHAR *pStart = szHeader;

    // skip "basic"
    pStart += 5;
    
    // skip space
    while (*pStart && _istspace(*pStart))
        pStart++;

    // are we pointing at 'realm'?
    if (!memcmp(pStart, "realm", 5))
    {
        // skip 'realm'
        pStart += 5;

        // skip space
        while (*pStart && _istspace(*pStart))
            pStart++;

        // skip '='
        if (*pStart && *pStart == _T('='))
            pStart++;

        // skip space
        while (*pStart && _istspace(*pStart))
            pStart++;

        TCHAR *pEnd = pStart;
        while (*pEnd)
            pEnd++;
        
        if (!(*pEnd))
        {
            int nLen = (int)(pEnd-pStart);
            if (nLen < MAX_REALM_LEN)
            {
                _tcsncpy(m_szRealm, pStart, nLen);
                m_szRealm[nLen]=0;
            }
        }
    }
}

inline CAtlBaseAuthObject::CAtlBaseAuthObject()
{
    m_bFailed = false;
}


inline CAtlNavigateData::CAtlNavigateData() 
{
    dwFlags =   ATL_HTTP_FLAG_AUTO_REDIRECT|
                ATL_HTTP_FLAG_PROCESS_RESULT|
                ATL_HTTP_FLAG_SEND_CHUNKS;
    szExtraHeaders = NULL;
    szMethod = ATL_HTTP_METHOD_GET;
    nPort = ATL_URL_DEFAULT_HTTP_PORT;
    pData = NULL;
    dwDataLen = 0;
    szDataType = NULL;
    dwTimeout = ATL_SOCK_TIMEOUT;
    dwSendChunkSize = ATL_HTTP_DEFAULT_CHUNK_SIZE;
    dwReadChunkSize = ATL_HTTP_DEFAULT_CHUNK_SIZE;
    pfnChunkCallback = NULL;
    pfnSendStatusCallback = NULL;
    pfnReadStatusCallback = NULL;
    m_lParamSend = NULL;
}
inline DWORD CAtlNavigateData::SetFlags(DWORD dwNewFlags) 
{
    // check for mutually exclusive flags
    if ((dwNewFlags & ATL_HTTP_FLAG_SEND_CALLBACK) &&
        (dwNewFlags & ATL_HTTP_FLAG_SEND_CHUNKS))
    {
        ATLASSERT(0);
        return ATL_HTTP_FLAG_INVALID_FLAGS;
    }

    DWORD dwOldFlags = dwFlags;
    dwFlags = dwNewFlags;
    return dwOldFlags;
}

inline DWORD CAtlNavigateData::GetFlags() 
{
    return dwFlags;
}

inline DWORD CAtlNavigateData::AddFlags(DWORD dwFlagsToAdd) 
{
        // check for mutually exclusive flags
    if (
        ((dwFlagsToAdd & ATL_HTTP_FLAG_SEND_CALLBACK) &&
         (dwFlags & ATL_HTTP_FLAG_SEND_CHUNKS)) ||
        ((dwFlagsToAdd & ATL_HTTP_FLAG_SEND_CHUNKS) &&
         (dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK))
       )
    {
        ATLASSERT(0);
        return ATL_HTTP_FLAG_INVALID_FLAGS;
    }

    DWORD dwOldFlags = dwFlags;
    dwFlags |= dwFlagsToAdd;
    return dwOldFlags;
}

inline DWORD CAtlNavigateData::RemoveFlags(DWORD dwFlagsToRemove) 
{
    DWORD dwOldFlags = dwFlags;
    dwFlags &= ~dwFlagsToRemove;
    return dwOldFlags;
}

inline LPCTSTR CAtlNavigateData::SetExtraHeaders(LPCTSTR szNewHeaders)
{
    LPCTSTR szold = szExtraHeaders;
    szExtraHeaders = szNewHeaders;
    return szold;
}

inline LPCTSTR CAtlNavigateData::GetExtraHeaders()
{
    return szExtraHeaders;  
}
inline LPCTSTR CAtlNavigateData::SetMethod(LPCTSTR szNewMethod)
{
    LPCTSTR szold = szMethod;
    szMethod = szNewMethod;
    return szold;
}
inline LPCTSTR CAtlNavigateData::GetMethod()
{
    return szMethod;
}
inline short CAtlNavigateData::SetPort(short newPort)
{
    short oldport = nPort;
    nPort = newPort;
    return oldport;
}
inline short CAtlNavigateData::GetPort()
{
    return nPort;
}
inline void CAtlNavigateData::SetData(BYTE *pd, DWORD len, LPCTSTR type)
{
    pData = pd;
    dwDataLen = len;
    szDataType = type;
}

inline DWORD CAtlNavigateData::SetSocketTimeout(DWORD dwNewTimeout)
{
    DWORD dwold = dwTimeout;
    dwTimeout = dwNewTimeout;
    return dwold;
}
inline DWORD CAtlNavigateData::GetSocketTimeout()
{
    return dwTimeout;
}
inline DWORD CAtlNavigateData::SetSendChunkSize(DWORD dwNewChunkSize)
{
    DWORD dwold = dwSendChunkSize;
    dwSendChunkSize = dwNewChunkSize;
    return dwold;
}
inline DWORD CAtlNavigateData::GetSendChunkSize()
{
    return dwSendChunkSize;
}

inline DWORD CAtlNavigateData::SetReadChunkSize(DWORD dwNewChunkSize)
{
    DWORD dwold = dwReadChunkSize;
    dwReadChunkSize = dwNewChunkSize;
    return dwold;
}

inline DWORD CAtlNavigateData::GetReadChunkSize()
{
    return dwReadChunkSize;
}

inline PFNATLCHUNKEDCB CAtlNavigateData::SetChunkCallback(PFNATLCHUNKEDCB pfn)
{
    PFNATLCHUNKEDCB pold = pfnChunkCallback;
    pfnChunkCallback = pfn;
    return pold;
}
inline PFNATLCHUNKEDCB CAtlNavigateData::GetChunkCallback()
{
    return pfnChunkCallback;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::SetSendStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD dwData)
{
    PFNATLSTATUSCALLBACK pold = pfnSendStatusCallback;
    pfnSendStatusCallback = pfn;
    m_lParamSend = dwData;
    return pold;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::GetSendStatusCallback()
{
    return pfnSendStatusCallback;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::SetReadStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD dwData)
{
    PFNATLSTATUSCALLBACK pOld = pfnReadStatusCallback;
    pfnReadStatusCallback = pfn;
    m_lParamRead = dwData;
    return pOld;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::GetReadStatusCallback()
{
    return pfnReadStatusCallback;
}



#endif // __ATLHTTP_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atliface.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0342 */
/* at Mon Feb 12 21:31:09 2001
 */
/* Compiler settings for atliface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRegistrarBase_FWD_DEFINED__
#define __IRegistrarBase_FWD_DEFINED__
typedef interface IRegistrarBase IRegistrarBase;
#endif 	/* __IRegistrarBase_FWD_DEFINED__ */


#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_FWD_DEFINED__
#define __IDocHostUIHandlerDispatch_FWD_DEFINED__
typedef interface IDocHostUIHandlerDispatch IDocHostUIHandlerDispatch;
#endif 	/* __IDocHostUIHandlerDispatch_FWD_DEFINED__ */


#ifndef __IAxWinHostWindow_FWD_DEFINED__
#define __IAxWinHostWindow_FWD_DEFINED__
typedef interface IAxWinHostWindow IAxWinHostWindow;
#endif 	/* __IAxWinHostWindow_FWD_DEFINED__ */


#ifndef __IAxWinHostWindowLic_FWD_DEFINED__
#define __IAxWinHostWindowLic_FWD_DEFINED__
typedef interface IAxWinHostWindowLic IAxWinHostWindowLic;
#endif 	/* __IAxWinHostWindowLic_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_FWD_DEFINED__
#define __IAxWinAmbientDispatch_FWD_DEFINED__
typedef interface IAxWinAmbientDispatch IAxWinAmbientDispatch;
#endif 	/* __IAxWinAmbientDispatch_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_FWD_DEFINED__
#define __IAxWinAmbientDispatchEx_FWD_DEFINED__
typedef interface IAxWinAmbientDispatchEx IAxWinAmbientDispatchEx;
#endif 	/* __IAxWinAmbientDispatchEx_FWD_DEFINED__ */


#ifndef __IInternalConnection_FWD_DEFINED__
#define __IInternalConnection_FWD_DEFINED__
typedef interface IInternalConnection IInternalConnection;
#endif 	/* __IInternalConnection_FWD_DEFINED__ */


#ifndef __IAccessibleProxy_FWD_DEFINED__
#define __IAccessibleProxy_FWD_DEFINED__
typedef interface IAccessibleProxy IAccessibleProxy;
#endif 	/* __IAccessibleProxy_FWD_DEFINED__ */


#ifndef __IAccessibleServer_FWD_DEFINED__
#define __IAccessibleServer_FWD_DEFINED__
typedef interface IAccessibleServer IAccessibleServer;
#endif 	/* __IAccessibleServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oleacc.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_atliface_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_s_ifspec;

#ifndef __IRegistrarBase_INTERFACE_DEFINED__
#define __IRegistrarBase_INTERFACE_DEFINED__

/* interface IRegistrarBase */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrarBase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e21f8a85-b05d-4243-8183-c7cb405588f7")
    IRegistrarBase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddReplacement( 
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarBaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegistrarBase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegistrarBase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegistrarBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
            IRegistrarBase * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
            IRegistrarBase * This);
        
        END_INTERFACE
    } IRegistrarBaseVtbl;

    interface IRegistrarBase
    {
        CONST_VTBL struct IRegistrarBaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrarBase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrarBase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrarBase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrarBase_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrarBase_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrarBase_AddReplacement_Proxy( 
    IRegistrarBase * This,
    /* [in] */ LPCOLESTR key,
    /* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrarBase_AddReplacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrarBase_ClearReplacements_Proxy( 
    IRegistrarBase * This);


void __RPC_STUB IRegistrarBase_ClearReplacements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrarBase_INTERFACE_DEFINED__ */


#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
    IRegistrar : public IRegistrarBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileRegister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileUnregister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringRegister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringUnregister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceRegister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceUnregister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
            IRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceRegisterSz )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceUnregisterSz )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *FileRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR fileName);
        
        HRESULT ( STDMETHODCALLTYPE *FileUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR fileName);
        
        HRESULT ( STDMETHODCALLTYPE *StringRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR data);
        
        HRESULT ( STDMETHODCALLTYPE *StringUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR data);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        END_INTERFACE
    } IRegistrarVtbl;

    interface IRegistrar
    {
        CONST_VTBL struct IRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)


#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
    (This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
    (This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
    (This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
    (This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__
#define __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__

/* interface IDocHostUIHandlerDispatch */
/* [object][unique][helpstring][uuid][local] */ 

typedef 
enum tagDOCHOSTUIDBLCLKDispatch
    {	docHostUIDblClkDEFAULT	= 0,
	docHostUIDblClkSHOWPROPERTIES	= 1,
	docHostUIDblClkSHOWCODE	= 2
    } 	DOCHOSTUIDBLCLKDispatch;

typedef 
enum tagDocHostUIFlagDispatch
    {	docHostUIFlagDIALOG	= 1,
	docHostUIFlagDISABLE_HELP_MENU	= 2,
	docHostUIFlagNO3DBORDER	= 4,
	docHostUIFlagSCROLL_NO	= 8,
	docHostUIFlagDISABLE_SCRIPT_INACTIVE	= 16,
	docHostUIFlagOPENNEWWIN	= 32,
	docHostUIFlagDISABLE_OFFSCREEN	= 64,
	docHostUIFlagFLAT_SCROLLBAR	= 128,
	docHostUIFlagDIV_BLOCKDEFAULT	= 256,
	docHostUIFlagACTIVATE_CLIENTHIT_ONLY	= 512
    } 	DocHostUIFlagDispatch;


EXTERN_C const IID IID_IDocHostUIHandlerDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("425B5AF0-65F1-11d1-9611-0000F81E0D0D")
    IDocHostUIHandlerDispatch : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown *pcmdtReserved,
            /* [in] */ IDispatch *pdispReserved,
            /* [retval][out] */ HRESULT *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwDoubleClick) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowUI( 
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown *pActiveObject,
            /* [in] */ IUnknown *pCommandTarget,
            /* [in] */ IUnknown *pFrame,
            /* [in] */ IUnknown *pDoc,
            /* [retval][out] */ HRESULT *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DWORD_PTR hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD_PTR wParam,
            /* [in] */ DWORD_PTR lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
            /* [out] */ BSTR *pbstrKey,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
            /* [in] */ IUnknown *pDropTarget,
            /* [out] */ IUnknown **ppDropTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExternal( 
            /* [out] */ IDispatch **ppDispatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR *pbstrURLOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
            /* [in] */ IUnknown *pDO,
            /* [out] */ IUnknown **ppDORet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocHostUIHandlerDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDocHostUIHandlerDispatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDocHostUIHandlerDispatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDocHostUIHandlerDispatch * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *ShowContextMenu )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown *pcmdtReserved,
            /* [in] */ IDispatch *pdispReserved,
            /* [retval][out] */ HRESULT *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostInfo )( 
            IDocHostUIHandlerDispatch * This,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwDoubleClick);
        
        HRESULT ( STDMETHODCALLTYPE *ShowUI )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown *pActiveObject,
            /* [in] */ IUnknown *pCommandTarget,
            /* [in] */ IUnknown *pFrame,
            /* [in] */ IUnknown *pDoc,
            /* [retval][out] */ HRESULT *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *HideUI )( 
            IDocHostUIHandlerDispatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateUI )( 
            IDocHostUIHandlerDispatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *OnDocWindowActivate )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE *OnFrameWindowActivate )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorder )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ DWORD_PTR hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD_PTR wParam,
            /* [in] */ DWORD_PTR lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptionKeyPath )( 
            IDocHostUIHandlerDispatch * This,
            /* [out] */ BSTR *pbstrKey,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *GetDropTarget )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ IUnknown *pDropTarget,
            /* [out] */ IUnknown **ppDropTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetExternal )( 
            IDocHostUIHandlerDispatch * This,
            /* [out] */ IDispatch **ppDispatch);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateUrl )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR *pbstrURLOut);
        
        HRESULT ( STDMETHODCALLTYPE *FilterDataObject )( 
            IDocHostUIHandlerDispatch * This,
            /* [in] */ IUnknown *pDO,
            /* [out] */ IUnknown **ppDORet);
        
        END_INTERFACE
    } IDocHostUIHandlerDispatchVtbl;

    interface IDocHostUIHandlerDispatch
    {
        CONST_VTBL struct IDocHostUIHandlerDispatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocHostUIHandlerDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandlerDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandlerDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocHostUIHandlerDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocHostUIHandlerDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocHostUIHandlerDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocHostUIHandlerDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocHostUIHandlerDispatch_ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)	\
    (This)->lpVtbl -> ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)

#define IDocHostUIHandlerDispatch_GetHostInfo(This,pdwFlags,pdwDoubleClick)	\
    (This)->lpVtbl -> GetHostInfo(This,pdwFlags,pdwDoubleClick)

#define IDocHostUIHandlerDispatch_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)	\
    (This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)

#define IDocHostUIHandlerDispatch_HideUI(This)	\
    (This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandlerDispatch_UpdateUI(This)	\
    (This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandlerDispatch_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandlerDispatch_OnDocWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_OnFrameWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)	\
    (This)->lpVtbl -> ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)

#define IDocHostUIHandlerDispatch_TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)	\
    (This)->lpVtbl -> TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)

#define IDocHostUIHandlerDispatch_GetOptionKeyPath(This,pbstrKey,dw)	\
    (This)->lpVtbl -> GetOptionKeyPath(This,pbstrKey,dw)

#define IDocHostUIHandlerDispatch_GetDropTarget(This,pDropTarget,ppDropTarget)	\
    (This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandlerDispatch_GetExternal(This,ppDispatch)	\
    (This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandlerDispatch_TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)	\
    (This)->lpVtbl -> TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)

#define IDocHostUIHandlerDispatch_FilterDataObject(This,pDO,ppDORet)	\
    (This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowContextMenu_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ DWORD dwID,
    /* [in] */ DWORD x,
    /* [in] */ DWORD y,
    /* [in] */ IUnknown *pcmdtReserved,
    /* [in] */ IDispatch *pdispReserved,
    /* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetHostInfo_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwDoubleClick);


void __RPC_STUB IDocHostUIHandlerDispatch_GetHostInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowUI_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ DWORD dwID,
    /* [in] */ IUnknown *pActiveObject,
    /* [in] */ IUnknown *pCommandTarget,
    /* [in] */ IUnknown *pFrame,
    /* [in] */ IUnknown *pDoc,
    /* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_HideUI_Proxy( 
    IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_HideUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_UpdateUI_Proxy( 
    IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_UpdateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_EnableModeless_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IDocHostUIHandlerDispatch_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnDocWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnFrameWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ResizeBorder_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ long left,
    /* [in] */ long top,
    /* [in] */ long right,
    /* [in] */ long bottom,
    /* [in] */ IUnknown *pUIWindow,
    /* [in] */ VARIANT_BOOL fFrameWindow);


void __RPC_STUB IDocHostUIHandlerDispatch_ResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateAccelerator_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ DWORD_PTR hWnd,
    /* [in] */ DWORD nMessage,
    /* [in] */ DWORD_PTR wParam,
    /* [in] */ DWORD_PTR lParam,
    /* [in] */ BSTR bstrGuidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetOptionKeyPath_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [out] */ BSTR *pbstrKey,
    /* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandlerDispatch_GetOptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetDropTarget_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ IUnknown *pDropTarget,
    /* [out] */ IUnknown **ppDropTarget);


void __RPC_STUB IDocHostUIHandlerDispatch_GetDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetExternal_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [out] */ IDispatch **ppDispatch);


void __RPC_STUB IDocHostUIHandlerDispatch_GetExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateUrl_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ DWORD dwTranslate,
    /* [in] */ BSTR bstrURLIn,
    /* [out] */ BSTR *pbstrURLOut);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_FilterDataObject_Proxy( 
    IDocHostUIHandlerDispatch * This,
    /* [in] */ IUnknown *pDO,
    /* [out] */ IUnknown **ppDORet);


void __RPC_STUB IDocHostUIHandlerDispatch_FilterDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindow_INTERFACE_DEFINED__
#define __IAxWinHostWindow_INTERFACE_DEFINED__

/* interface IAxWinHostWindow */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2050-048A-11d1-82B9-00C04FB9942E")
    IAxWinHostWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateControl( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateControlEx( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [out] */ IUnknown **ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown *punkAdvise) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachControl( 
            /* [in] */ IUnknown *pUnkControl,
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryControl( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalDispatch( 
            /* [in] */ IDispatch *pDisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalUIHandler( 
            /* [in] */ IDocHostUIHandlerDispatch *pDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinHostWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAxWinHostWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAxWinHostWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAxWinHostWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
            IAxWinHostWindow * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
            IAxWinHostWindow * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [out] */ IUnknown **ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown *punkAdvise);
        
        HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
            IAxWinHostWindow * This,
            /* [in] */ IUnknown *pUnkControl,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
            IAxWinHostWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
            IAxWinHostWindow * This,
            /* [in] */ IDispatch *pDisp);
        
        HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
            IAxWinHostWindow * This,
            /* [in] */ IDocHostUIHandlerDispatch *pDisp);
        
        END_INTERFACE
    } IAxWinHostWindowVtbl;

    interface IAxWinHostWindow
    {
        CONST_VTBL struct IAxWinHostWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinHostWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinHostWindow_CreateControl(This,lpTricsData,hWnd,pStream)	\
    (This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindow_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
    (This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindow_AttachControl(This,pUnkControl,hWnd)	\
    (This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindow_QueryControl(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindow_SetExternalDispatch(This,pDisp)	\
    (This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindow_SetExternalUIHandler(This,pDisp)	\
    (This)->lpVtbl -> SetExternalUIHandler(This,pDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControl_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream *pStream);


void __RPC_STUB IAxWinHostWindow_CreateControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControlEx_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream *pStream,
    /* [out] */ IUnknown **ppUnk,
    /* [in] */ REFIID riidAdvise,
    /* [in] */ IUnknown *punkAdvise);


void __RPC_STUB IAxWinHostWindow_CreateControlEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_AttachControl_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ IUnknown *pUnkControl,
    /* [in] */ HWND hWnd);


void __RPC_STUB IAxWinHostWindow_AttachControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_QueryControl_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB IAxWinHostWindow_QueryControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalDispatch_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ IDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalUIHandler_Proxy( 
    IAxWinHostWindow * This,
    /* [in] */ IDocHostUIHandlerDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalUIHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindow_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindowLic_INTERFACE_DEFINED__
#define __IAxWinHostWindowLic_INTERFACE_DEFINED__

/* interface IAxWinHostWindowLic */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindowLic;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3935BDA8-4ED9-495c-8650-E01FC1E38A4B")
    IAxWinHostWindowLic : public IAxWinHostWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateControlLic( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [in] */ BSTR bstrLic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateControlLicEx( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [out] */ IUnknown **ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown *punkAdvise,
            /* [in] */ BSTR bstrLic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinHostWindowLicVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAxWinHostWindowLic * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAxWinHostWindowLic * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAxWinHostWindowLic * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
            IAxWinHostWindowLic * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
            IAxWinHostWindowLic * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [out] */ IUnknown **ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown *punkAdvise);
        
        HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
            IAxWinHostWindowLic * This,
            /* [in] */ IUnknown *pUnkControl,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
            IAxWinHostWindowLic * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
            IAxWinHostWindowLic * This,
            /* [in] */ IDispatch *pDisp);
        
        HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
            IAxWinHostWindowLic * This,
            /* [in] */ IDocHostUIHandlerDispatch *pDisp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControlLic )( 
            IAxWinHostWindowLic * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [in] */ BSTR bstrLic);
        
        HRESULT ( STDMETHODCALLTYPE *CreateControlLicEx )( 
            IAxWinHostWindowLic * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream *pStream,
            /* [out] */ IUnknown **ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown *punkAdvise,
            /* [in] */ BSTR bstrLic);
        
        END_INTERFACE
    } IAxWinHostWindowLicVtbl;

    interface IAxWinHostWindowLic
    {
        CONST_VTBL struct IAxWinHostWindowLicVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinHostWindowLic_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindowLic_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindowLic_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinHostWindowLic_CreateControl(This,lpTricsData,hWnd,pStream)	\
    (This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindowLic_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
    (This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindowLic_AttachControl(This,pUnkControl,hWnd)	\
    (This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindowLic_QueryControl(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindowLic_SetExternalDispatch(This,pDisp)	\
    (This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindowLic_SetExternalUIHandler(This,pDisp)	\
    (This)->lpVtbl -> SetExternalUIHandler(This,pDisp)


#define IAxWinHostWindowLic_CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)	\
    (This)->lpVtbl -> CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)

#define IAxWinHostWindowLic_CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)	\
    (This)->lpVtbl -> CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLic_Proxy( 
    IAxWinHostWindowLic * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream *pStream,
    /* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLicEx_Proxy( 
    IAxWinHostWindowLic * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream *pStream,
    /* [out] */ IUnknown **ppUnk,
    /* [in] */ REFIID riidAdvise,
    /* [in] */ IUnknown *punkAdvise,
    /* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLicEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindowLic_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatch_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatch */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2051-048A-11d1-82B9-00C04FB9942E")
    IAxWinAmbientDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowWindowlessActivation( 
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowWindowlessActivation( 
            /* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clrBackground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR *pclrBackground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR clrForeground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ OLE_COLOR *pclrForeground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocaleID( 
            /* [in] */ LCID lcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
            /* [retval][out] */ LCID *plcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserMode( 
            /* [in] */ VARIANT_BOOL bUserMode) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserMode( 
            /* [retval][out] */ VARIANT_BOOL *pbUserMode) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayAsDefault( 
            /* [in] */ VARIANT_BOOL bDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayAsDefault( 
            /* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ IFontDisp *pFont) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ IFontDisp **pFont) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessageReflect( 
            /* [in] */ VARIANT_BOOL bMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MessageReflect( 
            /* [retval][out] */ VARIANT_BOOL *pbMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowGrabHandles( 
            /* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowHatching( 
            /* [retval][out] */ VARIANT_BOOL *pbShowHatching) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostFlags( 
            /* [in] */ DWORD dwDocHostFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostFlags( 
            /* [retval][out] */ DWORD *pdwDocHostFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostDoubleClickFlags( 
            /* [in] */ DWORD dwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostDoubleClickFlags( 
            /* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContextMenu( 
            /* [in] */ VARIANT_BOOL bAllowContextMenu) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowShowUI( 
            /* [in] */ VARIANT_BOOL bAllowShowUI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowShowUI( 
            /* [retval][out] */ VARIANT_BOOL *pbAllowShowUI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OptionKeyPath( 
            /* [in] */ BSTR bstrOptionKeyPath) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OptionKeyPath( 
            /* [retval][out] */ BSTR *pbstrOptionKeyPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinAmbientDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAxWinAmbientDispatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAxWinAmbientDispatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAxWinAmbientDispatch * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ OLE_COLOR clrBackground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ OLE_COLOR *pclrBackground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ OLE_COLOR clrForeground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ OLE_COLOR *pclrForeground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ LCID lcidLocaleID);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ LCID *plcidLocaleID);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bUserMode);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbUserMode);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bDisplayAsDefault);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ IFontDisp *pFont);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ IFontDisp **pFont);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbShowHatching);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ DWORD dwDocHostFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ DWORD *pdwDocHostFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ DWORD dwDocHostDoubleClickFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bAllowContextMenu);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ VARIANT_BOOL bAllowShowUI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
            IAxWinAmbientDispatch * This,
            /* [in] */ BSTR bstrOptionKeyPath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
            IAxWinAmbientDispatch * This,
            /* [retval][out] */ BSTR *pbstrOptionKeyPath);
        
        END_INTERFACE
    } IAxWinAmbientDispatchVtbl;

    interface IAxWinAmbientDispatch
    {
        CONST_VTBL struct IAxWinAmbientDispatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinAmbientDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatch_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
    (This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatch_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
    (This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatch_put_BackColor(This,clrBackground)	\
    (This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatch_get_BackColor(This,pclrBackground)	\
    (This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatch_put_ForeColor(This,clrForeground)	\
    (This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatch_get_ForeColor(This,pclrForeground)	\
    (This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatch_put_LocaleID(This,lcidLocaleID)	\
    (This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatch_get_LocaleID(This,plcidLocaleID)	\
    (This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatch_put_UserMode(This,bUserMode)	\
    (This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatch_get_UserMode(This,pbUserMode)	\
    (This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatch_put_DisplayAsDefault(This,bDisplayAsDefault)	\
    (This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatch_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
    (This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatch_put_Font(This,pFont)	\
    (This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatch_get_Font(This,pFont)	\
    (This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatch_put_MessageReflect(This,bMsgReflect)	\
    (This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatch_get_MessageReflect(This,pbMsgReflect)	\
    (This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatch_get_ShowGrabHandles(This,pbShowGrabHandles)	\
    (This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatch_get_ShowHatching(This,pbShowHatching)	\
    (This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatch_put_DocHostFlags(This,dwDocHostFlags)	\
    (This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatch_get_DocHostFlags(This,pdwDocHostFlags)	\
    (This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatch_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_put_AllowContextMenu(This,bAllowContextMenu)	\
    (This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatch_get_AllowContextMenu(This,pbAllowContextMenu)	\
    (This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatch_put_AllowShowUI(This,bAllowShowUI)	\
    (This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatch_get_AllowShowUI(This,pbAllowShowUI)	\
    (This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatch_put_OptionKeyPath(This,bstrOptionKeyPath)	\
    (This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatch_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
    (This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_BackColor_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ OLE_COLOR clrBackground);


void __RPC_STUB IAxWinAmbientDispatch_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_BackColor_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ OLE_COLOR *pclrBackground);


void __RPC_STUB IAxWinAmbientDispatch_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_ForeColor_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ OLE_COLOR clrForeground);


void __RPC_STUB IAxWinAmbientDispatch_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ForeColor_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ OLE_COLOR *pclrForeground);


void __RPC_STUB IAxWinAmbientDispatch_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_LocaleID_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ LCID lcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_put_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_LocaleID_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ LCID *plcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_get_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_UserMode_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bUserMode);


void __RPC_STUB IAxWinAmbientDispatch_put_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_UserMode_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbUserMode);


void __RPC_STUB IAxWinAmbientDispatch_get_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_put_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_get_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_Font_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ IFontDisp *pFont);


void __RPC_STUB IAxWinAmbientDispatch_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_Font_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ IFontDisp **pFont);


void __RPC_STUB IAxWinAmbientDispatch_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_MessageReflect_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_put_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_MessageReflect_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_get_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowGrabHandles_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowGrabHandles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowHatching_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbShowHatching);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowHatching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ DWORD dwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ DWORD *pdwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ DWORD dwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ VARIANT_BOOL bAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [in] */ BSTR bstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_put_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch * This,
    /* [retval][out] */ BSTR *pbstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_get_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatchEx */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2D0778B-AC99-4c58-A5C8-E7724E5316B5")
    IAxWinAmbientDispatchEx : public IAxWinAmbientDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAmbientDispatch( 
            /* [in] */ IDispatch *pDispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinAmbientDispatchExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAxWinAmbientDispatchEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAxWinAmbientDispatchEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAxWinAmbientDispatchEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ OLE_COLOR clrBackground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ OLE_COLOR *pclrBackground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ OLE_COLOR clrForeground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ OLE_COLOR *pclrForeground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ LCID lcidLocaleID);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ LCID *plcidLocaleID);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bUserMode);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbUserMode);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bDisplayAsDefault);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ IFontDisp *pFont);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ IFontDisp **pFont);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbShowHatching);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ DWORD dwDocHostFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ DWORD *pdwDocHostFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ DWORD dwDocHostDoubleClickFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bAllowContextMenu);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ VARIANT_BOOL bAllowShowUI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ BSTR bstrOptionKeyPath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
            IAxWinAmbientDispatchEx * This,
            /* [retval][out] */ BSTR *pbstrOptionKeyPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAmbientDispatch )( 
            IAxWinAmbientDispatchEx * This,
            /* [in] */ IDispatch *pDispatch);
        
        END_INTERFACE
    } IAxWinAmbientDispatchExVtbl;

    interface IAxWinAmbientDispatchEx
    {
        CONST_VTBL struct IAxWinAmbientDispatchExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinAmbientDispatchEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatchEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatchEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatchEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatchEx_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
    (This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
    (This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_put_BackColor(This,clrBackground)	\
    (This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatchEx_get_BackColor(This,pclrBackground)	\
    (This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatchEx_put_ForeColor(This,clrForeground)	\
    (This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatchEx_get_ForeColor(This,pclrForeground)	\
    (This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatchEx_put_LocaleID(This,lcidLocaleID)	\
    (This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatchEx_get_LocaleID(This,plcidLocaleID)	\
    (This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatchEx_put_UserMode(This,bUserMode)	\
    (This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatchEx_get_UserMode(This,pbUserMode)	\
    (This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatchEx_put_DisplayAsDefault(This,bDisplayAsDefault)	\
    (This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatchEx_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
    (This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatchEx_put_Font(This,pFont)	\
    (This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatchEx_get_Font(This,pFont)	\
    (This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatchEx_put_MessageReflect(This,bMsgReflect)	\
    (This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatchEx_get_MessageReflect(This,pbMsgReflect)	\
    (This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatchEx_get_ShowGrabHandles(This,pbShowGrabHandles)	\
    (This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatchEx_get_ShowHatching(This,pbShowHatching)	\
    (This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatchEx_put_DocHostFlags(This,dwDocHostFlags)	\
    (This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatchEx_get_DocHostFlags(This,pdwDocHostFlags)	\
    (This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatchEx_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_put_AllowContextMenu(This,bAllowContextMenu)	\
    (This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatchEx_get_AllowContextMenu(This,pbAllowContextMenu)	\
    (This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatchEx_put_AllowShowUI(This,bAllowShowUI)	\
    (This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatchEx_get_AllowShowUI(This,pbAllowShowUI)	\
    (This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatchEx_put_OptionKeyPath(This,bstrOptionKeyPath)	\
    (This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatchEx_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
    (This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)


#define IAxWinAmbientDispatchEx_SetAmbientDispatch(This,pDispatch)	\
    (This)->lpVtbl -> SetAmbientDispatch(This,pDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatchEx_SetAmbientDispatch_Proxy( 
    IAxWinAmbientDispatchEx * This,
    /* [in] */ IDispatch *pDispatch);


void __RPC_STUB IAxWinAmbientDispatchEx_SetAmbientDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IInternalConnection_INTERFACE_DEFINED__
#define __IInternalConnection_INTERFACE_DEFINED__

/* interface IInternalConnection */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72AD0770-6A9F-11d1-BCEC-0060088F444E")
    IInternalConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddConnection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseConnection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternalConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternalConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternalConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternalConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddConnection )( 
            IInternalConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseConnection )( 
            IInternalConnection * This);
        
        END_INTERFACE
    } IInternalConnectionVtbl;

    interface IInternalConnection
    {
        CONST_VTBL struct IInternalConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternalConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternalConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternalConnection_AddConnection(This)	\
    (This)->lpVtbl -> AddConnection(This)

#define IInternalConnection_ReleaseConnection(This)	\
    (This)->lpVtbl -> ReleaseConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternalConnection_AddConnection_Proxy( 
    IInternalConnection * This);


void __RPC_STUB IInternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalConnection_ReleaseConnection_Proxy( 
    IInternalConnection * This);


void __RPC_STUB IInternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternalConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atliface_0257 */
/* [local] */ 

namespace ATL
{
#ifdef __cplusplus
#include <atldef.h>
#else
#define ATLAPI EXTERN_C HRESULT __declspec(dllimport) __stdcall
#define ATLAPI_(x) EXTERN_C __declspec(dllimport) x __stdcall
#define ATLINLINE
#endif	// __cplusplus

ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxDialogBox AtlAxDialogBoxW
#else
#define AtlAxDialogBox AtlAxDialogBoxA
#endif

ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxCreateDialog AtlAxCreateDialogW
#else
#define AtlAxCreateDialog AtlAxCreateDialogA
#endif

ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer);
#ifdef __cplusplus
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL);
ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic = NULL);
ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL, BSTR bstrLic = NULL);
#else
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink, IUnknown* punkSink);
ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic);
ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink, IUnknown* punkSink, BSTR bstrLic);
#endif	// __cplusplus
ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer);
ATLAPI_(BOOL) AtlAxWinInit();

ATLAPI AtlAxGetHost(HWND h, IUnknown** pp);
ATLAPI AtlAxGetControl(HWND h, IUnknown** pp);

}; //namespace ATL



extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_s_ifspec;

#ifndef __IAccessibleProxy_INTERFACE_DEFINED__
#define __IAccessibleProxy_INTERFACE_DEFINED__

/* interface IAccessibleProxy */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A7D9DCF-B7A1-4019-9031-258268846980")
    IAccessibleProxy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [in] */ IAccessible *pAccessible,
            /* [in] */ IAccessibleServer *pServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAccessibleProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAccessibleProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAccessibleProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetServer )( 
            IAccessibleProxy * This,
            /* [in] */ IAccessible *pAccessible,
            /* [in] */ IAccessibleServer *pServer);
        
        END_INTERFACE
    } IAccessibleProxyVtbl;

    interface IAccessibleProxy
    {
        CONST_VTBL struct IAccessibleProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleProxy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleProxy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessibleProxy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessibleProxy_SetServer(This,pAccessible,pServer)	\
    (This)->lpVtbl -> SetServer(This,pAccessible,pServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleProxy_SetServer_Proxy( 
    IAccessibleProxy * This,
    /* [in] */ IAccessible *pAccessible,
    /* [in] */ IAccessibleServer *pServer);


void __RPC_STUB IAccessibleProxy_SetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleProxy_INTERFACE_DEFINED__ */


#ifndef __IAccessibleServer_INTERFACE_DEFINED__
#define __IAccessibleServer_INTERFACE_DEFINED__

/* interface IAccessibleServer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52C8FB5E-D779-4e77-AE9F-F611FA7E9D7A")
    IAccessibleServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProxy( 
            /* [in] */ IAccessibleProxy *pUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHWND( 
            /* [out] */ HWND *phWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumVariant( 
            /* [out] */ IEnumVARIANT **ppEnumVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAccessibleServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAccessibleServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAccessibleServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxy )( 
            IAccessibleServer * This,
            /* [in] */ IAccessibleProxy *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetHWND )( 
            IAccessibleServer * This,
            /* [out] */ HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumVariant )( 
            IAccessibleServer * This,
            /* [out] */ IEnumVARIANT **ppEnumVariant);
        
        END_INTERFACE
    } IAccessibleServerVtbl;

    interface IAccessibleServer
    {
        CONST_VTBL struct IAccessibleServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessibleServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessibleServer_SetProxy(This,pUnknown)	\
    (This)->lpVtbl -> SetProxy(This,pUnknown)

#define IAccessibleServer_GetHWND(This,phWnd)	\
    (This)->lpVtbl -> GetHWND(This,phWnd)

#define IAccessibleServer_GetEnumVariant(This,ppEnumVariant)	\
    (This)->lpVtbl -> GetEnumVariant(This,ppEnumVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleServer_SetProxy_Proxy( 
    IAccessibleServer * This,
    /* [in] */ IAccessibleProxy *pUnknown);


void __RPC_STUB IAccessibleServer_SetProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetHWND_Proxy( 
    IAccessibleServer * This,
    /* [out] */ HWND *phWnd);


void __RPC_STUB IAccessibleServer_GetHWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetEnumVariant_Proxy( 
    IAccessibleServer * This,
    /* [out] */ IEnumVARIANT **ppEnumVariant);


void __RPC_STUB IAccessibleServer_GetEnumVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleServer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlimpl.cpp is obsolete. Please remove it from your project.")

/////////////////////////////////////////////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlmime.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMIME_H__
#define __ATLMIME_H__

#pragma once

#include <tchar.h>
#include <time.h>
#include <atlbase.h>
#include <mlang.h>
#include <atlfile.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlsmtputil.h>
#include <atlenc.h>
#include <atlspriv.h>

#ifndef _CPPUNWIND
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif // _CPPUNWIND

namespace ATL {

extern __declspec(selectany) const DWORD ATL_MIME_BOUNDARYLEN = 32;
extern __declspec(selectany) const DWORD ATL_MIME_DATE_LEN    = 64;

// Called when message is sent - sets the "Date:" field
inline void SetRfc822Time(LPSTR szDate) throw()
{
	static const LPCSTR s_months[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                               "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

	static const LPCSTR s_days[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

	SYSTEMTIME st;
	DWORD      dwTimeZoneId=TIME_ZONE_ID_UNKNOWN;
	CHAR       cDiff;
	LONG       ltzBias=0;
	LONG       ltzHour;
	LONG       ltzMinute;
	TIME_ZONE_INFORMATION tzi;

	GetLocalTime(&st);

	// Gets TIME_ZONE_INFORMATION
	dwTimeZoneId = GetTimeZoneInformation(&tzi);
	switch (dwTimeZoneId)
	{
	case TIME_ZONE_ID_STANDARD:
		ltzBias = tzi.Bias + tzi.StandardBias;
		break;

	case TIME_ZONE_ID_DAYLIGHT:
		ltzBias = tzi.Bias + tzi.DaylightBias;
		break;

	case TIME_ZONE_ID_UNKNOWN:
	default:
		ltzBias = tzi.Bias;
		break;
	}

	// Set Hour Minutes and time zone dif
	ltzHour = ltzBias / 60;
	ltzMinute = ltzBias % 60;
	cDiff = (ltzHour < 0) ? '+' : '-';

	int nDay = (st.wDayOfWeek > 6) ? 0 : st.wDayOfWeek;
	int nMonth = st.wMonth = (WORD)((st.wMonth < 1 || st.wMonth > 12) ? 0 : st.wMonth - 1);


	// Constructs RFC 822 format: "ddd, dd mmm yyyy hh:mm:ss +/- hhmm\0"
	wsprintfA(szDate, "Date: %3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",
					  s_days[nDay],                            // "ddd"
					  st.wDay,                                 // "dd"
					  s_months[nMonth],                        // "mmm"
					  st.wYear,                                // "yyyy"
					  st.wHour,                                // "hh"
					  st.wMinute,                              // "mm"
					  st.wSecond,                              // "ss"
					  cDiff,                                   // "+" / "-"
					  abs (ltzHour),                           // "hh"
					  abs (ltzMinute));                        // "mm"
}

inline DWORD GetContentTypeFromFileName(LPCTSTR szFileName, CSimpleString& strContentType) throw()
{
	if (szFileName == NULL)
	{
		return ERROR_INVALID_DATA;
	}

	DWORD dwErr = ERROR_PATH_NOT_FOUND;
	_ATLTRY
	{
		// get the file extension
		TCHAR szExt[_MAX_EXT];
		_tsplitpath(szFileName, NULL, NULL, NULL, szExt);
		if (*szExt)
		{
			// Query the content type from the registry
			CRegKey rkContentType;
			dwErr = rkContentType.Open(HKEY_CLASSES_ROOT, szExt, KEY_READ);
			if (dwErr == ERROR_SUCCESS)
			{
				ULONG nChars=0;
				dwErr = rkContentType.QueryStringValue(_T("Content Type"), NULL, &nChars);
				if (dwErr == ERROR_SUCCESS)
				{
					LPTSTR szBuf = strContentType.GetBuffer(nChars);
					dwErr = rkContentType.QueryStringValue(_T("Content Type"), szBuf, &nChars);
					strContentType.ReleaseBuffer(nChars);
				}
			}
		}
		
		if (dwErr != ERROR_SUCCESS)
		{
			// default to application/octet-stream
			strContentType.SetString(_T("application/octet-stream"), sizeof("application/octet-stream")-1);
		}
	}
	_ATLCATCHALL()
	{
		dwErr = ERROR_OUTOFMEMORY;
	}

	return dwErr;
}

// CMimeBodyPart is an abstract base class for the body parts
// CMimeAttachment, CMimeText, CMimeHeader.
class CMimeBodyPart
{
public:

	virtual ~CMimeBodyPart() = 0 {}

	// WriteData - pure virtual method to dump the data for a body part.
	virtual BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) = 0;

	// GetContentType - pure virtual method to get the content of a body part
	virtual LPCSTR GetContentType() = 0;

	// GetCharset - virtual method to get the character set of a body part
	// (defaults to ATLSMTP_DEFAULT_CSET).
	virtual LPCSTR GetCharset()
	{
		return ATLSMTP_DEFAULT_CSET;
	}

	virtual CMimeBodyPart* Copy() = 0;

protected:

	// MakeMimeHeader - pure virutal method to create a MIME header for a 
	// body part.
	virtual BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) = 0;
}; // class CMimeBodyPart


// This enum is used with the X-Priority part of the message header
typedef enum {
	ATL_MIME_HIGH_PRIORITY   = 1, 
	ATL_MIME_NORMAL_PRIORITY = 3, 
	ATL_MIME_LOW_PRIORITY    = 5, 
	ATL_MIME_PRIORITY_ERROR  = 0
} ATL_MIME_PRIORITY;


// CMimeHeader describes the basic RFC 822 message header.
// It also serves as the base class for the CMimeMessage object.
class CMimeHeader : public CMimeBodyPart
{
protected:

	// Pointer to MLANG's IMultiLanguage interface.
	// This is used in doing conversion from code pages
	// to MIME-compatible character sets.
	CComPtr<IMultiLanguage> m_spMultiLanguage;

	//Basic Header Parts
	CStringA        m_strFrom;
	CStringA        m_strTo;
	CStringA        m_strCc;
	CStringA        m_strBcc;
	CStringA        m_strSubject;

	//Extended Header Parts
	ATL_MIME_PRIORITY   m_nPriority;
	CStringA        m_XHeader;

	//Display Names
	CStringA        m_strSenderName;

	//MIME Character Sets
	char            m_szSubjectCharset[ATL_MAX_ENC_CHARSET_LENGTH];
	char            m_szSenderCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	//Recipient and CC charsets are encoded in the Add methods

public:

	CMimeHeader() throw()
		:m_nPriority(ATL_MIME_NORMAL_PRIORITY)
	{
		m_szSubjectCharset[0] = '\0';
		m_szSenderCharset[0] = '\0';
	}

	~CMimeHeader() throw()
	{
	}

	// Initialize MLang for multilanguage support
	inline BOOL Initialize(IMultiLanguage* pMultiLanguage = NULL) throw()
	{
		if (pMultiLanguage != NULL)
		{
			m_spMultiLanguage = pMultiLanguage;
		}
		else
		{
			HRESULT hr = m_spMultiLanguage.CoCreateInstance(__uuidof(CMultiLanguage));
			if (hr != S_OK)
				return FALSE;
		}
		return TRUE;
	}

	// Get the content type
	virtual inline LPCSTR GetContentType() throw()
	{
		return "text/plain";
	}

	// Get the character set
	virtual inline LPCSTR GetCharset() throw()
	{
		return "iso-8859-1";
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeHeader> pNewHeader;
		ATLTRY(pNewHeader.Attach(new CMimeHeader));
		if (pNewHeader)
			*pNewHeader = *this;

		return pNewHeader.Detach();
	}

	const CMimeHeader& operator=(const CMimeHeader& that) throw( ... )
	{
		if (this != &that)
		{
			m_spMultiLanguage = that.m_spMultiLanguage;
			m_strFrom = that.m_strFrom;
			m_strTo = that.m_strTo;
			m_strCc = that.m_strCc;
			m_strSubject = that.m_strSubject;

			m_nPriority = that.m_nPriority;
			m_XHeader = that.m_XHeader;

			m_strSenderName = that.m_strSenderName;

			strcpy(m_szSubjectCharset, that.m_szSubjectCharset);
			strcpy(m_szSenderCharset, that.m_szSenderCharset);
		}

		return *this;
	}

	// Set the priority of the message
	inline BOOL SetPriority(ATL_MIME_PRIORITY nPriority) throw()
	{
		if (nPriority < 0)
			return FALSE;
		m_nPriority = nPriority;
		return TRUE;
	}

	// Get the priority of the message
	inline ATL_MIME_PRIORITY GetPriority() throw()
	{
		return m_nPriority;
	}

	// Set the display (friendly) name for the header
	inline BOOL SetSenderName(LPCTSTR szName, UINT uiCodePage = 0) throw()
	{
		if (szName == NULL)
			return FALSE;

		CHeapPtr<char> szNamePtr;
		UINT nLen(0);

		BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szName, &szNamePtr, &nLen);
		if (bRet)
		{
			_ATLTRY
			{
				m_strSenderName.Empty();
				m_strSenderName.Append(szNamePtr, (int) nLen);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
			bRet = AtlMimeCharsetFromCodePage(m_szSenderCharset, uiCodePage, m_spMultiLanguage);
		}

		return bRet;
	}

	// Get the display (friendly) name for the sender
	inline LPCSTR GetSenderName() throw()
	{
		return m_strSenderName;
	}

	// Append a user defined header (should not contain CRLF)
	inline BOOL AppendUserDefinedHeader(LPCTSTR szHeaderName, LPCTSTR szHeader, UINT uiCodePage = 0) throw()
	{
		if ((szHeader == NULL) || (szHeaderName == NULL))
			return FALSE;

		_ATLTRY
		{
			CHeapPtr<char> szName;
			UINT nLen(0);

			BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szHeader, &szName, &nLen);
			if (bRet)
			{
				// get the charset
				char szCharset[ATL_MAX_ENC_CHARSET_LENGTH];			
				bRet = AtlMimeCharsetFromCodePage(szCharset, uiCodePage, m_spMultiLanguage);

				if (bRet)
				{
					CStringA str;
					str.Append(szName, (int)nLen);

					// encode the string
					CHeapPtr<char> szBuf;
					DWORD dwReqLen = QEncodeGetRequiredLength(str.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH);

					if (szBuf.Allocate(dwReqLen) == false)
					{
						return FALSE;
					}

					DWORD dwLength(0);
					if (!GetEncodedString(str, szCharset, szBuf, dwReqLen, dwLength))
						return FALSE;

					// add to m_XHeader
					m_XHeader += CT2CA(szHeaderName);
					m_XHeader.Append(": ", 2);
					m_XHeader.Append(szBuf, dwLength);
					m_XHeader.Append("\r\n", 2);
				}
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Add a recipient ("To:" line)
	inline BOOL AddRecipient(LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		return AddRecipientHelper(m_strTo, szAddress, szName, uiCodePage);
	}

	// Get the recipients string ("To:" line)
	inline LPCSTR GetRecipients() throw()
	{
		return m_strTo;
	}

	// Clear all recipients ("To:" line)
	inline BOOL ClearRecipients() throw()
	{
		m_strTo.Empty();
		return TRUE;
	}

	// Add a recipient ("CC:" line)
	inline BOOL AddCc(LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		return AddRecipientHelper(m_strCc, szAddress, szName, uiCodePage);
	}

	// Get the recipients string ("CC:" line)
	inline LPCSTR GetCc() throw()
	{
		return m_strCc;
	}

	// Clear the recipients string ("CC:" line)
	inline BOOL ClearCc() throw()
	{
		m_strCc.Empty();
		return TRUE;
	}

	// Add a Bcc recipient (not output as part of message)
	inline BOOL AddBcc(LPCTSTR szAddress) throw()
	{
		if (szAddress == NULL)
		{
			return FALSE;
		}

		_ATLTRY
		{
			CStringA str = m_strBcc;

			if (m_strBcc.GetLength() > 0)
				str.Append(",", 1);

			str += CT2CA(szAddress);

			m_strBcc = str;

			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the recipients string (Bcc part)
	inline LPCSTR GetBcc() throw()
	{
		return m_strBcc;
	}

	// Clear the recipients string (Bcc part)
	inline BOOL ClearBcc() throw()
	{
		m_strBcc.Empty();
		return TRUE;
	}


	inline DWORD GetRequiredRecipientsStringLength() throw()
	{
		DWORD dwRet = m_strTo.GetLength();
		if (m_strCc.GetLength())
		{
			dwRet += dwRet ? 1 : 0;
			dwRet += m_strCc.GetLength();
		}
		if (m_strBcc.GetLength())
		{
			dwRet += dwRet ? 1 : 0;
			dwRet += m_strBcc.GetLength();
		}
		dwRet++;
		return dwRet;
	}

	// returns the recipients string to be (addresses only, in comma separated format)
	ATL_NOINLINE BOOL GetRecipientsString(LPSTR szRecip, LPDWORD pdwLen) throw()
	{
		if (szRecip == NULL)
		{
			return FALSE;
		}

		if ((pdwLen != NULL) && (*pdwLen < GetRequiredRecipientsStringLength()))
		{
			*pdwLen = GetRequiredRecipientsStringLength();
			return FALSE;
		}

		if (pdwLen != NULL)
		{
			*pdwLen = 0;
		}

		DWORD dwLen = 0;
		DWORD dwTotalLen = 0;
		if (m_strTo.GetLength() > 0)
		{
			if (AtlMimeMakeRecipientsString(m_strTo, szRecip, &dwLen) != TRUE)
			{
				return FALSE;
			}
			szRecip+= dwLen;
			dwTotalLen = dwLen;
		}

		if (m_strCc.GetLength() > 0)
		{
			if (dwTotalLen)
			{
				*szRecip++ = ',';
				dwTotalLen++;
			}
			if (AtlMimeMakeRecipientsString(m_strCc, szRecip, &dwLen) != TRUE)
			{
				return FALSE;
			}
			szRecip+= dwLen;
			dwTotalLen+= dwLen;
		}

		if (m_strBcc.GetLength() > 0)
		{
			dwLen = m_strBcc.GetLength();
			if (dwTotalLen)
			{
				*szRecip++ = ',';
				dwTotalLen++;
			}
			memcpy(szRecip, m_strBcc, dwLen);
			szRecip+= dwLen;
			dwTotalLen+= dwLen;
		}

		*szRecip = '\0';
		if (pdwLen != NULL)
		{
			*pdwLen = dwTotalLen;
		}

		return TRUE;
	}


	// Get the sender
	inline LPCSTR GetSender() throw()
	{
		return m_strFrom;
	}

	// Set the sender
	inline BOOL SetSender(LPCTSTR szSender) throw()
	{
		if (szSender == NULL)
			return FALSE;

		_ATLTRY
		{
			m_strFrom = CT2CA(szSender);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Set the subject
	inline BOOL SetSubject(LPCTSTR szSubject, UINT uiCodePage = 0) throw()
	{
		if (szSubject == NULL)
			return FALSE;

		_ATLTRY
		{
			CHeapPtr<char> szName;
			UINT nLen(0);

			BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szSubject, &szName, &nLen);
			if (bRet)
			{
				m_strSubject.Empty();
				m_strSubject.Append(szName, (int)nLen);
				bRet = AtlMimeCharsetFromCodePage(m_szSubjectCharset, uiCodePage, m_spMultiLanguage);
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the subject
	inline LPCSTR GetSubject() throw()
	{
		return (LPCSTR)m_strSubject;
	}

	// Dump the header to hFile
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR /*szBoundary*/, DWORD dwFlags = 0) throw()
	{
		if (pOverlapped == NULL)
		{
			return FALSE;
		}

		CHeapPtr<char> spSendBuffer;
		if (!spSendBuffer.Allocate(GetRequiredBufferSize(ATLSMTP_MAX_LINE_LENGTH-4)))
			return FALSE;

		// choose QEncode here, because the max QEncodeGetRequiredLength will always
		// return a value greater than BEncodeGetRequiredLength
		int nBufLen = max(QEncodeGetRequiredLength(m_strSubject.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH),
		                  QEncodeGetRequiredLength(m_strSenderName.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH)+m_strFrom.GetLength()+2);

		CHeapPtr<char> spBuf;
		if (!spBuf.Allocate(nBufLen))
			return FALSE;

		DWORD dwOffset = 0;

		char szDate[ATL_MIME_DATE_LEN];

		SetRfc822Time(szDate);
		char *pSendBuffer = spSendBuffer;

		DWORD dwLength = (DWORD) strlen(szDate);
		memcpy(pSendBuffer+dwOffset, szDate, dwLength);
		dwOffset += dwLength;
		*(pSendBuffer+dwOffset++) = '\r';
		*(pSendBuffer+dwOffset++) = '\n';

		DWORD dwHeaderPartLength = 0;
		*spBuf = '\0';

		// Get the sender name
		BOOL bRet = TRUE;
		if (m_strSenderName.GetLength() > 0)
		{
			bRet = GetEncodedString(m_strSenderName, m_szSenderCharset, spBuf, nBufLen, dwLength);
			dwHeaderPartLength += dwLength;
		}

		// Get the sender email address
		if (bRet && m_strFrom.GetLength() > 0)
		{
			if (dwHeaderPartLength != 0)
			{
				*(spBuf+dwHeaderPartLength++) = ' ';
			}
			*(spBuf+dwHeaderPartLength++) = '<';
			memcpy(spBuf+dwHeaderPartLength, (LPCSTR)m_strFrom, m_strFrom.GetLength());
			dwHeaderPartLength+= m_strFrom.GetLength();
			*(spBuf+dwHeaderPartLength++) = '>';
		}

		// Output the "From: " line
		if (bRet && dwHeaderPartLength != 0)
		{
			memcpy(pSendBuffer+dwOffset, "From: ", sizeof("From: ")-1);
			dwOffset+= 6;
			DWORD dwWritten = 0;
			bRet = FormatField((LPBYTE)(char*)spBuf, dwHeaderPartLength, (LPBYTE)(pSendBuffer+dwOffset), &dwWritten, dwFlags);
			dwOffset += dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Output the subject
		if (bRet && m_strSubject.GetLength() > 0)
		{
			dwLength = 0;
			bRet = GetEncodedString(m_strSubject, m_szSubjectCharset, spBuf, nBufLen, dwLength);
			if (bRet && dwLength != 0)
			{
				memcpy(pSendBuffer+dwOffset, "Subject: ", sizeof("Subject: ")-1);
				dwOffset+= 9;
				DWORD dwWritten = 0;
				bRet = FormatField((LPBYTE)(char*)spBuf, dwLength, (LPBYTE)(pSendBuffer+dwOffset), &dwWritten, dwFlags);
				dwOffset += dwWritten;
				*(pSendBuffer+dwOffset++) = '\r';
				*(pSendBuffer+dwOffset++) = '\n';
			}
		}

		// Output the "To:" line
		if (bRet && m_strTo.GetLength() > 0)
		{
			memcpy(pSendBuffer+dwOffset, "To: ", sizeof("To: ")-1);
			dwOffset+= 4;
			DWORD dwWritten = 0;
			FormatRecipients((LPBYTE)((LPCSTR)m_strTo), m_strTo.GetLength(), (LPBYTE)(pSendBuffer+dwOffset), &dwWritten);
			dwOffset+= dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Output the "CC:" line
		if (bRet && m_strCc.GetLength() > 0)
		{
			memcpy(pSendBuffer+dwOffset, "CC: ", sizeof("CC: ")-1);
			dwOffset+= 4;
			DWORD dwWritten = 0;
			bRet = FormatRecipients((LPBYTE)((LPCSTR)m_strCc), m_strCc.GetLength(), (LPBYTE)(pSendBuffer+dwOffset), &dwWritten);
			dwOffset+= dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Send the header
		if (bRet && dwOffset)
			bRet = AtlSmtpSendAndWait(hFile, pSendBuffer, dwOffset, pOverlapped);

		return bRet;
	}

protected:

	// Make the mime header
	virtual inline BOOL MakeMimeHeader(CStringA& /*header*/, LPCSTR /*szBoundary*/) throw()
	{
		// The message header does not have its own MIME header
		ATLASSERT(FALSE);
		return TRUE;
	}

	// Get an encoded string for a header field
	inline BOOL GetEncodedString(CStringA& headerString, LPCSTR szCharset, LPSTR szBuf, int nBufLen, DWORD& dwLength) throw()
	{
		BOOL bEncoded = FALSE;
		if (m_spMultiLanguage.p)
		{
			// only encode if there are 8bit characters
			int nExtendedChars = GetExtendedChars(headerString, headerString.GetLength());
			if (nExtendedChars)
			{
				// choose smallest encoding
				if (((nExtendedChars*100)/headerString.GetLength()) < 17)
				{
					int nEncCnt = 0;
					if (!QEncode((LPBYTE)((LPCSTR)headerString), headerString.GetLength(), szBuf, &nBufLen, szCharset, &nEncCnt))
					{
						return FALSE;
					}

					//if no unsafe characters were encountered, just output it
					if (nEncCnt != 0)
					{
						bEncoded = TRUE;
					}
				}
				else
				{
					if (!BEncode((LPBYTE)((LPCSTR)headerString), headerString.GetLength(), szBuf, &nBufLen, szCharset))
					{
						return FALSE;
					}

					bEncoded = TRUE;
				}
			}
		}

		if (!bEncoded)
		{
			// there was no encoding
			dwLength = (DWORD) headerString.GetLength();
			memcpy(szBuf, headerString, dwLength);
		}
		else
		{
			dwLength = nBufLen;
		}
		return TRUE;
	}


	// Helper function for adding recipients
	inline BOOL AddRecipientHelper(CStringA& str, LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		if ((szAddress == NULL) && (szName == NULL))
		{
			return FALSE;
		}

		_ATLTRY
		{
			if (str.GetLength() != 0)
				str.Append(", ", 2);

			if (szName)
			{
				CHeapPtr<char> szName;
				UINT nLen(0);

				BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szName, &szName, &nLen);
				if (bRet)
				{
					CStringA Name;
					Name.SetString("\"", 1);
					Name.Append(szName, (int)nLen);
					Name.Append("\"", 1);

					char szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

					if (!AtlMimeCharsetFromCodePage(szCharset, uiCodePage, m_spMultiLanguage))
						return FALSE;

					char szBuf[256];
					int nBufLen = 256;
					DWORD dwLength = 0;
					if (!GetEncodedString(Name, szCharset, szBuf, nBufLen, dwLength))
						return FALSE;
					str += szBuf;
				}
			}

			if (szAddress)
			{
				if (szName)
					str.Append(" ", 1);
				str.Append("<", 1);
				str += CT2CA(szAddress);
				str.Append(">", 1);
			}
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the formatted header information
	inline BOOL FormatField(LPBYTE pbSrcData, int nSrcLen, LPBYTE pbDest, 
		DWORD* pdwWritten = NULL, DWORD dwFlags = 0) throw()
	{
		int nRead = 0;

		// 9 is the length of the maximum field name : "Subject :"
		// we set that here for simplicity
		int nLineLen = 9;
		int nWritten = 0;

		//subtract 2 from these because it's easier for when we have
		//to break lines with a CRLF (and tab if necessary)
		int nMaxLineLength = ATLSMTP_MAX_LINE_LENGTH-3;
		while (nRead < nSrcLen)
		{
			//if we're at the end of the line, break it
			if (nLineLen == nMaxLineLength)
			{
				*pbDest++ = '\r';
				*pbDest++ = '\n';
				nWritten+= 2;
				nLineLen = -1;

				if ((dwFlags & ATLSMTP_FORMAT_SMTP))
				{
					*pbDest++ = '\t';
					nWritten++;
					nLineLen++;
				}
			}

			//if we hit a CRLF, reset nLineLen
			if (*pbSrcData == '\n' && nRead > 0 && *(pbSrcData-1) == '\r')
			{
				nLineLen = -1;
			}

			*pbDest++ = *pbSrcData++;
			nRead++;
			nWritten++;
			nLineLen++;
		}

		if (pdwWritten)
			*pdwWritten = (DWORD)nWritten;

		return TRUE;
	}


	// Get the formatted recipient information
	inline BOOL FormatRecipients(LPBYTE pbSrcData, int nSrcLen, LPBYTE pbDest, 
		DWORD* pdwWritten = NULL) throw()
	{
		int nRead    = 0;
		int nWritten = 0;

		while (nRead < nSrcLen)
		{
			if (*pbSrcData == ',')
			{
				*pbDest++ = *pbSrcData++;
				nRead++;
				if (nRead+1 <= nSrcLen && *pbSrcData == ' ')
				{
					pbSrcData++;
					nRead++;
				}
				*pbDest++ = '\r';
				*pbDest++ = '\n';
				*pbDest++ = '\t';
				nWritten+= 4;

				continue;
			}

			*pbDest++ = *pbSrcData++;
			nRead++;
			nWritten++;
		}

		if (pdwWritten)
			*pdwWritten = (DWORD)nWritten;

		return TRUE;
	}

	// Get the required buffer size for the header
	inline int GetRequiredBufferSize(int nMaxLineLength) throw()
	{
		const static DWORD DATELINE    = 27;
		const static DWORD FROMLINE    = 10;
		const static DWORD TOLINE      = 6;
		const static DWORD CCLINE      = 6;
		const static DWORD SUBJECTLINE = 11;

		//data lengths (QEncoding potentially takes up more space than BEncoding,
		//so default to it)
		int nRequiredLength = QEncodeGetRequiredLength(m_strSenderName.GetLength(), ATL_MAX_ENC_CHARSET_LENGTH)
			+QEncodeGetRequiredLength(m_strSubject.GetLength(), ATL_MAX_ENC_CHARSET_LENGTH);
		nRequiredLength += m_strFrom.GetLength()+m_strTo.GetLength()+m_strCc.GetLength();

		//Add space for date
		nRequiredLength += DATELINE;

		//Add space for From: line
		nRequiredLength += FROMLINE;
		
		//Add space for To: line
		nRequiredLength += TOLINE;

		//Add space for Cc: line
		nRequiredLength += CCLINE;

		//Add space for Subject: line
		nRequiredLength += SUBJECTLINE;

		//Add space for line breaks and tabs
		nRequiredLength += 3*(nRequiredLength/nMaxLineLength);

		//Trailing CRLF
		nRequiredLength += 2;

		return nRequiredLength;
	}

}; // class CMimeHeader


// CMimeAttachment is an abstract base class for MIME message attachments.
// It serves as a base class for CMimeFileAttachment and CMimeRawAttachment
class CMimeAttachment : public CMimeBodyPart
{
protected:

	// the encoding scheme (ATLSMTP_BASE64_ENCODE, ATLSMTP_UUENCODE, ATLSMTP_QP_ENCODE)
	int      m_nEncodingScheme;

	// the content type of the attachment
	CStringA m_ContentType;

	// the character set
	char     m_szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	// the encode string ("base64", "quoted-printable", "uuencode")
	char     *m_pszEncodeString;
	
	// the display name of the attachment
	TCHAR    m_szDisplayName[_MAX_FNAME];

public:
	CMimeAttachment() throw()
		:m_nEncodingScheme(ATLSMTP_BASE64_ENCODE), m_pszEncodeString(NULL)
	{
	}

	virtual ~CMimeAttachment() throw()
	{
	}

	// CMimeFileAttachment and CMimeRawAttachment have to handle their own dumping
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) = 0;

	// Set the encoding scheme of the attachment
	inline BOOL SetEncodingScheme(int nScheme) throw()
	{
		if (nScheme != ATLSMTP_BASE64_ENCODE && nScheme != ATLSMTP_UUENCODE && nScheme != ATLSMTP_QP_ENCODE)
		{
			return FALSE;
		}

		m_nEncodingScheme = nScheme;
		return TRUE;
	}
	
	// Set the Content-Type of the attachment
	inline BOOL SetContentType(LPCTSTR szContent) throw()
	{
		_ATLTRY
		{
			m_ContentType = CT2CA(szContent);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the content type of the attachment
	virtual inline LPCSTR GetContentType() throw()
	{
		return m_ContentType;
	}

	// Get the character set of the attachment
	virtual inline LPCSTR GetCharset() throw()
	{
		return m_szCharset;
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() = 0;

	const CMimeAttachment& operator=(const CMimeAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			m_nEncodingScheme = that.m_nEncodingScheme;
			m_ContentType = that.m_ContentType;
			strcpy(m_szCharset, that.m_szCharset);
			m_pszEncodeString = that.m_pszEncodeString;
			_tcscpy(m_szDisplayName, that.m_szDisplayName);
		}

		return *this;
	}

protected:

	// Make the MIME header for the attachment
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		// if no display name is specified, default to "rawdata"
		return MakeMimeHeader(header, szBoundary, _T("rawdata"));
	}

	// Make the MIME header with the specified filename
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary, LPCTSTR szFileName) throw()
	{
		ATLASSERT(szBoundary != NULL);
		ATLASSERT(szFileName != NULL);
		ATLASSERT(m_pszEncodeString != NULL);

		char szBegin[256];
		if (*szBoundary)
		{
			// this is not the only body part
			memcpy(szBegin, "\r\n\r\n--", 6);
			memcpy(szBegin+6, szBoundary, ATL_MIME_BOUNDARYLEN);
			*(szBegin+(ATL_MIME_BOUNDARYLEN+6)) = '\0';
		}
		else
		{
			// this is the only body part, so output the MIME header
			memcpy(szBegin, "MIME-Version: 1.0", sizeof("MIME-Version: 1.0"));
		}

		// Get file name with the path stripped out
		TCHAR szFile[MAX_PATH+1];
		TCHAR szExt[_MAX_EXT+1];
		_tsplitpath(szFileName, NULL, NULL, szFile, szExt);
		_tcscat(szFile, szExt);

		_ATLTRY
		{
			CT2CAEX<MAX_PATH+1> szFileNameA(szFile);

			header.Format("%s\r\nContent-Type: %s;\r\n\tcharset=\"%s\"\r\n\tname=\"%s\"\r\n"
		                 "Content-Transfer-Encoding: %s\r\nContent-Disposition: attachment;\r\n\tfilename=\"%s\"\r\n\r\n",
				szBegin, (LPCSTR) m_ContentType, m_szCharset, (LPCSTR) szFileNameA, m_pszEncodeString, (LPCSTR) szFileNameA);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get encoding information
	inline BOOL GetEncodingInformation(int* pnRequiredLength, int* pnLineLength) throw()
	{
		ATLASSERT(pnRequiredLength != NULL);
		ATLASSERT(pnLineLength != NULL);

		switch(m_nEncodingScheme)
		{
			case ATLSMTP_BASE64_ENCODE:
				m_pszEncodeString = "base64";
				*pnLineLength = ATLSMTP_MAX_BASE64_LINE_LENGTH;
				*pnRequiredLength = Base64EncodeGetRequiredLength(ATLSMTP_MAX_BASE64_LINE_LENGTH);
				break;
			case ATLSMTP_UUENCODE:
				m_pszEncodeString ="uuencode";
				*pnLineLength = ATLSMTP_MAX_UUENCODE_LINE_LENGTH;
				*pnRequiredLength = UUEncodeGetRequiredLength(ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
				break;
			case ATLSMTP_QP_ENCODE:
				m_pszEncodeString = "quoted-printable";
				*pnLineLength = ATLSMTP_MAX_QP_LINE_LENGTH;
				*pnRequiredLength = QPEncodeGetRequiredLength(ATLSMTP_MAX_QP_LINE_LENGTH);
				break;
			default:
				return FALSE;
		}
		return TRUE;
	}

}; // class CMimeAttachment


// CMimeFileAttachment represents a MIME file attachment body part
class CMimeFileAttachment : public CMimeAttachment
{
	
protected:
	// The filename
	TCHAR m_szFileName[MAX_PATH+1];

public:
	CMimeFileAttachment() throw()
	{
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeFileAttachment> pNewAttachment;
		ATLTRY(pNewAttachment.Attach(new CMimeFileAttachment));
		if (pNewAttachment)
			*pNewAttachment = *this;

		return pNewAttachment.Detach();
	}

	const CMimeFileAttachment& operator=(const CMimeFileAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeAttachment::operator=(that);
			_tcscpy(m_szFileName, that.m_szFileName);
		}

		return *this;
	}
		

	// Initialize the file attachment
	// szFileName - the actual file name
	// szDisplayName - the display name for the file (optional)
	// pMultiLanguage - the IMulitLanguage pointer for codepage to charset conversion (optional)
	// uiCodePage - the code page (optional)
	inline BOOL Initialize(LPCTSTR szFileName, LPCTSTR szDisplayName = NULL, IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		if (!AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage))
			return FALSE;

		_tcscpy(m_szFileName, szFileName);

		if (szDisplayName)
		{
			// use the user-specified display name
			_tcscpy(m_szDisplayName, szDisplayName);
		}
		else
		{
			// otherwise there is no display name
			*m_szDisplayName = '\0';
		}
		return TRUE;
	}
 
	// Dump the data for the file attachment
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		int nLineLength = 0;
		int nRequiredLength = 0;

		if (!GetEncodingInformation(&nRequiredLength, &nLineLength))
			return FALSE;

		//Try to open the file that is being attached
		CAtlFile readFile;
		if (FAILED(readFile.Create(m_szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING)))
			return FALSE;

		//Make the mime header
		CStringA header;
		if (!MakeMimeHeader(header, szBoundary, m_szFileName))
		{
			return FALSE;
		}

		//Try to send the mime header
		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)header), header.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		int nGetLines = ATLSMTP_GET_LINES;

		nRequiredLength *= nGetLines;

		//dwToGet is the total number of characters to attempt to get
		DWORD dwToGet = (DWORD)nGetLines*nLineLength;

		//allocate the data array
		CHeapPtr<BYTE> spData;
		if (!spData.Allocate(dwToGet+1))
			return FALSE;

// if double buffering is defined, create two buffers
#ifdef ATLSMTP_DOUBLE_BUFFERED
		CHeapPtr<char> buffer1;
		if (!buffer1.Allocate(nRequiredLength+3))
			return FALSE;
		
		CHeapPtr<char> buffer2;
		if (!buffer2.Allocate(nRequiredLength+3))
			return FALSE;

		char* currBuffer = buffer1;
		char* prevBuffer = NULL;
		int nCurrBuffer = 0;
		DWORD dwPrevLength = 0;
#else
		CHeapPtr<char> currBuffer;
		if (!currBuffer.Allocate(nRequiredLength+3))
			return FALSE;

#endif // ATLSMTP_DOUBLE_BUFFERED

		int nEncodedLength = nRequiredLength;
		BOOL bRet = FALSE;
		DWORD dwRead = 0;
		DWORD dwTotalRead = 0;
		DWORD dwCurrRead = 0;

		do
		{
			do 
			{
				//Read a chunk of data from the file increment buffer offsets and amount to read
				//based on what's already been read in this iteration of the loop
				HRESULT hr = readFile.Read(((LPBYTE)spData)+dwCurrRead, dwToGet-dwCurrRead, dwRead);
				if (FAILED(hr))
				{
					if (hr != AtlHresultFromWin32(ERROR_MORE_DATA))
					{
						return FALSE;
					}
				}
				dwCurrRead += dwRead;

			} while (dwRead != 0 && dwCurrRead < dwToGet);

			//reset nEncodedLength
			nEncodedLength = nRequiredLength;
			switch (m_nEncodingScheme)
			{
				case ATLSMTP_BASE64_ENCODE:
					//if we are at the end of input (dwCurrRead < dwToGet), output the trailing padding if necessary
					//(ATL_FLAG_NONE)
					bRet = Base64Encode(spData, dwCurrRead, currBuffer, &nEncodedLength, 
						(dwCurrRead < dwToGet ? ATL_BASE64_FLAG_NONE: ATL_BASE64_FLAG_NOPAD));
					//Base64Encoding needs explicit CRLF added
					currBuffer[nEncodedLength++] = '\r';
					currBuffer[nEncodedLength++] = '\n';
					break;
				case ATLSMTP_UUENCODE:
					//if we are at the beginning of the input, output the header (ATL_UUENCODE_HEADER)
					//if we are the end of input (dwCurrRead < dwToGet), output the 'end'
					//we are encoding for purposes of sending mail, so stuff dots (ATL_UUENCODE_DOT)
					bRet = UUEncode(spData, dwCurrRead, currBuffer, &nEncodedLength, m_szFileName,
						            (dwTotalRead > 0 ? 0 : ATLSMTP_UUENCODE_HEADER) | 
						            (dwCurrRead < dwToGet ? ATLSMTP_UUENCODE_END : 0) | 
						            ((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_UUENCODE_DOT : 0));
					break;
				case ATLSMTP_QP_ENCODE:
					//we are encoding for purposes of sending mail, so stuff dots
					bRet = QPEncode(spData, dwCurrRead, currBuffer, &nEncodedLength, 
						            ((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_QPENCODE_DOT : 0) |
						            (dwCurrRead < dwToGet ? 0 : ATLSMTP_QPENCODE_TRAILING_SOFT));
					break;
			}
			//try to send the encoded data
#ifdef ATLSMTP_DOUBLE_BUFFERED
			if (bRet)
			{
				bRet = AtlSmtpSendOverlapped(hFile, currBuffer, nEncodedLength, 
					prevBuffer, dwPrevLength, pOverlapped);
			}

			//swap the buffers
			dwPrevLength = nEncodedLength;
			prevBuffer = currBuffer;
			currBuffer = (nCurrBuffer == 0 ? buffer2 : buffer1);
			nCurrBuffer = (nCurrBuffer == 0 ? 1 : 0);
#else
			if (bRet)
			{
				bRet = AtlSmtpSendAndWait(hFile, currBuffer, nEncodedLength, pOverlapped);
			}
#endif // ATLSMTP_DOUBLE_BUFFERED

			dwTotalRead += dwCurrRead;
			if (dwRead != 0)
				dwCurrRead = 0;

			nEncodedLength = nRequiredLength;

		} while (dwRead != 0 && bRet);

		//ensure that the last Send sent all the data
#ifdef ATLSMTP_DOUBLE_BUFFERED
		DWORD dwWritten = 0, dwErr = 0;
		if (!GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE))
		{
			if ((dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
			{
				bRet = FALSE;
			}
			else if (dwWritten < dwPrevLength)
			{
				bRet = AtlSmtpSendAndWait(hFile, prevBuffer+dwWritten, 
					dwPrevLength-dwWritten, pOverlapped);
			}
		}
#endif // ATLSMTP_DOUBLE_BUFFERED

		//for uuencoding, if the last chunk read was of size dwToGet, but it was also the end of the file,
		//the "end" keyword will not get encoded, so a check is necessary
		if (m_nEncodingScheme == ATLSMTP_UUENCODE && dwCurrRead == dwToGet)
		{
			bRet = UUEncode(spData, 0, currBuffer, &nEncodedLength, m_szFileName, 
				            (dwFlags & ATLSMTP_FORMAT_SMTP ? ATLSMTP_UUENCODE_DOT : 0) |
				            ATLSMTP_UUENCODE_END);
			if (bRet)
			{
				bRet = AtlSmtpSendAndWait(hFile, currBuffer, nEncodedLength, pOverlapped);
			}
		}

		return bRet;
	}
}; // class CMimeFileAttachment

// CMimeRawAttachment represents a file attachment MIME body part.
// The data provided is not a file, but a blob of raw data.
class CMimeRawAttachment : public CMimeAttachment
{
protected:

	//the raw data
	void* m_pvRaw;
	
	//the length
	DWORD m_dwLength;

	//whether or not we own it
	bool  m_bShared;

public:
	CMimeRawAttachment() throw()
		:m_dwLength(0), m_bShared(false)
	{
	}

	~CMimeRawAttachment() throw()
	{
		//If we own the raw data, free it
		if (!m_bShared && m_pvRaw)
			free(m_pvRaw);
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeRawAttachment> pNewAttachment;
		ATLTRY(pNewAttachment.Attach(new CMimeRawAttachment));
		if (pNewAttachment)
			*pNewAttachment = *this;

		return pNewAttachment.Detach();
	}

	const CMimeRawAttachment& operator=(const CMimeRawAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeAttachment::operator=(that);
			if (!m_bShared && m_pvRaw)
				free(m_pvRaw);

			m_bShared = that.m_bShared;
			m_dwLength = that.m_dwLength;

			if (m_bShared)
			{
				m_pvRaw = that.m_pvRaw;
			}
			else
			{
				m_pvRaw = malloc(m_dwLength);
				if (m_pvRaw)
				{
					memcpy(m_pvRaw, that.m_pvRaw, m_dwLength);
				}
			}
		}

		return *this;
	}

	// Initialize the attachment
	// pData - the data
	// nDataLength - the size of pData in BYTEs
	// bCopyData - flag specifying whether CMimeRawAttachment should make a copy of the data (optional)
	// pMultiLanguage - the IMultiLanguage pointer for codepage to character set conversion (optional)
	// uiCodePage - the codepage (optional)
	inline BOOL Initialize(void* pData, DWORD nDataLength, BOOL bCopyData = TRUE, LPCTSTR szDisplayName = NULL, 
		IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		// if we're already attached to some data, and it's not shared, free it
		if (m_pvRaw && !m_bShared)
			free(m_pvRaw);
		m_pvRaw = NULL;

		m_dwLength = nDataLength;
		if (bCopyData)
		{
			m_pvRaw = malloc(sizeof(BYTE)*m_dwLength);
			if (!m_pvRaw)
			{
				return FALSE;
			}
			memcpy(m_pvRaw, pData, m_dwLength);
			m_bShared = false;
		}
		else
		{
			m_pvRaw = pData;
			m_bShared = true;
		}

		if (!AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage))
			return FALSE;
		
		if (szDisplayName)
		{
			// use the user-specified display name
			_tcscpy(m_szDisplayName, szDisplayName);
		}
		else
		{
			// no display name
			*m_szDisplayName = '\0';
		}
		return TRUE;
	}

	// Output the data--similar to CFileAttachment::WriteData
	// See CFileAttachment::WriteData for comments
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		if (!m_pvRaw)
			return FALSE;

		int nLineLength = 0, nRequiredLength = 0;
		if (!GetEncodingInformation(&nRequiredLength, &nLineLength))
			return FALSE;

		CStringA header;
		
		if (!MakeMimeHeader(header, szBoundary))
		{
			return FALSE;
		}

		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)header), header.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		int nGetLines = ATLSMTP_GET_LINES;
		DWORD dwCurrChunk = 0;
		nRequiredLength *= nGetLines;
		DWORD dwToGet = (DWORD)nGetLines*nLineLength;
		int nDestLen = nRequiredLength;
		BOOL bRet = FALSE;
		DWORD dwRead = 0;
#ifdef ATLSMTP_DOUBLE_BUFFERED
		CHeapPtr<char> buffer1;
		if (!buffer1.Allocate(nRequiredLength+3))
			return FALSE;

		CHeapPtr<char> buffer2;
		if (!buffer2.Allocate(nRequiredLength+3))
			return FALSE;

		char* currBuffer = buffer1;
		char* prevBuffer = NULL;
		int nCurrBuffer = 0;
		DWORD dwPrevLength = 0;
#else
		CHeapPtr<char> currBuffer;
		if (!currBuffer.Allocate(nRequiredLength+3))
			return FALSE;
#endif // ATLSMTP_DOUBLE_BUFFERED

		do 
		{
			if ((m_dwLength-dwRead) <= dwToGet)
				dwCurrChunk = m_dwLength-dwRead;
			else
				dwCurrChunk = dwToGet;
			switch(m_nEncodingScheme)
			{
				case ATLSMTP_BASE64_ENCODE:
					bRet = Base64Encode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, 
						(dwRead < m_dwLength) ? ATL_BASE64_FLAG_NONE : ATL_BASE64_FLAG_NOPAD);
					currBuffer[nDestLen++] = '\r';
					currBuffer[nDestLen++] = '\n';
					break;
				case ATLSMTP_UUENCODE:
					bRet = UUEncode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, _T("rawdata"), 
						            (dwRead > 0 ? 0 : ATLSMTP_UUENCODE_HEADER) | 
						            (dwRead+dwCurrChunk == m_dwLength ? ATLSMTP_UUENCODE_END : 0) | 
						            ((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_UUENCODE_DOT : 0));
					break;
				case ATLSMTP_QP_ENCODE:
					bRet = QPEncode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, 
						            ((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_QPENCODE_DOT : 0) | 
						            (dwRead+dwCurrChunk == m_dwLength ? 0 : ATLSMTP_QPENCODE_TRAILING_SOFT));
					break;
			}
			if (!bRet)
				break;
#ifdef ATLSMTP_DOUBLE_BUFFERED
			bRet = AtlSmtpSendOverlapped(hFile, currBuffer, nDestLen, prevBuffer, dwPrevLength, pOverlapped);
			dwPrevLength = (DWORD)nDestLen;
			prevBuffer = currBuffer;
			currBuffer = (nCurrBuffer == 0 ? buffer2 : buffer1);
			nCurrBuffer = (nCurrBuffer == 0 ? 1 : 0);
#else
			bRet = AtlSmtpSendAndWait(hFile, currBuffer, nDestLen, pOverlapped);
#endif // ATLSMTP_DOUBLE_BUFFERED

			nDestLen = nRequiredLength;
			dwRead += dwCurrChunk;
		} while (bRet && (dwRead < m_dwLength));

		//ensure all data is sent from prevBuffer
#ifdef ATLSMTP_DOUBLE_BUFFERED
		DWORD dwWritten = 0, dwErr = 0;
		if (!GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE))
		{
			if ((dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
				bRet = FALSE;
			else if (dwWritten < dwPrevLength)
				bRet = AtlSmtpSendAndWait(hFile, prevBuffer+dwWritten, dwPrevLength-dwWritten, pOverlapped);
		}
#endif // ATLSMTP_DOUBLE_BUFFERED

		//for uuencoding, if the last chunk read was of size dwToGet, but it was also the end of the file,
		//the "end" keyword will not get encoded, so a check is necessary
		if (m_nEncodingScheme == ATLSMTP_UUENCODE && dwCurrChunk == dwToGet)
		{
			bRet = UUEncode((LPBYTE)m_pvRaw, 0, currBuffer, &nDestLen, _T("rawdata"), (dwFlags & ATLSMTP_FORMAT_SMTP ? ATLSMTP_UUENCODE_DOT : 0) |
				ATLSMTP_UUENCODE_END);
			if (bRet)
				bRet = AtlSmtpSendAndWait(hFile, currBuffer, nDestLen, pOverlapped);
		}
		return bRet;
	}
}; // class CMimeRawAttachment


// CMimeText - represents a text body part in MIME body
class CMimeText : public CMimeBodyPart
{
protected:

	// the text
	CHeapPtr<char> m_szText;

	// the character set
	char     m_szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	// the text length
	int      m_nTextLen;

public:
	CMimeText() throw()
		:m_nTextLen(0)
	{
		strcpy(m_szCharset, ATLSMTP_DEFAULT_CSET);
	}

	virtual ~CMimeText() throw()
	{
	}

	// Get the content type
	virtual inline LPCSTR GetContentType() throw()
	{
		return "text/plain";
	}

	// Get the character set
	virtual inline LPCSTR GetCharset() throw()
	{
		return m_szCharset;
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeText> pNewText;
		ATLTRY(pNewText.Attach(new CMimeText));
		if (pNewText)
			*pNewText = *this;

		return pNewText.Detach();
	}

	const CMimeText& operator=(const CMimeText& that) throw( ... )
	{
		if (this != &that)
		{
			m_nTextLen = that.m_nTextLen;
			strcpy(m_szCharset, that.m_szCharset);
			m_szText.Free();
			if (m_szText.AllocateBytes(m_nTextLen) != false)
			{
				memcpy((char *)m_szText, (char *)that.m_szText, m_nTextLen);
			}
		}

		return *this;
	}

	// Initialize the body part
	// szText - the text (required)
	// nTextLen - the text length in bytes (optional--if not specified a _tcslen will be done)
	// pMultiLanguage - the IMultiLanguagte pointer for converting codepages to MIME character sets (optional)
	// uiCodePage - the codepage
	inline BOOL Initialize(LPCTSTR szText, int nTextLen = -1, IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		BOOL bRet = TRUE;

		// if IMultiLanguage is there, respect the codepage
		if (pMultiLanguage)
		{
			CHeapPtr<char> szTextPtr;
			UINT nLen(0);

			bRet = AtlMimeConvertString(pMultiLanguage, uiCodePage, szText, &szTextPtr, &nLen);
			if (bRet)
			{
				m_szText.Free();
				m_szText.Attach(szTextPtr.Detach());
				m_nTextLen = nLen;
			}
		}
		else // no multilanguage support
		{
			if (nTextLen < 0)
			{
				nTextLen = (int) _tcslen(szText);
				nTextLen*= sizeof(TCHAR);
			}
			
			m_szText.Free();
			if (m_szText.AllocateBytes(nTextLen) != false)
			{
				memcpy((char *)m_szText, szText, nTextLen);
				m_nTextLen = nTextLen;
			}
		}

		if (bRet)
		{
			bRet = AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage);
		}

		return bRet;
	}

	// Dump the data to hFile
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		CStringA strHeader;
		char sendBuffer[ATLSMTP_READBUFFER_SIZE];
		LPSTR pSendBuffer = sendBuffer;
		LPSTR szText = m_szText;

		if (!MakeMimeHeader(strHeader, szBoundary))
		{
			return FALSE;
		}

		//copy the header into the sendbuffer
		int nWritten = strHeader.GetLength();
		memcpy(pSendBuffer, (LPCSTR)strHeader, nWritten);
		pSendBuffer+= nWritten;
		int nRead = 0;
		int nLineLen = 0;

		//subtract 2 from these because it's easier for when we have
		//to break lines with a CRLF
		int nMaxLineLength = ATLSMTP_MAX_LINE_LENGTH-2;
		int nMaxBufferSize = ATLSMTP_READBUFFER_SIZE-2;
		while (nRead <= m_nTextLen)
		{
			//if the buffer is full or we've reached the end of the text, 
			//send it
			if (nWritten >= nMaxBufferSize || nRead == m_nTextLen)
			{
				if (!AtlSmtpSendAndWait(hFile, sendBuffer, nWritten, pOverlapped))
					return FALSE;
				nWritten = 0;
				pSendBuffer = sendBuffer;
			}

			//if we're at the end of the line, break it
			if (nLineLen == nMaxLineLength)
			{
				*pSendBuffer++ = '\r';
				*pSendBuffer++ = '\n';
				nWritten+= 2;
				nLineLen = -1;
				continue;
			}

			//stuff dots at the start of the line
			if (nLineLen == 0 && (dwFlags & ATLSMTP_FORMAT_SMTP) && *szText == '.')
			{
				*pSendBuffer++ = '.';
				nWritten++;
				nLineLen++;
				continue;
			}

			//if we hit a CRLF, reset nLineLen
			if (*szText == '\n' && nRead > 0 && *(szText-1) == '\r')
				nLineLen = -1;

			*pSendBuffer++ = (*szText++);
			nRead++;
			nWritten++;
			nLineLen++;
		}

		return TRUE;
	}

protected:

	// Make the MIME header
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		char szBegin[256];
		if (*szBoundary)
		{
			// this is not the only body part
			memcpy(szBegin, "\r\n\r\n--", 6);
			memcpy(szBegin+6, szBoundary, ATL_MIME_BOUNDARYLEN);
			*(szBegin+(ATL_MIME_BOUNDARYLEN+6)) = '\0';
		}
		else
		{
			// this is the only body part, so output the full MIME header
			memcpy(szBegin, "MIME-Version: 1.0", sizeof("MIME-Version: 1.0"));
		}

		_ATLTRY
		{
			header.Format("%s\r\nContent-Type: text/plain;\r\n\tcharset=\"%s\"\r\nContent-Transfer-Encoding: 8bit\r\n\r\n", 
				szBegin, m_szCharset);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}
}; // class CMimeText


// CMimeMessage - the MIME message class.  Represents a full MIME message
class CMimeMessage : public CMimeHeader
{
protected:

	// The list of the MIME body parts
//	CAtlList<CMimeBodyPart*> m_BodyParts;
	CAutoPtrList<CMimeBodyPart> m_BodyParts;

	// The display name of the message
	char m_szDisplayName[MAX_PATH+1];

public:
	CMimeMessage(IMultiLanguage *pMultiLanguage = NULL) throw()
	{
		Initialize(pMultiLanguage);
		memcpy(m_szDisplayName, "email", sizeof("email"));
	}

	virtual ~CMimeMessage() throw()
	{
		RemoveParts();
	}

	void RemoveParts() throw()
	{
//		POSITION currPos = m_BodyParts.GetHeadPosition();

		// free the body parts
//		while (currPos != NULL)
//		{
//			delete m_BodyParts.GetNext(currPos);
//		}

		m_BodyParts.RemoveAll();
	}


	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeMessage> pNewMessage;
		ATLTRY(pNewMessage.Attach(new CMimeMessage));
		if (pNewMessage)
			*pNewMessage = *this;

		return pNewMessage.Detach();
	}


	const CMimeMessage& operator=(const CMimeMessage& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeHeader::operator=(that);
			strcpy(m_szDisplayName, that.m_szDisplayName);

			RemoveParts();
			POSITION pos = that.m_BodyParts.GetHeadPosition();
			while (pos != NULL)
			{
				CAutoPtr<CMimeBodyPart> pCopy(that.m_BodyParts.GetNext(pos)->Copy());
				if (pCopy)
				{
					m_BodyParts.AddTail(pCopy);
				}
			}
		}

		return *this;
	}

	// Set the display name of the message
	inline BOOL SetDisplayName(LPCTSTR szDisplayName) throw()
	{
		if ((szDisplayName == NULL) || (_tcslen(szDisplayName) > MAX_PATH))
		{
			return FALSE;
		}

		_ATLTRY
		{
			strcpy(m_szDisplayName, CT2CA(szDisplayName));
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Add some text to the message at position nPos in the body parts list
	// szText - the text
	// nTextLen - the size of the text in bytes (optional - if not specified a _tcslen will be done)
	// nPos - the position in the message at which to insert the text (optional)
	// uiCodePage - the codepage (optional)
	inline BOOL AddText(LPCTSTR szText, int nTextLen = -1, int nPos = 1, UINT uiCodePage = 0) throw()
	{
		if (szText == NULL)
			return FALSE;

		if (nPos < 1)
		{
			nPos = 1;
		}

		CAutoPtr<CMimeBodyPart> spNewText;
		CMimeText *pNewText = NULL;
		ATLTRY(spNewText.Attach(pNewText = new CMimeText()));
		if (!spNewText)
			return FALSE;

		BOOL bRet = pNewText->Initialize(szText, nTextLen, m_spMultiLanguage, uiCodePage);
		if (bRet)
		{
			_ATLTRY
			{
				POSITION currPos = m_BodyParts.FindIndex(nPos-1);
				
					if (!currPos)
					{
						if (!m_BodyParts.AddTail(spNewText))
							bRet = FALSE;
					}
					else
					{
						if (!m_BodyParts.InsertBefore(currPos, spNewText))
							bRet = FALSE;
					}
				
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}

		return bRet;
	}

	// Dump the data
	virtual BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary=NULL, DWORD dwFlags = 0) throw()
	{	
		if (pOverlapped == NULL)
		{
			return FALSE;
		}

		// Make the MIME boundary for this message
		char szBoundaryBuf[ATL_MIME_BOUNDARYLEN+1];
		MakeBoundary(szBoundaryBuf);

		// if the passed boundary is valid, this is an attached message
		if (szBoundary && *szBoundary != '\0')
		{
			_ATLTRY
			{
				// output the MIME header for a message attachment
				CStringA strHeader;
				strHeader.Format("\r\n\r\n--%s\r\nContent-Type: message/rfc822\r\n\tname=\"%s\"\r\nContent-Transfer-Encoding: 8bit\r\n"
				    "Content-Disposition: attachment;\r\n\tfilename=\"%s\"\r\n\r\n", 
					szBoundary, m_szDisplayName, m_szDisplayName);

				if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)strHeader), strHeader.GetLength(), pOverlapped))
				{
					return FALSE;
				}
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
		}

		if (!CMimeHeader::WriteData(hFile, pOverlapped, szBoundaryBuf, dwFlags))
			return FALSE;

		// Create and output the header
		CStringA strHeader;
		
		if (!MakeMimeHeader(strHeader, szBoundaryBuf))
		{
			return FALSE;
		}

		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)strHeader), strHeader.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		CMimeBodyPart* pCurrPart;
		POSITION currPos = m_BodyParts.GetHeadPosition();

		//Dump the body parts
		while (currPos != NULL)
		{
			pCurrPart = m_BodyParts.GetAt(currPos);
			if (!pCurrPart->WriteData(hFile, pOverlapped, szBoundaryBuf, dwFlags))
			{
				return FALSE;
			}
			m_BodyParts.GetNext(currPos);
		}

		char szBuf[ATL_MIME_BOUNDARYLEN+(sizeof("\r\n\r\n--%s--\r\n"))];
		//output a trailing boundary
		if (*szBoundaryBuf)
		{
			int nBufLen = sprintf(szBuf, "\r\n\r\n--%s--\r\n", szBoundaryBuf);
			if (!AtlSmtpSendAndWait(hFile, szBuf, nBufLen, pOverlapped))
			{
				return FALSE;
			}
		}

		return TRUE;
	}

	// Attach a file.
	// szFileName - the filename
	// szDisplayName - the display name (optional)
	// szContentType - the content type (optional - defaults to NULL -- lookup will be attempted, otherwise default to application/octet-stream)
	// nEncodingScheme - the encoding scheme to use for the attachment (optional - defaults to base64
	// uiCodePage - the codepage (optional)
	inline BOOL AttachFile(LPCTSTR szFileName, LPCTSTR szDisplayName = NULL, LPCTSTR szContentType = NULL, 
		int nEncodingScheme = ATLSMTP_BASE64_ENCODE, UINT uiCodepage = 0)
	{
		if (szFileName == NULL)
			return FALSE;

		CAutoPtr<CMimeBodyPart> spFileAttach;
		CMimeFileAttachment* pFileAttach = NULL;
		ATLTRY(spFileAttach.Attach(pFileAttach = new CMimeFileAttachment()));
		if (!spFileAttach)
			return FALSE;

		BOOL bRet = pFileAttach->Initialize(szFileName, szDisplayName, m_spMultiLanguage, uiCodepage);

		if (bRet)
			bRet = pFileAttach->SetEncodingScheme(nEncodingScheme);

		CString strContentType;
		if (bRet && (szContentType == NULL))
		{
			if (GetContentTypeFromFileName(szFileName, strContentType) != ERROR_OUTOFMEMORY)
			{
				szContentType = strContentType;
			}
			else
			{
				bRet = FALSE;
			}
		}

		_ATLTRY
		{
			if (bRet)
			{
				bRet = pFileAttach->SetContentType(szContentType);
				if (bRet)
				{
					if (!m_BodyParts.AddTail(spFileAttach))
					{
						bRet = FALSE;
					}
				}
			}
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	// Attach some raw data
	// pRawData - the data
	// nDataLength - the size of the data in bytes
	// nEncodingScheme - the encoding scheme to use for the attachment (optional - defaults to base64
	// uiCodePage - the codepage (optional)
	inline BOOL AttachRaw(void* pRawData, DWORD dwDataLength, int nEncodingScheme = ATLSMTP_BASE64_ENCODE, BOOL bCopyData = TRUE, 
		LPCTSTR szDisplayName = NULL, LPCTSTR szContentType = _T("application/octet-stream"), UINT uiCodepage = 0)
	{
		if (!pRawData)
			return FALSE;

		CAutoPtr<CMimeBodyPart> spRawAttach;
		CMimeRawAttachment* pRawAttach;
		ATLTRY(spRawAttach.Attach(pRawAttach = new CMimeRawAttachment()));
		if (!spRawAttach)
		{
			return FALSE;
		}

		BOOL bRet = pRawAttach->Initialize(pRawData, dwDataLength, bCopyData, szDisplayName, m_spMultiLanguage, uiCodepage);

		if (bRet)
			bRet = pRawAttach->SetEncodingScheme(nEncodingScheme);
		if (bRet)
			bRet = pRawAttach->SetContentType(szContentType);

		_ATLTRY
		{
		if (bRet)
			if(!m_BodyParts.AddTail(spRawAttach))
				bRet = FALSE;
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	// Attach a CMimeMessage
	// pMsg - pointer to the Msg object
	inline BOOL AttachMessage(CMimeMessage* pMsg) throw( ... )
	{
		if (!pMsg)
			return FALSE;

		_ATLTRY
		{
			CAutoPtr<CMimeBodyPart> spMsg(pMsg->Copy());
			if (!m_BodyParts.AddTail(spMsg))
				return FALSE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		return TRUE;
	}

protected:
	// Make the MIME header
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		_ATLTRY
		{
			if (!*szBoundary)
			{
				header.Format("X-Priority: %d\r\n%s", m_nPriority, (LPCSTR) m_XHeader);
			}
			else if (m_BodyParts.GetCount() > 1)
			{
				header.Format("X-Priority: %d\r\n%sMIME-Version: 1.0\r\nContent-Type: multipart/mixed;\r\n\tboundary=\"%s\"\r\n", 
					m_nPriority, (LPCSTR) m_XHeader, szBoundary);
			}
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Make the MIME boundary
	inline BOOL MakeBoundary(LPSTR szBoundary) throw()
	{
		ATLASSERT(szBoundary != NULL);
		if (m_BodyParts.GetCount() < 2)
		{
			*szBoundary = '\0';
		}
		else 
		{
			sprintf(szBoundary, "------=_Next_Part_%.10u.%.3u", GetTickCount(), rand()%1000);
		}
		return TRUE;
	}

}; // class CMimeMessage

} // namespace ATL

#ifndef _CPPUNWIND
#pragma warning (pop)
#endif //_CPPUNWIND

#endif // __ATLMIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMEM_H__
#define __ATLMEM_H__

#pragma once

#include <atlbase.h>

#include <limits.h>

namespace ATL
{

template< typename N >
inline N AtlAlignUp( N n, ULONG nAlign ) throw()
{
	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );
}

template< typename N >
inline N AtlAlignDown( N n, ULONG nAlign ) throw()
{
	return( N( n&~(N( nAlign )-1) ) );
}

__interface __declspec(uuid("654F7EF5-CFDF-4df9-A450-6C6A13C622C0")) IAtlMemMgr
{
public:
	void* Allocate( size_t nBytes ) throw();
	void Free( void* p ) throw();
	void* Reallocate( void* p, size_t nBytes ) throw();
	size_t GetSize( void* p ) throw();
};

#ifndef _ATL_MIN_CRT
class CCRTHeap :
	public IAtlMemMgr
{
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( malloc( nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		free( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		return( realloc( p, nBytes ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( _msize( p ) );
	}

public:
};

#endif  //!_ATL_MIN_CRT

class CWin32Heap :
	public IAtlMemMgr
{
public:
	CWin32Heap() throw() :
		m_hHeap( NULL ),
		m_bOwnHeap( false )
	{
	}
	CWin32Heap( HANDLE hHeap ) throw() :
		m_hHeap( hHeap ),
		m_bOwnHeap( false )
	{
		ATLASSERT( hHeap != NULL );
	}
	CWin32Heap( DWORD dwFlags, size_t nInitialSize, size_t nMaxSize = 0 ) :
		m_hHeap( NULL ),
		m_bOwnHeap( true )
	{
		ATLASSERT( !(dwFlags&HEAP_GENERATE_EXCEPTIONS) );
		m_hHeap = ::HeapCreate( dwFlags, nInitialSize, nMaxSize );
		if( m_hHeap == NULL )
		{
			AtlThrowLastWin32();
		}
	}
	~CWin32Heap() throw()
	{
		if( m_bOwnHeap && (m_hHeap != NULL) )
		{
			BOOL bSuccess;

			bSuccess = ::HeapDestroy( m_hHeap );
			ATLASSERT( bSuccess );
		}
	}

	void Attach( HANDLE hHeap, bool bTakeOwnership ) throw()
	{
		ATLASSERT( hHeap != NULL );
		ATLASSERT( m_hHeap == NULL );
		
		m_hHeap = hHeap;
		m_bOwnHeap = bTakeOwnership;
	}
	HANDLE Detach() throw()
	{
		HANDLE hHeap;

		hHeap = m_hHeap;
		m_hHeap = NULL;
		m_bOwnHeap = false;

		return( hHeap );
	}

// IAtlMemMgr
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		if( p != NULL )
		{
			BOOL bSuccess;

			bSuccess = ::HeapFree( m_hHeap, 0, p );
			ATLASSERT( bSuccess );
		}
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		if( p == NULL )
		{
			return( Allocate( nBytes ) );
		}
		else
		{
			return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );
		}
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::HeapSize( m_hHeap, 0, p ) );
	}

public:
	HANDLE m_hHeap;
	bool m_bOwnHeap;
};

class CComHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return( ::CoTaskMemAlloc( ULONG( nBytes ) ) );
	}
	virtual void Free( void* p ) throw()
	{
		::CoTaskMemFree( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return( ::CoTaskMemRealloc( p, ULONG( nBytes ) ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		CComPtr< IMalloc > pMalloc;

		::CoGetMalloc( 1, &pMalloc );

		return( pMalloc->GetSize( p ) );
	}
};

class CLocalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::LocalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		::LocalFree( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		return( ::LocalReAlloc( p, nBytes, 0 ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::LocalSize( p ) );
	}
};

class CGlobalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::GlobalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		::GlobalFree( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		return( ::GlobalReAlloc( p, nBytes, 0 ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::GlobalSize( p ) );
	}
};

/////////////////////////////////////////////////////////////////////////////
// OLE task memory allocation support

inline LPWSTR AtlAllocTaskWideString(LPCWSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nSize = (UINT)((wcslen(lpszString)+1) * sizeof(WCHAR));
	LPWSTR lpszResult = (LPWSTR)CoTaskMemAlloc(nSize);
	if (lpszResult != NULL)
		memcpy(lpszResult, lpszString, nSize);
	return lpszResult;
}

inline LPWSTR AtlAllocTaskWideString(LPCSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nLen = lstrlenA(lpszString)+1;
	LPWSTR lpszResult = (LPWSTR)CoTaskMemAlloc(nLen*sizeof(WCHAR));
	if (lpszResult != NULL)
		ATLVERIFY(MultiByteToWideChar(CP_ACP, 0, lpszString, -1, lpszResult, nLen));
	return lpszResult;
}

inline LPSTR AtlAllocTaskAnsiString(LPCWSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nBytes = (UINT)((wcslen(lpszString)+1)*2);
	LPSTR lpszResult = (LPSTR)CoTaskMemAlloc(nBytes);
	if (lpszResult != NULL)
		ATLVERIFY(WideCharToMultiByte(CP_ACP, 0, lpszString, -1, lpszResult, nBytes, NULL, NULL));
	return lpszResult;
}

inline LPSTR AtlAllocTaskAnsiString(LPCSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nSize = lstrlenA(lpszString)+1;
	LPSTR lpszResult = (LPSTR)CoTaskMemAlloc(nSize);
	if (lpszResult != NULL)
		memcpy(lpszResult, lpszString, nSize);
	return lpszResult;
}

#ifdef _UNICODE
	#define AtlAllocTaskString(x) AtlAllocTaskWideString(x)
#else
	#define AtlAllocTaskString(x) AtlAllocTaskAnsiString(x)
#endif

#define AtlAllocTaskOleString(x) AtlAllocTaskWideString(x)

};  // namespace ATL

#endif  //__ATLMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlmq.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMQ_H__
#define __ATLMQ_H__

#pragma once

#include <atlbase.h>
#include <mq.h>                             // MSMQ header file
#include <atlcoll.h>

namespace ATL {

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "mqrt.lib")			// import lib for MSMQ runtime
#endif  // !_ATL_NO_DEFAULT_LIBS

// class CMQPropertyHolder
// Base class for variable MSMQ property structures
// PropT is the base MSMQ structure to derive from
// example: MQMSGPROPS
// Note, this class does NOT free any of the pointer
// values embedded in MQPROPVARIANTs contained
// in m_rgProps
template <class PropT>
class CMQPropertyHolder : public PropT
{
protected:

public:
	CSimpleArray<PROPID> m_rgIds;			// array of property ids
	CSimpleArray<MQPROPVARIANT, CSimpleArrayEqualHelperFalse<MQPROPVARIANT> > m_rgProps;	// array of MQPROPVARIANT property values
	CSimpleArray<HRESULT> m_rgStatus;		// array of HRESULT property status values

	// constructor
	CMQPropertyHolder() throw()
	{
		cProp = 0;
		aPropID = 0;
		aPropVar = NULL;
		aStatus = NULL;
	}


	int Add(PROPID msgPropId, VARTYPE vt, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		MQPROPVARIANT propVar;
		propVar.vt = vt;
		return Add(msgPropId, &propVar, pData, nElems, nElemSize);
	}


	int Add(PROPID msgPropId, MQPROPVARIANT *pPropVar, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		ATLASSERT(pPropVar);

		DWORD dw = msgPropId;
		if (!m_rgIds.Add(dw))
			return -1;

		if (!m_rgProps.Add(*pPropVar))
			return -1;
		int nIndex = m_rgProps.GetSize()-1;

#ifdef _DEBUG
		if (pPropVar->vt & VT_VECTOR)
		{
			ATLASSERT(nElemSize != 0);
			ATLASSERT(pData != NULL);
			ATLASSERT(nElems != 0);
		}
		else if (pPropVar->vt == VT_BSTR ||
			pPropVar->vt == VT_CLSID ||
			pPropVar->vt == VT_BLOB ||
			pPropVar->vt == VT_LPSTR ||
			pPropVar->vt == VT_LPWSTR)
		{
			ATLASSERT(pData != NULL);
		}
#endif

		if (pData)
		{
			if (nElemSize)
			{
				m_rgProps[m_rgProps.GetSize()-1].caub.cElems = nElems;
				m_rgProps[m_rgProps.GetSize()-1].caub.pElems = (BYTE*) pData;
			}
			else
				m_rgProps[m_rgProps.GetSize()-1].pwszVal = (WCHAR *) pData;
		}
		HRESULT hr = S_OK;
		if (!m_rgStatus.Add(hr))
			return -1;
		cProp++;
		aPropID = m_rgIds.GetData();
		aPropVar = m_rgProps.GetData();
		aStatus = m_rgStatus.GetData();
		
		return nIndex;
	}

	MQPROPVARIANT &GetProperty(int nIndex) throw()
	{
		return m_rgProps[nIndex];
	}

	int FindProperty(PROPID propId) throw()
	{
		int nSize = m_rgIds.GetSize();
		for (int i=0; i<nSize; i++)
		{
			if (m_rgIds[i]==propId)
				return i;
		}
		return -1;
	}
};

// s_MQMsgPropTypes is a map between MSMQ message property
// id to the type of the property
// the type can be retrieved by using s_MQMsgPropTypes[propId-PROPID_M_BASE]
extern "C" const __declspec(selectany) VARTYPE s_MQMsgPropTypes[] = 
{
	/*PROPID_M_BASE*/ VT_NULL,
	/*PROPID_M_CLASS*/ VT_UI2,
	/*PROPID_M_MSGID*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_CORRELATIONID*/VT_UI1|VT_VECTOR,
	/*PROPID_M_PRIORITY*/ VT_UI1,
	/*PROPID_M_DELIVERY*/ VT_UI1,
	/*PROPID_M_ACKNOWLEDGE*/ VT_UI1, 
	/*PROPID_M_JOURNAL*/ VT_UI1,
	/*PROPID_M_APPSPECIFIC*/ VT_UI4,
	/*PROPID_M_BODY*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_BODY_SIZE*/ VT_UI4,
	/*PROPID_M_LABEL*/ VT_LPWSTR,
	/*PROPID_M_LABEL_LEN*/ VT_UI4,
	/*PROPID_M_TIME_TO_REACH_QUEUE*/ VT_UI4,
	/*PROPID_M_TIME_TO_BE_RECEIVED*/ VT_UI4,
	/*PROPID_M_RESP_QUEUE*/ VT_LPWSTR,
	/*PROPID_M_RESP_QUEUE_LEN*/ VT_UI4,
	/*PROPID_M_ADMIN_QUEUE*/ VT_LPWSTR,
	/*PROPID_M_ADMIN_QUEUE_LEN*/ VT_UI4,
	/*PROPID_M_VERSION*/ VT_UI4,
	/*PROPID_M_SENDERID*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_SENDERID_LEN*/ VT_UI4,
	/*PROPID_M_SENDERID_TYPE*/ VT_UI4,
	/*PROPID_M_PRIV_LEVEL*/ VT_UI4,
	/*PROPID_M_AUTH_LEVEL*/ VT_UI4,
	/*PROPID_M_AUTHENTICATED*/ VT_UI1,
	/*PROPID_M_HASH_ALG*/ VT_UI4,
	/*PROPID_M_ENCRYPTION_ALG*/ VT_UI4,
	/*PROPID_M_SENDER_CERT*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_SENDER_CERT_LEN*/ VT_UI4,
	/*PROPID_M_SRC_MACHINE_ID*/ VT_CLSID,
	/*PROPID_M_SENTTIME*/ VT_UI4,
	/*PROPID_M_ARRIVEDTIME*/ VT_UI4,
	/*PROPID_M_DEST_QUEUE*/ VT_LPWSTR,
	/*PROPID_M_DEST_QUEUE_LEN*/ VT_UI4,
	/*PROPID_M_EXTENSION*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_EXTENSION_LEN*/ VT_UI4,
	/*PROPID_M_SECURITY_CONTEXT*/ VT_UI4,
	/*PROPID_M_CONNECTOR_TYPE*/ VT_CLSID,
	/*PROPID_M_XACT_STATUS_QUEUE*/ VT_LPWSTR,
	/*PROPID_M_XACT_STATUS_QUEUE_LEN*/ VT_UI4,
	/*PROPID_M_TRACE*/ VT_UI1,
	/*PROPID_M_BODY_TYPE*/ VT_UI4,
	/*PROPID_M_DEST_SYMM_KEY*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_DEST_SYMM_KEY_LEN*/ VT_UI4,
	/*PROPID_M_SIGNATURE*/ VT_UI1|VT_VECTOR,
	/*PROPID_M_SIGNATURE_LEN*/ VT_UI4,
	/*PROPID_M_PROV_TYPE*/ VT_UI4,
	/*PROPID_M_PROV_NAME*/ VT_LPWSTR,
	/*PROPID_M_PROV_NAME_LEN*/ VT_UI4,
};


// class CMQMessageProps
// Simple class to eliminate having to pass the property
// type of message properties
class CMQMessageProps : public CMQPropertyHolder<MQMSGPROPS>
{
protected:

public:
	int Add(MSGPROPID msgPropId, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		ATLASSERT(msgPropId - PROPID_M_BASE < sizeof(s_MQMsgPropTypes)/sizeof(VARTYPE));
		return CMQPropertyHolder<MQMSGPROPS>::Add(msgPropId, s_MQMsgPropTypes[msgPropId - PROPID_M_BASE], pData, nElems, nElemSize);
	}

	template <typename T>
	int AddT(MSGPROPID msgPropId, T val)
	{
		ATLASSERT(msgPropId - PROPID_M_BASE < sizeof(s_MQMsgPropTypes)/sizeof(VARTYPE));
		CMQPropVariantIn var (val);
		ATLASSERT(var.vt == s_MQMsgPropTypes[msgPropId - PROPID_M_BASE]);
		return CMQPropertyHolder<MQMSGPROPS>::Add (msgPropId, &var);
	}
};

// s_MQQueuePropTypes is a map between MSMQ queue property
// id to the type of the property
// the type can be retrieved by using s_MQQueuePropTypes[propId-PROPID_Q_BASE]
extern "C" const __declspec(selectany)  VARTYPE s_MQQueuePropTypes[] = 
{
/*PROPID_Q_BASE*/ VT_NULL,
/*PROPID_Q_INSTANCE*/ VT_CLSID,
/*PROPID_Q_TYPE*/ VT_CLSID,
/*PROPID_Q_PATHNAME*/ VT_LPWSTR,
/*PROPID_Q_JOURNAL*/ VT_UI1,
/*PROPID_Q_QUOTA*/ VT_UI4,
/*PROPID_Q_BASEPRIORITY*/ VT_I2,
/*PROPID_Q_JOURNAL_QUOTA*/ VT_UI4,
/*PROPID_Q_LABEL*/ VT_LPWSTR,
/*PROPID_Q_CREATE_TIME*/ VT_I4,
/*PROPID_Q_MODIFY_TIME*/ VT_I4,
/*PROPID_Q_AUTHENTICATE*/ VT_UI1,
/*PROPID_Q_PRIV_LEVEL*/ VT_UI4,
/*PROPID_Q_TRANSACTION*/ VT_UI1
};

// class CMQQueueProps
// Simple class to eliminate having to pass the property
// type of queue properties
// When constructing the class you have to specify
// a transfer direction.  MQ_TRANSFER_DIR_GET means
// the class is being used to retrieve properties
// from MSMQ, so some properties are dynamically
// allocated and must be freed by MSMQ.
// MQ_TRANSFER_DIR_PUT means the class is being
// used to set properties and so the properties
// are allocated and freed by the user.
// 
class CMQQueueProps : public CMQPropertyHolder<MQQUEUEPROPS>
{
protected:

public:
	enum MQ_TRANSFER_DIR { MQ_TRANSFER_DIR_INVALID, MQ_TRANSFER_DIR_GET, MQ_TRANSFER_DIR_PUT };

	MQ_TRANSFER_DIR m_nDirection;

	CMQQueueProps(MQ_TRANSFER_DIR nDirection) throw()
	{
		m_nDirection = MQ_TRANSFER_DIR_INVALID;
		SetDirection(nDirection);
	}

	void SetDirection(MQ_TRANSFER_DIR nDirection) throw()
	{
		// if we're switching from GET to PUT
		// free allocated properties now

		if (m_nDirection == MQ_TRANSFER_DIR_GET && nDirection == MQ_TRANSFER_DIR_PUT)
			FreeAllocatedProperties();
		m_nDirection = nDirection;
	}
	
	void FreeAllocatedProperties() throw()
	{
		// this function should only be called when
		// the class is being used to retrieve queue properties
		ATLASSERT(m_nDirection == MQ_TRANSFER_DIR_GET);

		for (int i=0; i<m_rgProps.GetSize(); i++)
		{
			if (m_rgIds[i] == PROPID_Q_LABEL ||
				m_rgIds[i] == PROPID_Q_PATHNAME && m_rgProps[i].pwszVal)
			{
				MQFreeMemory(m_rgProps[i].pwszVal);
				m_rgProps[i].pwszVal = NULL;
			}
		}
	}

	~CMQQueueProps() throw()
	{
		if (m_nDirection == MQ_TRANSFER_DIR_GET)
			FreeAllocatedProperties();
	}

	int Add(QUEUEPROPID queuePropId, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		ATLASSERT(queuePropId - PROPID_Q_BASE < sizeof(s_MQQueuePropTypes)/sizeof(VARTYPE));
		return Add(queuePropId, s_MQQueuePropTypes[queuePropId - PROPID_Q_BASE], pData, nElems, nElemSize);
	}

	int Add(PROPID propId, VARTYPE vt, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		MQPROPVARIANT propVar;
		propVar.vt = vt;
		return Add(propId, &propVar, pData, nElems, nElemSize);
	}

	int Add(PROPID propId, MQPROPVARIANT *pPropVar, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		if (m_nDirection == MQ_TRANSFER_DIR_GET && 
				(propId==PROPID_Q_LABEL || propId==PROPID_Q_PATHNAME))
		{
			// special handling for these two
			// when getting properties, vt should be set to VT_NULL

			ATLASSERT(pData == NULL);	// the result will be dynamially allocated by MSMQ
			pPropVar->vt = VT_NULL;
		}
		return CMQPropertyHolder<MQQUEUEPROPS>::Add(propId, pPropVar, pData, nElems, nElemSize);
	}
};

// s_MQMachinePropTypes is a map between MSMQ machine property
// id to the type of the property
// the type can be retrieved by using s_MQMachinePropTypes[propId-PROPID_QM_BASE]
extern "C" const __declspec(selectany)  VARTYPE s_MQMachinePropTypes[] = 
{
/*PROPID_QM_BASE*/ VT_NULL,
/*PROPID_QM_SITE_ID*/ VT_CLSID,
/*PROPID_QM_MACHINE_ID*/ VT_CLSID,
/*PROPID_QM_PATHNAME*/ VT_NULL,
/*PROPID_QM_CONNECTION*/ VT_LPWSTR|VT_VECTOR,
/*PROPID_QM_ENCRYPTION_PK*/ NULL,
};

// class CMQMachineProps
// Simple class to eliminate having to pass the property
// type of machine properties
// The class frees properties that are dynamically allocated
// by MSMQ
// 
class CMQMachineProps : public CMQPropertyHolder<MQQMPROPS>
{
protected:

public:
	~CMQMachineProps() throw()
	{
		FreeAllocatedProperties();
	}

	void FreeAllocatedProperties() throw()
	{
		for (int i=0; i<m_rgProps.GetSize(); i++)
		{
			// TODO: I haven't been able to get PROPID_QM_CONNECTION and PROPID_QM_ENCRYPTION_PK
			// to work, with any VT
			// the docs seem to indicate that they should be freed, but not very
			// clear about it!
			if ((m_rgIds[i] ==  PROPID_QM_PATHNAME && m_rgProps[i].pwszVal))
			{
				MQFreeMemory(m_rgProps[i].pwszVal);
				m_rgProps[i].pwszVal = NULL;
			}
		}
	}

	int Add(QMPROPID propId, void *pData = NULL, int nElems=0, int nElemSize=0) throw()
	{
		ATLASSERT(propId - PROPID_QM_BASE < sizeof(s_MQMachinePropTypes)/sizeof(VARTYPE));
		return CMQPropertyHolder<MQQMPROPS>::Add(propId, s_MQMachinePropTypes[propId - PROPID_QM_BASE], pData, nElems, nElemSize);
	}
};


class CMQQueue;


// struct CMQOverlapped
// This is the structure that will be used
// with IoCompletion port based io
struct CMQOverlapped : public OVERLAPPED
{
	CMQMessageProps *m_pProps;	// the message props associated with the request
	CMQQueue *m_pQueue;			// the queue associated with the request
};


// class CMQQueue
// This class encapsulates MSMQ queue related methods
class CMQQueue
{
protected:
	HANDLE m_hQueue;
	WCHAR m_wszFormatName[MQ_MAX_Q_NAME_LEN+1];
	
public:
	CMQQueue() throw()
	{
		m_hQueue = NULL;
		m_wszFormatName[0] = '\0';
	}

	HANDLE GetHandle() throw()
	{
		return m_hQueue;
	}

	operator HANDLE() throw()
	{
		return m_hQueue;
	}

	BOOL SetFormatName(LPCWSTR wszFormatName) throw()
	{
		int nLen = (int) wcslen(wszFormatName);
		if (nLen == 0 || nLen > MQ_MAX_Q_NAME_LEN)
			return FALSE;
		wcscpy(m_wszFormatName, wszFormatName);
		return TRUE;
	}

	HRESULT PathNameToFormatName(LPCWSTR wszPathName) throw()
	{
		DWORD dwDestFormatLen = sizeof(m_wszFormatName)/sizeof(WCHAR);
		return MQPathNameToFormatName(wszPathName, m_wszFormatName, &dwDestFormatLen);
	}

	HRESULT Open(
		LPCWSTR wszPathName,
		DWORD dwAccessMode=MQ_RECEIVE_ACCESS,
		DWORD dwShareMode=MQ_DENY_NONE) throw()
	{
		ATLASSERT(m_hQueue == NULL);	// You should the queue, before opening another one


		HRESULT hr = PathNameToFormatName(wszPathName);
		if (FAILED(hr))
			return hr;

		return Open(dwAccessMode, dwShareMode);
	}

	// open that uses the current format name
	HRESULT Open(DWORD dwAccessMode=MQ_RECEIVE_ACCESS, DWORD dwShareMode=MQ_DENY_NONE) throw()
	{
		ATLASSERT(m_wszFormatName[0]);
		return MQOpenQueue(m_wszFormatName, dwAccessMode, dwShareMode, &m_hQueue);
	}

	HRESULT FormatNameFromHandle(LPWSTR wszFormatName, LPDWORD pdwCount) throw()
	{
		ATLASSERT(m_hQueue);
		return MQHandleToFormatName(m_hQueue,  wszFormatName,  pdwCount);
	}

	HRESULT AssociateCompletionPort(HANDLE hIoCompletion, DWORD dwNumThreads=0) throw()
	{
		ATLASSERT(m_hQueue != NULL);

		HANDLE hIoCompletionRet = CreateIoCompletionPort(m_hQueue, hIoCompletion, (ULONG_PTR) this, dwNumThreads);
		if (!hIoCompletionRet)
			return AtlHresultFromLastError();
		return S_OK;
	}


	HRESULT Receive(MQMSGPROPS *pMsgProps) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQReceiveMessage(m_hQueue, 0, MQ_ACTION_RECEIVE, pMsgProps, NULL, NULL, NULL, NULL);
	}

	HRESULT Peek(MQMSGPROPS *pMsgProps, HANDLE hCursor) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQReceiveMessage(m_hQueue, 0, MQ_ACTION_PEEK_CURRENT, pMsgProps, NULL, NULL, hCursor, NULL);
	}

	HRESULT PeekNext(MQMSGPROPS *pMsgProps, HANDLE hCursor) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQReceiveMessage(m_hQueue, 0, MQ_ACTION_PEEK_NEXT, pMsgProps, NULL, NULL, hCursor, NULL);
	}

	HRESULT ReceiveWithCallback(
		CMQMessageProps *pProps,
		PMQRECEIVECALLBACK pfnCallback,
		DWORD dwTimeout=INFINITE) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQReceiveMessage(m_hQueue, dwTimeout, MQ_ACTION_RECEIVE, pProps, NULL, pfnCallback, NULL, NULL);
	}


	HRESULT ReceiveOverlapped(
		CMQMessageProps *pProps,
		OVERLAPPED *pOverlapped,
		DWORD dwTimeout=INFINITE) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQReceiveMessage(m_hQueue, dwTimeout, MQ_ACTION_RECEIVE, pProps, pOverlapped, NULL, NULL, NULL);
	}

	HRESULT ReceiveWithIoCompletion(CMQMessageProps *pProps, DWORD dwTimeout=INFINITE) throw()
	{
		ATLASSERT(m_hQueue != NULL);

		// The CMQOverlapped structure allocated here, must be
		// freed when the request is retrieved from the
		// IoCompletion port
		CMQOverlapped *pOverlapped = NULL;
		ATLTRY(pOverlapped = new CMQOverlapped);
		if (!pOverlapped)
			return E_OUTOFMEMORY;
		memset(pOverlapped, 0x00, sizeof(CMQOverlapped));

		pOverlapped->m_pProps = pProps;
		pOverlapped->m_pQueue = this;
		return MQReceiveMessage(m_hQueue, dwTimeout, MQ_ACTION_RECEIVE, pProps, pOverlapped, NULL, NULL, NULL);
	}

	HRESULT Send(MQMSGPROPS *pMsgProps, ITransaction *pTransaction = NULL) throw()
	{
		ATLASSERT(m_hQueue != NULL);
		return MQSendMessage(GetHandle(), pMsgProps, pTransaction);
	}

	HRESULT Close() throw()
	{
		HRESULT hr = S_OK;
		if (m_hQueue)
			hr = MQCloseQueue(m_hQueue);
		m_hQueue = NULL;
		return hr;
	}
		
	~CMQQueue() throw()
	{
		if (m_hQueue)
			Close();
	}

	HRESULT Create(MQQUEUEPROPS *pQueueProps, PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL) throw()
	{
		DWORD dwFormatNameLen = sizeof(m_wszFormatName)/sizeof(WCHAR);
		return MQCreateQueue(pSecurityDescriptor, pQueueProps, m_wszFormatName, &dwFormatNameLen);
	}

	HRESULT Create(
		LPCWSTR wszPathName,
		LPCWSTR wszLabel,
		BOOL bTransactional=FALSE,
		PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL) throw()
	{
		CMQQueueProps qProps(CMQQueueProps::MQ_TRANSFER_DIR_PUT);
		qProps.Add(PROPID_Q_PATHNAME, (void *) wszPathName);
		qProps.Add(PROPID_Q_LABEL, (void *) wszLabel);
		if (bTransactional)
		{
			int nIndex = qProps.Add(PROPID_Q_TRANSACTION);
			qProps.m_rgProps[nIndex].bVal = MQ_TRANSACTIONAL;
		}
		return Create(&qProps, pSecurityDescriptor);
	}


	HRESULT Delete() throw()
	{
		ATLASSERT(m_wszFormatName[0]);	// you should set the format name first
		return MQDeleteQueue(m_wszFormatName);
	}

	HRESULT GetQueueProperties(MQQUEUEPROPS *pQueueProps) throw()
	{
		ATLASSERT(m_wszFormatName[0]);	// you should set the format name first
		return MQGetQueueProperties(m_wszFormatName, pQueueProps);
	}

	HRESULT SetQueueProperties(MQQUEUEPROPS *pQueueProps) throw()
	{
		ATLASSERT(m_wszFormatName[0]);	// you should set the format name first
		return MQSetQueueProperties(m_wszFormatName, pQueueProps);
	}

	HRESULT CreateCursor(HANDLE *phHandle) throw()
	{
		ATLASSERT(m_hQueue);
		ATLASSERT(phHandle);
		return MQCreateCursor(m_hQueue, phHandle);
	}

	static HRESULT CloseCursor(HANDLE hCursor) throw()
	{
		ATLASSERT(hCursor!=NULL);
		return MQCloseCursor(hCursor);
	}

	static HRESULT BeginTransaction(ITransaction **ppTransaction) throw()
	{
		ATLASSERT(ppTransaction);
		return MQBeginTransaction(ppTransaction);
	}
};


// class CMQCursor
// This class encapsulates MSMQ cursor related methods
class CMQCursor
{
protected:
	HANDLE m_hCursor;
public:
	CMQCursor() throw() : m_hCursor(NULL)
	{

	}

	~CMQCursor() throw()
	{
		if (m_hCursor)
			Close();
	}

	void Attach(HANDLE hCursor) throw()
	{
		ATLASSERT(m_hCursor==NULL);
		m_hCursor = hCursor;
	}

	HANDLE Detach() throw()
	{
		HANDLE hCursor = m_hCursor;
		m_hCursor = NULL;
		return hCursor;
	}

	HRESULT Create(HANDLE hQueue) throw()
	{
		ATLASSERT(m_hCursor==NULL);
		return MQCreateCursor(hQueue, &m_hCursor);
	}

	HRESULT Close() throw()
	{
		ATLASSERT(m_hCursor!=NULL);
		HRESULT hr = MQCloseCursor(m_hCursor);
		m_hCursor = NULL;
		return hr;
	}

	operator HANDLE() throw()
	{
		return m_hCursor;
	}
};

// class CMQColumnSet
// Simple wrapper around an MSQM column set
class CMQColumnSet : public MQCOLUMNSET
{
protected:
	CAtlArray<PROPID> m_Ids;

public:
	CMQColumnSet() throw()
	{
		cCol = 0;
		aCol = NULL;
	}

	int Add(PROPID propId) throw()
	{
		int nIndex = (int)m_Ids.Add(propId);
		if (nIndex < 0)
			return nIndex;
		// update the MQCOLUMNSET members
		cCol = (int)m_Ids.GetCount();
		aCol = m_Ids.GetData();
		return nIndex;
	}
};

// class CMQPropVariantIn
// Simple wrapper around an MQPROPVARIANT
// Notice that this class is not suitable
// for receiving property values from MSMQ
// since it allocates memory using malloc
// CMQPropVariantRet can be used to receive
// property values from MSMQ
class CMQPropVariantIn : public MQPROPVARIANT
{
public:
	CMQPropVariantIn() throw()
	{
		vt = VT_NULL;
	}

	~CMQPropVariantIn() throw()
	{
		Clear();
	}

	CMQPropVariantIn(int n, VARTYPE vType=VT_I4) throw()
	{
		Set(n, vType);
	}

	CMQPropVariantIn(UINT n) throw()
	{
		Set((int) n, VT_UI4);
	}

	CMQPropVariantIn(unsigned char src) throw()
	{
		Set(src);
	}

	CMQPropVariantIn(short src) throw()
	{
		Set(src);
	}

	CMQPropVariantIn(USHORT src) throw()
	{
		Set(src);
	}

	CMQPropVariantIn(bool src) throw()
	{
		Set(src);
	}

	void Set(int n, VARTYPE vType=VT_I4) throw()
	{
		Clear();
		vt = vType;
		lVal = (long) n;
	}

	void Set(unsigned char b) throw()
	{
		Clear();
		vt = VT_UI1;
		bVal = b;
	}

	void Set(short s) throw()
	{
		Clear();
		vt = VT_I2;
		iVal = s;
	}

	void Set(USHORT us) throw()
	{
		Clear();
		vt = VT_UI2;
		uiVal = us;
	}

	void Set(bool b) throw()
	{
		Clear();
		vt = VT_BOOL;
		boolVal = b ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
	}

	BOOL Set(LPCWSTR wsz) throw()
	{
		Clear();
		DWORD dwLen = (DWORD) (wcslen(wsz)+1)*2;
		pwszVal = (LPWSTR) malloc(dwLen);
		if (!pwszVal)
			return FALSE;
		memcpy(pwszVal, wsz, dwLen);
		vt = VT_LPWSTR;
		return TRUE;
	}

	BOOL Set(CLSID *pclsid) throw()
	{
		Clear();
		puuid = (CLSID *) malloc(sizeof(CLSID));
		if (!puuid)
			return FALSE;
		memcpy(puuid, pclsid, sizeof(CLSID));
		vt = VT_CLSID;
		return TRUE;
	}

	// other overrides for set

	void Clear() throw()
	{
		void *pvFree = NULL;

		switch (vt)
		{
		case VT_CLSID:
			pvFree = puuid;
			break;

		case VT_LPWSTR:
			pvFree = pwszVal;
			break;

		}
		if (pvFree)
			free(pvFree);
		vt = VT_NULL;
	}
};


// class CMQPropVariantRet
// Simple wrapper around an MQPROPVARIANT
// Notice that this class is only suitable
// for receiving property values from MSMQ
class CMQPropVariantRet : public MQPROPVARIANT
{
public:
	CMQPropVariantRet() throw()
	{
		vt = VT_NULL;
	}

	~CMQPropVariantRet() throw()
	{
		Clear();
	}

	void Clear() throw()
	{
		void *pvFree = NULL;

		switch (vt)
		{
		case VT_CLSID:
			pvFree = puuid;
			break;

		case VT_LPWSTR:
			pvFree = pwszVal;
			break;

		}
		if (pvFree)
			MQFreeMemory(pvFree);
		vt = VT_NULL;
	}
};


// class CMQPropertyRestriction
// a class that encapsulates an MSMQ property restriction
class CMQPropertyRestriction : public MQPROPERTYRESTRICTION
{
public:
	CMQPropertyRestriction() throw()
	{
		rel = PREQ;
		prop = 0;
		prval.vt = VT_NULL;
	}

	CMQPropertyRestriction(ULONG rel, PROPID propId, MQPROPVARIANT *pVal) throw()
	{
		Set(rel, propId, pVal);
	}

	void Set(ULONG ulRel, PROPID propId, MQPROPVARIANT *pVal) throw()
	{
		ATLASSERT(ulRel==PRLT || ulRel==PRLE || ulRel==PRGE || ulRel==PREQ || ulRel==PRNE);
		ATLASSERT(pVal);

		// todo: figure out how to free current!
		rel = ulRel;
		prop = propId;
		prval = *pVal;
		pVal->vt = VT_NULL;
	}
};


// class CMQRestriction
// a class that encapsulates an MSMQ restriction
class CMQRestriction : public MQRESTRICTION
{
protected:
	CAtlArray<CMQPropertyRestriction, CElementTraitsBase<CMQPropertyRestriction> > m_propRestrictions;

public:
	CMQRestriction() throw()
	{
		cRes = 0;
		paPropRes = NULL;
	}


	int Add(CMQPropertyRestriction &res) throw()
	{
		int nIndex = (int)m_propRestrictions.Add(res);
		if (nIndex < 0)
			return nIndex;
		cRes = (int)m_propRestrictions.GetCount();
		paPropRes = m_propRestrictions.GetData();
		return nIndex;
	}
};

// class CMQLocator
// a class the encapsulates the MSMQ Locator APIs
class CMQLocator
{
protected:
	HANDLE m_hEnum;

public:
	CMQLocator() throw()
	{
		m_hEnum = NULL;
	}
	
	~CMQLocator() throw()
	{
		if (m_hEnum)
			End();
	}

	HRESULT Begin(MQRESTRICTION *pRestriction, MQCOLUMNSET *pColumns, MQSORTSET *pSort=NULL) throw()
	{
		ATLASSERT(m_hEnum == NULL);
		ATLASSERT(pColumns != NULL);
		return MQLocateBegin(NULL, pRestriction, pColumns, pSort, &m_hEnum);
	}
	
	HRESULT Next(DWORD *pcProps, PROPVARIANT *aPropVar) throw()
	{
		ATLASSERT(m_hEnum != NULL);
		ATLASSERT(pcProps);
		ATLASSERT(aPropVar);
		return MQLocateNext(m_hEnum, pcProps, aPropVar);
	}

	HRESULT End() throw()
	{
		ATLASSERT(m_hEnum != NULL);
		HRESULT hr = MQLocateEnd(m_hEnum);
		m_hEnum = NULL;
		return hr;
	}
};
} // namespace ATL

#endif // __ATLMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlpath.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPATH_H__
#define __ATLPATH_H__

#pragma once

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "shlwapi.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

namespace ATL
{

namespace ATLPath
{

inline char* AddBackslash( char* pszPath )
{
	return ::PathAddBackslashA( pszPath );
}

inline wchar_t* AddBackslash( wchar_t* pszPath )
{
	return ::PathAddBackslashW( pszPath );
}

inline BOOL AddExtension( char* pszPath, const char* pszExtension )
{
	return ::PathAddExtensionA( pszPath, pszExtension );
}

inline BOOL AddExtension( wchar_t* pszPath, const wchar_t* pszExtension )
{
	return ::PathAddExtensionW( pszPath, pszExtension );
}

inline BOOL Append( char* pszPath, const char* pszMore )
{
	return ::PathAppendA( pszPath, pszMore );
}

inline BOOL Append( wchar_t* pszPath, const wchar_t* pszMore )
{
	return ::PathAppendW( pszPath, pszMore );
}

inline char* BuildRoot( char* pszPath, int iDrive )
{
	return ::PathBuildRootA( pszPath, iDrive );
}

inline wchar_t* BuildRoot( wchar_t* pszPath, int iDrive )
{
	return ::PathBuildRootW( pszPath, iDrive );
}

inline BOOL Canonicalize( char* pszDest, const char* pszSrc )
{
	return ::PathCanonicalizeA( pszDest, pszSrc );
}

inline BOOL Canonicalize( wchar_t* pszDest, const wchar_t* pszSrc )
{
	return ::PathCanonicalizeW( pszDest, pszSrc );
}

inline char* Combine( char* pszDest, const char* pszDir,
	const char* pszFile )
{
	return ::PathCombineA( pszDest, pszDir, pszFile );
}

inline wchar_t* Combine( wchar_t* pszDest, const wchar_t* pszDir,
	const wchar_t* pszFile )
{
	return ::PathCombineW( pszDest, pszDir, pszFile );
}

inline int CommonPrefix( const char* pszFile1, const char* pszFile2,
	char* pszDest )
{
	return ::PathCommonPrefixA( pszFile1, pszFile2, pszDest );
}

inline int CommonPrefix( const wchar_t* pszFile1, const wchar_t* pszFile2,
	wchar_t* pszDest )
{
	return ::PathCommonPrefixW( pszFile1, pszFile2, pszDest );
}

inline BOOL FileExists( const char* pszPath )
{
	return ::PathFileExistsA( pszPath );
}

inline BOOL FileExists( const wchar_t* pszPath )
{
	return ::PathFileExistsW( pszPath );
}

inline char* FindExtension( const char* pszPath )
{
	return ::PathFindExtensionA( pszPath );
}

inline wchar_t* FindExtension( const wchar_t* pszPath )
{
	return ::PathFindExtensionW( pszPath );
}

inline char* FindFileName( const char* pszPath )
{
	return ::PathFindFileNameA( pszPath );
}

inline wchar_t* FindFileName( const wchar_t* pszPath )
{
	return ::PathFindFileNameW( pszPath );
}

inline int GetDriveNumber( const char* pszPath )
{
	return ::PathGetDriveNumberA( pszPath );
}

inline int GetDriveNumber( const wchar_t* pszPath )
{
	return ::PathGetDriveNumberW( pszPath );
}

inline BOOL IsDirectory( const char* pszPath )
{
	return ::PathIsDirectoryA( pszPath );
}

inline BOOL IsDirectory( const wchar_t* pszPath )
{
	return ::PathIsDirectoryW( pszPath );
}

/*
inline BOOL IsDirectoryEmpty( const char* pszPath )
{
	return ::PathIsDirectoryEmptyA( pszPath );
}
*/

/*
inline BOOL IsDirectoryEmpty( const wchar_t* pszPath )
{
	return ::PathIsDirectoryEmptyW( pszPath );
}
*/

inline BOOL IsFileSpec( const char* pszPath )
{
	return ::PathIsFileSpecA( pszPath );
}

inline BOOL IsFileSpec( const wchar_t* pszPath )
{
	return ::PathIsFileSpecW( pszPath );
}

inline BOOL IsPrefix( const char* pszPrefix, const char* pszPath )
{
	return ::PathIsPrefixA( pszPrefix, pszPath );
}

inline BOOL IsPrefix( const wchar_t* pszPrefix, const wchar_t* pszPath )
{
	return ::PathIsPrefixW( pszPrefix, pszPath );
}

inline BOOL IsRelative( const char* pszPath )
{
	return ::PathIsRelativeA( pszPath );
}

inline BOOL IsRelative( const wchar_t* pszPath )
{
	return ::PathIsRelativeW( pszPath );
}

inline BOOL IsRoot( const char* pszPath )
{
	return ::PathIsRootA( pszPath );
}

inline BOOL IsRoot( const wchar_t* pszPath )
{
	return ::PathIsRootW( pszPath );
}

inline BOOL IsSameRoot( const char* pszPath1, const char* pszPath2 )
{
	return ::PathIsSameRootA( pszPath1, pszPath2 );
}

inline BOOL IsSameRoot( const wchar_t* pszPath1, const wchar_t* pszPath2 )
{
	return ::PathIsSameRootW( pszPath1, pszPath2 );
}

inline BOOL IsUNC( const char* pszPath )
{
	return ::PathIsUNCA( pszPath );
}

inline BOOL IsUNC( const wchar_t* pszPath )
{
	return ::PathIsUNCW( pszPath );
}

inline BOOL IsUNCServer( const char* pszPath )
{
	return ::PathIsUNCServerA( pszPath );
}

inline BOOL IsUNCServer( const wchar_t* pszPath )
{
	return ::PathIsUNCServerW( pszPath );
}

inline BOOL IsUNCServerShare( const char* pszPath )
{
	return ::PathIsUNCServerShareA( pszPath );
}

inline BOOL IsUNCServerShare( const wchar_t* pszPath )
{
	return ::PathIsUNCServerShareW( pszPath );
}

inline BOOL MakePretty( char* pszPath )
{
	return ::PathMakePrettyA( pszPath );
}

inline BOOL MakePretty( wchar_t* pszPath )
{
	return ::PathMakePrettyW( pszPath );
}

inline BOOL MatchSpec( const char* pszPath, const char* pszSpec )
{
	return ::PathMatchSpecA( pszPath, pszSpec );
}

inline BOOL MatchSpec( const wchar_t* pszPath, const wchar_t* pszSpec )
{
	return ::PathMatchSpecW( pszPath, pszSpec );
}

inline void QuoteSpaces( char* pszPath )
{
	::PathQuoteSpacesA( pszPath );
}

inline void QuoteSpaces( wchar_t* pszPath )
{
	::PathQuoteSpacesW( pszPath );
}

inline BOOL RelativePathTo( char* pszPath, const char* pszFrom,
	DWORD dwAttrFrom, const char* pszTo, DWORD dwAttrTo )
{
	return ::PathRelativePathToA( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline BOOL RelativePathTo( wchar_t* pszPath, const wchar_t* pszFrom,
	DWORD dwAttrFrom, const wchar_t* pszTo, DWORD dwAttrTo )
{
	return ::PathRelativePathToW( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline void RemoveArgs( char* pszPath )
{
	::PathRemoveArgsA( pszPath );
}

inline void RemoveArgs( wchar_t* pszPath )
{
	::PathRemoveArgsW( pszPath );
}

inline char* RemoveBackslash( char* pszPath )
{
	return ::PathRemoveBackslashA( pszPath );
}

inline wchar_t* RemoveBackslash( wchar_t* pszPath )
{
	return ::PathRemoveBackslashW( pszPath );
}

inline void RemoveBlanks( char* pszPath )
{
	::PathRemoveBlanksA( pszPath );
}

inline void RemoveBlanks( wchar_t* pszPath )
{
	::PathRemoveBlanksW( pszPath );
}

inline void RemoveExtension( char* pszPath )
{
	::PathRemoveExtensionA( pszPath );
}

inline void RemoveExtension( wchar_t* pszPath )
{
	::PathRemoveExtensionW( pszPath );
}

inline BOOL RemoveFileSpec( char* pszPath )
{
	return ::PathRemoveFileSpecA( pszPath );
}

inline BOOL RemoveFileSpec( wchar_t* pszPath )
{
	return ::PathRemoveFileSpecW( pszPath );
}

inline BOOL RenameExtension( char* pszPath, const char* pszExt )
{
	return ::PathRenameExtensionA( pszPath, pszExt );
}

inline BOOL RenameExtension( wchar_t* pszPath, const wchar_t* pszExt )
{
	return ::PathRenameExtensionW( pszPath, pszExt );
}

inline char* SkipRoot( const char* pszPath )
{
	return ::PathSkipRootA( pszPath );
}

inline wchar_t* SkipRoot( const wchar_t* pszPath )
{
	return ::PathSkipRootW( pszPath );
}

inline void StripPath( char* pszPath )
{
	::PathStripPathA( pszPath );
}

inline void StripPath( wchar_t* pszPath )
{
	::PathStripPathW( pszPath );
}

inline BOOL StripToRoot( char* pszPath )
{
	return ::PathStripToRootA( pszPath );
}

inline BOOL StripToRoot( wchar_t* pszPath )
{
	return ::PathStripToRootW( pszPath );
}

inline void UnquoteSpaces( char* pszPath )
{
	::PathUnquoteSpacesA( pszPath );
}

inline void UnquoteSpaces( wchar_t* pszPath )
{
	::PathUnquoteSpacesW( pszPath );
}

inline BOOL CompactPath( HDC hDC, char* pszPath, UINT dx )
{
	return ::PathCompactPathA( hDC, pszPath, dx );
}

inline BOOL CompactPath( HDC hDC, wchar_t* pszPath, UINT dx )
{
	return ::PathCompactPathW( hDC, pszPath, dx );
}

inline BOOL CompactPathEx( char* pszDest, const char* pszSrc,
	UINT nMaxChars, DWORD dwFlags )
{
	return ::PathCompactPathExA( pszDest, pszSrc, nMaxChars, dwFlags );
}

inline BOOL CompactPathEx( wchar_t* pszDest, const wchar_t* pszSrc,
	UINT nMaxChars, DWORD dwFlags )
{
	return ::PathCompactPathExW( pszDest, pszSrc, nMaxChars, dwFlags );
}

};  // namespace ATLPath

template< typename StringType >
class CPathT
{
public:
	typedef StringType::XCHAR XCHAR;
	typedef StringType::PCXSTR PCXSTR;
	typedef StringType::PXSTR PXSTR;

public:
	CPathT() throw()
	{
	}
	CPathT( const CPathT< StringType >& path ) :
		m_strPath( path.m_strPath )
	{
	}
	CPathT( PCXSTR pszPath ) :
		m_strPath( pszPath )
	{
	}

	operator const StringType& () const throw()
	{
		return m_strPath;
	}
	operator StringType& () throw()
	{
		return m_strPath;
	}
	operator PCXSTR() const throw()
	{
		return m_strPath;
	}
	CPathT< StringType >& operator+=( PCXSTR pszMore )
	{
		Append( pszMore );

		return *this;
	}

	void AddBackslash()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+1 );
		ATLPath::AddBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL AddExtension( PCXSTR pszExtension )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+StringType::StringLength( pszExtension ) );
		bResult = ATLPath::AddExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL Append( PCXSTR pszMore )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+StringType::StringLength( pszMore )+1 );
		bResult = ATLPath::Append( pszBuffer, pszMore );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void BuildRoot( int iDrive )
	{
		PXSTR pszBuffer;

		ATLASSERT( iDrive >= 0 );
		ATLASSERT( iDrive <= 25 );

		pszBuffer = m_strPath.GetBuffer( 3 );
		ATLPath::BuildRoot( pszBuffer, iDrive );
		m_strPath.ReleaseBuffer();
	}
	void Canonicalize()
	{
		PXSTR pszBuffer;
		StringType strResult;

		pszBuffer = strResult.GetBuffer( m_strPath.GetLength() );
		ATLPath::Canonicalize( pszBuffer, m_strPath );
		strResult.ReleaseBuffer();

		m_strPath = strResult;
	}
	void Combine( PCXSTR pszDir, PCXSTR pszFile )
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		ATLPath::Combine( pszBuffer, pszDir, pszFile );
		m_strPath.ReleaseBuffer();
	}
	CPathT< StringType > CommonPrefix( PCXSTR pszOther )
	{
		PXSTR pszBuffer;
		int nLength;
		CPathT< StringType > pathResult;

		pszBuffer = pathResult.m_strPath.GetBuffer( max( m_strPath.GetLength(), StringType::StringLength( pszOther ) ) );
		nLength = ATLPath::CommonPrefix( m_strPath, pszOther, pszBuffer );
		pathResult.m_strPath.ReleaseBuffer( nLength );

		return pathResult;
	}
	BOOL CompactPath( HDC hDC, UINT nWidth )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		// PathCompactPath can actually _increase_ the length of the path
		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::CompactPath( hDC, pszBuffer, nWidth );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL CompactPathEx( UINT nMaxChars, DWORD dwFlags = 0 )
	{
		StringType strResult;
		BOOL bResult;
		PXSTR pszBuffer;

		pszBuffer = strResult.GetBuffer( nMaxChars );
		bResult = ATLPath::CompactPathEx( pszBuffer, m_strPath, nMaxChars,
			dwFlags );
		strResult.ReleaseBuffer();

		m_strPath = strResult;

		return bResult;
	}
	BOOL FileExists() const
	{
		return ATLPath::FileExists( m_strPath );
	}
	int FindExtension() const
	{
		PCXSTR pszBuffer;
		PCXSTR pszExtension;

		pszBuffer = m_strPath;
		pszExtension = ATLPath::FindExtension( pszBuffer );
		if( *pszExtension == 0 )
			return -1;
		else
			return int( pszExtension-pszBuffer );
	}
	int FindFileName() const
	{
		PCXSTR pszBuffer;
		PCXSTR pszFileName;

		pszBuffer = m_strPath;
		pszFileName = ATLPath::FindFileName( pszBuffer );
		if( *pszFileName == 0 )
			return -1;
		else
			return int( pszFileName-pszBuffer );
	}
	int GetDriveNumber() const
	{
		return ATLPath::GetDriveNumber( m_strPath );
	}
	StringType GetExtension() const
	{
		int iExtension;
		StringType strExtension;

		iExtension = FindExtension();
		if( iExtension != -1 )
			strExtension = m_strPath.Mid( iExtension );

		return strExtension;
	}
	BOOL IsDirectory() const
	{
		return ATLPath::IsDirectory( m_strPath );
	}
	/*
	BOOL IsDirectoryEmpty() const
	{
		return Traits::PathIsDirectoryEmpty( m_strPath );
	}
	*/
	BOOL IsFileSpec() const
	{
		return ATLPath::IsFileSpec( m_strPath );
	}
	BOOL IsPrefix( PCXSTR pszPrefix ) const
	{
		return ATLPath::IsPrefix( pszPrefix, m_strPath );
	}
	BOOL IsRelative() const
	{
		return ATLPath::IsRelative( m_strPath );
	}
	BOOL IsRoot() const
	{
		return ATLPath::IsRoot( m_strPath );
	}
	BOOL IsSameRoot( PCXSTR pszOther ) const
	{
		return ATLPath::IsSameRoot( m_strPath, pszOther );
	}
	BOOL IsUNC() const
	{
		return ATLPath::IsUNC( m_strPath );
	}
	BOOL IsUNCServer() const
	{
		return ATLPath::IsUNCServer( m_strPath );
	}
	BOOL IsUNCServerShare() const
	{
		return ATLPath::IsUNCServerShare( m_strPath );
	}
	BOOL MakePretty()
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		bResult = ATLPath::MakePretty( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL MatchSpec( PCXSTR pszSpec ) const
	{
		return ATLPath::MatchSpec( m_strPath, pszSpec );
	}
	void QuoteSpaces()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+2 );
		ATLPath::QuoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RelativePathTo( PCXSTR pszFrom, DWORD dwAttrFrom, 
		PCXSTR pszTo, DWORD dwAttrTo )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::RelativePathTo( pszBuffer, pszFrom, dwAttrFrom,
			pszTo, dwAttrTo );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void RemoveArgs()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveArgs( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBackslash()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBlanks()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBlanks( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveExtension()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveExtension( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RemoveFileSpec()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		BOOL bResult = ATLPath::RemoveFileSpec( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL RenameExtension( PCXSTR pszExtension )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::RenameExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	int SkipRoot() const
	{
		PCXSTR pszBuffer;
		PXSTR pszResult;

		pszBuffer = m_strPath;
		pszResult = ATLPath::SkipRoot( pszBuffer );

		return int( pszResult-pszBuffer );
	}
	void StripPath()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::StripPath( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL StripToRoot()
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		bResult = ATLPath::StripToRoot( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void UnquoteSpaces()
	{
		PXSTR pszBuffer;
		
		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::UnquoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}

public:
	StringType m_strPath;
};

typedef CPathT< CString > CPath;
typedef CPathT< CStringA > CPathA;
typedef CPathT< CStringW > CPathW;

};  // namespace ATL

#endif  //__ATLPATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlimage.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLIMAGE_H__
#define __ATLIMAGE_H__

#pragma once

#include <atldef.h>
#include <atlbase.h>
#include <atlstr.h>
#include <atlsimpcoll.h>
#include <atltypes.h>

//REVIEW
#pragma warning( push, 3 )
#pragma push_macro("new")
#undef new
#include <gdiplus.h>
#pragma pop_macro("new")
#pragma warning( pop )

#include <shlwapi.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "gdiplus.lib")
#if WINVER >= 0x0500
#pragma comment(lib, "msimg32.lib")
#endif  // WINVER >= 0x0500
#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma pack(push, _ATL_PACKING)

namespace ATL
{

const int CIMAGE_DC_CACHE_SIZE = 4;

class CImage;

class CImageDC
{
public:
	CImageDC( const CImage& image ) throw( ... );
	~CImageDC() throw();

	operator HDC() const throw();

private:
	const CImage& m_image;
	HDC m_hDC;
};

class CImage
{
private:
	class CDCCache
	{
	public:
		CDCCache() throw();
		~CDCCache() throw();

		HDC GetDC() throw();
		void ReleaseDC( HDC ) throw();

	private:
		HDC m_ahDCs[CIMAGE_DC_CACHE_SIZE];
	};

	class CInitGDIPlus
	{
	public:
		CInitGDIPlus() throw();
		~CInitGDIPlus() throw();

		bool Init() throw();

	private:
		ULONG_PTR m_dwToken;
	};

public:
	static const DWORD createAlphaChannel = 0x01;

	static const DWORD excludeGIF = 0x01;
	static const DWORD excludeBMP = 0x02;
	static const DWORD excludeEMF = 0x04;
	static const DWORD excludeWMF = 0x08;
	static const DWORD excludeJPEG = 0x10;
	static const DWORD excludePNG = 0x20;
	static const DWORD excludeTIFF = 0x40;
	static const DWORD excludeIcon = 0x80;
	static const DWORD excludeOther = 0x80000000;
	static const DWORD excludeDefaultLoad = 0;
	static const DWORD excludeDefaultSave = excludeIcon|excludeEMF|excludeWMF;
	static const DWORD excludeValid = 0x800000ff;

	enum DIBOrientation
	{
		DIBOR_DEFAULT,
		DIBOR_TOPDOWN,
		DIBOR_BOTTOMUP
	};

public:
	CImage() throw();
	virtual ~CImage() throw();

	operator HBITMAP() const throw();
#if WINVER >= 0x0500
	BOOL AlphaBlend( HDC hDestDC, int xDest, int yDest, BYTE bSrcAlpha = 0xff, 
		BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, const POINT& pointDest, BYTE bSrcAlpha = 0xff, 
		BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
		BYTE bSrcAlpha = 0xff, BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc, 
		BYTE bSrcAlpha = 0xff, BYTE bBlendOp = AC_SRC_OVER ) const throw();
#endif  // WINVER >= 0x0500
	void Attach( HBITMAP hBitmap, DIBOrientation eOrientation = DIBOR_DEFAULT ) throw();
	BOOL BitBlt( HDC hDestDC, int xDest, int yDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, const POINT& pointDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, const RECT& rectDest, const POINT& pointSrc, 
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL Create( int nWidth, int nHeight, int nBPP, DWORD dwFlags = 0 ) throw();
	BOOL CreateEx( int nWidth, int nHeight, int nBPP, DWORD eCompression, 
		const DWORD* pdwBitmasks = NULL, DWORD dwFlags = 0 ) throw();
	void Destroy() throw();
	HBITMAP Detach() throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight ) const throw();
	BOOL Draw( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc ) const throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest ) const throw();
	BOOL Draw( HDC hDestDC, const POINT& pointDest ) const throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight ) const throw();
	BOOL Draw( HDC hDestDC, const RECT& rectDest ) const throw();
	const void* GetBits() const throw();
	void* GetBits() throw();
	int GetBPP() const throw();
	void GetColorTable( UINT iFirstColor, UINT nColors, RGBQUAD* prgbColors ) const throw();
	HDC GetDC() const throw();
	static HRESULT GetExporterFilterString( CSimpleString& strExporters, 
		CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription = NULL, 
		DWORD dwExclude = excludeDefaultSave, TCHAR chSeparator = _T( '|' ) );
	static HRESULT GetImporterFilterString( CSimpleString& strImporters, 
		CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription = NULL, 
		DWORD dwExclude = excludeDefaultLoad, TCHAR chSeparator = _T( '|' ) );
	int GetHeight() const throw();
	int GetMaxColorTableEntries() const throw();
	int GetPitch() const throw();
	const void* GetPixelAddress( int x, int y ) const throw();
	void* GetPixelAddress( int x, int y ) throw();
	COLORREF GetPixel( int x, int y ) const throw();
	LONG GetTransparentColor() const throw();
	int GetWidth() const throw();
	bool IsDIBSection() const throw();
	bool IsIndexed() const throw();
	bool IsNull() const throw();
	HRESULT Load( LPCTSTR pszFileName ) throw();
	HRESULT Load( IStream* pStream ) throw();
	void LoadFromResource( HINSTANCE hInstance, LPCTSTR pszResourceName ) throw();
	void LoadFromResource( HINSTANCE hInstance, UINT nIDResource ) throw();
	BOOL MaskBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, 
		int yMask, DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, const RECT& rectDest, const POINT& pointSrc, 
		HBITMAP hbmMask, const POINT& pointMask, DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, int xDest, int yDest, HBITMAP hbmMask, 
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, const POINT& pointDest, HBITMAP hbmMask, 
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, HBITMAP hbmMask = NULL ) const throw();
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, int xSrc, int ySrc, 
		int nSrcWidth, int nSrcHeight, HBITMAP hbmMask = NULL, int xMask = 0, 
		int yMask = 0 ) const throw();
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, const RECT& rectSrc, 
		HBITMAP hbmMask = NULL, const POINT& pointMask = CPoint( 0, 0 ) ) const throw();
	void ReleaseDC() const throw();
	HRESULT Save( IStream* pStream, REFGUID guidFileType ) const throw();
	HRESULT Save( LPCTSTR pszFileName, REFGUID guidFileType = GUID_NULL ) const throw();
	void SetColorTable( UINT iFirstColor, UINT nColors, 
		const RGBQUAD* prgbColors ) throw();
	void SetPixel( int x, int y, COLORREF color ) throw();
	void SetPixelIndexed( int x, int y, int iIndex ) throw();
	void SetPixelRGB( int x, int y, BYTE r, BYTE g, BYTE b ) throw();
	LONG SetTransparentColor( LONG iTransparentColor ) throw();
	BOOL StretchBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, const RECT& rectDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight,
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc,
		DWORD dwROP = SRCCOPY ) const throw();
#if WINVER >= 0x0500
	BOOL TransparentBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, const RECT& rectDest, 
		UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth,
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight,
		UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc,
		UINT crTransparent = CLR_INVALID ) const throw();
#endif  // WINVER >= 0x0500

	static BOOL IsTransparencySupported() throw();

private:
	HBITMAP m_hBitmap;
	void* m_pBits;
	int m_nWidth;
	int m_nHeight;
	int m_nPitch;
	int m_nBPP;
	bool m_bIsDIBSection;
	bool m_bHasAlphaChannel;
	LONG m_iTransparentColor;

	static CInitGDIPlus s_initGDIPlus;

// Implementation
private:
	static CLSID FindCodecForExtension( LPCTSTR pszExtension, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs );
	static CLSID FindCodecForFileType( REFGUID guidFileType, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs );
	static void BuildCodecFilterString( const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs, 
		CSimpleString& strFilter, CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription, DWORD dwExclude, TCHAR chSeparator );
	static bool ShouldExcludeFormat( REFGUID guidFileType, DWORD dwExclude ) throw();
	void UpdateBitmapInfo( DIBOrientation eOrientation );
	HRESULT CreateFromGdiplusBitmap( Gdiplus::Bitmap& bmSrc ) throw();
	
	static bool InitGDIPlus() throw();

	static int ComputePitch( int nWidth, int nBPP )
	{
		return( (((nWidth*nBPP)+31)/32)*4 );
	}
	static void GenerateHalftonePalette( LPRGBQUAD prgbPalette );
	COLORREF GetTransparentRGB() const;

private:
	mutable HDC m_hDC;
	mutable int m_nDCRefCount;
	mutable HBITMAP m_hOldBitmap;

	static CDCCache s_cache;
};

inline CImageDC::CImageDC( const CImage& image ) throw( ... ) :
	m_image( image ),
	m_hDC( image.GetDC() )
{
	if( m_hDC == NULL )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline CImageDC::~CImageDC() throw()
{
	m_image.ReleaseDC();
}

inline CImageDC::operator HDC() const throw()
{
	return( m_hDC );
}

inline CImage::CInitGDIPlus::CInitGDIPlus() throw() :
	m_dwToken( 0 )
{
}

inline CImage::CInitGDIPlus::~CInitGDIPlus() throw()
{
	if( m_dwToken != 0 )
	{
		Gdiplus::GdiplusShutdown( m_dwToken );
	}
}

inline bool CImage::CInitGDIPlus::Init() throw()
{
	if( m_dwToken == 0 )
	{
		Gdiplus::GdiplusStartupInput input;
		Gdiplus::GdiplusStartupOutput output;
		Gdiplus::Status status = Gdiplus::GdiplusStartup( &m_dwToken, &input, &output );
		if( status != Gdiplus::Ok )
		{
			return( false );
		}
	}

	return( true );
}

inline CImage::CDCCache::CDCCache()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		m_ahDCs[iDC] = NULL;
	}
}

inline CImage::CDCCache::~CDCCache()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		if( m_ahDCs[iDC] != NULL )
		{
			::DeleteDC( m_ahDCs[iDC] );
		}
	}
}

inline HDC CImage::CDCCache::GetDC()
{
	HDC hDC;

	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		hDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), NULL ) );
		if( hDC != NULL )
		{
			return( hDC );
		}
	}

	hDC = ::CreateCompatibleDC( NULL );

	return( hDC );
}

inline void CImage::CDCCache::ReleaseDC( HDC hDC )
{
	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		HDC hOldDC;

		hOldDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), hDC ) );
		if( hOldDC == NULL )
		{
			return;
		}
		else
		{
			hDC = hOldDC;
		}
	}
	if( hDC != NULL )
	{
		::DeleteDC( hDC );
	}
}

inline CImage::CImage() :
	m_hBitmap( NULL ),
	m_pBits( NULL ),
	m_hDC( NULL ),
	m_nDCRefCount( 0 ),
	m_hOldBitmap( NULL ),
	m_nWidth( 0 ),
	m_nHeight( 0 ),
	m_nPitch( 0 ),
	m_nBPP( 0 ),
	m_iTransparentColor( -1 ),
	m_bHasAlphaChannel( false ),
	m_bIsDIBSection( false )
{
}

inline CImage::~CImage()
{
	Destroy();
}

inline CImage::operator HBITMAP() const
{
	return( m_hBitmap );
}

#if WINVER >= 0x0500
inline BOOL CImage::AlphaBlend( HDC hDestDC, int xDest, int yDest, 
	BYTE bSrcAlpha, BYTE bBlendOp ) const
{
	return( AlphaBlend( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, 
		m_nWidth, m_nHeight, bSrcAlpha, bBlendOp ) );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, const POINT& pointDest, 
   BYTE bSrcAlpha, BYTE bBlendOp ) const
{
	return( AlphaBlend( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 
		0, 0, m_nWidth, m_nHeight, bSrcAlpha, bBlendOp ) );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, BYTE bSrcAlpha, BYTE bBlendOp ) const
{
	BLENDFUNCTION blend;
	BOOL bResult;

	blend.SourceConstantAlpha = bSrcAlpha;
	blend.BlendOp = bBlendOp;
	blend.BlendFlags = 0;
	if( m_bHasAlphaChannel )
	{
		blend.AlphaFormat = AC_SRC_ALPHA;
	}
	else
	{
		blend.AlphaFormat = 0;
	}

	GetDC();

	bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, 
		xSrc, ySrc, nSrcWidth, nSrcHeight, blend );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, BYTE bSrcAlpha, BYTE bBlendOp ) const
{
	return( AlphaBlend( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, bSrcAlpha, 
		bBlendOp ) );
}
#endif  // WINVER >= 0x0500

inline void CImage::Attach( HBITMAP hBitmap, DIBOrientation eOrientation )
{
	ATLASSERT( m_hBitmap == NULL );
	ATLASSERT( hBitmap != NULL );

	m_hBitmap = hBitmap;

	UpdateBitmapInfo( eOrientation );
}

inline BOOL CImage::BitBlt( HDC hDestDC, int xDest, int yDest, DWORD dwROP ) const
{
	return( BitBlt( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, dwROP ) );
}

inline BOOL CImage::BitBlt( HDC hDestDC, const POINT& pointDest, DWORD dwROP ) const
{
	return( BitBlt( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight,
		0, 0, dwROP ) );
}

inline BOOL CImage::BitBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
	int nDestHeight, int xSrc, int ySrc, DWORD dwROP ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, 
		xSrc, ySrc, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::BitBlt( HDC hDestDC, const RECT& rectDest, 
	const POINT& pointSrc, DWORD dwROP ) const
{
	return( BitBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y, 
		dwROP ) );
}

inline BOOL CImage::Create( int nWidth, int nHeight, int nBPP, DWORD dwFlags ) throw()
{
	return( CreateEx( nWidth, nHeight, nBPP, BI_RGB, NULL, dwFlags ) );
}

inline BOOL CImage::CreateEx( int nWidth, int nHeight, int nBPP, DWORD eCompression, 
	const DWORD* pdwBitfields, DWORD dwFlags ) throw()
{
	LPBITMAPINFO pbmi;
	HBITMAP hBitmap;

	ATLASSERT( (eCompression == BI_RGB) || (eCompression == BI_BITFIELDS) );
	if( dwFlags&createAlphaChannel )
	{
		ATLASSERT( (nBPP == 32) && (eCompression == BI_RGB) );
	}

	pbmi = LPBITMAPINFO( _alloca( sizeof( BITMAPINFO )+256*sizeof( 
	  RGBQUAD ) ) );

	memset( &pbmi->bmiHeader, 0, sizeof( pbmi->bmiHeader ) );
	pbmi->bmiHeader.biSize = sizeof( pbmi->bmiHeader );
	pbmi->bmiHeader.biWidth = nWidth;
	pbmi->bmiHeader.biHeight = nHeight;
	pbmi->bmiHeader.biPlanes = 1;
	pbmi->bmiHeader.biBitCount = USHORT( nBPP );
	pbmi->bmiHeader.biCompression = eCompression;
	if( nBPP <= 8 )
	{
		ATLASSERT( eCompression == BI_RGB );
		memset( pbmi->bmiColors, 0, 256*sizeof( RGBQUAD ) );
	}
	else 
	{
		if( eCompression == BI_BITFIELDS )
		{
			ATLASSERT( pdwBitfields != NULL );
			memcpy( pbmi->bmiColors, pdwBitfields, 3*sizeof( DWORD ) );
		}
	}

	hBitmap = ::CreateDIBSection( NULL, pbmi, DIB_RGB_COLORS, &m_pBits, NULL,
		0 );
	if( hBitmap == NULL )
	{
		return( FALSE );
	}

	Attach( hBitmap, (nHeight < 0) ? DIBOR_TOPDOWN : DIBOR_BOTTOMUP );

	if( dwFlags&createAlphaChannel )
	{
		m_bHasAlphaChannel = true;
	}

	return( TRUE );
}

inline void CImage::Destroy()
{
	HBITMAP hBitmap;

	if( m_hBitmap != NULL )
	{
		hBitmap = Detach();
		::DeleteObject( hBitmap );
	}
}

inline HBITMAP CImage::Detach()
{
	HBITMAP hBitmap;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( m_hDC == NULL );

	hBitmap = m_hBitmap;
	m_hBitmap = NULL;
	m_pBits = NULL;
	m_nWidth = 0;
	m_nHeight = 0;
	m_nBPP = 0;
	m_nPitch = 0;
	m_iTransparentColor = -1;
	m_bHasAlphaChannel = false;
	m_bIsDIBSection = false;

	return( hBitmap );
}

inline BOOL CImage::Draw( HDC hDestDC, const RECT& rectDest ) const
{
	return( Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth, 
		m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, int nDestHeight ) const
{
	return( Draw( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, const POINT& pointDest ) const
{
	return( Draw( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest ) const
{
	return( Draw( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc ) const
{
	return( Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth,
	int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );
	ATLASSERT( nDestWidth > 0 );
	ATLASSERT( nDestHeight > 0 );
	ATLASSERT( nSrcWidth > 0 );
	ATLASSERT( nSrcHeight > 0 );

	GetDC();

#if WINVER >= 0x0500
	if( (m_iTransparentColor != -1) && IsTransparencySupported() )
	{
		bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, GetTransparentRGB() );
	}
	else if( m_bHasAlphaChannel && IsTransparencySupported() )
	{
		BLENDFUNCTION bf;

		bf.BlendOp = AC_SRC_OVER;
		bf.BlendFlags = 0;
		bf.SourceConstantAlpha = 0xff;
		bf.AlphaFormat = AC_SRC_ALPHA;
		bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf );
	}
	else
#endif  // WINVER >= 0x0500
	{
		bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, SRCCOPY );
	}

	ReleaseDC();

	return( bResult );
}

inline const void* CImage::GetBits() const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline void* CImage::GetBits()
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline int CImage::GetBPP() const
{
	ATLASSERT( m_hBitmap != NULL );

	return( m_nBPP );
}

inline void CImage::GetColorTable( UINT iFirstColor, UINT nColors, 
	RGBQUAD* prgbColors ) const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( m_pBits != NULL );
	ATLASSERT( IsIndexed() );

	GetDC();

	::GetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline HDC CImage::GetDC() const
{
	ATLASSERT( m_hBitmap != NULL );

	m_nDCRefCount++;
	if( m_hDC == NULL )
	{
		m_hDC = s_cache.GetDC();
		m_hOldBitmap = HBITMAP( ::SelectObject( m_hDC, m_hBitmap ) );
	}

	return( m_hDC );
}

inline bool CImage::ShouldExcludeFormat( REFGUID guidFileType, DWORD dwExclude ) throw()
{
	static const GUID* apguidFormats[] =
	{
		&Gdiplus::ImageFormatGIF,
		&Gdiplus::ImageFormatBMP,
		&Gdiplus::ImageFormatEMF,
		&Gdiplus::ImageFormatWMF,
		&Gdiplus::ImageFormatJPEG,
		&Gdiplus::ImageFormatPNG,
		&Gdiplus::ImageFormatTIFF,
		&Gdiplus::ImageFormatIcon,
		NULL
	};

	ATLASSERT( (dwExclude|excludeValid) == excludeValid );
	for( int iFormat = 0; apguidFormats[iFormat] != NULL; iFormat++ )
	{
		if( guidFileType == *apguidFormats[iFormat] )
		{
			return( (dwExclude&(1<<iFormat)) != 0 );
		}
	}

	return( (dwExclude&excludeOther) != 0 );
}

inline void CImage::BuildCodecFilterString( const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs,
	CSimpleString& strFilter, CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription, 
	DWORD dwExclude, TCHAR chSeparator )
{
	USES_CONVERSION;

	if( pszAllFilesDescription != NULL )
	{
		aguidFileTypes.Add( GUID_NULL );
	}

	CString strAllExtensions;
	CString strTempFilter;
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		const Gdiplus::ImageCodecInfo* pCodec = &pCodecs[iCodec];

		if( !ShouldExcludeFormat( pCodec->FormatID, dwExclude ) )
		{
			strTempFilter += CW2CT( pCodec->FormatDescription );
			strTempFilter += _T( " (" );
			strTempFilter += CW2CT( pCodec->FilenameExtension );
			strTempFilter += _T( ")" );
			strTempFilter += chSeparator;
			strTempFilter += CW2CT( pCodec->FilenameExtension );
			strTempFilter += chSeparator;

			aguidFileTypes.Add( pCodec->FormatID );

			if( !strAllExtensions.IsEmpty() )
			{
				strAllExtensions += _T( ";" );
			}
			strAllExtensions += CW2CT( pCodec->FilenameExtension );
		}
	}

	if( pszAllFilesDescription != NULL )
	{
		strFilter += pszAllFilesDescription;
		strFilter += chSeparator;
		strFilter += strAllExtensions;
		strFilter += chSeparator;
	}
	strFilter += strTempFilter;

	strFilter += chSeparator;
	if( aguidFileTypes.GetSize() == 0 )
	{
		strFilter += chSeparator;
	}
}

inline HRESULT CImage::GetImporterFilterString( CSimpleString& strImporters, 
	CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription /* = NULL */,
	DWORD dwExclude /* = excludeDefaultLoad */, TCHAR chSeparator /* = '|' */ )
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _alloca( nSize ) );

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strImporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

inline HRESULT CImage::GetExporterFilterString( CSimpleString& strExporters, 
	CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription /* = NULL */,
	DWORD dwExclude /* = excludeDefaultSave */, TCHAR chSeparator /* = '|' */ )
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _alloca( nSize ) );

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strExporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

inline int CImage::GetHeight() const
{
	ATLASSERT( m_hBitmap != NULL );

	return( m_nHeight );
}

inline int CImage::GetMaxColorTableEntries() const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	if( IsIndexed() )
	{
		return( 1<<m_nBPP );
	}
	else
	{
		return( 0 );
	}
}

inline int CImage::GetPitch() const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nPitch );
}

inline COLORREF CImage::GetPixel( int x, int y ) const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	COLORREF clr = ::GetPixel( m_hDC, x, y );

	ReleaseDC();

	return( clr );
}

inline const void* CImage::GetPixelAddress( int x, int y ) const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

inline void* CImage::GetPixelAddress( int x, int y )
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

inline LONG CImage::GetTransparentColor() const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );

	return( m_iTransparentColor );
}

inline int CImage::GetWidth() const
{
	ATLASSERT( m_hBitmap != NULL );

	return( m_nWidth );
}

inline bool CImage::IsDIBSection() const
{
	return( m_bIsDIBSection );
}

inline bool CImage::IsIndexed() const
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nBPP <= 8 );
}

inline bool CImage::IsNull() const throw()
{
	return( m_hBitmap == NULL );
}

inline HRESULT CImage::Load( IStream* pStream ) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( pStream );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::Load( LPCTSTR pszFileName ) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( (CT2W)pszFileName );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::CreateFromGdiplusBitmap( Gdiplus::Bitmap& bmSrc ) throw()
{
	Gdiplus::PixelFormat eSrcPixelFormat = bmSrc.GetPixelFormat();
	UINT nBPP = 32;
	DWORD dwFlags = 0;
	Gdiplus::PixelFormat eDestPixelFormat = PixelFormat32bppRGB;
	if( eSrcPixelFormat&PixelFormatGDI )
	{
		nBPP = Gdiplus::GetPixelFormatSize( eSrcPixelFormat );
		eDestPixelFormat = eSrcPixelFormat;
	}
	if( Gdiplus::IsAlphaPixelFormat( eSrcPixelFormat ) )
	{
		nBPP = 32;
		dwFlags |= createAlphaChannel;
		eDestPixelFormat = PixelFormat32bppARGB;
	}

	BOOL bSuccess = Create( bmSrc.GetWidth(), bmSrc.GetHeight(), nBPP, dwFlags );
	if( !bSuccess )
	{
		return( E_FAIL );
	}
	Gdiplus::ColorPalette* pPalette = NULL;
	if( Gdiplus::IsIndexedPixelFormat( eSrcPixelFormat ) )
	{
		UINT nPaletteSize = bmSrc.GetPaletteSize();

		pPalette = static_cast< Gdiplus::ColorPalette* >( _alloca( nPaletteSize ) );
		bmSrc.GetPalette( pPalette, nPaletteSize );

		RGBQUAD argbPalette[256];
		ATLASSERT( (pPalette->Count > 0) && (pPalette->Count <= 256) );
		for( UINT iColor = 0; iColor < pPalette->Count; iColor++ )
		{
			Gdiplus::ARGB color = pPalette->Entries[iColor];
			argbPalette[iColor].rgbRed = BYTE( color>>RED_SHIFT );
			argbPalette[iColor].rgbGreen = BYTE( color>>GREEN_SHIFT );
			argbPalette[iColor].rgbBlue = BYTE( color>>BLUE_SHIFT );
			argbPalette[iColor].rgbReserved = 0;
		}

		SetColorTable( 0, pPalette->Count, argbPalette );
	}

	if( eDestPixelFormat == eSrcPixelFormat )
	{
		// The pixel formats are identical, so just memcpy the rows.
		Gdiplus::BitmapData data;
		bmSrc.LockBits( Gdiplus::Rect( 0, 0, GetWidth(), GetHeight() ), Gdiplus::ImageLockModeRead, eSrcPixelFormat, &data );

		UINT nBytesPerRow = AtlAlignUp( nBPP*GetWidth(), 8 )/8;
		BYTE* pbDestRow = static_cast< BYTE* >( GetBits() );
		BYTE* pbSrcRow = static_cast< BYTE* >( data.Scan0 );
		for( int y = 0; y < GetHeight(); y++ )
		{
			memcpy( pbDestRow, pbSrcRow, nBytesPerRow );
			pbDestRow += GetPitch();
			pbSrcRow += data.Stride;
		}

		bmSrc.UnlockBits( &data );
	}
	else
	{
		// Let GDI+ work its magic
		Gdiplus::Bitmap bmDest( GetWidth(), GetHeight(), GetPitch(), eDestPixelFormat, static_cast< BYTE* >( GetBits() ) );
		Gdiplus::Graphics gDest( &bmDest );

		gDest.DrawImage( &bmSrc, 0, 0 );
	}

	return( S_OK );
}

inline void CImage::LoadFromResource( HINSTANCE hInstance, LPCTSTR pszResourceName )
{
	HBITMAP hBitmap;

	hBitmap = HBITMAP( ::LoadImage( hInstance, pszResourceName, IMAGE_BITMAP, 0, 
		0, LR_CREATEDIBSECTION ) );

	Attach( hBitmap );
}

inline void CImage::LoadFromResource( HINSTANCE hInstance, UINT nIDResource )
{
	LoadFromResource( hInstance, MAKEINTRESOURCE( nIDResource ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, int xDest, int yDest, int nWidth, 
	int nHeight, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask,
	DWORD dwROP ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::MaskBlt( hDestDC, xDest, yDest, nWidth, nHeight, m_hDC, xSrc, 
		ySrc, hbmMask, xMask, yMask, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, const RECT& rectDest, 
	const POINT& pointSrc, HBITMAP hbmMask, const POINT& pointMask, 
	DWORD dwROP ) const
{
	return( MaskBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y, 
		hbmMask, pointMask.x, pointMask.y, dwROP ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, int xDest, int yDest, HBITMAP hbmMask, 
	DWORD dwROP ) const
{
	return( MaskBlt( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, hbmMask, 
		0, 0, dwROP ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, const POINT& pointDest, HBITMAP hbmMask,
	DWORD dwROP ) const
{
	return( MaskBlt( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 
		0, hbmMask, 0, 0, dwROP ) );
}

inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, int xSrc, 
	int ySrc, int nSrcWidth, int nSrcHeight, HBITMAP hbmMask, int xMask, 
	int yMask ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::PlgBlt( hDestDC, pPoints, m_hDC, xSrc, ySrc, nSrcWidth, 
		nSrcHeight, hbmMask, xMask, yMask );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, 
	const RECT& rectSrc, HBITMAP hbmMask, const POINT& pointMask ) const
{
	return( PlgBlt( hDestDC, pPoints, rectSrc.left, rectSrc.top, rectSrc.right-
		rectSrc.left, rectSrc.bottom-rectSrc.top, hbmMask, pointMask.x, 
		pointMask.y ) );
}

inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, 
	HBITMAP hbmMask ) const
{
	return( PlgBlt( hDestDC, pPoints, 0, 0, m_nWidth, m_nHeight, hbmMask, 0, 
		0 ) );
}

inline void CImage::ReleaseDC() const
{
	HBITMAP hBitmap;

	ATLASSERT( m_hDC != NULL );

	m_nDCRefCount--;
	if( m_nDCRefCount == 0 )
	{
		hBitmap = HBITMAP( ::SelectObject( m_hDC, m_hOldBitmap ) );
		ATLASSERT( hBitmap == m_hBitmap );
		s_cache.ReleaseDC( m_hDC );
		m_hDC = NULL;
	}
}

inline CLSID CImage::FindCodecForExtension( LPCTSTR pszExtension, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs )
{
	CT2CW pszExtensionW( pszExtension );

	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		CStringW strExtensions( pCodecs[iCodec].FilenameExtension );

		int iStart = 0;
		do
		{
			CStringW strExtension = ::PathFindExtensionW( strExtensions.Tokenize( L";", iStart ) );
			if( iStart != -1 )
			{
				if( strExtension.CompareNoCase( pszExtensionW ) == 0 )
				{
					return( pCodecs[iCodec].Clsid );
				}
			}
		} while( iStart != -1 );
	}

	return( CLSID_NULL );
}

inline CLSID CImage::FindCodecForFileType( REFGUID guidFileType, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs )
{
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		if( pCodecs[iCodec].FormatID == guidFileType )
		{
			return( pCodecs[iCodec].Clsid );
		}
	}

	return( CLSID_NULL );
}

inline HRESULT CImage::Save( IStream* pStream, REFGUID guidFileType ) const
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	USES_CONVERSION;
	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _alloca( nBytes ) );
	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	if( m_bHasAlphaChannel )
	{
		ATLASSERT( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

inline HRESULT CImage::Save( LPCTSTR pszFileName, REFGUID guidFileType ) const
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	USES_CONVERSION;
	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _alloca( nBytes ) );
	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = CLSID_NULL;
	if( guidFileType == GUID_NULL )
	{
		// Determine clsid from extension
		clsidEncoder = FindCodecForExtension( ::PathFindExtension( pszFileName ), pEncoders, nEncoders );
	}
	else
	{
		// Determine clsid from file type
		clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	}
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	if( m_bHasAlphaChannel )
	{
		ATLASSERT( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( T2CW( pszFileName ), &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( T2CW( pszFileName ), &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

inline void CImage::SetColorTable( UINT iFirstColor, UINT nColors, 
	const RGBQUAD* prgbColors )
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( IsIndexed() );

	GetDC();

	::SetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline void CImage::SetPixel( int x, int y, COLORREF color )
{
	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	::SetPixel( m_hDC, x, y, color );

	ReleaseDC();
}

inline void CImage::SetPixelIndexed( int x, int y, int iIndex )
{
	SetPixel( x, y, PALETTEINDEX( iIndex ) );
}

inline void CImage::SetPixelRGB( int x, int y, BYTE r, BYTE g, BYTE b )
{
	SetPixel( x, y, RGB( r, g, b ) );
}

inline LONG CImage::SetTransparentColor( LONG iTransparentColor )
{
	LONG iOldTransparentColor;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );
	ATLASSERT( iTransparentColor < GetMaxColorTableEntries() );
	ATLASSERT( iTransparentColor >= -1 );

	iOldTransparentColor = m_iTransparentColor;
	m_iTransparentColor = iTransparentColor;

	return( iOldTransparentColor );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, DWORD dwROP ) const
{
	return( StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0, 
		m_nWidth, m_nHeight, dwROP ) );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, const RECT& rectDest, 
	DWORD dwROP ) const
{
	return( StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth, m_nHeight, 
		dwROP ) );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, DWORD dwROP ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC,
		xSrc, ySrc, nSrcWidth, nSrcHeight, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, DWORD dwROP ) const
{
	return( StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, dwROP ) );
}

#if WINVER >= 0x0500
inline BOOL CImage::TransparentBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, UINT crTransparent ) const
{
	return( TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 
		0, m_nWidth, m_nHeight, crTransparent ) );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, const RECT& rectDest, 
	UINT crTransparent ) const
{
	return( TransparentBlt( hDestDC, rectDest.left, rectDest.top, 
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, 
		crTransparent ) );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, UINT crTransparent ) const
{
	BOOL bResult;

	ATLASSERT( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	if( crTransparent == CLR_INVALID )
	{
		crTransparent = GetTransparentRGB();
	}

	bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
		m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, UINT crTransparent ) const
{
	return( TransparentBlt( hDestDC, rectDest.left, rectDest.top, 
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, 
		rectSrc.top, rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, 
		crTransparent ) );
}
#endif  // WINVER >= 0x0500

inline BOOL CImage::IsTransparencySupported()
{
#if WINVER >= 0x0500
	return( _AtlBaseModule.m_bNT5orWin98 );
#else  // WINVER < 0x0500
	return( FALSE );
#endif  // WINVER >= 0x0500
}

inline void CImage::UpdateBitmapInfo( DIBOrientation eOrientation )
{
	DIBSECTION dibsection;
	int nBytes;

	nBytes = ::GetObject( m_hBitmap, sizeof( DIBSECTION ), &dibsection );
	if( nBytes == sizeof( DIBSECTION ) )
	{
		m_bIsDIBSection = true;
		m_nWidth = dibsection.dsBmih.biWidth;
		m_nHeight = abs( dibsection.dsBmih.biHeight );
		m_nBPP = dibsection.dsBmih.biBitCount;
		m_nPitch = ComputePitch( m_nWidth, m_nBPP );
		m_pBits = dibsection.dsBm.bmBits;
		if( eOrientation == DIBOR_DEFAULT )
		{
			eOrientation = (dibsection.dsBmih.biHeight > 0) ? DIBOR_BOTTOMUP : DIBOR_TOPDOWN;
		}
		if( eOrientation == DIBOR_BOTTOMUP )
		{
			m_pBits = LPBYTE( m_pBits )+((m_nHeight-1)*m_nPitch);
			m_nPitch = -m_nPitch;
		}
	}
	else
	{
		// Non-DIBSection
		ATLASSERT( nBytes == sizeof( BITMAP ) );
		m_bIsDIBSection = false;
		m_nWidth = dibsection.dsBm.bmWidth;
		m_nHeight = dibsection.dsBm.bmHeight;
		m_nBPP = dibsection.dsBm.bmBitsPixel;
		m_nPitch = 0;
		m_pBits = 0;
	}
	m_iTransparentColor = -1;
	m_bHasAlphaChannel = false;
}

inline void CImage::GenerateHalftonePalette( LPRGBQUAD prgbPalette )
{
	int r;
	int g;
	int b;
	int gray;
	LPRGBQUAD prgbEntry;

	prgbEntry = prgbPalette;
	for( r = 0; r < 6; r++ )
	{
		for( g = 0; g < 6; g++ )
		{
			for( b = 0; b < 6; b++ )
			{
				prgbEntry->rgbBlue = BYTE( b*255/5 );
				prgbEntry->rgbGreen = BYTE( g*255/5 );
				prgbEntry->rgbRed = BYTE( r*255/5 );
				prgbEntry->rgbReserved = 0;

				prgbEntry++;
			}
		}
	}

	for( gray = 0; gray < 20; gray++ )
	{
		prgbEntry->rgbBlue = BYTE( gray*255/20 );
		prgbEntry->rgbGreen = BYTE( gray*255/20 );
		prgbEntry->rgbRed = BYTE( gray*255/20 );
		prgbEntry->rgbReserved = 0;

		prgbEntry++;
	}
}

inline COLORREF CImage::GetTransparentRGB() const
{
	RGBQUAD rgb;

	ATLASSERT( m_hDC != NULL );  // Must have a DC
	ATLASSERT( m_iTransparentColor != -1 );

	::GetDIBColorTable( m_hDC, m_iTransparentColor, 1, &rgb );

	return( RGB( rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue ) );
}

inline bool CImage::InitGDIPlus() throw()
{
	static bool bSuccess = s_initGDIPlus.Init();

	return( bSuccess );
}

};  // namespace ATL

#pragma pack(pop)

#endif  // __ATLIMAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlperf.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPERF_H__
#define __ATLPERF_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <atlfile.h>
#include <atlsync.h>
#include <winperf.h>
#include <atlcoll.h>

#ifndef _ATL_PERF_NOXML
#include <atlenc.h>
#include <oaidl.h>
#include <xmldomdid.h>
#include <xmldsodid.h>
#include <msxmldid.h>
#include <msxml.h>
#endif

namespace ATL
{

const DWORD ATLPERF_SIZE_MASK = 0x00000300;
const DWORD ATLPERF_TYPE_MASK = 0x00000C00;
const DWORD ATLPERF_TEXT_MASK = 0x00010000;

#ifndef ATLPERF_DEFAULT_MAXINSTNAMELENGTH
#define ATLPERF_DEFAULT_MAXINSTNAMELENGTH 64
#endif

// base class for user-defined perf objects
struct CPerfObject
{
	ULONG m_nAllocSize;
	DWORD m_dwObjectId;
	DWORD m_dwInstance;
	ULONG m_nRefCount;
	ULONG m_nInstanceNameOffset; // byte offset from beginning of PerfObject to LPWSTR szInstanceName
};

struct CPerfMapEntry
{
	DWORD m_dwPerfId;
	CString m_strName;
	CString m_strHelp;
	DWORD m_dwDetailLevel;
	BOOL m_bIsObject;

	// OBJECT INFO
	ULONG m_nNumCounters;
	LONG m_nDefaultCounter;
	LONG m_nInstanceLess; // PERF_NO_INSTANCES if instanceless
	
	// the size of the struct not counting the name and string counters
	ULONG m_nStructSize;
	
	 // in characters including the null terminator
	ULONG m_nMaxInstanceNameLen;

	ULONG m_nAllocSize;

	// COUNTER INFO
	DWORD m_dwCounterType;
	LONG m_nDefaultScale;

	// the maximum size of the string counter data in characters, including the null terminator
	// ignored if not a string counter
	ULONG m_nMaxCounterSize;

	ULONG m_nDataOffset;

	// the ids that correspond to the name and help strings stored in the registry
	UINT m_nNameId;
	UINT m_nHelpId;
};

class CPerfMon
{
public:
	~CPerfMon() throw();

	// PerfMon entry point helpers
	DWORD Open(LPWSTR lpDeviceNames) throw();
	DWORD Collect(LPWSTR lpwszValue, LPVOID* lppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes) throw();
	DWORD Close() throw();

#ifdef _ATL_PERF_REGISTER
	// registration
	HRESULT Register(
		LPCTSTR szOpenFunc,
		LPCTSTR szCollectFunc,
		LPCTSTR szCloseFunc,
		HINSTANCE hDllInstance = _AtlBaseModule.GetModuleInstance()) throw();
	HRESULT RegisterStrings(
		LANGID wLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
		HINSTANCE hResInstance = _AtlBaseModule.GetResourceInstance()) throw();
	HRESULT RegisterAllStrings(HINSTANCE hResInstance = NULL) throw();
	HRESULT Unregister() throw();

	static BOOL CALLBACK EnumResLangProc(HINSTANCE hModule, LPCTSTR szType, LPCTSTR szName, LANGID wIDLanguage, LPARAM lParam);
#endif

	HRESULT Initialize() throw();
	void UnInitialize() throw();
	HRESULT CreateInstance(
		DWORD dwObjectId,
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance) throw();
	HRESULT CreateInstanceByName(
		DWORD dwObjectId,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance) throw();

	template <class T>
	HRESULT CreateInstance(
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		T** ppInstance) throw()
	{
		// Ensure T derives from CPerfObject
		static_cast<CPerfObject*>(*ppInstance);
		
		return CreateInstance(
			T::kObjectId,
			dwInstance,
			szInstanceName,
			reinterpret_cast<CPerfObject**>(ppInstance)
			);
	}

	template <class T>
	HRESULT CreateInstanceByName(
		LPCWSTR szInstanceName,
		T** ppInstance) throw()
	{
		// Ensure T derives from CPerfObject
		static_cast<CPerfObject*>(*ppInstance);
		
		return CreateInstanceByName(
			T::kObjectId,
			szInstanceName,
			reinterpret_cast<CPerfObject**>(ppInstance)
			);
	}

	HRESULT ReleaseInstance(CPerfObject* pInstance) throw();
	HRESULT LockPerf(DWORD dwTimeout = INFINITE) throw();
	void UnlockPerf() throw();

	// map building routines
	HRESULT AddObjectDefinition(
		DWORD dwObjectId,
		LPCTSTR szObjectName,
		LPCTSTR szHelpString,
		DWORD dwDetailLevel,
		INT nDefaultCounter,
		BOOL bInstanceLess,
		UINT nStructSize,
		UINT nMaxInstanceNameLen = ATLPERF_DEFAULT_MAXINSTNAMELENGTH) throw();
	HRESULT AddCounterDefinition(
		DWORD dwCounterId,
		LPCTSTR szCounterName,
		LPCTSTR szHelpString,
		DWORD dwDetailLevel,
		DWORD dwCounterType,
		ULONG nMaxCounterSize,
		UINT nOffset,
		INT nDefaultScale) throw();
	void ClearMap() throw();

#ifndef _ATL_PERF_NOXML
	HRESULT PersistToXML(IStream *pStream, BOOL bFirst=TRUE, BOOL bLast=TRUE) throw(...);
	HRESULT LoadFromXML(IStream *pStream) throw(...);
#endif

protected:
	virtual LPCTSTR GetAppName() const throw() = 0;
	virtual HRESULT CreateMap(WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes = NULL) throw();
	virtual void OnBlockAlloc(CAtlFileMappingBase* /*pNewBlock*/) { }

	// implementation helpers
	LPBYTE _AllocData(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, size_t nBytesNeeded) throw();
	template<typename T> T* _AllocStruct(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, T*) throw()
	{
		return reinterpret_cast<T*>(_AllocData(pData, nBytesAvail, pnBytesUsed, sizeof(T)));
	}

	CPerfMapEntry& _GetMapEntry(UINT nIndex) throw();
	UINT _GetNumMapEntries() throw();
	CPerfObject* _GetFirstObject(CAtlFileMappingBase* pBlock) throw();
	CPerfObject* _GetNextObject(CPerfObject* pInstance) throw();
	CAtlFileMappingBase* _GetNextBlock(CAtlFileMappingBase* pBlock) throw();
	CAtlFileMappingBase* _AllocNewBlock(CAtlFileMappingBase* pPrev, BOOL* pbExisted = NULL) throw();
	DWORD& _GetBlockId(CAtlFileMappingBase* pBlock) throw();
	CPerfMapEntry* _FindObjectInfo(DWORD dwObjectId) throw();
	CPerfMapEntry* _FindCounterInfo(CPerfMapEntry* pObjectEntry, DWORD dwCounterId) throw();
	CPerfMapEntry* _FindCounterInfo(DWORD dwObjectId, DWORD dwCounterId) throw();
	BOOL _WantObjectType(LPWSTR lpwszValue, DWORD dwPerfId) throw(...);
	void _FillObjectType(PERF_OBJECT_TYPE* pObjectType, CPerfMapEntry* pObjectEntry) throw();
	void _FillCounterDef(
		PERF_COUNTER_DEFINITION* pCounterDef,
		CPerfMapEntry* pCounterEntry,
		ULONG& nCBSize) throw();
	HRESULT _CollectObjectType(
		CPerfMapEntry* pObjectEntry,
		LPBYTE pData,
		ULONG nBytesAvail,
		ULONG* pnBytesUsed) throw();
	HRESULT _LoadMap() throw();
	HRESULT _SaveMap() throw();
	HRESULT _GetAttribute(
		IXMLDOMNode *pNode, 
		LPCWSTR szAttrName, 
		BSTR *pbstrVal) throw();
	HRESULT CPerfMon::_CreateInstance(
		DWORD dwObjectId,
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance,
		bool bByName) throw();

#ifdef _ATL_PERF_REGISTER
	void _AppendStrings(
		LPTSTR& pszNew,
		CAtlArray<CString>& astrStrings,
		ULONG iFirstIndex
		) throw();
	HRESULT _AppendRegStrings(
		CRegKey& rkLang,
		LPCTSTR szValue,
		CAtlArray<CString>& astrStrings,
		ULONG nNewStringSize,
		ULONG iFirstIndex,
		ULONG iLastIndex) throw();
	HRESULT _RemoveRegStrings(
		CRegKey& rkLang,
		LPCTSTR szValue,
		ULONG iFirstIndex,
		ULONG iLastIndex) throw();
	HRESULT _ReserveStringRange(DWORD& dwFirstCounter, DWORD& dwFirstHelp) throw();
	HRESULT _UnregisterStrings() throw();
	HRESULT _RegisterAllStrings(UINT nRes, HINSTANCE hResInstance) throw();
#endif
private:
	CAtlArray<CPerfMapEntry> m_map;
	CAutoPtrArray<CAtlFileMappingBase> m_aMem;
	CMutex m_lock;
	ULONG m_nAllocSize;
	ULONG m_nHeaderSize;
	ULONG m_nSchemaSize;
	ULONG m_nNumObjectTypes;
};

class CPerfLock
{
public:
	CPerfLock(CPerfMon* pPerfMon, DWORD dwTimeout = INFINITE) throw()
	{
		ATLASSERT(pPerfMon != NULL);
		m_pPerfMon = pPerfMon;
		m_hrStatus = m_pPerfMon->LockPerf(dwTimeout);
	}

	~CPerfLock() throw()
	{
		if (SUCCEEDED(m_hrStatus))
			m_pPerfMon->UnlockPerf();
	}

	HRESULT GetStatus() const throw()
	{
		return m_hrStatus;
	}

private:
	CPerfMon* m_pPerfMon;
	HRESULT m_hrStatus;
};

// empty definition just for ease of use with code wizards, etc.
#define BEGIN_PERFREG_MAP()

// empty definition just for ease of use with code wizards, etc.
#define END_PERFREG_MAP()

#if !defined(_ATL_PERF_REGISTER) | defined(_ATL_PERF_NOEXPORT)
#define PERFREG_ENTRY(className)
#endif

#ifdef _ATL_PERF_REGISTER
#define BEGIN_PERF_MAP(AppName) \
	private: \
		LPCTSTR GetAppName() const throw() { return AppName; } \
		HRESULT CreateMap(WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes = NULL) throw() \
		{ \
			CPerfMon* pPerf = this; \
			wLanguage; \
			hResInstance; \
			if (pSampleRes) \
				*pSampleRes = 0; \
			CString strName; \
			CString strHelp; \
			HRESULT hr; \
			ClearMap();

#define BEGIN_COUNTER_MAP(objectclass) \
	public: \
		typedef objectclass _PerfCounterClass; \
		static HRESULT CreateMap(CPerfMon* pPerf, WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes) throw() \
		{ \
			wLanguage; \
			hResInstance; \
			pSampleRes; \
			CString strName; \
			CString strHelp; \
			HRESULT hr; \
			hr = RegisterObject(pPerf, wLanguage, hResInstance, pSampleRes); \
			if (FAILED(hr)) \
				return hr;

#define DECLARE_PERF_OBJECT_EX(dwObjectId, namestring, helpstring, detail, instanceless, structsize, maxinstnamelen, defcounter) \
		static HRESULT RegisterObject(CPerfMon* pPerf, WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes) throw() \
		{ \
			CString strName; \
			CString strHelp; \
			HRESULT hr; \
			_ATLTRY \
			{ \
				if (IS_INTRESOURCE(namestring)) \
				{ \
					ATLASSERT(IS_INTRESOURCE(helpstring)); \
					if (pSampleRes) \
						*pSampleRes = (UINT) (UINT_PTR) namestring; \
					if (hResInstance && !strName.LoadString(hResInstance, (UINT) (UINT_PTR) namestring, wLanguage)) \
						return E_FAIL; \
					if (hResInstance && !strHelp.LoadString(hResInstance, (UINT) (UINT_PTR) helpstring, wLanguage)) \
						return E_FAIL; \
				} \
				else \
				{ \
					ATLASSERT(!IS_INTRESOURCE(helpstring)); \
					strName = (LPCTSTR) namestring; \
					strHelp = (LPCTSTR) helpstring; \
				} \
			} \
			_ATLCATCHALL() \
			{ \
				return E_FAIL; \
			} \
			hr = pPerf->AddObjectDefinition(dwObjectId, strName, strHelp, detail, defcounter, instanceless, (ULONG) structsize, maxinstnamelen); \
			if (FAILED(hr)) \
				return hr; \
			return S_OK; \
		} \
		/* NOTE: put a semicolon after your call to DECLARE_PERF_OBJECT*(...) */ \
		/* this is needed for the code wizards to parse things properly */ \
		static const DWORD kObjectId = dwObjectId

#define CHAIN_PERF_OBJECT(objectclass) \
			hr = objectclass::CreateMap(pPerf, wLanguage, hResInstance, pSampleRes); \
			if (FAILED(hr)) \
				return hr;

// CAssertValidField ensures that the member variable that's being passed to
// DEFINE_COUNTER[_EX] is the proper type. only 32-bit integral types can be used with
// PERF_SIZE_DWORD and only 64-bit integral types can be used with PERF_SIZE_LARGE
template< DWORD t_dwSize >
class CAssertValidField
{
};

template<>
class CAssertValidField< PERF_SIZE_DWORD >
{
public:
	template< class C > static void AssertValidFieldType( ULONG C::* ) throw() { }
	template< class C > static void AssertValidFieldType( LONG C::* ) throw() { }
};

template<>
class CAssertValidField< PERF_SIZE_LARGE >
{
public:
	template< class C > static void AssertValidFieldType( ULONGLONG C::* p ) throw() { }
	template< class C > static void AssertValidFieldType( LONGLONG C::* p ) throw() { }
};

#define DEFINE_COUNTER_EX(member, dwCounterId, namestring, helpstring, detail, countertype, maxcountersize, defscale) \
			CAssertValidField< (countertype) & ATLPERF_SIZE_MASK >::AssertValidFieldType( &_PerfCounterClass::member ); \
			_ATLTRY \
			{ \
				if (IS_INTRESOURCE(namestring)) \
				{ \
					ATLASSERT(IS_INTRESOURCE(helpstring)); \
					if (hResInstance && !strName.LoadString(hResInstance, (UINT) (UINT_PTR) namestring, wLanguage)) \
						return E_FAIL; \
					if (hResInstance && !strHelp.LoadString(hResInstance, (UINT) (UINT_PTR) helpstring, wLanguage)) \
						return E_FAIL; \
				} \
				else \
				{ \
					ATLASSERT(!IS_INTRESOURCE(helpstring)); \
					strName = (LPCTSTR) namestring; \
					strHelp = (LPCTSTR) helpstring; \
				} \
			} \
			_ATLCATCHALL() \
			{ \
				return E_FAIL; \
			} \
			hr = pPerf->AddCounterDefinition(dwCounterId, strName, strHelp, detail, countertype, maxcountersize, (ULONG) offsetof(_PerfCounterClass, member), defscale); \
			if (FAILED(hr)) \
				return hr;

#define END_PERF_MAP() \
			return S_OK; \
		}

#define END_COUNTER_MAP() \
			return S_OK; \
		}

// define _ATL_PERF_NOEXPORT if you don't want to use the PERFREG map and don't want these
// functions exported from your DLL
#ifndef _ATL_PERF_NOEXPORT

// Perf register map stuff
// this is for ease of integration with the module attribute and for the 
// perfmon wizard

#pragma data_seg(push)
#pragma data_seg("ATLP$A")
__declspec(selectany) CPerfMon * __pperfA = NULL;
#pragma data_seg("ATLP$Z") 
__declspec(selectany) CPerfMon * __pperfZ = NULL;
#pragma data_seg("ATLP$C")
#pragma data_seg(pop)

ATL_NOINLINE inline HRESULT RegisterPerfMon(HINSTANCE hDllInstance = _AtlBaseModule.GetModuleInstance()) throw() 
{
	CPerfMon **ppPerf = &__pperfA; 
	HRESULT hr = S_OK; 
	while (ppPerf != &__pperfZ) 
	{ 
		if (*ppPerf != NULL) 
		{ 
			hr = (*ppPerf)->Register(_T("_OpenPerfMon"), _T("_CollectPerfMon"), _T("_ClosePerfMon"), hDllInstance);
			if (FAILED(hr)) 
				return hr; 
			hr = (*ppPerf)->RegisterAllStrings(hDllInstance);
			if (FAILED(hr)) 
				return hr; 
		} 
		ppPerf++; 
	} 
	return S_OK; 
} 

ATL_NOINLINE inline HRESULT UnregisterPerfMon() throw() 
{ 
	CPerfMon **ppPerf = &__pperfA; 
	HRESULT hr = S_OK; 
	while (ppPerf != &__pperfZ) 
	{ 
		if (*ppPerf != NULL) 
		{ 
			hr = (*ppPerf)->Unregister(); 
			if (FAILED(hr)) 
				return hr; 
		} 
		ppPerf++; 
	} 
	return S_OK; 
} 

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI OpenPerfMon(LPWSTR lpDeviceNames) throw()
{
	CPerfMon **ppPerf = &__pperfA;
	DWORD dwErr = 0;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			dwErr = (*ppPerf)->Open(lpDeviceNames);
			if (dwErr != 0)
				return dwErr;
		}
		ppPerf++;
	}
	return 0;
}

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI CollectPerfMon(LPWSTR lpwszValue, LPVOID* lppData,
	LPDWORD lpcbBytes, LPDWORD lpcObjectTypes) throw()
{
	DWORD dwOrigBytes = *lpcbBytes;
	DWORD dwBytesRemaining = *lpcbBytes;
	CPerfMon **ppPerf = &__pperfA;
	DWORD dwErr = 0;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			dwErr = (*ppPerf)->Collect(lpwszValue, lppData, lpcbBytes, lpcObjectTypes);
			if (dwErr != 0)
				return dwErr;
			dwBytesRemaining -= *lpcbBytes;
			*lpcbBytes = dwBytesRemaining;
		}
		ppPerf++;
	}
	*lpcbBytes = dwOrigBytes - dwBytesRemaining;
	return 0;
}

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI ClosePerfMon() throw()
{
	CPerfMon **ppPerf = &__pperfA;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			(*ppPerf)->Close();
		}
		ppPerf++;
	}
	return 0;
}

// this class handles integrating the registration with CComModule
class _CAtlPerfSetFuncPtr
{
public:
	_CAtlPerfSetFuncPtr()
	{
		_pPerfRegFunc = RegisterPerfMon;
		_pPerfUnRegFunc = UnregisterPerfMon;
	}
};

extern "C" { __declspec(selectany) _CAtlPerfSetFuncPtr g_atlperfinit; }
#pragma comment(linker, "/INCLUDE:_g_atlperfinit")

#if defined(_M_IX86)
#define PERF_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:___pperf_" #class))
#elif defined(_M_IA64)
#define PERF_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pperf_" #class))
#else
#error Unknown Platform. define PERF_ENTRY_PRAGMA
#endif

#define PERFREG_ENTRY(className) \
	className __perf_##className; \
	extern "C" __declspec(allocate("ATLP$C")) CPerfMon * __pperf_##className = \
		static_cast<CPerfMon*>(&__perf_##className); \
	PERF_ENTRY_PRAGMA(className)

#endif // _ATL_PERF_NOEXPORT

#else // _ATL_PERF_REGISTER

#define BEGIN_PERF_MAP(AppName) \
	private: \
		LPCTSTR GetAppName() const throw() { return AppName; }
#define BEGIN_COUNTER_MAP(objectclass)

#define DECLARE_PERF_OBJECT_EX(dwObjectId, namestring, helpstring, detail, instanceless, structsize, maxinstnamelen, defcounter) \
		/* NOTE: put a semicolon after your call to DECLARE_PERF_OBJECT*(...) */ \
		/* this is needed for the code wizards to parse things properly */ \
		static const DWORD kObjectId = dwObjectId
#define CHAIN_PERF_OBJECT(objectclass)
#define DEFINE_COUNTER_EX(member, dwCounterId, namestring, helpstring, detail, countertype, maxcountersize, defscale)

#define END_PERF_MAP()
#define END_COUNTER_MAP()

#endif // _ATL_PERF_REGISTER

#define DECLARE_PERF_OBJECT(objectclass, dwObjectId, namestring, helpstring, defcounter) \
	DECLARE_PERF_OBJECT_EX(dwObjectId, namestring, helpstring, PERF_DETAIL_NOVICE, 0, sizeof(objectclass), ATLPERF_DEFAULT_MAXINSTNAMELENGTH, defcounter)
#define DECLARE_PERF_OBJECT_NO_INSTANCES(objectclass, dwObjectId, namestring, helpstring, defcounter) \
	DECLARE_PERF_OBJECT_EX(dwObjectId, namestring, helpstring, PERF_DETAIL_NOVICE, PERF_NO_INSTANCES, sizeof(objectclass), 0, defcounter)

#define DEFINE_COUNTER(member, namestring, helpstring, countertype, defscale) \
	DEFINE_COUNTER_EX(member, 0, namestring, helpstring, PERF_DETAIL_NOVICE, countertype, 0, defscale)

} // namespace ATL

#include <atlperf.inl>
#endif // __ATLPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlisapi.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTENCIL_H__
#include <atlstencil.h>
#endif

#ifndef __ATLISAPI_H__
#define __ATLISAPI_H__

#pragma once
#include <atlbase.h>
#include <time.h>   // needed for cookie support
#include <httpext.h>    // needed for ECB and IIS support
#include <atlspriv.h>
#include <atlserr.h>
#include <atlbase.inl>
#include <atlfile.h>
#include <atlstr.h>
#include <atldbcli.h>
#include <atlutil.h>
#include <atlcache.h>
#include <atlsrvres.h>
#include <atlsiface.h>
#include <objbase.h>
#include <atlsecurity.h>
#ifndef ATL_NO_SOAP
	#include <msxml2.h>
#endif
#ifndef ATL_NO_ACLAPI
    #include <aclapi.h>
#endif
#ifndef ATL_NO_MMSYS
#pragma warning(push)
#pragma warning(disable:4201)
#include <mmsystem.h>
#pragma warning(pop)
#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "winmm.lib")
#ifndef ATL_NO_SOAP
#pragma comment(lib, "msxml2.lib")
#endif
#endif  // !_ATL_NO_DEFAULT_LIBS
#endif

#pragma warning(push)
#pragma warning(disable: 4291) // allow placement new
#pragma warning(disable: 4127)
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#pragma warning(disable: 4702) // unreachable code



/* REVIEW: Remove these at some point in the future */
#include <initguid.h>
#include <dbgautoattach.h>

#ifndef SESSION_COOKIE_NAME
    #define SESSION_COOKIE_NAME "SESSIONID"
#endif

#ifndef ATLS_MAX_HTTP_DATE
    #define ATLS_MAX_HTTP_DATE 64
#endif


// This function is used in CValidateObject to determine if an empty
// request parameter really should be empty. You can 
// specialize this function in your own code such as
// the following specialization for type long:
// template <>
// inline bool IsNullByType<long>(long type) throw()
// {
//   return type == 0;
// }
// You should provide your own specialization for this 
// function if the comparison of type==0 is not adequate
// to discover whether or not your type is 0.
template <class TComp>
inline bool IsNullByType(TComp type) throw()
{
    return type == 0;
}

namespace ATL {

// Default file extension for server response files
#ifndef ATL_DEFAULT_STENCIL_EXTENSION
#define ATL_DEFAULT_STENCIL_EXTENSION ".srf"
#endif
__declspec(selectany) LPCSTR c_AtlSRFExtension = ATL_DEFAULT_STENCIL_EXTENSION;
__declspec(selectany) LPCTSTR c_tAtlSRFExtension = _T(ATL_DEFAULT_STENCIL_EXTENSION);
#define ATLS_EXTENSION_LEN (sizeof(ATL_DEFAULT_STENCIL_EXTENSION)-2)

// maximum handler name length
#ifndef ATL_MAX_HANDLER_NAME_LEN 
    #define ATL_MAX_HANDLER_NAME_LEN 64
#endif

// maximum timeout for async guard mutex
#ifndef ATLS_ASYNC_MUTEX_TIMEOUT
    #define ATLS_ASYNC_MUTEX_TIMEOUT 10000
#endif

#if defined(_M_IA64)
#define ATLS_FUNCID_INITIALIZEHANDLERS "InitializeAtlHandlers"
#define ATLS_FUNCID_GETATLHANDLERBYNAME "GetAtlHandlerByName"
#define ATLS_FUNCID_UNINITIALIZEHANDLERS "UninitializeAtlHandlers"
#else
#define ATLS_FUNCID_INITIALIZEHANDLERS "_InitializeAtlHandlers@8"
#define ATLS_FUNCID_GETATLHANDLERBYNAME "_GetAtlHandlerByName@12"
#define ATLS_FUNCID_UNINITIALIZEHANDLERS "_UninitializeAtlHandlers@0"
#endif

#define ATL_MAX_COOKIE_LEN 2048
#define ATL_MAX_COOKIE_ELEM 1024


// Defines a small value used for comparing the equality of floating point numbers.
#ifndef ATL_EPSILON
    #define ATL_EPSILON .0001
#endif

#ifndef ATL_DEFAULT_PRECISION
    #define ATL_DEFAULT_PRECISION 6
#endif


// Returns the number of instances of a particular character between the specified start and end points inclusive.
inline int CountOf(CHAR c, LPCSTR pBegin, LPCSTR pEnd) throw()
{
    int nCount = 0;
    while (pBegin < pEnd && *pBegin)
    {
        if (*pBegin == c)
            nCount++;
        pBegin++;
    }   
    return nCount;
}

// Call this function to copy a substring to a CString reference and ensure nul-termination.
ATL_NOINLINE inline bool CopyToCString(CStringA& string, LPCSTR pStart, LPCSTR pEnd) throw()
{
    _ATLTRY
    {
        if (pStart > pEnd)
            return true; //nothing to do
        int nLen = ((int)(pEnd-pStart))+1;
        LPSTR pBuff = string.GetBuffer(nLen+1);
        if (pBuff)
        {
            memcpy(pBuff, pStart, nLen);
            pBuff[nLen]=0;
            string.ReleaseBuffer(nLen);
        }

        return true;
    }
    _ATLCATCHALL()
    {
        return false;
    }
}

// Call this function to URL-encode a buffer and have the result appended to a CString passed by reference.
//
// A space in the input string is encoded as a plus sign (+).
// Other unsafe characters (as determined by AtlIsUnsafeUrlChar) are encoded as escaped octets.
// An escaped octet is a percent sign (%) followed by two digits representing the hexadecimal code of the character.
//
// string       A CStringA reference to which will be appended the encoded version of szBuf.
//
// szBuf        The string to be URL-encoded.
ATL_NOINLINE inline bool EscapeToCString(CStringA& string, LPCSTR szBuf) throw()
{
    ATLASSERT( szBuf != NULL );

    _ATLTRY
    {
        CHAR szEscaped[512];
        LPSTR pszStr = szEscaped;
        DWORD dwLen = 0;

        while (*szBuf)
        {
            if (dwLen+4 >= 512)
            {
                *pszStr = '\0';
                string+= szEscaped;
                pszStr = szEscaped;
                dwLen = 0;
            }
            if (AtlIsUnsafeUrlChar(*szBuf))
            {
                if (*szBuf == ' ')
                {
                    dwLen++;
                    *pszStr++ = '+';
                }
                else
                {
                    DWORD dwEsc = sprintf(pszStr, "%%%.2X", (unsigned char)*szBuf);
                    pszStr+= dwEsc;
                    dwLen+= dwEsc;
                }
            }
            else
            {
                *pszStr++ = *szBuf;
                dwLen++;
            }
            szBuf++;
        }

        *pszStr = '\0';
        string+= szEscaped;
    }
    _ATLCATCHALL()
    {
        return false;
    }

    return true;
}

// UNICODE overload for EscapeToCString
// follow specifications detailed in RFC document on
// Internationalized Uniform Resource Identifiers (IURI)
inline bool EscapeToCString(CStringA& string, LPCWSTR wszBuf) throw()
{
    _ATLTRY
    {
        // convert string to UTF8
        CFixedStringT<CStringA, 2048> strConvert;

        // get the required length for conversion
        int nLen = WideCharToMultiByte(CP_UTF8, 0, wszBuf, -1, NULL, 0, NULL, NULL);
        if (!nLen)
            return false; // error -- most likely CP_UTF8 not supported on the OS (e.g. Win98)

        // allocate MBCS conversion string
        LPSTR sz = strConvert.GetBuffer(nLen);
        if (!sz)
            return false;

        // do the UNICODE to UTF8 conversion
        nLen = WideCharToMultiByte(CP_UTF8, 0, wszBuf, -1, sz, nLen, NULL, NULL);
        if (!nLen)
            return false;

        // null-terminate
        sz[nLen] = '\0';

        // delegate to ANSI version of EscapeToCString
        if (!EscapeToCString(string, sz))
            return false;

        strConvert.ReleaseBuffer();
    }
    _ATLCATCHALL()
    {
        return false;
    }

    return true;
}

struct CDefaultErrorProvider
{
    struct HTTP_ERROR_TEXT
    {
        UINT uHttpError;    // the Http Error value
        UINT uHttpSubError; // Allows for customization of error text based on srf specific errors.
        LPCSTR szHeader;    // the string that should appear in the http response header
        UINT uResId;        // the resource id of the string to send back as the body
    };


    // GetErrorText retrieves the http response header string
    // and a resource id of the response body for a given
    // http error code
    // uError: Http error code to retrieve information for
    // ppszHeader: pointer to LPCSTR that receives the response header string
    //          ppszHeader is optional
    // puResId: pointer to UINT that receives the response body resource id
    //          puResId is optional
    static BOOL GetErrorText(UINT uError, UINT uSubErr, LPCSTR *ppszHeader, UINT *puResId) throw()
    {
        static const HTTP_ERROR_TEXT s_Errors[] = 
        {
            { 200, SUBERR_NONE, "OK", 0 },
            { 201, SUBERR_NONE, "Created", 0 },
            { 202, SUBERR_NONE, "Accepted", 0 },
            { 203, SUBERR_NONE, "Non-Authoritative Information", 0 },
            { 204, SUBERR_NONE, "No Content", 0 },
            { 204, DBG_SUBERR_ALREADY_DEBUGGING, "Already being debugged by another user", 0},
            { 204, DBG_SUBERR_NOT_DEBUGGING, "Not currently debugging a process", 0},
            { 204, DBG_SUBERR_INVALID_SESSION, "Requested DebugSessionID does not match current DebugSessionID", 0},
            { 204, DBG_SUBERR_BAD_ID, "DebugSessionID corrupted or not provided", 0 },
            { 204, DBG_SUBERR_COCREATE, "Could not CoCreate the debugger", 0 },
            { 204, DBG_SUBERR_ATTACH, "Could not attach to process", 0 },
            { 205, SUBERR_NONE, "Reset Content", 0 },
            { 206, SUBERR_NONE, "Partial Content", 0 },
            { 300, SUBERR_NONE, "Multiple Choices", 0 },
            { 301, SUBERR_NONE, "Moved Permanently", 0 },
            { 302, SUBERR_NONE, "Found", 0 },
            { 303, SUBERR_NONE, "See Other", 0 },
            { 304, SUBERR_NONE, "Not Modified", 0 },
            { 305, SUBERR_NONE, "Use Proxy", 0 },
            { 306, SUBERR_NONE, "(Unused)", 0 },
            { 307, SUBERR_NONE, "Temporary Redirect", 0 },
            { 400, SUBERR_NONE, "Bad Request", IDS_ATLSRV_BAD_REQUEST },
            { 401, SUBERR_NONE, "Unauthorized", IDS_ATLSRV_AUTH_REQUIRED },
            { 402, SUBERR_NONE, "Payment Required", 0 },
            { 403, SUBERR_NONE, "Forbidden", IDS_ATLSRV_FORBIDDEN },
            { 404, SUBERR_NONE, "Not Found", IDS_ATLSRV_NOT_FOUND },
            { 405, SUBERR_NONE, "Method Not Allowed", 0 },
            { 406, SUBERR_NONE, "Not Acceptable", 0 },
            { 407, SUBERR_NONE, "Proxy Authentication Required", 0 },
            { 408, SUBERR_NONE, "Request Timeout", 0 },
            { 409, SUBERR_NONE, "Conflict", 0 },
            { 410, SUBERR_NONE, "Gone", 0 },
            { 411, SUBERR_NONE, "Length Required", 0 },
            { 412, SUBERR_NONE, "Precondition Failed", 0 },
            { 413, SUBERR_NONE, "Request Entity Too Long", 0 },
            { 414, SUBERR_NONE, "Request-URI Too Long", 0 },
            { 415, SUBERR_NONE, "Unsupported Media Type", 0 },
            { 416, SUBERR_NONE, "Requested Range Not Satisfiable", 0 },
            { 417, SUBERR_NONE, "Expectation Failed", 0 },
            { 500, SUBERR_NONE, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR },
            { 500, ISE_SUBERR_BADSRF, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_BADSRF },
            { 500, ISE_SUBERR_HNDLFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HNDLFAIL },
            { 500, ISE_SUBERR_SYSOBJFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_SYSOBJFAIL},
            { 500, ISE_SUBERR_READFILEFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_READFILEFAIL},
			{ 500, ISE_SUBERR_LOADFILEFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LOADFILEFAIL},
            { 500, ISE_SUBERR_LOADLIB, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LOADLIB},
            { 500, ISE_SUBERR_HANDLERIF, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HANDLERIF},
            { 500, ISE_SUBERR_OUTOFMEM, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_OUTOFMEM},
            { 500, ISE_SUBERR_UNEXPECTED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_UNEXPECTED},
            { 500, ISE_SUBERR_STENCIL_PARSE_FAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_STENCILPARSEFAIL},
            { 500, ISE_SUBERR_STENCIL_LOAD_FAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL},
            { 500, ISE_SUBERR_HANDLER_NOT_FOUND, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HANDLERNOTFOUND},
            { 500, ISE_SUBERR_BAD_HANDLER_TAG, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_BADHANDLERTAG},
            { 500, ISE_SUBERR_LONGMETHODNAME, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LONGMETHODNAME},
            { 500, ISE_SUBERR_LONGHANDLERNAME, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LONGHANDLERNAME},
            { 500, ISE_SUBERR_NO_HANDLER_TAG, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_NOHANDLERTAG},
            { 500, ISE_SUBERR_IMPERSONATIONFAILED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_IMPERSONATIONFAILED},
            { 500, ISE_SUBERR_ISAPISTARTUPFAILED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_ISAPISTARTUPFAILED},
            
            { 501, SUBERR_NONE, "Not Implemented", IDS_ATLSRV_NOT_IMPLEMENTED },
            { 502, SUBERR_NONE, "Bad Gateway", IDS_ATLSRV_BAD_GATEWAY },
            { 503, SUBERR_NONE, "Service Unavailable", IDS_ATLSRV_SERVICE_NOT_AVAILABLE },
            { 504, SUBERR_NONE, "Gateway Timeout", 0 },
            { 505, SUBERR_NONE, "HTTP Version Not Supported", 0 },
        };

        // look for the error
        for (int i=0; i<sizeof(s_Errors)/sizeof(s_Errors[0]); i++)
        {
            if ((s_Errors[i].uHttpError == uError) && (s_Errors[i].uHttpSubError == uSubErr))
            {
                if (ppszHeader)
                    *ppszHeader = s_Errors[i].szHeader;
                if (puResId)
                    *puResId = s_Errors[i].uResId;
                return TRUE;
            }
        }

        // not found
        return FALSE;
    }
}; // CDefaultErrorProvider

template<class HttpUserErrorTextProvider>
CStringA GetStatusHeader(DWORD dwStatus, DWORD dwSubStatus, HttpUserErrorTextProvider* pErrorProvider, UINT *puResId = NULL) throw(...)
{
    pErrorProvider;

    LPCSTR szHeadErr = NULL;
    // First, we check for the error text in the extension's user error text provider
    BOOL bRet = pErrorProvider->GetErrorText(dwStatus, dwSubStatus, &szHeadErr, puResId);
    if (!bRet)
        szHeadErr = "";

    CStringA strStatus;
    strStatus.Format("%d %s", dwStatus, szHeadErr);
    return strStatus;
}

template<class HttpUserErrorTextProvider>
void RenderError(IHttpServerContext *pServerContext, DWORD dwStatus, DWORD dwSubStatus, HttpUserErrorTextProvider* pErrorProvider) throw()
{
    _ATLTRY
    {
        UINT uResId = 0;

        CStringA strStatus = GetStatusHeader(dwStatus, dwSubStatus, pErrorProvider, &uResId);
        pServerContext->SendResponseHeader(NULL, strStatus, FALSE);

        CStringA strBody = strStatus;
        if (uResId)
        {
            // load the body string from a resource
            CStringA strTemp;
            if (strTemp.LoadString(uResId))
            {
                strBody = strTemp;
            }
        }

        DWORD dwBodyLen = strBody.GetLength();
        pServerContext->WriteClient((void *) (LPCSTR) strBody, &dwBodyLen);
    }
    _ATLCATCHALL()
    {
        // last resort message when low on memory
        LPCSTR szError;
        BOOL bRes;
        bRes = CDefaultErrorProvider::GetErrorText(dwStatus, dwSubStatus, &szError, 0);
        if (!bRes)
            bRes = CDefaultErrorProvider::GetErrorText(dwStatus, SUBERR_NONE, &szError, 0);
        if (!bRes)
            bRes = CDefaultErrorProvider::GetErrorText(500, SUBERR_NONE, &szError, 0);
        DWORD dwBodyLen = (DWORD) strlen(szError);
        pServerContext->WriteClient((void *) szError, &dwBodyLen);
    }
}

// Call this function to retrieve the full canonical physical path 
 // of a file relative to the current script.
//
// Returns TRUE on success, FALSE on error.
//
// szFile           A file path relative to the current script directory for which
//                  you are trying to retrieve the full path.
//
// szFullFileName   A caller-allocated buffer of at least MAX_PATH characters in length.
//                  On success, contains the the full canonical path of szFile.
//
// pServerContext   The context for the current request. The context is used to obtain the
//                  current script directory.
inline BOOL GetScriptFullFileName(
    LPCSTR szFile,
    LPSTR szFullFileName,
    IHttpServerContext* pServerContext) throw()
{
    ATLASSERT(szFile != NULL);
    ATLASSERT(szFullFileName != NULL);

    char szTmpScriptPath[MAX_PATH+1];
    LPCSTR szTmp = pServerContext->GetScriptPathTranslated();

    if (!szTmp)
    {
        return FALSE;
    }
    strcpy(szTmpScriptPath, szTmp);

    CHAR *szScriptPath = szTmpScriptPath;

    LPSTR szBackslash;
    if (*szFile != '\\')
    {
        szBackslash = strrchr(szScriptPath, '\\');
        if (szBackslash)
            szBackslash++;
    }
    else
    {
        // handle case where szFile is of the form \directory\etc\etc
        szBackslash = strchr(szScriptPath, '\\');
    }

    if (szBackslash)
        *szBackslash = '\0';

    int nScriptPathLen = (int)(szBackslash ? strlen(szScriptPath) : 0);
    int nFileLen = (int) strlen(szFile);

    if (nScriptPathLen + nFileLen > MAX_PATH)
    {
        return FALSE;
    }
    CHAR szTemp[MAX_PATH + 1];
    if (nScriptPathLen)
        memcpy(szTemp, szScriptPath, nScriptPathLen);
    memcpy(szTemp + nScriptPathLen, szFile, nFileLen);
    *(szTemp + nScriptPathLen + nFileLen) = 0;
    PathCanonicalizeA(szFullFileName, szTemp);

    return TRUE;
}

interface IStencilCache;

enum ATLSRV_STATE
{
    ATLSRV_STATE_BEGIN,     // The request has just arrived, and the type has not been determined
    ATLSRV_STATE_CONTINUE,  // The request is a continuation of an async request
    ATLSRV_STATE_DONE,      // The request is a continuation of an async request, but the server is done with it
    ATLSRV_STATE_CACHE_DONE // The request is the callback of a cached page
};

enum ATLSRV_REQUESTTYPE
{
    ATLSRV_REQUEST_UNKNOWN=-1,  // The request type isn't known yet
    ATLSRV_REQUEST_STENCIL,     // The request is for a .srf file
    ATLSRV_REQUEST_DLL          // The request is for a .dll file
};

// Flags the InitRequest can return in dwStatus
#define  ATLSRV_INIT_USECACHE    1
#define  ATLSRV_INIT_USEASYNC    2
#define  ATLSRV_INIT_USEASYNC_EX 4 // required for use of NOFLUSH status

typedef HTTP_CODE (IRequestHandler::*PFnHandleRequest)(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
typedef void (*PFnAsyncComplete)(AtlServerRequest *pRequestInfo, DWORD cbIO, DWORD dwError);

struct AtlServerRequest
{
    DWORD cbSize;                           // For future compatibility
    IHttpServerContext *pServerContext;     // Necessary because it wraps the ECB
    ATLSRV_REQUESTTYPE dwRequestType;       // See the ATLSRV variables above
                                            // Indicates whether it was called through an .srf file or through a .dll file
    ATLSRV_STATE dwRequestState;            // See the ATLSRV variables above
                                            // Indicates what state of completion the request is in
    IRequestHandler *pHandler;              // Necessary because the callback (for async calls) must know where to
                                            // route the request
    HINSTANCE hInstDll;                     // Necessary in order to release the dll properly (for async calls)
    IIsapiExtension *pExtension;            // Necessary to requeue the request (for async calls)
    IDllCache* pDllCache;                   // Necessary to release the dll in async callback

    HANDLE hFile;
    HCACHEITEM hEntry;
    IFileCache* pFileCache;

    HANDLE m_hMutex;                        // necessary to syncronize calls to HandleRequest
                                            // if HandleRequest could potientially make an
                                            // async call before returning. only used
                                            // if indicated with ATLSRV_INIT_USEASYNC_EX

    DWORD dwStartTicks;                     // Tick count when the request was received
    EXTENSION_CONTROL_BLOCK *pECB;
    PFnHandleRequest pfnHandleRequest;
    PFnAsyncComplete pfnAsyncComplete;
    LPCSTR pszBuffer;                       // buffer to be flushed asyncronously
    DWORD dwBufferLen;                      // length of data in pszBuffer
    void* pUserData;                        // value that can be used to pass user data between parent and child handlers
};

inline void _ReleaseAtlServerRequest(AtlServerRequest* pRequest) throw()
{
    if (pRequest->pHandler)
        pRequest->pHandler->Release();
    if (pRequest->pServerContext)
        pRequest->pServerContext->Release();
    if (pRequest->pDllCache && pRequest->hInstDll)
        pRequest->pDllCache->ReleaseModule(pRequest->hInstDll);
    if (pRequest->m_hMutex)
        CloseHandle(pRequest->m_hMutex);
}

typedef BOOL (__stdcall *GETATLHANDLERBYNAME)(LPCSTR szHandlerName, IIsapiExtension *pExtension, IUnknown **ppHandler);
typedef BOOL (__stdcall *INITIALIZEATLHANDLERS)(IHttpServerContext*, IIsapiExtension*);
typedef void (__stdcall *UNINITIALIZEATLHANDLERS)();

// initial size of thread worker heap (per thread)
// The heap is growable.  The default initial is 16KB
#ifndef ATLS_WORKER_HEAP_SIZE
#define ATLS_WORKER_HEAP_SIZE 16384
#endif

class CIsapiWorker
{
public:
    typedef AtlServerRequest* RequestType;
    HANDLE m_hHeap;
#ifndef ATL_NO_SOAP
	CComPtr<ISAXXMLReader> m_spReader;
#endif

    CIsapiWorker() throw()
    {
        m_hHeap = NULL;
    }

    ~CIsapiWorker() throw()
    {
        ATLASSERT(m_hHeap == NULL);
    }

    virtual BOOL Initialize(void *pvParam) throw(...)
    {
        IIsapiExtension* pExtension = (IIsapiExtension*) pvParam;
        ATLASSERT(pExtension);
        if (!(pExtension->OnThreadAttach()))
            return FALSE;

        m_hHeap = HeapCreate(HEAP_NO_SERIALIZE, ATLS_WORKER_HEAP_SIZE, 0);
        if (!m_hHeap)
            return FALSE;
#ifndef ATL_NO_SOAP
		if (FAILED(m_spReader.CoCreateInstance(__uuidof(SAXXMLReader30))))
		{
			return FALSE;
		}
#endif
        return pExtension->SetThreadWorker(this);
    }

    virtual void Terminate(void* pvParam) throw()
    {
        if (m_hHeap)
        {
            if (HeapDestroy(m_hHeap))
                m_hHeap = NULL;
            else
            {
                ATLASSERT(FALSE);
            }
        }

#ifndef ATL_NO_SOAP
		m_spReader.Release();
#endif

        (static_cast<IIsapiExtension*>(pvParam))->OnThreadTerminate();
    }

    void Execute(AtlServerRequest *pRequestInfo, void *pvParam, OVERLAPPED *pOverlapped) throw()
    {
        ATLASSERT(pRequestInfo != NULL);
        ATLASSERT(pvParam != NULL);
        pOverlapped;    // unused
        ATLASSERT(m_hHeap != NULL);
		// any exceptions thrown at this point should have been caught in an
		// override of DispatchStencilCall. They will not be thrown out of this
		// function.
		_ATLTRY
		{
			(static_cast<IIsapiExtension*>(pvParam))->DispatchStencilCall(pRequestInfo);
		}
		_ATLCATCHALL()
		{
			ATLTRACE(_T("Warning. An uncaught exception was thrown from DispatchStencilCall\n"));
			ATLASSERT(FALSE);
		}
    }

    virtual BOOL GetWorkerData(DWORD /*dwParam*/, void ** /*ppvData*/) throw()
    {
        return FALSE;
    }
};


inline void _AtlGetScriptPathTranslated(
    LPCSTR szPathTranslated, 
    CFixedStringT<CStringA, MAX_PATH>& strScriptPathTranslated) throw()
{
    LPCSTR szEnd = szPathTranslated;

    while (TRUE)
    {
        while (*szEnd != '.' && *szEnd != '\0')
            szEnd++;
        if (*szEnd == '\0')
            break;

        szEnd++;

        size_t nLen(0);
        if (!_strnicmp(szEnd, "dll", sizeof("dll")-sizeof('\0')))
            nLen = 3;
        else if (!_strnicmp(szEnd, c_AtlSRFExtension+1, ATLS_EXTENSION_LEN))
            nLen = ATLS_EXTENSION_LEN;

        if (nLen)
        {
            szEnd += nLen;
            if (!*szEnd || *szEnd == '/' || *szEnd == '\\' || *szEnd == '?' || *szEnd == '#')
                break;
        }
    }

    DWORD dwResult = (DWORD)(szEnd - szPathTranslated);
    char *szScriptPathTranslated = strScriptPathTranslated.GetBuffer(dwResult);
    if (szScriptPathTranslated)
    {
        memcpy(szScriptPathTranslated, szPathTranslated, dwResult);
        szScriptPathTranslated[dwResult] = '\0';
        strScriptPathTranslated.ReleaseBuffer(dwResult);
    }
}
struct CStencilState
{
    CStencilState() throw()
    {
        dwIndex = 0;
        locale = CP_ACP;
        pIncludeInfo = NULL;
        pParentInfo = NULL;
    }

    DWORD dwIndex;
    LCID locale;
    AtlServerRequest* pIncludeInfo;
    AtlServerRequest* pParentInfo;
};

class CWrappedServerContext:
    public IHttpServerContext
{
public:
    CComPtr<IHttpServerContext> m_spParent;

    CWrappedServerContext() throw()
    {
    }

    CWrappedServerContext(IHttpServerContext *pParent) throw()
    {
        m_spParent = pParent;
    }

    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetRequestMethod();
    }

    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetQueryString();
    }

    LPCSTR GetPathInfo() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetPathInfo();
    }

    LPCSTR GetScriptPathTranslated() throw()
    {       
        ATLASSERT(m_spParent);
        return m_spParent->GetScriptPathTranslated();
    }

    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetPathTranslated();
    }

    DWORD GetTotalBytes() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetTotalBytes();
    }

    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetAvailableBytes();
    }

    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetAvailableData();
    }

    LPCSTR GetContentType() throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetContentType();
    }

    BOOL GetServerVariable(LPCSTR pszVariableName, LPSTR pvBuffer, DWORD *pdwSize) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetServerVariable(pszVariableName, pvBuffer, pdwSize);
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    { 
        ATLASSERT(m_spParent);
        return m_spParent->WriteClient(pvBuffer, pdwBytes);
    }

    BOOL AsyncWriteClient(void * pvBuffer, DWORD * pdwBytes) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->AsyncWriteClient(pvBuffer, pdwBytes);
    }

    BOOL ReadClient(void * pvBuffer, DWORD * pdwSize) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->ReadClient(pvBuffer, pdwSize);
    }

    BOOL AsyncReadClient(void * pvBuffer, DWORD * pdwSize) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->AsyncReadClient(pvBuffer, pdwSize);
    }
    
    BOOL SendRedirectResponse(LPCSTR pszRedirectUrl) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->SendRedirectResponse(pszRedirectUrl);
    }

    BOOL GetImpersonationToken(HANDLE * pToken) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->GetImpersonationToken(pToken);
    }

    BOOL SendResponseHeader(LPCSTR pszHeader, LPCSTR pszStatusCode, BOOL fKeepConn) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->SendResponseHeader(pszHeader, pszStatusCode, fKeepConn);
    }

    BOOL DoneWithSession(DWORD dwHttpStatusCode) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->DoneWithSession(dwHttpStatusCode);
    }

    BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION pfn, DWORD * pdwContext) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->RequestIOCompletion(pfn, pdwContext);
    }

    BOOL TransmitFile(HANDLE hFile, PFN_HSE_IO_COMPLETION pfn, void * pContext,
        LPCSTR szStatusCode, DWORD dwBytesToWrite, DWORD dwOffset, void * pvHead,
        DWORD dwHeadLen, void * pvTail, DWORD dwTailLen, DWORD dwFlags) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->TransmitFile(hFile, pfn, pContext, szStatusCode,
            dwBytesToWrite, dwOffset, pvHead, dwHeadLen, pvTail, dwTailLen,
            dwFlags);
    }

    BOOL AppendToLog(LPCSTR szMessage, DWORD* pdwLen) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->AppendToLog(szMessage, pdwLen);
    }

    BOOL MapUrlToPathEx(LPCSTR szLogicalPath, DWORD dwLen, HSE_URL_MAPEX_INFO *pumInfo) throw()
    {
        ATLASSERT(m_spParent);
        return m_spParent->MapUrlToPathEx(szLogicalPath, dwLen, pumInfo);
    }

};

// Wraps the EXTENSION_CONTROL_BLOCK structure used by IIS to provide
// an ISAPI extension with information about the current request and
// access to the web server's functionality.
class CServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHttpServerContext
{
public:
    BEGIN_COM_MAP(CServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    // The constructor.
    CServerContext() throw()
    {
        m_pECB = NULL;
        m_bHeadersHaveBeenSent = false;
    }

    void Initialize(EXTENSION_CONTROL_BLOCK *pECB) throw()
    {
        ATLASSERT(pECB);
        m_pECB = pECB;

        // Initialize the translated script path
        _AtlGetScriptPathTranslated(GetPathTranslated(), m_strScriptPathTranslated);
    }

    // Returns a nul-terminated string that contains the HTTP method of the current request.
    // Examples of common HTTP methods include "GET" and "POST".
    // Equivalent to the REQUEST_METHOD server variable or EXTENSION_CONTROL_BLOCK::lpszMethod.
    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpszMethod;
    }

    // Returns a nul-terminated string that contains the query information.
    // This is the part of the URL that appears after the question mark (?). 
    // Equivalent to the QUERY_STRING server variable or EXTENSION_CONTROL_BLOCK::lpszQueryString.
    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpszQueryString;
    }

    // Returns a nul-terminated string that contains the path of the current request.
    // This is the part of the URL that appears after the server name, but before the query string.
    // Equivalent to the PATH_INFO server variable or EXTENSION_CONTROL_BLOCK::lpszPathInfo.
    LPCSTR GetPathInfo() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpszPathInfo;
    }

    // Call this function to retrieve a nul-terminated string containing the physical path of the script.
    //
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the 
    // buffer (including the nul-terminating byte).
    // The script path is the same as GetPathTranslated up to the first .srf or .dll.
    // For example, if GetPathTranslated returns "c:\inetpub\vcisapi\hello.srf\goodmorning",
    // then this function returns "c:\inetpub\vcisapi\hello.srf".
    LPCSTR GetScriptPathTranslated() throw()
    {
        ATLASSERT(m_pECB);
        return m_strScriptPathTranslated;
    }


    // Returns a nul-terminated string that contains the translated path of the requested resource.
    // This is the path of the resource on the local server.
    // Equivalent to the PATH_TRANSLATED server variable or EXTENSION_CONTROL_BLOCK::lpszPathTranslated.
    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpszPathTranslated;
    }

    // Returns the total number of bytes to be received from the client.
    // If this value is 0xffffffff, then there are four gigabytes or more of available data.
    // In this case, ReadClient or AsyncReadClient should be called until no more data is returned.
    // Equivalent to the CONTENT_LENGTH server variable or EXTENSION_CONTROL_BLOCK::cbTotalBytes. 
    DWORD GetTotalBytes() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->cbTotalBytes;
    }

    // Returns the number of bytes available in the request buffer accessible via GetAvailableData.
    // If GetAvailableBytes returns the same value as GetTotalBytes, the request buffer contains the whole request.
    // Otherwise, the remaining data should be read from the client using ReadClient or AsyncReadClient.
    // Equivalent to EXTENSION_CONTROL_BLOCK::cbAvailable.
    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->cbAvailable;
    }

    // Returns a pointer to the request buffer containing the data sent by the client.
    // The size of the buffer can be determined by calling GetAvailableBytes.
    // Equivalent to EXTENSION_CONTROL_BLOCK::lpbData
    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpbData;
    }

    // Returns a nul-terminated string that contains the content type of the data sent by the client.
    // Equivalent to the CONTENT_TYPE server variable or EXTENSION_CONTROL_BLOCK::lpszContentType.
    LPCSTR GetContentType() throw()
    {
        ATLASSERT(m_pECB);
        return m_pECB->lpszContentType;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the requested server variable.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    // Equivalent to  EXTENSION_CONTROL_BLOCK::GetServerVariable.
    BOOL GetServerVariable(
        LPCSTR pszVariableName,
        LPSTR pvBuffer,
        DWORD *pdwSize) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pszVariableName);
        ATLASSERT(pdwSize);

        if (pszVariableName && pdwSize)
        {
            return m_pECB->GetServerVariable(m_pECB->ConnID, (LPSTR) pszVariableName,
                            pvBuffer, pdwSize);
        }
        return FALSE;
    }

    // Synchronously sends the data present in the given buffer to the client that made the request.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to EXTENSION_CONTROL_BLOCK::WriteClient(..., HSE_IO_SYNC).
    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pvBuffer);
        ATLASSERT(pdwBytes);

        if (pvBuffer && pdwBytes)
        {
            return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_SYNC | HSE_IO_NODELAY);
        }
        return FALSE;
    }

    // Asynchronously sends the data present in the given buffer to the client that made the request.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to EXTENSION_CONTROL_BLOCK::WriteClient(..., HSE_IO_ASYNC).
    BOOL AsyncWriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pvBuffer);
        ATLASSERT(pdwBytes);

        if (pvBuffer && pdwBytes)
        {
            return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_ASYNC | HSE_IO_NODELAY);
        }
        return FALSE;
    }

    // Call this function to synchronously read information from the body of the web client's HTTP request into the buffer supplied by the caller.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to EXTENSION_CONTROL_BLOCK::ReadClient.
    BOOL ReadClient(void *pvBuffer, DWORD *pdwSize) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pvBuffer);
        ATLASSERT(pdwSize);

        if (pvBuffer && pdwSize)
        {
            return m_pECB->ReadClient(m_pECB->ConnID, pvBuffer, pdwSize);
        }
        return FALSE;
    }

    // Call this function to asynchronously read information from the body of the web client's HTTP request into the buffer supplied by the caller.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to the HSE_REQ_ASYNC_READ_CLIENT server support function.
    BOOL AsyncReadClient(void *pvBuffer, DWORD *pdwSize) throw()
    {
        // To call this function successfully someone has to have already
        // called RequestIOCompletion specifying the callback function
        // to be used for IO completion.
        ATLASSERT(m_pECB);
        ATLASSERT(pvBuffer);
        ATLASSERT(pdwSize);

        if (pvBuffer && pdwSize)
        {
            DWORD dwFlag = HSE_IO_ASYNC;
            return m_pECB->ServerSupportFunction(m_pECB->ConnID,
                HSE_REQ_ASYNC_READ_CLIENT, pvBuffer, pdwSize,
                &dwFlag);
        }
        return FALSE;
    }
    
    // Call this function to redirect the client to the specified URL.
    // The client receives a 302 (Found) HTTP status code.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_SEND_URL_REDIRECT_RESP server support function.
    BOOL SendRedirectResponse(LPCSTR pszRedirectUrl) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pszRedirectUrl);

        if (pszRedirectUrl)
        {
            DWORD dwSize = (DWORD) strlen(pszRedirectUrl);
            return m_pECB->ServerSupportFunction(m_pECB->ConnID,
                HSE_REQ_SEND_URL_REDIRECT_RESP,
                (void *) pszRedirectUrl, &dwSize, NULL);
        }
        return FALSE;
    }

    // Call this function to retrieve a handle to the impersonation token for this request.
    // An impersonation token represents a user context. You can use the handle in calls to ImpersonateLoggedOnUser or SetThreadToken.
    // Do not call CloseHandle on the handle.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_GET_IMPERSONATION_TOKEN server support function.
    BOOL GetImpersonationToken(HANDLE * pToken) throw()
    {
        ATLASSERT(m_pECB);
        if (pToken)
        {
            return m_pECB->ServerSupportFunction(m_pECB->ConnID,
                HSE_REQ_GET_IMPERSONATION_TOKEN, pToken,
                NULL, NULL);
        }
        return FALSE;
    }

    // Call this function to send an HTTP response header to the client including the HTTP status, server version, message time, and MIME version.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_SEND_RESPONSE_HEADER_EX server support function.
    BOOL SendResponseHeader(
        LPCSTR pszHeader = "Content-Type: text/html\r\n\r\n",
        LPCSTR pszStatusCode = "200 OK",
        BOOL fKeepConn=FALSE) throw()
    {
        ATLASSERT(m_pECB);

        if (m_bHeadersHaveBeenSent)
            return TRUE;
        
        HSE_SEND_HEADER_EX_INFO hex;
        hex.pszStatus = pszStatusCode;
        hex.pszHeader = pszHeader;
        hex.cchStatus = (DWORD)(pszStatusCode ? strlen(pszStatusCode) : 0);
        hex.cchHeader = (DWORD)(pszHeader ? strlen(pszHeader) : 0);
        hex.fKeepConn = fKeepConn;

        m_bHeadersHaveBeenSent = true;

        return m_pECB->ServerSupportFunction(m_pECB->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &hex, NULL, NULL);
    }

    // Call this function to terminate the session for the current request.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_DONE_WITH_SESSION server support function.
    BOOL DoneWithSession(DWORD dwHttpStatusCode) throw()
    {
        ATLASSERT(m_pECB);

		m_pECB->dwHttpStatusCode = dwHttpStatusCode;

		DWORD dwStatusCode = (dwHttpStatusCode >= 400) ? HSE_STATUS_ERROR : HSE_STATUS_SUCCESS;

        return m_pECB->ServerSupportFunction(m_pECB->ConnID,
            HSE_REQ_DONE_WITH_SESSION, &dwStatusCode, NULL, NULL);
    }

    // Call this function to set a special callback function that will be used for handling the completion of asynchronous I/O operations.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_IO_COMPLETION server support function.
    BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION pfn, DWORD *pdwContext) throw()
    {
        ATLASSERT(m_pECB);
        ATLASSERT(pfn);

        if (pfn)
        {
            return m_pECB->ServerSupportFunction(m_pECB->ConnID,
                HSE_REQ_IO_COMPLETION, pfn, NULL, pdwContext);
        }
        return FALSE;
    }

    // Call this function to transmit a file asynchronously to the client.
    // Returns TRUE on success, and FALSE on failure.
    // Equivalent to the HSE_REQ_TRANSMIT_FILE server support function.
    BOOL TransmitFile(
        HANDLE hFile,
        PFN_HSE_IO_COMPLETION pfn,
        void *pContext,
        LPCSTR szStatusCode,
        DWORD dwBytesToWrite,
        DWORD dwOffset,
        void *pvHead,
        DWORD dwHeadLen,
        void *pvTail,
        DWORD dwTailLen,
        DWORD dwFlags) throw()
    {
        ATLASSERT(m_pECB);

        HSE_TF_INFO tf;
        tf.hFile = hFile;
        tf.BytesToWrite = dwBytesToWrite;
        tf.Offset = dwOffset;
        tf.pContext = pContext;
        tf.pfnHseIO = pfn;
        tf.pHead = pvHead;
        tf.HeadLength = dwHeadLen;
        tf.pTail = pvTail;
        tf.TailLength = dwTailLen;
        tf.pszStatusCode = szStatusCode;
        tf.dwFlags = dwFlags;
        return m_pECB->ServerSupportFunction(m_pECB->ConnID,
            HSE_REQ_TRANSMIT_FILE, &tf, NULL, NULL);
    }

    // Appends the string szMessage to the web server log for the current
    // request.
    // Returns TRUE on success, FALSE on failure.
    // Equivalent to the HSE_APPEND_LOG_PARAMETER server support function.
    BOOL AppendToLog(LPCSTR szMessage, DWORD *pdwLen) throw()
    {
        DWORD dwLen = 0;
        if (!pdwLen)
            dwLen = (DWORD)strlen(szMessage);
        else
            dwLen = *pdwLen;

        return m_pECB->ServerSupportFunction(m_pECB->ConnID,
            HSE_APPEND_LOG_PARAMETER, (void *)szMessage, 
            &dwLen, NULL);
    }

    // Maps a logical Url Path to a physical path
    // Returns TRUE on success, FALSE on failure.
    // Equivalent to the HSE_REQ_MAP_URL_TO_PATH_EX server support function.
    // you can pass 0 for dwLen if szLogicalPath is null terminated
    BOOL MapUrlToPathEx(LPCSTR szLogicalPath, DWORD dwLen, HSE_URL_MAPEX_INFO *pumInfo)
    {
        if (dwLen == 0)
            dwLen = (DWORD) strlen(szLogicalPath);
        return m_pECB->ServerSupportFunction(m_pECB->ConnID, HSE_REQ_MAP_URL_TO_PATH_EX, (void *) szLogicalPath,
            &dwLen, (DWORD *) pumInfo);
    }

protected:
    // The pointer to the extension control block provided by IIS.
    EXTENSION_CONTROL_BLOCK *m_pECB;
    bool m_bHeadersHaveBeenSent;

    // The translated script path
//    char m_szScriptPathTranslated[MAX_PATH];
    CFixedStringT<CStringA, MAX_PATH> m_strScriptPathTranslated;

}; // class CServerContext

class CPageCachePeer
{
public:

	struct PeerInfo
	{
		CStringA strHeader;
		CStringA strStatus;
	};

	static BOOL Add(PeerInfo * pDest, void * pSrc) throw()
	{
		PeerInfo *pIn = (PeerInfo *)pSrc;
		pDest->strHeader = pIn->strHeader;
		pDest->strStatus = pIn->strStatus;
		return TRUE;
	}

	static BOOL Remove(const PeerInfo * /*pDest*/) throw()
	{
		return TRUE;
	}
};


class CCacheServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext,
    public IPageCacheControl
{
private:

	CAtlTemporaryFile m_cacheFile;
    CComPtr<IFileCache> m_spCache;
    char m_szFullUrl[ATL_URL_MAX_URL_LENGTH + 1];
    FILETIME m_ftExpiration;
    BOOL m_bIsCached;
	CPageCachePeer::PeerInfo m_Headers;

public:

    BEGIN_COM_MAP(CCacheServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
        COM_INTERFACE_ENTRY(IPageCacheControl)
    END_COM_MAP()

    // The constructor.
    CCacheServerContext() throw()
    {
    }

    void Initialize(IHttpServerContext *pParent, IFileCache *pCache) throw()
    {
        ATLASSERT(pParent);
        m_spParent = pParent;
        m_spCache = pCache;
        m_cacheFile.Create();

        LPCSTR szPathInfo = pParent->GetPathInfo();
        LPCSTR szQueryString = pParent->GetQueryString();

        LPSTR szTo = m_szFullUrl;
        while (*szPathInfo)
        {
            *szTo++ = *szPathInfo++;
        }
        *szTo++ = '?';
        while (*szQueryString)
        {
            *szTo++ = *szQueryString++;
        }
        *szTo = '\0';

        memset(&m_ftExpiration, 0x00, sizeof(FILETIME));
        m_bIsCached = TRUE;
    }

    // IPageCacheControl methods
    HRESULT GetExpiration(FILETIME *pftExpiration) throw()
    {
        if (!pftExpiration)
            return E_INVALIDARG;

        *pftExpiration = m_ftExpiration;

        return S_OK;
    }

    HRESULT SetExpiration(FILETIME ftExpiration) throw()
    {
        m_ftExpiration = ftExpiration;

        return S_OK;
    }
    
    BOOL IsCached() throw()
    {
        return m_bIsCached;
    }

    BOOL Cache(BOOL bCache) throw()
    {
        BOOL bRet = m_bIsCached;
        m_bIsCached = bCache;
        return bRet;
    }


    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    { 
        ATLASSERT(m_spParent);
        if (S_OK != m_cacheFile.Write(pvBuffer, *pdwBytes))
            return FALSE;

        return m_spParent->WriteClient(pvBuffer, pdwBytes);
    }

    BOOL DoneWithSession(DWORD dwHttpStatusCode) throw()
    {
        ATLASSERT(m_spParent);

        _ATLTRY
        {
           if (m_bIsCached)
           {
               CT2CA strFileName(m_cacheFile.TempFileName());
               m_cacheFile.HandsOff();
               m_spCache->AddFile(m_szFullUrl, strFileName, &m_ftExpiration, &m_Headers, NULL);
           }
           else
               m_cacheFile.Close();
        }
        _ATLCATCHALL()
        {
            m_cacheFile.Close();
        }

        return m_spParent->DoneWithSession(dwHttpStatusCode);
    }

    BOOL GetImpersonationToken(HANDLE * pToken) throw()
    {
        ATLTRACE(atlTraceISAPI, 0, _T("Getting impersonation token for cached page -- Possible security problem"));
        ATLASSERT(m_spParent);
        return m_spParent->GetImpersonationToken(pToken);
    }

    BOOL AppendToLog(LPCSTR szMessage, DWORD* pdwLen) throw()
    {
        ATLTRACE(atlTraceISAPI, 0, _T("Logging on cached page -- future hits will not log"));
        ATLASSERT(m_spParent);
        return m_spParent->AppendToLog(szMessage, pdwLen);
    }

    BOOL SendResponseHeader(
        LPCSTR pszHeader = "Content-Type: text/html\r\n\r\n",
        LPCSTR pszStatusCode = "200 OK",
        BOOL fKeepConn=FALSE) throw()
    {
        ATLASSERT(m_spParent);

		m_Headers.strHeader = pszHeader;
		m_Headers.strStatus = pszStatusCode;

        return m_spParent->SendResponseHeader(pszHeader, pszStatusCode, fKeepConn);
    }

    // The methods below this point are actions that should not be performed on cached
    // pages, as they will not behave correctly.
    BOOL AsyncWriteClient(void * /*pvBuffer*/, DWORD * /*pdwBytes*/) throw()
    {
        // Asynchronous calls will not work
        ATLASSERT(FALSE);
        return FALSE;
    }

    BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        // Nobody should be reading from this client if the page is being cached
        // Also, only GET's are cached anyway
        ATLASSERT(FALSE);
        return FALSE;
    }

    BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }
    
    BOOL SendRedirectResponse(LPCSTR /*pszRedirectUrl*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }


    BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION /*pfn*/, DWORD * /*pdwContext*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }

    BOOL TransmitFile(
        HANDLE /*hFile*/,
        PFN_HSE_IO_COMPLETION /*pfn*/,
        void * /*pContext*/,
        LPCSTR /*szStatusCode*/,
        DWORD /*dwBytesToWrite*/,
        DWORD /*dwOffset*/,
        void * /*pvHead*/,
        DWORD /*dwHeadLen*/,
        void * /*pvTail*/,
        DWORD /*dwTailLen*/,
        DWORD /*dwFlags*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }

    BOOL MapUrlToPathEx(LPCSTR szLogicalPath, DWORD dwLen, HSE_URL_MAPEX_INFO *pumInfo) throw()
    {
		return CWrappedServerContext::MapUrlToPathEx(szLogicalPath, dwLen, pumInfo);
    }
};


// This class represents a collection of validation failures.
// Use this class in combination with CValidateObject to validate
// forms, cookies, or query strings and build up a collection of
// failures. If appropriate, use the information in the collection
// to return detailed responses to the client to help them correct the failures.
#define EMPTY_PARAMS_ARE_FAILURES   0x00000001

class CValidateContext :
    public CSimpleMap<CStringA, DWORD> 
{
public:
    CValidateContext(DWORD dwFlags=0) throw()
    {
        m_bFailures = false;
        m_dwFlags = dwFlags;
    }

    // Call this function to add a validation result to the collection managed by this object.
    // Each result is identified by a name and the type of result that occurred.
    // The result codes are the VALIDATION_ codes defined at the top of this file.
    // The bOnlyFailure parameter below is used to only allow failure results to
    // be added to the list of failures. The reason you'd want to do this is that
    // success codes should be the common case in validation routines so you can
    // use bOnlyFailures to limit the number of allocations by this class's base
    // map for mapping success results if you don't care about iterating successes.
    bool AddResult(LPCSTR szName, DWORD type, bool bOnlyFailures = true) throw()
    {
        _ATLTRY
        {
            if (!VALIDATION_SUCCEEDED(type) ||
                (type == VALIDATION_S_EMPTY && (m_dwFlags & EMPTY_PARAMS_ARE_FAILURES)))
                m_bFailures = true;

            if (!bOnlyFailures)
                return TRUE == Add(szName, type); // add everything

            else if (bOnlyFailures && 
                    (!VALIDATION_SUCCEEDED(type) ||
                    (type == VALIDATION_S_EMPTY && (m_dwFlags & EMPTY_PARAMS_ARE_FAILURES))))
                return TRUE == Add(szName, type); // only add failures
        }
        _ATLCATCHALL()
        {
        }

        return false;
    }

    // Returns true if there are no validation failures in the collection,
    // returns false otherwise.
    bool ParamsOK() throw()
    {
        return !m_bFailures;
    }

    // Returns the number of validation results in the collection.
    int GetResultCount() throw()
    {
        return GetSize();
    }

    // Call this function to retrieve the name and type of a
    // validation result based on its index in the collection.
    // Returns true on success, false on failure.
    //
    // i        The index of a result managed by this collection.
    //
    // strName  On success, the name of the result with index i.
    //
    // type     On success, the type of the result with index i.
    bool GetResultAt(int i, CStringA& strName, DWORD& type) throw()
    {
        if ( i >= 0 && i < GetSize())
        {
			_ATLTRY
			{
				strName = GetKeyAt(i);
				type = GetValueAt(i);
			}
			_ATLCATCHALL()
			{
				return false;
			}
            return true;
        }
        return false;
    }

    DWORD m_dwFlags;
protected:
    bool m_bFailures;
}; // CValidateContext



class CAtlValidator
{
public:
    template <class T, class TCompType>
    static DWORD Validate(
        T value,
        TCompType nMinValue,
        TCompType nMaxValue) throw()
    {
        DWORD dwRet = VALIDATION_S_OK;
        if (value < static_cast<T>(nMinValue))
            dwRet = VALIDATION_E_LENGTHMIN;
        else if (value > static_cast<T>(nMaxValue))             
            dwRet = VALIDATION_E_LENGTHMAX;
        return dwRet;
    }

    static DWORD Validate( LPCSTR pszValue, int nMinChars, int nMaxChars) throw()
    {
        DWORD dwRet = VALIDATION_S_OK;
        int nChars = (int) strlen(pszValue);
        if (nChars < nMinChars)
            dwRet = VALIDATION_E_LENGTHMIN;
        else if (nChars > nMaxChars)
            dwRet = VALIDATION_E_LENGTHMAX;
        return dwRet;
    }
    static DWORD Validate( double dblValue, double dblMinValue, double dblMaxValue) throw()
    {
        DWORD dwRet = VALIDATION_S_OK;
        if ( dblValue < (dblMinValue - ATL_EPSILON) )
            dwRet = VALIDATION_E_LENGTHMIN;
        else if ( dblValue > (dblMaxValue + ATL_EPSILON) )
            dwRet = VALIDATION_E_LENGTHMAX;
        return dwRet;
    }
};

// This class provides functions for retrieving and validating named values.
//
// The named values are expected to be provided in string form by the class used as
// the template parameter. CValidateObject provides the means of
// retrieving these values converted to data types chosen by you. You can validate the values
// by specifying a range for numeric values or by specifying a minimum and maximum length
// for string values.
//
// Call one of the Exchange overloads to retrieve a named value converted to your chosen data type.
// Call one of the Validate overloads to retrieve a named value converted to your chosen data type
// and validated against a minimum and maximum value or length supplied by you.
//
// To add validation functionality to the class TLookupClass, derive that class from CValidateObject<TLookupClass>
// and provide a Lookup function that takes a name as a string and returns the corresponding value
// also as a string:
//      LPCSTR Lookup(LPCSTR szName);
template <class TLookupClass, class TValidator = CAtlValidator>
class CValidateObject
{
public:
    // Exchange Routines

    // Call this function to retrieve a named value converted to your chosen data type.
    // Returns one of the following validation status codes:
    //      VALIDATION_S_OK             The named value was found and could be converted successfully
    //      VALIDATION_S_EMPTY          The name was present, but the value was empty
    //      VALIDATION_E_PARAMNOTFOUND  The named value was not found
    //      VALIDATION_E_INVALIDPARAM   The name was present, but the value could not be converted to the requested data type
    //      VALIDATION_E_FAIL           An unspecified error occurred
    // Pass a pointer to a validation context object if you want to add
    // failures to the collection managed by that object.
    template <class T>
    ATL_NOINLINE DWORD Exchange(
        LPCSTR szParam,
        T* pValue,
        CValidateContext *pContext = NULL) const throw()
    {
        DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
        if (pValue)
        {
            const TLookupClass *pT = static_cast<const TLookupClass*>(this);
            LPCSTR szValue = pT->Lookup(szParam);
            if (szValue)
            {
                if (*szValue=='\0')
                    dwRet = VALIDATION_S_EMPTY; 
                else
                {
                    dwRet = ConvertNumber(szValue, pValue);
                }
            }
        }
        else
            dwRet = VALIDATION_E_FAIL; // invalid input

        if (pContext)
            pContext->AddResult(szParam, dwRet);
        return dwRet;
    }

    template<>
    ATL_NOINLINE DWORD Exchange(
        LPCSTR szParam,
        CString* pstrValue,
        CValidateContext *pContext) const throw()
    {
        _ATLTRY
        {
            LPCSTR pszValue = NULL;
            DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
            if (pstrValue)
            {
                dwRet = Exchange(szParam, &pszValue, pContext);
                if (VALIDATION_SUCCEEDED(dwRet) && pstrValue != NULL)
                    *pstrValue = CA2T(pszValue);
            }
            else
            {
                dwRet = VALIDATION_E_FAIL; // invalid input
                if (pContext)
                    pContext->AddResult(szParam, dwRet);
            }
            
            return dwRet;
        }
        _ATLCATCHALL()
        {
            return VALIDATION_E_FAIL;
        }
    }

    template<>
    ATL_NOINLINE DWORD Exchange(
        LPCSTR szParam,
        LPCSTR* ppszValue,
        CValidateContext *pContext) const throw()
    {
        DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
        if (ppszValue)
        {
            *ppszValue = NULL;
            const TLookupClass *pT = static_cast<const TLookupClass*>(this);
            LPCSTR szValue = pT->Lookup(szParam);
            if (szValue)
            {
                if (*szValue=='\0')
                    dwRet = VALIDATION_S_EMPTY; 
                else
                {
                    *ppszValue = szValue;
                    dwRet = VALIDATION_S_OK;
                }
            }
        }
        else
            dwRet = VALIDATION_E_FAIL; // invalid input

        if (pContext)
            pContext->AddResult(szParam, dwRet);
        return dwRet;
    }

    template<>
    ATL_NOINLINE DWORD Exchange(
        LPCSTR szParam,
        GUID* pValue,
        CValidateContext *pContext) const throw()
    {
        DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
        if (pValue)
        {
            const TLookupClass *pT = static_cast<const TLookupClass*>(this);
            LPCSTR szValue = pT->Lookup(szParam);
            if (szValue)
            {
                if (*szValue=='\0')
                    dwRet = VALIDATION_S_EMPTY; 
                else
                {
                    USES_CONVERSION;
                    if (S_OK != CLSIDFromString(A2OLE(szValue), pValue))
                    {
                        dwRet = VALIDATION_E_INVALIDPARAM;
                    }
                    else
                        dwRet = VALIDATION_S_OK;
                }
            }
        }
        else
            dwRet = VALIDATION_E_FAIL; // invalid input

        if (pContext)
            pContext->AddResult(szParam, dwRet);
        return dwRet;
    }
    
    template<>
    ATL_NOINLINE DWORD Exchange(
        LPCSTR szParam,
        bool* pbValue,
        CValidateContext *pContext) const throw()
    {
        DWORD dwRet = VALIDATION_S_OK;
        if (pbValue)
        {
            const TLookupClass *pT = static_cast<const TLookupClass*>(this);
            LPCSTR szValue = pT->Lookup(szParam);
            *pbValue = false;
            if (szValue)
            {
                if (*szValue != '\0')
                    *pbValue = true;
            }
        }
        else
            dwRet = VALIDATION_E_FAIL; // invalid input

        if (pContext)
            pContext->AddResult(szParam, dwRet);

        return dwRet;
    }

    DWORD ConvertNumber(LPCSTR szVal, ULONGLONG *pnVal) const throw()
    {
        if (!pnVal)
            return VALIDATION_E_FAIL;
        char *pEnd = NULL;
        ULONGLONG n = _strtoui64(szVal, &pEnd, 10);
        if (pEnd == szVal || errno == ERANGE)
        {
            errno = 0;
            return VALIDATION_E_INVALIDPARAM;
        }
        *pnVal = n;
        return VALIDATION_S_OK;
    }

    DWORD ConvertNumber(LPCSTR szVal, LONGLONG *pnVal) const throw()
    {
        if (!pnVal)
            return VALIDATION_E_FAIL;
        char *pEnd = NULL;
        LONGLONG n = _strtoi64(szVal, &pEnd, 10);
        if (pEnd == szVal || errno == ERANGE)
		{
			errno = 0;
            return VALIDATION_E_INVALIDPARAM;
		}
        *pnVal = n;
        return VALIDATION_S_OK;
    }

    DWORD ConvertNumber(LPCSTR szVal, double *pdblVal) const throw()
    {
        if (!pdblVal)
            return VALIDATION_E_FAIL;
        char *pEnd = NULL;
        double d = strtod(szVal, &pEnd);
        if (pEnd == szVal || errno == ERANGE)
		{
			errno = 0;
            return VALIDATION_E_INVALIDPARAM;
		}
        *pdblVal = d;
        return VALIDATION_S_OK;
    }

    DWORD ConvertNumber(LPCSTR szVal, int *pnVal) const throw()
    {
        return ConvertNumber(szVal, (long*)pnVal);
    }

    DWORD ConvertNumber(LPCSTR szVal, unsigned int *pnVal) const throw()
    {
        return ConvertNumber(szVal, (unsigned long*)pnVal);
    }

    DWORD ConvertNumber(LPCSTR szVal, long *pnVal) const throw()
    {
        if (!pnVal)
            return VALIDATION_E_FAIL;
        char *pEnd = NULL;
        long n = strtol(szVal, &pEnd, 10);
        if (pEnd == szVal || errno == ERANGE)
		{
			errno = 0;
            return VALIDATION_E_INVALIDPARAM;
		}
        *pnVal = n;
        return VALIDATION_S_OK;
    }

    DWORD ConvertNumber(LPCSTR szVal, unsigned long *pnVal) const throw()
    {
        if (!pnVal)
            return VALIDATION_E_FAIL;
        char *pEnd = NULL;
        long n = strtoul(szVal, &pEnd, 10);
        if (pEnd == szVal || errno == ERANGE)
		{
			errno = 0;
            return VALIDATION_E_INVALIDPARAM;
		}
        *pnVal = n;
        return VALIDATION_S_OK;
    }

    DWORD ConvertNumber(LPCSTR szVal, short *pnVal) const throw()
    {
        long nVal = 0;
        DWORD dwRet = ConvertNumber(szVal, &nVal);
        if (dwRet == VALIDATION_S_OK)
        {
            // clamp to the size of a short
            if(nVal <= SHRT_MAX &&
                nVal >= SHRT_MIN)
            {
                *pnVal = (short)nVal;
            }
            else
            {
                dwRet = VALIDATION_E_INVALIDPARAM;
            }
        }
        return dwRet;
    };

    DWORD ConvertNumber(LPCSTR szVal, unsigned short *pnVal) const throw()
    {
        unsigned long nVal = 0;
        DWORD dwRet = ConvertNumber(szVal, &nVal);
        if (dwRet == VALIDATION_S_OK)
        {
            // clamp to the size of a short
            if(nVal <= USHRT_MAX &&
               nVal >= 0)
            {
                *pnVal = (unsigned short)nVal;
            }
            else
            {
                dwRet = VALIDATION_E_INVALIDPARAM;
            }
        }
        return dwRet;
    };

    // Call this function to retrieve a named value converted to your chosen data type
    // and validated against a minimum and maximum value or length supplied by you.
    //
    // Returns one of the following validation status codes:
    //      VALIDATION_S_OK             The named value was found and could be converted successfully
    //      VALIDATION_S_EMPTY          The name was present, but the value was empty
    //      VALIDATION_E_PARAMNOTFOUND  The named value was not found
    //      VALIDATION_E_INVALIDPARAM   The name was present, but the value could not be converted to the requested data type
    //      VALIDATION_E_LENGTHMIN      The name was present and could be converted to the requested data type, but the value was too small
    //      VALIDATION_E_LENGTHMAX      The name was present and could be converted to the requested data type, but the value was too large
    //      VALIDATION_E_FAIL           An unspecified error occurred
    //
    // Validate can be used to convert and validate name-value pairs
    // such as those associated with HTTP requests (query string, form fields, or cookie values).  
    // The numeric specializations validate the minimum and maximum value.
    // The string specializations validate the minimum and maximum length.
    //
    // Pass a pointer to a validation context object if you want to add
    // failures to the collection managed by that object.
    //
    // Note that you can validate the value of a parameter without
    // storing its value by passing NULL for the second parameter. However
    // if you pass NULL for the second parameter, make sure you cast the NULL to a 
    // type so that the compiler will call the correct specialization of Validate.
    template <class T, class TCompType>
    ATL_NOINLINE DWORD Validate(
        LPCSTR Param,
        T *pValue,
        TCompType nMinValue,
        TCompType nMaxValue,
        CValidateContext *pContext = NULL) const throw()
    {
        T value;
        DWORD dwRet = Exchange(Param, &value, pContext);
        if ( dwRet == VALIDATION_S_OK )
        {
            if (pValue)
                *pValue = value;
            dwRet = TValidator::Validate(value, nMinValue, nMaxValue);
            if (pContext && dwRet != VALIDATION_S_OK)
                pContext->AddResult(Param, dwRet);
        }
        else if (dwRet == VALIDATION_S_EMPTY &&
                 !IsNullByType(nMinValue))
        {
                 dwRet = VALIDATION_E_LENGTHMIN;
                 if (pContext)
                 {
                    pContext->SetAt(Param, VALIDATION_E_LENGTHMIN);
                 }
        }

        return dwRet;
    }

    // Specialization for strings. Comparison is for number of characters.
    template<>
    ATL_NOINLINE DWORD Validate(
        LPCSTR Param,
        LPCSTR* ppszValue,
        int nMinChars,
        int nMaxChars,
        CValidateContext *pContext) const throw()
    {
        LPCSTR pszValue = NULL;
        DWORD dwRet = Exchange(Param, &pszValue, pContext);
        if (dwRet == VALIDATION_S_OK )
        {
            if (ppszValue)
                *ppszValue = pszValue;
            dwRet = TValidator::Validate(pszValue, nMinChars, nMaxChars);
            if (pContext && dwRet != VALIDATION_S_OK)
                pContext->AddResult(Param, dwRet);
        }
        else if (dwRet == VALIDATION_S_EMPTY &&
                 nMinChars > 0)
        {
                 dwRet = VALIDATION_E_LENGTHMIN;
                 if (pContext)
                 {
                    pContext->SetAt(Param, VALIDATION_E_LENGTHMIN);
                 }
        }


        return dwRet;
    }

    // Specialization for CString so caller doesn't have to cast CString
    template<>
    ATL_NOINLINE DWORD Validate(
        LPCSTR Param,
        CString* pstrValue,
        int nMinChars,
        int nMaxChars,
        CValidateContext *pContext) const throw()
    {
        _ATLTRY
        {
            LPCSTR szValue;
            DWORD dwRet = Validate(Param, &szValue, nMinChars, nMaxChars, pContext);
            if (pstrValue && dwRet == VALIDATION_S_OK )
                *pstrValue = szValue;
            return dwRet;
        }
        _ATLCATCHALL()
        {
            return VALIDATION_E_FAIL;
        }
    }

    // Specialization for doubles, uses a different comparison.
    template<>
    ATL_NOINLINE DWORD Validate(
        LPCSTR Param,
        double* pdblValue,
        double dblMinValue,
        double dblMaxValue,
        CValidateContext *pContext) const throw()
    {
        double dblValue;
        DWORD dwRet = Exchange(Param, &dblValue, pContext);
        if (dwRet == VALIDATION_S_OK)
        {
            if (pdblValue)
                *pdblValue = dblValue;
            dwRet = TValidator::Validate(dblValue, dblMinValue, dblMaxValue);
            if (pContext && dwRet != VALIDATION_S_OK)
                pContext->AddResult(Param, dwRet);
        }
        else if (dwRet == VALIDATION_S_EMPTY &&
                 (dblMinValue < -ATL_EPSILON ||
                 dblMinValue > ATL_EPSILON))
        {
            dwRet = VALIDATION_E_LENGTHMIN;
            if (pContext)
            {
                pContext->SetAt(Param, VALIDATION_E_LENGTHMIN);
            }
        }
        return dwRet;
    }
};


// Cookies provide a way for a server to store a small amount of data on a client
// and have that data returned to it on each request the client makes.
// Use this class to represent a cookie to be sent from the server to a client
// or to represent a cookie that has been returned by a client to the originating server.
//
// At the HTTP level, a cookie is an application-defined name-value pair
// plus some standard attribute-value pairs that describe the way in which the user agent (web browser)
// should interact with the cookie. The HTTP format of a cookie is described in RFC 2109.
//
// The CCookie class provides methods to set and get the application-defined name and value
// as well as methods for the standard attributes. In addition, CCookie provides an abstraction
// on top of the application-defined value that allows it to be treated as a collection of name-value
// pairs if that model makes sense to you. Cookies with a single value are known as single-valued cookies.
// Cookies whose value consists of name-value pairs are known as multi-valued cookies or dictionary cookies.
//
// You can set the name of a cookie by calling SetName or using the appropriate constructor.
// The name of a cookie can be 0 or more characters.
//
// You can set the value of a cookie by calling SetValue or using the appropriate constructor.
// If the cookie has a value set, it is a single-valued cookie and attempts to add a name-value pair will fail.
// You can remove the value of a cookie by calling SetValue(NULL).
//
// You can add a name-value pair to a cookie by calling AddValue.
// If the cookie has any name-value pairs, it is a multi-valued cookie and attempts to set the primary value will fail.
// You can remove all the name-value pairs of a cookie by calling RemoveAllValues.
//
// Class CCookie follows the same rules for creating cookies as ASP does.
class CCookie :
    public CValidateObject<CCookie>
{
    typedef CStringA elemType;

    typedef CAtlMap<elemType, elemType, CStringElementTraits<elemType>,
        CStringElementTraits<elemType> > mapType;
public:
    // Constructs a named cookie.
    CCookie(LPCSTR szName) throw(...)
    {
        SetName(szName);
    }

    // Constructs a single-valued cookie.
    CCookie(LPCSTR szName, LPCSTR szValue) throw(...)
    {
        SetName(szName);
        SetValue(szValue);
    }

    CCookie(const CCookie& thatCookie) throw(...)
    {
        Copy(thatCookie);
    }

    CCookie& operator=(const CCookie& thatCookie) throw(...)
    {
        return Copy(thatCookie);
    }

    CCookie() throw()
    {

    }

    BOOL IsEmpty() const throw()
    {
        return m_strName.IsEmpty();
    }

    // Call this function to set the name of this cookie.
    // Returns TRUE on success, FALSE on failure.
    // The name of a cookie cannot contain whitespace, semicolons or commas.
    // The name should not begin with a dollar sign ($) since such names are reserved for future use.
    BOOL SetName(LPCSTR szName) throw()
    {
		_ATLTRY
		{
			if (szName && *szName)
			{
				m_strName = szName;
				return TRUE;
			}
		}
		_ATLCATCHALL()
		{
		}
        return FALSE;
    }

    // Call this function to retrieve the name of this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL GetName(LPSTR szBuff, DWORD *pdwSize) const throw()
    {
        return CopyCString(m_strName, szBuff, pdwSize);
    }
    
    // Call this function to retrieve the name of this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL GetName(CStringA &szName) const throw(...)
    {
        szName = m_strName;
        return TRUE;
    }

    // Call this function to set the value of this cookie.
    // Returns TRUE on success, FALSE on failure.
    // Will fail if the cookie is multi-valued.
    // Pass NULL to remove the cookie's value.
    BOOL SetValue(LPCSTR szValue) throw(...)
    {
        if (m_Values.GetCount())
            return FALSE; //already dictionary values in the cookie

        if (!szValue)
            m_strValue.Empty();
        else 
            m_strValue = szValue;

        return TRUE;
    }

    // Call this function to retrieve the value of this cookie.
    // Returns TRUE on success, FALSE on failure.
    // Returns TRUE if there is no value or the value is of zero length.
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetValue(LPSTR szBuff, DWORD *pdwSize) const throw()
    {
        return CopyCString(m_strValue, szBuff, pdwSize);
    }

    // Call this function to retrieve the value of this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL GetValue(CStringA &strValue) const throw()
    {
		_ATLTRY
		{
			strValue = m_strValue;
			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;        
    }

    // Call this function to add a name-value pair to the cookie.
    // Returns TRUE on success, FALSE on failure.
    // Will fail if the cookie is single-valued.
    // If the named value is already present in the cookie, calling this function
    // will modify the current value, otherwise a new name-value pair is added to the cookie.
    // Call RemoveValue or RemoveAllValues to remove the name-value pairs
    // added by this function.
    BOOL AddValue(LPCSTR szName, LPCSTR szValue) throw()
    {
        if (m_strValue.GetLength())
            return FALSE;
        _ATLTRY
		{
        return m_Values.SetAt(szName, szValue) != NULL;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }
    
    // Call this function to modify a name-value pair associated with the cookie.
    // Returns TRUE on success, FALSE on failure.
    // Will fail if the cookie is single-valued.
    // This function just calls AddValue so the name-value pair will be added if not already present.
    // Use this function instead of AddValue to document the intentions of your call. 
    BOOL ModifyValue(LPCSTR szName, LPCSTR szValue) throw()
    {
        return AddValue(szName, szValue);
    }

    // Call this function to remove a name-value pair from the collection managed by this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL RemoveValue(LPCSTR szName) throw()
    {
        return m_Values.RemoveKey(szName);
    }

    // Call this function to remove all the name-value pairs from the collection managed by this cookie.
    void RemoveAllValues() throw()
    {
        m_Values.RemoveAll();
    }

    // Call this function to add an attribute-value pair to the collection of attributes for this cookie.
    // Returns TRUE on success, FALSE on failure.
    // This function is equivalent to calling ModifyAttribute.
    // Both functions will add the attribute if not already present or
    // change its value if it has already been applied to the cookie.
    BOOL AddAttribute(LPCSTR szName, LPCSTR szValue) throw()
    {
        if (!szName || !*szName || !szValue)
            return FALSE;

		_ATLTRY
		{
        return (m_Attributes.SetAt(szName, szValue) != NULL);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
        
    }

    // Call this function to modify an attribute-value pair associated with the cookie.
    // Returns TRUE on success, FALSE on failure.
    // This function is equivalent to calling AddAttribute.
    // Both functions will add the attribute if not already present or
    // change its value if it has already been applied to the cookie.
    BOOL ModifyAttribute(LPCSTR szName, LPCSTR szValue) throw()
    {
        return AddAttribute(szName, szValue);
    }

    // Call this function to remove an attribute-value pair from the collection of attributes managed by this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL RemoveAttribute(LPCSTR szName) throw()
    {
        return m_Attributes.RemoveKey(szName);
    }

    // Call this function to remove all the attribute-value pairs from the collection of attributes managed by this cookie.
    void RemoveAllAttributes() throw()
    {
        m_Attributes.RemoveAll();
    }


    // Call this function to set the Comment attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Comment attribute allows a web server to document its
    // intended use of a cookie. This information may be displayed
    // by supporting browsers so that the user of the web site can
    // decide whether to initiate or continue a session with this cookie.
    // This attribute is optional.
    // Version 1 attribute.
    BOOL SetComment(LPCSTR szComment) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("comment", szComment);
        return bRet;
    }

    // Call this function to set the CommentUrl attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The CommentUrl attribute allows a web server to document its intended 
    // use of a cookie via a URL that the user of the web site can navigate to.
    // The URL specified here should not send further cookies to the client to
    // avoid frustrating the user.
    // This attribute is optional.
    // Version 1 attribute.
    BOOL SetCommentUrl(LPCSTR szUrl) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("commenturl", szUrl);
        return bRet;
    }

    // Call this function to add or remove the Discard attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Discard attribute does not have a value.
    // Call SetDiscard(TRUE) to add the Discard attribute
    // or SetDiscard(FALSE) to remove the Discard attribute.
    // Setting the Discard attribute tells a web browser that it should
    // discard this cookie when the browser exits regardless of the 
    // value of the Max-Age attribute.
    // This attribute is optional.
    // When omitted, the default behavior is that the Max-Age attribute
    // controls the lifetime of the cookie.
    // Version 1 attribute.
    BOOL SetDiscard(BOOL bDiscard) throw()
    {
        BOOL bRet = FALSE;
        LPCSTR szKey = "Discard";
        bRet = SetVersion(1);
        if (bRet)
        {
            if (bDiscard == 0)
            {
                bRet = m_Attributes.RemoveKey(szKey);
            }
            else
            {
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
            }
        }
        return bRet;
    }

    // Call this function to set the Domain attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Domain attribute is used to indicate the domain to which the current 
    // cookie applies. Browsers should only send cookies back to the relevant domains.
    // This attribute is optional.
    // When omitted, the default behavior is for
    // browsers to use the full domain of the server originating the cookie. You can
    // set this attribute value explicitly if you want to share cookies among several servers.
    // Version 0 & Version 1 attribute.
    BOOL SetDomain(LPCSTR szDomain) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("domain", szDomain);
        return bRet;
    }

    // Call this function to set the Max-Age attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The value of the Max-Age attribute is a lifetime in seconds for the cookie.
    // When the time has expired, compliant browsers will discard this cookie
    // (if they haven't already done so as a result of the Discard attribute).
    // If Max-Age is set to zero, the browser discards the cookie immediately.
    // This attribute is the Version 1 replacement for the Expires attribute.
    // This attribute is optional.
    // When omitted, the default behavior is for browsers to discard cookies
    // when the user closes the browser.
    // Version 1 attribute.
    BOOL SetMaxAge(UINT nMaxAge) throw()
    {
        BOOL bRet = FALSE;
        bRet = SetVersion(1);
        if (bRet)
        {
            CHAR buff[20];
            if (_itoa(nMaxAge, buff, 10))
            {
                bRet = AddAttribute("max-age", buff);
            }
        }
        return bRet;
    }

    // Call this function to set the Path attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Path attribute specifies the subset of URLs to which this cookie applies.
    // Only URLs that contain that path are allowed to read or modify the cookie. 
    // This attribute is optional.
    // When omitted the default behavior is for browsers to treat the path of a cookie
    // as the path of the request URL that generated the Set-Cookie response, up to,
    // but not including, the right-most /.
    // Version 0 & Version 1 attribute.
    BOOL SetPath(LPCSTR szPath) throw()
    {   
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("path", szPath);
        return bRet;
    }

    // Call this function to set the Port attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Port attribute specifies the port to which this cookie applies.
    // Only URLs accessed via that port are allowed to read or modify the cookie. 
    // This attribute is optional.
    // When omitted the default behavior is for browsers to return the cookie via any port.
    // Version 1 attribute.
    BOOL SetPort(LPCSTR szPort) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("port", szPort);
        return bRet;
    }

    // Call this function to add or remove the Secure attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Secure attribute does not have a value.
    // Call SetSecure(TRUE) to add the Secure attribute
    // or SetSecure(FALSE) to remove the Secure attribute.
    // Setting the Secure attribute tells a browser that it should
    // transmit the cookie to the web server only via secure means such as HTTPS.
    // This attribute is optional.
    // When omitted, the default behavior is that the cookie
    // will be sent via unsecured protocols.
    // Version 0 & Version 1 attribute.
    BOOL SetSecure(BOOL bSecure) throw()
    {
        BOOL bRet = FALSE;
        LPCSTR szKey = "secure";
        bRet = SetVersion(1);
        if (bRet)
        {
            if (bSecure == 0)
            {
                bRet = m_Attributes.RemoveKey(szKey);
            }
            else
            {
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
            }
        }
        return bRet;
    }

    // Call this function to set the Version attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // This attribute is required for Version 1 cookies by RFC 2109 and must have a value of 1.
    // However, you do not need to call SetVersion explicitly from your own code unless you need to
    // force RFC 2109 compliance. CCookie will automatically set this attribute whenever
    // you use a Version 1 attribute in your cookie.
    // Version 1 attribute.
    BOOL SetVersion(UINT nVersion) throw()
    {
        BOOL bRet = FALSE;      
        CHAR buff[20];
        if (_itoa(nVersion, buff, 10))
        {
            bRet = AddAttribute("version", buff);
        }
        return bRet;
    }

    // Call this function to set the Expires attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Expires attribute specifies an absolute date and time at which this cookie
    // should be discarded by web browsers. Pass a SYSTEMTIME holding a Greenwich Mean Time (GMT)
    // value or a string in the following format:
    //      Wdy, DD-Mon-YY HH:MM:SS GMT
    // This attribute is optional.
    // When omitted, the default behavior is for browsers to discard cookies
    // when the user closes the browser.
    // This attribute has been superceded in Version 1 by the Max-Age attribute,
    // but you should continue to use this attribute for Version 0 clients.
    // Version 0 attribute.
    BOOL SetExpires(LPCSTR szExpires) throw()
    {
        return AddAttribute("expires", szExpires);
    }

    BOOL SetExpires(const SYSTEMTIME &st) throw()
    {
		_ATLTRY
		{
			CFixedStringT<CStringA, ATLS_MAX_HTTP_DATE> strTime;
			SystemTimeToHttpDate(st, strTime);
			return SetExpires(strTime);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to look up the value of a name-value pair applied to this cookie.
    // Returns the requested value if present or NULL if the name was not found.
    LPCSTR Lookup(LPCSTR szName=NULL) const throw()
    {
        if (IsEmpty())
            return NULL;

		if (!szName && m_strValue.GetLength())
			return m_strValue;

        if (m_Values.GetCount())
        {
            const mapType::CPair *pPair = m_Values.Lookup(szName);
            if (pPair)
                return (LPCSTR)pPair->m_value;
        }

        return NULL;
    }

    // Call this function to clear the cookie of all content
    // including name, value, name-value pairs, and attributes.
    void Empty() throw()
    {
        m_strName = "";
        m_strValue = "";
        m_Attributes.RemoveAll();
        m_Values.RemoveAll();
    }

     // Call this function to create a CCookie from a buffer.
     // The passed in buffer contains a cookie header retrieved
     // from the HTTP_COOKIE request variable
     //
     // review: support MBCS cookie values?
     ATL_NOINLINE bool Parse(LPSTR pstart) throw()
     {
        //pStart points to the beginning of the cookie
        //pEnd points to the character just past the end of the cookie.
        //cookie is in the form name=value
        LPSTR pEnd = pstart;
        LPSTR pStart = pstart;
        int index = 0;
        LPSTR pTokens[16];
        CStringA strName, name, value;

        while (*pEnd != '&' && *pEnd != ';' && *pEnd != '\0')
            pEnd++;

        int nCount = CountOf('=', pStart, pEnd);
        
        if (nCount == 2)
        {
            //first token is name, next tokens are first name/value in
            //the Values collection
            pEnd = pStart;
            index = 1;
            pTokens[0]=pStart;
            while (*pEnd != '&' && *pEnd != ';' && *pEnd != '\0')
            {
                if (*pEnd == '=')
                {
                    pTokens[index++] = pEnd;
                }                   
                pEnd++;
            }

            CopyToCString(strName, pTokens[0], pTokens[1]-1);
            CopyToCString(name, pTokens[1]+1, pTokens[2]-1);
            CopyToCString(value, pTokens[2]+1, pEnd-1);
			_ATLTRY
			{
				m_strName = strName;
				AddValue(name, value);
			}
			_ATLCATCHALL()
			{
				return false;
			}
        }
        else if (nCount == 1)
        {
            LPSTR pCurr = pStart;
            index = 1;
            pTokens[0] = pStart;
            while (pCurr != pEnd)
            {
                if (*pCurr == '=')
                {
                    pTokens[index] = pCurr;
                }                   
                pCurr++;
            }
            CopyToCString(name, pTokens[0], pTokens[1]-1);
            CopyToCString(value, pTokens[1]+1, pEnd-1);
			_ATLTRY
			{
				m_strName = name;
				m_strValue = value;
			}
			_ATLCATCHALL()
			{
				return false;
			}
		
        }
        else if (nCount == 0)
        {
            // no value
            if (pEnd > pStart)
            {
                CopyToCString(name, pStart, pEnd-1);
				_ATLTRY
				{
					m_strName = name;
					m_strValue = "";
				}
				_ATLCATCHALL()
				{
					return false;
				}
            }
        }
        else
            return false; //error in cookie

        if (*pEnd == '&')
        {
            //still have name/values to parse
            pStart = pEnd+1;
            pEnd = pStart;
            while(1)
            {
                if (*pEnd == '=') //separates the name from the value
                    pTokens[0] = pEnd;
                //Marks either the end of the name/values or    
                //the end of the name/value statement
                if (*pEnd == '&' || *pEnd == ';' || *pEnd == '\0')
                {
                    CopyToCString(name, pStart, pTokens[0]-1);
                    CopyToCString(value, pTokens[0]+1, pEnd-1);
                    AddValue(name, value);
                    pStart = pEnd+1;
                }

                if (*pEnd == ';' || *pEnd =='\0')
                    break;

                pEnd++;
            }
        }
         
        m_strName.TrimRight();
        m_strName.TrimLeft();
        m_strValue.TrimRight();
        m_strValue.TrimLeft();
        return true;
     }

    // Call this function to render this cookie
    // into a buffer. Returns TRUE on success, FALSE on failure.
    // On entry, pdwLen should point to a DWORD that indicates 
    // the size of the buffer in bytes. On exit, the DWORD contains
    // the number of bytes transferred or available to be transferred
    // into the buffer (including the nul-terminating byte). On
    // success, the buffer will contain the correct HTTP 
    // representation of the current cookie suitable for sending to 
    // a client as the body of a Set-Cookie header.
    ATL_NOINLINE BOOL Render(LPSTR szCookieBuffer, DWORD *pdwLen) const throw()
    {
        CStringA strCookie;
        CStringA name, value;
        DWORD nLenBuff = *pdwLen;
        *pdwLen = 0;

        // A cookie must have a name!
        if (!m_strName.GetLength())
        {
            *pdwLen = 0;
            return FALSE;
        }
		_ATLTRY
		{
			strCookie = m_strName;
			int nValSize = (int) m_Values.GetCount();

			//add value or name/value pairs.
			if (m_strValue.GetLength())
			{
				strCookie += '=';
				strCookie += m_strValue;
			}
			else if (nValSize)
			{
				strCookie += '=';
				POSITION pos = m_Values.GetStartPosition();
				for (int i=0; pos; i++)
				{
					m_Values.GetNextAssoc(pos, name, value);
					strCookie += name;
					if (value.GetLength())
					{
						strCookie += '=';
						strCookie += value;
					}
					if (i <= nValSize-2)
						strCookie += '&';
				}
			}

			CStringA strAttributes;
			if (!RenderAttributes(strAttributes))
				return FALSE;
			if (strAttributes.GetLength() > 0)
			{
				strCookie += "; ";
				strCookie += strAttributes;
			}
	        
			DWORD dwLenCookie = strCookie.GetLength() + 1;
			if (dwLenCookie > nLenBuff)
			{
				*pdwLen = dwLenCookie;
				return FALSE; //buffer wasn't big enough
			}

			*pdwLen = dwLenCookie - 1;
			strcpy(szCookieBuffer, strCookie);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

        return TRUE;
    }

    POSITION GetFirstAttributePos() const throw()
    {
        return m_Attributes.GetStartPosition();
    }

    const elemType& GetNextAttributeName(POSITION& pos) const throw()
    {
        return m_Attributes.GetNextKey(pos);
    }

	const elemType& GetAttributeValueAt(POSITION pos) const throw()
	{
		return m_Attributes.GetValueAt(pos);
	}

    BOOL GetNextAttrAssoc(POSITION& pos, elemType& key,
        elemType& val) const throw()
    {
		_ATLTRY
		{
			m_Attributes.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }

    POSITION GetFirstValuePos() const throw()
    {
        return m_Values.GetStartPosition();
    }

    const elemType& GetNextValueName(POSITION& pos) const throw()
    {
        return m_Values.GetNextKey(pos);
    }

    const elemType& GetValueAt(POSITION pos) const throw()
    {
        return m_Values.GetValueAt(pos);
    }
	
	BOOL GetNextValueAssoc(POSITION& pos, elemType& key,
        elemType& val) const throw()
    {
		_ATLTRY
		{
			m_Values.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }

protected:
// Implementation
    BOOL RenderAttributes(CStringA& strAttributes) const throw()
    {
		_ATLTRY
		{
			strAttributes = "";

			POSITION pos = m_Attributes.GetStartPosition();
			CStringA key, val;
			for (int i=0; pos; i++)
			{
				if (i)
					strAttributes += ";";
				m_Attributes.GetNextAssoc(pos, key, val);
				strAttributes += key;
				strAttributes += '=';
				strAttributes += val;
			}
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }
private:
    CCookie& Copy(const CCookie& thatCookie) throw(...)
    {
        m_strName = thatCookie.m_strName;
        m_strValue = thatCookie.m_strValue;
        POSITION pos = NULL;
        CStringA strName, strValue;
        if (!thatCookie.m_Attributes.IsEmpty())
        {
            pos = thatCookie.m_Attributes.GetStartPosition();
            while (pos)
            {
                thatCookie.m_Attributes.GetNextAssoc(pos, strName, strValue);
                m_Attributes.SetAt(strName, strValue);
            }
        }
        if (!thatCookie.m_Values.IsEmpty())
        {
            strName.Empty();
            strValue.Empty();
            pos = thatCookie.m_Values.GetStartPosition();
            while (pos)
            {
                thatCookie.m_Values.GetNextAssoc(pos, strName, strValue);
                m_Values.SetAt(strName, strValue);
            }
        }
        return *this;
    }

public:
    // These are implementation only, use at your own risk!
    // Map of attribute-value pairs applied to this cookie.
    mapType m_Attributes;

    // Map of name-value pairs applied to this cookie.
    mapType m_Values;

    // The name of this cookie.
    CStringA m_strName;

    // The value of this cookie.
    CStringA m_strValue;

};  // class CCookie

class CSessionCookie : public CCookie
{
public:
    CSessionCookie() throw(...)
    {
        if (!SetName(SESSION_COOKIE_NAME) &&
			!SetPath("/"))
			AtlThrow(E_OUTOFMEMORY);
    }

    CSessionCookie(LPCSTR szSessionID) throw(...)
    {
        if (!SetName(SESSION_COOKIE_NAME) &&
			!SetPath("/") &&
			!SetSessionID(szSessionID) )
			AtlThrow(E_OUTOFMEMORY);
    }

    BOOL SetSessionID(LPCSTR szSessionID) throw()
    {
        ATLASSERT(szSessionID && szSessionID[0]);
        return SetValue(szSessionID);
    }
}; // class CSessionCookie

template<>
class CElementTraits< CCookie > :
    public CElementTraitsBase< CCookie >
{
public:
    typedef const CCookie& INARGTYPE;
    typedef CCookie& OUTARGTYPE;
    
    static ULONG Hash( INARGTYPE cookie )
    {
        return CStringElementTraits<CStringA>::Hash( cookie.m_strName );
    }

    static bool CompareElements( INARGTYPE cookie1, INARGTYPE cookie2 )
    {
        return( cookie1.m_strName == cookie2.m_strName );
    }

    static int CompareElementsOrdered( INARGTYPE cookie1, INARGTYPE cookie2 )
    {
        return( cookie1.m_strName.Compare( cookie2.m_strName ) );
    }
};

///////////////////////////////////////////////////////////////////////////////
// Request and response classes and support functions


// This class is a wrapper for CAtlMap that allows maps to be chained.
// It simply adds a bool that tells whether or not a map shares values
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpMap
{
private:

#ifdef ATL_HTTP_PARAM_MULTIMAP
	typedef CRBMultiMap<K, V, KTraits, VTraits> MAPTYPE;
#else
	typedef CAtlMap<K, V, KTraits, VTraits> MAPTYPE;
#endif // ATL_HTTP_PARAM_MULTIMAP

public:

	typedef KTraits::INARGTYPE KINARGTYPE;
	typedef KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef VTraits::INARGTYPE VINARGTYPE;
	typedef VTraits::OUTARGTYPE VOUTARGTYPE;

	typedef MAPTYPE::CPair CPair;

private:

	bool m_bShared;
	
	MAPTYPE m_map;
	
public:

	CHttpMap() throw()
		: m_bShared(false)
	{
	}

	virtual ~CHttpMap()
	{
	}

	inline bool IsShared() const throw()
	{
		return m_bShared;
	}

	inline void SetShared(bool bShared) throw()
	{
		m_bShared = bShared;
	}

	//
	// exposed lookup and iteration functionality
	//

	inline size_t GetCount() const throw()
	{
		return m_map.GetCount();
	}

	inline bool IsEmpty() const throw()
	{
		return m_map.IsEmpty();
	}

	inline POSITION GetStartPosition() const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.GetHeadPosition();
#else
		return m_map.GetStartPosition();
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// Lookup wrappers
	bool Lookup( KINARGTYPE key, VOUTARGTYPE value ) const throw()
	{
		_ATLTRY
		{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		CPair *p = Lookup(key);
		if (p != NULL)
		{
			value = p->m_value;
			return true;
		}
		return false;
#else
		return m_map.Lookup(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
		}
		_ATLCATCHALL()
		{
			return false;
		}
	}

	const CPair* Lookup( KINARGTYPE key ) const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	CPair* Lookup( KINARGTYPE key ) throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// iteration wrappers
	void GetNextAssoc( POSITION& pos, KOUTARGTYPE key, VOUTARGTYPE value ) const throw(...)
	{
		m_map.GetNextAssoc(pos, key, value);
	}

	const CPair* GetNext( POSITION& pos ) const throw()
	{
		return m_map.GetNext(pos);
	}

	CPair* GetNext( POSITION& pos ) throw()
	{
		return m_map.GetNext(pos);
	}

	const K& GetNextKey( POSITION& pos ) const throw()
	{
		return m_map.GetNextKey(pos);
	}

	const V& GetNextValue( POSITION& pos ) const throw()
	{
		return m_map.GetNextValue(pos);
	}

	V& GetNextValue( POSITION& pos ) throw()
	{
		return m_map.GetNextValue(pos);
	}

	void GetAt( POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value ) const throw(...)
	{
		return m_map.GetAt(pos, key, value);
	}

	CPair* GetAt( POSITION pos ) throw()
	{
		return m_map.GetAt(pos);
	}

	const CPair* GetAt( POSITION pos ) const throw()
	{
		return m_map.GetAt(pos);
	}

	const K& GetKeyAt( POSITION pos ) const throw()
	{
		return m_map.GetKeyAt(pos);
	}

	const V& GetValueAt( POSITION pos ) const throw()
	{
		return m_map.GetValueAt(pos);
	}

	V& GetValueAt( POSITION pos ) throw()
	{
		return m_map.GetValueAt(pos);
	}

	// modification wrappers
	POSITION SetAt( KINARGTYPE key, VINARGTYPE value ) throw(...)
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.Insert(key, value);
#else
		return m_map.SetAt(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	virtual void RemoveAll() throw()
	{
		m_map.RemoveAll();
	}
};

// This class is a wrapper for CHttpMap that assumes it's values are pointers that
// should be deleted on RemoveAll
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpPtrMap : public CHttpMap<K, V, KTraits, VTraits>
{
public:
	typedef CHttpMap<K, V, KTraits, VTraits> Base;

	void RemoveAll() throw()
	{
		if (!IsShared())
		{
			POSITION pos = GetStartPosition();
			while (pos)
			{
				GetNextValue(pos)->Release();
			}
		}
		Base::RemoveAll();
	}

	~CHttpPtrMap() throw()
	{
		RemoveAll();
	}
};

// This class represents a collection of request parameters - the name-value pairs
// found, for example, in a query string or in the data provided when a form is submitted to the server.
// Call Parse to build the collection from a string of URL-encoded data.
// Use the standard collection methods of the CSimpleMap base class to retrieve the
// decoded names and values.
// Use the methods of the CValidateObject base class to validate the parameters.
class CHttpRequestParams : 
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
    public CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> >, 
#else
    public CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> >, 
#endif
    public CValidateObject<CHttpRequestParams>
{
public:
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
    typedef CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> > BaseMap;
#else
	typedef CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> > BaseMap;
#endif

    LPCSTR Lookup(LPCSTR szName) const throw()
    {
        if (!szName)
            return NULL;

        const CPair *p = BaseMap::Lookup(szName);
        if (p)
        {
            return p->m_value;
        }
        return NULL;
    }

    // Call this function to build a collection of name-value pairs from a string of URL-encoded data.
    // Returns TRUE on success, FALSE on failure.
    // URL-encoded data:
    //      Each name-value pair is separated from the next by an ampersand (&)
    //      Each name is separated from its corresponding value by an equals signs (=)
    //      The end of the data to be parsed is indicated by a nul character (\0) or a pound symbol (#)
    //      A plus sign (+) in the input will be decoded as a space
    //      A percent sign (%) in the input signifies the start of an escaped octet.
    //          The next two digits represent the hexadecimal code of the character.
    //          For example, %21 is the escaped encoding for the US-ASCII exclamation mark and will be decoded as !.
    // Common sources of URL-encoded data are query strings and the bodies of POST requests with content type of application/x-www-form-urlencoded.
    //
    // Parse and Render are complementary operations.
    // Parse creates a collection from a string.
    // Render creates a string from a collection.
    ATL_NOINLINE BOOL Parse(LPSTR szQueryString) throw()
    {
        while (szQueryString && *szQueryString)
        {
            LPSTR szUrlCurrent = szQueryString;
            LPSTR szName = szUrlCurrent;
            LPSTR szPropValue;

            while (*szQueryString)
            {
                if (*szQueryString == '=')
                {
                    szQueryString++;
                    break;
                }
                if (*szQueryString == '&')
                {
                    break;
                }
                if (*szQueryString == '+')
                    *szUrlCurrent = ' ';
                else if (*szQueryString == '%')
                {
                    // if there is a % without two characters
                    // at the end of the url we skip it
                    if (*(szQueryString+1) && *(szQueryString+2))
                    {
                        CHAR szCharCode[3];
                        szCharCode[0] = *(szQueryString+1);
                        szCharCode[1] = *(szQueryString+2);
                        szCharCode[2] = '\0';
                        LPSTR szEnd;
                        *szUrlCurrent = (CHAR) strtoul(szCharCode, &szEnd, 16);
                        szQueryString += 2;
                    }
                    else
                        *szUrlCurrent = '\0';
                }
                else
                    *szUrlCurrent = *szQueryString;

                szQueryString++;
                szUrlCurrent++;
            }

            if (*szUrlCurrent)
                *szUrlCurrent++ = '\0';

            // we have the property name
            szPropValue = szUrlCurrent;
            while (*szQueryString && *szQueryString != '#')
            {
                if (*szQueryString == '&')
                {
                    szQueryString++;
                    break;
                }
                if (*szQueryString == '+')
                    *szUrlCurrent = ' ';
                else if (*szQueryString == '%')
                {
                    // if there is a % without two characters
                    // at the end of the url we skip it
                    if (*(szQueryString+1) && *(szQueryString+2))
                    {
                        CHAR szCharCode[3];
                        szCharCode[0] = *(szQueryString+1);
                        szCharCode[1] = *(szQueryString+2);
                        szCharCode[2] = '\0';
                        LPSTR szEnd;
                        *szUrlCurrent = (CHAR) strtoul(szCharCode, &szEnd, 16);
                        szQueryString += 2;
                    }
                    else
                        *szUrlCurrent = '\0';
                }
                else
                    *szUrlCurrent = *szQueryString;
                szQueryString++;
                szUrlCurrent++;
            }
            // we have the value
            *szUrlCurrent = '\0';
            szUrlCurrent++;
			_ATLTRY
			{
				SetAt(szName, szPropValue);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
        }
        return TRUE;
    }

    // Call this function to render the map of names and values into a buffer as a URL-encoded string.
    // Returns TRUE on success, FALSE on failure.
    // On entry, pdwLen should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    // On success, the buffer will contain the correct URL-encoded representation of the current object
    // suitable for sending to a server as a query string or in the body of a form.
    // URL-encoding:
    //      Each name-value pair is separated from the next by an ampersand (&)
    //      Each name is separated from its corresponding value by an equals signs (=)
    //      A space is encoded as a plus sign (+).
    //      Other unsafe characters (as determined by AtlIsUnsafeUrlChar) are encoded as escaped octets.
    //      An escaped octet is a percent sign (%) followed by two digits representing the hexadecimal code of the character.
    //
    // Parse and Render are complementary operations.
    // Parse creates a collection from a string.
    // Render creates a string from a collection.
    ATL_NOINLINE BOOL Render(LPSTR szParameters, LPDWORD pdwLen) throw()
    {
        ATLASSERT(szParameters);
        ATLASSERT(pdwLen);
		_ATLTRY
		{
			if (GetCount() == 0)
			{
				*szParameters = '\0';
				*pdwLen = 0;
				return TRUE;
			}

			CStringA strParams;
			POSITION pos = GetStartPosition();
			while (pos != NULL)
			{
				LPCSTR szBuf = GetKeyAt(pos);
				EscapeToCString(strParams, szBuf);
				szBuf = GetValueAt(pos);
				if (*szBuf)
				{
					strParams+= '=';
					EscapeToCString(strParams, szBuf);
				}
				strParams+= '&';
				GetNext(pos);
			}

			DWORD dwLen = strParams.GetLength();
			strParams.Delete(dwLen-1);
			BOOL bRet = TRUE;
			if (dwLen >= *pdwLen)
			{
				bRet = FALSE;
			}
			else
			{
				dwLen--;
				memcpy(szParameters, static_cast<LPCSTR>(strParams), dwLen);
				szParameters[dwLen] = '\0';
			}

			*pdwLen = dwLen;
			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}	
    }

}; // class CHttpRequestParams

#define MAX_TOKEN_LENGTH (MAX_PATH)

// This class represents the information about a file that has been uploaded to the web server.
class CHttpRequestFile : public IHttpFile
{
protected:

    // The name of the form field used to upload the file.
    CHAR m_szParamName[MAX_TOKEN_LENGTH];

    // The original file name of the uploaded file as set by the client.
    CHAR m_szFileName[MAX_PATH];

    // The original path and file name of the uploaded file as set by the client.
    CHAR m_szFullFileName[MAX_PATH];

    // The MIME type of the uploaded file.
    CHAR m_szContentType[MAX_TOKEN_LENGTH];

    // The name of the uploaded file on the server.
    CHAR m_szTempFileName[MAX_PATH];

    // The size of the file in bytes.
    ULONGLONG m_nFileSize;

public:

    // The constructor.
    CHttpRequestFile(
        LPCSTR pParamName,
        LPCSTR pFileName,
        LPCSTR pTempFileName,
        LPCSTR pContentType, 
        const ULONGLONG& nFileSize) throw()
    {
        ATLASSERT(pFileName);

        m_szParamName[0] = 0;
        m_szFileName[0] = 0;
        m_szTempFileName[0] = 0;
        m_szFullFileName[0] = 0;
        m_szContentType[0] = 0;
        m_nFileSize = nFileSize;

        strcpy(m_szParamName, pParamName);
        strcpy(m_szFullFileName, pFileName);
        strcpy(m_szTempFileName, pTempFileName);

        if (pContentType && *pContentType)
        {
            strcpy(m_szContentType, pContentType);
        }

        // Set m_szFileName to be the file name without the path.
        // This is likely to be the most meaningful part of the 
        // original file name once the file reaches the server.

        LPSTR szTmp = m_szFullFileName;
        LPSTR szFile = m_szFileName;

        while (*szTmp)
        {
            if (*szTmp == '\\')
            {
                szFile = m_szFileName;
            }
            else
            {
                *szFile++ = *szTmp;
            }
            szTmp++;
        }
        *szFile = 0;
    }

    //=======================================
    // IHttpFile interface
    //=======================================
    LPCSTR GetParamName() throw()
    {
        return m_szParamName;
    }

    LPCSTR GetFileName() throw()
    {
        return m_szFileName;
    }

    LPCSTR GetFullFileName() throw()
    {
        return m_szFullFileName;
    }

    LPCSTR GetContentType() throw()
    {
        return m_szContentType;
    }

    LPCSTR GetTempFileName() throw()
    {
        return m_szTempFileName;
    }

    ULONGLONG GetFileSize() throw()
    {
        return m_nFileSize;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
        {
            return E_POINTER;
        }

        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IHttpFile)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IHttpFile*>(this));
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        ATLASSERT( FALSE );
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        delete this;

        return 1;
    }

}; // class CHttpRequestFile


// utility function to ReadData from a ServerContext
ATL_NOINLINE inline 
BOOL ReadClientData(IHttpServerContext *pServerContext, LPSTR pbDest, LPDWORD pdwLen, DWORD dwBytesRead) throw()
{
    ATLASSERT(pServerContext != NULL);
    ATLASSERT(pbDest != NULL);
    ATLASSERT(pdwLen != NULL);

    DWORD dwToRead = *pdwLen;
    DWORD dwAvailableBytes = pServerContext->GetAvailableBytes();
    DWORD dwRead(0);

    // Read from available data first
    if (dwBytesRead < dwAvailableBytes)
    {
        LPBYTE pbAvailableData = pServerContext->GetAvailableData();
        pbAvailableData+= dwBytesRead;
        DWORD dwAvailableToRead = min(dwToRead, dwAvailableBytes-dwBytesRead);
        memcpy(pbDest, pbAvailableData, dwAvailableToRead);
        dwBytesRead+= dwAvailableToRead;
        dwToRead-= dwAvailableToRead;
        pbDest+= dwAvailableToRead;
        dwRead+= dwAvailableToRead;
    }

    DWORD dwTotalBytes = pServerContext->GetTotalBytes();

    // If there is still more to read after the available data is exhausted
    if (dwToRead && dwBytesRead < dwTotalBytes)
    {
        DWORD dwClientBytesToRead = min(pServerContext->GetTotalBytes()-dwBytesRead, dwToRead);
        DWORD dwClientBytesRead = 0;

        // keep on reading until we've read the amount requested
        do
        {
            dwClientBytesRead = dwClientBytesToRead;
            if (!pServerContext->ReadClient(pbDest, &dwClientBytesRead))
            {
                return FALSE;
            }
            dwClientBytesToRead-= dwClientBytesRead;
            pbDest+= dwClientBytesRead;

        } while (dwClientBytesToRead != 0 && dwClientBytesRead != 0);

        dwRead+= dwToRead-dwClientBytesToRead;
    }

    *pdwLen = dwRead;

    return TRUE;
}

#define FORM_BUFFER_SIZE      2048
#define MAX_MIME_LINE_LEN     1024
#define MAX_MIME_BOUNDARY_LEN 128
#define MAX_PARAM_LEN         _MAX_PATH
#define MAX_CONTENT_TYPE_LEN  512

enum ATL_FORM_FLAGS
{
    ATL_FORM_FLAG_NONE = 0,
    ATL_FORM_FLAG_IGNORE_FILES = 1,
    ATL_FORM_FLAG_REFUSE_FILES = 2,
    ATL_FORM_FLAG_IGNORE_EMPTY_FILES = 4,
    ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS = 8,
};

// Use this class to read multipart/form-data from the associated server context
// and generate files as necessary from the data in the body of the request.
class CMultiPartFormParser
{
protected:

    LPSTR                       m_pCurrent;
    LPSTR                       m_pEnd;
    LPSTR                       m_pStart;
    CHAR                        m_szBoundary[MAX_MIME_BOUNDARY_LEN+2];
    CHAR                        m_szSearchBoundary[MAX_MIME_BOUNDARY_LEN+4];
    DWORD                       m_dwBoundaryLen;
    BOOL                        m_bFinished;
    CComPtr<IHttpServerContext> m_spServerContext;

public:
    // The constructor.
    CMultiPartFormParser(IHttpServerContext* pServerContext) throw() :
        m_pCurrent(NULL),
        m_pEnd(NULL),
        m_pStart(NULL),
        m_dwBoundaryLen(0),
        m_bFinished(FALSE),
        m_spServerContext(pServerContext)
    {
        *m_szBoundary = '\0';
    }
    
    ~CMultiPartFormParser() throw()
    {
        // free memory if necessary
        if (m_spServerContext->GetTotalBytes() > m_spServerContext->GetAvailableBytes())
        {
            free(m_pStart);
        }
    }

    // Call this function to read multipart/form-data from the current HTTP request,
    // allowing files to be uploaded to the web server.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // Forms can be sent to a web server using one of two encodings: application/x-www-form-urlencoded or multipart/form-data.
    // In addition to the simple name-value pairs typically associated with
    // application/x-www-form-urlencoded form data, multipart/form-data (as 
    // described in RFC 2388) can also contain files to be uploaded
    // to the web server.
    //
    // This function will generate a physical file for each file contained in the multipart/form-data request body.
    // The generated files are stored in the server's temporary directory as returned by the 
    // GetTempPath API and are named using the GetTempFileName API.
    // The information about each file can be obtained from the elements of the Files array.
    // You can retrieve the original name of the file on the client, the name of the generated file on the server,
    // the MIME content type of the uploaded file, the name of the form field associated with that file, and the size in
    // bytes of the file. All this information is exposed by the CHttpRequestFile objects in the array.
    //
    // In addition to generating files and populating the Files array with information about them,
    // this function also populates the pQueryParams array with the names and values of the other form fields
    // contained in the current request. The file fields are also added to this array. The value of these fields
    // is the full name of the generated file on the server.
    //
    //      Note that files can be generated even if this function returns FALSE unless you specify either the
    //      ATL_FORM_FLAG_IGNORE_FILES or the ATL_FORM_FLAG_REFUSE_FILES flag. If you don't specify one of these
    //      flags, you should always check the Files array for generated files and delete any that are no longer
    //      needed to prevent your web server from running out of disk space.
    //
    // dwFlags can be a combination of one or more of the following values:
    //      ATL_FORM_FLAG_NONE                  Default behavior.
    //      ATL_FORM_FLAG_IGNORE_FILES          Any attempt to upload files is ignored.
    //      ATL_FORM_FLAG_REFUSE_FILES          Any attempt to upload files is treated as a failure. The function will return FALSE.
    //      ATL_FORM_FLAG_IGNORE_EMPTY_FILES    Files with a size of zero bytes are ignored.
    //      ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS   Fields with no content are ignored.
    ATL_NOINLINE BOOL GetMultiPartData(CHttpMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> >& Files,
        CHttpRequestParams* pQueryParams, 
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
    {
        _ATLTRY
        {
            if (!InitializeParser())
            {
                return FALSE;
            }

            //Get to the first boundary
            if (!ReadUntilBoundary())
            {
                return FALSE;
            }
            
            CStringA strParamName;
            CStringA strFileName;
            CStringA strContentType;
            CStringA strData;
            BOOL bFound;

            while (!m_bFinished)
            {
                // look for "name" field
                if (!GetMimeData(strParamName, "name=", sizeof("name=")-1, &bFound) || !bFound)
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }
                
                // see if it's a file
                if (!GetMimeData(strFileName, "filename=", sizeof("filename=")-1, &bFound))
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }
                
                if (bFound)
                {
                    if (dwFlags & ATL_FORM_FLAG_REFUSE_FILES)
                    {
                        return FALSE;
                    }

                    if (!strFileName.GetLength())
                    {
                        ReadUntilBoundary();
                        continue;
                    }
                    
                    if (!GetMimeData(strContentType, "Content-Type:", sizeof("Content-Type:")-1, &bFound, TRUE))
                    {
                        ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                        return FALSE;
                    }
                    
                    // move to the actual uploaded data
                    if (!MoveToData())
                    {
                        ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                        return FALSE;
                    }

                    // if the user doesn't want files, don't save the file
                    if (dwFlags & ATL_FORM_FLAG_IGNORE_FILES)
                    {
                        if (!ReadUntilBoundary(NULL, NULL))
                        {
                            return FALSE;
                        }
                        continue;
                    }

                    CAtlTemporaryFile ctf;
                    HRESULT hr = ctf.Create();
                    if (hr != S_OK)
                        return FALSE;

                    if (!ReadUntilBoundary(NULL, &ctf))
                    {
                        ctf.Close();
                        return FALSE;
                    }
                    ULONGLONG nFileSize = 0;
                    if (ctf.GetSize(nFileSize) != S_OK)
                        return FALSE;

                    if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FILES) && nFileSize == 0)
                    {
                        ctf.Close();
                        continue;
                    }

                    //REVIEW: if exceptions are thrown, the temp file created by ctf is never removed
                    ctf.HandsOff();

                    //REVIEW: pFile always leaks
                    CHttpRequestFile* pFile = NULL;

                    CT2AEX<MAX_PATH+1> szTempFileNameA(ctf.TempFileName());

                    ATLTRY(pFile = new CHttpRequestFile(strParamName, strFileName, szTempFileNameA, strContentType, nFileSize));
                    if (!pFile)
                        return FALSE;

                    Files.SetAt(szTempFileNameA, pFile);
                    pQueryParams->SetAt(strParamName, szTempFileNameA);
                    continue;
                }
                
                // move to the actual uploaded data
                if (!MoveToData())
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }

                if (!ReadUntilBoundary(&strData))
                {
                    return FALSE;
                }

                if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS) && strData.GetLength() == 0)
                    continue;

                pQueryParams->SetAt(strParamName, strData);
            }

            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }

protected:

    // case insensitive substring search -- does not handle multibyte characters
    // allows searching up to a maximum point in a string
    inline char AtlCharLower(char ch) throw()
    {
        if (ch > 64 && ch < 91)
        {
            return ch+32;
        }

        return ch;
    }

    inline char * _stristrex (const char * str1, const char * str2, const char * str1End) throw()
    {
        char *cp = (char *) str1;
        char *s1, *s2;

        if ( !*str2 )
            return((char *)str1);

        while (cp != str1End)
        {
            s1 = cp;
            s2 = (char *) str2;

            while ( s1 != str1End && *s2 && !(AtlCharLower(*s1)-AtlCharLower(*s2)) )
            {
                s1++, s2++;
            }

            if (s1 == str1End)
            {
                return (NULL);
            }

            if (!*s2)
            {
                return (cp);
            }

            cp++;
        }

        return(NULL);
    }

    inline char * _strstrex (const char * str1, const char * str2, const char * str1End) throw()
    {
        char *cp = (char *) str1;
        char *s1, *s2;

        if ( !*str2 )
            return((char *)str1);

        while (cp != str1End)
        {
            s1 = cp;
            s2 = (char *) str2;

            while ( s1 != str1End && *s2 && !((*s1)-(*s2)) )
            {
                s1++, s2++;
            }
            
            if (s1 == str1End)
            {
                return (NULL);
            }

            if (!*s2)
            {
                return (cp);
            }

            cp++;
        }

        return(NULL);
    }

    ATL_NOINLINE BOOL InitializeParser() throw()
    {
        DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();
        
        // if greater than bytes available, allocate necessary space
        if (dwBytesTotal > m_spServerContext->GetAvailableBytes())
        {
			ATLTRYALLOC(m_pStart = (LPSTR) malloc(dwBytesTotal));
            if (!m_pStart)
            {
                return FALSE;
            }
            m_pCurrent = m_pStart;
            DWORD dwLen = dwBytesTotal;
            if (!ReadClientData(m_spServerContext, m_pStart, &dwLen, 0) || dwLen != dwBytesTotal)
            {
                return FALSE;
            }
        }
        else
        {
            m_pStart = (LPSTR) m_spServerContext->GetAvailableData();
        }
        
        m_pCurrent = m_pStart;
        m_pEnd = m_pCurrent + dwBytesTotal;
        
        //get the boundary
        LPCSTR pszContentType = m_spServerContext ? m_spServerContext->GetContentType() : NULL;
        ATLASSERT(pszContentType != NULL);

        LPCSTR pszTmp = strstr(pszContentType, "boundary=");
        if (!pszTmp)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
            return FALSE;
        }

        pszTmp += sizeof("boundary=")-1;
        BOOL bInQuote = FALSE;
        if (*pszTmp == '\"')
        {
            bInQuote = TRUE;
            pszTmp++;
        }

        LPSTR pszMimeBoundary = m_szBoundary;
        *pszMimeBoundary++ = '-';
        *pszMimeBoundary++ = '-';
        m_dwBoundaryLen = 2;
        while (*pszTmp && (bInQuote || IsStandardBoundaryChar(*pszTmp)))
        {
            if (m_dwBoundaryLen >= MAX_MIME_BOUNDARY_LEN)
            {
                ATLTRACE(atlTraceISAPI, 0, _T("Malformed MIME boundary"));
                return FALSE;
            }
            
            if (*pszTmp == '\r' || *pszTmp == '\n')
            {
                if (bInQuote)
                {
                    pszTmp++;
                    continue;
                }
                break;
            }
            if (bInQuote && *pszTmp == '"')
            {
                break;
            }

            *pszMimeBoundary++ = *pszTmp++;
            m_dwBoundaryLen++;
        }
        
        *pszMimeBoundary = '\0';
        m_szSearchBoundary[0] = '\r';
        m_szSearchBoundary[1] = '\n';
        strcpy(m_szSearchBoundary+2, m_szBoundary);
        return TRUE;
    }

    inline BOOL MoveToData() throw()
    {
        LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
        if (!szEnd)
        {
            return FALSE;
        }

        m_pCurrent = szEnd+4;
        if (m_pCurrent >= m_pEnd)
        {
            return FALSE;
        }

        return TRUE;
    }

    inline BOOL GetMimeData(CStringA &str, LPCSTR szField, DWORD dwFieldLen, LPBOOL pbFound, BOOL bIgnoreCase = FALSE) throw()
    {
        _ATLTRY
        {
            ATLASSERT( szField != NULL );
            ATLASSERT( pbFound != NULL );
            
            *pbFound = FALSE;
            
            LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
            if (!szEnd)
            {
                return FALSE;
            }
            
            LPSTR szDataStart = NULL;
            
            if (!bIgnoreCase)
            {
                szDataStart = _strstrex(m_pCurrent, szField, szEnd);
            }
            else
            {
                szDataStart = _stristrex(m_pCurrent, szField, szEnd);
            }

            if (szDataStart)
            {
                szDataStart+= dwFieldLen;
                if (szDataStart >= m_pEnd)
                {
                    return FALSE;
                }
                
                BOOL bInQuote = FALSE;
                if (*szDataStart == '\"')
                {
                    bInQuote = TRUE;
                    szDataStart++;
                }
                
                LPSTR szDataEnd = szDataStart;
                while (!bInQuote && (szDataEnd < m_pEnd) && (*szDataEnd == ' ' || *szDataEnd == '\t'))
                {
                    szDataEnd++;
                }
                
                if (szDataEnd >= m_pEnd)
                {
                    return FALSE;
                }
                
                while (szDataEnd < m_pEnd)
                {
                    if (!IsValidTokenChar(*szDataEnd))
                    {
                        if (*szDataEnd == '\"' || !bInQuote)
                        {
                            break;
                        }
                    }
                    szDataEnd++;
                }
                
                if (szDataEnd >= m_pEnd)
                {
                    return FALSE;
                }
                
                LPSTR szOut = str.GetBuffer((int)(szDataEnd-szDataStart)+1);
                if (!szOut)
                {
                    str.ReleaseBuffer();
                    return FALSE;
                }
                memcpy(szOut, szDataStart, szDataEnd-szDataStart);
                szOut[szDataEnd-szDataStart] = '\0';
                str.ReleaseBuffer((int)(szDataEnd-szDataStart));
                *pbFound = TRUE;
            }
            
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }
    
    ATL_NOINLINE BOOL ReadUntilBoundary(CStringA* pStrData=NULL, CAtlTemporaryFile* pCtf=NULL) throw()
    {
        _ATLTRY
        {
            LPSTR szBoundaryStart = m_pCurrent;
            LPSTR szBoundaryEnd = NULL;
            
            do 
            {
                szBoundaryStart = _strstrex(szBoundaryStart, m_szBoundary, m_pEnd);
                if (szBoundaryStart != m_pStart)
                {
                    if ((szBoundaryStart-m_pStart) >= 2)
                    {
                        if (*(szBoundaryStart-1) != 0x0a && *(szBoundaryStart-2) != 0x0d)
                            continue;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                szBoundaryEnd = szBoundaryStart+m_dwBoundaryLen;
                if (szBoundaryEnd+2 >= m_pEnd)
                {
                    return FALSE;
                }
                if (szBoundaryEnd[0] == '\r' && szBoundaryEnd[1] == '\n')
                {
                    break;
                }
                if (szBoundaryEnd[0] == '-' && szBoundaryEnd[1] == '-')
                {
                    m_bFinished = TRUE;
                    break;
                }
            } while (szBoundaryStart);
            
            if (!szBoundaryStart)
            {
                return FALSE;
            }
            
            szBoundaryStart-= 2;
            if (pStrData)
            {
                LPSTR szData = pStrData->GetBuffer((int)(szBoundaryStart-m_pCurrent)+1);
                if (!szData)
                {
                    pStrData->ReleaseBuffer();
                    return FALSE;
                }
                memcpy(szData, m_pCurrent, (int)(szBoundaryStart-m_pCurrent));
                szData[szBoundaryStart-m_pCurrent] = '\0';
                pStrData->ReleaseBuffer((int)(szBoundaryStart-m_pCurrent));
            }
            if (pCtf)
            {
                if (FAILED(pCtf->Write(m_pCurrent, (DWORD)(szBoundaryStart-m_pCurrent))))
                {
                    return FALSE;
                }
            }
            
            if (!m_bFinished)
            {
                m_pCurrent = szBoundaryEnd+2;
                if (m_pCurrent >= m_pEnd)
                {
                    return FALSE;
                }
            }
            
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }

    static inline BOOL IsStandardBoundaryChar(CHAR ch) throw()
    {
        if ( (ch >= 'A' && ch <= 'Z') ||
             (ch >= 'a' && ch <= 'z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '\'') ||
             (ch == '+')  ||
             (ch == '_')  ||
             (ch == '-')  ||
             (ch == '=')  ||
             (ch == '?') )
        {
            return TRUE;
        }

        return FALSE;
    }

    inline IsValidTokenChar(CHAR ch) throw()
    {
        return ( (ch != 0) && (ch != 0xd) && (ch != 0xa) && (ch != ' ') && (ch != '\"') );
    }

private:
    // Prevents copying.
    CMultiPartFormParser(const CMultiPartFormParser& /*that*/) throw()
    {
        ATLASSERT(FALSE);
    }

    const CMultiPartFormParser& operator=(const CMultiPartFormParser& /*that*/) throw()
    {
        ATLASSERT(FALSE);
        return (*this);
    }
}; // class CMultiPartFormParser


// 48K max form size
#ifndef DEFAULT_MAX_FORM_SIZE
#define DEFAULT_MAX_FORM_SIZE 49152
#endif

// This class provides access to the information contained in an HTTP request submitted to a web server.
//
// CHttpRequest provides access to the query string parameters, form fields, cookies, and files
// that make up an HTTP request, as well as many other important properties of the request.
class CHttpRequest : public IHttpRequestLookup
{
protected:
    // Implementation: Array used to map an HTTP request method (for example, "GET" or "POST")
    // from a string to a numeric constant from the HTTP_METHOD enum (HTTP_METHOD_GET or HTTP_METHOD_HEAD).
    static LPCSTR m_szMethodStrings[];

    // Implementation: The server context.
    CComPtr<IHttpServerContext> m_spServerContext;

    // Implementation: The number of bytes read from the body of the request.
    DWORD m_dwBytesRead;

    // Implementation: TRUE if the request method was POST and the encoding was
    // multipart/form-data, FALSE otherwise.
    BOOL m_bMultiPart;

    // Implementation: Constructor function used to reinitialize all data members.
    void Construct() throw()
    {
        m_spServerContext.Release();
        m_bMultiPart = FALSE;
        m_dwBytesRead = 0;
        if (m_pFormVars != &m_QueryParams)
            delete m_pFormVars;

        m_pFormVars = NULL;
        m_pFormVars = &m_QueryParams;
        m_QueryParams.RemoveAll();
        m_QueryParams.SetShared(false);

        ClearFilesAndCookies();
    }

    void ClearFilesAndCookies() throw()
    {
        m_Files.RemoveAll();
        m_Files.SetShared(false);
        m_requestCookies.RemoveAll();
        m_requestCookies.SetShared(false);
    }

public:

	// Implementation: The collection of query parameters (name-value pairs) obtained from the query string.
    CHttpRequestParams m_QueryParams;

    // Implementation: The collection of form fields (name-value pairs).
    // The elements of this collection are obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    CHttpRequestParams *m_pFormVars;

    // The array of CHttpRequestFiles obtained from the current request.
    // See CHttpRequest::Initialize and CMultiPartFormParser::GetMultiPartData for more information.
    typedef CHttpPtrMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> > FileMap;
    FileMap m_Files;

    // Implementation: The array of cookies obtained from the current request.
    typedef CHttpMap<CStringA, CCookie, CStringElementTraits<CStringA> > CookieMap;
    CookieMap m_requestCookies;

    // Numeric constants for the HTTP request methods (such as GET and POST).
    enum HTTP_METHOD 
    {
        HTTP_METHOD_UNKNOWN=-1,
        HTTP_METHOD_GET,
        HTTP_METHOD_POST,
        HTTP_METHOD_HEAD,
        HTTP_METHOD_DELETE,
        HTTP_METHOD_LINK,
        HTTP_METHOD_UNLINK,
        HTTP_METHOD_DEBUG  // Debugging support for VS7
    };

    // The collection of query parameters (name-value pairs) obtained from the query string.
    // A read-only property.
    __declspec(property(get=GetQueryParams)) const CHttpRequestParams& QueryParams;

    // Returns a reference to the collection of query parameters(name-value pairs) 
    // obtained from the query string.
    const CHttpRequestParams& GetQueryParams() const throw()
    {
        return m_QueryParams;
    }

    // The collection of form fields (name-value pairs).
    // The elements of this collection are obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    // A read-only property.
    __declspec(property(get=GetFormVars)) const CHttpRequestParams& FormVars;

    // Returns a reference to the collection of form fields (name-value pairs)
    // obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    const CHttpRequestParams& GetFormVars() const throw()
    {
        return *m_pFormVars;
    }

    // The default constructor.
    CHttpRequest() throw()
        :m_pFormVars(NULL)
    {
        Construct();
    }

    // Implementation: The destructor.
    ~CHttpRequest() throw()
    {
        DeleteFiles();
        ClearFilesAndCookies();

        if (m_pFormVars != &m_QueryParams)
        {
            delete m_pFormVars;
            m_pFormVars = NULL;
        }
    }

    // Constructs and initializes the object.
    CHttpRequest(
        IHttpServerContext *pServerContext,
        DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw(...)
        :m_pFormVars(NULL)
    {
        Construct();
        if (!Initialize(pServerContext, dwMaxFormSize, dwFlags))
			AtlThrow(E_FAIL);
    }

    CHttpRequest(IHttpRequestLookup *pRequestLookup) throw(...)
        :m_pFormVars(NULL)
    {
        if (!Initialize(pRequestLookup)) // Calls Construct for you
			AtlThrow(E_FAIL);
    }

    //=========================================================================================
    // BEGIN IHttpRequestLoookup interface
    //=========================================================================================
    POSITION GetFirstQueryParam(LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION pos = m_QueryParams.GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_QueryParams.GetKeyAt(pos);
            *ppszValue = m_QueryParams.GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextQueryParam(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION posNext(pos);
        m_QueryParams.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_QueryParams.GetKeyAt(posNext);
            *ppszValue = m_QueryParams.GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstFormVar(LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        // if no form vars and just pointing to the query params,
        // then return NULL
        if (m_pFormVars == &m_QueryParams)
            return NULL;
        
        POSITION pos = m_pFormVars->GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_pFormVars->GetKeyAt(pos);
            *ppszValue = m_pFormVars->GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextFormVar(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION posNext(pos);
        m_pFormVars->GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_pFormVars->GetKeyAt(posNext);
            *ppszValue = m_pFormVars->GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstFile(LPCSTR *ppszName, IHttpFile **ppFile) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppFile != NULL);

        POSITION pos = m_Files.GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_Files.GetKeyAt(pos);
            *ppFile = m_Files.GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextFile(POSITION pos, LPCSTR *ppszName, IHttpFile **ppFile) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppFile != NULL);

        POSITION posNext(pos);
        m_Files.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_Files.GetKeyAt(posNext);
            *ppFile = m_Files.GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstCookie(LPCSTR *ppszName, const CCookie **ppCookie) throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppCookie != NULL);
        POSITION pos = NULL;
        if (GetRequestCookies())
        {
            pos = m_requestCookies.GetStartPosition();
            if (pos != NULL)
            {
                *ppszName = m_requestCookies.GetKeyAt(pos);
                *ppCookie = &(m_requestCookies.GetValueAt(pos));
            }
        }
        return pos;
    }

    POSITION GetNextCookie(POSITION pos, LPCSTR *ppszName, const CCookie **ppCookie) throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppCookie != NULL);

        POSITION posNext(pos);
        m_requestCookies.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_requestCookies.GetKeyAt(posNext);
            *ppCookie = &(m_requestCookies.GetValueAt(posNext));
        }
        return posNext;
    }

    // Returns a pointer to the IHttpServerContext interface for the current request.
    HRESULT GetServerContext(IHttpServerContext ** ppOut) throw()
    {
        return m_spServerContext.CopyTo(ppOut);
    }
    //=========================================================================================
    // END IHttpRequestLookup interface
    //=========================================================================================

    void SetServerContext(IHttpServerContext *pServerContext) throw()
    {
        m_spServerContext = pServerContext;
    }

    BOOL Initialize(IHttpRequestLookup *pRequestLookup) throw()
    {
		_ATLTRY
		{	
			ATLASSERT(pRequestLookup != NULL);
			// if there's no pRequestLookup, just return
			if (!pRequestLookup)
				return TRUE;

			Construct();
			HRESULT hr = pRequestLookup->GetServerContext(&m_spServerContext);
			if (FAILED(hr))
				return FALSE;

			LPCSTR szName(NULL);
			LPCSTR szValue(NULL);

			// Initialize query params from the IHttpRequestLookup*
			POSITION pos(pRequestLookup->GetFirstQueryParam(&szName, &szValue));
			while (pos != NULL)
			{
				m_QueryParams.SetAt(szName, szValue);
				pos = pRequestLookup->GetNextQueryParam(pos, &szName, &szValue);
			}
			m_QueryParams.SetShared(true);

			// Initialize the form vars from the IHttpRequestLookup*
			pos = pRequestLookup->GetFirstFormVar(&szName, &szValue);
			if (pos)
			{
				m_pFormVars = NULL;
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (!m_pFormVars)
					return FALSE;

				while (pos != NULL)
				{
					m_pFormVars->SetAt(szName, szValue);
					pos = pRequestLookup->GetNextFormVar(pos, &szName, &szValue);
				}
				m_pFormVars->SetShared(true);
			}
			else
			{
				m_pFormVars = &m_QueryParams;
			}

			// Initialize the files from the IHttpRequestLookup*
			IHttpFile *pFile(NULL);
			pos = pRequestLookup->GetFirstFile(&szName, &pFile);
			while (pos != NULL)
			{
				m_Files.SetAt(szName, pFile);
				pos = pRequestLookup->GetNextFile(pos, &szName, &pFile);
			}
			m_Files.SetShared(true);

			// Initialzie the cookies form the IHttpRequestLookup*
			BOOL bRet = FALSE;
			CStringA strCookies;
			bRet = GetCookies(strCookies);
			if (bRet)
			{
				bRet = Parse((LPSTR)(LPCSTR)strCookies);
			}
			m_requestCookies.SetShared(false);
			return bRet;
		} // _ATLTRY
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to initialize the object with information about the current request.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // Call Initialize directly or via the appropriate constructor before using the methods and
    // properties of the request object.
    //
    // Initialize does the following:
    //
    //      Parses and decodes the query string into a collection of name-value pairs.
    //      This collection is accessible via the GetQueryParams method or the QueryParams property.
    //
    //      Sets m_bMultiPart to TRUE if the request is a POST request with multipart/form-data encoding.
    //
    //      Parses the body of a POST request if the size of the request data is less than or equal to dwMaxFormSize.
    //      The body of the request will consist of simple form fields and may also contain files if the request is encoded as multipart/form-data.
    //      In that case, the dwFlags parameter is passed to CMultiPartFormParser::GetMultiPartData to control the creation of the files.
    //      The collection of form fields is accessible via the GetFormVars method or the FormVars property.
    //      The collection of files is accessible via the m_Files member.
    //
    // Note that Initialize does not parse the cookies associated with a request.
    // Cookies are not processed until an attempt is made to access a cookie in the collection.
    BOOL Initialize(
        IHttpServerContext *pServerContext,
        DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
    {
		_ATLTRY
		{
			ATLASSERT(pServerContext != NULL);
			if (!pServerContext)
				return FALSE;

			m_spServerContext = pServerContext;

			HTTP_METHOD httpMethod = GetMethod();

			// Parse the query string.
			CHAR szQueryString[ATL_URL_MAX_URL_LENGTH];
			strcpy(szQueryString, GetQueryString());
			if (!m_QueryParams.Parse(szQueryString))
				return FALSE;

			if (m_QueryParams.IsShared())
				return TRUE;

			// If this is a GET request, the collection of form fields
			// is the same as the collection of query parameters.
			if (httpMethod == HTTP_METHOD_GET)
				m_pFormVars = &m_QueryParams;
			else if (httpMethod == HTTP_METHOD_POST)
			{
				LPCSTR szContentType = GetContentType();
				if (!szContentType)
					return FALSE;

				// Don't parse the form data if the size is bigger than the maximum specified.
				if (m_spServerContext->GetTotalBytes() > dwMaxFormSize)
				{
					if (memcmp(szContentType, "multipart/form-data", 19) == 0)
						m_bMultiPart = TRUE;

					m_dwBytesRead = 0;

					// REVIEW : We have to assume the developer knows what they're doing to
					// some extent here.
					return TRUE;
				}

				// If POSTed data is urlencoded, call InitFromPost.
				if (memcmp(szContentType, "application/x-www-form-urlencoded", 33) == 0 && !m_pFormVars->IsShared())
					return InitFromPost();

				// If POSTed data is encoded as multipart/form-data, use CMultiPartFormParser.
				if (memcmp(szContentType, "multipart/form-data", 19) == 0 && !m_pFormVars->IsShared())
				{
					if (m_pFormVars != &m_QueryParams)
						delete m_pFormVars;
					m_pFormVars = NULL;

					CMultiPartFormParser FormParser(m_spServerContext);
					ATLTRY(m_pFormVars = new CHttpRequestParams);
					if (!m_pFormVars)
						return FALSE;

					BOOL bRet = FormParser.GetMultiPartData(m_Files, m_pFormVars, dwFlags);
					return bRet;
				}

				// else initialize m_dwBytesRead for ReadData
				m_dwBytesRead = 0;
			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;

    }

    // Implementation: Call this function to initialize the collection of form fields
    // from the body of an application/x-www-form-urlencoded POST request.
    ATL_NOINLINE BOOL InitFromPost() throw()
    {
		_ATLTRY
		{
			ATLASSERT(m_spServerContext != NULL);

			// create our m_pFormVars
			if (m_pFormVars == NULL || m_pFormVars == &m_QueryParams)
			{
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (m_pFormVars == NULL)
				{
					return FALSE;
				}
			}   

			// read the form data into a buffer
			DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();
			CAutoVectorPtr<CHAR> szBuff;
			if (!szBuff.Allocate(dwBytesTotal+1))
			{
				return FALSE;
			}
			// first copy the available
			BOOL bRet = ReadClientData(m_spServerContext, szBuff, &dwBytesTotal, 0);
			if (bRet)
			{
				szBuff[dwBytesTotal] = '\0';
				bRet = m_pFormVars->Parse(szBuff);
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to remove the files listed in m_Files from the web server's hard disk.
    // Returns the number of files deleted.
    int DeleteFiles() throw()
    {
        int nDeleted = 0;
        POSITION pos = m_Files.GetStartPosition();
        while (pos != NULL)
        {
            LPCSTR szTempFile = m_Files.GetKeyAt(pos);
            if (szTempFile && DeleteFileA(szTempFile))
            {
                nDeleted++;
            }
            m_Files.GetNext(pos);
        }

        return nDeleted;
    }

    // Read a specified amount of data into pbDest and return the bytes read in pdwLen.
    // Returns TRUE on success, FALSE on failure.
    BOOL ReadData(LPSTR pDest, LPDWORD pdwLen) throw()
    {
        ATLASSERT(pDest);
        ATLASSERT(pdwLen);

        BOOL bRet = ReadClientData(m_spServerContext, pDest, pdwLen, m_dwBytesRead);
        if (bRet)
            m_dwBytesRead+= *pdwLen;
        return bRet;
    }

    // Returns the number of bytes available in the request buffer accessible via GetAvailableData.
    // If GetAvailableBytes returns the same value as GetTotalBytes, the request buffer contains the whole request.
    // Otherwise, the remaining data should be read from the client using ReadData.
    // Equivalent to EXTENSION_CONTROL_BLOCK::cbAvailable.
    DWORD GetAvailableBytes() throw()
    {
        return m_spServerContext ? m_spServerContext->GetAvailableBytes() : 0;
    }

    // Returns the total number of bytes to be received from the client.
    // If this value is 0xffffffff, then there are four gigabytes or more of available data.
    // In this case, ReadData should be called until no more data is returned.
    // Equivalent to the CONTENT_LENGTH server variable or EXTENSION_CONTROL_BLOCK::cbTotalBytes. 
    DWORD GetTotalBytes() throw()
    {
        return m_spServerContext ? m_spServerContext->GetTotalBytes() : 0;
    }

    // Returns a pointer to the request buffer containing the data sent by the client.
    // The size of the buffer can be determined by calling GetAvailableBytes.
    // Equivalent to EXTENSION_CONTROL_BLOCK::lpbData
    LPBYTE GetAvailableData() throw()
    {
        return m_spServerContext ? m_spServerContext->GetAvailableData() : NULL;
    }


    // Returns a nul-terminated string that contains the query information.
    // This is the part of the URL that appears after the question mark (?). 
    // Equivalent to the QUERY_STRING server variable or EXTENSION_CONTROL_BLOCK::lpszQueryString.
    LPCSTR GetQueryString() throw()
    {
        return m_spServerContext ? m_spServerContext->GetQueryString() : NULL;
    }

    // Returns a nul-terminated string that contains the HTTP method of the current request.
    // Examples of common HTTP methods include "GET" and "POST".
    // Equivalent to the REQUEST_METHOD server variable or EXTENSION_CONTROL_BLOCK::lpszMethod.
    LPCSTR GetMethodString() throw()
    {
        return m_spServerContext ? m_spServerContext->GetRequestMethod() : NULL;
    }

    // Returns an HTTP_METHOD enum value corresponding to the HTTP method of the current request.
    // Returns HTTP_METHOD_UNKNOWN if the request method is not one of the following methods:
    //      GET
    //      POST
    //      HEAD
    //      DELETE
    //      LINK
    //      UNLINK
    HTTP_METHOD GetMethod() throw()
    {
        LPCSTR szMethod = GetMethodString();
        if (!szMethod)
            return HTTP_METHOD_UNKNOWN;
        for (int i=0; m_szMethodStrings[i]; i++)
        {
            if (strcmp(szMethod, m_szMethodStrings[i]) == 0)
                return (HTTP_METHOD) i;
        }
        return HTTP_METHOD_UNKNOWN;
    }

    // Returns a nul-terminated string that contains the content type of the data sent by the client.
    // Equivalent to the CONTENT_TYPE server variable or EXTENSION_CONTROL_BLOCK::lpszContentType.
    LPCSTR GetContentType() throw()
    {
        return m_spServerContext ? m_spServerContext->GetContentType() : NULL;
    }


    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_USER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthUserName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_USER", szBuff, pdwSize) :
            FALSE;
    }
    
    // Call this function to retrieve a nul-terminated string containing the value of the "APPL_PHYSICAL_PATH" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetPhysicalPath(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("APPL_PHYSICAL_PATH", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_PASSWORD" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthUserPassword(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_PASSWORD", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "URL" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUrl(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("URL", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_HOST" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserHostName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_HOST", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_ADDR" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserHostAddress(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_ADDR", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the physical path of the script.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    // The script path is the same as GetPathTranslated up to the first .srf or .dll.
    // For example, if GetPathTranslated returns "c:\inetpub\vcisapi\hello.srf\goodmorning",
    // then this function returns "c:\inetpub\vcisapi\hello.srf".
    LPCSTR GetScriptPathTranslated() throw()
    {
        return m_spServerContext ? m_spServerContext->GetScriptPathTranslated() : NULL;
    }

    // Returns a nul-terminated string that contains the physical path of the requested resource on the local server.
    // Equivalent to the PATH_TRANSLATED server variable or EXTENSION_CONTROL_BLOCK::lpszPathTranslated.
    LPCSTR GetPathTranslated() throw()
    {
        return m_spServerContext ? m_spServerContext->GetPathTranslated() : NULL;
    }

    // Returns a nul-terminated string that contains the path of the current request.
    // This is the part of the URL that appears after the server name, but before the query string.
    // Equivalent to the PATH_INFO server variable or EXTENSION_CONTROL_BLOCK::lpszPathInfo.
    LPCSTR GetPathInfo() throw()
    {
        return m_spServerContext ? m_spServerContext->GetPathInfo() : NULL;
    }

    // Call this function to determine whether the current request was authenticated.
    // Returns TRUE if the authentication type is one of the following:
    //      BASIC
    //      NTLM
    //      Negotiate
    // Returns FALSE otherwise.
    BOOL GetAuthenticated() throw(...)
    {
		// check for basic or NTLM authentication
		CStringA strAuthType;
		if (GetAuthenticationType(strAuthType) &&
				(strAuthType == "BASIC" ||
				strAuthType == "NTLM" ||
				strAuthType == "Negotiate"))
			return TRUE;

		return FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_TYPE" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthenticationType(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_TYPE", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_USER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_USER", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_USER_AGENT" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
     BOOL GetUserAgent(LPSTR szBuff, DWORD *pdwSize) throw()
     {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_USER_AGENT", szBuff, pdwSize) :
            FALSE;
     }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
     BOOL GetUserLanguages(LPSTR szBuff, DWORD *pdwSize) throw()
     {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT_LANGUAGE", szBuff, pdwSize) :
            FALSE;
     }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAcceptTypes(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_ENCODING" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAcceptEncodings(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT_ENCODING", szBuff, pdwSize) :
            FALSE;
    }


    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_REFERER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUrlReferer(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_REFERER", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "SCRIPT_NAME" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetScriptName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("SCRIPT_NAME", szBuff, pdwSize) :
            FALSE;
    }

    // Fills a buffer with the contents of the HTTP_COOKIE headers sent
    // from the browser.
    BOOL GetCookies(LPSTR szBuf, LPDWORD pdwSize) const throw()
    {
        ATLASSERT(pdwSize != NULL);
        ATLASSERT(szBuf != NULL);

        CStringA strCookie;
        if (GetCookies(strCookie))
        {
            if (pdwSize && *pdwSize > (DWORD)strCookie.GetLength())
            {
                strcpy(szBuf, strCookie);
                *pdwSize = strCookie.GetLength();
                return true;
            }
        }
        return false;
    }

    // Fills a CStringA with the contents of the HTTP_COOKIE headers sent
    // from the browser.
    BOOL GetCookies(CStringA& strBuff) const throw()
    {
        return GetServerVariable("HTTP_COOKIE", strBuff);
    }

    // Call this function to retrieve a reference to the specified cookie.
    // Returns a CCookie reference to the specified cookie or a
    // reference to an empty cookie if the name can not be found.
    ATL_NOINLINE const CCookie& Cookies(LPCSTR szName) throw()
    {
        static CCookie m_EmptyCookie;
        if (GetRequestCookies())
        {
            // p->m_value is a const CCookie&
            CookieMap::CPair *p = m_requestCookies.Lookup(szName);
            if (p)
            {
                return p->m_value;
            }
        }
        return m_EmptyCookie;
    }


    // Call this function to retrieve the session cookie.
    const CCookie& GetSessionCookie() throw()
    {
        return Cookies(SESSION_COOKIE_NAME);
    }

    // Call this function to retrieve the value of the requested server variable in a CStringA object.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to EXTENSION_CONTROL_BLOCK::GetServerVariable.
    BOOL GetServerVariable(LPCSTR szVariable, CStringA &str) const throw()
    {
        if (!m_spServerContext)
            return FALSE;

        DWORD dwSize = 0;
		BOOL bRet = FALSE;
		_ATLTRY
		{
			m_spServerContext->GetServerVariable(szVariable, NULL, &dwSize);
			bRet = m_spServerContext->GetServerVariable(szVariable, str.GetBuffer(dwSize), &dwSize);
			if (dwSize > 0)
				dwSize--;
			str.ReleaseBuffer(dwSize);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to retrieve the value of the "APPL_PHYSICAL_PATH" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetPhysicalPath(CStringA &str) throw()
    {
        return GetServerVariable("APPL_PHYSICAL_PATH", str);
    }

    // Call this function to retrieve the value of the "REMOTE_HOST" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserHostName(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_HOST", str);
    }

    // Call this function to retrieve the value of the "REMOTE_ADDR" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserHostAddress(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_ADDR", str);
    }

    // Call this function to retrieve the value of the "AUTH_TYPE" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthenticationType(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_TYPE", str);
    }

    // Call this function to retrieve the value of the "REMOTE_USER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserName(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_USER", str);
    }

    // Call this function to retrieve the value of the "HTTP_USER_AGENT" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserAgent(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_USER_AGENT", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserLanguages(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT_LANGUAGE", str);
    }

    // Call this function to retrieve the value of the "AUTH_USER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthUserName(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_USER", str);
    }

    // Call this function to retrieve the value of the "AUTH_PASSWORD" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthUserPassword(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_PASSWORD", str);
    }

    // Call this function to retrieve the value of the "URL" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUrl(CStringA &str) throw()
    {
        return GetServerVariable("URL", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAcceptTypes(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT_ENCODING" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAcceptEncodings(CStringA& str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT_ENCODING", str);
    }

    // Call this function to retrieve the value of the "HTTP_REFERER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUrlReferer(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_REFERER", str);
    }

    // Call this function to retrieve the value of the "SCRIPT_NAME" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetScriptName(CStringA &str) throw()
    {
        return GetServerVariable("SCRIPT_NAME", str);
    }

    // Implementation: Call this function to populate the collection 
    // of CCookie objects with the cookies in the current request.
    // Returns TRUE on success, FALSE on failure.
    BOOL GetRequestCookies() throw()
    {
        BOOL bRet = FALSE;

        if (m_requestCookies.GetCount())
            return TRUE; // we already got the cookies!

        CStringA strCookies;
        if (GetCookies(strCookies))
        {
            bRet = Parse((LPSTR)(LPCSTR)strCookies);
        }
        return bRet;
    }

    // Implementation: Call this function to populate m_requestCookies
    // with a collection of CCookie objects which represents the
    // cookies contained in szCookie header sent from the browser.
    BOOL Parse(LPSTR szCookieIn) throw()
    {
        // The browser only sends back the data for the
        // cookie, separated by ';'. Parse out all of the cookies
        // in the cookie string and create CCookie's out of them which
        // we add to our array of CCookies
        // example 1: Param1=Value1; hello=world&right=wrong&the+direction=west;
        // example 2: hello=world

        if (!szCookieIn)
            return FALSE;
        LPSTR pEnd = szCookieIn;
        LPSTR pStart = szCookieIn;
        CStringA strCookieName;
		_ATLTRY
		{
			while (1)
			{
				if (*pEnd == '\0' || *pEnd == ';')
				{
					CCookie c;
					if (c.Parse(pStart))
					{
						if (c.GetName(strCookieName))
							m_requestCookies.SetAt(strCookieName, c);
					}

					if (*pEnd)
						pStart = pEnd+1;
				}
				if (*pEnd == '\0')
					break;
				pEnd++;
			}
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
        return TRUE;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IHttpRequestLookup)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IHttpRequestLookup*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)))
        {
            *ppv = static_cast<IUnknown*>(this);
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        return 1;
    }
}; // class CHttpRequest

LPCSTR __declspec(selectany) CHttpRequest::m_szMethodStrings[] = {
    "GET",
    "POST",
    "HEAD",
    "DELETE",
    "LINK",
    "UNLINK",
    "DEBUG",  // Debugging support for VS7
    NULL
};

// This class provides type conversions via the Write method
// and overloaded left shift << operator for writing
// data to the IWriteStream interface. The IWriteStream interface
// only accepts strings, but this helper class allows you to transparently
// pass many different types by providing automatic type conversions.
//
// Notes on Type Conversions:
//      Numeric types are converted to their decimal representations.
//      Floating point values are output with a precision of 6 decimal places.
//      Currency values are converted according to the locale settings of the current thread.
class CWriteStreamHelper
{
protected:
    // Implementation: The IWriteStream interface.
    IWriteStream *m_pStream;

public:
    // The default constructor.
    CWriteStreamHelper() throw()
        :m_pStream(NULL)
    {
    }

    // The constructor.
    CWriteStreamHelper(IWriteStream *pStream) throw()
    {
        m_pStream = pStream;
    }

    // Attach a IWriteStream
    IWriteStream *Attach(IWriteStream *pStream) throw()
    {
        IWriteStream *pRetStream = m_pStream;
        m_pStream = pStream;
        return pRetStream;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(LPCSTR szOut) throw()
    {
        if (!szOut)
            return FALSE;

        DWORD dwWritten;
        return SUCCEEDED(m_pStream->WriteStream(szOut, (int) strlen(szOut), &dwWritten));
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(int n) throw()
    {
        CHAR szTmp[21];
        _itoa(n, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned int u) throw()
    {
        CHAR szTmp[21];
        _itoa((int)u, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(short int w) throw()
    {
        return Write((int) w);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(long int dw) throw()
    {
        CHAR szTmp[21];
        _ltoa(dw, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned long int dw) throw()
    {
        CHAR szTmp[21];
        _ultoa(dw, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(double d, int nDigitCount=ATL_DEFAULT_PRECISION) throw()
    {
        CHAR szTmp[512];
        int nDec = 0;
        int nSign = 0;
        bool fWriteDec=true;
        strcpy(szTmp, _fcvt(d, nDigitCount, &nDec, &nSign));
        if (nSign != 0)
            m_pStream->WriteStream("-", 1, NULL);
        if (nDec < 0)
        {
            nDec *= -1;
            m_pStream->WriteStream("0.", 2, NULL);
            for (int i=0;i<nDec;i++)
            {
                m_pStream->WriteStream("0", 1, NULL);
            }
            nDec = 0;
            fWriteDec=false;
        }

        char *p = szTmp;
        while (*p)
        {
            // if the decimal lies at the end of the number
            // (no digits to the right of the decimal, we don't
            // print it.
            if (nDec == 0 && fWriteDec)
                m_pStream->WriteStream(".", 1, NULL);
            m_pStream->WriteStream(p, 1, NULL);
            nDec--;
            p++;
        }
        return TRUE;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(__int64 i) throw()
    {
        CHAR szTmp[21];
        _i64toa(i, szTmp, 10);
        return Write(szTmp);
    }       

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned __int64 i) throw()
    {
        CHAR szTmp[21];
        _ui64toa(i, szTmp, 10);
        return Write(szTmp);
    }       

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(CURRENCY c) throw()
    {
        CHAR szDest[256];
        CHAR szNumber[32];
        
#if 0
        sprintf(szNumber, "%05I64d", c.int64);
        int nLen = (int) strlen(szNumber);
#else
        _i64toa(c.int64, szNumber, 10);
        int nLen = (int) strlen(szNumber);
        if (nLen < 5)
        {
            // prepend ascii zeros
            memmove(szNumber+5-nLen, szNumber, nLen+1);
            memset(szNumber, '0', 5-nLen);
            nLen = 5;
        }
#endif
        memmove(szNumber+nLen-3, szNumber+nLen-4, 5);
        szNumber[nLen-4] = '.';

        int nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szDest, sizeof(szDest));
        if (nRet > 0)
            return Write(szDest);

        ATLASSERT(GetLastError()==ERROR_INSUFFICIENT_BUFFER);

        nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, NULL, 0);
        ATLASSERT(nRet > 0);
        
        if (nRet <= 0)
            return FALSE;

        CAutoVectorPtr<CHAR> szBuffer;
        if (!szBuffer.Allocate(nRet))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szBuffer, nRet);

        ATLASSERT(nRet > 0);
        BOOL bRet = FALSE;
        if (nRet > 0)
            bRet = Write(szBuffer);

        return bRet;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(LPCWSTR wsz) throw()
    {
		BOOL bRet;

        _ATLTRY
        {
            CW2A sz(wsz);

            if (!sz)
			{
                bRet = FALSE;
			}

            DWORD dwWritten;
            bRet = SUCCEEDED(m_pStream->WriteStream(sz, (int) strlen(sz), &dwWritten));
        }
        _ATLCATCHALL()
        {
            bRet = FALSE;
        }

		return bRet;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(LPCSTR szStr) throw(...)
    {
        if (!Write(szStr))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(LPCWSTR wszStr) throw(...)
    {
        if (!Write(wszStr))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(int n) throw(...)
    {
        if (!Write(n))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(short int w) throw(...)
    {
        if (!Write(w))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned int u) throw(...)
    {
        if (!Write(u))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(long int dw) throw(...)
    {
        if (!Write(dw))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned long int dw) throw(...)
    {
        if (!Write(dw))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(double d) throw(...)
    {
        if (!Write(d))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(__int64 i) throw(...)
    {
        if (!Write(i))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned __int64 i) throw(...)
    {
        if (!Write(i))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(CURRENCY c) throw(...)
    {
        if (!Write(c))
            AtlThrow(E_FAIL);
        return *this;
    }
};


// This class represents the response that the web server will send back to the client.
//
// CHttpResponse provides friendly functions for building up the headers, cookies, and body of an HTTP response.
// The class derives from IWriteStream and CWriteStreamHelper, allowing you to call those classes' methods
// to build up the body of the response. By default, the class improves performance by buffering the response until it is complete before sending it back to the client.
class CHttpResponse : public IWriteStream, public CWriteStreamHelper
{
protected:
    // Implementation: A map of HTTP response headers.
    // The key is the name of the response header.
    // The value is the data for the response header.
    CSimpleMap<CStringA, CStringA> m_headers;

    // Implementation: Determines whether the response is currently being buffered.
    BOOL m_bBufferOutput;
    
    // Implementation: Determines whether any output should be sent to the client.
    // Intended mainly for HEAD requests, where the client should get the same headers
    // (i.e. Content-Length) as for a GET request
    BOOL m_bSendOutput;

    // Implementation: The limit in bytes of the response buffer.
    // When the limit is reached, the buffer is automatically flushed
    // and data is sent to the client. You can set this to ULONG_MAX
    // to enable full buffering (this is the default, and is required
    // for enabling keep alive connections).
    DWORD m_dwBufferLimit;

    // Implementation: The server context.
    CComPtr<IHttpServerContext> m_spServerContext;

    // Implementation: The HTTP status code for the response.
    int m_nStatusCode;

    // Implementation: Determines whether the response headers have already been sent to the client.
    BOOL m_bHeadersSent;

    // Implementation: Handle of the file being transmitted so it can be closed
    // when the async I/O completes
    HANDLE m_hFile;
public:
    // Implementation: The buffer used to store the response before
    // the data is sent to the client.
    CAtlIsapiBuffer<> m_strContent;

    // Numeric constants for the HTTP status codes used for redirecting client requests.
    enum HTTP_REDIRECT
    { 
        HTTP_REDIRECT_MULTIPLE=300,
        HTTP_REDIRECT_MOVED=301,
        HTTP_REDIRECT_FOUND=302,
        HTTP_REDIRECT_SEE_OTHER=303,
        HTTP_REDIRECT_NOT_MODIFIED=304,
        HTTP_REDIRECT_USE_PROXY=305,
        HTTP_REDIRECT_TEMPORARY_REDIRECT=307
    };

    // The default constructor. 
    CHttpResponse() throw()
    {
        m_bBufferOutput = TRUE;
        m_dwBufferLimit = ULONG_MAX;
        m_nStatusCode = 200;
        m_pStream = this;
        m_bHeadersSent = FALSE;
        m_bSendOutput = TRUE;
        m_hFile = INVALID_HANDLE_VALUE;
    }

    // The constructor.
    CHttpResponse(IHttpServerContext *pServerContext) throw()
    {
        m_bBufferOutput = TRUE;
        m_dwBufferLimit = ULONG_MAX;
        m_nStatusCode = 200;
        m_pStream = this;
        m_bHeadersSent = FALSE;
        Initialize(pServerContext);
        m_bSendOutput = TRUE;
        m_hFile = INVALID_HANDLE_VALUE;
    }

    // The destructor flushes the buffer if there is content that
    // hasn't yet been sent to the client.
    ~CHttpResponse() throw()
    {
//      if (m_strContent.GetLength())
            Flush(TRUE);
        if (m_hFile && m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle(m_hFile);
    }

    // Call this function to initialize the response object with a pointer to the server context.
    // Returns TRUE on success, FALSE on failure.
    BOOL Initialize(IHttpServerContext *pServerContext) throw()
    {
        ATLASSERT(pServerContext != NULL);
        if (!pServerContext)
            return FALSE;

        m_spServerContext = pServerContext;

        return TRUE;
    }

    // This is called to initialize the CHttpResponse for a child handler.  By default, it
    // assumes the parent will be responsible for sending the headers.
    BOOL Initialize(IHttpRequestLookup *pLookup) throw()
    {
        ATLASSERT(pLookup);
        if (!pLookup)
            return FALSE;

        CComPtr<IHttpServerContext> spContext;
        HRESULT hr = pLookup->GetServerContext(&spContext);
        if (FAILED(hr))
            return FALSE;

        if (!Initialize(spContext))
            return FALSE;

        m_bHeadersSent = TRUE;

        return TRUE;
    }

    // Returns a pointer to the IHttpServerContext interface for the current request.
    HRESULT GetServerContext(IHttpServerContext ** ppOut) throw()
    {
        return m_spServerContext.CopyTo(ppOut);
    }

    // Call this function to set buffering options for the response.
    //
    // This function allows you to turn buffering on or off, and to set a size limit
    // on the amount of data that will be buffered before being sent to the client.
    // 
    // When you turn off buffering, the current contents of the buffer will be sent to the client.
    // If you need to clear the buffer without sending the contents to the client, call ClearContent instead.
    //
    // When the size of the buffer is reduced below the current size of the buffered content,
    // the entire buffer is flushed.
    void SetBufferOutput(BOOL bBufferOutput, DWORD dwBufferLimit=ATL_ISAPI_BUFFER_SIZE) throw()
    {
        if (m_bBufferOutput && !bBufferOutput)
        {
            // before turning off buffering, flush
            // the current contents
            Flush();
        }
        SetBufferLimit(dwBufferLimit);

        m_bBufferOutput = bBufferOutput;
    }

    // Call this function to determine whether data written to the response object is being buffered or not.
    // Returns TRUE if output is being buffered, FALSE otherwise.
    BOOL GetBufferOutput() throw()
    {
        return m_bBufferOutput;
    }

    // Call this function to determine whether the response headers have been sent
    // Returns TRUE if headers have been sent, FALSE otherwise.
    BOOL HaveSentHeaders() throw()
    {
        return m_bHeadersSent;
    }

    // Call this function to override the m_bHeadersSent state.  This is useful
    // when you want child handlers (e.g. from an include or subhandler) to send the headers
    void HaveSentHeaders(BOOL bSent) throw()
    {
        m_bHeadersSent = bSent;
    }

    // Call this function to set a size limit on the amount of data buffered by the reponse object.
    // When the size of the buffer is reduced below the current size of the buffered content,
    // the entire buffer is flushed.
    // See GetBufferLimit.
    void SetBufferLimit(DWORD dwBufferLimit) throw()
    {
        if (m_bBufferOutput)
        {
            if (m_strContent.GetLength() >= dwBufferLimit)
            {
                // new buffer limit is less than the
                // size currently buffered.  So flush
                // the current buffer
                Flush();
            }
        }
        m_dwBufferLimit = dwBufferLimit;
    }

    // Returns the current size limit of the buffer in bytes.
    // See SetBufferLimit.
    DWORD GetBufferLimit() throw()
    {
        return m_dwBufferLimit;
    }

    // Returns the current value of the Content-Type header if present, otherwise returns NULL.
    LPCSTR GetContentType() throw()
    {
        // return the content type from the
        // header collection if any
		_ATLTRY
		{
        CStringA strKey("Content-Type");

        int nIndex = m_headers.FindKey(strKey);
        if (nIndex >= 0)
            return m_headers.GetValueAt(nIndex);
		}
		_ATLCATCHALL()
		{
		}
        return NULL;
    }

    // Call this function to set the Content-Type of the HTTP response.
    // Examples of common MIME content types include text/html and text/plain.
    BOOL SetContentType(LPCSTR szContentType) throw()
    {
		_ATLTRY
		{
			if (!m_headers.SetAt("Content-Type", szContentType))
				return m_headers.Add("Content-Type", szContentType);
		}
		_ATLCATCHALL()
		{
		}
        return TRUE;
    }

    // Call this function to set the HTTP status code of the response.
    // If not set explicitly, the default status code is 200 (OK).
    // See GetStatusCode.
    void SetStatusCode(int nCode) throw()
    {
        m_nStatusCode = nCode;
    }

    // Returns the current HTTP status code of the response.
    // See SetStatusCode.
    int GetStatusCode() throw()
    {
        return m_nStatusCode;
    }

    // Call this function to set the Cache-Control http header of the response.
    // Examples of common Cache-Control header values: public, private, max-age=delta-seconds
    BOOL SetCacheControl(LPCSTR szCacheControl) throw()
    {
		_ATLTRY
		{
			if (!m_headers.SetAt("Cache-Control", szCacheControl))
				return m_headers.Add("Cache-Control", szCacheControl);
		}
		_ATLCATCHALL()
		{
		}
        return FALSE;
    }

    // Call this function to set the Expires HTTP header to the absolute date/time
    // specified in the stExpires parameter
    BOOL SetExpiresAbsolute(const SYSTEMTIME& stExpires) throw()
    {
		_ATLTRY
		{
			CStringA strExpires;
			SystemTimeToHttpDate(stExpires, strExpires);

			if (!m_headers.SetAt("Expires", strExpires))
				return m_headers.Add("Expires", strExpires);
		}
		_ATLCATCHALL()
		{
		}
        return FALSE;
    }

    // Call this function to set the Expires HTTP header to a relative date/time
    // value specified in minutes;
    BOOL SetExpires(long lMinutes) throw()
    {
        CFileTime ft;
        GetSystemTimeAsFileTime(&ft);

        // add the specified number of minutes
        ft += CFileTimeSpan(((ULONGLONG)lMinutes)*60*10000000);

        SYSTEMTIME st;
        FileTimeToSystemTime(&ft, &st);
        return SetExpiresAbsolute(st);
    }

    // Call this function to set whether or not to output to client.
    // Intended primarily for HEAD requests
    BOOL SetWriteToClient(BOOL bSendOutput) throw()
    {
        m_bSendOutput = bSendOutput;
        return TRUE;
    }

    // Call this function to determine whether or not the data is
    // sent to the client.  Intended primarily for HEAD requests
    BOOL GetWriteToClient() throw()
    {
        return m_bSendOutput;
    }

    // Call this function to write data to the response object.
    //
    // Returns S_OK on success, E_INVALIDARG or E_FAIL on failure.
    //
    // See WriteClient for comments on buffering.
    //
    // szOut    A pointer to the first byte of the data to be written.
    //
    // nLen     The number of bytes to write. If this parameter is -1,
    //          szOut is assumed to be a nul-terminated string and the
    //          whole string will be written.
    //
    // pdwWritten   A DWORD pointer that can be used to get the number of bytes written.
    //              This parameter can be NULL.
    HRESULT WriteStream(LPCSTR szOut, int nLen, DWORD *pdwWritten) throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        if (pdwWritten)
            *pdwWritten = 0;
        if (nLen == -1)
        {
            if (!szOut)
                return E_INVALIDARG;
            nLen = (int) strlen(szOut);
        }
        BOOL bRet = WriteLen(szOut, nLen);
        if (!bRet)
        {
            return AtlHresultFromLastError();
        }
        if (pdwWritten)
            *pdwWritten = nLen;
        return S_OK;
    }

    // Call this function to write data to the response object.
    //
    // Returns TRUE on success. FALSE on failure.
    //
    // If buffering is disabled, data is written directly to the client.
    // If buffering is enabled, this function attempts to write to the buffer.
    // If the buffer is too small to contain its existing data and the new data,
    // the current contents of the buffer are flushed.
    // If the buffer is still too small to contain the new data, that data is written
    // directly to the client. Otherwise the new data is written to the buffer.
    //
    // Any headers that have been set in the response will be sent just before the 
    // data is written to the client if no headers have been sent up to that point.
    //
    // szOut    A pointer to the first byte of the data to be written.
    //
    // nLen     The number of bytes to write.
    BOOL WriteLen(LPCSTR szOut, DWORD dwLen) throw()
    {
        ATLASSERT(m_spServerContext != NULL);
        if (!szOut)
            return FALSE;

        if (m_bBufferOutput)
        {
            if (m_strContent.GetLength()+dwLen >= m_dwBufferLimit)
            {
                if (!Flush())
                    return FALSE;
            }
            if (dwLen <= m_dwBufferLimit)
                return m_strContent.Append(szOut, dwLen);
        }
        BOOL bRet = SendHeadersInternal();

        if (bRet && m_bSendOutput)
            bRet = m_spServerContext->WriteClient((void *) szOut, &dwLen);
        
        return bRet;
    }

    // Call this function to redirect the client to a different resource.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // szURL        A nul-terminated string specifying the resource the client should navigate to. 
    //
    // statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
    //              for the redirection.
    //
    // bSendBody    Specifies whether to generate and send a response body with the headers.
    //
    //  This function allows (and RFC 2616 encourages) a response body to be sent
    //  with the following redirect types:
    //      HTTP_REDIRECT_MOVED
    //      HTTP_REDIRECT_FOUND
    //      HTTP_REDIRECT_SEE_OTHER
    //      HTTP_REDIRECT_TEMPORARY_REDIRECT
    // No body will be sent with other redirect types.
    //
    // The response body contains a short hypertext note with a hyperlink to the new resource.
    // A meta refresh tag is also included to allow browsers to automatically redirect
    // the user to the resource even if they don't understand the redirect header.
    //
    // See RFC 2616 section 10.3 for more information on redirection.
    BOOL Redirect(LPCSTR szUrl, HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED, BOOL bSendBody=TRUE) throw(...)
    {
        CStringA strBody;
        LPCSTR szBody = NULL;
        if (bSendBody &&
            (HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
            HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
        {
			_ATLTRY
			{
            strBody.Format(
                "<html>\r\n"
                "<head>\r\n"
                "<meta http-equiv=\"refresh\" content=\"0; url=%s\">\r\n"
                "</head>\r\n"
                "<body>Please use the following link to access this resource:"
                " <a href=\"%s\">%s</a>\r\n"
                "</body>\r\n"
                "</html>\r\n",
                szUrl, szUrl, szUrl);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
            szBody = (LPCSTR) strBody;
        }
        return Redirect(szUrl, szBody, statusCode);
    }

    // Call this function to redirect the client to a different resource.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // szURL        A nul-terminated string specifying the resource the client should navigate to.
    //
    // szBody       A nul-terminated string containing the body of the response to be sent to the client.
    //
    // statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
    //              for the redirection.
    //
    //  This function allows (and RFC 2616 encourages) a response body to be sent
    //  with the following redirect types:
    //      HTTP_REDIRECT_MOVED
    //      HTTP_REDIRECT_FOUND
    //      HTTP_REDIRECT_SEE_OTHER
    //      HTTP_REDIRECT_TEMPORARY_REDIRECT
    // No body will be sent with other redirect types.
    //
    // The response body should contain a short hypertext note with a hyperlink to the new resource.
    // You can include a meta refresh tag to allow browsers to automatically redirect
    // the user to the resource even if they don't understand the redirect header.
    //
    // See RFC 2616 section 10.3 for more information on redirection.
    BOOL Redirect(LPCSTR szUrl, LPCSTR szBody, HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED) throw()
    {
        // todo: handle multiple
        SetStatusCode(statusCode);
        AppendHeader("Location", szUrl);

		_ATLTRY
		{
			if (!SendHeadersInternal())
				return FALSE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

        if (szBody &&
            (HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
            HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
        {
            Write(szBody);
            return Flush();
        }
        return TRUE;
    }

    // Call this function to append a header to the collection of HTTP headers managed by this object.
    //
    // szName   A nul-teminated string containing the name of the HTTP header.
    //
    // szValue  A nul-teminated string containing the value of the HTTP header.
    BOOL AppendHeader(LPCSTR szName, LPCSTR szValue) throw()
    {
		BOOL bRet = FALSE;
        _ATLTRY
		{
			bRet = m_headers.Add(szName, szValue);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // pCookie      A pointer to a CCookie object describing the cookie to be sent to the client.
    BOOL AppendCookie(const CCookie *pCookie) throw()
    {
        ATLASSERT(pCookie);
        return AppendCookie((const CCookie&)*pCookie);
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // cookie       A reference to a CCookie object describing the cookie to be sent to the client.
    BOOL AppendCookie(const CCookie& cookie) throw()
    {
        CHAR szCookie[ATL_MAX_COOKIE_LEN];
        DWORD dwBuffSize = ATL_MAX_COOKIE_LEN;
        BOOL bRet = FALSE;
        bRet = cookie.Render(szCookie, &dwBuffSize);
        if (bRet)
        {
            bRet = m_headers.Add("Set-Cookie", szCookie);
        }

        if (!bRet && dwBuffSize > 0)    //static buffer wasn't big enough.
        {   
            //We'll have to try dynamically allocating it
            //allocate a buffer
            CAutoVectorPtr<CHAR> sz;
            if (sz.Allocate(dwBuffSize+1))
            {
                DWORD dwSizeNew = dwBuffSize + 1;
                if (cookie.Render(sz, &dwSizeNew))
                {
                    bRet = m_headers.Add("Set-Cookie", (const char *) sz);
                }
            }
        }
        return bRet;
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // szName       A nul-terminated string containing the name of the cookie to be sent to the client.
    //
    // szValue      A nul-terminated string containing the value of the cookie to be sent to the client.
    BOOL AppendCookie(LPCSTR szName, LPCSTR szValue) throw()
    {
		BOOL bRet = FALSE;
		_ATLTRY
		{
			CCookie c(szName, szValue);
			bRet = AppendCookie(c);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
    }

    // Call this function to add a Set-Cookie header that removes a cookie value
    // to the collection of HTTP headers managed by this object.
    // 
    // szName       A nul-terminated string containing the name of the cookie to be deleted
    BOOL DeleteCookie(LPCSTR szName) throw()
    {
		BOOL bRet = FALSE;
		_ATLTRY
		{
        CCookie cookie(szName, "");
        cookie.SetMaxAge(0);
        bRet = AppendCookie(cookie);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;

    }

    // Call this function to clear the collection of HTTP response headers maintained by this object.
    //
    // Note that clearing the headers includes removing all cookies associated with the response
    // object. Cookies are sent to the client as Set-Cookie HTTP headers.
    void ClearHeaders() throw()
    {
        m_headers.RemoveAll();
    }

    // Call this function to clear theresponse buffer without sending the contents to the client.
    // If you need to empty the buffer but you do want the current contents sent to the client, call Flush instead. 
    void ClearContent() throw()
    {
        m_strContent.Empty();
    }

    // Call this function to send the current headers associated with this object to the client.
    // 
    // Returns TRUE on success, FALSE on failure.
    //
    // The response headers are sent to the client using the current status code for the
    // response object. See SetStatusCode and GetStatusCode.
    BOOL SendHeadersInternal(BOOL fKeepConn=FALSE) throw()
    {
        if (m_bHeadersSent)
            return TRUE;

        ATLASSERT(m_spServerContext != NULL);

        CStringA strHeaders;

        RenderHeaders(strHeaders);

        // REVIEW: should fix this to use the user's custom error provider
        CDefaultErrorProvider prov;

		BOOL bRet = FALSE;
		_ATLTRY
		{
        CStringA strStatus = GetStatusHeader(m_nStatusCode, SUBERR_NONE, &prov);
        bRet = m_spServerContext->SendResponseHeader(strHeaders, strStatus, fKeepConn);
        if (bRet)
            m_bHeadersSent = TRUE;
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to get a string containing all the HTTP headers associated with
    // this object in a format suitable for sending to a client.
    //
    // strHeaders   A CStringA reference to which will be appended the HTTP headers.
    void RenderHeaders(CStringA& strHeaders) throw()
    {
		_ATLTRY
		{
			for (int i=0; i<m_headers.GetSize(); i++)
			{
				strHeaders += m_headers.GetKeyAt(i);
				strHeaders += ": ";
				strHeaders += m_headers.GetValueAt(i);
				strHeaders += "\r\n";
			}
			strHeaders += "\r\n";
		}
		_ATLCATCHALL()
		{
		}
    }

    // Call this function to empty the response buffer and send its current
    // contents to the client.
    //
    // Returns S_OK on success, or an error HRESULT on failure.
    HRESULT FlushStream() throw()
    {
        if (!Flush())
            return AtlHresultFromLastError();
        return S_OK;
    }

    // Call this function to empty the response buffer and send its current
    // contents to the client.
    //
    // Returns TRUE on success, or FALSE on failure.
    //
    // Any headers that have been set in the response will be sent just before the 
    // data is written to the client if no headers have been sent up to that point.
    BOOL Flush(BOOL bFinal=FALSE) throw()
    {
        if (!m_spServerContext)
            return FALSE;

        BOOL bRet = TRUE;

		_ATLTRY
		{
			// if the headers haven't been sent,
			// send them now

			if (!m_bHeadersSent)
			{
				char szProtocol[ATL_URL_MAX_URL_LENGTH];
				DWORD dwProtocolLen = sizeof(szProtocol);

				if (bFinal && m_bBufferOutput && m_dwBufferLimit==ULONG_MAX)
				{
					if (m_spServerContext->GetServerVariable("SERVER_PROTOCOL", szProtocol, &dwProtocolLen) &&
						!strcmp(szProtocol, "HTTP/1.0"))
						AppendHeader("Connection", "Keep-Alive");
					_itoa(m_strContent.GetLength(), szProtocol, 10);
					AppendHeader("Content-Length", szProtocol);
					bRet = SendHeadersInternal(TRUE);
				}
				else
					bRet = SendHeadersInternal();
			}
			if (m_bBufferOutput)
			{
				DWORD dwLen = 0;

				dwLen = m_strContent.GetLength();
				if (dwLen)
				{
					if (m_bSendOutput && 
						m_spServerContext->WriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
					{
						m_strContent.Empty();
						return FALSE;
					}
					m_strContent.Empty();
				}
			}
		} // _ATLTRY
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to clear the response object of any headers
    // and the contents of the buffer.
    void ClearResponse() throw()
    {
        m_strContent.Empty();
        m_headers.RemoveAll();
        
    }

    BOOL AsyncPrep(BOOL fKeepConn=FALSE) throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        return SendHeadersInternal(fKeepConn);
    }
    
    BOOL AsyncFlush() throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        BOOL bRet = SendHeadersInternal();

        if (bRet && m_bBufferOutput)
        {
            DWORD dwLen = 0;

            dwLen = m_strContent.GetLength();
            if (dwLen)
            {
                if (m_spServerContext->AsyncWriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
                    return FALSE;
            }
        }
        return bRet;
    }

    BOOL TransmitFile(HANDLE hFile, LPCSTR szContentType="text/plain") throw()
    {
        ATLASSERT(m_spServerContext != NULL);
        ATLASSERT(hFile != NULL && hFile != INVALID_HANDLE_VALUE);

        SetContentType(szContentType);

        if (m_strContent.GetLength())
            if (!Flush())
                return FALSE;

        BOOL bRet = SendHeadersInternal();
        if (bRet)
        {
            bRet = m_spServerContext->TransmitFile(hFile, NULL, NULL, NULL, 
                0, 0, NULL, 0, NULL, 0, HSE_IO_ASYNC);
        }
    
        return bRet;
    }
}; // class CHttpResponse



#define ATLS_FLAG_NONE      0
#define ATLS_FLAG_ASYNC     1   // handler might do some async handling

//REVIEW: push_macro/pop_macro don't work in a template definition.
//these have been moved out of IRequestHandlerImpl temporarily because
//of placement new usage
#pragma push_macro("new")
#undef new
template <class T>
class PerThreadWrapper : public CComObjectNoLock<T>
{
public:
    void *operator new(size_t /*size*/, void *p) throw()
    {
        return p;
    }
    
    void operator delete(void * /*p*/) throw()
    {
    }

    STDMETHOD_(ULONG, Release)() throw()
    {
        ULONG l = InternalRelease();
        if (l == 0)
        {
            T *pT = static_cast<T*>(this);
            ATLASSERT(pT->m_spExtension != NULL);
            CIsapiWorker *pWorker = pT->m_spExtension->GetThreadWorker();
            ATLASSERT(pWorker);

            delete this;
            HeapFree(pWorker->m_hHeap, HEAP_NO_SERIALIZE, this);
        }
        return l;
    }
};

template <typename THandler>
inline BOOL CreateRequestHandlerSync(IIsapiExtension *pExtension, IUnknown **ppOut) throw()
{
    CIsapiWorker *pWorker = pExtension->GetThreadWorker();
    ATLASSERT(pWorker);
    void *pv = HeapAlloc(pWorker->m_hHeap, HEAP_NO_SERIALIZE, sizeof(PerThreadWrapper<THandler>));
    if (!pv)
        return FALSE;

    PerThreadWrapper<THandler> *pHandler = new(pv) PerThreadWrapper<THandler>;
    *ppOut = static_cast<IRequestHandler *>(pHandler);
    pHandler->m_spExtension = pExtension;

    (*ppOut)->AddRef();

    return TRUE;
}
#pragma pop_macro("new")

#define DECLARE_ASYNC_HANDLER() \
    static DWORD GetHandlerFlags() throw() \
    { \
        return ATLS_FLAG_ASYNC; \
    } \
    DWORD GetAsyncFlags() throw() \
    { \
        return ATLSRV_INIT_USEASYNC; \
    }

#define DECLARE_ASYNC_HANDLER_EX() \
    static DWORD GetHandlerFlags() throw() \
    { \
        return ATLS_FLAG_ASYNC; \
    } \
    DWORD GetAsyncFlags() throw() \
    { \
        return (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX); \
    }


template <typename THandler>
class IRequestHandlerImpl : public IRequestHandler
{
public:
    HINSTANCE m_hInstHandler;
    CComPtr<IServiceProvider> m_spServiceProvider;
    CComPtr<IHttpServerContext> m_spServerContext;
    CComPtr<IIsapiExtension> m_spExtension;
    DWORD m_dwAsyncFlags;

    IRequestHandlerImpl() throw()
        :m_hInstHandler(NULL)
    {
        m_dwAsyncFlags = 0;
    }

    HTTP_CODE GetFlags(DWORD *pdwStatus) throw(...)
    {
        THandler *pT = static_cast<THandler *>(this);
        if (pdwStatus)
        {
            *pdwStatus = pT->GetAsyncFlags();
            if (pT->CachePage())
                *pdwStatus |= ATLSRV_INIT_USECACHE;

#ifdef _DEBUG
            if (*pdwStatus & (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX))
                ATLASSERT(pT->GetHandlerFlags() & ATLS_FLAG_ASYNC);
#endif
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeHandler(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider) throw()
    {
        ATLASSERT(pRequestInfo != NULL);
        ATLASSERT(pProvider != NULL);
        ATLASSERT(pRequestInfo->hInstDll != NULL);
        ATLASSERT(pRequestInfo->pServerContext != NULL);

        // Initialize our internal references to required services
        m_hInstHandler = pRequestInfo->hInstDll;
        m_spServiceProvider = pProvider;
        m_spServerContext = pRequestInfo->pServerContext;

        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeChild(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider, IHttpRequestLookup * /*pLookup*/) throw()
    {
        return InitializeHandler(pRequestInfo, pProvider);
    }

    void UninitializeHandler() throw()
    {
    }

    HTTP_CODE HandleRequest(
        AtlServerRequest* /*pRequestInfo*/,
        IServiceProvider* /*pServiceProvider*/) throw()
    {
        return HTTP_SUCCESS;
    }

    DWORD GetAsyncFlags() throw()
    {
        return m_dwAsyncFlags;
    }

    void SetAsyncFlags(DWORD dwAsyncFlags) throw()
    {
        ATLASSERT((dwAsyncFlags & ~(ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX)) == 0);
        m_dwAsyncFlags = dwAsyncFlags;
    }

    BOOL CachePage() throw()
    {
        return FALSE;
    }

    static DWORD GetHandlerFlags() throw()
    {
        return ATLS_FLAG_NONE;
    }

    // Used to create new instance of this object. A pointer to this
    // function is stored in the handler map in user's code.
    static BOOL CreateRequestHandler(IIsapiExtension *pExtension, IUnknown **ppOut) throw()
    {
        ATLASSERT(ppOut != NULL);
        if (ppOut == NULL)
            return false;

        *ppOut = NULL;

        if (THandler::GetHandlerFlags() & ATLS_FLAG_ASYNC)
        {
            THandler *pHandler = NULL;
            ATLTRY(pHandler = new CComObjectNoLock<THandler>);
            if (!pHandler)
                return FALSE;
            *ppOut = static_cast<IRequestHandler *>(pHandler);
            pHandler->m_spExtension = pExtension;
            (*ppOut)->AddRef();
        }
        else
        {
            if (!CreateRequestHandlerSync<THandler>(pExtension, ppOut))
                return FALSE;
        }

        return TRUE;
    }

    // Used to initialize the class
    // function is stored in the handler map in user's code.
    static BOOL InitRequestHandlerClass(IHttpServerContext *pContext, IIsapiExtension *pExt) throw()
    {
        pContext; // unused
        pExt; // unused
        return TRUE;
    }

    // Used to uninitialize the class
    // function is stored in the handler map in user's code.
    static void UninitRequestHandlerClass() throw()
    {
        return;
    }
};

struct CRequestStats
{
    long m_lTotalRequests;
    long m_lFailedRequests;
    __int64 m_liTotalResponseTime;
    long m_lAvgResponseTime;
    long m_lCurrWaiting;
    long m_lMaxWaiting;
    long m_lActiveThreads;

    CRequestStats() throw()
    {
        m_lTotalRequests = 0;
        m_lFailedRequests = 0;
        m_liTotalResponseTime = 0;
        m_lAvgResponseTime = 0;
        m_lCurrWaiting = 0;
        m_lMaxWaiting = 0;
        m_lActiveThreads = 0;
    }

    void RequestHandled(AtlServerRequest *pRequestInfo, BOOL bSuccess) throw()
    {
        InterlockedIncrement(&m_lTotalRequests);
        if (!bSuccess)
            InterlockedIncrement(&m_lFailedRequests);

        long lTicks;

#ifndef ATL_NO_MMSYS
        lTicks = (long) (timeGetTime() - pRequestInfo->dwStartTicks);
#else
        lTicks = GetTickCount();
#endif
		m_liTotalResponseTime += lTicks;
		long lAv = (long) (m_liTotalResponseTime / m_lTotalRequests);
        InterlockedExchange(&m_lAvgResponseTime, lAv);

        InterlockedDecrement(&m_lActiveThreads);
    }

    long GetTotalRequests() throw()
    {
        return m_lTotalRequests;
    }

    long GetFailedRequests() throw()
    {
        return m_lFailedRequests;
    }

    long GetAvgResponseTime() throw()
    {
        return m_lAvgResponseTime;
    }

    void OnRequestReceived() throw()
    {
        InterlockedIncrement(&m_lCurrWaiting);
        if (m_lCurrWaiting > m_lMaxWaiting)
            InterlockedExchange(&m_lMaxWaiting, m_lCurrWaiting);
    }

    void OnRequestDequeued() throw()
    {
        InterlockedDecrement(&m_lCurrWaiting);
        InterlockedIncrement(&m_lActiveThreads);
    }

    long GetCurrWaiting() throw()
    {
        return m_lCurrWaiting;
    }

    long GetMaxWaiting() throw()
    {
        return m_lCurrWaiting;
    }

    long GetActiveThreads() throw()
    {
        return m_lActiveThreads;
    }
};

class CStdRequestStats : public CRequestStats
{

public:
    HRESULT Initialize() throw()
    {
        return S_OK;
    }

    void Uninitialize() throw()
    {
    }
};

#define PERF_REQUEST_OBJECT 100

struct CPerfRequestStatObject : public CPerfObject,
    public CRequestStats
{
    DECLARE_PERF_OBJECT_EX(PERF_REQUEST_OBJECT, IDS_PERFMON_REQUEST, IDS_PERFMON_REQUEST_HELP, PERF_DETAIL_NOVICE, 0, sizeof(CPerfRequestStatObject), MAX_PATH, -1);
	BEGIN_COUNTER_MAP(CPerfRequestStatObject)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_TOTAL, IDS_PERFMON_REQUEST_TOTAL_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lFailedRequests, IDS_PERFMON_REQUEST_FAILED, IDS_PERFMON_REQUEST_FAILED_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_RATE, IDS_PERFMON_REQUEST_RATE_HELP, PERF_COUNTER_COUNTER, -1)
		DEFINE_COUNTER(m_lAvgResponseTime, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lCurrWaiting, IDS_PERFMON_REQUEST_CURR_WAITING, IDS_PERFMON_REQUEST_CURR_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lMaxWaiting, IDS_PERFMON_REQUEST_MAX_WAITING, IDS_PERFMON_REQUEST_MAX_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lActiveThreads, IDS_PERFMON_REQUEST_ACTIVE_THREADS, IDS_PERFMON_REQUEST_ACTIVE_THREADS, PERF_COUNTER_RAWCOUNT, -1)
	END_COUNTER_MAP()
};

class CRequestPerfMon : public CPerfMon
{
public:
    BEGIN_PERF_MAP(_T("ATL Server:Request"))
		CHAIN_PERF_OBJECT(CPerfRequestStatObject)
    END_PERF_MAP()
};

class CPerfMonRequestStats
{
    CRequestPerfMon m_PerfMon;
    CPerfRequestStatObject * m_pPerfObjectInstance;
    CPerfRequestStatObject * m_pPerfObjectTotal;

public:
    CPerfMonRequestStats() throw()
    {
        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;
    }

    HRESULT Initialize() throw()
    {
        HRESULT hr;

        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;

        hr = m_PerfMon.Initialize();
        if (SUCCEEDED(hr))
        {
            CPerfLock lock(&m_PerfMon);
            if (FAILED(hr = lock.GetStatus()))
            {
                return hr;
            }

            HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
            WCHAR szName[MAX_PATH];
            if (GetModuleFileNameW(hInst, szName, MAX_PATH) == 0)
            {
                return E_FAIL;
            }
            szName[MAX_PATH-1] = 0;

            hr = m_PerfMon.CreateInstanceByName(PERF_REQUEST_OBJECT, L"_Total", reinterpret_cast<CPerfObject**>(&m_pPerfObjectTotal));
            if (FAILED(hr))
            {
                return hr;
            }

            hr = m_PerfMon.CreateInstanceByName(PERF_REQUEST_OBJECT, szName, reinterpret_cast<CPerfObject**>(&m_pPerfObjectInstance));
            if (FAILED(hr))
            {
                m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);
                m_pPerfObjectTotal = NULL;
                return hr;
            }

            return S_OK;
        }

        return hr;
    }

    void Uninitialize() throw()
    {
        if (m_pPerfObjectInstance)
            m_PerfMon.ReleaseInstance(m_pPerfObjectInstance);
        if (m_pPerfObjectTotal)
            m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);

        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;

        m_PerfMon.UnInitialize();
    }

    void RequestHandled(AtlServerRequest *pRequestInfo, BOOL bSuccess) throw()
    {
        CPerfLock lock(&m_PerfMon);
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->RequestHandled(pRequestInfo, bSuccess);
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->RequestHandled(pRequestInfo, bSuccess);
    }

    long GetTotalRequests() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetTotalRequests();

        return 0;
    }

    long GetFailedRequests() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetFailedRequests();

        return 0;
    }

    long GetAvgResponseTime() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetAvgResponseTime();

        return 0;
    }

    void OnRequestReceived() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->OnRequestReceived();
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->OnRequestReceived();
    }

    void OnRequestDequeued() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->OnRequestDequeued();
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->OnRequestDequeued();
    }

    long GetCurrWaiting() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetCurrWaiting();

        return 0;
    }

    long GetMaxWaiting() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetMaxWaiting();

        return 0;
    }

    long GetActiveThreads() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetActiveThreads();

        return 0;
    }
};

class CNoRequestStats
{
protected:

public:

    HRESULT Initialize() throw()
    {
        return S_OK;
    }

    void Uninitialize() throw()
    {
    }

    void RequestHandled(AtlServerRequest * /*pRequestInfo*/, BOOL /*bSuccess*/) throw()
    {
    }

    long GetTotalRequests() throw()
    {
        return 0;
    }

    long GetFailedRequests() throw()
    {
        return 0;
    }

    long GetAvgResponseTime() throw()
    {
        return 0;
    }

    void OnRequestReceived() throw()
    {
    }

    void OnRequestDequeued() throw()
    {
    }

    long GetCurrWaiting() throw()
    {
        return 0;
    }

    long GetMaxWaiting() throw()
    {
        return 0;
    }

    long GetActiveThreads() throw()
    {
        return 0;
    }
};


inline LPSTR StripHandlerComment(LPSTR szLine) throw()
{
    if (!memcmp(szLine, "<!--", 4))
    {
        szLine += 4;
        while (_istspace(*szLine))
            szLine++;
        LPSTR szEndComment = strstr(szLine, "-->");
        if (szEndComment)
            *szEndComment = '\0';
        return szLine;
    }
    return NULL;
}

struct ATLServerDllInfo
{
    GETATLHANDLERBYNAME     pfnGetHandler;
    UNINITIALIZEATLHANDLERS pfnUninitHandlers;
    INITIALIZEATLHANDLERS pfnInitHandlers;
    IIsapiExtension *pExtension;
    IHttpServerContext *pContext;
};

class CDllCachePeer
{
public:
    struct DllInfo : public ATLServerDllInfo
    {
        DllInfo& operator=(const DllInfo& right) throw()
        {
            if (this != &right)
			{
                pfnGetHandler = right.pfnGetHandler;
                pfnUninitHandlers = right.pfnUninitHandlers;
                pfnInitHandlers = right.pfnInitHandlers;
                pExtension = right.pExtension;
                pContext = right.pContext;
            }
		    return *this;
        }
    };

    BOOL Add(HINSTANCE hInst, DllInfo *pInfo) throw(...)
    {
        pInfo->pfnInitHandlers = (INITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_INITIALIZEHANDLERS);

        pInfo->pfnGetHandler = (GETATLHANDLERBYNAME) GetProcAddress(hInst, ATLS_FUNCID_GETATLHANDLERBYNAME);
        if (!pInfo->pfnGetHandler)
            return FALSE;

        pInfo->pfnUninitHandlers = (UNINITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_UNINITIALIZEHANDLERS);

        if (pInfo->pfnInitHandlers)
        {
			pInfo->pfnInitHandlers(pInfo->pContext, pInfo->pExtension);
            pInfo->pContext = NULL; // won't be valid after this call
        }

        return TRUE;
    }

    void Remove(HINSTANCE /*hInst*/, DllInfo *pInfo) throw(...)
    {
		if (pInfo->pfnUninitHandlers)
			(*pInfo->pfnUninitHandlers)();
    }

};

inline bool operator==(const CDllCachePeer::DllInfo& left, const CDllCachePeer::DllInfo& right) throw()
{
    return ( (left.pfnGetHandler == right.pfnGetHandler) &&
             (left.pfnUninitHandlers == right.pfnUninitHandlers) &&
             (left.pfnInitHandlers == right.pfnInitHandlers) &&
             (left.pExtension == right.pExtension) &&
             (left.pContext == right.pContext)
           );
}



// Helper function to impersonate the client
// on the current thread
inline BOOL AtlImpersonateClient(IHttpServerContext *pServerContext) throw()
{
    // impersonate the calling client on the current thread
    HANDLE hToken;
    if (!pServerContext->GetImpersonationToken(&hToken))
        return FALSE;
    
    if (!SetThreadToken(NULL, hToken))
        return FALSE;
    return TRUE;    
}

// Helper class to set the thread impersonation token
// This is mainly used internally to ensure that we
// don't forget to revert to the process impersonation
// level
class CSetThreadToken
{
public:
    BOOL Initialize(AtlServerRequest *pRequestInfo) throw()
    {
        return AtlImpersonateClient(pRequestInfo->pServerContext);
    }

    ~CSetThreadToken() throw()
    {
        RevertToSelf();         
    }
};


//REVIEW: push_macro/pop_macro don't work in a template definition.
//this has been moved out of  temporarily because
//of placement new usage
#pragma push_macro("new")
#undef new
template <class Base>
class _CComObjectHeap : public Base
{
public:
    typedef Base _BaseClass;
    HANDLE m_hHeap;
    _CComObjectHeap(HANDLE hHeap) throw()
    {
        m_hHeap = hHeap;
    }
    // Set refcount to 1 to protect destruction
    ~_CComObjectHeap() throw()
    {
        m_dwRef = 1L;
        FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
        _AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
    }

    //If InternalAddRef or InternalRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)()throw() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()throw()
    {
        ULONG l = InternalRelease();
        if (l == 0)
        {
            HANDLE hHeap = m_hHeap;;
            this->~_CComObjectHeap();
            HeapFree(hHeap, 0, this);
        }
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) throw()
    {return _InternalQueryInterface(iid, ppvObject);}
};

inline CServerContext* CreateServerContext(HANDLE hRequestHeap) throw()
{
    // Allocate a fixed block size to avoid fragmentation
    void *pv = HeapAlloc(hRequestHeap, HEAP_ZERO_MEMORY,
        max(sizeof(AtlServerRequest), sizeof(_CComObjectHeap<CServerContext>)));
    if (!pv)
        return FALSE;

    _CComObjectHeap<CServerContext>* pContext = new(pv) _CComObjectHeap<CServerContext>(hRequestHeap);

    return pContext;
}
#pragma pop_macro("new")

// _AtlGetHandlerName
// get handler name from stencil file. Ignore all server side comments
//  szFileName - the file from which to extract the handler name
//  szHandlerName - buffer into which handler name will be copied,
//       it is assumed to be of size MAX_PATH+ATL_MAX_HANDLER_NAME+2
inline HTTP_CODE _AtlGetHandlerName(LPCSTR szFileName, LPSTR szHandlerName) throw()
{
    szHandlerName[0] = '\0';
    CAtlFile cfFile;
    HRESULT hr;

	_ATLTRY
	{
    hr = cfFile.Create(CA2TEX<MAX_PATH+1>(szFileName), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
	if (FAILED(hr))
		return HTTP_ERROR(500, ISE_SUBERR_LOADFILEFAIL);
	}
	_ATLCATCHALL()
	{
		return ISE_SUBERR_OUTOFMEM; // CA2TEX threw
	}

    if (cfFile.m_h == NULL || GetFileType(cfFile.m_h) != FILE_TYPE_DISK)
    {
        if (hr == AtlHresultFromWin32(ERROR_FILE_NOT_FOUND))
            return HTTP_ERROR(404, SUBERR_NONE);
        else            
            return HTTP_ERROR(500, IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL);
    }

    HTTP_CODE hcErr = HTTP_SUCCESS;
    DWORD dwRead=0;
    LPSTR szHandler = "handler";
    LPSTR pszHandlerPos = NULL;
    LPSTR pszHandlerName = szHandlerName;
    char szBuf[4097];
    LPSTR szCurly = NULL;
    LPSTR pszBuf = NULL;
    bool bInQuote = false;

    // state:
    //  0 = default/unknown
    //  1 = have "{"
	//  2 = have "{{" -- skip spaces
    //  3 = have "{{" -- check "handler"
    //  4 = have "handler" -- skip spaces
    //  5 = have "handler" -- get name
    //  6 = scan until first '}'
    //  7 = better be '}'
    //  8 = done
    int nState = 0;

    do
    {
        hr = cfFile.Read(szBuf, sizeof(szBuf)-1, dwRead);
        if (hr != S_OK)
        {
            return HTTP_ERROR(500, ISE_SUBERR_READFILEFAIL); // failed reading
        }

        szBuf[dwRead] = '\0';
        pszBuf = szBuf;

        while (*pszBuf && nState != 8)
        {
            switch (nState)
            {
            case 0: 
                //  0 = default/unknown

                // look for the first curly
                szCurly = strchr(pszBuf, '{');
                if (!szCurly)
                {
                    // skip to the end of the buffer
                    pszBuf = szBuf+dwRead-1;
                }
                else
                {
                    pszBuf = szCurly;
                    nState = 1;
                }
                break;
            case 1:
                //  1 = have "{"
                if (*pszBuf == '{') 
                {
                    nState = 2;
                }
                else
                {
                    nState = 0; // if the next character is not a '{', start over
                }
                break;
			case 2:
				if (!isspace(*pszBuf))
				{
					pszHandlerPos = szHandler;
					pszBuf--;
					nState = 3;
				}
				break;
            case 3:
                //  3 = partial handler "h..." 
                if (*pszBuf != *pszHandlerPos)
                {
                    // not a handler, skip tag
                    nState = 6;
                }
                else
                {
                    pszHandlerPos++;
                    if (!*pszHandlerPos) // at the end of the "handler" part
                        nState = 4;
                }
                break;
            case 4:
                //  4 = have "handler" -- skip spaces
                if (!isspace(*pszBuf))
                {
                    if (*pszBuf == '\"')
                    {
                        bInQuote = true;
                    }
                    else
                    {
                        pszBuf--;
                    }
                    nState = 5;
                }
                break;
            case 5:
                //  5 = have "handler" -- get name
                if (isspace(*pszBuf) && !bInQuote)
                {
                    if (*(pszHandlerName-1) != '/')
                    {
                        // end of the name -- jump to getting the first '}'
                        nState = 6;
                    }
                    else
                    {
                        nState = 4;
                    }
                }
                else if (*pszBuf == '}')
                {
                    // end of the name -- jump to getting the second '}'
                    nState = 7;
                }
                else if (*pszBuf == '\"')
                {
                    if (bInQuote)
                    {
                        bInQuote = false;
                    }
                    else
                    {
                        hcErr = HTTP_FAIL;
                        nState = 8;
                    }
                }
                else
                {
                    // ensure we don't overwrite the buffer
                    if (pszHandlerName-szHandlerName >= MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1)
                    {
                        hcErr =  HTTP_FAIL;
                        nState = 8;
                    }
                    else
                    {
                        *pszHandlerName++ = *pszBuf;
                    }
                }
                break;
            case 6:
                //  6 = scan until first '}'
                if (*pszBuf == '}')
                    nState = 7;
                break;
            case 7:
                //  7 = better be '}'
                if (*pszBuf != '}')
                {
                    hcErr = HTTP_ERROR(500, ISE_SUBERR_BAD_HANDLER_TAG);
                    nState = 8;
                }
                if (*szHandlerName)
                    nState = 8;
                else
                    nState = 0;
                break;
            default:
                __assume( 0 ); // the optimizer will not generate code for this branch
            }

            pszBuf++;
        }
    } while (dwRead != 0 && nState != 8);
    
    *pszHandlerName = '\0';

    return hcErr;
}

// _AtlCrackHandler cracks a request path of the form dll_path/handler_name into its
// consituent parts
// szHandlerDllName - the full handler path of the form "dll_path/handler_name"
// szDllPath - the DLL path (should be of length MAX_PATH+1)
// szHandlerName - the handler name (should be of length ATL_MAX_HANDLER_NAME_LEN+1)
//
inline BOOL _AtlCrackHandler(
    LPCSTR szHandlerDllName,
    LPSTR szDllPath,
    LPDWORD pdwDllPathLen,
    LPSTR szHandlerName,
    LPDWORD pdwHandlerNameLen) throw()
{
    ATLASSERT( szHandlerDllName != NULL );
    ATLASSERT( szDllPath != NULL );
    ATLASSERT( pdwDllPathLen != NULL );
    ATLASSERT( szHandlerName != NULL );
    ATLASSERT( pdwHandlerNameLen != NULL );
    
    BOOL bRet = TRUE;
    
    // skip leading spaces
    while (*szHandlerDllName && isspace(*szHandlerDllName))
        ++szHandlerDllName;

    // get the handler name
    LPSTR szSlash = strchr(szHandlerDllName, '/');
    LPSTR szEnd = NULL;
    LPSTR szSlashEnd = NULL;
    
    // if it is of the form <dll_name>/<handler_name>
    if (szSlash)
    {
        szEnd = szSlash;
        
        // skip trailing spaces on <dll_name>
        while (szEnd>szHandlerDllName && isspace(*(szEnd-1)))
            --szEnd;

        szSlash++;
        // skip leading whitespace
        while (*szSlash && isspace(*szSlash))
            szSlash++;
        
        // right trim szSlash;
        szSlashEnd = szSlash;
        while (*szSlashEnd && !isspace(*szSlashEnd))
            szSlashEnd++;       
    }
    else // only the <dll_name>
    {
        szSlash = "Default";
        szSlashEnd = szSlash+sizeof("Default")-1;

        // do it this way to handle paths with spaces
        // (e.g. "some path\subdirectory one\subdirectory two\dll_name.dll")
        szEnd = (LPSTR) (szHandlerDllName+strlen(szHandlerDllName));
        
        // skip trailing spaces
        while (szEnd>szHandlerDllName && isspace(*(szEnd-1)))
            --szEnd;
    }

    // if the dll path is quoted, strip the quotes
    if (*szHandlerDllName == '\"' && *(szEnd-1) == '\"' && szEnd > szHandlerDllName+2)
    {
        szHandlerDllName++;
        szEnd--;
    }

    if (*pdwDllPathLen > (DWORD)(szEnd-szHandlerDllName))
    {
        memcpy(szDllPath, szHandlerDllName, szEnd-szHandlerDllName);
        szDllPath[szEnd-szHandlerDllName] = '\0';
        *pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName);
    }
    else
    {
        *pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName)+1;
        bRet = FALSE;
    }

    if (*pdwHandlerNameLen > (DWORD)(szSlashEnd-szSlash))
    {
        memcpy(szHandlerName, szSlash, (szSlashEnd-szSlash));
        szHandlerName[szSlashEnd-szSlash] = '\0';
        *pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash);
    }
    else
    {
        *pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash)+1;
        bRet = FALSE;
    }
    
    return bRet;
}

inline HTTP_CODE _AtlLoadRequestHandler(
            LPCSTR szDllPath, 
            LPCSTR szHandlerName,
            IHttpServerContext *pServerContext, 
            HINSTANCE *phInstance, 
            IRequestHandler **ppHandler,
            IIsapiExtension *pExtension,
            IDllCache *pDllCache) throw(...)
{
    *phInstance = NULL;
    *ppHandler = NULL;

    ATLServerDllInfo DllInfo;
    DllInfo.pExtension = pExtension;
    DllInfo.pContext = pServerContext;
    if (!IsFullPathA(szDllPath))
    {
        CHAR szFileName[MAX_PATH];
        if (!GetScriptFullFileName(szDllPath, szFileName, pServerContext))
        {
            return HTTP_FAIL;
        }
        *phInstance = pDllCache->Load(szFileName, (void *)&DllInfo);
    }
    else
    {
        *phInstance = pDllCache->Load(szDllPath, (void *)&DllInfo);
    }
    if (!*phInstance)
    {
        ATLTRACE( "LoadLibrary failed: '%s' with error: %d\r\n", szDllPath, GetLastError() );
        return HTTP_ERROR(500, ISE_SUBERR_LOADLIB);
    }
    
    CComPtr<IUnknown> spUnk;

    if (!DllInfo.pfnGetHandler || 
        !DllInfo.pfnGetHandler(szHandlerName, pExtension, &spUnk) ||
        spUnk->QueryInterface(__uuidof(IRequestHandler), (void **)ppHandler))
    {
        pDllCache->Free(*phInstance);
        *phInstance = NULL;
        return HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
    }

    return HTTP_SUCCESS;
} // _AtlLoadRequestHandler


class CTransferServerContext : public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    char m_szFileName[MAX_PATH+1];
    char m_szQueryString[ATL_URL_MAX_PATH_LENGTH+1];
    IWriteStream *m_pStream;

    BEGIN_COM_MAP(CTransferServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    CTransferServerContext() throw()
    {
        m_pStream = NULL;
    }

    BOOL Initialize(LPCSTR szUrl, IWriteStream *pStream, IHttpServerContext *pParent) throw()
    {
        m_pStream = pStream;
        m_spParent = pParent;
		m_szFileName[0] = '\0';
		long nUrlLen = (long)strlen(szUrl);

        if (!IsFullPathA(szUrl))
        {
            DWORD dwLen = MAX_PATH;
            BOOL bRet = m_spParent->GetServerVariable(
                                        "APPL_PHYSICAL_PATH",
                                        m_szFileName,
                                        &dwLen);
            if (!bRet)
                return FALSE;
        }

		// check for query params
        LPCSTR szMark = strchr(szUrl, '?');
        if (szMark)
        {
			long nPathLen = szMark - szUrl;
			if (strlen(m_szFileName) + nPathLen < MAX_PATH)
			{
				if (m_szFileName[0])
					strncat(m_szFileName, szUrl, nPathLen);
				else
				{
					memcpy(m_szFileName, szUrl, nPathLen);
					m_szFileName[nPathLen] = '\0';
				}
			}
			else
				return FALSE; // path would overwrite buffer

			// save query params
			if (strlen(szMark + 1) < ATL_URL_MAX_PATH_LENGTH)
				strcpy(m_szQueryString, szMark+1);
			else
				return FALSE; // url would overwrite buffer
        }
        else
        {
			// no query string
			if (strlen(m_szFileName) + nUrlLen < MAX_PATH)
			{
				if (m_szFileName[0])
					strcat(m_szFileName, szUrl);
				else
					strcpy(m_szFileName, szUrl);
			}
			else
				return FALSE; // path would be too long
            m_szQueryString[0] = '\0';
        }

        return TRUE;
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        HRESULT hr = m_pStream->WriteStream((LPCSTR) pvBuffer, *pdwBytes, pdwBytes);
        return SUCCEEDED(hr);
    }


    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_spParent);
        return m_szQueryString;
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        ATLASSERT(m_spParent);
        return m_szFileName;
    }

    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_spParent);
        return m_szFileName;
    }

    // Asynchronous writes will not work properly in a child handler
    BOOL AsyncWriteClient(void * /*pvBuffer*/, DWORD * /*pdwBytes*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }

    // These next few methods are to protect against attempting to parse form data twice
    // We tell the new handler that it was a GET request
    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_spParent);
        return "GET";
    }

    // The handler should not query these methods -- they are only useful if attempting to
    // parse form data, which is not allowed in child handlers.
    BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    DWORD GetTotalBytes() throw()
    {       
        ATLASSERT(FALSE);
        return 0;
    }

    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(FALSE);
        return 0;
    }

    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(FALSE);
        return NULL;
    }

    LPCSTR GetContentType() throw()
    {
        ATLASSERT(FALSE);
        return 0;
    }
};

inline HTTP_CODE _AtlTransferRequest(
    AtlServerRequest *pRequest, 
    IServiceProvider *pServiceProvider,
    IWriteStream *pWriteStream,
    IHttpRequestLookup *pLookup,
    LPCSTR szNewUrl,
    WORD nCodePage,
    bool bContinueAfterProcess = false,
    void *pState = NULL) throw(...)
{
    ATLASSERT(pRequest != NULL);
    AtlServerRequest* pRequestInfo = NULL;
    HTTP_CODE dwErr = HTTP_SUCCESS;

    CComPtr<IStencilCache> spStencilCache;

    if (pRequest->pServerContext == NULL)
        return HTTP_ERROR(500, 0);

    pServiceProvider->QueryService(
                                    __uuidof(IStencilCache),
                                    __uuidof(IStencilCache),
                                    (void**)&spStencilCache
                                    );
    if (!spStencilCache)
        return HTTP_ERROR(500, 0);

    CComObjectStackEx<CTransferServerContext> serverContext;
    serverContext.Initialize(szNewUrl, pWriteStream, pRequest->pServerContext);

    CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
    if (_pState && _pState->pIncludeInfo)
    {
        pRequestInfo = _pState->pIncludeInfo;
        _pState->pIncludeInfo = NULL;
    }
    else
    {
        ATLASSERT(spStencilCache != NULL);
        ATLASSERT(pRequest->pDllCache != NULL);
        ATLASSERT(pRequest->pExtension != NULL);

        pRequestInfo = pRequest->pExtension->CreateRequest();
        if (pRequestInfo == NULL)
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

        pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
        pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
        pRequestInfo->pDllCache = pRequest->pDllCache;
        pRequestInfo->pExtension = pRequest->pExtension;
        pRequestInfo->pServerContext = &serverContext;
        if (_pState)
            pRequestInfo->pUserData = _pState->pParentInfo->pUserData;
        else
            pRequestInfo->pUserData = pRequest->pUserData;

        // Extract the file extension of the included file by searching
        // for the first '.' from the right.
        // Can't use _tcsrchr because we have to use the stencil's codepage
        LPSTR szDot = NULL;
        LPSTR szMark = serverContext.m_szFileName;
        while (*szMark)
        {
            if (*szMark == '.')
                szDot = szMark;

            szMark = CharNextExA(nCodePage, szMark, 0);
        }

        if (szDot && _stricmp(szDot, c_AtlSRFExtension) == 0)
        {
            dwErr = pRequest->pExtension->LoadDispatchFile(
                            serverContext.m_szFileName,
                            pRequestInfo
                            );
            if (dwErr)
                return dwErr;

            CComPtr<IHttpRequestLookup> spLookup;
            DWORD dwStatus;
            if (pLookup)

            {
                dwErr = pRequestInfo->pHandler->GetFlags(&dwStatus);
                if (dwErr)
                    return dwErr;

                if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
                {
                    CComObjectNoLock<CTransferServerContext>* pServerContext = NULL;
                    ATLTRY(pServerContext = new CComObjectNoLock<CTransferServerContext>);
                    if (pServerContext == NULL)
                        return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
                    pServerContext->Initialize(szNewUrl, pWriteStream, pRequest->pServerContext);

                    pServerContext->AddRef();
                    pRequestInfo->pServerContext = pServerContext;
                }

                dwErr = pRequestInfo->pHandler->InitializeChild(
                                    pRequestInfo,
                                    pServiceProvider,
                                    pLookup);
                if (dwErr)
                    return dwErr;

            }
        }
        else if (szDot && _stricmp(szDot, ".dll") == 0)
        {
            // Get the handler name if they used the asdf.dll?Handler=Default notation
            // REVIEW : case sensitivity on the "Handler"?
            char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1] = { '\0' };

            LPSTR szStart = strstr(serverContext.m_szQueryString, "Handler");
            if (szStart)
            {
                szStart += 8;  // Skip past "Handler" and the "="
                LPSTR szEnd = strchr(szStart, '&');
                if (szEnd)
                {
                    memcpy(szHandlerName, szStart, min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN));
                    szHandlerName[min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN)] = '\0';
                }
                else
                {
                    strcpy(szHandlerName, szStart);
                }
            }
            else
            {
                memcpy(szHandlerName, "Default", sizeof("Default"));
            }

            pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;

            dwErr = pRequest->pExtension->LoadRequestHandler(
                                            serverContext.m_szFileName,
                                            szHandlerName,
                                            pRequestInfo->pServerContext,
                                            &pRequestInfo->hInstDll,
                                            &pRequestInfo->pHandler
                                            );
			if (dwErr != HTTP_SUCCESS)
				return dwErr;

            ATLASSERT(pLookup);
            dwErr = pRequestInfo->pHandler->InitializeChild(
                                            pRequestInfo,
                                            pServiceProvider,
                                            pLookup
                                            );
        }

        pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;
    }

    if (pRequestInfo)
    {
        if (!dwErr)
        {
            if (pRequestInfo->pServerContext == NULL)
                pRequestInfo->pServerContext = &serverContext;

            ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);
            dwErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, pServiceProvider);

            if (pRequestInfo->pServerContext == &serverContext)
                pRequestInfo->pServerContext = NULL;

            if (IsAsyncStatus(dwErr))
            {
                ATLASSERT(pState); // state is required for async
                if (IsAsyncContinueStatus(dwErr))
                {
                    _pState->pIncludeInfo = pRequestInfo;
                    pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;
                }
                else if (IsAsyncDoneStatus(dwErr))
                    pRequest->pExtension->FreeRequest(pRequestInfo);
            }
            else
                pRequest->pExtension->FreeRequest(pRequestInfo);
        }
    }
    else
        dwErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

    if (dwErr == HTTP_SUCCESS && bContinueAfterProcess)
        return dwErr;
    return HTTP_SUCCESS_NO_PROCESS;
}

//
// Used to terminate process when buffer security check fails
//
inline void __cdecl AtlsSecErrHandlerFunc(int nCode, void * /* pv */)
{
    nCode;

#if defined(_M_IX86)
    //
    // only valid code
    //
    ATLASSERT( nCode == _SECERR_BUFFER_OVERRUN );
#endif

    //
    // a buffer overflow has occurred in your code
    //
    ATLASSERT( FALSE );

    //
    // terminate process (safest thing to do)
    //
    TerminateProcess( GetCurrentProcess(), 1 );
}

//
// Class CIsapiExtension
// The main ISAPI Extension implementation.
// Template parameters
// ThreadPoolClass: Specifies the thread pool that will be used by the 
//		extension to queue incoming requests. CThreadPool is the
//		default and is declared and implemented in ATLUTIL.H. This class
//		templatizes on a worker thread class. The worker thread class
//		represents an abstraction of a thread that will be used to
//		process requests as they are dequeued from the pool's work queue.
//		You would change this parameter if you wanted to use a completely
//		different thread pool, or, more commonly, if you wanted to use 
//		a different worker thread class. Request processing code can
//		access a pointer to the worker thread class, which allows the
//		request handling code to easily access per-thread data.
// CRequestStatClass:	Specifies the class to be used to track request statistics
//		CNoRequestStats is the default which is a noop class.
//		You would change this parameter to provide a class that will
//		track request statistics for you. ATL provides CStdRequestStats
//		and CPerfRequestStatObject but these classes should be used
//		with caution because they require interlocked operations to
//		keep track of request statistics which can affect server performance.
// HttpUserErrorTextProvider: This class provides error text messages
//		and headers, including  resource IDs of error messages to the
//		isapi extension's error handling functions. You would change this
//		parameter if you wanted to provide your own error headers and/or
//		messages in response to error encountered during request processing.
// WorkerThreadClass: The worker thread that will be used for this extension.
//		The worker thread will be used to sweep any caches used by the extension
//		and perform other periodic maintanence work while the extension is 
//		loaded. You would provide your own worker thread class to customize
//		when the worker thread times out.
// CPageCacheStats, CStencilCacheStats: These two classes are used to keep
//		statistics about the page and stencil caches. You could change these
//		paramters if you wanted to track statistics for these caches. ATL
//		provides CPerfStatClass and CStdStatClass to store the stat data but
//		using these classes can affect server performance because they use
//		interlocked operations internally to store the data.
template <  class ThreadPoolClass=CThreadPool<CIsapiWorker>, 
            class CRequestStatClass=CNoRequestStats,
            class HttpUserErrorTextProvider=CDefaultErrorProvider,
            class WorkerThreadTraits=DefaultThreadTraits,
            class CPageCacheStats=CNoStatClass,
            class CStencilCacheStats=CNoStatClass>
class CIsapiExtension :
    public IServiceProvider, public IIsapiExtension, public IRequestStats
{
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

	DWORD m_dwCriticalIsapiError;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

protected:
    typedef CWorkerThread<WorkerThreadTraits> extWorkerType;

    extWorkerType m_WorkerThread;
    ThreadPoolClass m_ThreadPool;
    
    CDllCache<extWorkerType, CDllCachePeer> m_DllCache;
    CFileCache<extWorkerType, CPageCacheStats, CPageCachePeer> m_PageCache;
    CComObjectGlobal<CStencilCache<extWorkerType, CStencilCacheStats > > m_StencilCache;
    HttpUserErrorTextProvider m_UserErrorProvider;
    HANDLE m_hRequestHeap;
    CComCriticalSection m_critSec;

    // Dynamic services stuff
    struct ServiceNode
    {
        HINSTANCE hInst;
        IUnknown *punk;
        GUID guidService;
        IID riid;

        ServiceNode() throw()
        {
        }

        ServiceNode(const ServiceNode& that) throw()
            :hInst(that.hInst), punk(that.punk), guidService(that.guidService), riid(that.riid)
        {
        }
    };

    class CServiceEqualHelper
    {
    public:
        static bool IsEqual(const ServiceNode& t1, const ServiceNode& t2) throw()
        {
            return (InlineIsEqualGUID(t1.guidService, t2.guidService) != 0 &&
                    InlineIsEqualGUID(t1.riid, t2.riid) != 0);
        }
    };

    CSimpleArray<ServiceNode, CServiceEqualHelper> m_serviceMap;

public:
    DWORD m_dwTlsIndex;
    CWin32Heap m_heap;

    CRequestStatClass m_reqStats;

    AtlServerRequest *CreateRequest() throw()
    {
        // Allocate a fixed block size to avoid fragmentation
        AtlServerRequest *pRequest = (AtlServerRequest *) HeapAlloc(m_hRequestHeap, 
                HEAP_ZERO_MEMORY, max(sizeof(AtlServerRequest), sizeof(_CComObjectHeap<CServerContext>)));
        if (!pRequest)
            return NULL;
        pRequest->cbSize = sizeof(AtlServerRequest);
        return pRequest;
    }

    void FreeRequest(AtlServerRequest *pRequest) throw()
    {
        _ReleaseAtlServerRequest(pRequest);
        HeapFree(m_hRequestHeap, 0, pRequest);
    }

    CIsapiExtension() throw()
    {
        m_hRequestHeap = NULL;
#ifdef _DEBUG
        m_bDebug = FALSE;
#endif
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
		
		m_dwCriticalIsapiError = 0;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

    }

    HTTP_CODE TransferRequest(
                        AtlServerRequest *pRequest, 
                        IServiceProvider *pServiceProvider,
                        IWriteStream *pWriteStream,
                        IHttpRequestLookup *pLookup,
                        LPCSTR szNewUrl,
                        WORD nCodePage,
                        bool bContinueAfterProcess = false,
                        void *pState = NULL
                        ) throw(...)
    {
        return _AtlTransferRequest(pRequest, pServiceProvider, pWriteStream,
            pLookup, szNewUrl, nCodePage, bContinueAfterProcess, pState);
    }

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
	DWORD ReturnCriticalError(EXTENSION_CONTROL_BLOCK *pECB) throw()
	{
        UINT uResId = 0;
		LPCSTR szHeader = NULL;

		m_UserErrorProvider.GetErrorText(500,
										 ISE_SUBERR_ISAPISTARTUPFAILED,
										 &szHeader,
										 &uResId);
		_ATLTRY
		{
			CStringA strStatus, strBody;
			strStatus.Format("500 %s", szHeader);
			if (uResId)
			{
				// load the body string from a resource
				if (!strBody.LoadString(uResId))
				{
					strBody = "<html><body>A critical error has occurred initializing this ISAPI extension.</body></html>";
				}
			}


			HSE_SEND_HEADER_EX_INFO hex;
			hex.pszStatus = (LPCSTR)strStatus;
			hex.pszHeader = NULL;
			hex.cchStatus = (DWORD)strStatus.GetLength();
			hex.cchHeader = 0;
			hex.fKeepConn = FALSE;

			pECB->ServerSupportFunction(pECB->ConnID,
										HSE_REQ_SEND_RESPONSE_HEADER_EX,
										&hex,
										NULL,
										NULL);

			DWORD dwBodyLen = strBody.GetLength();
			pECB->WriteClient(pECB->ConnID, 
							 (void *) (LPCSTR) strBody,
							 &dwBodyLen,
							 NULL);
		}
		_ATLCATCHALL()
		{
			//REALLY BAD!
			return HSE_STATUS_ERROR;
		}
		return HSE_STATUS_SUCCESS;
	}
#endif // ATL_NO_CRITICAL_ISAPI_ERROR

    DWORD HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK lpECB) throw()
    {
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
		if (GetCriticalIsapiError() != 0)
		{
			return ReturnCriticalError(lpECB);
		}
#endif // ATL_NO_CRITICAL_ISAPI_ERROR

        AtlServerRequest *pRequestInfo = NULL;
        pRequestInfo = CreateRequest();
        if (pRequestInfo == NULL)
            return HSE_STATUS_ERROR;

        CServerContext *pServerContext = NULL;
        ATLTRY(pServerContext = CreateServerContext(m_hRequestHeap));
        if (pServerContext == NULL)
        {
            FreeRequest(pRequestInfo);
            return HSE_STATUS_ERROR;
        }
        pServerContext->Initialize(lpECB);
        pServerContext->AddRef();

        pRequestInfo->pServerContext = pServerContext;
        pRequestInfo->dwRequestType = ATLSRV_REQUEST_UNKNOWN;
        pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
        pRequestInfo->pExtension = static_cast<IIsapiExtension *>(this);
        pRequestInfo->pDllCache = static_cast<IDllCache *>(&m_DllCache);
#ifndef ATL_NO_MMSYS
        pRequestInfo->dwStartTicks = timeGetTime();
#else
        pRequestInfo->dwStartTicks = GetTickCount();
#endif
        pRequestInfo->pECB = lpECB;

        m_reqStats.OnRequestReceived();

        if (m_ThreadPool.QueueRequest(pRequestInfo))
            return HSE_STATUS_PENDING;

        // QueueRequest failed
        FreeRequest(pRequestInfo);
        return HSE_STATUS_ERROR;
    }


    BOOL QueueRequest(AtlServerRequest * pRequestInfo) throw()
    {
        return m_ThreadPool.QueueRequest(pRequestInfo);
    }

    CIsapiWorker *GetThreadWorker() throw()
    {
        return (CIsapiWorker *) TlsGetValue(m_dwTlsIndex);
    }

    BOOL SetThreadWorker(CIsapiWorker *pWorker) throw()
    {
        return TlsSetValue(m_dwTlsIndex, (void*)pWorker);
    }


    // Configuration functions -- override in base class if another value is desired
    virtual LPCSTR GetExtensionDesc() throw() { return "VC Server Classes"; }
    virtual int GetNumPoolThreads() throw() { return 0; }
    virtual int GetPoolStackSize() throw() { return 0; }
    virtual HANDLE GetIOCompletionHandle() throw() { return INVALID_HANDLE_VALUE; }
    virtual DWORD GetDllCacheTimeout() throw() { return ATL_DLL_CACHE_TIMEOUT; }
    virtual DWORD GetStencilCacheTimeout() throw() { return ATL_STENCIL_CACHE_TIMEOUT; }
    virtual LONGLONG GetStencilLifespan() throw() { return ATL_STENCIL_LIFESPAN; }

    BOOL OnThreadAttach() throw()
    {
        return SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    }

    void OnThreadTerminate() throw()
    {
        CoUninitialize();
    }


#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
	BOOL SetCriticalIsapiError(DWORD dwErr = 1) throw()
	{
		m_dwCriticalIsapiError = dwErr;
		return TRUE;
	}


	DWORD GetCriticalIsapiError() throw()
	{
		return m_dwCriticalIsapiError;
	}

#else
	BOOL SetCriticalIsapiError(DWORD dwErr = 1) throw()
	{
		return FALSE;
	}

	DWORD GetCriticalIsapiError() throw()
	{
		return 0;
	}

#endif // ATL_NO_CRITICAL_ISAPI_ERROR


    BOOL GetExtensionVersion(HSE_VERSION_INFO* pVer) throw()
    {
        // allocate a Tls slot for storing per thread data
        m_dwTlsIndex = TlsAlloc();

        // create a private heap for request data
        // this heap has to be thread safe to allow for
        // async processing of requests
        m_hRequestHeap = HeapCreate(0, 0, 0);
        if (!m_hRequestHeap)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Failed creating request heap.  Using process heap\n"));
            m_hRequestHeap = GetProcessHeap();
			if (!m_hRequestHeap)
			{
				return SetCriticalIsapiError();
			}

        }

        // create a private heap (synchronized) for
        // allocations.  This reduces fragmentation overhead
        // as opposed to the process heap
        HANDLE hHeap = HeapCreate(0, 0, 0);
        if (!hHeap)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Failed creating extension heap.  Using process heap\n"));
            hHeap = GetProcessHeap();
            m_heap.Attach(hHeap, false);
        }
        else
        {
            m_heap.Attach(hHeap, true);
        }
        hHeap = NULL;

        if (S_OK != m_reqStats.Initialize())
        {
			ATLTRACE(atlTraceISAPI,
				     0,
					 _T("Initialization failed for request statistics perfmon support.\n")
					 _T("Check request statistics perfmon dll registration\n") );

			return SetCriticalIsapiError();
        }

        if (S_OK != m_WorkerThread.Initialize())
        {
            return SetCriticalIsapiError();
        }

        if (m_critSec.Init() != S_OK)
        {
            m_WorkerThread.Shutdown();
            return SetCriticalIsapiError();
        }

        if (S_OK != m_ThreadPool.Initialize(static_cast<IIsapiExtension*>(this), GetNumPoolThreads(), GetPoolStackSize(), GetIOCompletionHandle()))
        {
            m_WorkerThread.Shutdown();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }


        if (FAILED(m_DllCache.Initialize(&m_WorkerThread, GetDllCacheTimeout())))
        {
            m_WorkerThread.Shutdown();
            m_ThreadPool.Shutdown();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }

        if (FAILED(m_PageCache.Initialize(&m_WorkerThread)))
        {
            m_WorkerThread.Shutdown();
            m_ThreadPool.Shutdown();
            m_DllCache.Uninitialize();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }

		if (S_OK != m_StencilCache.Initialize(static_cast<IServiceProvider*>(this),
										  &m_WorkerThread, 
										  GetStencilCacheTimeout(),
										  GetStencilLifespan()))
		{
			m_WorkerThread.Shutdown();
			m_ThreadPool.Shutdown();
			m_DllCache.Uninitialize();
            m_PageCache.Uninitialize();
            m_critSec.Term();
			return SetCriticalIsapiError();
        }

        pVer->dwExtensionVersion = HSE_VERSION;
        strcpy(pVer->lpszExtensionDesc, GetExtensionDesc());

        return TRUE;
    }

    BOOL TerminateExtension(DWORD /*dwFlags*/) throw()
    {
        m_critSec.Lock();
        for (int i=0; i < m_serviceMap.GetSize(); i++)
        {
            ATLASSERT(m_serviceMap[i].punk != NULL);
            m_serviceMap[i].punk->Release();
            m_DllCache.ReleaseModule(m_serviceMap[i].hInst);
        }
        m_critSec.Unlock();

		m_ThreadPool.Shutdown();
		m_StencilCache.Uninitialize();
		m_DllCache.Uninitialize();
        m_PageCache.Uninitialize();
        m_WorkerThread.Shutdown();
        m_reqStats.Uninitialize();
        m_critSec.Term();
        
        // free the request heap
        if (m_hRequestHeap != GetProcessHeap())
            HeapDestroy(m_hRequestHeap);

        // free the Tls slot that we allocated
        TlsFree(m_dwTlsIndex);

        return TRUE;
    }

    static void WINAPI AsyncCallback(LPEXTENSION_CONTROL_BLOCK /*lpECB*/,
                                     PVOID pContext,
                                     DWORD cbIO,
                                     DWORD dwError) throw(...)
    {
        ATLASSERT(pContext);

        AtlServerRequest *pRequestInfo = reinterpret_cast<AtlServerRequest*>(pContext);
        ATLASSERT(pRequestInfo);
        if (pRequestInfo->m_hMutex)
        {
            // synchronize in case the previous async_noflush call isn't finished
            // setting up state for the next call.
            DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
            if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
            {
				_ATLTRY
				{
					pRequestInfo->pExtension->RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
				}
				_ATLCATCHALL()
				{
					ATLTRACE(_T("Warning: Uncaught user exception thrown and caught in AsyncCallback.\n"));
					_ATLRETHROW;
				}
                return;
            }
        }

        if (pRequestInfo->pfnAsyncComplete != NULL)
            ATLTRY((*pRequestInfo->pfnAsyncComplete)(pRequestInfo, cbIO, dwError));

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_DONE)
        {
			pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
        }
        else if (pRequestInfo->dwRequestState == ATLSRV_STATE_CACHE_DONE)
        {
            CloseHandle(pRequestInfo->hFile);
            pRequestInfo->pFileCache->ReleaseFile(pRequestInfo->hEntry);
            pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
        }
        else 
        {
            HANDLE hMutex = pRequestInfo->m_hMutex;
            pRequestInfo->pExtension->QueueRequest(pRequestInfo);
            if (hMutex)
                ReleaseMutex(hMutex);
        }
    }

    void HandleError(IHttpServerContext *pServerContext, DWORD dwStatus, DWORD dwSubStatus) throw()
    {
        RenderError(pServerContext, dwStatus, dwSubStatus, &m_UserErrorProvider);
    }

    void RequestComplete(AtlServerRequest *pRequestInfo, DWORD dwStatus, DWORD dwSubStatus) throw(...)
    {
        ATLASSERT(pRequestInfo);
        
        if (pRequestInfo->pHandler != NULL)
            pRequestInfo->pHandler->UninitializeHandler();

		DWORD dwReqStatus = dwStatus;
		if (!dwReqStatus)
			dwReqStatus = 200;

        if (dwStatus >= 400)
        {
            if (dwSubStatus != SUBERR_NO_PROCESS)
                HandleError(pRequestInfo->pServerContext, dwStatus, dwSubStatus);
            m_reqStats.RequestHandled(pRequestInfo, FALSE);
        }
        else
            m_reqStats.RequestHandled(pRequestInfo, TRUE);

        CComPtr<IHttpServerContext> spServerContext = pRequestInfo->pServerContext;

        FreeRequest(pRequestInfo);

        spServerContext->DoneWithSession(dwReqStatus);
    }

    HTTP_CODE GetHandlerName(LPCSTR szFileName, LPSTR szHandlerName) throw()
    {
        return _AtlGetHandlerName(szFileName, szHandlerName);
    }

    HTTP_CODE LoadDispatchFile(LPCSTR szFileName, AtlServerRequest *pRequestInfo) throw()
    {
        CStencil *pStencil = NULL;
        HCACHEITEM hStencil = NULL;
        
        // Must have space for the path to the handler + the maximum size
        // of the handler, plus the '/' plus the '\0'
        CHAR szDllPath[MAX_PATH+1];
        CHAR szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];

        pRequestInfo->pHandler = NULL;
        pRequestInfo->hInstDll = NULL;

        m_StencilCache.LookupStencil(szFileName, &hStencil);

        // Stencil was found, check to see if it needs to be refreshed
        if (hStencil)
        {
            m_StencilCache.GetStencil(hStencil, (void **) &pStencil);
            pStencil->GetHandlerName(szDllPath, szHandlerName);

            CFileTime cftCurr;
            CFileTime cftLastChecked;
            cftCurr = CFileTime::GetCurrentTime();

            pStencil->GetLastChecked(&cftLastChecked);

            CFileTimeSpan d(ATL_STENCIL_CHECK_TIMEOUT * CFileTime::Millisecond);

            if (cftLastChecked + d < cftCurr)
            {
                CComPtr<IStencilCacheControl> spCacheCtrl;
                m_StencilCache.QueryInterface(__uuidof(IStencilCacheControl), (void **)&spCacheCtrl);
                if (spCacheCtrl)
                {
                    CFileTime cftLastModified;
                    pStencil->GetLastModified(&cftLastModified);

                    // Resource based stencils have a last modified filetime of 0
                    if (cftLastModified != 0)
                    {
                        // for file base stencils, we check whether the file
                        // has been modified since being put in the cache
                        WIN32_FILE_ATTRIBUTE_DATA fad;
                        pStencil->SetLastChecked(&cftCurr);
                        BOOL bRet = GetFileAttributesExA(szFileName, GetFileExInfoStandard, &fad);

                        if ((bRet && cftLastModified < fad.ftLastWriteTime) ||
                            !bRet)
                        {
                            // the file has changed or an error has occurred trying to read the file, 
                            // so remove it from the cache and force a reload
                            spCacheCtrl->RemoveStencil(hStencil);
                            pStencil = NULL;
                            hStencil = NULL;
                        }
                    }
                }   
            }
        }


        if (!hStencil)
        {
            CHAR szHandlerDllName[MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+2] = { '\0' };
            
            // not in the cache, so open the file
            HTTP_CODE hcErr = GetHandlerName(szFileName, szHandlerDllName);
            if (hcErr)
                return hcErr;
            DWORD dwDllPathLen = MAX_PATH+1;
            DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;
            if (!_AtlCrackHandler(szHandlerDllName, szDllPath, &dwDllPathLen, szHandlerName, &dwHandlerNameLen))
            {
                HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
            }
            ATLASSERT(*szHandlerName);
            ATLASSERT(*szDllPath);
            if (!*szHandlerName)
                return HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
        }
        else
            m_StencilCache.ReleaseStencil(hStencil);


        return LoadRequestHandler(szDllPath, szHandlerName, pRequestInfo->pServerContext, 
            &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
    }

    HTTP_CODE LoadDllHandler(LPCSTR szFileName, AtlServerRequest *pRequestInfo) throw()
    {
        _ATLTRY
        {
            HTTP_CODE hcErr = HTTP_SUCCESS;
			CHAR szHandler[ATL_MAX_HANDLER_NAME_LEN+1] = { 'D', 'e', 'f', 'a', 'u', 'l', 't', '\0' };
			LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();
			if (szQueryString != NULL)
			{
				LPCSTR szHdlr = strstr(szQueryString, "Handler=");
				if (szHdlr != NULL)
				{
					if ((szHdlr == szQueryString) ||
						((szHdlr > szQueryString) && (*(szHdlr-1) == '&')))
					{
						int nCnt = 0;
						LPSTR pszHandler = szHandler;
						szHdlr += sizeof("Handler=")-1;
						while (*szHdlr && *szHdlr != '&')
						{
							if (nCnt < ATL_MAX_HANDLER_NAME_LEN)
							{
								*pszHandler++ = *szHdlr++;
								nCnt++;
							}
							else
							{
								hcErr = HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
								break;
							}
						}
						if (hcErr == HTTP_SUCCESS)
						{
							*pszHandler = '\0';
						}
					}
				}
			}

			if (hcErr == HTTP_SUCCESS)
			{
				CHAR szFile[_MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1];
				strcpy(szFile, szFileName);

				hcErr = LoadRequestHandler(szFile, szHandler, pRequestInfo->pServerContext, &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
			}

            return hcErr;
        }
        _ATLCATCHALL()
        {
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
        }
    }

    BOOL TransmitFromCache(AtlServerRequest* pRequestInfo) throw()
    {
        if (strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
            return FALSE;

        char szUrl[ATL_URL_MAX_URL_LENGTH + 1];
        LPCSTR szPathInfo = pRequestInfo->pServerContext->GetPathInfo();
        LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();

        LPSTR szTo = szUrl;
        while (*szPathInfo)
        {
            *szTo++ = *szPathInfo++;
        }
        *szTo++ = '?';
        while (*szQueryString)
        {
            *szTo++ = *szQueryString++;
        }
        *szTo = '\0';

        HCACHEITEM hEntry;

        if (S_OK == m_PageCache.LookupFile(szUrl, &hEntry))
        { 
            LPSTR szFileName;
			CPageCachePeer::PeerInfo *pInfo;
            m_PageCache.GetFile(hEntry, &szFileName, (void **)&pInfo);
            CAtlFile file;
			HRESULT hr = E_FAIL;

			_ATLTRY
			{
				CA2CTEX<MAX_PATH+1> strFile(szFileName);
				hr = file.Create(strFile,
								GENERIC_READ,
								FILE_SHARE_READ,
								OPEN_EXISTING,
								FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
            
            if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
                return FALSE;

            pRequestInfo->pServerContext->SendResponseHeader(
				(LPCSTR)pInfo->strHeader, (LPCSTR)pInfo->strStatus, FALSE);
            HANDLE hFile = file.Detach();
            BOOL bRet = FALSE;

            pRequestInfo->dwRequestState = ATLSRV_STATE_CACHE_DONE;
            pRequestInfo->hFile = hFile;
            pRequestInfo->hEntry = hEntry;
            pRequestInfo->pFileCache = &m_PageCache;

            bRet = pRequestInfo->pServerContext->TransmitFile(
                hFile,                          // The file to transmit
                AsyncCallback, pRequestInfo,    // The async callback and context
                pInfo->strStatus,               // HTTP status code
                0,                              // Send entire file
                0,                              // Start at the beginning of the file
                NULL, 0,                        // Head and length
                NULL, 0,                        // Tail and length
                HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND // Send asynchronously
                );
            if (!bRet)
            {
                m_PageCache.ReleaseFile(hEntry);
                CloseHandle(hFile);
            }
            return TRUE;
        }
        else
            return FALSE;
    }

#ifdef _DEBUG
    BOOL m_bDebug;
    // F5 debugging support for VS7
    BOOL ProcessDebug(AtlServerRequest *pRequestInfo) throw()
    {
        _ATLTRY
        {
            if (!_stricmp(pRequestInfo->pServerContext->GetRequestMethod(), "debug"))
            {
                DWORD dwHeadersLen = 0;
                CStringA strHeaders;
                pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", NULL, &dwHeadersLen);
                BOOL bRet = pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", strHeaders.GetBuffer(dwHeadersLen), &dwHeadersLen);
                if (!bRet)
                {
                    RequestComplete(pRequestInfo, 501, 0);
                    return FALSE;
                }
                strHeaders.ReleaseBuffer(dwHeadersLen - 1);
                LPCSTR szCur = (LPCSTR)strHeaders;

                while(*szCur)
                {
                    if (!strncmp(szCur, "HTTP_COMMAND:", 13))
                    {
                        szCur += 13;
                        break;
                    }
                    
                    szCur = strchr(szCur, '\n');
                    if (!szCur)
                    {
                        RequestComplete(pRequestInfo, 501, 0);
                        return FALSE;
                    }

                    szCur++;
                }


                if (!_strnicmp(szCur, "start-debug", sizeof("start-debug")-sizeof('\0')))
                {
                    CCritSecLock Lock(m_critSec.m_sec);
                    if (m_bDebug)
                    {            
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_ALREADY_DEBUGGING);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_ALREADY_DEBUGGING);   // Already being debugged by another process
                        return FALSE;
                    }
                    CHttpRequest HttpRequest;
                    HttpRequest.Initialize(pRequestInfo->pServerContext);
                    HttpRequest.InitFromPost();
                    LPCSTR szString;
                    szString = HttpRequest.FormVars.Lookup("DebugSessionID");
                    if (!szString || !*szString)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_INVALID_SESSION);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_INVALID_SESSION);
                        return FALSE;
                    }
                    CA2W szSessionID(szString);
                    if (!szSessionID)
                    {
                        HandleError(pRequestInfo->pServerContext, 500, ISE_SUBERR_OUTOFMEM);
                        RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
                        return FALSE;
                    }
                    DWORD dwPid = GetCurrentProcessId();
                    LPWSTR szPoint = szSessionID;
                    while (szPoint && *szPoint && wcsncmp(szPoint, L"autoattachclsid=", 16))
                    {
                        szPoint = wcschr(szPoint, ';');
                        if (szPoint)
                            szPoint++;
                    }
                    
                    if (!szPoint || !*szPoint)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
                        return FALSE;
                    }

                    szPoint += (sizeof("autoattachclsid=") - 1);
                    WCHAR szClsid[39];
                    wcsncpy(szClsid, szPoint, 38);
                    szClsid[38] = '\0';

                    CLSID clsidDebugAutoAttach = CLSID_NULL;
                    HRESULT hr = CLSIDFromString(szClsid, &clsidDebugAutoAttach);
                    
                    if (hr != S_OK)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
                        return FALSE;
                    }

                    CComPtr<IDebugAutoAttach> spDebugAutoAttach;
                    hr = CoCreateInstance(clsidDebugAutoAttach, NULL, CLSCTX_LOCAL_SERVER, __uuidof(IDebugAutoAttach), (void**)&spDebugAutoAttach);
                    if (FAILED(hr))
                    {
                        if (hr == E_ACCESSDENIED)
                            RequestComplete(pRequestInfo, 401, 0);
                        else
                        {
                            HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_COCREATE);
                            RequestComplete(pRequestInfo, 204, DBG_SUBERR_COCREATE);
                        }
                        return FALSE;
                    }
                    hr = spDebugAutoAttach->AutoAttach(GUID_NULL, dwPid, AUTOATTACH_PROGRAM_WIN32, 0, szSessionID);
                    if (FAILED(hr))
                    {
//                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_ATTACH);
						char szRetBuf[256];
						DWORD dwLen = wsprintfA(szRetBuf, "204 HRESULT=0x%.08X;ErrorString=Unable to attach to worker process", hr);
						pRequestInfo->pServerContext->SendResponseHeader(NULL, szRetBuf, FALSE);
						pRequestInfo->pServerContext->WriteClient(szRetBuf, &dwLen);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_ATTACH);
                        return FALSE;
                    }
                    m_bDebug = TRUE;
                    HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
                    RequestComplete(pRequestInfo, 200, SUBERR_NONE);
                    return FALSE;
                }
                else if (!_strnicmp(szCur, "stop-debug", sizeof("stop-debug")-sizeof('\0')))
                {
                    m_bDebug = FALSE;
                    HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
                    RequestComplete(pRequestInfo, 200, SUBERR_NONE);
                    return FALSE;
                }
                else
                {
                    RequestComplete(pRequestInfo, 501, SUBERR_NONE);   // Not Implemented
                    return FALSE;
                }            
            }
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }
#endif

    BOOL DispatchStencilCall(AtlServerRequest *pRequestInfo) throw(...)
    {
        CSetThreadToken sec;

        m_reqStats.OnRequestDequeued();

        if (!sec.Initialize(pRequestInfo))
        {
            RequestComplete(pRequestInfo, 500, ISE_SUBERR_IMPERSONATIONFAILED);
            return FALSE;
        }

#ifdef _DEBUG
        if (!ProcessDebug(pRequestInfo))
            return TRUE;
#endif
        if (pRequestInfo->m_hMutex)
        {
            // synchronize in case the previous async_noflush call isn't finished
            // setting up state for the next call.
            DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
            if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
            {
                RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                return FALSE;
            }
        }

#ifdef _DEBUG
        bool bAsyncAllowed = false;
#endif
        HTTP_CODE hcErr = HTTP_SUCCESS;
        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN)
        {
            if (TransmitFromCache(pRequestInfo))    // Page is in the cache, send it and bail
            {                                       // Async Callback will handle freeing pRequestInfo
                return TRUE;
            }

            // get the srf filename
            LPCSTR szFileName = pRequestInfo->pServerContext->GetScriptPathTranslated();

            if (!szFileName)
            {
                RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                return FALSE;
            }

            LPCSTR szDot = szFileName + strlen(szFileName) - 1;

            // load a handler
            if (_stricmp(szDot - ATLS_EXTENSION_LEN, c_AtlSRFExtension) == 0)
            {
                pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
                hcErr = LoadDispatchFile(szFileName, pRequestInfo);
            }
            else if (_stricmp(szDot - 3, ".dll") == 0)
            {
                pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;
                hcErr = LoadDllHandler(szFileName, pRequestInfo);
            }
            else
            {
                hcErr = HTTP_FAIL;
            }

            if (hcErr)
            {
                RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
                return TRUE;
            }

            pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;

            // initialize the handler
            DWORD dwStatus = 0;

            hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);

            if (dwStatus & ATLSRV_INIT_USECACHE &&
                !strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
            {
                CComObjectNoLock<CCacheServerContext> *pCacheServerContext = NULL;
                ATLTRY(pCacheServerContext = new CComObjectNoLock<CCacheServerContext>);
                if (pCacheServerContext == NULL)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
                    return FALSE;
                }

                pCacheServerContext->Initialize(pRequestInfo->pServerContext, &m_PageCache);
                pCacheServerContext->AddRef();
                pRequestInfo->pServerContext = pCacheServerContext;
            }

            if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
            {
#ifdef _DEBUG
                bAsyncAllowed = true;
#endif
                if (!pRequestInfo->pServerContext->RequestIOCompletion(AsyncCallback, (DWORD *)pRequestInfo))
                {
                    RequestComplete(pRequestInfo, 500, SUBERR_NONE);
                    return FALSE;
                }
            }

            if (dwStatus & ATLSRV_INIT_USEASYNC_EX)
            {
                pRequestInfo->m_hMutex = CreateMutex(NULL, FALSE, NULL);
                if (pRequestInfo->m_hMutex == NULL)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_SYSOBJFAIL);
                    return FALSE;
                }

                DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, 10000);
                if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                    return FALSE;
                }
            }
            hcErr = pRequestInfo->pHandler->InitializeHandler(pRequestInfo, static_cast<IServiceProvider*>(this));
        }
#ifdef _DEBUG
        else // pRequestInfo->dwRequestState != ATLSRV_STATE_BEGIN
        {
            bAsyncAllowed = true;
        }
#endif

        ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);

	    if (hcErr == HTTP_SUCCESS)
           hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, static_cast<IServiceProvider*>(this));
 
       if (hcErr == HTTP_SUCCESS_NO_CACHE)
        {
            CComPtr<IPageCacheControl> spControl;
            HRESULT hr = pRequestInfo->pServerContext->QueryInterface(__uuidof(IPageCacheControl), (void **)&spControl);
            if (hr == S_OK)
                spControl->Cache(FALSE);
        }

#ifdef _DEBUG
        // must use ATLSRV_INIT_USEASYNC to use ASYNC returns
        if (IsAsyncStatus(hcErr))
            ATLASSERT(bAsyncAllowed);

        // must use ATLSRV_INIT_USEASYNC_EX to use NOFLUSH returns
        if (IsAsyncNoFlushStatus(hcErr))
            ATLASSERT(pRequestInfo->m_hMutex);
#endif

        // save hMutex in case pRequestInfo is deleted by AsyncCallback after
        // we call StartAsyncFlush but before we check to see if we need to
        // call ReleaseMutex
        HANDLE hMutex = pRequestInfo->m_hMutex;

        if (IsAsyncStatus(hcErr))
        {
            if (IsAsyncDoneStatus(hcErr))
                pRequestInfo->dwRequestState = ATLSRV_STATE_DONE;
            else
                pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;

            if (IsAsyncFlushStatus(hcErr) && !StartAsyncFlush(pRequestInfo))
            {
                RequestComplete(pRequestInfo, 500, SUBERR_NONE);
                pRequestInfo = NULL;
            }
        }
        else
        {
            RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
            pRequestInfo = NULL;
        }

        if (hMutex)
            ReleaseMutex(hMutex);

        return TRUE;
    }

    BOOL StartAsyncFlush(AtlServerRequest *pRequestInfo) throw()
    {
        if (pRequestInfo->pszBuffer == NULL || pRequestInfo->dwBufferLen == 0)
        {
            ATLASSERT(FALSE);
            return FALSE;
        }

        return pRequestInfo->pServerContext->AsyncWriteClient(
            LPVOID(pRequestInfo->pszBuffer),
            &pRequestInfo->dwBufferLen);
    }

    long GetTotalRequests() throw()
    {
        return m_reqStats.GetTotalRequests();
    }

    long GetFailedRequests() throw()
    {
        return m_reqStats.GetFailedRequests();
    }

    long GetAvgResponseTime() throw()
    {
        return m_reqStats.GetAvgResponseTime();
    }

    long GetCurrWaiting() throw()
    {
        return m_reqStats.GetCurrWaiting();
    }

    long GetMaxWaiting() throw()
    {
        return m_reqStats.GetMaxWaiting();
    }

    long GetActiveThreads() throw()
    {
        return m_reqStats.GetActiveThreads();
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IRequestStats)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IRequestStats*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IServiceProvider)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IServiceProvider*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IIsapiExtension)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IIsapiExtension*>(this));
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        return 1;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryService(
        REFGUID guidService,
        REFIID riid,
        void **ppvObject) throw()
    {
        if (!ppvObject)
            return E_POINTER;

        if (InlineIsEqualGUID(guidService, __uuidof(IDllCache)))
            return m_DllCache.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IStencilCache)))
            return m_StencilCache.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IThreadPoolConfig)))
            return m_ThreadPool.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IAtlMemMgr)))
        {
            *ppvObject = static_cast<IAtlMemMgr *>(&m_heap);
            return S_OK;
        }
#ifndef ATL_NO_SOAP
		else if (InlineIsEqualGUID(guidService, __uuidof(ISAXXMLReader)))
		{
			CIsapiWorker *p = GetThreadWorker();
			ATLASSERT( p != NULL );
			return p->m_spReader->QueryInterface(riid, ppvObject);
		}
#endif

        // otherwise look it up in the servicemap
        return GetService(guidService, riid, ppvObject);
    }

    virtual HRESULT AddService(REFGUID guidService, REFIID riid, IUnknown *punkService, HINSTANCE hInstance) throw()
    {
        if (!m_DllCache.AddRefModule(hInstance))
            return E_FAIL;

		if (!punkService)
			return E_INVALIDARG;
        
        CCritSecLock Lock(m_critSec.m_sec);
        
        ServiceNode srvNode;
        srvNode.hInst = hInstance;
        srvNode.punk = punkService;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));
        
        // if the service is already there, return S_FALSE
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex >= 0)
            return S_FALSE;

        if (!m_serviceMap.Add(srvNode))
            return E_OUTOFMEMORY;

        punkService->AddRef();
        return S_OK;
    }

    virtual HRESULT RemoveService(REFGUID guidService, REFIID riid) throw()
    {
        CCritSecLock Lock(m_critSec.m_sec);
        
        ServiceNode srvNode;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex < 0)
            return S_FALSE;

        ATLASSERT(m_serviceMap[nIndex].punk != NULL);
        m_serviceMap[nIndex].punk->Release();

        HINSTANCE hInstRemove = m_serviceMap[nIndex].hInst;

        m_serviceMap.RemoveAt(nIndex);

        if (!m_DllCache.ReleaseModule(hInstRemove))
            return S_FALSE;

        return S_OK;
    }

    HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObject) throw()
    {
        if (!ppvObject)
            return E_POINTER;

        *ppvObject = NULL;
        if (!m_serviceMap.GetSize())
            return E_NOINTERFACE;

        ServiceNode srvNode;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));

        CCritSecLock Lock(m_critSec.m_sec);
        
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex < 0)
            return E_NOINTERFACE;

        ATLASSERT(m_serviceMap[nIndex].punk != NULL);
        return m_serviceMap[nIndex].punk->QueryInterface(riid, ppvObject);
    }

    HTTP_CODE LoadRequestHandler(LPCSTR szDllPath, LPCSTR szHandlerName, IHttpServerContext *pServerContext,
        HINSTANCE *phInstance, IRequestHandler **ppHandler) throw()
    {
        return _AtlLoadRequestHandler(szDllPath, szHandlerName, pServerContext, 
            phInstance, ppHandler, this, static_cast<IDllCache*>(&m_DllCache));
    } // LoadRequestHandler

}; // class CIsapiExtension

//===========================================================================================
// IMPORTANT NOTE TO USERS: 
// DO NOT ASSUME *ANYTHING* ABOUT THE STRUCTURE OF THESE MAPS/ENTRIES/FUNCTIONS--THEY CAN 
// AND *WILL* CHANGE IN THE FUTURE. CORRECT USAGE MANDATES THAT YOU USE THE MACROS PROVIDED.
// ABSOLUTELY NO GUARANTEES ABOUT BACKWARD COMPATABILITY ARE MADE FOR MANUALLY DEFINED 
// HANDLERS OR FUNCTIONS.
//===========================================================================================

typedef BOOL (*CREATEHANDLERFUNC)(IIsapiExtension *pExtension, IUnknown **ppOut);
typedef BOOL (*INITHANDLERFUNC)(IHttpServerContext*, IIsapiExtension*);
typedef void (*UNINITHANDLERFUNC)();

struct _HANDLER_ENTRY
{
    LPCSTR szName;
    CREATEHANDLERFUNC pfnCreate;
    INITHANDLERFUNC pfnInit;
    UNINITHANDLERFUNC pfnUninit;
};
// definitions of data segments and _HANDLER_ENTRY delimiters
#pragma data_seg(push)
#pragma data_seg("ATLS$A")
__declspec(selectany) ATL::_HANDLER_ENTRY * __phdlrA = NULL;
#pragma data_seg("ATLS$Z") 
__declspec(selectany) ATL::_HANDLER_ENTRY * __phdlrZ = NULL;
#pragma data_seg("ATLS$C")
#pragma data_seg(pop)

#ifndef HANDLER_ENTRY_PRAGMA

#if defined(_M_IX86)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:___phdlrEntry_" #class "_" #line))
#elif defined(_M_IA64)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:__phdlrEntry_" #class "_" #line))
#else
#error Unknown Platform. define HANDLER_ENTRY_PRAGMA
#endif

#endif // HANDLER_ENTRY_PRAGMA

// DECLARE_REQUEST_HANDLER macro
#define __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, lineNum) \
__declspec(selectany) ATL::_HANDLER_ENTRY __hdlrEntry_ ## className ## _ ## lineNum = { handlerName, className::CreateRequestHandler, className::InitRequestHandlerClass, className::UninitRequestHandlerClass }; \
extern "C" __declspec(allocate("ATLS$C")) __declspec(selectany) \
ATL::_HANDLER_ENTRY * __phdlrEntry_ ## className ## _ ## lineNum = &__hdlrEntry_ ## className ## _ ## lineNum; \
HANDLER_ENTRY_PRAGMA(className, lineNum) \
__if_not_exists(GetAtlHandlerByName) \
{ \
extern "C" ATL_NOINLINE inline BOOL __declspec(dllexport) __stdcall GetAtlHandlerByName(LPCSTR szHandlerName, IIsapiExtension *pExtension, IUnknown **ppHandler) throw() \
{ \
    *ppHandler = NULL; \
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName) \
        { \
            if (strcmp((*pEntry)->szName, szHandlerName)==0) \
            { \
                return (*(*pEntry)->pfnCreate)(pExtension, ppHandler); \
            } \
        } \
        pEntry++; \
    } \
    return FALSE; \
} \
extern "C" ATL_NOINLINE inline  BOOL __declspec(dllexport) __stdcall InitializeAtlHandlers(IHttpServerContext *pContext, IIsapiExtension *pExt) throw() \
{ \
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    BOOL bRet = TRUE; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnInit) \
        { \
            bRet = (*(*pEntry)->pfnInit)(pContext, pExt); \
            if (!bRet) \
                break; \
        } \
        pEntry++; \
    } \
    if (!bRet) \
    { \
        if (pEntry == &__phdlrA) \
            return FALSE; \
        do \
        { \
            pEntry--; \
            (*(*pEntry)->pfnUninit)(); \
        } \
        while (pEntry != &__phdlrA); \
    } \
    return bRet; \
} \
extern "C" ATL_NOINLINE inline void __declspec(dllexport) __stdcall UninitializeAtlHandlers() throw() \
{\
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnUninit) \
        { \
            (*(*pEntry)->pfnUninit)(); \
        } \
        pEntry++; \
    } \
} \
}

// TODO (jasjitg): When __COUNTER__ becomes available, replace __LINE__ with that
#define __DECLARE_REQUEST_HANDLER(handlerName, className, lineNum) __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, lineNum)
#define DECLARE_REQUEST_HANDLER(handlerName, className) __DECLARE_REQUEST_HANDLER(handlerName, className, __COUNTER__)

#define BEGIN_HANDLER_MAP()
#define HANDLER_ENTRY(handlerName, className) DECLARE_REQUEST_HANDLER(handlerName, className)
#define END_HANDLER_MAP()

#define HANDLER_ENTRY_SDL(handlerString, handlerClass, sdlClassName)\
__declspec(selectany) LPCSTR s_szClassName##handlerClass=handlerString;\
typedef CSDLGenerator<handlerClass, s_szClassName##handlerClass> sdlClassName; \
HANDLER_ENTRY(handlerString, handlerClass)\
HANDLER_ENTRY(#sdlClassName, sdlClassName)

// 
// Use this class to check the authorization level of a client who is making
// a request to this application. This class checks for the stronger authentication
// levels (NTLM and Negotiate). You can call it directly from an implementation
// of HandleRequest to check authorization before handling a request.
#define MAX_AUTH_TYPE 50
#define MAX_NAME_LEN 255

template <class T>
class CVerifyAuth
{
public:
    HTTP_CODE IsAuthorized(AtlServerRequest *pInfo, const SID* psidAuthGroup) throw()
    {
        HTTP_CODE hcErr = HTTP_UNAUTHORIZED;
        char szAuthType[MAX_AUTH_TYPE];
        DWORD dwSize = MAX_AUTH_TYPE;
        if (pInfo->pServerContext->GetServerVariable("AUTH_TYPE", 
            szAuthType, &dwSize))
        {
            if (szAuthType[0] && (!_stricmp(szAuthType, "NTLM") 
                || !_stricmp(szAuthType, "Negotiate")))
            {
                // if we were passed a group name
                // we check to see that the logged on user is part
                // of that group, else we just return success.
                if (psidAuthGroup)
                {
                    T* pT = static_cast<T*>(this);
                    if (pT->CheckAccount(pInfo->pServerContext, psidAuthGroup))
                        hcErr = HTTP_SUCCESS;
                    else
                        hcErr = pT->HandleError(pInfo);
                }
                else
                    hcErr = HTTP_SUCCESS;
            }
        }
        return hcErr;       
    }

    bool CheckAccount(IHttpServerContext *pContext, const SID *psidAuthGroup) throw()
    {
        pContext; // unused
        psidAuthGroup; // unused
        return true;
    }

    HTTP_CODE HandleError(AtlServerRequest *pRequestInfo) throw()
    {
        pRequestInfo; // unused
        return HTTP_FAIL;
    }
    
    bool CheckAuthAccount(IHttpServerContext *pContext, const SID* psidAuthGroup) throw()
    {
        ATLASSERT(pContext);
        ATLASSERT(psidAuthGroup);
        if (!pContext || !psidAuthGroup)
            return false;

        HANDLE hToken = INVALID_HANDLE_VALUE;
        if (!pContext->GetImpersonationToken(&hToken) ||
                            hToken == INVALID_HANDLE_VALUE)
            return false;

        CAccessToken tok;
		tok.Attach(hToken, true);

        bool bIsMember;
        bool bRet = tok.CheckTokenMembership(CSid(psidAuthGroup), &bIsMember);

        if (!bRet)
            return false;

        return bIsMember;
    }
};

// Checks that the user that is logging on is in the required group
class CDefaultAuth :
    public CVerifyAuth<CDefaultAuth>
{
public:
    bool CheckAccount(IHttpServerContext *pContext, const SID* psidAuthGroup) throw()
    {
        return CheckAuthAccount(pContext, psidAuthGroup);
    }

    HTTP_CODE HandleError(AtlServerRequest *pRequestInfo) throw()
    {
        ATLASSERT(pRequestInfo); // should always be valid
        
        CHttpResponse response(pRequestInfo->pServerContext);
        response.Write(GetErrorResponse());
        response.Flush();
        return HTTP_SUCCESS_NO_PROCESS;
    }

    virtual LPCSTR GetErrorResponse() throw()
    {
        static const char *szResponse = "<html><body>"
            "<H1 align=center>NOT AUTHORIZED</H1><p>"
            "</body></html>";
        return szResponse;
    }

};

} // namespace ATL

#pragma warning(pop)

#endif // __ATLISAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlres.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#define ATL_RESID_BASE						0xD800
#define ATL_STRING_BASE						ATL_RESID_BASE

#define ATL_IDS_DATETIME_INVALID			(ATL_STRING_BASE + 0)
#define ATL_IDS_DATETIMESPAN_INVALID		(ATL_STRING_BASE + 1)

#define ATL_SERIVCE_MANAGER_OPEN_ERROR		(ATL_STRING_BASE + 10)
#define ATL_SERIVCE_START_ERROR				(ATL_STRING_BASE + 11)
#define ATL_SERIVCE_OPEN_ERROR				(ATL_STRING_BASE + 12)
#define ATL_SERIVCE_DELETE_ERROR			(ATL_STRING_BASE + 13)
#define ATL_SERIVCE_STOP_ERROR				(ATL_STRING_BASE + 14)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlplus.h ===
// This is a part of the Visual C++ COM Library
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.

#ifndef __ATLPLUS_H__
#define __ATLPLUS_H__

#pragma once

#ifndef __cplusplus
	#error The Visual C++ COM Library requires C++ compilation (use a .cpp suffix)
#endif

#include <shellapi.h>
#include "atlevent.h"
#include <atlstr.h>

[
	provider(name="ATL4", uuid="BC6B4B8A-0E4A-4bc9-B319-9DC2ACFB61EE")
];

namespace ATL
{
// This class is constructor helper
template <class TCtor, class T = ContainerPair<> >
class Constructor : public OuterClassHelper<T>
{
public:
	Constructor()
	{
		TCtor x(__GetOuter());
	}
};

// Registry

#define rgsopEndOfStream 0
#define rgsopAddKeyNoRemove  1
#define rgsopAddKeyForceRemove 2
#define rgsopAddKey 3
#define rgsopDeleteKey 4
#define rgsopOpenAsParent 5
#define rgsopCloseAsParent 6
#define rgsopOpenRootKey 7
#define rgsopAddStringValue 8
#define rgsopAddMultiStringValue 9
#define rgsopAddDWORDValue 10
#define rgsopAddBinaryValue 11

struct RGSStrings
{
	LPTSTR sz;
	BYTE bHasReplacement;
};
struct RGSDWORD
{
	DWORD dwValueOrIndex;
	BYTE bHasReplacement;
};
struct RGSBinary
{
	BYTE* pBytes;
	DWORD dwLenOrIndex;
	BYTE bHasReplacement;
};

typedef DWORD RGSOps;

enum RDXOperations
{
	eReadFromReg,
	eWriteToReg,
	eDeleteFromReg
};

class CVMExpansionVector : public CSimpleMap<LPTSTR, LPTSTR>
{
public:
	int FindKey(LPTSTR& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aKey[i],key) == 0)
				return i;
		}
		return -1;  // not found
	}
	int FindVal(LPTSTR& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aVal[i],val) == 0)
				return i;
		}
		return -1;  // not found
	}

	LPTSTR Lookup(LPTSTR key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
};


class CRegistryVirtualMachine
{
public:

	~CRegistryVirtualMachine() throw()
	{
		ClearReplacements();
	}

	// Operations
	HRESULT  AddStandardReplacements() throw()
	{
		USES_CONVERSION;

		TCHAR szModule[_MAX_PATH];

		GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, _MAX_PATH);
		// Convert to short path to work around bug in NT4's CreateProcess
		TCHAR szModuleShort[_MAX_PATH];
		GetShortPathName(szModule, szModuleShort, _MAX_PATH);
//              LPOLESTR pszModule = T2OLE(szModuleShort);

//              int nLen = ocslen(pszModule);
//              LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
//              ReplaceSingleQuote(pszModuleQuote, pszModule);
		HRESULT hr = AddReplacement(_T("Module"), szModule);
		if (FAILED(hr))
			return hr;
		OLECHAR* sz;
		hr = StringFromCLSID(CAtlModule::m_libid, &sz);
		if (FAILED(hr))
			return hr;
		hr = AddReplacement(_T("MODULEGUID"), OLE2T(sz));
		CoTaskMemFree(sz);
		if (FAILED(hr))
			return hr;
		SHFILEINFO shf;
		if (SHGetFileInfo(szModule, 0, &shf, sizeof(shf), SHGFI_EXETYPE) == 0)
			hr = AddReplacement(_T("MODULETYPE"), _T("InprocServer32"));
		else
			hr = AddReplacement(_T("MODULETYPE"), _T("LocalServer32"));
		return hr;
	}

	HRESULT AddReplacement(LPCTSTR lpszKey, LPCTSTR lpszItem) throw()
	{
		ATLASSERT(lpszKey != NULL && lpszItem != NULL);
		if (lpszKey == NULL || lpszItem == NULL)
			return E_INVALIDARG;
			
		HRESULT hr = E_OUTOFMEMORY; // If any of the new's fail.

		m_csMap.Lock();
		DWORD cb = lstrlen(lpszKey) + 1;
		CAutoVectorPtr<TCHAR> szNewKey;
		if (szNewKey.Allocate(cb))
		{			
			lstrcpy(szNewKey, lpszKey);
			cb = lstrlen(lpszItem) + 1;
			CAutoVectorPtr<TCHAR> szNewItem;
			if (szNewItem.Allocate(cb))
			{
				lstrcpy(szNewItem, lpszItem);
				if (m_RepMap.Add(szNewKey, szNewItem))
				{
					hr = S_OK;
					szNewKey.Detach();
					szNewItem.Detach();
				}
			}
		}
		m_csMap.Unlock();
		return hr;
	}

	HRESULT ClearReplacements() throw()
	{
		m_csMap.Lock();
		HRESULT hr = S_OK;
		for (int i = 0; i < m_RepMap.GetSize(); i++)
		{
			delete [] m_RepMap.m_aKey[i];
			delete [] m_RepMap.m_aVal[i];
		}
		m_RepMap.RemoveAll();
		m_csMap.Unlock();
		return hr;
	}
	
	HRESULT VMUpdateRegistry(RGSOps* pOps, RGSStrings* rgStrings, RGSDWORD* rgDWORDS, RGSBinary *rgBinary, BOOL bRegister) throw()
	{
		ATLASSERT(pOps != NULL && rgStrings != NULL);
		if (pOps == NULL || rgStrings == NULL)
			return E_INVALIDARG;
		DWORD code, p1, p2;
		GetOpsFromDWORD(*pOps, code, p1, p2);
		
		if (code != rgsopOpenRootKey)
		{
			ATLASSERT(FALSE); // Bad parse tree
			return E_FAIL;
		}
		HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
		pOps++;
		return VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
	}

	// Implementation
	inline BYTE ChToByte(const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}
	
	HRESULT GetStringAtLoc(RGSStrings* rgStrings, DWORD iLoc, CSimpleArray<TCHAR>& rgBytes, LPTSTR* pszCur) throw()
	{
		if (pszCur == NULL)
			return E_INVALIDARG;

		LPTSTR& szCur = *pszCur;
		szCur = rgStrings[iLoc].sz;
		if (szCur == NULL)
			return S_FALSE;

		if (rgStrings[iLoc].bHasReplacement)
		{
			rgBytes.RemoveAll();
			LPTSTR szTemp = szCur;
			szCur = NULL;
			while (*szTemp != NULL) // look for end
			{
				if (*szTemp == _T('%'))
				{
					szTemp = CharNext(szTemp);
					if (*szTemp == _T('%'))
						rgBytes.Add(*szTemp);
					else
					{
						LPTSTR lpszNext = _tcschr(szTemp, _T('%'));
						if (lpszNext == NULL)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Error : closing '%' found\n"));
							return E_FAIL;
						}
						int nLength = (int)(INT_PTR)(lpszNext - szTemp);
						if (nLength > 31)
							return E_FAIL;
						TCHAR buf[32];
						lstrcpyn(buf, szTemp, nLength+1);
						LPTSTR lpszVar = m_RepMap.Lookup(buf);
						if (lpszVar == NULL)
							return E_FAIL;
						for (int iMapped = 0; lpszVar[iMapped] != NULL; iMapped++)
							rgBytes.Add(lpszVar[iMapped]);
						szTemp = lpszNext;
					}
				}
				else
					rgBytes.Add(*szTemp);
				szTemp = CharNext(szTemp);
			}
			rgBytes.Add(*szTemp);
		}
		return S_OK;
	}
	HRESULT GetDWORDAtLoc(RGSDWORD* rgDWORDS, DWORD iLoc, DWORD& dwValueOrIndex) throw()
	{
		dwValueOrIndex = rgDWORDS[iLoc].dwValueOrIndex;
		return rgDWORDS[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}
	
	HRESULT GetBinaryAtLoc(RGSBinary* rgBinary, DWORD iLoc, BYTE** ppValue, DWORD* pdwLen) throw()
	{
		*ppValue = rgBinary[iLoc].pBytes;
		*pdwLen = rgBinary[iLoc].dwLenOrIndex;
		return rgBinary[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}
	
	HRESULT DeleteKeyWithReplacement(HKEY hKeyParent, DWORD iString, RGSStrings* rgStrings) throw()
	{
		CRegKey rkForceRemove;
		CSimpleArray<TCHAR> rgBytes;
		LPTSTR szReplacement = NULL;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;
		rkForceRemove.Attach(hKeyParent);
		LONG lRet = rkForceRemove.RecurseDeleteKey((szReplacement) ? szReplacement : rgBytes.m_aT);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete key %s or one of its subkeys\n"),
				(szReplacement) ? szReplacement : rgBytes.m_aT);
			hr = AtlHresultFromWin32(lRet);
		}
		rkForceRemove.Detach();
		return hr;
	}

	HRESULT AddKeyWithReplacement(HKEY hKeyParent, CRegKey& rkCur, DWORD iString, RGSStrings* rgStrings) throw()
	{
		LPTSTR szReplacement = NULL;
		CSimpleArray<TCHAR> rgBytes;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;
		
		if (rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, 
					   KEY_READ | KEY_WRITE) != ERROR_SUCCESS)
		{
			LONG lRes = rkCur.Create(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, REG_NONE, REG_OPTION_NON_VOLATILE , KEY_READ | KEY_WRITE); 
			if (lRes != ERROR_SUCCESS)
				return AtlHresultFromWin32(lRes);
		}
		return S_OK;
	}
		
	HRESULT VMUpdateRegistryRecurse(HKEY hKeyParent, RGSOps*& pOps, RGSStrings* rgStrings, RGSDWORD* rgDWORDS, RGSBinary *rgBinary, BOOL bRegister) throw()
	{
		CRegKey  rkCur;
		LONG     lRes = ERROR_SUCCESS;
		HRESULT  hr = S_OK;
		bool bNoRemove = false;
		RGSOps opParent = 0;
		DWORD code, p1, p2;

		GetOpsFromDWORD(*pOps, code, p1, p2);
		while (code != rgsopCloseAsParent)
		{
			switch(code)
			{
			case rgsopEndOfStream:
				return S_OK;
			case rgsopAddKeyNoRemove:
				bNoRemove = true;
				if (bRegister)
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++; // NoRemove means do nothing during Unreg
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			case rgsopAddKeyForceRemove:
				if (bRegister) 
				{
					hr = DeleteKeyWithReplacement(hKeyParent, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				// fall through to normal add functionality
			case rgsopAddKey:
			{
				if (!bRegister)
				{
					LPTSTR szReplacement = NULL;
					CSimpleArray<TCHAR> rgBytes;
					HRESULT hr = GetStringAtLoc(rgStrings, p1, rgBytes, &szReplacement);
					if (FAILED(hr))
						return hr;
					
					lRes = rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						return AtlHresultFromWin32(lRes); // Ignore if it is not in the registry and continue.
					opParent = *pOps; // remember this for the delete
				}
				else
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopDeleteKey:
				ATLASSERT(FALSE); // Not yet implemented
				break;
			case rgsopOpenAsParent:
				pOps++;
				hr = VMUpdateRegistryRecurse(rkCur.m_hKey, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				if (FAILED(hr))
					return hr;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				if (!bRegister)
				{
					if (!bNoRemove)
					{
						DWORD codeTemp, p1Temp, p2Temp;
						GetOpsFromDWORD(opParent, codeTemp, p1Temp, p2Temp);
						hr = DeleteKeyWithReplacement(hKeyParent, p1Temp, rgStrings);
						if (FAILED(hr))
							return hr;
					}
					else
						bNoRemove = false; // turn it back off
				}
				break;
			case rgsopCloseAsParent:
				ATLASSERT(FALSE); // Should never get here it is the governing loop constraint
				return E_FAIL;
			case rgsopOpenRootKey:
			{
				HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
				pOps++;
				return VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				break;
			}
			case rgsopAddStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);
					
					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;
					lRes = key.SetStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL, 
						(szReplacement) ? szReplacement : rgBytes.m_aT); 
					key.m_hKey = NULL;
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddMultiStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
						
					TCHAR* pszValue = (szReplacement) ? szReplacement : rgBytes.m_aT;
					int nLen = lstrlen(pszValue);
					TCHAR* pszDestValue = (TCHAR*) _alloca(nLen * sizeof(TCHAR));
					if (pszDestValue != NULL)
					{
						TCHAR* p = pszDestValue;
						TCHAR* q = pszValue;
						nLen = 0;
						while (*q != NULL)
						{
							TCHAR* r = CharNext(q);
							if (*q == '\\' && *r == '0')
							{
								*p++ = NULL;
								q = CharNext(r);
							}
							else
							{
								*p = *q;
		#ifndef _UNICODE
								if (IsDBCSLeadByte(*q))
								{
									p++;
									q++;
									*p = *q;
								}
		#endif
								p++;
								q++;
							}
							nLen ++;
						}
						*p = NULL;
					
						CRegKey key;
						if (p1 == 0)
							key.m_hKey = rkCur.m_hKey;
						else
						key.m_hKey = hKeyParent;						
						lRes = key.SetMultiStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL, 
							pszDestValue); 
						key.m_hKey = NULL;
						if (ERROR_SUCCESS != lRes)
							return AtlHresultFromWin32(lRes);
						if (bRestoreRK)
							rkCur.m_hKey = NULL;
					}
					else
					{
						return E_OUTOFMEMORY;
					}
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}

			case rgsopAddDWORDValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					DWORD dwValue;
					hr = GetDWORDAtLoc(rgDWORDS, p2, dwValue);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwValue, rgBytes, &szReplacement);
						ATLASSERT(szReplacement != NULL);
						USES_CONVERSION;
						hr = VarUI4FromStr(T2OLE(szReplacement), 0, 0, &dwValue);
						if (FAILED(hr))
						{
							// Replacement value exceeds max DWORD value
							return E_FAIL;
						}
					}
						
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);
					
					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;						
					lRes = key.SetDWORDValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT, 
						dwValue);
					key.m_hKey = NULL; 
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddBinaryValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					BYTE* pByte;
					DWORD dwLen;
					hr = GetBinaryAtLoc(rgBinary, p2, &pByte, &dwLen);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwLen, rgBytes, &szReplacement);
						ATLASSERT(szReplacement != NULL);
						int cbValue = lstrlen(szReplacement);
						if (cbValue & 0x00000001)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
							return E_FAIL;
						}
						dwLen = cbValue/2;
						pByte = (BYTE*)_alloca(dwLen*sizeof(BYTE));
						memset(pByte, 0, dwLen);
						if (pByte == NULL)
							return E_FAIL;
						for (int irg = 0; irg < cbValue; irg++)
							pByte[(irg/2)] |= (ChToByte(szReplacement[irg])) << (4*(1 - (irg & 0x00000001)));
					}
						
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);
					
					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;	
					lRes = key.SetBinaryValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT, 
						pByte, dwLen);
					key.m_hKey = NULL; 
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}


			default:
				ATLASSERT(FALSE); // Should never get here
				break;
			};
		}
		pOps++;
		GetOpsFromDWORD(*pOps, code, p1, p2);
		return hr;
	}

	void GetOpsFromDWORD(RGSOps op, DWORD& rcode, DWORD& rp1, DWORD& rp2) throw()
	{
		rcode = (op & 0xF0000000) >> 28;
		rp1 = (op & 0x0FFFC000) >> 14;
		rp2 = (op & 0x00003FFF);
	}


	CVMExpansionVector								m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};


struct _RDXEntries
{
	enum KeyType
	{
		keyTypeString,
		keyTypeCString,
		keyTypeDWORD,
		keyTypeBinary,
		keyTypeNoEntry
	};

	HKEY iRootKey;
	LPTSTR szSubKey;
	LPTSTR szValue;
	enum KeyType nKey;
	void* pMember;
	DWORD cb;
};

#define BEGIN_RDX_MAP() \
	ATL::_RDXEntries* _GetRDXEntries() \
	{ \
		static ATL::_RDXEntries rgEntries [] = { 

#define RDX_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeString, member, member_size },

#define RDX_CSTRING_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeCString, &member, member_size },

#define RDX_DWORD(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeDWORD, &member, member_size },

#define RDX_BINARY(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeBinary, member, member_size },

#define END_RDX_MAP() \
		{NULL, NULL, NULL, ATL::_RDXEntries::keyTypeNoEntry, NULL, 0} };\
		return rgEntries; \
	} \
	HRESULT RegistryDataExchange(enum ATL::RDXOperations rdxOp, void* pItem = NULL) \
	{ \
		return ::RegistryDataExchange(this, rdxOp, pItem); \
	}

class CByteFilter 
{
public:

	static BYTE ChToByte(const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}
};

template <class T>
HRESULT RegistryDataExchange(T* pT, enum RDXOperations rdxOp, void* pItem = NULL)
{
	_RDXEntries* pEntries = pT->_GetRDXEntries();
	ATLASSERT(pEntries != NULL);
	LONG lRes = ERROR_SUCCESS;

	while (pEntries->nKey != _RDXEntries::keyTypeNoEntry)
	{
		ATLASSERT(pEntries->pMember != NULL); 
		if (pItem == NULL || pItem == pEntries->pMember) 
		{ 
			if (rdxOp == eDeleteFromReg)
			{
				if (pEntries->szSubKey != NULL)
				{
					if (pEntries->szValue != NULL)
					{
						CRegKey rkDel;
						lRes = rkDel.Open(pEntries->iRootKey, pEntries->szSubKey, KEY_READ | KEY_WRITE);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to Open key in order to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
						lRes = rkDel.DeleteValue(pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
					else
					{
						lRes = RegDeleteKey(pEntries->iRootKey, pEntries->szSubKey);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteKey failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				else
				{
					if (pEntries->szValue)
					{
						lRes = RegDeleteValue(pEntries->iRootKey, pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteValue failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				pEntries++;
				continue;
			}

			CRegKey rk; 
			lRes = rk.Open(pEntries->iRootKey, pEntries->szSubKey, KEY_READ | KEY_WRITE); 
			if (lRes != ERROR_SUCCESS && rdxOp == eReadFromReg) 
				return AtlHresultFromWin32(lRes);
			else 
			{
				if (lRes != ERROR_SUCCESS) 
				{ 
					lRes = rk.Create(pEntries->iRootKey, pEntries->szSubKey, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ); 
					if (lRes != ERROR_SUCCESS) 
						return AtlHresultFromWin32(lRes);
				} 
			} 
			DWORD dwRet = pEntries->cb;
			switch(pEntries->nKey)
			{
			case _RDXEntries::keyTypeString:
				if (rdxOp == eWriteToReg) 
					lRes = rk.SetStringValue(pEntries->szValue, (LPCTSTR)pEntries->pMember); 
				else 
					lRes= rk.QueryStringValue(pEntries->szValue, (LPTSTR)pEntries->pMember, &dwRet); 
				break;
			case _RDXEntries::keyTypeCString:
				{
					CString& rStr = *((CString*)pEntries->pMember);
					if (rdxOp == eWriteToReg)
						lRes = rk.SetStringValue(pEntries->szValue, rStr); 
					else
					{
						lRes = rk.QueryStringValue(pEntries->szValue, NULL, &dwRet);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to determine keys length\n"));
							return AtlHresultFromWin32(lRes);
						}
						// Review : If Unicode dwRet should be converted from no. of bytes to no. of characters for GetBuffer?
						lRes= rk.QueryStringValue(pEntries->szValue, rStr.GetBuffer(dwRet), &dwRet); 
						rStr.ReleaseBuffer();
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to copy keys data to CString\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				break;
			case _RDXEntries::keyTypeDWORD:
				{
					DWORD& rdw = *((DWORD*)pEntries->pMember);
					if (rdxOp == eWriteToReg) 
						lRes = rk.SetDWORDValue(pEntries->szValue, rdw); 
					else 
						lRes= rk.QueryDWORDValue(pEntries->szValue, rdw); 
					break;
				}
			case _RDXEntries::keyTypeBinary:
				if (rdxOp == eReadFromReg)
				{
					DWORD dwType = REG_BINARY;
					DWORD dwCount = pEntries->cb;
					LONG lRes = RegQueryValueEx(rk, pEntries->szValue, NULL, &dwType, (LPBYTE)pEntries->pMember, &dwCount);
					if (lRes != ERROR_SUCCESS)
					{
						ATLTRACE(atlTraceRegistrar, 0, _T("Failed to query binary value\n"));
						return AtlHresultFromWin32(lRes);
					}
					ATLASSERT(dwType == REG_BINARY);
					break;
				}
				else
				{
					lRes = RegSetValueEx(rk, pEntries->szValue, 0, REG_BINARY, (const BYTE *)pEntries->pMember, pEntries->cb);
					break;
				}
			case _RDXEntries::keyTypeNoEntry:
				ATLASSERT(FALSE);  // Not yet implemented
				break;
			};
			if (pItem != NULL)
				return AtlHresultFromWin32(lRes); 
		}
		pEntries++;
	}
	return AtlHresultFromWin32(lRes); 
}
}; // namespace ATL

#endif // __ATLPLUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlperf.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPERF_INL__
#define __ATLPERF_INL__

#pragma once

#ifndef __ATLPERF_H__
	#error atlperf.inl requires atlperf.h to be included first
#endif

#include <atlsecurity.h>

#pragma warning(push)

#ifndef _CPPUNWIND
#pragma warning(disable: 4702) // unreachable code
#endif

namespace ATL
{

__declspec(selectany) LPCTSTR c_szAtlPerfCounter = _T("Counter");
__declspec(selectany) LPCTSTR c_szAtlPerfFirstCounter = _T("First Counter");
__declspec(selectany) LPCTSTR c_szAtlPerfLastCounter = _T("Last Counter");
__declspec(selectany) LPCTSTR c_szAtlPerfHelp = _T("Help");
__declspec(selectany) LPCTSTR c_szAtlPerfFirstHelp = _T("First Help");
__declspec(selectany) LPCTSTR c_szAtlPerfLastHelp = _T("Last Help");

__declspec(selectany) LPCWSTR c_szAtlPerfGlobal = L"Global";
__declspec(selectany) LPCTSTR c_szAtlPerfLibrary = _T("Library");
__declspec(selectany) LPCTSTR c_szAtlPerfOpen = _T("Open");
__declspec(selectany) LPCTSTR c_szAtlPerfCollect = _T("Collect");
__declspec(selectany) LPCTSTR c_szAtlPerfClose = _T("Close");
__declspec(selectany) LPCTSTR c_szAtlPerfLanguages = _T("Languages");
__declspec(selectany) LPCTSTR c_szAtlPerfMap = _T("Map");
__declspec(selectany) LPCTSTR c_szAtlPerfServicesKey = _T("SYSTEM\\CurrentControlSet\\Services");
__declspec(selectany) LPCTSTR c_szAtlPerfPerformanceKey = _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance");
__declspec(selectany) LPCTSTR c_szAtlPerfPerfLibKey = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
__declspec(selectany) LPCTSTR c_szAtlPerfPerfLibLangKey = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\%3.3x");

inline CPerfMon::~CPerfMon() throw()
{
	UnInitialize();
}

inline HRESULT CPerfMon::CreateMap(LANGID language, HINSTANCE hResInstance, UINT* pSampleRes) throw()
{
	language; // unused
	hResInstance; // unused
	pSampleRes; // unused
	return S_OK;
}

inline CPerfMapEntry& CPerfMon::_GetMapEntry(UINT nIndex) throw()
{
	ATLASSERT(nIndex < _GetNumMapEntries());
	return m_map[nIndex];
}

inline UINT CPerfMon::_GetNumMapEntries() throw()
{
	return (UINT) m_map.GetCount();
}

inline CPerfObject* CPerfMon::_GetFirstObject(CAtlFileMappingBase* pBlock) throw()
{
	ATLASSERT(pBlock != NULL);

	// should never happen if Initialize succeeded
	// are you checking return codes?
	ATLASSERT(pBlock->GetData() != NULL);

	return reinterpret_cast<CPerfObject*>(LPBYTE(pBlock->GetData()) + m_nHeaderSize);
}

inline CPerfObject* CPerfMon::_GetNextObject(CPerfObject* pInstance) throw()
{
	ATLASSERT(pInstance != NULL);

	return reinterpret_cast<CPerfObject*>(LPBYTE(pInstance) + pInstance->m_nAllocSize);
}

inline CAtlFileMappingBase* CPerfMon::_GetNextBlock(CAtlFileMappingBase* pBlock) throw()
{
	// calling _GetNextBlock(NULL) will return the first block
	DWORD dwNextBlockIndex = 0;
	if (pBlock)
	{
		dwNextBlockIndex= _GetBlockId(pBlock) +1;
		if (DWORD(m_aMem.GetCount()) == dwNextBlockIndex)
			return NULL;
	}
	return m_aMem[dwNextBlockIndex];
}

inline CAtlFileMappingBase* CPerfMon::_AllocNewBlock(CAtlFileMappingBase* pPrev, BOOL* pbExisted /* == NULL */) throw()
{
	// initialize a security descriptor to give everyone access to objects we create
	CSecurityDescriptor sd;
	sd.InitializeFromThreadToken();
	SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), sd, FALSE };

	CAutoPtr<CAtlFileMappingBase> spMem;
	CAtlFileMappingBase* pMem = NULL;
	ATLTRY(spMem.Attach(new CAtlFileMappingBase));
	if (spMem == NULL)
		return NULL;

	// create a unique name for the shared mem segment based on the index
	DWORD dwNextBlockIndex;
	if (pPrev != NULL)
		dwNextBlockIndex = _GetBlockId(pPrev) +1;
	else
	{
		// use the system allocation granularity (65536 currently. may be different in the future)
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		m_nAllocSize = si.dwAllocationGranularity;

		dwNextBlockIndex = 0;
	}

	BOOL bExisted = FALSE;
	_ATLTRY
	{
		CString strName;
		strName.Format(_T("ATLPERF_%s_%3.3d"), GetAppName(), dwNextBlockIndex);

		HRESULT hr = spMem->MapSharedMem(m_nAllocSize, strName, &bExisted, &sa);
		if (FAILED(hr))
			return NULL;

		// save the index of this block
		// don't for first block since we don't know m_nSchemaSize yet
		if (dwNextBlockIndex)
			_GetBlockId(spMem) = dwNextBlockIndex;

		if (!bExisted)
			memset(spMem->GetData(), 0, m_nAllocSize);

		if (pbExisted)
			*pbExisted = bExisted;

		pMem = spMem;
		m_aMem.Add(spMem);

		OnBlockAlloc(pMem);
	}
	_ATLCATCHALL()
	{
		return NULL;
	}

	return pMem;
}

inline HRESULT CPerfMon::_LoadMap() throw()
{
	_ATLTRY
	{
		HRESULT hr;

		ClearMap();

		DWORD* pData = LPDWORD(m_aMem[0]->GetData());

		DWORD dwDataSize = *pData++; // blob size
		DWORD dwNumItems = *pData++; // number of items

		// see if we have name data
		DWORD* pNameData = NULL;
		if (dwDataSize > (2+dwNumItems*9) * sizeof(DWORD))
			pNameData = pData + dwNumItems*9; // blob size and item count already skipped. skip item data

		for (DWORD i=0; i<dwNumItems; i++)
		{
			DWORD dwIsObject = *pData++;
			DWORD dwPerfId = *pData++;
			DWORD dwDetailLevel = *pData++;

			CString strName;
			if (pNameData)
			{
				strName = CString(LPWSTR(pNameData+1), *pNameData);
				pNameData += AtlAlignUp(sizeof(WCHAR) * *pNameData, sizeof(DWORD))/sizeof(DWORD) + 1;
			}

			if (dwIsObject)
			{
				DWORD dwDefaultCounter = *pData++;
				DWORD dwInstanceLess = *pData++;
				DWORD dwStructSize = *pData++;
				DWORD dwMaxInstanceNameLen = *pData++;

				hr = AddObjectDefinition(
					dwPerfId,
					strName,
					NULL,
					dwDetailLevel,
					dwDefaultCounter,
					dwInstanceLess,
					dwStructSize,
					dwMaxInstanceNameLen);
				if (FAILED(hr))
				{
					ClearMap();
					return hr;
				}
			}
			else
			{
				DWORD dwCounterType = *pData++;
				DWORD dwMaxCounterSize = *pData++;
				DWORD dwDataOffset = *pData++;
				DWORD dwDefaultScale = *pData++;

				hr = AddCounterDefinition(
					dwPerfId,
					strName,
					NULL,
					dwDetailLevel,
					dwCounterType,
					dwMaxCounterSize,
					dwDataOffset,
					dwDefaultScale);
				if (FAILED(hr))
				{
					ClearMap();
					return hr;
				}
			}

			DWORD dwNameId = *pData++;
			DWORD dwHelpId = *pData++;
			CPerfMapEntry& entry = _GetMapEntry(_GetNumMapEntries()-1);
			entry.m_nNameId = dwNameId;
			entry.m_nHelpId = dwHelpId;
		}

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_SaveMap() throw()
{
	_ATLTRY
	{
		// figure out how much memory we need
		size_t nSize = (2 + 9*_GetNumMapEntries()) * sizeof(DWORD);
		for (UINT i=0; i<_GetNumMapEntries(); i++)
		{
			// if any of the entries have names, they'd better all have names
			CPerfMapEntry& entry = _GetMapEntry(i);
			if (!entry.m_strName.IsEmpty())
				nSize += sizeof(DWORD) + AtlAlignUp(sizeof(WCHAR) * entry.m_strName.GetLength(), sizeof(DWORD));
		}

		CHeapPtr<BYTE> blob;
		if (!blob.Allocate(nSize))
			return E_OUTOFMEMORY;

		// start with blob size and number of items in the blob
		DWORD* pCurrent = reinterpret_cast<DWORD*>(blob.m_pData);
		*pCurrent++ = (DWORD) nSize; // blob size
		*pCurrent++ = _GetNumMapEntries(); // number of items

		for (UINT i=0; i<_GetNumMapEntries(); i++)
		{
			// add all the relevant runtime info to the blob for each item
			CPerfMapEntry& entry = _GetMapEntry(i);
			*pCurrent++ = entry.m_bIsObject;
			*pCurrent++ = entry.m_dwPerfId;
			*pCurrent++ = entry.m_dwDetailLevel;
			if (entry.m_bIsObject)
			{
				*pCurrent++ = entry.m_nDefaultCounter;
				*pCurrent++ = entry.m_nInstanceLess;
				*pCurrent++ = entry.m_nStructSize;
				*pCurrent++ = entry.m_nMaxInstanceNameLen;
			}
			else
			{
				*pCurrent++ = entry.m_dwCounterType;
				*pCurrent++ = entry.m_nMaxCounterSize;
				*pCurrent++ = entry.m_nDataOffset;
				*pCurrent++ = entry.m_nDefaultScale;
			}
			*pCurrent++ = entry.m_nNameId;
			*pCurrent++ = entry.m_nHelpId;
		}

		// add names to the blob
		for (UINT i=0; i<_GetNumMapEntries(); i++)
		{
			// if any of the entries have names, they'd better all have names
			CPerfMapEntry& entry = _GetMapEntry(i);
			if (!entry.m_strName.IsEmpty())
			{
				// copy the len of the string (in characters) then the wide-char version of the string
				// pad the string to a dword boundary
				int nLen = entry.m_strName.GetLength();
				*pCurrent++ = nLen;
				memcpy(pCurrent, CT2CW(entry.m_strName), sizeof(WCHAR)*nLen);
				pCurrent += AtlAlignUp(sizeof(WCHAR) * nLen, sizeof(DWORD))/sizeof(DWORD);
			}
		}

		CRegKey rkApp;
		CString str;
		DWORD dwErr;

		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		rkApp.SetBinaryValue(c_szAtlPerfMap, blob, *LPDWORD(blob.m_pData));

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline CPerfMapEntry* CPerfMon::_FindObjectInfo(DWORD dwObjectId) throw()
{
	for (UINT i=0; i<_GetNumMapEntries(); i += _GetMapEntry(i).m_nNumCounters+1)
	{
		CPerfMapEntry& object = _GetMapEntry(i);
		if (object.m_dwPerfId == dwObjectId)
			return &object;
	}

	return NULL;
}

inline CPerfMapEntry* CPerfMon::_FindCounterInfo(CPerfMapEntry* pObjectEntry, DWORD dwCounterId) throw()
{
	ATLASSERT(pObjectEntry != NULL);

	for (DWORD i=0; i<pObjectEntry->m_nNumCounters; i++)
	{
		CPerfMapEntry* pCounter = pObjectEntry+i+1;
		if (pCounter->m_dwPerfId == dwCounterId)
			return pCounter;
	}

	return NULL;
}

inline CPerfMapEntry* CPerfMon::_FindCounterInfo(DWORD dwObjectId, DWORD dwCounterId) throw()
{
	CPerfMapEntry* pObjectEntry = _FindObjectInfo(dwObjectId);
	if (pObjectEntry != NULL)
		return _FindCounterInfo(pObjectEntry, dwCounterId);

	return NULL;
}

inline BOOL CPerfMon::_WantObjectType(LPWSTR szValue, DWORD dwObjectId) throw(...)
{
	ATLASSERT(szValue != NULL);

	if (lstrcmpiW(c_szAtlPerfGlobal, szValue) == 0)
		return TRUE;

	CString strList(szValue);
	int nStart = 0;

	CString strNum = strList.Tokenize(_T(" "), nStart);
	while (!strNum.IsEmpty())
	{
		if (_ttoi(strNum) == int(dwObjectId))
			return TRUE;

		strNum = strList.Tokenize(_T(" "), nStart);
	}

	return FALSE;
}

inline LPBYTE CPerfMon::_AllocData(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, size_t nBytesNeeded) throw()
{
	ATLASSERT(pnBytesUsed != NULL);

	if (nBytesAvail < *pnBytesUsed + (ULONG) nBytesNeeded)
		return NULL;

	LPBYTE p = pData;
	pData += nBytesNeeded;
	*pnBytesUsed += (ULONG) nBytesNeeded;

	return p;
}

inline DWORD& CPerfMon::_GetBlockId(CAtlFileMappingBase* pBlock) throw()
{
	ATLASSERT(pBlock != NULL);

	return *LPDWORD(LPBYTE(pBlock->GetData()) + m_nSchemaSize);
}

inline void CPerfMon::_FillObjectType(PERF_OBJECT_TYPE* pObjectType, CPerfMapEntry* pObjectEntry) throw()
{
	ATLASSERT(pObjectType != NULL);
	ATLASSERT(pObjectEntry != NULL);

    pObjectType->DefinitionLength = sizeof(PERF_OBJECT_TYPE) + sizeof(PERF_COUNTER_DEFINITION) * pObjectEntry->m_nNumCounters;
    pObjectType->TotalByteLength = pObjectType->DefinitionLength; // we will add the instance definitions/counter blocks as we go
    pObjectType->HeaderLength = sizeof(PERF_OBJECT_TYPE);
    pObjectType->ObjectNameTitleIndex = pObjectEntry->m_nNameId;
    pObjectType->ObjectNameTitle = NULL;
    pObjectType->ObjectHelpTitleIndex = pObjectEntry->m_nHelpId;
    pObjectType->ObjectHelpTitle = NULL;
    pObjectType->DetailLevel = pObjectEntry->m_dwDetailLevel;
    pObjectType->NumCounters = pObjectEntry->m_nNumCounters;
    pObjectType->DefaultCounter = pObjectEntry->m_nDefaultCounter;
	if (pObjectEntry->m_nInstanceLess == PERF_NO_INSTANCES)
		pObjectType->NumInstances = PERF_NO_INSTANCES;
	else
		pObjectType->NumInstances = 0; // this will be calculated as we go
    pObjectType->CodePage = 0;
    pObjectType->PerfTime.QuadPart = 0;
    pObjectType->PerfFreq.QuadPart = 0;
}

inline void CPerfMon::_FillCounterDef(
	PERF_COUNTER_DEFINITION* pCounterDef,
	CPerfMapEntry* pCounterEntry,
	ULONG& nCBSize
	) throw()
{
	ATLASSERT(pCounterDef != NULL);
	ATLASSERT(pCounterEntry != NULL);

	pCounterDef->ByteLength = sizeof(PERF_COUNTER_DEFINITION);
	pCounterDef->CounterNameTitleIndex = pCounterEntry->m_nNameId;
	pCounterDef->CounterNameTitle = NULL;
	pCounterDef->CounterHelpTitleIndex = pCounterEntry->m_nHelpId;
	pCounterDef->CounterHelpTitle = NULL;
	pCounterDef->DefaultScale = pCounterEntry->m_nDefaultScale;
	pCounterDef->DetailLevel = pCounterEntry->m_dwDetailLevel;
	pCounterDef->CounterType = pCounterEntry->m_dwCounterType;
	switch (pCounterEntry->m_dwCounterType & ATLPERF_SIZE_MASK)
	{
	case PERF_SIZE_DWORD:
		pCounterDef->CounterSize = sizeof(DWORD);
		break;
	case PERF_SIZE_LARGE:
		pCounterDef->CounterSize = sizeof(__int64);
		break;
	case PERF_SIZE_ZERO:
		pCounterDef->CounterSize = 0;
		break;
	case PERF_SIZE_VARIABLE_LEN:
		ATLASSERT((pCounterEntry->m_dwCounterType & ATLPERF_TYPE_MASK) == PERF_TYPE_TEXT);
		if ((pCounterEntry->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
			pCounterDef->CounterSize = (DWORD) AtlAlignUp(pCounterEntry->m_nMaxCounterSize * sizeof(WCHAR), sizeof(DWORD));
		else
			pCounterDef->CounterSize = (DWORD) AtlAlignUp(pCounterEntry->m_nMaxCounterSize * sizeof(char), sizeof(DWORD));
		break;
	}
	pCounterDef->CounterOffset = sizeof(PERF_COUNTER_BLOCK) + nCBSize;
	nCBSize += pCounterDef->CounterSize;
}

inline HRESULT CPerfMon::_CollectObjectType(
	CPerfMapEntry* pObjectEntry,
	LPBYTE pData,
	ULONG nBytesAvail,
	ULONG* pnBytesUsed
	) throw()
{
	ATLASSERT(pObjectEntry != NULL);
	ATLASSERT(pnBytesUsed != NULL);

	ATLASSERT(m_aMem.GetCount() != 0);

	*pnBytesUsed = 0;

	// write the object definition out
	PERF_OBJECT_TYPE* pObjectType = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_OBJECT_TYPE*) NULL);
	if (pObjectType == NULL)
		return E_OUTOFMEMORY;

	_FillObjectType(pObjectType, pObjectEntry);

	// save a pointer to the first counter entry and counter definition.
	// we'll need them when we create the PERF_COUNTER_BLOCK data
	CPerfMapEntry* pCounterEntries = pObjectEntry + 1;
	PERF_COUNTER_DEFINITION* pCounterDefs = reinterpret_cast<PERF_COUNTER_DEFINITION*>(pData);
	ULONG nCBSize = 0; // counter block size

	// write the counter definitions out
	for (DWORD i=0; i<pObjectEntry->m_nNumCounters; i++)
	{
		CPerfMapEntry* pCounterEntry = pObjectEntry+i+1;

		PERF_COUNTER_DEFINITION* pCounterDef = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_COUNTER_DEFINITION*) NULL);
		if (pCounterDef == NULL)
			return E_OUTOFMEMORY;

		_FillCounterDef(pCounterDef, pCounterEntry, nCBSize);
	}

	// search for objects of the appropriate type and write out their instance/counter data
	CAtlFileMappingBase* pCurrentBlock = m_aMem[0];
	CPerfObject* pInstance = _GetFirstObject(pCurrentBlock);
	while (pInstance && pInstance->m_nAllocSize != 0)
	{
		if (pInstance->m_dwObjectId == pObjectEntry->m_dwPerfId)
		{
			PERF_INSTANCE_DEFINITION* pInstanceDef = NULL;

			if (pObjectEntry->m_nInstanceLess == PERF_NO_INSTANCES)
				pObjectType->NumInstances = PERF_NO_INSTANCES;
			else
			{
				pObjectType->NumInstances++;

				// create an instance definition
				pInstanceDef = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_INSTANCE_DEFINITION*) NULL);
				if (pInstanceDef == NULL)
					return E_OUTOFMEMORY;

				pInstanceDef->ParentObjectTitleIndex = 0;
				pInstanceDef->ParentObjectInstance = 0;
				pInstanceDef->UniqueID = PERF_NO_UNIQUE_ID;

				// handle the instance name
				LPCWSTR szInstNameSrc = LPCWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset);
				pInstanceDef->NameLength = (ULONG)(wcslen(szInstNameSrc)+1)*sizeof(WCHAR);
				LPWSTR szInstNameDest = (LPWSTR) _AllocData(pData, nBytesAvail, pnBytesUsed, AtlAlignUp(pInstanceDef->NameLength, sizeof(DWORD)));
				if (szInstNameDest == NULL)
					return E_OUTOFMEMORY;

				memcpy(szInstNameDest, szInstNameSrc, pInstanceDef->NameLength);
				pInstanceDef->NameOffset = ULONG(LPBYTE(szInstNameDest) - LPBYTE(pInstanceDef));

				pInstanceDef->ByteLength = DWORD(sizeof(PERF_INSTANCE_DEFINITION) + AtlAlignUp(pInstanceDef->NameLength, sizeof(DWORD)));
			}

			// create the counter block
			PERF_COUNTER_BLOCK* pCounterBlock = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_COUNTER_BLOCK*) NULL);
			if (pCounterBlock == NULL)
				return E_OUTOFMEMORY;

			pCounterBlock->ByteLength = sizeof(PERF_COUNTER_BLOCK) + nCBSize;

			LPBYTE pCounterData = _AllocData(pData, nBytesAvail, pnBytesUsed, nCBSize);
			if (pCounterData == NULL)
				return E_OUTOFMEMORY;

			for (ULONG i=0; i<pObjectType->NumCounters; i++)
			{
				switch (pCounterEntries[i].m_dwCounterType & ATLPERF_SIZE_MASK)
				{
				case PERF_SIZE_DWORD:
					*LPDWORD(pCounterData+pCounterDefs[i].CounterOffset-sizeof(PERF_COUNTER_BLOCK)) =
						*LPDWORD(LPBYTE(pInstance)+pCounterEntries[i].m_nDataOffset);
					break;
				case PERF_SIZE_LARGE:
					*PULONGLONG(pCounterData+pCounterDefs[i].CounterOffset-sizeof(PERF_COUNTER_BLOCK)) =
						*PULONGLONG(LPBYTE(pInstance)+pCounterEntries[i].m_nDataOffset);
					break;
				case PERF_SIZE_VARIABLE_LEN:
					{
						LPBYTE pSrc = LPBYTE(pInstance)+pObjectEntry->m_nDataOffset;
						LPBYTE pDest = pCounterData+pCounterDefs[i].CounterOffset-sizeof(PERF_COUNTER_BLOCK);
						if ((pCounterEntries[i].m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
						{
							ULONG nLen = (ULONG)wcslen(LPCWSTR(pSrc));
							nLen = min(nLen, pCounterEntries[i].m_nMaxCounterSize-1);
							wcsncpy(LPWSTR(pDest), LPCWSTR(pSrc), nLen);
							((LPWSTR) pDest)[nLen] = 0;
						}
						else
						{
							ULONG nLen = (ULONG)strlen(LPCSTR(pSrc));
							nLen = min(nLen, pCounterEntries[i].m_nMaxCounterSize-1);
							strncpy(LPSTR(pDest), LPCSTR(pSrc), nLen);
							((LPSTR) pDest)[nLen] = 0;
						}
					}
					break;
				}
			}

			if (pInstanceDef != NULL)
				pObjectType->TotalByteLength += pInstanceDef->ByteLength;
			pObjectType->TotalByteLength += sizeof(PERF_COUNTER_BLOCK) + nCBSize;
		}

		pInstance = _GetNextObject(pInstance);
		if (pInstance->m_nAllocSize == (ULONG) -1)
		{
			pCurrentBlock = _GetNextBlock(pCurrentBlock);
			if (pCurrentBlock == NULL)
				pInstance = NULL;
			else
				pInstance = _GetFirstObject(pCurrentBlock);
		}
	}

	return S_OK;
}

inline DWORD CPerfMon::Open(LPWSTR szDeviceNames) throw()
{
	szDeviceNames; // unused
	return Initialize();
}

inline DWORD CPerfMon::Collect(
	LPWSTR szValue,
	LPVOID* ppData,
	LPDWORD pcbBytes,
	LPDWORD pcObjectTypes
	) throw()
{
	_ATLTRY
	{
		if (m_aMem.GetCount() == 0 || m_aMem[0]->GetData() == NULL || m_lock.m_h == NULL)
		{
			*pcbBytes = 0;
			*pcObjectTypes = 0;
			return ERROR_SUCCESS;
		}

		// get a lock so that other threads don't corrupt the data we're collecting
		CPerfLock lock(this);
		if (FAILED(lock.GetStatus()))
		{
			*pcbBytes = 0;
			*pcObjectTypes = 0;
			return ERROR_SUCCESS;
		}

		LPBYTE pData = LPBYTE(*ppData);
		ULONG nBytesLeft = *pcbBytes;
		ULONG nBytesUsed;
		*pcbBytes = 0;

		for (UINT i=0; i<_GetNumMapEntries(); i += _GetMapEntry(i).m_nNumCounters+1)
		{
			CPerfMapEntry* pObjectEntry = &_GetMapEntry(i);
			if (_WantObjectType(szValue, pObjectEntry->m_nNameId))
			{
				if (FAILED(_CollectObjectType(pObjectEntry, pData, nBytesLeft, &nBytesUsed)))
				{
					*pcbBytes = 0;
					*pcObjectTypes = 0;
					return ERROR_SUCCESS;
				}

				(*pcObjectTypes)++;
				(*pcbBytes) += nBytesUsed;
				nBytesLeft -= nBytesUsed;
				pData += nBytesUsed;
			}
		}

		*ppData = pData;
		return ERROR_SUCCESS;
	}
	_ATLCATCHALL()
	{
		*pcbBytes = 0;
		*pcObjectTypes = 0;
		return ERROR_SUCCESS;
	}
}

inline DWORD CPerfMon::Close() throw()
{
	UnInitialize();
	return ERROR_SUCCESS;
}

#ifdef _ATL_PERF_REGISTER
inline void CPerfMon::_AppendStrings(
	LPTSTR& pszNew,
	CAtlArray<CString>& astrStrings,
	ULONG iFirstIndex
	) throw()
{
	for (UINT iString = 0; iString < astrStrings.GetCount(); iString++)
	{
		INT nFormatChars = _stprintf(pszNew, _T("%d"), iFirstIndex+2*iString);
		pszNew += nFormatChars + 1;
		_tcscpy(pszNew, astrStrings[iString]);
		pszNew += astrStrings[iString].GetLength() + 1;
	}
}

inline HRESULT CPerfMon::_AppendRegStrings(
	CRegKey& rkLang,
	LPCTSTR szValue,
	CAtlArray<CString>& astrStrings,
	ULONG nNewStringSize,
	ULONG iFirstIndex,
	ULONG iLastIndex
	) throw()
{
	_ATLTRY
	{
		// load the existing strings, add the new data, and resave the strings
		ULONG nCharsOrig = 0;
		ULONG nCharsNew;
		DWORD dwErr;

		dwErr = rkLang.QueryMultiStringValue(szValue, NULL, &nCharsOrig);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		nCharsNew = nCharsOrig + nNewStringSize;

		CString strOrig;
		dwErr = rkLang.QueryMultiStringValue(szValue, CStrBuf(strOrig, nCharsOrig, CStrBuf::SET_LENGTH), &nCharsOrig);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
		LPCTSTR pszOrig = strOrig;

		CString strNew;
		CStrBuf szNew(strNew, nCharsNew, CStrBuf::SET_LENGTH);
		LPTSTR pszNew = szNew;

		bool bNewStringsAdded = false;

		while (*pszOrig != '\0')
		{
			ULONG iIndex = _ttoi(pszOrig);
			int nLen = (int) _tcslen(pszOrig) + 1; // get the length of the index and null
			nLen += (int) _tcslen(pszOrig+nLen) + 1; // add the length of the description and null

			if (!bNewStringsAdded && iIndex >= iFirstIndex)
			{
				_AppendStrings(pszNew, astrStrings, iFirstIndex);
				bNewStringsAdded = true;
			}

			if (iIndex < iFirstIndex || iIndex > iLastIndex)
			{
				memmove(pszNew, pszOrig, nLen*sizeof(TCHAR));
				pszNew += nLen;
			}
			pszOrig += nLen;
		}
		if (!bNewStringsAdded)
			_AppendStrings(pszNew, astrStrings, iFirstIndex);

		*pszNew++ = '\0'; // must have 2 null terminators at end of multi_sz

		dwErr = rkLang.SetMultiStringValue(szValue, strNew);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_RemoveRegStrings(
	CRegKey& rkLang,
	LPCTSTR szValue,
	ULONG iFirstIndex,
	ULONG iLastIndex
	) throw()
{
	_ATLTRY
	{
		// load the existing strings, remove the data, and resave the strings
		DWORD nChars = 0;
		DWORD dwErr;
		
		dwErr = rkLang.QueryMultiStringValue(szValue, NULL, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		CString str;
		CStrBuf szBuf(str, nChars, CStrBuf::SET_LENGTH);

		dwErr = rkLang.QueryMultiStringValue(szValue, szBuf, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		LPCTSTR pszRead = szBuf;
		LPTSTR pszWrite = szBuf;
		while (*pszRead != '\0')
		{
			ULONG iIndex = _ttoi(pszRead);
			int nLen = (int) _tcslen(pszRead) + 1; // get the length of the index and null
			nLen += (int) _tcslen(pszRead+nLen) + 1; // add the length of the description and null
			if (iIndex < iFirstIndex || iIndex > iLastIndex)
			{
				memmove(pszWrite, pszRead, nLen*sizeof(TCHAR));
				pszWrite += nLen;
			}
			pszRead += nLen;
		}
		*pszWrite++ = '\0'; // must have 2 null terminators at end of multi_sz

		dwErr = rkLang.SetMultiStringValue(szValue, szBuf);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_ReserveStringRange(DWORD& dwFirstCounter, DWORD& dwFirstHelp) throw()
{
	CRegKey rkApp;
	CString strAppKey;
	DWORD dwErr;

	_ATLTRY
	{
		strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, strAppKey);
	if (dwErr == ERROR_SUCCESS)
	{
		// see if we already have a sufficient range reserved
		DWORD dwFirstAppCounter;
		DWORD dwFirstAppHelp;
		DWORD dwLastAppCounter;
		DWORD dwLastAppHelp;
	
		if (rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp) == ERROR_SUCCESS &&
				dwLastAppCounter-dwFirstAppCounter+2 >= DWORD(2*_GetNumMapEntries()) &&
				dwLastAppHelp-dwFirstAppHelp+2 >= DWORD(2*_GetNumMapEntries()))
		{
			dwFirstCounter = dwFirstAppCounter;
			dwFirstHelp = dwFirstAppHelp;
			return S_OK;
		}
	}

	CRegKey rkPerfLib;

	dwErr = rkPerfLib.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfPerfLibKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	if (!rkApp)
	{
		dwErr = rkApp.Create(HKEY_LOCAL_MACHINE, strAppKey);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	// figure out the counter range
	DWORD dwLastCounter;
	DWORD dwLastHelp;

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwFirstCounter = dwLastCounter + 2;
	dwFirstHelp = dwLastHelp + 2;
	dwLastCounter += 2*_GetNumMapEntries();
	dwLastHelp += 2*_GetNumMapEntries();

	dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	// register the used counter range
	dwErr = rkApp.SetDWORDValue(c_szAtlPerfFirstCounter, dwFirstCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfFirstHelp, dwFirstHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	return S_OK;
}

inline HRESULT CPerfMon::Register(
	LPCTSTR szOpenFunc,
	LPCTSTR szCollectFunc,
	LPCTSTR szCloseFunc,
	HINSTANCE hDllInstance /* == _AtlBaseModule.GetModuleInstance() */
	) throw()
{
	ATLASSERT(szOpenFunc != NULL);
	ATLASSERT(szCollectFunc != NULL);
	ATLASSERT(szCloseFunc != NULL);

	CString str;
	DWORD dwErr;
	HRESULT hr;

	hr = CreateMap(LANGIDFROMLCID(GetThreadLocale()), hDllInstance);
	if (FAILED(hr))
		return hr;

	CString strAppKey;
	_ATLTRY
	{
		strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	// if we're already registered, unregister so we can redo registration
	_UnregisterStrings();
	
	// reserve a range for our counter and help strings
	DWORD dwFirstCounter = 0;
	DWORD dwFirstHelp = 0;
	_ReserveStringRange(dwFirstCounter, dwFirstHelp);

	for (UINT i=0; i<_GetNumMapEntries(); i++)
	{
		CPerfMapEntry& entry = _GetMapEntry(i);

		entry.m_nNameId = dwFirstCounter + i*2;
		entry.m_nHelpId = dwFirstHelp + i*2;
	}

	// register the app entry points
	CRegKey rkApp;

	dwErr = rkApp.Create(HKEY_LOCAL_MACHINE, strAppKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	_ATLTRY
	{
		if (GetModuleFileName(hDllInstance, CStrBuf(str, MAX_PATH), MAX_PATH) == 0)
			return AtlHresultFromLastError();
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	dwErr = rkApp.SetStringValue(c_szAtlPerfLibrary, str);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfOpen, szOpenFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfCollect, szCollectFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfClose, szCloseFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, _T(""));
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	hr = _SaveMap();
	if (FAILED(hr))
		return hr;

	return S_OK;
}

inline HRESULT CPerfMon::RegisterStrings(
	LANGID language /* = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) */,
	HINSTANCE hResInstance /* = _AtlBaseModule.GetResourceInstance() */
	) throw()
{
	_ATLTRY
	{
		CString str;
		DWORD dwErr;
		HRESULT hr;
		CRegKey rkLang;
		CRegKey rkApp;

		LANGID wPrimaryLanguage = (LANGID) PRIMARYLANGID(language);

		if (language == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			language = LANGIDFROMLCID(GetThreadLocale());
			wPrimaryLanguage = (LANGID) PRIMARYLANGID(language);
		}

		hr = CreateMap(language, hResInstance);
		if (FAILED(hr))
			return hr;

		str.Format(c_szAtlPerfPerfLibLangKey, wPrimaryLanguage);
		dwErr = rkLang.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr == ERROR_FILE_NOT_FOUND)
			return S_FALSE; // the language isn't installed on the system
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		// load list of language strings already registered
		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		DWORD dwLangsLen = 0;
		CString strLangs;

		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, NULL, &dwLangsLen);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		CStrBuf szLangs(strLangs, dwLangsLen+4, CStrBuf::SET_LENGTH); // reserve room for adding new language
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, szLangs, &dwLangsLen);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
		dwLangsLen--; // don't count '\0'

		// see if this language has already been registered and if so, return
		TCHAR szNewLang[5];
		_stprintf(szNewLang, _T("%3.3x "), wPrimaryLanguage);
		if (strLangs.Find(szNewLang) != -1)
			return S_OK;

		// load the strings we want to append and figure out how much extra space is needed for them
		// (including up to 5-digit index values and 2 null separators)
		CAtlArray<CString> astrCounters;
		CAtlArray<CString> astrHelp;
		ULONG nNewCounterSize = 0;
		ULONG nNewHelpSize = 0;

		for (UINT i=0; i<_GetNumMapEntries(); i++)
		{
			CPerfMapEntry& object = _GetMapEntry(i);

			astrCounters.Add(object.m_strName);
			nNewCounterSize += object.m_strName.GetLength() + 7;

			astrHelp.Add(object.m_strHelp);
			nNewHelpSize += object.m_strHelp.GetLength() + 7;
		}

		DWORD dwFirstCounter;
		DWORD dwFirstHelp;
		DWORD dwLastCounter;
		DWORD dwLastHelp;

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		hr = _AppendRegStrings(rkLang, c_szAtlPerfCounter, astrCounters, nNewCounterSize, dwFirstCounter, dwLastCounter);
		if (FAILED(hr))
			return hr;

		hr = _AppendRegStrings(rkLang, c_szAtlPerfHelp, astrHelp, nNewHelpSize, dwFirstHelp, dwLastHelp);
		if (FAILED(hr))
			return hr;

		// add the language to the list of installed languages
		_tcscpy(szLangs+dwLangsLen, szNewLang);

		dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, szLangs);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline BOOL CPerfMon::EnumResLangProc(
	HINSTANCE hModule,
	LPCTSTR szType,
	LPCTSTR szName,
	LANGID wIDLanguage,
	LPARAM lParam
	) throw()
{
	hModule; // unused
	szType; // unused
	szName; // unused

	CAtlArray<LANGID>* pLangs = reinterpret_cast<CAtlArray<LANGID>*>(lParam);
	_ATLTRY
	{
		pLangs->Add(wIDLanguage);
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	return TRUE;
}

inline HRESULT CPerfMon::RegisterAllStrings(
	HINSTANCE hResInstance /* = NULL */
	) throw()
{
	HRESULT hrReturn = S_FALSE;
	HRESULT hr;

	UINT nRes;
	hr = CreateMap(0, NULL, &nRes);
	if (FAILED(hr))
		return hr;

	if (nRes == 0)
		return RegisterStrings(0, hResInstance);

	if (hResInstance != NULL)
		return _RegisterAllStrings(nRes, hResInstance);

	for (int i = 0; hResInstance = _AtlBaseModule.GetHInstanceAt(i), hResInstance != NULL; i++)
	{
		hr = _RegisterAllStrings(nRes, hResInstance);
		if (FAILED(hr))
			return hr;
		if (hr == S_OK)
			hrReturn = S_OK;
	}

	return hrReturn;
}

inline HRESULT CPerfMon::_RegisterAllStrings(
	UINT nRes,
	HINSTANCE hResInstance
	) throw()
{
	HRESULT hrReturn = S_FALSE;
	HRESULT hr;

	CAtlArray<LANGID> langs;
	if (!EnumResourceLanguages(hResInstance, RT_STRING, MAKEINTRESOURCE((nRes>>4)+1), EnumResLangProc, reinterpret_cast<LPARAM>(&langs)))
		return AtlHresultFromLastError();

	for (UINT i=0; i<langs.GetCount(); i++)
	{
		hr = RegisterStrings(langs[i], hResInstance);
		if (FAILED(hr))
			return hr;
		if (hr == S_OK)
			hrReturn = S_OK;
	}

	return hrReturn;
}

inline HRESULT CPerfMon::_UnregisterStrings() throw()
{
	_ATLTRY
	{
		CString str;
		HRESULT hr;
		DWORD dwErr;

		// unregister the PerfMon counter and help strings
		CRegKey rkApp;

		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		DWORD dwFirstAppCounter;
		DWORD dwFirstAppHelp;
		DWORD dwLastAppCounter;
		DWORD dwLastAppHelp;

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		// iterate through the installed languages and delete them all
		DWORD nChars = 0;
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, NULL, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		CString strLangs;
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, CStrBuf(strLangs, nChars, CStrBuf::SET_LENGTH), &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		int nIndex = 0;
		CString strLang = strLangs.Tokenize(_T(" "), nIndex);
		while (!strLang.IsEmpty())
		{
			CRegKey rkLang;

			dwErr = rkLang.Open(HKEY_LOCAL_MACHINE, CString(c_szAtlPerfPerfLibKey) + _T("\\") + strLang);
			if (dwErr != ERROR_SUCCESS)
				return AtlHresultFromWin32(dwErr);

			hr = _RemoveRegStrings(rkLang, c_szAtlPerfCounter, dwFirstAppCounter, dwLastAppCounter);
			if (FAILED(hr))
				return hr;

			hr = _RemoveRegStrings(rkLang, c_szAtlPerfHelp, dwFirstAppHelp, dwLastAppHelp);
			if (FAILED(hr))
				return hr;

			strLang = strLangs.Tokenize(_T(" "), nIndex);
		}

		dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, _T(""));
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
			
		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::Unregister() throw()
{
	CString str;
	HRESULT hr;
	DWORD dwErr;

	CRegKey rkPerfLib;
	CRegKey rkApp;

	hr = _UnregisterStrings();
	if (FAILED(hr))
		return hr;

	dwErr = rkPerfLib.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfPerfLibKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	_ATLTRY
	{
		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
	dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	DWORD dwLastCounter;
	DWORD dwLastHelp;
	DWORD dwFirstAppCounter;
	DWORD dwFirstAppHelp;
	DWORD dwLastAppCounter;
	DWORD dwLastAppHelp;

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	// rewind the Last Help/Last Counter values if possible
	if (dwLastCounter == dwLastAppCounter)
	{
		dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastCounter, dwFirstAppCounter-2);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	if (dwLastHelp == dwLastAppHelp)
	{
		dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastHelp, dwFirstAppHelp-2);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	// delete the app key
	CRegKey rkServices;

	rkApp.Close();
	dwErr = rkServices.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfServicesKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkServices.RecurseDeleteKey(GetAppName());
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	return S_OK;
}
#endif

inline HRESULT CPerfMon::Initialize() throw()
{
	CMutex tempLock;
	CString strAppName;
	HRESULT hr;

	_ATLTRY
	{
		strAppName = GetAppName();

		ATLASSERT(m_aMem.GetCount() == 0);

		// initialize a security descriptor to give everyone access to objects we create
		CSecurityDescriptor sd;
		sd.InitializeFromThreadToken();
		SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), sd, FALSE };

		// create a mutex to handle syncronizing access to the shared memory area
		CString strMutexName;
		strMutexName.Format(_T("ATLPERF_%s_LOCK"), strAppName);
		tempLock.Create(&sa, FALSE, strMutexName);
		if (tempLock.m_h == NULL)
			return AtlHresultFromLastError();

		// create a shared memory area to share data between the app being measured and the client doing the measuring
		{
			CMutexLock lock(tempLock);

			BOOL bExisted = FALSE;

			CAtlFileMappingBase* pMem;
			pMem = _AllocNewBlock(NULL, &bExisted);
			if (pMem == NULL)
				return E_OUTOFMEMORY;

			if (!bExisted)
			{
				// copy the map from the registry to the shared memory
				CRegKey rkApp;
				DWORD dwErr;
				CString strAppKey;

				strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());

				dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, strAppKey, KEY_READ);
				if (dwErr != ERROR_SUCCESS)
				{
					m_aMem.RemoveAll();
					return AtlHresultFromWin32(dwErr);
				}

				ULONG nBytes = m_nAllocSize;
				dwErr = rkApp.QueryBinaryValue(c_szAtlPerfMap, pMem->GetData(), &nBytes);
				if (dwErr != ERROR_SUCCESS)
				{
					m_aMem.RemoveAll();
					return AtlHresultFromWin32(dwErr);
				}
			}

			hr = _LoadMap();
			if (FAILED(hr))
			{
				m_aMem.RemoveAll();
				return hr;
			}

			m_nSchemaSize = *LPDWORD(pMem->GetData());
			m_nHeaderSize = m_nSchemaSize + sizeof(DWORD);
		}

		m_lock.Attach(tempLock.Detach());
	}
	_ATLCATCHALL()
	{
		m_aMem.RemoveAll();
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

inline void CPerfMon::UnInitialize() throw()
{
	if (m_lock.m_h != NULL)
		m_lock.Close();
	m_aMem.RemoveAll();
	ClearMap();
}

inline HRESULT CPerfMon::_CreateInstance(
	DWORD dwObjectId,
	DWORD dwInstance,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance,
	bool bByName
	) throw()
{
	CPerfObject* pEmptyBlock = NULL;

	if (ppInstance == NULL)
		return E_POINTER;
	if (m_aMem.GetCount() == 0 || m_aMem[0]->GetData() == NULL || m_lock.m_h == NULL)
		return E_UNEXPECTED; // Initialize must succeed before calling CreateInstance

	*ppInstance = NULL;

	CPerfMapEntry* pObjectEntry = _FindObjectInfo(dwObjectId);
	if (pObjectEntry == NULL)
		return E_INVALIDARG;
	if (szInstanceName == NULL && bByName)
		return E_INVALIDARG;
	if (pObjectEntry->m_nInstanceLess == PERF_NO_INSTANCES &&
			(dwInstance != 0 || szInstanceName != NULL))
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return lock.GetStatus();

	CAtlFileMappingBase* pCurrentBlock = m_aMem[0];
	CPerfObject* pInstance = _GetFirstObject(pCurrentBlock);
	ULONG nMaxInstance = 0;
	ULONG nUsedSpace = 0;

	// walk all of the existing objects trying to find one that matches the request
	while (pInstance->m_nAllocSize != 0)
	{
		nUsedSpace += pInstance->m_nAllocSize;

		if (pInstance->m_dwObjectId == dwObjectId)
		{
			nMaxInstance = max(nMaxInstance, pInstance->m_dwInstance);

			// check to see if we've found the one the caller wants
			if (!bByName && pInstance->m_dwInstance == dwInstance &&
				(pObjectEntry->m_nInstanceLess == PERF_NO_INSTANCES || dwInstance != 0))
			{
				*ppInstance = pInstance;
				pInstance->m_nRefCount++;
				return S_OK;
			}
			if (bByName)
			{
				LPWSTR szInstName = (LPWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset));
				if (wcsncmp(szInstName, szInstanceName, pObjectEntry->m_nMaxInstanceNameLen-1) == 0)
				{
					*ppInstance = pInstance;
					pInstance->m_nRefCount++;
					return S_OK;
				}
			}
		}

		if (pInstance->m_nAllocSize == pObjectEntry->m_nAllocSize && pInstance->m_dwObjectId == 0)
			pEmptyBlock = pInstance;

		pInstance = _GetNextObject(pInstance);

		if (pInstance->m_nAllocSize == 0 &&
			m_nHeaderSize + nUsedSpace + pObjectEntry->m_nAllocSize + sizeof(CPerfObject) > m_nAllocSize)
		{
			// we've reached the end of the block and have no room to allocate an object of this
			// type. cap the block with a sentinel
			pInstance->m_nAllocSize = (ULONG) -1;
		}

		// check for an end-of-shared-mem sentinel
		if (pInstance->m_nAllocSize == (ULONG) -1)
		{
			nUsedSpace = 0;
			CAtlFileMappingBase* pNextBlock = _GetNextBlock(pCurrentBlock);
			if (pNextBlock == NULL)
			{
				// we've reached the last block of shared mem.
				// the instance hasn't been found, so either use a
				// previously freed instance block (pEmptyBlock) or allocate a new
				// shared mem block to hold the new instance
				if (pEmptyBlock == NULL)
				{
					pNextBlock = _AllocNewBlock(pCurrentBlock);
					if (pNextBlock == NULL)
						return E_OUTOFMEMORY;
				}
				else
					break;
			}
			pCurrentBlock = pNextBlock;
			pInstance = _GetFirstObject(pCurrentBlock);
		}
	}

	// allocate a new object
	if (pEmptyBlock != NULL)
		pInstance = pEmptyBlock;
	else
		pInstance->m_nAllocSize = pObjectEntry->m_nAllocSize;

	pInstance->m_dwObjectId = pObjectEntry->m_dwPerfId;
	if (dwInstance == 0 && pObjectEntry->m_nInstanceLess != PERF_NO_INSTANCES)
		pInstance->m_dwInstance = nMaxInstance + 1;
	else
		pInstance->m_dwInstance = dwInstance;

	pInstance->m_nRefCount = 1;

	// copy the instance name, truncate if necessary
	if (pObjectEntry->m_nInstanceLess != PERF_NO_INSTANCES)
	{
		ULONG nNameLen = (ULONG)min(wcslen(szInstanceName), pObjectEntry->m_nMaxInstanceNameLen-1);
		ULONG nNameBytes = (nNameLen+1) * sizeof(WCHAR);
		pInstance->m_nInstanceNameOffset = pInstance->m_nAllocSize-nNameBytes;
		memcpy(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset, szInstanceName, nNameBytes);
		LPWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset)[nNameLen] = 0;
	}

	*ppInstance = pInstance;

	return S_OK;
}

inline HRESULT CPerfMon::CreateInstance(
	DWORD dwObjectId,
	DWORD dwInstance,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance
	) throw()
{
	return _CreateInstance(dwObjectId, dwInstance, szInstanceName, ppInstance, false);
}

inline HRESULT CPerfMon::CreateInstanceByName(
	DWORD dwObjectId,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance
	) throw()
{
	return _CreateInstance(dwObjectId, 0, szInstanceName, ppInstance, true);
}

inline HRESULT CPerfMon::ReleaseInstance(CPerfObject* pInstance) throw()
{
	ATLASSERT(pInstance != NULL);
	if (pInstance == NULL)
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return lock.GetStatus();

	if (--pInstance->m_nRefCount == 0)
	{
		pInstance->m_dwInstance = 0;
		pInstance->m_dwObjectId = 0;
	}

	return S_OK;
}

inline HRESULT CPerfMon::LockPerf(DWORD dwTimeout /* == INFINITE */) throw()
{
	if (m_lock.m_h == NULL)
		return E_UNEXPECTED;

	DWORD dwRes = WaitForSingleObject(m_lock.m_h, dwTimeout);
	if (dwRes == WAIT_ABANDONED || dwRes == WAIT_OBJECT_0)
		return S_OK;
	if (dwRes == WAIT_TIMEOUT)
		return HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	return AtlHresultFromLastError();
}

inline void CPerfMon::UnlockPerf() throw()
{
	m_lock.Release();
}

// map building routines
inline HRESULT CPerfMon::AddObjectDefinition(
	DWORD dwObjectId,
	LPCTSTR szObjectName,
	LPCTSTR szHelpString,
	DWORD dwDetailLevel,
	INT nDefaultCounter,
	BOOL bInstanceLess,
	UINT nStructSize,
	UINT nMaxInstanceNameLen) throw()
{
	// must have one and only one of these
	ATLASSERT(!bInstanceLess ^ !nMaxInstanceNameLen);

	CPerfMapEntry entry;

	entry.m_dwPerfId = dwObjectId;
	_ATLTRY
	{
		entry.m_strName = szObjectName;
		entry.m_strHelp = szHelpString;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
	entry.m_dwDetailLevel = dwDetailLevel;
	entry.m_bIsObject = TRUE;

	// OBJECT INFO
	entry.m_nNumCounters = 0;
	entry.m_nDefaultCounter = nDefaultCounter;
	entry.m_nInstanceLess = bInstanceLess ? PERF_NO_INSTANCES : 0;
	entry.m_nStructSize = nStructSize;
	entry.m_nMaxInstanceNameLen = nMaxInstanceNameLen;
	entry.m_nAllocSize = nStructSize + nMaxInstanceNameLen*sizeof(WCHAR);

	// COUNTER INFO
	entry.m_dwCounterType = 0;
	entry.m_nDefaultScale = 0;
	entry.m_nMaxCounterSize = 0;
	entry.m_nDataOffset = 0;

	entry.m_nNameId = 0;
	entry.m_nHelpId = 0;

	_ATLTRY
	{
		m_map.Add(entry);
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	if (_GetNumMapEntries() == 1)
		m_nNumObjectTypes = 1;
	else
		m_nNumObjectTypes++;

	return S_OK;
}

inline HRESULT CPerfMon::AddCounterDefinition(
	DWORD dwCounterId,
	LPCTSTR szCounterName,
	LPCTSTR szHelpString,
	DWORD dwDetailLevel,
	DWORD dwCounterType,
	ULONG nMaxCounterSize,
	UINT nOffset,
	INT nDefaultScale) throw()
{
	for (int i=_GetNumMapEntries()-1; i>=0; i--)
	{
		CPerfMapEntry& object = _GetMapEntry(i);
		if (object.m_bIsObject)
		{
			CPerfMapEntry counter;

			counter.m_dwPerfId = dwCounterId;
			_ATLTRY
			{
				counter.m_strName = szCounterName;
				counter.m_strHelp = szHelpString;
			}
			_ATLCATCHALL()
			{
				return E_OUTOFMEMORY;
			}
			counter.m_dwDetailLevel = dwDetailLevel;
			counter.m_bIsObject = FALSE;

			// OBJECT INFO
			counter.m_nNumCounters = 0;
			counter.m_nDefaultCounter = 0;
			counter.m_nInstanceLess = 0;
			counter.m_nStructSize = 0;
			counter.m_nMaxInstanceNameLen = 0;
			counter.m_nAllocSize = 0;

			// COUNTER INFO
			counter.m_dwCounterType = dwCounterType;
			counter.m_nDefaultScale = nDefaultScale;
			counter.m_nMaxCounterSize = nMaxCounterSize;
			counter.m_nDataOffset = nOffset;

			object.m_nNumCounters++;
			if (counter.m_nMaxCounterSize > 0)
			{
				ATLASSERT(counter.m_dwCounterType & PERF_TYPE_TEXT);
				object.m_nAllocSize += counter.m_nMaxCounterSize * sizeof(WCHAR);
			}

			counter.m_nNameId = 0;
			counter.m_nHelpId = 0;

			_ATLTRY
			{
				m_map.Add(counter);
			}
			_ATLCATCHALL()
			{
				return E_OUTOFMEMORY;
			}

			return S_OK;
		}
	}

	// found no object in map! must add object BEFORE adding counter!
	ATLASSERT(FALSE);
	return E_UNEXPECTED;
}

inline void CPerfMon::ClearMap() throw()
{
	m_map.RemoveAll();
}

#ifndef _ATL_PERF_NOXML

ATL_NOINLINE inline HRESULT CPerfMon::PersistToXML(IStream *pStream, BOOL bFirst/*=TRUE*/, BOOL bLast/*=TRUE*/) throw(...)
{
	ATLASSERT(pStream != NULL);
	if (pStream == NULL)
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return ERROR_SUCCESS;

	CStringA strXML;
	HRESULT hr = S_OK;
	ULONG nLen = 0;
	
	if (bFirst)
	{
		strXML = "<?xml version=\"1.0\" ?>\r\n<perfPersist>\r\n";
		hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
		if (hr != S_OK)
			return hr;
	}

	strXML.Format("\t<perfmon name=\"%s\">\r\n", CT2CA(GetAppName()));
	hr = pStream->Write(strXML, strXML.GetLength(), &nLen);

	for (UINT i=0; i<_GetNumMapEntries(); i+= _GetMapEntry(i).m_nNumCounters+1)
	{
		CPerfMapEntry *pObjectEntry = &_GetMapEntry(i);
		CPerfMapEntry *pCounterEntries = pObjectEntry+1;

		CAtlFileMappingBase *pCurrentBlock = _GetNextBlock(NULL);
		CPerfObject *pInstance = _GetFirstObject(pCurrentBlock);

		strXML.Format("\t\t<perfObject perfid=\"%d\">\r\n", 
			pObjectEntry->m_dwPerfId, pObjectEntry->m_nNameId, pObjectEntry->m_nHelpId);

		hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
		if (hr != S_OK)
			return E_FAIL;

		while (pInstance && pInstance->m_nAllocSize)
		{
			if (pInstance->m_dwObjectId == pObjectEntry->m_dwPerfId)
			{
				if (pObjectEntry->m_nInstanceLess != PERF_NO_INSTANCES)
				{
					// handle the instance name
					LPCWSTR wszInstNameSrc = LPCWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset);
					int nInstLen = (int) wcslen(wszInstNameSrc);

					// convert to UTF8
					nLen = AtlUnicodeToUTF8(wszInstNameSrc, nInstLen, NULL, 0);
					CHeapPtr<CHAR> szUTF8;
					if (!szUTF8.Allocate(nLen+1))
						return E_OUTOFMEMORY;
					nLen = AtlUnicodeToUTF8(wszInstNameSrc, nInstLen, szUTF8, nLen);
					szUTF8[nLen] = '\0';

					strXML.Format("\t\t\t<instance name=\"%s\">\r\n", szUTF8);
					hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
					if (hr != S_OK)
						return hr;
				}

				for (ULONG j=0; j<pObjectEntry->m_nNumCounters; j++)
				{
					CPerfMapEntry *pCounterEntry = pCounterEntries+j;
					switch (pCounterEntry->m_dwCounterType & ATLPERF_SIZE_MASK)
					{
						case PERF_SIZE_DWORD:
						{
							strXML.Format("\t\t\t\t<counter type=\"perf_size_dword\" value=\"%d\" offset=\"%d\"/>\r\n",
								*LPDWORD(LPBYTE(pInstance)+pCounterEntry->m_nDataOffset), 
								pCounterEntry->m_nDataOffset);
							break;
						}
						case PERF_SIZE_LARGE:
						{
							strXML.Format("\t\t\t\t<counter type=\"perf_size_large\" value=\"%d\" offset=\"%d\"/>\r\n",
								*PULONGLONG(LPBYTE(pInstance)+pCounterEntry->m_nDataOffset),
								pCounterEntry->m_nDataOffset);
							break;
						}
						case PERF_SIZE_VARIABLE_LEN:
						{
							CHeapPtr<CHAR> szUTF8;
							LPBYTE pSrc = LPBYTE(pInstance)+pCounterEntry->m_nDataOffset;
							if ((pCounterEntry->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
							{
								ULONG nTextLen = (ULONG)wcslen(LPCWSTR(pSrc));
								// convert to UTF8
								nLen = AtlUnicodeToUTF8(LPCWSTR(pSrc), nTextLen, NULL, 0);
								if (!szUTF8.Allocate(nLen+1))
									return E_OUTOFMEMORY;

								nLen = AtlUnicodeToUTF8(LPCWSTR(pSrc), nTextLen, szUTF8, nLen);	
								szUTF8[nLen] = '\0';
								strXML.Format("\t\t\t\t<counter type=\"perf_size_variable_len_unicode\" value=\"%s\" offset=\"%d\"/>\r\n",
										szUTF8,
										pCounterEntry->m_nDataOffset);
							}
							else
							{
								ULONG nTextLen = (ULONG)strlen(LPCSTR(pSrc));
								if (!szUTF8.Allocate(nTextLen+1))
									return E_OUTOFMEMORY;
								strcpy(szUTF8, LPCSTR(pSrc));
								strXML.Format("\t\t\t\t<counter type=\"perf_size_variable_len_ansi\" value=\"%s\" offset=\"%d\"/>\r\n",
										szUTF8,
										pCounterEntry->m_nDataOffset);
							}
							break;
						}
						default:
							// error:
							return E_FAIL;
					}
					hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
					if (hr != S_OK)
						return hr;
				}
			}

			if (pObjectEntry->m_nInstanceLess != PERF_NO_INSTANCES)
			{
				hr = pStream->Write("\t\t\t</instance>\r\n", sizeof("\t\t\t</instance>\r\n")-1, &nLen);
				if (hr != S_OK)
					return hr;
			}

			pInstance = _GetNextObject(pInstance);
			if (pInstance->m_nAllocSize == (ULONG)-1)
			{
				pCurrentBlock = _GetNextBlock(pCurrentBlock);
				if (pCurrentBlock == NULL)
					pInstance = NULL;
				else
					pInstance = _GetFirstObject(pCurrentBlock);
			}
		}

		hr = pStream->Write("\t\t</perfObject>\r\n", sizeof("\t\t</perfObject>\r\n")-1, &nLen);
		if (hr != S_OK)
			return hr;
	}

	hr = pStream->Write("\t</perfmon>\r\n", sizeof("\t</perfmon>\r\n")-1, &nLen);
	if (hr != S_OK)
		return hr;

	if (hr == S_OK && bLast)
		hr = pStream->Write("</perfPersist>", sizeof("</perfPersist>")-1, &nLen);

	return hr;
}

// This function is very lenient with inappropriate XML
ATL_NOINLINE inline HRESULT CPerfMon::LoadFromXML(IStream *pStream) throw(...)
{	
	ATLASSERT(pStream != NULL);
	if (pStream == NULL)
		return E_INVALIDARG;

	// Get a lock
	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return ERROR_SUCCESS;

	CComPtr<IXMLDOMDocument> spdoc;

	// load the xml
	HRESULT hr = CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC, __uuidof(IXMLDOMDocument), (void **) &spdoc);
	if (FAILED(hr))
	{
		return hr;
	}

	spdoc->put_async(VARIANT_FALSE);

	CComPtr<IPersistStreamInit> spSI;
	hr = spdoc->QueryInterface(&spSI);
	if (hr != S_OK)
		return hr;
	hr = spSI->Load(pStream);
	if (hr != S_OK)
		return hr;

	// validate that it is a perfPersist stream
	CComPtr<IXMLDOMElement> spRoot;

	hr = spdoc->get_documentElement(&spRoot);
	if (hr != S_OK)
		return hr;

	CComBSTR bstrName;
	hr = spRoot->get_baseName(&bstrName);
	if (wcscmp(bstrName, L"perfPersist"))
		return S_FALSE;

	USES_CONVERSION;	
	// find the appropriate perfmon node

	CComPtr<IXMLDOMNode> spChild;
	hr = spRoot->get_firstChild(&spChild);
	while (hr == S_OK)
	{
		bstrName.Empty();
		hr = spChild->get_baseName(&bstrName);
		if (hr == S_OK)
		{
			if (!wcscmp(bstrName, L"perfmon"))
			{
				bstrName.Empty();
				hr = _GetAttribute(spChild, L"name", &bstrName);
				if (hr == S_OK)
				{
					if (!_tcscmp(W2CT(bstrName), GetAppName()))
						break;
				}
			}
		}

		CComPtr<IXMLDOMNode> spNext;
		hr = spChild->get_nextSibling(&spNext);
		spChild.Attach(spNext.Detach());
	}

	// there is no perfmon node in the XML for the current CPerfMon class
	if (hr != S_OK)
		return S_FALSE;

	CComPtr<IXMLDOMNode> spPerfRoot;
	spPerfRoot.Attach(spChild.Detach());

	// iterate over the objects in the perfmon subtree
	// this is the loop that does the real work
	hr = spPerfRoot->get_firstChild(&spChild);
	DWORD dwInstance = 1;
	while (hr == S_OK)
	{
		// see if it's a perfObject
		bstrName.Empty();
		hr = spChild->get_baseName(&bstrName);
		if (hr != S_OK || wcscmp(bstrName, L"perfObject"))
			return S_FALSE;

		// get the perfid
		bstrName.Empty();
		hr = _GetAttribute(spChild, L"perfid", &bstrName);
		DWORD dwPerfId = _wtoi(bstrName);

		// iterate over children
		CComPtr<IXMLDOMNode> spInstChild;
		hr = spChild->get_firstChild(&spInstChild);
		while (hr == S_OK)
		{
			// see if it's a instance
			bstrName.Empty();
			hr = spInstChild->get_baseName(&bstrName);
			if (hr != S_OK || wcscmp(bstrName, L"instance"))
				return S_FALSE;

			// get the instance name
			bstrName.Empty();
			hr = _GetAttribute(spInstChild, L"name", &bstrName);
			if (hr != S_OK)
				return S_FALSE;

			// create the instance
			// REVIEW : take a loook at the dwInstance stuff--is it acceptable?
			CPerfObject *pInstance = NULL;
			hr = CreateInstance(dwPerfId, dwInstance++, bstrName, &pInstance);
			if (hr != S_OK)
				return S_FALSE;

			// iterate over the counters and set the data
			CComPtr<IXMLDOMNode> spCntrChild;
			hr = spInstChild->get_firstChild(&spCntrChild);
			while (hr == S_OK)
			{
				// get the base name
				bstrName.Empty();
				hr = spCntrChild->get_baseName(&bstrName);
				if (hr != S_OK || wcscmp(bstrName, L"counter"))
					return S_FALSE;

				// get the type
				bstrName.Empty();
				hr = _GetAttribute(spCntrChild, L"type", &bstrName);
				if (hr != S_OK)
					return S_FALSE;

				DWORD dwType;
				if (!wcscmp(bstrName, L"perf_size_dword"))
					dwType = PERF_SIZE_DWORD;
				else if (!wcscmp(bstrName, L"perf_size_large"))
					dwType = PERF_SIZE_LARGE;
				else if (!wcscmp(bstrName, L"perf_size_variable_len_ansi"))
					dwType = PERF_SIZE_VARIABLE_LEN;
				else if (!wcscmp(bstrName, L"perf_size_variable_len_unicode"))
					dwType = PERF_SIZE_VARIABLE_LEN | PERF_TEXT_UNICODE;
				else
					return S_FALSE;

				// get the value
				bstrName.Empty();
				hr = _GetAttribute(spCntrChild, L"value", &bstrName);
				if (hr != S_OK)
					return S_FALSE;

				CComBSTR bstrOffset;
				hr = _GetAttribute(spCntrChild, L"offset", &bstrOffset);
				if (hr != S_OK)
					return S_FALSE;

				WCHAR *pStop = NULL;
				DWORD dwOffset = wcstoul(bstrOffset, &pStop, 10);

				if (dwType == PERF_SIZE_DWORD) // add it as a DWORD
				{
					DWORD dwVal = wcstoul(bstrName, &pStop, 10);
					*LPDWORD(LPBYTE(pInstance)+dwOffset) = dwVal;
				}
				else if (dwType == PERF_SIZE_LARGE) // add it is a ULONGLONG
				{
					ULONGLONG qwVal = _wcstoui64(bstrName, &pStop, 10);
					*PULONGLONG(LPBYTE(pInstance)+dwOffset) = qwVal;
				}
				else if (dwType == PERF_SIZE_VARIABLE_LEN) // add it as an ansi string
				{
					AtlW2AHelper(LPSTR(LPBYTE(pInstance)+dwOffset), bstrName, bstrName.Length(), ATL::_AtlGetConversionACP());
				}
				else // add it as a unicode string
				{
					memcpy(LPBYTE(pInstance)+dwOffset, bstrName, bstrName.Length()*sizeof(WCHAR));
				}

				CComPtr<IXMLDOMNode> spCntrNext;
				hr = spCntrChild->get_nextSibling(&spCntrNext);
				spCntrChild.Attach(spCntrNext.Detach());
			}

			CComPtr<IXMLDOMNode> spInstNext;
			hr = spInstChild->get_nextSibling(&spInstNext);
			spInstChild.Attach(spInstNext.Detach());
		}

		CComPtr<IXMLDOMNode> spNext;
		hr = spChild->get_nextSibling(&spNext);
		spChild.Attach(spNext.Detach());
	}

	return S_OK;
}

// a little utility function to retrieve a named attribute from a node
ATL_NOINLINE inline HRESULT CPerfMon::_GetAttribute(IXMLDOMNode *pNode, LPCWSTR szAttrName, BSTR *pbstrVal) throw()
{
	ATLASSERT(pNode != NULL);
	ATLASSERT(szAttrName != NULL);
	ATLASSERT(pbstrVal != NULL);

	*pbstrVal = NULL;
	CComPtr<IXMLDOMNamedNodeMap> spAttrs;

	HRESULT hr = pNode->get_attributes(&spAttrs);
	if (hr != S_OK)
		return hr;
	
	CComPtr<IXMLDOMNode> spAttr;
	
	hr = spAttrs->getNamedItem((BSTR) szAttrName, &spAttr);
	if (hr != S_OK)
		return hr;
	
	CComVariant varVal;
	hr = spAttr->get_nodeValue(&varVal);
	if (hr != S_OK)
		return hr;
	
	hr = varVal.ChangeType(VT_BSTR);
	if (hr != S_OK)
		return hr;

	*pbstrVal = varVal.bstrVal;
	varVal.vt = VT_EMPTY;

	return S_OK;
}

#endif // _ATL_PERF_NOXML

} // namespace ATL

#pragma warning(pop)

#endif // __ATLPERF_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsafe.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSAFE_H__
#define __ATLSAFE_H__

#pragma once

#include <atlbase.h>

namespace ATL
{

// This struct is used with CComSafeArray to set the matching VARTYPE based on
// template argument type passed in to CComSafeArray.
template <typename T>
struct _ATL_AutomationType
{
};

#define DEFINE_AUTOMATION_TYPE_FUNCTION(ctype, typewrapper, oleautomationtype) \
	template <> \
	struct _ATL_AutomationType<ctype> \
	{ \
		typedef typewrapper _typewrapper;\
		enum { type = oleautomationtype }; \
		static void* GetT(const T& t) throw() \
		{ \
			return (void*)&t; \
		} \
	};
	// specialization for BSTR so GetT doesn't return &BSTR
	template <>
	struct _ATL_AutomationType<BSTR>
	{
		typedef CComBSTR _typewrapper ;
		enum { type = VT_BSTR};
		static void* GetT(const T& t) throw()
		{
			return t;
		}
	};
	// specialization for LPUNKNOWN so GetT doesn't return &LPUNKNOWN
	template <>
	struct _ATL_AutomationType<LPUNKNOWN>
	{
		typedef CComPtr<IUnknown> _typewrapper;
		enum { type = VT_UNKNOWN};
		static void* GetT(const T& t) throw()
		{
			return t;
		}
	};
	// specialization for LPDISPATCH so GetT doesn't return &LPDISPATCH
	template <>
	struct _ATL_AutomationType<LPDISPATCH>
	{
		typedef CComPtr<IDispatch> _typewrapper;
		enum { type = VT_DISPATCH};
		static void* GetT(const T& t) throw()
		{
			return t;
		}
	};

	DEFINE_AUTOMATION_TYPE_FUNCTION(CHAR		, CHAR			,VT_I1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(SHORT		, SHORT			,VT_I2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(INT			, INT			,VT_I4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONG		, LONG			,VT_I4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONGLONG	, LONGLONG		,VT_I8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(BYTE		, BYTE			,VT_UI1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(USHORT		, USHORT		,VT_UI2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(UINT		, UINT			,VT_UI4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONG		, ULONG			,VT_UI4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONGLONG	, ULONGLONG		,VT_UI8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(FLOAT		, FLOAT			,VT_R4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DOUBLE		, DOUBLE		,VT_R8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DECIMAL		, DECIMAL		,VT_DECIMAL)
	DEFINE_AUTOMATION_TYPE_FUNCTION(VARIANT		, CComVariant	,VT_VARIANT)
	DEFINE_AUTOMATION_TYPE_FUNCTION(CY			, CY			,VT_CY)

// wrapper for SAFEARRAYBOUND used with CComSafeArray
class CComSafeArrayBound : public SAFEARRAYBOUND
{
public:
	CComSafeArrayBound(ULONG ulCount = 0, LONG lLowerBound = 0) throw()
	{
		cElements = ulCount;
		lLbound = lLowerBound;
	}
	CComSafeArrayBound& operator=(const CComSafeArrayBound& bound) throw()
	{
		cElements = bound.cElements;
		lLbound = bound.lLbound;
		return *this;
	}
	CComSafeArrayBound& operator=(ULONG ulCount) throw() 
	{
		cElements = ulCount;
		lLbound = 0;
		return *this;
	}
	ULONG GetCount() const throw()
	{
		return cElements;
	}
	ULONG SetCount(ULONG ulCount) throw()
	{
		cElements = ulCount;
		return cElements;
	}
	LONG GetLowerBound() const throw()
	{
		return lLbound;
	}
	LONG SetLowerBound(LONG lLowerBound) throw()
	{
		lLbound = lLowerBound;
		return lLbound;
	}
	LONG GetUpperBound() const throw()
	{
		return lLbound + cElements - 1;
	}
};

// wrapper for SAFEARRAY.  T is type stored (e.g. BSTR, VARIANT, etc.)
template <typename T, VARTYPE _vartype = _ATL_AutomationType<T>::type>
class CComSafeArray 
{
public:
// Constructors
	CComSafeArray() throw() : m_psa(NULL)
	{
	}
	// create SAFEARRAY where number of elements = ulCount
	explicit CComSafeArray(ULONG ulCount, LONG lLBound = 0) : m_psa(NULL)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		HRESULT hRes = Create(&bound);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComSafeArray(const SAFEARRAYBOUND& bound) : m_psa(NULL)
	{
		HRESULT hRes = Create(&bound); 
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	// pass an array of SAFEARRAYBOUNDs for multi-dimensional
	explicit CComSafeArray(const SAFEARRAYBOUND *pBound, UINT uDims = 1) : m_psa(NULL)
	{
		ATLASSERT(pBound != NULL);
		ATLASSERT(uDims > 0);
		HRESULT hRes = Create(pBound, uDims);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const SAFEARRAY *psaSrc) : m_psa(NULL)
	{ 
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const SAFEARRAY& saSrc) : m_psa(NULL)
	{ 
		HRESULT hRes = CopyFrom(&saSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const CComSafeArray& saSrc) : m_psa(NULL)
	{
		ATLASSERT(saSrc.m_psa != NULL);
		HRESULT hRes = CopyFrom(saSrc.m_psa);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}

	~CComSafeArray() throw()
	{
		HRESULT hRes = Destroy();
		hRes;
		ATLASSERT(SUCCEEDED(hRes));
	} 

	HRESULT Attach(const SAFEARRAY *psaSrc) 
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT	hRes = Destroy();
		ATLASSERT(SUCCEEDED(hRes));
		if (SUCCEEDED(hRes))
		{
			m_psa = const_cast<LPSAFEARRAY>(psaSrc);
			hRes = Lock();
		}
		return hRes;
	}
	LPSAFEARRAY Detach()
	{
		Unlock();
		LPSAFEARRAY pTemp = m_psa;
		m_psa = NULL;
		return pTemp;
	} 

// overloaded operators
	CComSafeArray<T>& operator=(const CComSafeArray& saSrc)
	{
		*this = saSrc.m_psa;
		return *this;
	}
	CComSafeArray<T>& operator=(const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	operator const SAFEARRAY *() const throw()
	{
		return m_psa; 
	}
	operator LPSAFEARRAY() throw()
	{
		return m_psa; 
	}
	LPSAFEARRAY* GetSafeArrayPtr() throw()
	{
		return &m_psa;
	}
	const _ATL_AutomationType<T>::_typewrapper& operator[](int nIndex) const
	{
		return GetAt(nIndex);
	}
	_ATL_AutomationType<T>::_typewrapper& operator[](int nIndex)
	{
		return GetAt(nIndex);
	}
	const _ATL_AutomationType<T>::_typewrapper& operator[](LONG nIndex) const
	{
		return GetAt(nIndex);
	}
	_ATL_AutomationType<T>::_typewrapper& operator[](LONG nIndex)
	{
		return GetAt(nIndex);
	}

// info functions
	LONG GetLowerBound(UINT uDim = 0) const
	{
		ATLASSERT(m_psa != NULL);
		LONG lLBound = 0;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lLBound;
	}
	LONG GetUpperBound(UINT uDim = 0) const
	{
		ATLASSERT(m_psa != NULL);
		LONG lUBound = 0;
		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lUBound;
	}
	ULONG GetCount(UINT uDim = 0) const
	{
		ATLASSERT(m_psa != NULL);
		ATLASSERT(uDim < GetDimensions());
		LONG lLBound, lUBound;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		ATLASSERT(SUCCEEDED(hRes));
		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		ATLASSERT(SUCCEEDED(hRes));
		return (lUBound - lLBound + 1);
	}
	UINT GetDimensions() const
	{
		ATLASSERT(m_psa != NULL);
		return SafeArrayGetDim(m_psa);
	}
	VARTYPE GetType() const throw()
	{
		return _vartype;
	}
	bool IsSizable() const
	{
		ATLASSERT(m_psa != NULL);
		return (m_psa->fFeatures & FADF_FIXEDSIZE) ? false : true;
	}

// miscellaneous functions
	const _ATL_AutomationType<T>::_typewrapper& GetAt(LONG lIndex) const
	{
		ATLASSERT(m_psa != NULL);
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}

	_ATL_AutomationType<T>::_typewrapper& GetAt(LONG lIndex)
	{
		ATLASSERT(m_psa != NULL);
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}
	HRESULT SetAt(LONG lIndex, const T& t, BOOL bCopy = TRUE)
	{
		bCopy;
		ATLASSERT(m_psa != NULL);
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		((T*)m_psa->pvData)[lIndex-lLBound] = t;
		return S_OK;
	}
	// multi-dimensional version
	HRESULT MultiDimGetAt(const LONG *alIndex, T& t)
	{
		ATLASSERT(m_psa != NULL);
		return SafeArrayGetElement(m_psa, const_cast<LONG*>(alIndex), _ATL_AutomationType<T>::GetT(t));
	}
	// multi-dimensional version
	HRESULT MultiDimSetAt(const LONG *alIndex, const T& t)
	{
		ATLASSERT(m_psa != NULL);
		return SafeArrayPutElement(m_psa, const_cast<LONG*>(alIndex), _ATL_AutomationType<T>::GetT(t));
	}
	// append an item
	HRESULT Add(const T& t, BOOL bCopy = TRUE)
	{
		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		LONG lLBound = GetLowerBound();
		hRes = Resize(GetCount() + 1, lLBound);
		if (SUCCEEDED(hRes))
			return SetAt(GetCount() - 1 + lLBound, t, bCopy);
		else
			return hRes;
	}
	// appends an array of type T items
	HRESULT Add(ULONG ulCount, const T *pT, BOOL bCopy = TRUE)
	{
		ATLASSERT(pT != NULL);
		ATLASSERT(ulCount > 0);
		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			for (ULONG ulCntr=0; ulCntr<ulCount; ulCntr++, ulLastIndex++)
			{
				hRes = SetAt(ulLastIndex + lLBound, pT[ulCntr], bCopy);
				if (FAILED(hRes))
					break;
			}
		}
		return hRes;
	}
	// appends items in the safearray
	HRESULT Add(const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		// safearrays must only have one dimension
		ATLASSERT(SafeArrayGetDim(const_cast<LPSAFEARRAY>(psaSrc)) == 1);

		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1);

		// types must match
		VARTYPE vt;
		SafeArrayGetVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		ATLASSERT(GetType() == vt);

		// resize safearray
		ULONG ulCount = psaSrc->rgsabound[0].cElements;
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			CComSafeArray saTemp;
			hRes = saTemp.Attach(psaSrc);
			if (FAILED(hRes))
				return hRes;
			
			LONG lsrcLBound = saTemp.GetLowerBound();
			for(ULONG lCntr = 0; lCntr < ulCount; lCntr++, ulLastIndex++)
			{
				// copy data to end of our safearray
				hRes = SetAt(ulLastIndex + lLBound, saTemp.GetAt(lCntr + lsrcLBound));
				if (FAILED(hRes))
					break;
			}
			saTemp.Detach();
		}
		return hRes;
	}

	// Resize only resizes the right-most dimension
	HRESULT Resize(ULONG ulCount, LONG lLBound = 0)
	{
		ATLASSERT(m_psa != NULL);
		CComSafeArrayBound bound(ulCount, lLBound);
		return Resize(&bound);
	}
	// Resize only resizes the right-most dimension
	HRESULT Resize(const SAFEARRAYBOUND *pBound)
	{
		ATLASSERT(m_psa != NULL);
		ATLASSERT(pBound != NULL);
		if (!IsSizable())
			return E_FAIL;
		HRESULT hRes = Unlock();
		if (SUCCEEDED(hRes))
		{
			hRes = SafeArrayRedim(m_psa, const_cast<LPSAFEARRAYBOUND>(pBound));
			if (SUCCEEDED(hRes))
				hRes = Lock();
			else
				hRes = Lock();
		}
		return hRes;
	}
	HRESULT CopyFrom(const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = Destroy();
		ATLASSERT(SUCCEEDED(hRes));
		if (SUCCEEDED(hRes))
			hRes = SafeArrayCopy(const_cast<LPSAFEARRAY>(psaSrc), &m_psa);
		if (m_psa && SUCCEEDED(hRes))
			hRes = Lock();
		return hRes;
	}
	HRESULT CopyTo(LPSAFEARRAY *ppArray)
	{
		ATLASSERT(m_psa != NULL);
		ATLASSERT(ppArray != NULL);
		HRESULT hRes = E_POINTER;
		if (ppArray != NULL)
			hRes = SafeArrayCopy(m_psa, ppArray);
		return hRes;
	}
	HRESULT Create(ULONG ulCount = 0, LONG lLBound = 0)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		return Create(&bound);
	}
	HRESULT Create(const SAFEARRAYBOUND *pBound, UINT uDims = 1)
	{
		ATLASSERT(m_psa == NULL);
		ATLASSERT(uDims > 0);
		HRESULT hRes = S_OK;
		m_psa = SafeArrayCreate(_vartype, uDims, const_cast<LPSAFEARRAYBOUND>(pBound));
		if (NULL == m_psa)
			hRes = E_OUTOFMEMORY;
		else
			hRes = Lock();
		return hRes;
	}
	HRESULT Destroy()
	{
		HRESULT hRes = S_OK;
		if (m_psa != NULL)
		{
			hRes = Unlock();
			if (SUCCEEDED(hRes))
			{
				hRes = SafeArrayDestroy(m_psa);
				if (SUCCEEDED(hRes))
					m_psa = NULL;
			}
		}
		return hRes;
	}
protected:
	HRESULT Lock()
	{
		ATLASSERT(m_psa != NULL);
		return SafeArrayLock(m_psa);
	}
	HRESULT Unlock()
	{
		ATLASSERT(m_psa != NULL);
		return SafeArrayUnlock(m_psa);
	}
public:
	LPSAFEARRAY m_psa;
};

template<>
HRESULT CComSafeArray<BSTR>::SetAt(LONG lIndex, const BSTR& strData, BOOL bCopy)
{
	ATLASSERT(strData != NULL);
	ATLASSERT(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());	

	BSTR strOrg = ((BSTR*)m_psa->pvData)[lIndex-lLBound];
	if (strOrg)
		::SysFreeString(strOrg);

	if (bCopy)
	{
		BSTR strTemp = ::SysAllocString(strData);
		if (NULL == strTemp)
			return E_OUTOFMEMORY;
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strTemp;
	}
	else
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strData;

	return S_OK;
}
template<>
HRESULT CComSafeArray<VARIANT>::SetAt(LONG lIndex, const VARIANT& varData, BOOL bCopy)
{
	ATLASSERT(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if (bCopy)
		return VariantCopyInd(&((VARIANT*)m_psa->pvData)[lIndex-lLBound], const_cast<LPVARIANT>(&varData));
	else
	{	
		VARIANT varOrg = ((VARIANT*)m_psa->pvData)[lIndex-lLBound];
		if (V_VT(&varOrg) != VT_EMPTY)
			::VariantClear(&varOrg);
		((VARIANT*)m_psa->pvData)[lIndex-lLBound] = varData;
		return S_OK;
	}
}
template<>
HRESULT CComSafeArray<LPUNKNOWN>::SetAt(LONG lIndex, const LPUNKNOWN& pUnk, BOOL bAddRef)
{
	ATLASSERT(pUnk != NULL);
	ATLASSERT(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());
	LPUNKNOWN pOrgUnk = ((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgUnk)
		pOrgUnk->Release();
	if (bAddRef)
		pUnk->AddRef();
	((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound] = pUnk;
	return S_OK;
}
template<>
HRESULT CComSafeArray<LPDISPATCH>::SetAt(LONG lIndex, const LPDISPATCH& pDisp, BOOL bAddRef)
{
	ATLASSERT(pDisp != NULL);
	ATLASSERT(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());
	LPDISPATCH pOrgDisp = ((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgDisp)
		pOrgDisp->Release();
	if (bAddRef)
		pDisp->AddRef();
	((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound] = pDisp;
	return S_OK;
}

}; //namespace ATL

#endif //__ATLSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlrx.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLRX_H__
#define __ATLRX_H__

#pragma once

#include <atlbase.h>
#include <atlcoll.h>
#include <mbstring.h>

#ifndef ATL_REGEXP_MIN_STACK
#define ATL_REGEXP_MIN_STACK 256
#endif

/* 
	Regular Expression Grammar

	R    - top level grammar rule
	RE   - regular expression
	AltE - Alternative expression
	E    - expression
	SE   - simple expression

	R -> RE
	     '^'RE		(matches begining of string)

	RE -> AltE RE
		  AltE


	AltE -> E
		    E '|' AltE
	E -> SE (RepeatOp '?'?)?
	SE -> Arg
		Group
		CharClass
		'\'Abbrev		(see below)
		'\'EscapedChar	(any character including reserved symbols)
		'\'Digit+    (group back reference)
		'!'   (not)
		'.'   (any char)
		'$'   (end of input)
		Symbol			(any non-reserved character)
	Arg -> '{'RE'}'
	Group -> '('RE')'
	CharClass -> '[' '^'? CharSet ']'
	CharSet -> CharItem+
	CharItem -> Char('-'Char)?
	RepeatOp ->  '*'
	             '+'
			     '?'
	Abbrev -> Abbreviation defined in CAtlRECharTraits
		Abbrev  Expansion					Meaning
			a	[a-zA-Z0-9]					alpha numeric
			b	[ \\t]*						white space (blank)
			c	[a-zA-Z]					alpha
			d	[0-9]						digit
			h	[0-9a-fA-F]					hex digit
			n	(\r|(\r?\n))				newline
			q	(\"[^\"]*\")|(\'[^\']*\')	quoted string
			w	[a-zA-Z]+					simple word
			z	[0-9]+						integer
*/

namespace ATL {

class CAtlRECharTraitsA
{
public:
	typedef char RECHARTYPE;

	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return (RECHARTYPE *) (sz+1);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return strncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _strnicmp(szLeft, szRight, nCount);
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		return _strlwr(sz);
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return strtol(sz, szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return isdigit(ch);
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		static const RECHARTYPE *s_szAbbrevs[] = 
		{
			"a[a-zA-Z0-9]",	// alpha numeric
			"b[ \\t]*",		// white space (blank)
			"c[a-zA-Z]",	// alpha
			"d[0-9]",		// digit
			"h[0-9a-fA-F]",	// hex digit
			"n(\r|(\r?\n))",	// newline
			"q(\"[^\"]*\")|(\'[^\']*\')",	// quoted string
			"w[a-zA-Z]+",	// simple word
			"z[0-9]+",		// integer
			NULL
		};

		return s_szAbbrevs;
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return TRUE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return int(strlen(sz));
	}
};

class CAtlRECharTraitsW
{
public:
	typedef WCHAR RECHARTYPE;

	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return (RECHARTYPE *) (sz+1);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return wcsncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _wcsnicmp(szLeft, szRight, nCount);
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		return _wcslwr(sz);
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return wcstol(sz, szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return iswdigit(ch);
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		static const RECHARTYPE *s_szAbbrevs[] = 
		{
			L"a[a-zA-Z0-9]",	// alpha numeric
			L"b[ \\t]*",		// white space (blank)
			L"c[a-zA-Z]",	// alpha
			L"d[0-9]",		// digit
			L"h[0-9a-fA-F]",	// hex digit
			L"n(\r|(\r?\n))",	// newline
			L"q(\"[^\"]*\")|(\'[^\']*\')",	// quoted string
			L"w[a-zA-Z]+",	// simple word
			L"z[0-9]+",		// integer
			NULL
		};

		return s_szAbbrevs;
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return FALSE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return int(wcslen(sz)*sizeof(WCHAR));
	}
};

class CAtlRECharTraitsMB
{
public:
	typedef unsigned char RECHARTYPE;

	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return _mbsinc(sz);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _mbsncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _mbsnicmp(szLeft, szRight, nCount);
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		return _mbslwr(sz);
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return strtol((const char *) sz, (char **) szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return _ismbcdigit((unsigned int) ch);
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		return reinterpret_cast<const RECHARTYPE **>(CAtlRECharTraitsA::GetAbbrevs());
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return FALSE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return (int)strlen((const char *) sz);
	}
};

#ifndef _UNICODE
typedef CAtlRECharTraitsA CAtlRECharTraits;
#else	// _UNICODE
typedef CAtlRECharTraitsW CAtlRECharTraits;
#endif // !_UNICODE
// Note: If you want to use CAtlRECharTraitsMB you must pass it in
// as a template argument

template <class CharTraits=CAtlRECharTraits>
class CAtlRegExp;	// forward declaration

template <class CharTraits=CAtlRECharTraits>
class CAtlREMatchContext
{
public:
	friend CAtlRegExp<CharTraits>;
	typedef CharTraits::RECHARTYPE RECHAR;

	struct MatchGroup
	{
		const RECHAR *szStart;
		const RECHAR *szEnd;
	};

	UINT m_uNumGroups;

	MatchGroup m_Match;

	void GetMatch(int nIndex, const RECHAR **szStart, const RECHAR **szEnd)
	{
		ATLASSERT(szStart != NULL);
		ATLASSERT(szEnd != NULL);
		*szStart = m_Matches[nIndex].szStart;
		*szEnd = m_Matches[nIndex].szEnd;
	}

	void GetMatch(int nIndex, MatchGroup *pGroup)
	{
		ATLASSERT(pGroup != NULL);
		pGroup->szStart = m_Matches[nIndex].szStart;
		pGroup->szEnd = m_Matches[nIndex].szEnd;
	}

protected:
	CAutoVectorPtr<void *> m_Mem;
	CAutoVectorPtr<MatchGroup> m_Matches;
	CAtlArray<void *> m_stack;
	size_t m_nTos;


public:
	CAtlREMatchContext(size_t nInitStackSize=ATL_REGEXP_MIN_STACK)
	{
		m_uNumGroups = 0;
		m_nTos = 0;
		m_stack.SetCount(nInitStackSize);
		m_Match.szStart = NULL;
		m_Match.szEnd = NULL;
	}

	BOOL Initialize(UINT uRequiredMem, UINT uNumGroups) throw()
	{
		m_nTos = 0;

		m_uNumGroups = 0;
		m_Matches.Free();

		if (!m_Matches.Allocate(uNumGroups))
			return FALSE;

		m_uNumGroups = uNumGroups;

		m_Mem.Free();

		if (!m_Mem.Allocate(uRequiredMem))
			return FALSE;

		memset(m_Matches, 0x00, m_uNumGroups * sizeof(MatchGroup));
		return TRUE;
	}
	
protected:
	BOOL Push(void *p)
	{
		m_nTos++;
		if (m_stack.GetCount() <= (UINT) m_nTos)
		{
			if (!m_stack.SetCount((m_nTos+1)*2))
			{
				m_nTos--;
				return FALSE;
			}
		}
		m_stack[m_nTos] = p;
		return TRUE;
	}

	BOOL Push(size_t n)
	{
		return Push((void *) n);
	}

	void *Pop() throw()
	{
		if (m_nTos==0)
		{
			// stack underflow
			// this should never happen at match time.
			// (the parsing succeeded when it shouldn't have)
			ATLASSERT(FALSE);
			return NULL;
		}
		void *p = m_stack[m_nTos];
		m_nTos--;
		return p;
	}
};

enum REParseError {
	REPARSE_ERROR_OK = 0,				// No error occurred
	REPARSE_ERROR_OUTOFMEMORY,			// Out of memory
	REPARSE_ERROR_BRACE_EXPECTED,		// A closing brace was expected
	REPARSE_ERROR_PAREN_EXPECTED,		// A closing parenthesis was expected
	REPARSE_ERROR_BRACKET_EXPECTED,		// A closing bracket was expected
	REPARSE_ERROR_UNEXPECTED,			// An unspecified fatal error occurred
	REPARSE_ERROR_EMPTY_RANGE,			// A range expression was empty
	REPARSE_ERROR_INVALID_GROUP,		// A backreference was made to a group
										// that did not exist
	REPARSE_ERROR_INVALID_RANGE,		// An invalid range was specified
};

template <class CharTraits=CAtlRECharTraits>
class CAtlRegExp
{
public:
	CAtlRegExp() throw()
	{
		m_uNumGroups = 0;
		m_uRequiredMem = 0;
		m_bCaseSensitive = TRUE;
		m_LastError = REPARSE_ERROR_OK;
	}

	typedef CharTraits::RECHARTYPE RECHAR;

	// CAtlRegExp::Parse
	// Parses the regular expression
	// returns REPARSE_ERROR_OK if successful, an REParseError otherwise
	REParseError Parse(const RECHAR *szRE, BOOL bCaseSensitive=TRUE)
	{
		ATLASSERT(szRE);
		
		Reset();
		
		m_bCaseSensitive = bCaseSensitive;

		const RECHAR *szInput = szRE;

		if (!bCaseSensitive)
		{
			// copy the string
			int nSize = CharTraits::ByteLen(szRE)+sizeof(RECHAR);
			szInput = (const RECHAR *) malloc(nSize);
			if (!szInput)
				return REPARSE_ERROR_OUTOFMEMORY;
			
			memcpy((char *) szInput, szRE, nSize);

			CharTraits::Strlwr( const_cast<RECHAR *>(szInput));
		}
		const RECHAR *sz = szInput;

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return REPARSE_ERROR_OUTOFMEMORY;

		if (*sz == '^')
		{
			if (AddInstruction(RE_FAIL) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
			sz++;
		}
		else
		{
			if (AddInstruction(RE_ADVANCE) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
		}

		ParseRE(&sz);
		if (!GetLastParseError())
		{
			GetInstruction(nCall).call.nTarget = 2;

			if (AddInstruction(RE_MATCH) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
		}
		
		if (szInput != szRE)
			free((void *) szInput);

		return GetLastParseError();
	}

	BOOL Match(const RECHAR *szIn, CAtlREMatchContext<CharTraits> *pContext, const RECHAR **ppszEnd=NULL)
	{
		ATLASSERT(szIn);
		ATLASSERT(pContext);
		
		if (!szIn || !pContext)
			return FALSE;

		if (ppszEnd)
			*ppszEnd = NULL;

		const RECHAR *szInput = szIn;
		
		if (!m_bCaseSensitive)
		{
			int nSize = CharTraits::ByteLen(szIn)+sizeof(RECHAR);
			szInput = (const RECHAR *) malloc(nSize);
			if (!szInput)
				return FALSE;
			
			memcpy((char *) szInput, szIn, nSize);
			CharTraits::Strlwr((RECHAR *) szInput);
		}

		if (!pContext->Initialize(m_uRequiredMem, m_uNumGroups))
		{
			if (szInput != szIn)
				free((void *) szInput);
			return FALSE;
		}

		size_t ip = 0;

		const RECHAR *sz = szInput;
		const RECHAR *szCurrInput = szInput;
		
		while (1)
		{
			if (ip == 0)
				pContext->m_Match.szStart = sz;

			switch (GetInstruction(ip).type)
 			{
			case RE_NOP:
				ip++;
				break;

			case RE_SYMBOL:
				if (GetInstruction(ip).symbol.nSymbol == (unsigned char)*sz)
				{
					sz = CharTraits::Next(sz);
					ip++;
				}
				else
				{
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_ANY:
				if (*sz)
				{
					sz = CharTraits::Next(sz);
					ip++;
				}
				else
				{
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_GROUP_START:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szStart = sz;
				ip++;
				break;

			case RE_GROUP_END:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szEnd = sz;
				ip++;
				break;

			case RE_GROUP_RESET:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szStart = NULL;;
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szEnd = NULL;;
				ip++;
				break;

			case RE_PUSH_CHARPOS:
				pContext->Push((void *) sz);
				ip++;
				break;

			case RE_POP_CHARPOS:
				sz = (RECHAR *) pContext->Pop();
				ip++;
				break;

			case RE_CALL:
				pContext->Push(ip+1);
				ip = GetInstruction(ip).call.nTarget;
				break;

			case RE_JMP:
				ip = GetInstruction(ip).jmp.nTarget;
				break;

			case RE_RETURN:
				ip = (size_t) pContext->Pop();
				break;

			case RE_PUSH_MEMORY:
				pContext->Push((void *) (pContext->m_Mem[GetInstruction(ip).memory.nIndex]));
				ip++;
				break;

			case RE_POP_MEMORY:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = pContext->Pop();
				ip++;
				break;

			case RE_STORE_CHARPOS:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = (void *) sz;
				ip++;
				break;

			case RE_GET_CHARPOS:
				sz = (RECHAR *) pContext->m_Mem[GetInstruction(ip).memory.nIndex];
				ip++;
				break;

			case RE_STORE_STACKPOS:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = (void *) pContext->m_nTos;
				ip++;
				break;

			case RE_GET_STACKPOS:
				pContext->m_nTos = (size_t) pContext->m_Mem[GetInstruction(ip).memory.nIndex];
				ip++;
				break;

			case RE_RET_NOMATCH:
				if (sz == (RECHAR *) pContext->m_Mem[GetInstruction(ip).memory.nIndex])
				{
					// do a return
					ip = (size_t) pContext->Pop();
				}
				else
					ip++;
				break;

			case RE_ADVANCE:
				sz = CharTraits::Next(szCurrInput);
				szCurrInput = sz;
				if (*sz == '\0')
					goto Error;
				ip = 0;
				pContext->m_nTos = 0;
				break;

			case RE_FAIL:
				goto Error;
		
			case RE_RANGE:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					unsigned char *pBits = (unsigned char *) (&m_Instructions[ip]+1);
					size_t u = (size_t) *sz;
					if (pBits[u >> 3] & 1 << (u & 0x7))
					{
						ip += InstructionsPerRangeBitField();
						ip++;
						sz = CharTraits::Next(sz);
					}
					else
					{
						ip = (size_t) pContext->Pop();
					}
				}
				break;

			case RE_NOTRANGE:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					unsigned char *pBits = (unsigned char *) (&m_Instructions[ip]+1);
					size_t u = (size_t) * ((unsigned char *) sz);
					if (pBits[u >> 3] & 1 << (u & 0x7))
					{
						ip = (size_t) pContext->Pop();
					}
					else
					{
						ip += InstructionsPerRangeBitField();
						ip++;
						sz = CharTraits::Next(sz);
					}
				}
				break;

			case RE_RANGE_EX:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					BOOL bMatch = FALSE;
					size_t inEnd = GetInstruction(ip).range.nTarget;
					ip++;

					while (ip < inEnd)
					{						
						if ((unsigned char)*sz >= GetInstruction(ip).memory.nIndex && 
							(unsigned char)*sz <= GetInstruction(ip+1).memory.nIndex)
						{
							// if we match, we jump to the end
							sz = CharTraits::Next(sz);
							ip = inEnd;
							bMatch = TRUE;
						}
						else
						{
							ip += 2;
						}
					}
					if (!bMatch)
					{
						ip = (size_t) pContext->Pop();
					}
				}
				break;

			case RE_NOTRANGE_EX:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					BOOL bMatch = TRUE;
					size_t inEnd = GetInstruction(ip).range.nTarget;
					ip++;

					while (ip < inEnd)
					{
						if ((unsigned char)*sz >= GetInstruction(ip).memory.nIndex && 
							(unsigned char)*sz <= GetInstruction(ip+1).memory.nIndex)
						{
							ip = (size_t) pContext->Pop();
							bMatch = FALSE;
							break;
						}
						else
						{
							// if we match, we jump to the end
							ip += 2;
						}
					}
					if (bMatch)
						sz = CharTraits::Next(sz);
				}
				break;

			case RE_PREVIOUS:
				{
					BOOL bMatch = FALSE;
					if (m_bCaseSensitive)
					{
						bMatch = !CharTraits::Strncmp(sz, pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart,
							pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart);
					}
					else
					{
						bMatch = !CharTraits::Strnicmp(sz, pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart,
							pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart);
					}
					if (bMatch)
					{
						sz += pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart;
						ip++;
						break;
					}
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_MATCH:
				pContext->m_Match.szEnd = sz;
				if (!m_bCaseSensitive)
					FixupMatchContext(pContext, szIn, szInput);
				if (ppszEnd)
					*ppszEnd = szIn + (sz - szInput);
				if (szInput != szIn)
					free((void *) szInput);
				return TRUE;
				break;

			default:
				ATLASSERT(FALSE);
				break;
			}
		}

		ATLASSERT(FALSE);
Error:
		pContext->m_Match.szEnd = sz;
		if (!m_bCaseSensitive)
			FixupMatchContext(pContext, szIn, szInput);
		if (ppszEnd)
			*ppszEnd = szIn + (sz - szInput);
		if (szInput != szIn)
			free((void *) szInput);
		return FALSE;
	}

#ifdef ATL_REGEXP_DUMP
	void Dump()
	{
		size_t ip = 0;

		while (1)
		{
			printf("%08x ", ip);
			switch (GetInstruction(ip).type)
			{
			case RE_NOP:
				printf("NOP\n");
				ip++;
				break;

			case RE_SYMBOL:
				printf("Symbol %c\n", GetInstruction(ip).symbol.nSymbol);
				ip++;
				break;

			case RE_ANY:
				printf("Any\n");
				ip++;
				break;

			case RE_RANGE:
				printf("Range\n");
				ip++;
				ip += InstructionsPerRangeBitField();
				break;

			case RE_NOTRANGE:
				printf("NOT Range\n");
				ip++;
				ip += InstructionsPerRangeBitField();
				break;

			case RE_RANGE_EX:
				printf("RangeEx %08x\n", GetInstruction(ip).range.nTarget);
				ip++;
				break;

			case RE_NOTRANGE_EX:
				printf("NotRangeEx %08x\n", GetInstruction(ip).range.nTarget);
				ip++;
				break;

			case RE_GROUP_START:
				printf("Start group %d\n", GetInstruction(ip).group.nGroup);
				ip++;
				break;

			case RE_GROUP_END:
				printf("Group end %d\n", GetInstruction(ip).group.nGroup);
				ip++;
				break;

			case RE_GROUP_RESET:
				printf("Group reset %d\n", GetInstruction(ip).group.nGroup);
				ip++;
				break;

			case RE_PUSH_CHARPOS:
				printf("Push char pos\n");
				ip++;
				break;

			case RE_POP_CHARPOS:
				printf("Pop char pos\n");
				ip++;
				break;

			case RE_STORE_CHARPOS:
				printf("Store char pos %d\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_GET_CHARPOS:
				printf("Get char pos %d\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_STORE_STACKPOS:
				printf("Store stack pos %d\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_GET_STACKPOS:
				printf("Get stack pos %d\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_CALL:
				printf("Call %08x\n", GetInstruction(ip).call.nTarget);
				ip++;
				break;

			case RE_JMP:
				printf("Jump %08x\n", GetInstruction(ip).jmp.nTarget);
				ip++;
				break;

			case RE_RETURN:
				printf("return\n");
				ip++;
				break;

			case RE_PUSH_MEMORY:
				printf("Push memory %08x\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_POP_MEMORY:
				printf("Pop memory %08x\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_RET_NOMATCH:
				printf("Return no match %08x\n", GetInstruction(ip).memory.nIndex);
				ip++;
				break;

			case RE_MATCH:
				printf("END\n");
				return;
				break;

			case RE_ADVANCE:
				printf("ADVANCE\n");
				ip++;
				break;

			case RE_FAIL:
				printf("FAIL\n");
				ip++;
				break;

			case RE_PREVIOUS:
				printf("Prev %d\n", GetInstruction(ip).prev.nGroup);
				ip++;
				break;

			default:
				printf("????\n");
				ip++;
				break;
			}
		}
	}
#endif

protected:
	REParseError m_LastError;

	REParseError GetLastParseError() throw()
	{
		return m_LastError;
	}

	void SetLastParseError(REParseError Error) throw()
	{
		m_LastError = Error;
	}
	// CAtlRegExp::Reset
	// Removes all instructions to allow reparsing into the same instance
	void Reset() throw()
	{
		m_Instructions.RemoveAll();
		m_uRequiredMem = 0;
		m_bCaseSensitive = TRUE;
		m_uNumGroups = 0;
	}


	enum REInstructionType { 
		RE_NOP,
		RE_GROUP_START,
		RE_GROUP_END, 
		RE_GROUP_RESET,
		RE_SYMBOL,
		RE_ANY,
		RE_RANGE,
		RE_NOTRANGE,
		RE_RANGE_EX,
		RE_NOTRANGE_EX,
		RE_PLUS,
		RE_NG_PLUS,
		RE_QUESTION,
		RE_NG_QUESTION,
		RE_JMP,
		RE_PUSH_CHARPOS,
		RE_POP_CHARPOS,
		RE_CALL,
		RE_RETURN,
		RE_STAR_BEGIN,
		RE_NG_STAR_BEGIN, 
		RE_PUSH_MEMORY,
		RE_POP_MEMORY,
		RE_STORE_CHARPOS,
		RE_STORE_STACKPOS,
		RE_GET_CHARPOS,
		RE_GET_STACKPOS,
		RE_RET_NOMATCH,
		RE_PREVIOUS,
		RE_FAIL,
		RE_ADVANCE,
		RE_MATCH,
	};

	struct INSTRUCTION_SYMBOL
	{
		size_t nSymbol;
	};

	struct INSTRUCTION_JMP
	{
		size_t nTarget;	
	};

	struct INSTRUCTION_GROUP
	{
		size_t nGroup;
	};

	struct INSTRUCTION_CALL
	{
		size_t nTarget;
	};

	struct INSTRUCTION_MEMORY
	{
		size_t nIndex;
	};

	struct INSTRUCTION_PREVIOUS
	{
		size_t nGroup;
	};

	struct INSTRUCTION_RANGE_EX
	{
		size_t nTarget;
	};

	struct INSTRUCTION
	{
		REInstructionType type;
		union
		{
			INSTRUCTION_SYMBOL symbol;
			INSTRUCTION_JMP jmp;
			INSTRUCTION_GROUP group;
			INSTRUCTION_CALL call;
			INSTRUCTION_MEMORY memory;
			INSTRUCTION_PREVIOUS prev;
			INSTRUCTION_RANGE_EX range;
		};
	};

	inline int InstructionsPerRangeBitField() throw()
	{
		return (256/8) / sizeof(INSTRUCTION) + ((256/8) % sizeof(INSTRUCTION) ? 1 : 0);
	}

	CAtlArray<INSTRUCTION> m_Instructions;

	UINT m_uNumGroups;
	UINT m_uRequiredMem;
	BOOL m_bCaseSensitive;


	// class used internally to restore
	// parsing state when unwinding
	class CParseState
	{
	public:
		int m_nNumInstructions;
		UINT m_uNumGroups;
		UINT m_uRequiredMem;

		CParseState(CAtlRegExp *pRegExp) throw()
		{
			m_nNumInstructions = (int) pRegExp->m_Instructions.GetCount();
			m_uNumGroups = pRegExp->m_uNumGroups;
			m_uRequiredMem = pRegExp->m_uRequiredMem;
		}

		void Restore(CAtlRegExp *pRegExp)
		{
			pRegExp->m_Instructions.SetCount(m_nNumInstructions);
			pRegExp->m_uNumGroups = m_uNumGroups;
			pRegExp->m_uRequiredMem = m_uRequiredMem;
		}
	};

	int AddInstruction(REInstructionType type)
	{
		if (!m_Instructions.SetCount(m_Instructions.GetCount()+1))
		{
			SetLastParseError(REPARSE_ERROR_OUTOFMEMORY);
			return -1;
		}

		m_Instructions[m_Instructions.GetCount()-1].type = type;
		return (int) m_Instructions.GetCount()-1;
	}

	BOOL PeekToken(const RECHAR **ppszRE, int ch) throw()
	{
		if (**ppszRE != ch)
			return FALSE;
		return TRUE;
	}

	BOOL MatchToken(const RECHAR **ppszRE, int ch) throw()
	{
		if (!PeekToken(ppszRE, ch))
			return FALSE;
		*ppszRE = CharTraits::Next(*ppszRE);
		return TRUE;
	}

	INSTRUCTION &GetInstruction(size_t nIndex) throw()
	{
		return m_Instructions[nIndex];
	}

	// ParseArg: parse grammar rule Arg
	int ParseArg(const RECHAR **ppszRE)
	{
		int p = AddInstruction(RE_GROUP_START);
		if (p < 0)
			return -1;
		GetInstruction(p).group.nGroup = m_uNumGroups++;

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;
			
		int nReset = AddInstruction(RE_GROUP_RESET);
		if (nReset < 0)
			return -1;
			
		if (AddInstruction(RE_RETURN) < 0)
			return -1;

		int nAlt = ParseRE(ppszRE);
		if (nAlt < 0)
		{
			if (GetLastParseError())
				return -1;

			if (!PeekToken(ppszRE, '}'))
			{
				SetLastParseError(REPARSE_ERROR_BRACE_EXPECTED);
				return -1;
			}

			// in the case of an empty group, we add a nop
			nAlt = AddInstruction(RE_NOP);
			if (nAlt < 0)
				return -1;
		}

		GetInstruction(nCall).call.nTarget = nAlt;
		GetInstruction(nReset).group.nGroup = GetInstruction(p).group.nGroup;

		if (!MatchToken(ppszRE, '}'))
		{
			SetLastParseError(REPARSE_ERROR_BRACE_EXPECTED);
			return -1;
		}

		int nEnd = AddInstruction(RE_GROUP_END);
		if (nEnd < 0)
			return -1;
		GetInstruction(nEnd).group.nGroup = GetInstruction(p).group.nGroup;
		return p;
	}

	// ParseGroup: parse grammar rule Group
	int ParseGroup(const RECHAR **ppszRE)
	{
		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;
			
		if (AddInstruction(RE_RETURN) < 0)
			return -1;

		int nAlt = ParseRE(ppszRE);
		if (nAlt < 0)
		{
			if (GetLastParseError())
				return -1;

			if (!PeekToken(ppszRE, ')'))
			{
				SetLastParseError(REPARSE_ERROR_PAREN_EXPECTED);
				return -1;
			}

			// in the case of an empty group, we add a nop
			nAlt = AddInstruction(RE_NOP);
			if (nAlt < 0)
				return -1;
		}

		GetInstruction(nCall).call.nTarget = nAlt;

		if (!MatchToken(ppszRE, ')'))
		{
			SetLastParseError(REPARSE_ERROR_PAREN_EXPECTED);
			return -1;
		}

		return nCall;
	}

	RECHAR GetEscapedChar(RECHAR ch) throw()
	{
		if (ch == 't')
			return '\t';
		return ch;
	}

	// ParseCharItem: parse grammar rule CharItem
	int ParseCharItem(const RECHAR **ppszRE, RECHAR *pchStartChar, RECHAR *pchEndChar) throw()
	{
		if (**ppszRE == '\\')
		{
			*ppszRE = CharTraits::Next(*ppszRE);
			*pchStartChar = GetEscapedChar(**ppszRE);
		}
		else
			*pchStartChar = **ppszRE;
		*ppszRE = CharTraits::Next(*ppszRE);

		if (!MatchToken(ppszRE, '-'))
		{
			*pchEndChar = *pchStartChar;
			return 0;
		}

		// check for unterminated range
		if (!**ppszRE || PeekToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_BRACKET_EXPECTED);
			return -1;
		}

		*pchEndChar = **ppszRE;
		*ppszRE = CharTraits::Next(*ppszRE);

		if (*pchEndChar < *pchStartChar)
		{
			SetLastParseError(REPARSE_ERROR_INVALID_RANGE);
			return -1;
		}
		return 0;
	}

	int AddInstructions(int nNumInstructions)
	{
		size_t nCurr = m_Instructions.GetCount();
		if (!m_Instructions.SetCount(nCurr+nNumInstructions))
		{
			SetLastParseError(REPARSE_ERROR_OUTOFMEMORY);
			return -1;
		}
		return (int) nCurr;
	}

	// ParseCharSet: parse grammar rule CharSet
	int ParseCharSet(const RECHAR **ppszRE, BOOL bNot)
	{
		int p = -1;
		
		unsigned char *pBits = NULL;
		
		if (CharTraits::UseBitFieldForRange())
		{
			// we use a bit field to represent the characters
			// a 1 bit means match against the character
			// the last 5 bits are used as an index into 
			// the byte array, and the first 3 bits
			// are used to index into the selected byte

			p = AddInstruction(bNot ? RE_NOTRANGE : RE_RANGE);
			if (p < 0)
				return -1;

			// add the required space to hold the character
			// set.  We use one bit per character for ansi
			if (AddInstructions(InstructionsPerRangeBitField()) < 0)
				return -1;

			pBits = (unsigned char *) (&m_Instructions[p+1]);
			memset(pBits, 0x00, 256/8);
		}
		else
		{
			p = AddInstruction(bNot ? RE_NOTRANGE_EX : RE_RANGE_EX);
			if (p < 0)
				return -1;
		}

		RECHAR chStart;
		RECHAR chEnd;

		while (**ppszRE && **ppszRE != ']')
		{
			if (ParseCharItem(ppszRE, &chStart, &chEnd))
				return -1;

			if (CharTraits::UseBitFieldForRange())
			{
				for (int i=chStart; i<=chEnd; i++)
					pBits[i >> 3] |= 1 << (i & 0x7);
			}
			else
			{
				int nStart = AddInstruction(RE_NOP);
				if (nStart < 0)
					return -1;
					
				int nEnd = AddInstruction(RE_NOP);
				if (nEnd < 0)
					return -1;

				GetInstruction(nStart).memory.nIndex = (int) chStart;
				GetInstruction(nEnd).memory.nIndex = (int) chEnd;
			}
		}

		if (!CharTraits::UseBitFieldForRange())
			GetInstruction(p).range.nTarget = m_Instructions.GetCount();

		return p;
	}

	// ParseCharClass: parse grammar rule CharClass
	int ParseCharClass(const RECHAR **ppszRE)
	{
		if (MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_EMPTY_RANGE);
			return -1;
		}

		BOOL bNot = FALSE;
		if (MatchToken(ppszRE, '^'))
			bNot = TRUE;

		if (MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_EMPTY_RANGE);
			return -1;
		}

		int p = ParseCharSet(ppszRE, bNot);
		if (p < 0)
			return p;
		if (!MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_BRACKET_EXPECTED);
			return -1;
		}

		return p;
	}

	int AddMemInstruction(REInstructionType type)
	{
		int p = AddInstruction(type);
		if (p < 0)
			return p;
		GetInstruction(p).memory.nIndex = m_uRequiredMem++;
		return p;
	}

	// helper for parsing !SE
	int ParseNot(const RECHAR **ppszRE)
	{
		int nStoreCP = AddMemInstruction(RE_STORE_CHARPOS);
		int nStoreSP = AddMemInstruction(RE_STORE_STACKPOS);

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;

		int nGetCP = AddInstruction(RE_GET_CHARPOS);
		if (nGetCP < 0)
			return -1;
		GetInstruction(nGetCP).memory.nIndex = GetInstruction(nStoreCP).memory.nIndex;

		int nGetSP = AddInstruction(RE_GET_STACKPOS);
		if (nGetSP < 0)
			return -1;
		GetInstruction(nGetSP).memory.nIndex = GetInstruction(nStoreSP).memory.nIndex;

		int nJmp = AddInstruction(RE_JMP);
		if (nJmp < 0)
			return -1;
		
		int nSE = ParseSE(ppszRE);
		if (nSE < 0)
			return nSE;

		// patch the call
		GetInstruction(nCall).call.nTarget = nSE;

		int nGetCP1 = AddInstruction(RE_GET_CHARPOS);
		if (nGetCP1 < 0)
			return -1;
		GetInstruction(nGetCP1).memory.nIndex = GetInstruction(nStoreCP).memory.nIndex;

		int nGetSP1 = AddInstruction(RE_GET_STACKPOS);
		if (nGetSP1 < 0)
			return -1;
		GetInstruction(nGetSP1).memory.nIndex = GetInstruction(nStoreSP).memory.nIndex;

		int nRet = AddInstruction(RE_RETURN);
		if (nRet < 0)
			return -1;

		GetInstruction(nJmp).jmp.nTarget = nRet+1;

		return nStoreCP;
	}

	// ParseAbbrev: parse grammar rule Abbrev
	int ParseAbbrev(const RECHAR **ppszRE)
	{
		const RECHAR **szAbbrevs = CharTraits::GetAbbrevs();

		while (*szAbbrevs)
		{
			if (**ppszRE == **szAbbrevs)
			{
				const RECHAR *szAbbrev = (*szAbbrevs)+1;
				int p = ParseE(&szAbbrev);
				if (p < 0)
				{
					SetLastParseError(REPARSE_ERROR_UNEXPECTED);
					return p;
				}
				*ppszRE = CharTraits::Next(*ppszRE);
				return p;
			}
			szAbbrevs++;
		}
		return -1;
	}

	// ParseSE: parse grammar rule SE (simple expression)
	int ParseSE(const RECHAR **ppszRE)
	{

		if (MatchToken(ppszRE, '{'))
			return ParseArg(ppszRE);
		if (MatchToken(ppszRE, '('))
			return ParseGroup(ppszRE);
		if (MatchToken(ppszRE, '['))
			return ParseCharClass(ppszRE);

		if (MatchToken(ppszRE, '\\'))
		{
			if (!CharTraits::Isdigit(**ppszRE))
			{
				// check for abbreviations
				int p;
				p = ParseAbbrev(ppszRE);
				if (p >= 0)
					return p;

				if (GetLastParseError())
					return -1;

				// escaped char
				p = AddInstruction(RE_SYMBOL);
				if (p < 0)
					return -1;
				GetInstruction(p).symbol.nSymbol = (int) **ppszRE;
				*ppszRE = CharTraits::Next(*ppszRE);
				return p;
			}
			// previous match
			int nPrev = AddInstruction(RE_PREVIOUS);
			if (nPrev < 0)
				return -1;

			UINT uValue = (UINT) CharTraits::Strtol(*ppszRE, (RECHAR **) ppszRE, 10);
			if (uValue >= m_uNumGroups)
			{
				SetLastParseError(REPARSE_ERROR_INVALID_GROUP);
				return -1;
			}
			GetInstruction(nPrev).prev.nGroup = (size_t) uValue;
			return nPrev;
		}
		
		if (MatchToken(ppszRE, '!'))
			return ParseNot(ppszRE);

		if (**ppszRE == '}' || **ppszRE == ']' || **ppszRE == ')')
		{
			return -1;
		}

		if (**ppszRE == '\0')
		{
			return -1;
		}

		int p;
		if (**ppszRE == '.')
		{
			p = AddInstruction(RE_ANY);
			if (p < 0)
				return -1;
		}
		else if (**ppszRE == '$' && (*ppszRE)[1] == '\0')
		{
			p = AddInstruction(RE_SYMBOL);
			if (p < 0)
				return -1;
			GetInstruction(p).symbol.nSymbol = 0;
		}
		else
		{
			p = AddInstruction(RE_SYMBOL);
			if (p < 0)
				return -1;
			GetInstruction(p).symbol.nSymbol = (int) **ppszRE;
		}
		*ppszRE = CharTraits::Next(*ppszRE);
		return p;
	}

	// ParseE: parse grammar rule E (expression)
	int ParseE(const RECHAR **ppszRE)
	{
		CParseState ParseState(this);
		const RECHAR *sz = *ppszRE;
		
		int nSE;

		int nFirst = ParseSE(ppszRE);
		if (nFirst < 0)
			return nFirst;

		REInstructionType type = RE_MATCH;

		if (MatchToken(ppszRE, '*'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_STAR_BEGIN;
			else
				type = RE_STAR_BEGIN;

			
		else if (MatchToken(ppszRE, '+'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_PLUS;
			else
				type = RE_PLUS;
			
		else if (MatchToken(ppszRE, '?'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_QUESTION;
			else
				type = RE_QUESTION;


		if (type == RE_MATCH)
			return nFirst;

		if (type == RE_STAR_BEGIN || type == RE_QUESTION|| type == RE_NG_STAR_BEGIN || type == RE_NG_QUESTION)
		{
			ParseState.Restore(this);
		}
		*ppszRE = sz;
		
		int nE;

		if (type == RE_NG_STAR_BEGIN || type == RE_NG_PLUS || type == RE_NG_QUESTION) // Non-Greedy
		{			
			int nCall = AddInstruction(RE_CALL);
			if (nCall < 0)
				return -1;

			nSE = ParseSE(ppszRE);
			if (nSE < 0)
				return nSE;

			*ppszRE = CharTraits::Next(*ppszRE);
			*ppszRE = CharTraits::Next(*ppszRE);

			if (type == RE_NG_STAR_BEGIN || type == RE_NG_PLUS)
			{
				int nJmp = AddInstruction(RE_JMP);
				if (nJmp < 0)
					return -1;
				GetInstruction(nCall).call.nTarget = nJmp+1;
				GetInstruction(nJmp).jmp.nTarget = nCall;
			}
			else
				GetInstruction(nCall).call.nTarget = nSE+1;

			if (type == RE_NG_PLUS)
				nE = nFirst;
			else
				nE = nCall;
		}
		else // Greedy
		{

			int nPushMem = AddInstruction(RE_PUSH_MEMORY);
			if (nPushMem < 0)
				return -1;
				
			int nStore = AddInstruction(RE_STORE_CHARPOS);
			if (nStore < 0)
				return -1;
				
			if (AddInstruction(RE_PUSH_CHARPOS) < 0)
				return -1;
				
			int nCall = AddInstruction(RE_CALL);
			if (nCall < 0)
				return -1;
				
			if (AddInstruction(RE_POP_CHARPOS) < 0)
				return -1;
				
			int nPopMem = AddInstruction(RE_POP_MEMORY);
			if (nPopMem < 0)
				return -1;
				
			int nJmp = AddInstruction(RE_JMP);
			if (nJmp < 0)
				return -1;

			GetInstruction(nPushMem).memory.nIndex = m_uRequiredMem++;
			GetInstruction(nStore).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;
			GetInstruction(nCall).call.nTarget = nJmp+1;
			GetInstruction(nPopMem).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;

			nSE = ParseSE(ppszRE);
			if (nSE < 0)
				return nSE;

			*ppszRE = CharTraits::Next(*ppszRE);


			int nRetNoMatch = AddInstruction(RE_RET_NOMATCH);
			if (nRetNoMatch < 0)
				return -1;
				
			int nStore1 = AddInstruction(RE_STORE_CHARPOS);
			if (nStore1 < 0)
				return -1;

			GetInstruction(nRetNoMatch).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;
			GetInstruction(nStore1).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;

			if (type != RE_QUESTION)
			{
				int nJmp1 = AddInstruction(RE_JMP);
				if (nJmp1 < 0)
					return -1;
				GetInstruction(nJmp1).jmp.nTarget = nPushMem;
			}

			GetInstruction(nJmp).jmp.nTarget = m_Instructions.GetCount();
			if (type == RE_PLUS)
				nE = nFirst;
			else
				nE = nPushMem;
		}

		return nE;
	}


	// ParseAltE: parse grammar rule AltE
	int ParseAltE(const RECHAR **ppszRE)
	{
		const RECHAR *sz = *ppszRE;
		CParseState ParseState(this);

		int nPush = AddInstruction(RE_PUSH_CHARPOS);
		if (nPush < 0)
			return -1;
			
		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;
			
		GetInstruction(nCall).call.nTarget = nPush+4;
		if (AddInstruction(RE_POP_CHARPOS) < 0)
			return -1;
			
		int nJmpNext = AddInstruction(RE_JMP);
		if (nJmpNext < 0)
			return -1;

		int nE = ParseE(ppszRE);
		if (nE < 0)
		{
			if (GetLastParseError())
				return -1;
			ParseState.Restore(this);
			return nE;
		}

		int nJmpEnd = AddInstruction(RE_JMP);
		if (nJmpEnd < 0)
			return -1;
			
		GetInstruction(nJmpNext).jmp.nTarget = nJmpEnd+1;

		if (!MatchToken(ppszRE, '|'))
		{
			ParseState.Restore(this);
			*ppszRE = sz;

			return ParseE(ppszRE);
		}

		int nAltE = ParseAltE(ppszRE);
		GetInstruction(nJmpEnd).jmp.nTarget = m_Instructions.GetCount();
		GetInstruction(nJmpNext).jmp.nTarget = nAltE;
		if (nAltE < 0)
		{
			if (GetLastParseError())
				return -1;
			ParseState.Restore(this);
			return nAltE;
		}
		return nPush;
	}

	// ParseRE: parse grammar rule RE (regular expression)
	int ParseRE(const RECHAR **ppszRE)
	{
		if (**ppszRE == '\0')
			return -1;

		int p = ParseAltE(ppszRE);
		if (p < 0)
			return p;

		ParseRE(ppszRE);
		if (GetLastParseError())
			return -1;
		return p;
	}

	void FixupMatchContext(CAtlREMatchContext<CharTraits> *pContext, const RECHAR *szOrig, const RECHAR *szNew) throw()
	{
		ATLASSERT(pContext);
		ATLASSERT(szOrig);
		ATLASSERT(szNew);
		
		pContext->m_Match.szStart = szOrig + (pContext->m_Match.szStart - szNew);
		pContext->m_Match.szEnd = szOrig + (pContext->m_Match.szEnd - szNew);
		for (UINT i=0; i<pContext->m_uNumGroups; i++)
		{
			pContext->m_Matches[i].szStart = szOrig + (pContext->m_Matches[i].szStart - szNew);
			pContext->m_Matches[i].szEnd = szOrig + (pContext->m_Matches[i].szEnd - szNew);
		}
	}
};

} // namespace ATL

#endif // __ATLRX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlscontext.inl ===
namespace ATL
{

inline void CIncludeServerContext::CrackTag()
{
	if (m_bTagCracked)
		return;

	LPCSTR szStencilBegin = m_szTagBegin;
	LPCSTR szStencilEnd = m_szTagEnd;
	LPCSTR szParamBegin = m_szTagBegin;
	LPCSTR szParamEnd = m_szTagEnd;

	while (*szParamBegin && *szParamBegin != '?' && *szParamBegin != '}')
		szParamBegin = CharNextExA(GetCodePage(), szParamBegin, 0);

	if (*szParamBegin=='?')
	{
		szStencilEnd = szParamBegin-1;
		szParamBegin = CharNextExA(GetCodePage(), szParamBegin, 0);
	}
	
	if (szParamBegin > szParamEnd)
		szParamBegin = szParamEnd + 1;

	CHAR szFileNameRelative[MAX_PATH];

	memcpy(szFileNameRelative, szStencilBegin, szStencilEnd-szStencilBegin+1);
	szFileNameRelative[szStencilEnd-szStencilBegin+1] = '\0';

	memcpy(m_szQueryString, szParamBegin, szParamEnd-szParamBegin+1);
	m_szQueryString[szParamEnd-szParamBegin+1] = '\0';

	if (!IsFullPathA(szFileNameRelative))
	{
		CHAR szTemp[MAX_PATH*2];
		strcpy(szTemp, GetBaseDir());
		strcat(szTemp, szFileNameRelative);
		PathCanonicalizeA(m_szFileName, szTemp);
	}
	else
	{
		strcpy(m_szFileName, szFileNameRelative);
	}

	m_bTagCracked = true;
}

inline WORD CIncludeServerContext::GetCodePage()
{
	if (m_pStencil)
		return m_pStencil->GetCodePage();
	return m_nCodePage;
}

inline LPCSTR CIncludeServerContext::GetBaseDir()
{
	if (m_pStencil)
		return m_pStencil->GetBaseDir();
	return m_szBaseDir;
}

} // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsecurity.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLSECURITY_H__
#define __ATLSECURITY_H__

#pragma once

#include <sddl.h>
#include <userenv.h>
#include <aclapi.h>
#include <atlcoll.h>
#include <atlstr.h>

namespace ATL
{
#pragma comment(lib, "userenv.lib")

class CSid
{

public:
	CSid();

	explicit CSid(LPCTSTR pszAccountName, LPCTSTR pszSystem = NULL);
	explicit CSid(const SID *pSid, LPCTSTR pszSystem = NULL);
	CSid(const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority, BYTE nSubAuthorityCount, ...);
	virtual ~CSid(){free(m_pSid);}

	CSid(const CSid &rhs);
	CSid &operator=(const CSid &rhs);

	CSid(const SID &rhs);
	CSid &operator=(const SID &rhs);

	typedef CSimpleArray<CSid> CSidArray;

	bool LoadAccount(LPCTSTR pszAccountName, LPCTSTR pszSystem = NULL);
	bool LoadAccount(const SID *pSid, LPCTSTR pszSystem = NULL);

	LPCTSTR AccountName() const;
	LPCTSTR Domain() const;
	LPCTSTR Sid() const;

	const SID *GetPSID() const {return m_pSid;}
	operator const SID *() const {return GetPSID();}
	SID_NAME_USE SidNameUse() const {return m_SidNameUse;}

	UINT GetLength() const
		{ATLASSERT(IsValid()); return ::GetLengthSid(m_pSid);}

	// SID functions
	bool operator==(const CSid &rhs) const
		{return 0 != ::EqualSid(m_pSid, rhs.m_pSid);}
	bool operator==(const SID &rhs) const
		{return 0 != ::EqualSid(m_pSid, const_cast<SID *>(&rhs));}

	bool EqualPrefix(const CSid &rhs) const
		{return 0 != ::EqualPrefixSid(m_pSid, rhs.m_pSid);}
	bool EqualPrefix(const SID &rhs) const
		{return 0 != ::EqualPrefixSid(m_pSid, const_cast<SID *>(&rhs));}

	const SID_IDENTIFIER_AUTHORITY *GetPSID_IDENTIFIER_AUTHORITY() const
		{ATLASSERT(IsValid()); return ::GetSidIdentifierAuthority(m_pSid);}
	DWORD GetSubAuthority(DWORD nSubAuthority) const
		{ATLASSERT(IsValid()); return *::GetSidSubAuthority(m_pSid, nSubAuthority);}
	UCHAR GetSubAuthorityCount() const
		{ATLASSERT(IsValid()); return *::GetSidSubAuthorityCount(m_pSid);}
	bool IsValid() const {return 0 != ::IsValidSid(m_pSid);}

private:
	void Copy(const SID &rhs);
	void Clear();
	void GetAccountNameAndDomain() const;

	SID *m_pSid;

	mutable SID_NAME_USE m_SidNameUse;
	mutable CString m_strAccountName;
	mutable CString m_strDomain;
	mutable CString m_strSid;

	CString m_strSystem;
};

// Well-known sids
namespace Sids
{
__declspec(selectany) extern const SID_IDENTIFIER_AUTHORITY
SecurityNullSidAuthority		= SECURITY_NULL_SID_AUTHORITY,
SecurityWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
SecurityLocalSidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
SecurityCreatorSidAuthority		= SECURITY_CREATOR_SID_AUTHORITY,
SecurityNonUniqueAuthority		= SECURITY_NON_UNIQUE_AUTHORITY,
SecurityNTAuthority				= SECURITY_NT_AUTHORITY;

// Universal
inline const CSid &Null()
{
	static const CSid sid(SecurityNullSidAuthority,	1, SECURITY_NULL_RID);
	return sid;
}
inline const CSid &World()
{
	static const CSid sid(SecurityWorldSidAuthority, 1, SECURITY_WORLD_RID);
	return sid;
}
inline const CSid &Local()
{
	static const CSid sid(SecurityLocalSidAuthority, 1, SECURITY_LOCAL_RID);
	return sid;
}
inline const CSid &CreatorOwner()
{
	static const CSid sid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_RID);
	return sid;
}
inline const CSid &CreatorGroup()
{
	static const CSid sid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_RID);
	return sid;
}
inline const CSid &CreatorOwnerServer()
{
	static const CSid sid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_SERVER_RID);
	return sid;
}
inline const CSid &CreatorGroupServer()
{
	static const CSid sid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_SERVER_RID);
	return sid;
}

// NT Authority
inline const CSid &Dialup()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_DIALUP_RID);
	return sid;
}
inline const CSid &Network()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_NETWORK_RID);
	return sid;
}
inline const CSid &Batch()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_BATCH_RID);
	return sid;
}
inline const CSid &Interactive()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_INTERACTIVE_RID);
	return sid;
}
inline const CSid &Service()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_SERVICE_RID);
	return sid;
}
inline const CSid &AnonymousLogon()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_ANONYMOUS_LOGON_RID);
	return sid;
}
inline const CSid &Proxy()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_PROXY_RID);
	return sid;
}
inline const CSid &ServerLogon()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_SERVER_LOGON_RID);
	return sid;
}
inline const CSid &Self()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_PRINCIPAL_SELF_RID);
	return sid;
}
inline const CSid &AuthenticatedUser()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_AUTHENTICATED_USER_RID);
	return sid;
}
inline const CSid &RestrictedCode()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_RESTRICTED_CODE_RID);
	return sid;
}
inline const CSid &TerminalServer()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_TERMINAL_SERVER_RID);
	return sid;
}
inline const CSid &System()
{
	static const CSid sid(SecurityNTAuthority, 1, SECURITY_LOCAL_SYSTEM_RID);
	return sid;
}

// NT Authority\BUILTIN
inline const CSid &Admins()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS);
	return sid;
}
inline const CSid &Users()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS);
	return sid;
}
inline const CSid &Guests()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS);
	return sid;
}
inline const CSid &PowerUsers()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS);
	return sid;
}
inline const CSid &AccountOps()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ACCOUNT_OPS);
	return sid;
}
inline const CSid &SystemOps()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS);
	return sid;
}
inline const CSid &PrintOps()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PRINT_OPS);
	return sid;
}
inline const CSid &BackupOps()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_BACKUP_OPS);
	return sid;
}
inline const CSid &Replicator()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_REPLICATOR);
	return sid;
}
inline const CSid &RasServers()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_RAS_SERVERS);
	return sid;
}
inline const CSid &PreW2KAccess()
{
	static const CSid sid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS);
	return sid;
}
} // namespace Sids

inline CSid::CSid()
	: m_pSid(NULL), m_SidNameUse(SidTypeInvalid)
{
}

inline CSid::CSid(LPCTSTR pszAccountName, LPCTSTR pszSystem)
	: m_pSid(NULL), m_SidNameUse(SidTypeInvalid)
{
	if(!LoadAccount(pszAccountName, pszSystem))
		AtlThrowLastWin32();
}

inline CSid::CSid(const SID *pSid, LPCTSTR pszSystem)
	: m_pSid(NULL), m_SidNameUse(SidTypeInvalid)
{
	if(!LoadAccount(pSid, pszSystem))
		AtlThrowLastWin32();
}

inline CSid::CSid(const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
				  BYTE nSubAuthorityCount, ...)
				  : m_pSid(NULL), m_SidNameUse(SidTypeInvalid)
{
	SID *pSid;

	ATLASSERT(nSubAuthorityCount);
	if(!nSubAuthorityCount)
		AtlThrow(E_INVALIDARG);

	pSid = static_cast<SID *>(_alloca(::GetSidLengthRequired(nSubAuthorityCount)));

	if(!::InitializeSid(pSid,
		const_cast<SID_IDENTIFIER_AUTHORITY *>(&IdentifierAuthority),
		nSubAuthorityCount))
	{
		AtlThrowLastWin32();
	}

	va_list args;
	va_start(args, nSubAuthorityCount);
	for(UINT i = 0; i < nSubAuthorityCount; i++)
		*::GetSidSubAuthority(pSid, i) = va_arg(args, DWORD);
	va_end(args);

	Copy(*pSid);

	m_SidNameUse = SidTypeUnknown;
}

inline CSid::CSid(const CSid &rhs)
	: m_SidNameUse(rhs.m_SidNameUse), m_pSid(NULL),
		m_strAccountName(rhs.m_strAccountName), m_strDomain(rhs.m_strDomain),
		m_strSid(rhs.m_strSid)
{
	if(!rhs.IsValid())
		AtlThrow(E_INVALIDARG);

	DWORD dwLengthSid = ::GetLengthSid(rhs.m_pSid);
	m_pSid = static_cast<SID *>(malloc(dwLengthSid));
	if(!m_pSid)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid(dwLengthSid, m_pSid, rhs.m_pSid))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSid);
		AtlThrow(hr);
	}
}

inline CSid &CSid::operator=(const CSid &rhs)
{
	if(this != &rhs)
	{
		if(!rhs.IsValid())
			AtlThrow(E_INVALIDARG);

		m_SidNameUse = rhs.m_SidNameUse;
		m_strAccountName = rhs.m_strAccountName;
		m_strDomain = rhs.m_strDomain;
		m_strSid = rhs.m_strSid;

		free(m_pSid);

		DWORD dwLengthSid = ::GetLengthSid(rhs.m_pSid);
		m_pSid = static_cast<SID *>(malloc(dwLengthSid));
		if(!m_pSid)
			AtlThrow(E_OUTOFMEMORY);

		if(!::CopySid(dwLengthSid, m_pSid, rhs.m_pSid))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pSid);
			m_pSid = NULL;
			AtlThrow(hr);
		}
	}
	return *this;
}

inline CSid::CSid(const SID &rhs)
	: m_pSid(NULL), m_SidNameUse(SidTypeInvalid)
{
	Copy(rhs);
}

inline CSid &CSid::operator=(const SID &rhs)
{
	if(m_pSid != &rhs)
	{
		Clear();
		Copy(rhs);

		m_SidNameUse = SidTypeUnknown;
	}
	return *this;
}

inline bool CSid::LoadAccount(LPCTSTR pszAccountName, LPCTSTR pszSystem)
{
	// REVIEW
	
	static const DWORD dwSidSize = offsetof(SID, SubAuthority) + SID_MAX_SUB_AUTHORITIES * sizeof(DWORD);
	static const DWORD dwDomainSize = 128; // seems reasonable
	BYTE byTmp[dwSidSize];
	SID *pSid = reinterpret_cast<SID *>(byTmp);
	TCHAR szDomain[dwDomainSize];
	DWORD cbSid = dwSidSize, cbDomain = dwDomainSize;

	BOOL bSuccess = ::LookupAccountName(pszSystem, pszAccountName, pSid, &cbSid, szDomain, &cbDomain, &m_SidNameUse);

	if(bSuccess || ERROR_INSUFFICIENT_BUFFER == ::GetLastError())
	{
		// LookupAccountName doesn't change cbSid on success (although it changes cbDomain)
		if(bSuccess)
			cbSid = ::GetLengthSid(pSid);

		free(m_pSid);
		m_pSid = static_cast<SID *>(malloc(cbSid));
		if (m_pSid)
		{
			if(bSuccess)
			{
				if(::CopySid(cbSid, m_pSid, pSid))
				{
					m_strDomain = szDomain;
					m_strAccountName = pszAccountName;
					m_strSystem = pszSystem;
					return true;
				}
			}
			else
			{
				LPTSTR pszDomain = m_strDomain.GetBuffer(cbDomain);
				bSuccess = ::LookupAccountName(pszSystem, pszAccountName, m_pSid, &cbSid,
					pszDomain ,&cbDomain, &m_SidNameUse);
				m_strDomain.ReleaseBuffer();

				if(bSuccess)
				{
					m_strAccountName = pszAccountName;
					m_strSystem = pszSystem;
					return true;
				}
			}
		}
	}

	Clear();
	return false;
}

inline bool CSid::LoadAccount(const SID *pSid, LPCTSTR pszSystem)
{
	ATLASSERT(pSid);
	if(pSid)
		_ATLTRY
		{
			m_strSystem = pszSystem;
			Copy(*pSid);
			return true;
		}
		_ATLCATCHALL()
		{
			Clear();
		}
	return false;
}

inline LPCTSTR CSid::AccountName() const
{
	if(m_strAccountName.IsEmpty())
		GetAccountNameAndDomain();
	return m_strAccountName;
}

inline LPCTSTR CSid::Domain() const
{
	if(m_strDomain.IsEmpty())
		GetAccountNameAndDomain();
	return m_strDomain;
}

inline LPCTSTR CSid::Sid() const
{
	if(m_strSid.IsEmpty())
	{
#if(_WIN32_WINNT >= 0x0500)
		LPTSTR pszSid;
		if(::ConvertSidToStringSid(m_pSid, &pszSid))
		{
			m_strSid = pszSid;
			::LocalFree(pszSid);
		}
#else
		SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(m_pSid);
		UINT i;

		if(psia->Value[0] || psia->Value[1])
		{
			unsigned __int64 nAuthority = 0;
			for(i = 0; i < 6; i++)
			{
				nAuthority <<= 8;
				nAuthority |= psia->Value[i];
			}
			m_strSid.Format(_T("S-%d-%I64u"), SID_REVISION, nAuthority);
		}
		else
		{
			ULONG nAuthority = 0;
			for(i = 2; i < 6; i++)
			{
				nAuthority <<= 8;
				nAuthority |= psia->Value[i];
			}
			m_strSid.Format(_T("S-%d-%lu"), SID_REVISION, nAuthority);
		}

		UINT nSubAuthorityCount = *::GetSidSubAuthorityCount(m_pSid);
		CString strTemp;
		for(i = 0; i < nSubAuthorityCount; i++)
		{
			strTemp.Format(_T("-%lu"), *::GetSidSubAuthority(m_pSid, i));
			m_strSid += strTemp;
		}
#endif
	}
	return m_strSid;
}

inline void CSid::Clear()
{
	m_SidNameUse = SidTypeInvalid;
	m_strAccountName.Empty();
	m_strDomain.Empty();
	m_strSid.Empty();
	m_strSystem.Empty();

	free(m_pSid);
	m_pSid = NULL;
}

inline void CSid::Copy(const SID &rhs)
{
	// This function assumes everything is cleaned up/initialized
	// (with the exception of m_strSystem).
	// It does some sanity checking to prevent memory leaks, but
	// you should clean up all members of CSid before calling this
	// function.  (i.e., results are unpredictable on error)

	ATLASSERT(m_SidNameUse == SidTypeInvalid);
	ATLASSERT(m_strAccountName.IsEmpty());
	ATLASSERT(m_strDomain.IsEmpty());
	ATLASSERT(m_strSid.IsEmpty());

	SID *p = const_cast<SID *>(&rhs);
	if(!::IsValidSid(p))
		AtlThrow(E_INVALIDARG);

	free(m_pSid);

	DWORD dwLengthSid = ::GetLengthSid(p);
	m_pSid = (SID *) malloc(dwLengthSid);
	if(!m_pSid)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid(dwLengthSid, m_pSid, p))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSid);
		m_pSid = NULL;
		AtlThrow(hr);
	}
}

inline void CSid::GetAccountNameAndDomain() const
{
	// REVIEW: 32 large enough?
	
	static const DWORD dwMax = 32; // seems reasonable
	DWORD cbName = dwMax, cbDomain = dwMax;
	TCHAR szName[dwMax], szDomain[dwMax];

	if(::LookupAccountSid(m_strSystem, m_pSid, szName, &cbName, szDomain, &cbDomain, &m_SidNameUse))
	{
		m_strAccountName = szName;
		m_strDomain = szDomain;
	}
	else
	{
		switch(::GetLastError())
		{
		case ERROR_INSUFFICIENT_BUFFER:
		{
			LPTSTR pszName = m_strAccountName.GetBuffer(cbName);
			LPTSTR pszDomain = m_strDomain.GetBuffer(cbDomain);

			if (!::LookupAccountSid(m_strSystem, m_pSid, pszName, &cbName, pszDomain, &cbDomain, &m_SidNameUse))
			{
				AtlThrowLastWin32();
			}

			m_strAccountName.ReleaseBuffer();
			m_strDomain.ReleaseBuffer();
			break;
		}

		case ERROR_NONE_MAPPED:
			m_strAccountName.Empty();
			m_strDomain.Empty();
			m_SidNameUse = SidTypeUnknown;
			break;

		default:
			ATLASSERT(FALSE);
		}
	}
}

template<>
class CElementTraits< CSid > :
	public CElementTraitsBase< CSid >
{
public:
	static ULONG Hash( INARGTYPE t ) throw()
	{
		return( ULONG( ULONG_PTR( t.GetPSID() ) ) );
	}

	static int CompareElements( INARGTYPE element1, INARGTYPE element2 ) throw()
	{
		return( element1 == element2 );
	}

	static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 ) throw()
	{
#if 0
		if( element1 < element2 )
		{
			return( -1 );
		}
		else if( element1 == element2 )
		{
			return( 0 );
		}
		else
		{
			ATLASSERT( element1 > element2 );
			return( 1 );
		}
#else
		element1;
		element2;
		ATLASSERT(false);
		return 0;
#endif
	}
};

//***************************************
// CAcl
//		CAce
//
//		CDacl
//			CAccessAce
//
//		CSacl
//			CAuditAce
//***************************************

// **************************************************************
// ACLs
class CAcl
{
public:
	CAcl() : m_pAcl(NULL), m_bNull(false), m_dwAclRevision(ACL_REVISION){}
	virtual ~CAcl(){free(m_pAcl);}

	CAcl(const CAcl &rhs) : m_pAcl(NULL), m_bNull(rhs.m_bNull),
		m_dwAclRevision(rhs.m_dwAclRevision){}
	CAcl &operator=(const CAcl &rhs)
	{
		if(this != &rhs)
		{
			free(m_pAcl);
			m_pAcl = NULL;
			m_bNull = rhs.m_bNull;
			m_dwAclRevision = rhs.m_dwAclRevision;
		}
		return *this;
	}

	typedef CSimpleArray<ACCESS_MASK> CAccessMaskArray;
	typedef CSimpleArray<BYTE> CAceTypeArray;
	typedef CSimpleArray<BYTE> CAceFlagArray;
	
	void GetAclEntries(CSid::CSidArray *pSids, CAccessMaskArray *pAccessMasks = NULL,
		CAceTypeArray *pAceTypes = NULL, CAceFlagArray *pAceFlags = NULL) const;

	bool RemoveAces(const CSid &rSid);

	virtual UINT GetAceCount() const = 0;
	virtual void RemoveAllAces() = 0;

	const ACL *GetPACL() const;
	operator const ACL *() const {return GetPACL();}
	UINT GetLength() const;

	void SetNull(){Dirty(); m_bNull = true;}
	void SetEmpty(){Dirty(); m_bNull = false;}
	bool IsNull() const {return m_bNull;}
	bool IsEmpty() const {return !m_bNull && 0 == GetAceCount();}

private:
	mutable ACL *m_pAcl;
	bool m_bNull;

protected:
	void Dirty(){free(m_pAcl); m_pAcl = NULL;}

	class CAce
	{
	public:
		CAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags)
			: m_dwAccessMask(AccessMask), m_Sid(rSid), m_AceFlags(AceFlags), m_pAce(NULL){}
		virtual ~CAce(){free(m_pAce);}

		CAce(const CAce &rhs) : m_Sid(rhs.m_Sid), m_dwAccessMask(rhs.m_dwAccessMask),
			m_AceFlags(rhs.m_AceFlags), m_pAce(NULL){}
		CAce &operator=(const CAce &rhs)
		{
			if(this != &rhs)
			{
				m_Sid = rhs.m_Sid;
				m_dwAccessMask = rhs.m_dwAccessMask;
				m_AceFlags = rhs.m_AceFlags;
				free(m_pAce);
				m_pAce = NULL;
			}
			return *this;
		}

		virtual void *GetACE() const = 0;
		virtual UINT GetLength() const = 0;
		virtual BYTE AceType() const = 0;
		virtual bool IsObjectAce() const {return false;}

		ACCESS_MASK AccessMask() const
			{return m_dwAccessMask;}
		BYTE AceFlags() const
			{return m_AceFlags;}
		const CSid &Sid() const
			{return m_Sid;}

		void AddAccess(ACCESS_MASK AccessMask)
			{m_dwAccessMask |= AccessMask; free(m_pAce); m_pAce = NULL;}

	protected:
		CSid m_Sid;
		ACCESS_MASK m_dwAccessMask;
		BYTE m_AceFlags;
		mutable void *m_pAce;
	};

	virtual const CAce *GetAce(UINT nIndex) const = 0;
	virtual void RemoveAce(UINT nIndex) = 0;
	virtual void PrepareAcesForACL() const {}

	DWORD m_dwAclRevision;
};

inline const ACL *CAcl::GetPACL() const
{
	if(!m_pAcl && !m_bNull)
	{
		UINT nAclLength = sizeof(ACL);
		const CAce *pAce;
		UINT i;
		const UINT nCount = GetAceCount();
		
		for(i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);
			ATLASSERT(pAce);
			if(pAce)
				nAclLength += pAce->GetLength();
		}

		m_pAcl = static_cast<ACL *>(malloc(nAclLength));
		if(!m_pAcl)
			return NULL;

		if(!::InitializeAcl(m_pAcl, nAclLength, m_dwAclRevision))
		{
			free(m_pAcl);
			m_pAcl = NULL;
		}
		else
		{
			PrepareAcesForACL();

			for(i = 0; i < nCount; i++)
			{
				pAce = GetAce(i);
				ATLASSERT(pAce);
				if(!pAce ||
					!::AddAce(m_pAcl, m_dwAclRevision, MAXDWORD, pAce->GetACE(), pAce->GetLength()))
				{
					free(m_pAcl);
					m_pAcl = NULL;
					break;
				}
			}
		}
	}
	return m_pAcl;
}

inline UINT CAcl::GetLength() const
{
	ACL *pAcl = const_cast<ACL *>(GetPACL());
	ACL_SIZE_INFORMATION AclSize;

	ATLASSERT(pAcl);

	if(!::GetAclInformation(pAcl, &AclSize, sizeof(AclSize), AclSizeInformation))
	{
		ATLASSERT(false);
		return 0;
	}
	else
		return AclSize.AclBytesInUse;
}

inline void CAcl::GetAclEntries(CSid::CSidArray *pSids, CAccessMaskArray *pAccessMasks,
								CAceTypeArray *pAceTypes, CAceFlagArray *pAceFlags) const
{
	ATLASSERT(pSids);
	if(pSids)
	{
		pSids->RemoveAll();
		if(pAccessMasks)
			pAccessMasks->RemoveAll();
		if(pAceTypes)
			pAceTypes->RemoveAll();
		if(pAceFlags)
			pAceFlags->RemoveAll();

		const CAce *pAce;
		const UINT nCount = GetAceCount();
		for(UINT i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);

			pSids->Add(pAce->Sid());
			if(pAccessMasks)
				pAccessMasks->Add(pAce->AccessMask());
			if(pAceTypes)
				pAceTypes->Add(pAce->AceType());
			if(pAceFlags)
				pAceFlags->Add(pAce->AceFlags());
		}
	}
}

inline bool CAcl::RemoveAces(const CSid &rSid)
{
	ATLASSERT(rSid.IsValid());

	if(IsNull() || !rSid.IsValid())
		return false;

	bool bRet = false;
	const CAce *pAce;
	UINT i = 0;

	while(i < GetAceCount())
	{
		pAce = GetAce(i);
		if(rSid == pAce->Sid())
		{
			RemoveAce(i);
			bRet = true;
		}
		else
			i++;
	}

	if(bRet)
		Dirty();

	return bRet;
}

// ************************************************
// CDacl
class CDacl : public CAcl
{
public:
	CDacl(){}
	~CDacl(){CDacl::RemoveAllAces();}

	CDacl(const ACL &rhs){Copy(rhs);}
	CDacl &operator=(const ACL &rhs);

	bool AddAllowedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags = 0);
	bool AddDeniedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags = 0);
#if(_WIN32_WINNT >= 0x0500)
	bool AddAllowedAce(const CSid &rSid, ACCESS_MASK AccessMask,  BYTE AceFlags,
		const GUID *pObjectType, const GUID *pInheritedObjectType);
	bool AddDeniedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
		const GUID *pObjectType, const GUID *pInheritedObjectType);
#endif
	void RemoveAllAces();

	UINT GetAceCount() const
		{return m_Acl.GetSize();}

private:
	void Copy(const ACL &rhs);

	class CAccessAce : public CAcl::CAce
	{
	public:
		CAccessAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags, bool bAllowAccess)
			: CAce(rSid, AccessMask, AceFlags), m_bAllow(bAllowAccess){}

		void *GetACE() const;
		UINT GetLength() const
			{return offsetof(ACCESS_ALLOWED_ACE, SidStart) + m_Sid.GetLength();}
		BYTE AceType() const
			{return (BYTE)(m_bAllow ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE);}

		bool Allow() const {return m_bAllow;}
		bool Inherited() const {return 0 != (m_AceFlags & INHERITED_ACE);}

	protected:
		bool m_bAllow;
	};

#if(_WIN32_WINNT >= 0x0500)
	class CAccessObjectAce : public CAccessAce
	{
	public:
		CAccessObjectAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags, bool bAllowAccess,
			const GUID *pObjectType, const GUID *pInheritedObjectType);
		~CAccessObjectAce();

		CAccessObjectAce(const CAccessObjectAce &rhs)
			: CAccessAce(rhs), m_pObjectType(NULL), m_pInheritedObjectType(NULL){*this = rhs;}
		CAccessObjectAce &operator=(const CAccessObjectAce &rhs);

		void *GetACE() const;
		UINT GetLength() const;
		BYTE AceType() const
			{return (BYTE)(m_bAllow ? ACCESS_ALLOWED_OBJECT_ACE_TYPE : ACCESS_DENIED_OBJECT_ACE_TYPE);}
		bool IsObjectAce() const {return true;}

	protected:
		GUID *m_pObjectType, *m_pInheritedObjectType;
	};

#endif
	const CAcl::CAce *GetAce(UINT nIndex) const
		{return m_Acl[nIndex];}
	void RemoveAce(UINT nIndex);

	void PrepareAcesForACL() const;

	mutable CSimpleArray<CAccessAce *> m_Acl;

	friend bool operator>(const CAccessAce &lhs, const CAccessAce &rhs)
	{
		// The order is:
		// denied direct aces
		// denied direct object aces
		// allowed direct aces
		// allowed direct object aces
		// denied inherit aces
		// denied inherit object aces
		// allowed inherit aces
		// allowed inherit object aces

		// inherited aces are always "greater" than non-inherited aces
		if(lhs.Inherited() && !rhs.Inherited())
			return true;
		if(!lhs.Inherited() && rhs.Inherited())
			return false;

		// if the aces are *both* either inherited or non-inherited, continue...

		// allowed aces are always "greater" than denied aces (subject to above)
		if(lhs.Allow() && !rhs.Allow())
			return true;
		if(!lhs.Allow() && rhs.Allow())
			return false;

		// if the aces are *both* either allowed or denied, continue...

		// object aces are always "greater" than non-object aces (subject to above)
		if(lhs.IsObjectAce() && !rhs.IsObjectAce())
			return true;
		if(!lhs.IsObjectAce() && rhs.IsObjectAce())
			return false;

		// aces are "equal" (e.g., both are access denied inherited object aces)
		return false;
	}
};

inline CDacl &CDacl::operator=(const ACL &rhs)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline void CDacl::PrepareAcesForACL() const
{
	// For a dacl, sort the aces
	int i, j, h = 1;
	const int nCount = m_Acl.GetSize();
	CAccessAce *pAce;

	while(h * 3 + 1 < nCount)
		h = 3 * h + 1;

	while(h > 0)
	{
		for(i = h - 1; i < nCount; i++)
		{
			pAce = m_Acl[i];

			for(j = i; j >= h && *m_Acl[j - h] > *pAce; j -= h)
				m_Acl[j] = m_Acl[j - h];

			m_Acl[j] = pAce;
		}

		h /= 3;
	}
}

inline void CDacl::Copy(const ACL &rhs)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	ACL_SIZE_INFORMATION AclSizeInfo;
	ACE_HEADER *pHeader;
	CSid Sid;
	ACCESS_MASK AccessMask;
	CAccessAce *pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation))
		AtlThrowLastWin32();

	for(DWORD i = 0; i < AclSizeInfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		AccessMask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		switch(pHeader->AceType)
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
			Sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

			ATLTRY(pAce = new CAccessAce(Sid, AccessMask, pHeader->AceFlags,
				ACCESS_ALLOWED_ACE_TYPE == pHeader->AceType));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			if (!m_Acl.Add(pAce))
			{
				delete pAce;
				AtlThrow(E_OUTOFMEMORY);
			}
			break;

#if(_WIN32_WINNT >= 0x0500)
		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType) :
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			Sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce = new CAccessObjectAce(Sid, AccessMask, pHeader->AceFlags,
				ACCESS_ALLOWED_OBJECT_ACE_TYPE == pHeader->AceType,
				pObjectType, pInheritedObjectType));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			if (!m_Acl.Add(pAce))
			{
				delete pAce;
				AtlThrow(E_OUTOFMEMORY);
			}
			break;
		}
#endif

		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline bool CDacl::AddAllowedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags)
{
	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAccessAce *pAce = NULL;
	ATLTRY(pAce = new CAccessAce(rSid, AccessMask, AceFlags, true));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}
	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddAllowedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
								 const GUID *pObjectType, const GUID *pInheritedObjectType)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAllowedAce(rSid, AccessMask, AceFlags);

	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAccessAce *pAce;
	ATLTRY(pAce = new CAccessObjectAce(rSid, AccessMask, AceFlags, true,
		pObjectType, pInheritedObjectType));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}

	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline bool CDacl::AddDeniedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags)
{
	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAccessAce *pAce = NULL;
	ATLTRY(pAce = new CAccessAce(rSid, AccessMask, AceFlags, false));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}
	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddDeniedAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
								const GUID *pObjectType, const GUID *pInheritedObjectType)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddDeniedAce(rSid, AccessMask, AceFlags);

	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAccessAce *pAce;
	ATLTRY(pAce = new CAccessObjectAce(rSid, AccessMask, AceFlags, false,
		pObjectType, pInheritedObjectType));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}
	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CDacl::RemoveAllAces()
{
	const UINT nCount = GetAceCount();
	
	for(UINT i = 0; i < nCount; i++)
		delete GetAce(i);

	m_Acl.RemoveAll();
	Dirty();
}

inline void CDacl::RemoveAce(UINT nIndex)
{
	delete GetAce(nIndex);
	m_Acl.RemoveAt(nIndex);
}

inline void *CDacl::CAccessAce::GetACE() const
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_ACE) == sizeof(ACCESS_DENIED_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Header)==offsetof(ACCESS_DENIED_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Mask)==offsetof(ACCESS_DENIED_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, SidStart)==offsetof(ACCESS_DENIED_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();
		ACCESS_ALLOWED_ACE *pAce = static_cast<ACCESS_ALLOWED_ACE *>(malloc(nLength));
		if(!pAce)
			return NULL;

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_AceFlags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(ACCESS_ALLOWED_ACE, SidStart) >= m_Sid.GetLength());
		memcpy(&pAce->SidStart, m_Sid.GetPSID(), m_Sid.GetLength());

		m_pAce = pAce;
	}
	return m_pAce;
}

#if(_WIN32_WINNT >= 0x0500)
inline CDacl::CAccessObjectAce::CAccessObjectAce(const CSid &rSid, ACCESS_MASK AccessMask,
												 BYTE AceFlags,  bool bAllowAccess,
												 const GUID *pObjectType,
												 const GUID *pInheritedObjectType) :
	CAccessAce(rSid, AccessMask, AceFlags, bAllowAccess),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CDacl::CAccessObjectAce::~CAccessObjectAce()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CDacl::CAccessObjectAce &CDacl::CAccessObjectAce::operator=(const CAccessObjectAce &rhs)
{
	if(this != &rhs)
	{
		CAccessAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline UINT CDacl::CAccessObjectAce::GetLength() const
{
	UINT nLength = offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_Sid.GetLength();

	return nLength;
}

inline void *CDacl::CAccessObjectAce::GetACE() const
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_OBJECT_ACE) == sizeof(ACCESS_DENIED_OBJECT_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Header)==offsetof(ACCESS_DENIED_OBJECT_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Mask)==offsetof(ACCESS_DENIED_OBJECT_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Flags)==offsetof(ACCESS_DENIED_OBJECT_ACE, Flags));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, ObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, InheritedObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart)==offsetof(ACCESS_DENIED_OBJECT_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();

		ACCESS_ALLOWED_OBJECT_ACE *pAce = static_cast<ACCESS_ALLOWED_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			return NULL;

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_AceFlags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		BYTE *pb = (reinterpret_cast<BYTE *>(pAce)) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}
		ATLASSERT(size_t(pb - reinterpret_cast<BYTE *>(pAce)) >= m_Sid.GetLength());
		memcpy(pb, m_Sid.GetPSID(), m_Sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}
#endif // _WIN32_WINNT

//******************************************
// CSacl
class CSacl : public CAcl
{
public:
	CSacl(){}
	~CSacl(){CSacl::RemoveAllAces();}

	CSacl(const ACL &rhs) {Copy(rhs);}
	CSacl &operator=(const ACL &rhs);

	bool AddAuditAce(const CSid &rSid, ACCESS_MASK AccessMask,
		bool bSuccess, bool bFailure, BYTE AceFlags = 0);
#if(_WIN32_WINNT >= 0x0500)
	bool AddAuditAce(const CSid &rSid, ACCESS_MASK AccessMask,
		bool bSuccess, bool bFailure, BYTE AceFlags,
		const GUID *pObjectType, const GUID *pInheritedObjectType);
#endif
	void RemoveAllAces();

	UINT GetAceCount() const
		{return m_Acl.GetSize();}

private:
	void Copy(const ACL &rhs);

	class CAuditAce : public CAcl::CAce
	{
	public:
		CAuditAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
			bool bAuditSuccess, bool bAuditFailure)
			: CAce(rSid, AccessMask, AceFlags),
			m_bSuccess(bAuditSuccess), m_bFailure(bAuditFailure){}

		void *GetACE() const;
		UINT GetLength() const
			{return offsetof(SYSTEM_AUDIT_ACE, SidStart) + m_Sid.GetLength();}
		BYTE AceType() const
			{return SYSTEM_AUDIT_ACE_TYPE;}

	protected:
		bool m_bSuccess, m_bFailure;
	};

#if(_WIN32_WINNT >= 0x0500)
	class CAuditObjectAce : public CAuditAce
	{
	public:
		CAuditObjectAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
			bool bAuditSuccess, bool bAuditFailure,
			const GUID *pObjectType, const GUID *pInheritedObjectType);
		~CAuditObjectAce();

		CAuditObjectAce(const CAuditObjectAce &rhs)
			: CAuditAce(rhs), m_pObjectType(NULL), m_pInheritedObjectType(NULL){*this = rhs;}
		CAuditObjectAce &operator=(const CAuditObjectAce &rhs);

		void *GetACE() const;
		UINT GetLength() const;
		BYTE AceType() const
			{return SYSTEM_AUDIT_OBJECT_ACE_TYPE;}
		bool IsObjectAce() const {return true;}

	protected:
		GUID *m_pObjectType, *m_pInheritedObjectType;
	};
#endif
	POSITION GetHeadAce() const;
	const CAce *GetAce(UINT nIndex) const
		{return m_Acl[nIndex];}
	void RemoveAce(UINT nIndex);

	CSimpleArray<CAuditAce *> m_Acl;
};

inline CSacl &CSacl::operator=(const ACL &rhs)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline void CSacl::Copy(const ACL &rhs)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	ACL_SIZE_INFORMATION AclSizeInfo;
	ACE_HEADER *pHeader;
	CSid Sid;
	ACCESS_MASK AccessMask;
	bool bSuccess, bFailure;
	CAuditAce *pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation))
		AtlThrowLastWin32();

	for(DWORD i = 0; i < AclSizeInfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		AccessMask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		bSuccess = 0 != (pHeader->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG);
		bFailure = 0 != (pHeader->AceFlags & FAILED_ACCESS_ACE_FLAG);

		switch(pHeader->AceType)
		{
		case SYSTEM_AUDIT_ACE_TYPE:
			Sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) +	sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
			ATLTRY(pAce = new CAuditAce(Sid, AccessMask, pHeader->AceFlags, bSuccess, bFailure));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			if (!m_Acl.Add(pAce))
			{
				delete pAce;
				AtlThrow(E_OUTOFMEMORY);
			}
			break;

#if(_WIN32_WINNT >= 0x0500)
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<SYSTEM_AUDIT_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, InheritedObjectType) :
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			Sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce = new CAuditObjectAce(Sid, AccessMask, pHeader->AceFlags,
				bSuccess, bFailure, pObjectType, pInheritedObjectType));
			if(!pAce)
				AtlThrow(E_OUTOFMEMORY);
			if (!m_Acl.Add(pAce))
			{
				delete pAce;
				AtlThrow(E_OUTOFMEMORY);
			}
			break;
		}
#endif
		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline bool CSacl::AddAuditAce(const CSid &rSid, ACCESS_MASK AccessMask,
							   bool bSuccess, bool bFailure, BYTE AceFlags)
{
	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAuditAce *pAce;
	ATLTRY(pAce = new CAuditAce(rSid, AccessMask, AceFlags, bSuccess, bFailure));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}
	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSacl::AddAuditAce(const CSid &rSid, ACCESS_MASK AccessMask,
							   bool bSuccess, bool bFailure, BYTE AceFlags,
							   const GUID *pObjectType, const GUID *pInheritedObjectType)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAuditAce(rSid, AccessMask, bSuccess, bFailure, AceFlags);

	ATLASSERT(rSid.IsValid());
	if(IsNull() || !rSid.IsValid())
		return false;

	CAuditAce *pAce;
	ATLTRY(pAce = new CAuditObjectAce(rSid, AccessMask, AceFlags, bSuccess,
		bFailure, pObjectType, pInheritedObjectType));
	if(!pAce)
		return false;

	if (!m_Acl.Add(pAce))
	{
		delete pAce;
		return false;
	}
	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CSacl::RemoveAllAces()
{
	const UINT nCount = GetAceCount();

	for(UINT i = 0; i < nCount; i++)
		delete GetAce(i);

	m_Acl.RemoveAll();
	Dirty();
}

inline void CSacl::RemoveAce(UINT nIndex)
{
	delete GetAce(nIndex);
	m_Acl.RemoveAt(nIndex);
}

inline void *CSacl::CAuditAce::GetACE() const
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_ACE *pAce = static_cast<SYSTEM_AUDIT_ACE *>(malloc(nLength));
		if(!pAce)
			return NULL;

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_AceFlags;
		pAce->Header.AceType = AceType();;

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(SYSTEM_AUDIT_ACE, SidStart) >= m_Sid.GetLength());
		memcpy(&pAce->SidStart, m_Sid.GetPSID(), m_Sid.GetLength());

		if(m_bSuccess)
			pAce->Header.AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~SUCCESSFUL_ACCESS_ACE_FLAG;

		if(m_bFailure)
			pAce->Header.AceFlags |= FAILED_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~FAILED_ACCESS_ACE_FLAG;

		m_pAce = pAce;
	}
	return m_pAce;
}

#if(_WIN32_WINNT >= 0x0500)
inline CSacl::CAuditObjectAce::CAuditObjectAce(const CSid &rSid, ACCESS_MASK AccessMask, BYTE AceFlags,
	bool bAuditSuccess, bool bAuditFailure, const GUID *pObjectType, const GUID *pInheritedObjectType)
	: CAuditAce(rSid, AccessMask, AceFlags, bAuditSuccess, bAuditFailure)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CSacl::CAuditObjectAce::~CAuditObjectAce()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CSacl::CAuditObjectAce &CSacl::CAuditObjectAce::operator=(const CAuditObjectAce &rhs)
{
	if(this != &rhs)
	{
		CAuditAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline UINT CSacl::CAuditObjectAce::GetLength() const
{
	UINT nLength = offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_Sid.GetLength();

	return nLength;
}

inline void *CSacl::CAuditObjectAce::GetACE() const
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_OBJECT_ACE *pAce = static_cast<SYSTEM_AUDIT_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			return NULL;

		memset(pAce, 0x00, nLength);

		pAce->Header.AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_AceFlags;

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		if(m_bSuccess)
			pAce->Header.AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~SUCCESSFUL_ACCESS_ACE_FLAG;

		if(m_bFailure)
			pAce->Header.AceFlags |= FAILED_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~FAILED_ACCESS_ACE_FLAG;

		BYTE *pb = ((BYTE *) pAce) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}
		ATLASSERT(size_t(pb - reinterpret_cast<BYTE*>(pAce)) >= m_Sid.GetLength());
		memcpy(pb, m_Sid.GetPSID(), m_Sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}
#endif

//******************************************
// CSecurityDesc

class CSecurityDesc
{
public:
	CSecurityDesc() : m_pSecurityDescriptor(NULL){}
	virtual ~CSecurityDesc() {Clear();}

	CSecurityDesc(const CSecurityDesc &rhs);
	CSecurityDesc &operator=(const CSecurityDesc &rhs);

	CSecurityDesc(const SECURITY_DESCRIPTOR &rhs);
	CSecurityDesc &operator=(const SECURITY_DESCRIPTOR &rhs);

#if(_WIN32_WINNT >= 0x0500)
	bool FromString(LPCTSTR pstr);
	bool ToString(CString *pstr,
		SECURITY_INFORMATION si =
		OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION) const;
#endif

	bool SetOwner(const CSid &Sid, bool bDefaulted = false);
	bool SetGroup(const CSid &Sid, bool bDefaulted = false);
	bool SetDacl(const CDacl &Dacl, bool bDefaulted = false);
	bool SetDacl(bool bPresent, bool bDefaulted = false);
	bool SetSacl(const CSacl &Sacl, bool bDefaulted = false);
	bool GetOwner(CSid *pSid, bool *pbDefaulted = NULL) const;
	bool GetGroup(CSid *pSid, bool *pbDefaulted = NULL) const;
	bool GetDacl(CDacl *pDacl, bool *pbPresent = NULL, bool *pbDefaulted = NULL) const;
	bool GetSacl(CSacl *pSacl, bool *pbPresent = NULL, bool *pbDefaulted = NULL) const;

	bool IsDaclDefaulted() const;
	bool IsDaclPresent() const;
	bool IsGroupDefaulted() const;
	bool IsOwnerDefaulted() const;
	bool IsSaclDefaulted() const;
	bool IsSaclPresent() const;
	bool IsSelfRelative() const;

	// Only meaningful on Win2k or better
	bool IsDaclAutoInherited() const;
	bool IsDaclProtected() const;
	bool IsSaclAutoInherited() const;
	bool IsSaclProtected() const;

	const SECURITY_DESCRIPTOR *GetPSECURITY_DESCRIPTOR() const
		{return m_pSecurityDescriptor;}
	operator const SECURITY_DESCRIPTOR *() const {return GetPSECURITY_DESCRIPTOR();}

	bool GetSECURITY_DESCRIPTOR(SECURITY_DESCRIPTOR *pSD, LPDWORD lpdwBufferLength);

	bool GetControl(SECURITY_DESCRIPTOR_CONTROL *psdc) const;
#if(_WIN32_WINNT >= 0x0500)
	bool SetControl(SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
		SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);
#endif

	bool MakeSelfRelative();
	bool MakeAbsolute();

protected:
	virtual void Clear();
	bool AllocateAndInitializeSecurityDescriptor();
	void Init(const SECURITY_DESCRIPTOR &rhs);

	SECURITY_DESCRIPTOR *m_pSecurityDescriptor;
};

class CSecurityAttributes : public SECURITY_ATTRIBUTES
{
public:
	CSecurityAttributes()
		{nLength = 0; lpSecurityDescriptor = NULL; bInheritHandle = FALSE;}
	explicit CSecurityAttributes(const CSecurityDesc &rSecurityDescriptor, bool bInheritHandle = false) :
		m_SecurityDescriptor(rSecurityDescriptor)
	{
		Set(m_SecurityDescriptor, bInheritHandle);
	}

	void Set(const CSecurityDesc &rSecurityDescriptor, bool bInheritHandle = false)
	{
		m_SecurityDescriptor = rSecurityDescriptor;
		nLength = sizeof(SECURITY_ATTRIBUTES);
		lpSecurityDescriptor = const_cast<SECURITY_DESCRIPTOR *>
			(m_SecurityDescriptor.GetPSECURITY_DESCRIPTOR());
		this->bInheritHandle = bInheritHandle;
	}

protected:
	CSecurityDesc m_SecurityDescriptor;
};

inline CSecurityDesc::CSecurityDesc(const CSecurityDesc &rhs)
	: m_pSecurityDescriptor(NULL)
{
	if(rhs.m_pSecurityDescriptor)
		Init(*rhs.m_pSecurityDescriptor);
}

inline CSecurityDesc &CSecurityDesc::operator=(const CSecurityDesc &rhs)
{
	if(this != &rhs)
	{
		Clear();
		if(rhs.m_pSecurityDescriptor)
			Init(*rhs.m_pSecurityDescriptor);
	}
	return *this;
}

inline CSecurityDesc::CSecurityDesc(const SECURITY_DESCRIPTOR &rhs)
	: m_pSecurityDescriptor(NULL)
{
	Init(rhs);
}

inline CSecurityDesc &CSecurityDesc::operator=(const SECURITY_DESCRIPTOR &rhs)
{
	if(m_pSecurityDescriptor != &rhs)
	{
		Clear();
		Init(rhs);
	}
	return *this;
}

inline void CSecurityDesc::Init(const SECURITY_DESCRIPTOR &rhs)
{
	SECURITY_DESCRIPTOR *pSD = const_cast<SECURITY_DESCRIPTOR *>(&rhs);
	DWORD dwRev, dwLen = ::GetSecurityDescriptorLength(pSD);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!m_pSecurityDescriptor)
		AtlThrow(E_OUTOFMEMORY);

	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!::GetSecurityDescriptorControl(pSD, &sdc, &dwRev))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		AtlThrow(hr);
	}

	if(sdc & SE_SELF_RELATIVE)
		memcpy(m_pSecurityDescriptor, pSD, dwLen);
	else
	{
		if(!::MakeSelfRelativeSD(pSD, m_pSecurityDescriptor, &dwLen))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pSecurityDescriptor);
			m_pSecurityDescriptor = NULL;
			AtlThrow(hr);
		}
	}
}

inline void CSecurityDesc::Clear()
{
	if(m_pSecurityDescriptor)
	{
		SECURITY_DESCRIPTOR_CONTROL sdc;
		if(GetControl(&sdc) && !(sdc & SE_SELF_RELATIVE))
		{
			PSID pOwner, pGroup;
			ACL *pDacl, *pSacl;
			BOOL bDefaulted, bPresent;

			::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOwner, &bDefaulted);
			free(pOwner);
			::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pGroup, &bDefaulted);
			free(pGroup);
			::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pDacl, &bDefaulted);
			if(bPresent)
				free(pDacl);
			::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pSacl, &bDefaulted);
			if(bPresent)
				free(pSacl);
		}
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
	}
}

inline bool CSecurityDesc::MakeSelfRelative()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor || !GetControl(&sdc))
		return false;

	if(sdc & SE_SELF_RELATIVE)
		return true;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwLen = 0;

	::MakeSelfRelativeSD(m_pSecurityDescriptor, NULL, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return false;

	pSD = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!pSD)
		return false;

	if(!::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, &dwLen))
	{
		free(pSD);
		return false;
	}

	Clear();
	m_pSecurityDescriptor = pSD;
	return true;
}

inline bool CSecurityDesc::MakeAbsolute()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor || !GetControl(&sdc))
		return false;

	if(!(sdc & SE_SELF_RELATIVE))
		return true;

	SECURITY_DESCRIPTOR *pSD;
	SID *pOwner, *pGroup;
	ACL *pDacl, *pSacl;
	DWORD dwSD, dwOwner, dwGroup, dwDacl, dwSacl;

	dwSD = dwOwner = dwGroup = dwDacl = dwSacl = 0;

	::MakeAbsoluteSD(m_pSecurityDescriptor, NULL, &dwSD, NULL, &dwDacl,
		NULL, &dwSacl, NULL, &dwOwner, NULL, &dwGroup);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return false;

	pSD    = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwSD));
	pOwner = static_cast<SID *>(dwOwner ? malloc(dwOwner) : NULL);
	pGroup = static_cast<SID *>(dwGroup ? malloc(dwGroup) : NULL);
	pDacl  = static_cast<ACL *>(dwDacl ? malloc(dwDacl) : NULL);
	pSacl  = static_cast<ACL *>(dwSacl ? malloc(dwSacl) : NULL);

	if(!::MakeAbsoluteSD(m_pSecurityDescriptor,
		pSD, &dwSD,
		pDacl, &dwDacl,
		pSacl, &dwSacl,
		pOwner, &dwOwner,
		pGroup, &dwGroup))
	{
		free(pSD);
		free(pOwner);
		free(pGroup);
		free(pDacl);
		free(pSacl);
		return false;
	}

	Clear();
	m_pSecurityDescriptor = pSD;
	return true;
}

inline bool CSecurityDesc::AllocateAndInitializeSecurityDescriptor()
{
	// m_pSecurityDescriptor should be NULL.
	ATLASSERT(!m_pSecurityDescriptor);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(sizeof(SECURITY_DESCRIPTOR)));
	if(!m_pSecurityDescriptor)
		return false;

	if(!::InitializeSecurityDescriptor(m_pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
	{
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		return false;
	}
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::FromString(LPCTSTR pstr)
{
	SECURITY_DESCRIPTOR *pSD;
	if(!::ConvertStringSecurityDescriptorToSecurityDescriptor(pstr, SDDL_REVISION_1,
		(PSECURITY_DESCRIPTOR *) &pSD, NULL))
	{
		return false;
	}

	*this = *pSD;
	::LocalFree(pSD);

	return true;
}

inline bool CSecurityDesc::ToString(CString *pstr, SECURITY_INFORMATION si) const
{
	ATLASSERT(pstr);
	if(!pstr || !m_pSecurityDescriptor)
		return false;
	
	LPTSTR pszStringSecurityDescriptor;
	if(!::ConvertSecurityDescriptorToStringSecurityDescriptor(m_pSecurityDescriptor,
		SDDL_REVISION_1,
		si,
		&pszStringSecurityDescriptor,
		NULL))
	{
		return false;
	}

	*pstr = pszStringSecurityDescriptor;
	::LocalFree(pszStringSecurityDescriptor);

	return true;
}
#endif

inline bool CSecurityDesc::GetSECURITY_DESCRIPTOR(SECURITY_DESCRIPTOR *pSD, LPDWORD lpdwBufferLength)
{
	ATLASSERT(lpdwBufferLength);
	if(!lpdwBufferLength)
		return false;

	if(!MakeAbsolute())
		return false;
	return 0 != ::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, lpdwBufferLength);
}

inline bool CSecurityDesc::SetOwner(const CSid &Sid, bool bDefaulted)
{
	if(m_pSecurityDescriptor && !MakeAbsolute())
		return false;

	PSID pNewOwner, pOldOwner;
	if(m_pSecurityDescriptor)
	{
		BOOL bDefaulted;
		if(!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOldOwner, &bDefaulted))
			return false;
	}
	else
	{
		if(!AllocateAndInitializeSecurityDescriptor())
			return false;
		pOldOwner = NULL;
	}

	if(!Sid.IsValid())
		return false;

	UINT nSidLength = Sid.GetLength();
	pNewOwner = malloc(nSidLength);
	if(!pNewOwner)
		return false;

	if(!::CopySid(nSidLength, pNewOwner, const_cast<SID *>(Sid.GetPSID())) ||
		!::SetSecurityDescriptorOwner(m_pSecurityDescriptor, pNewOwner, bDefaulted))
	{
		free(pNewOwner);
		return false;
	}

	free(pOldOwner);
	return true;
}

inline bool CSecurityDesc::SetGroup(const CSid &Sid, bool bDefaulted)
{
	if(m_pSecurityDescriptor && !MakeAbsolute())
		return false;

	PSID pNewGroup, pOldGroup;
	if(m_pSecurityDescriptor)
	{
		BOOL bDefaulted;
		if(!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pOldGroup, &bDefaulted))
			return false;
	}
	else
	{
		if(!AllocateAndInitializeSecurityDescriptor())
			return false;
		pOldGroup = NULL;
	}

	if(!Sid.IsValid())
		return false;

	UINT nSidLength = Sid.GetLength();
	pNewGroup = malloc(nSidLength);
	if(!pNewGroup)
		return false;

	if(!::CopySid(nSidLength, pNewGroup, const_cast<SID *>(Sid.GetPSID())) ||
		!::SetSecurityDescriptorGroup(m_pSecurityDescriptor, pNewGroup, bDefaulted))
	{
		free(pNewGroup);
		return false;
	}

	free(pOldGroup);
	return true;
}

inline bool CSecurityDesc::SetDacl(bool bPresent, bool bDefaulted)
{
	if(m_pSecurityDescriptor && !MakeAbsolute())
		return false;

	PACL pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL bDefaulted, bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pOldDacl, &bDefaulted))
			return false;
	}
	else
		if(!AllocateAndInitializeSecurityDescriptor())
			return false;

#ifdef _DEBUG
	if(bPresent)
		ATLTRACE(atlTraceSecurity, 2, _T("Caution: Setting Dacl to Null\n"));
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, bPresent, NULL, bDefaulted))
		return false;

	free(pOldDacl);
	return true;
}

inline bool CSecurityDesc::SetDacl(const CDacl &Dacl, bool bDefaulted)
{
	if(m_pSecurityDescriptor && !MakeAbsolute())
		return false;

	PACL pNewDacl, pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL bDefaulted, bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pOldDacl, &bDefaulted))
			return false;
	}
	else if(!AllocateAndInitializeSecurityDescriptor())
			return false;

	if(Dacl.IsNull() || Dacl.IsEmpty())
		pNewDacl = NULL;
	else
	{
		UINT nAclLength = Dacl.GetLength();
		if(!nAclLength)
			return false;

		pNewDacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewDacl)
			return false;

		memcpy(pNewDacl, Dacl.GetPACL(), nAclLength);
	}

#ifdef _DEBUG
	if(Dacl.IsNull())
		ATLTRACE(atlTraceSecurity, 2, _T("Caution: Setting Dacl to Null\n"));
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, Dacl.IsNull() || pNewDacl, pNewDacl, bDefaulted))
	{
		free(pNewDacl);
		return false;
	}

	free(pOldDacl);
	return true;
}

inline bool CSecurityDesc::SetSacl(const CSacl &Sacl, bool bDefaulted)
{
	if(m_pSecurityDescriptor && !MakeAbsolute())
		return false;

	PACL pNewSacl, pOldSacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL bDefaulted, bPresent;
		if(!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pOldSacl, &bDefaulted))
			return false;
	}
	else if(!AllocateAndInitializeSecurityDescriptor())
		return false;

	if(Sacl.IsNull() || Sacl.IsEmpty())
		pNewSacl = NULL;
	else
	{
		UINT nAclLength = Sacl.GetLength();
		if(!nAclLength)
			return false;

		pNewSacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewSacl)
			return false;

		memcpy(pNewSacl, Sacl.GetPACL(), nAclLength);
	}

	if(!::SetSecurityDescriptorSacl(m_pSecurityDescriptor, Sacl.IsNull() || pNewSacl, pNewSacl, bDefaulted))
	{
		free(pNewSacl);
		return false;
	}

	free(pOldSacl);
	return true;
}

inline bool CSecurityDesc::GetOwner(CSid *pSid, bool *pbDefaulted) const
{
	ATLASSERT(pSid);
	SID *pOwner;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, (PSID *) &pOwner, &bDefaulted))
	{
		return false;
	}

	*pSid = *pOwner;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetGroup(CSid *pSid, bool *pbDefaulted) const
{
	ATLASSERT(pSid);
	SID *pGroup;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, (PSID *) &pGroup, &bDefaulted))
	{
		return false;
	}

	*pSid = *pGroup;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetDacl(CDacl *pDacl, bool *pbPresent, bool *pbDefaulted) const
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted) ||
		!bPresent)
	{
		return false;
	}

	if(pDacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pDacl = *pAcl;
			else
				pDacl->SetNull();
		}
		else
			pDacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetSacl(CSacl *pSacl, bool *pbPresent, bool *pbDefaulted) const
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted) ||
		!bPresent)
	{
		return false;
	}

	if(pSacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pSacl = *pAcl;
			else
				pSacl->SetNull();
		}
		else
			pSacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::IsDaclDefaulted() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_DACL_PRESENT) &&
		(sdc & SE_DACL_DEFAULTED);
}

inline bool CSecurityDesc::IsDaclPresent() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PRESENT);
}

inline bool CSecurityDesc::IsGroupDefaulted() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_GROUP_DEFAULTED);
}

inline bool CSecurityDesc::IsOwnerDefaulted() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_OWNER_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclDefaulted() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_SACL_PRESENT) &&
		(sdc & SE_SACL_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclPresent() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PRESENT);
}

inline bool CSecurityDesc::IsSelfRelative() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SELF_RELATIVE);
}

inline bool CSecurityDesc::IsDaclAutoInherited() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsDaclProtected() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PROTECTED);
}

inline bool CSecurityDesc::IsSaclAutoInherited() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsSaclProtected() const
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PROTECTED);
}

inline bool CSecurityDesc::GetControl(SECURITY_DESCRIPTOR_CONTROL *psdc) const
{
	ATLASSERT(psdc);
	if(!psdc)
		return false;

	DWORD dwRev;
	*psdc = 0;
	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorControl(m_pSecurityDescriptor, psdc, &dwRev))
	{
		return false;
	}
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::SetControl(SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
									  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
{
	return 0 != ::SetSecurityDescriptorControl(m_pSecurityDescriptor,
		ControlBitsOfInterest, ControlBitsToSet);
}
#endif

template<>
class CSimpleArrayEqualHelper<LUID>
{
public:
	static bool IsEqual(const LUID& l1, const LUID& l2)
	{
		return l1.HighPart == l2.HighPart && l1.LowPart == l2.LowPart;
	}
};

template<>
class CElementTraits< LUID > :
	public CElementTraitsBase< LUID >
{
public:
	typedef const LUID& INARGTYPE;
	typedef LUID& OUTARGTYPE;

	static ULONG Hash( INARGTYPE luid )
	{
		return luid.HighPart ^ luid.LowPart;
	}

	static BOOL CompareElements( INARGTYPE element1, INARGTYPE element2 )
	{
		return CSimpleArrayEqualHelper<LUID>::IsEqual(element1, element2);
	}

	static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 )
	{
		_LARGE_INTEGER li1, li2;
		li1.LowPart = element1.LowPart;
		li1.HighPart = element1.HighPart;
		li2.LowPart = element2.LowPart;
		li2.HighPart = element2.HighPart;

		if( li1.QuadPart > li2.QuadPart )
			return( 1 );
		else if( li1.QuadPart < li2.QuadPart )
			return( -1 );

		return( 0 );
	}
};

typedef CSimpleArray<LUID> CLUIDArray;

//******************************************************
// CTokenPrivileges
class CTokenPrivileges
{
public:
	CTokenPrivileges() : m_bDirty(true), m_pTokenPrivileges(NULL){}
	virtual ~CTokenPrivileges() {free(m_pTokenPrivileges);}

	CTokenPrivileges(const CTokenPrivileges &rhs);
	CTokenPrivileges &operator=(const CTokenPrivileges &rhs);

	CTokenPrivileges(const TOKEN_PRIVILEGES &rPrivileges) :
		m_pTokenPrivileges(NULL) {AddPrivileges(rPrivileges);}
	CTokenPrivileges &operator=(const TOKEN_PRIVILEGES &rPrivileges)
		{m_TokenPrivileges.RemoveAll(); AddPrivileges(rPrivileges); return *this;}

	void Add(const TOKEN_PRIVILEGES &rPrivileges)
		{AddPrivileges(rPrivileges);}
	bool Add(LPCTSTR pszPrivilege, bool bEnable);

	typedef CSimpleArray<CString> CNames;
	typedef CSimpleArray<DWORD> CAttributes;
	
	bool LookupPrivilege(LPCTSTR pszPrivilege, DWORD *pdwAttributes = NULL) const;
	void GetNamesAndAttributes(CNames *pNames, CAttributes *pAttributes = NULL) const;
	void GetDisplayNames(CNames *pDisplayNames) const;
	void GetLuidsAndAttributes(CLUIDArray *pPrivileges, CAttributes *pAttributes = NULL) const;

	bool Delete(LPCTSTR pszPrivilege);
	void DeleteAll(){m_TokenPrivileges.RemoveAll(); m_bDirty = true;}

	UINT GetCount() const {return (UINT) m_TokenPrivileges.GetCount();}

	UINT GetLength() const
		{return offsetof(TOKEN_PRIVILEGES, Privileges) + sizeof(LUID_AND_ATTRIBUTES) * GetCount();}

	const TOKEN_PRIVILEGES *GetPTOKEN_PRIVILEGES() const;
	operator const TOKEN_PRIVILEGES *() const {return GetPTOKEN_PRIVILEGES();}

private:
	typedef CAtlMap<LUID, DWORD> Map;
	Map m_TokenPrivileges;
	mutable TOKEN_PRIVILEGES *m_pTokenPrivileges;
	bool m_bDirty;

	void AddPrivileges(const TOKEN_PRIVILEGES &rPrivileges);
};

inline CTokenPrivileges::CTokenPrivileges(const CTokenPrivileges &rhs)
	: m_pTokenPrivileges(NULL), m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_TokenPrivileges.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_TokenPrivileges.GetNext(pos);
		m_TokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenPrivileges &CTokenPrivileges::operator=(const CTokenPrivileges &rhs)
{
	if(this != &rhs)
	{
		m_TokenPrivileges.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_TokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_TokenPrivileges.GetNext(pos);
			m_TokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline bool CTokenPrivileges::Add(LPCTSTR pszPrivilege, bool bEnable)
{
	LUID_AND_ATTRIBUTES la;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &la.Luid))
		return false;
	
	la.Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	m_TokenPrivileges.SetAt(la.Luid, la.Attributes);

	m_bDirty = true;
	return true;
}

inline bool CTokenPrivileges::Delete(LPCTSTR pszPrivilege)
{
	LUID Luid;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &Luid))
		return false;

	if(!m_TokenPrivileges.RemoveKey(Luid))
		return false;

	m_bDirty = true;
	return true;
}

inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const
{
	if(m_bDirty)
	{
		free(m_pTokenPrivileges);
		m_pTokenPrivileges = NULL;

		if(m_TokenPrivileges.GetCount())
		{
			m_pTokenPrivileges = static_cast<TOKEN_PRIVILEGES *>(malloc(GetLength()));
			if(!m_pTokenPrivileges)
				return NULL;

			m_pTokenPrivileges->PrivilegeCount = (DWORD) GetCount();

			UINT i = 0;
			POSITION pos = m_TokenPrivileges.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				pPair = m_TokenPrivileges.GetNext(pos);
				m_pTokenPrivileges->Privileges[i].Luid = pPair->m_key;
				m_pTokenPrivileges->Privileges[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenPrivileges;
}

inline void CTokenPrivileges::AddPrivileges(const TOKEN_PRIVILEGES &rPrivileges)
{
	m_bDirty = true;
	for(UINT i = 0; i < rPrivileges.PrivilegeCount; i++)
		m_TokenPrivileges.SetAt(
			rPrivileges.Privileges[i].Luid, rPrivileges.Privileges[i].Attributes);
}

inline bool CTokenPrivileges::LookupPrivilege(LPCTSTR pszPrivilege, 
											  DWORD *pdwAttributes) const
{
	DWORD dwAttributes;
	LUID luid;

	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &luid))
		return false;

	if(m_TokenPrivileges.Lookup(luid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenPrivileges::GetNamesAndAttributes(CNames *pNames,
													CAttributes *pAttributes) const
{
	ATLASSERT(pNames);
	if(pNames)
	{
		LPTSTR psz = NULL;
		DWORD cbName = 0, cbTmp;
		const Map::CPair *pPair;

		pNames->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_TokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_TokenPrivileges.GetNext(pos);

			cbTmp = cbName;
			if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					delete[] psz;
					ATLTRY(psz = new TCHAR[cbTmp + 1]);
					if(!psz)
					{
						pNames->RemoveAll();
						if(pAttributes)
							pAttributes->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbName = cbTmp;
					if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
						break;
				}
				else
					break;

			pNames->Add(psz);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
		delete[] psz;

		if(pos)
		{
			pNames->RemoveAll();
			if(pAttributes)
				pAttributes->RemoveAll();
		}
	}
}

inline void CTokenPrivileges::GetDisplayNames(CNames *pDisplayNames) const
{
	ATLASSERT(pDisplayNames);
	if(pDisplayNames)
	{
		DWORD dwLang, cbTmp, cbDisplayName = 0;
		LPTSTR psz = NULL;
		CNames Names;
		int i;

		GetNamesAndAttributes(&Names);

		pDisplayNames->RemoveAll();

		for(i = 0; i < Names.GetSize(); i++)
		{
			cbTmp = cbDisplayName;
			if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
			{
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					delete[] psz;
					ATLTRY(psz = new TCHAR[cbTmp + 1]);
					if(!psz)
					{
						pDisplayNames->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbDisplayName = cbTmp;
					if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
						break;
				}
				else
					break;
			}
			pDisplayNames->Add(psz);
		}
		delete[] psz;

		if(i != Names.GetSize())
			pDisplayNames->RemoveAll();
	}
}

inline void CTokenPrivileges::GetLuidsAndAttributes(CLUIDArray *pLuids,
													CAttributes *pAttributes) const
{
	ATLASSERT(pLuids);
	if(pLuids)
	{
		const Map::CPair *pPair;

		pLuids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_TokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_TokenPrivileges.GetNext(pos);
			pLuids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

//******************************************************
// CTokenGroups
class CTokenGroups
{
public:
	CTokenGroups() : m_pTokenGroups(NULL), m_bDirty(true){}
	virtual ~CTokenGroups() {free(m_pTokenGroups);}

	CTokenGroups(const CTokenGroups &rhs);
	CTokenGroups &operator=(const CTokenGroups &rhs);

	CTokenGroups(const TOKEN_GROUPS &rhs) :
		m_pTokenGroups(NULL) {AddTokenGroups(rhs);}
	CTokenGroups &operator=(const TOKEN_GROUPS &rhs)
		{m_TokenGroups.RemoveAll(); AddTokenGroups(rhs); return *this;}

	void Add(const TOKEN_GROUPS &rTokenGroups)
		{AddTokenGroups(rTokenGroups);}
	void Add(const CSid &rSid, DWORD dwAttributes)
		{m_TokenGroups.SetAt(rSid, dwAttributes); m_bDirty = true;}

	bool LookupSid(const CSid &rSid, DWORD *pdwAttributes = NULL) const;
	void GetSidsAndAttributes(CSid::CSidArray *pSids,
		CSimpleArray<DWORD> *pAttributes = NULL) const;

	bool Delete(const CSid &rSid) {return m_TokenGroups.RemoveKey(rSid);}
	void DeleteAll(){m_TokenGroups.RemoveAll(); m_bDirty = true;}

	UINT GetCount() const {return (UINT) m_TokenGroups.GetCount();}

	UINT GetLength() const
		{return UINT(offsetof(TOKEN_GROUPS, Groups) +
			sizeof(SID_AND_ATTRIBUTES) * m_TokenGroups.GetCount());}

	const TOKEN_GROUPS *GetPTOKEN_GROUPS() const;
	operator const TOKEN_GROUPS *() const {return GetPTOKEN_GROUPS();}

private:
	class CTGElementTraits : 
		public CElementTraitsBase< CSid >
	{
	public:
		static UINT Hash(const CSid &sid)
			{return sid.GetSubAuthority(sid.GetSubAuthorityCount() - 1);}

		static bool CompareElements( INARGTYPE element1, INARGTYPE element2 ) throw()
		{
			return( element1 == element2 );
		}
	};

	typedef CAtlMap<CSid, DWORD, CTGElementTraits> Map;
	Map m_TokenGroups;
	mutable TOKEN_GROUPS *m_pTokenGroups;
	mutable bool m_bDirty;

	void AddTokenGroups(const TOKEN_GROUPS &rTokenGroups);
};

inline CTokenGroups::CTokenGroups(const CTokenGroups &rhs)
	: m_pTokenGroups(NULL), m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_TokenGroups.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_TokenGroups.GetNext(pos);
		m_TokenGroups.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenGroups &CTokenGroups::operator=(const CTokenGroups &rhs)
{
	if(this != &rhs)
	{
		m_TokenGroups.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_TokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_TokenGroups.GetNext(pos);
			m_TokenGroups.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const
{
	if(m_bDirty)
	{
		free(m_pTokenGroups);
		m_pTokenGroups = NULL;

		if(m_TokenGroups.GetCount())
		{
			m_pTokenGroups = static_cast<TOKEN_GROUPS *>(malloc(GetLength()));
			if(!m_pTokenGroups)
				return NULL;

			m_pTokenGroups->GroupCount = (DWORD) m_TokenGroups.GetCount();

			UINT i = 0;
			POSITION pos = m_TokenGroups.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				// REVIEW: see if there's a way to make sure that no one mucks with this
				// sid... (unlikely that anyone would, but possible)
				pPair = m_TokenGroups.GetNext(pos);
				m_pTokenGroups->Groups[i].Sid = const_cast<SID *>(pPair->m_key.GetPSID());
				m_pTokenGroups->Groups[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenGroups;
}

inline void CTokenGroups::AddTokenGroups(const TOKEN_GROUPS &rTokenGroups)
{
	m_bDirty = true;
	for(UINT i = 0; i < rTokenGroups.GroupCount; i++)
		m_TokenGroups.SetAt(
			CSid(static_cast<SID *>(rTokenGroups.Groups[i].Sid)),
			rTokenGroups.Groups[i].Attributes);
}

inline bool CTokenGroups::LookupSid(const CSid &rSid, DWORD *pdwAttributes) const
{
	DWORD dwAttributes;
	if(m_TokenGroups.Lookup(rSid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenGroups::GetSidsAndAttributes(CSid::CSidArray *pSids,
											   CSimpleArray<DWORD> *pAttributes) const
{
	ATLASSERT(pSids);
	if(pSids)
	{
		const Map::CPair *pPair;

		pSids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_TokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = m_TokenGroups.GetNext(pos);
			pSids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

// *************************************
// CAccessToken
class CAccessToken
{
public:
	CAccessToken() : m_hToken(NULL), m_hProfile(NULL), m_pRevert(NULL){}

	// REVIEW: should privileges that have been enabled be automatically
	// disabled in the dtor of CAccessToken?
	virtual ~CAccessToken();

	bool Attach(HANDLE hToken, bool bDuplicate = false,
		HANDLE hSrcProcess = NULL, HANDLE hDestProcess = NULL, bool bInherit = false);
	HANDLE Detach()
		{HANDLE hToken = m_hToken; m_hToken = NULL; Clear(); return hToken;}
	HANDLE GetHandle() const {return m_hToken;}
	HANDLE HKeyCurrentUser() const {return m_hProfile;}

	// Privileges
	bool EnablePrivilege(LPCTSTR pszPrivilege, CTokenPrivileges *pPreviousState = NULL);
	bool EnablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges,
		CTokenPrivileges *pPreviousState = NULL);
	bool DisablePrivilege(LPCTSTR pszPrivilege, CTokenPrivileges *pPreviousState = NULL);
	bool DisablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges, CTokenPrivileges *pPreviousState = NULL);
	bool EnableDisablePrivileges(const CTokenPrivileges &rPrivilenges,
		CTokenPrivileges *pPreviousState = NULL);
	bool PrivilegeCheck(PPRIVILEGE_SET RequiredPrivileges, bool *pbResult) const;
	
	bool GetLogonSid(CSid *pSid) const;
	bool GetTokenId(LUID *pluid) const;
	bool GetLogonSessionId(LUID *pluid) const;

	bool CheckTokenMembership(const CSid &rSid, bool *pbIsMember) const;
#if(_WIN32_WINNT >= 0x0500)
	bool IsTokenRestricted() const {return 0 != ::IsTokenRestricted(m_hToken);}
#endif

	// Token Information
protected:
	template<typename RET_T, typename INFO_T>
	void InfoTypeToRetType(RET_T *pRet, const INFO_T &rWork) const
		{ATLASSERT(pRet); *pRet = rWork;}
	template<>
	void InfoTypeToRetType(CDacl *pRet, const TOKEN_DEFAULT_DACL &rWork) const
		{ATLASSERT(pRet); *pRet = *rWork.DefaultDacl;}
	template<>
	void InfoTypeToRetType(CSid *pRet, const TOKEN_OWNER &rWork) const
		{ATLASSERT(pRet); *pRet = *static_cast<SID *>(rWork.Owner);}
	template<>
	void InfoTypeToRetType(CSid *pRet, const TOKEN_PRIMARY_GROUP &rWork) const
		{ATLASSERT(pRet); *pRet = *static_cast<SID *>(rWork.PrimaryGroup);}
	template<>
	void InfoTypeToRetType(CSid *pRet, const TOKEN_USER &rWork) const
		{ATLASSERT(pRet); *pRet = *static_cast<SID *>(rWork.User.Sid);}

	template<typename RET_T, typename INFO_T>
	bool GetInfoConvert(RET_T *pRet, TOKEN_INFORMATION_CLASS TokenClass, INFO_T *pWork = NULL) const
	{
		ATLASSERT(pRet);
		if(!pRet)
			return false;

		DWORD dwLen;
		::GetTokenInformation(m_hToken, TokenClass, NULL, 0, &dwLen);
		if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			return false;

		pWork = static_cast<INFO_T *>(_alloca(dwLen));
		if(!::GetTokenInformation(m_hToken, TokenClass, pWork, dwLen, &dwLen))
			return false;

		InfoTypeToRetType(pRet, *pWork);
		return true;
	}

	template<typename RET_T>
	bool GetInfo(RET_T *pRet, TOKEN_INFORMATION_CLASS TokenClass) const
	{
		ATLASSERT(pRet);
		if(!pRet)
			return false;

		DWORD dwLen;
		if(!::GetTokenInformation(m_hToken, TokenClass, pRet, sizeof(RET_T), &dwLen))
			return false;
		return true;
	}

public:
	bool GetDefaultDacl(CDacl *pDacl) const
		{return GetInfoConvert<CDacl, TOKEN_DEFAULT_DACL>(pDacl, TokenDefaultDacl);}
	bool GetGroups(CTokenGroups *pGroups) const
		{return GetInfoConvert<CTokenGroups, TOKEN_GROUPS>(pGroups, TokenGroups);}
	bool GetImpersonationLevel(SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const
		{return GetInfo<SECURITY_IMPERSONATION_LEVEL>(pImpersonationLevel, TokenImpersonationLevel);}
	bool GetOwner(CSid *pSid) const
		{return GetInfoConvert<CSid, TOKEN_OWNER>(pSid, TokenOwner);}
	bool GetPrimaryGroup(CSid *pSid) const
		{return GetInfoConvert<CSid, TOKEN_PRIMARY_GROUP>(pSid, TokenPrimaryGroup);}
	bool GetPrivileges(CTokenPrivileges *pPrivileges) const
		{return GetInfoConvert<CTokenPrivileges, TOKEN_PRIVILEGES>(pPrivileges, TokenPrivileges);}
	bool GetTerminalServicesSessionId(DWORD *pdwSessionId) const
		{return GetInfo<DWORD>(pdwSessionId, TokenSessionId);}
	bool GetSource(TOKEN_SOURCE *pSource) const
		{return GetInfo<TOKEN_SOURCE>(pSource, TokenSource);}
	bool GetStatistics(TOKEN_STATISTICS *pStatistics) const
		{return GetInfo<TOKEN_STATISTICS>(pStatistics, TokenStatistics);}
	bool GetType(TOKEN_TYPE *pType) const
		{return GetInfo<TOKEN_TYPE>(pType, TokenType);}
	bool GetUser(CSid *pSid) const
		{return GetInfoConvert<CSid, TOKEN_USER>(pSid, TokenUser);}

	bool SetOwner(const CSid &rSid);
	bool SetPrimaryGroup(const CSid &rSid);
	bool SetDefaultDacl(const CDacl &rDacl);

	bool CreateImpersonationToken(CAccessToken *pImp,
		SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) const;
	bool CreatePrimaryToken(CAccessToken *pPri,
		DWORD dwDesiredAccess = MAXIMUM_ALLOWED,
		const CSecurityAttributes *pTokenAttributes = NULL) const;

#if(_WIN32_WINNT >= 0x0500)
	bool CreateRestrictedToken(CAccessToken *pRestrictedToken,
		const CTokenGroups &SidsToDisable, const CTokenGroups &SidsToRestrict, 
		const CTokenPrivileges &PrivilegesToDelete = CTokenPrivileges()) const;
#endif

	// Token API type functions
	bool GetProcessToken(DWORD dwDesiredAccess, HANDLE hProcess = NULL);
	bool GetThreadToken(DWORD dwDesiredAccess, HANDLE hThread = NULL, bool bOpenAsSelf = true);
	bool GetEffectiveToken(DWORD dwDesiredAccess);

	bool OpenThreadToken(DWORD dwDesiredAccess,
		bool bImpersonate = false, bool bOpenAsSelf = true,
		SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation);

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 
	bool OpenCOMClientToken(DWORD dwDesiredAccess,
		bool bImpersonate = false, bool bOpenAsSelf = true);
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 

	bool OpenNamedPipeClientToken(HANDLE hPipe, DWORD dwDesiredAccess,
		bool bImpersonate = false, bool bOpenAsSelf = true);
	bool OpenRPCClientToken(RPC_BINDING_HANDLE BindingHandle, DWORD dwDesiredAccess,
		bool bImpersonate = false, bool bOpenAsSelf = true);

	bool ImpersonateLoggedOnUser() const;
	bool Impersonate(HANDLE hThread = NULL) const;
	bool Revert(HANDLE hThread = NULL) const;

	bool LoadUserProfile();
	HANDLE GetProfile() const {return m_hProfile;}

	// Must hold Tcb privilege
	bool LogonUser(
		LPCTSTR pszUserName, LPCTSTR pszDomain, LPCTSTR pszPassword,
		DWORD dwLogonType = LOGON32_LOGON_INTERACTIVE,
		DWORD dwLogonProvider = LOGON32_PROVIDER_DEFAULT);

	// Must hold AssignPrimaryToken (unless restricted token) and
	// IncreaseQuota privileges
	bool CreateProcessAsUser(
		LPCTSTR pApplicationName, LPTSTR pCommandLine,
		LPPROCESS_INFORMATION pProcessInformation,
		LPSTARTUPINFO pStartupInfo,
		DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS,
		bool bLoadProfile = false,
		const CSecurityAttributes *pProcessAttributes = NULL,
		const CSecurityAttributes *pThreadAttributes = NULL,
		bool bInherit = false,
		LPCTSTR pCurrentDirectory = NULL);

protected:
	bool EnableDisablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges,
		bool bEnable, CTokenPrivileges *pPreviousState);
	void CheckImpersonation() const;

	virtual void Clear();

	HANDLE m_hToken, m_hProfile;

private:
	// REVIEW: need copy?
	CAccessToken(const CAccessToken &rhs);
	CAccessToken &operator=(const CAccessToken &rhs);
	
	class CRevert
	{
	public:
		virtual bool Revert() = 0;
	};
	class CRevertToSelf : public CRevert
	{
	public:
		bool Revert(){return 0 != ::RevertToSelf();}
	};

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 
	class CCoRevertToSelf : public CRevert
	{
	public:
		bool Revert(){return SUCCEEDED(::CoRevertToSelf());}
	};
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 

	class CRpcRevertToSelfEx : public CRevert
	{
	public:
		CRpcRevertToSelfEx(RPC_BINDING_HANDLE BindingHandle)
			: m_BindingHandle(BindingHandle){}
		bool Revert(){return RPC_S_OK == ::RpcRevertToSelfEx(m_BindingHandle);}

	private:
		RPC_BINDING_HANDLE m_BindingHandle;
	};
	mutable CRevert *m_pRevert;
};

// *************************************
// CAccessToken implementation
inline CAccessToken::~CAccessToken()
{
	Clear();
}

inline bool CAccessToken::Attach(HANDLE hToken, bool bDuplicate,
								 HANDLE hSrcProcess, HANDLE hDestProcess, bool bInherit)
{
	ATLASSERT(hToken && hToken != m_hToken);
	if(hToken && hToken != m_hToken)
	{
		Clear();

		if(!bDuplicate)
		{
			m_hToken = hToken;
			return true;
		}
		else
		{
			if(!hSrcProcess)
				hSrcProcess = ::GetCurrentProcess();
			if(!hDestProcess)
				hDestProcess = ::GetCurrentProcess();

			return 0 != ::DuplicateHandle(hSrcProcess, hToken, hDestProcess, &m_hToken,
				0, bInherit, DUPLICATE_SAME_ACCESS);
		}
	}
	return false;
}

inline void CAccessToken::Clear()
{
	if(m_hProfile)
	{
		ATLASSERT(m_hToken);
		if(m_hToken)
			::UnloadUserProfile(m_hToken, m_hProfile);
		m_hProfile = NULL;
	}

	if(m_hToken)
	{
		::CloseHandle(m_hToken);
		m_hToken = NULL;
	}
	delete m_pRevert;
	m_pRevert = NULL;
}

inline bool CAccessToken::EnablePrivilege(LPCTSTR pszPrivilege,
										  CTokenPrivileges *pPreviousState)
{
	CTokenPrivileges NewState;
	return NewState.Add(pszPrivilege, true) &&
		EnableDisablePrivileges(NewState, pPreviousState);
}

inline bool CAccessToken::EnablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges,
										   CTokenPrivileges *pPreviousState)
{
	return EnableDisablePrivileges(rPrivileges, true, pPreviousState);
}

inline bool CAccessToken::DisablePrivilege(LPCTSTR pszPrivilege,
										   CTokenPrivileges *pPreviousState)
{
	CTokenPrivileges NewState;
	return NewState.Add(pszPrivilege, false) &&
		EnableDisablePrivileges(NewState, pPreviousState);
}

inline bool CAccessToken::DisablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges,
											CTokenPrivileges *pPreviousState)
{
	return EnableDisablePrivileges(rPrivileges, false, pPreviousState);
}

inline bool CAccessToken::EnableDisablePrivileges(const CSimpleArray<LPCTSTR> &rPrivileges,
												  bool bEnable, CTokenPrivileges *pPreviousState)
{
	CTokenPrivileges NewState;
	for(int i = 0; i < rPrivileges.GetSize(); i++)
		if(!NewState.Add(rPrivileges[i], bEnable))
			return false;
	return EnableDisablePrivileges(NewState, pPreviousState);
}

inline bool CAccessToken::EnableDisablePrivileges(const CTokenPrivileges &rNewState,
												  CTokenPrivileges *pPreviousState)
{
	if(!rNewState.GetCount())
		return true;

	TOKEN_PRIVILEGES *pNewState = const_cast<TOKEN_PRIVILEGES *>(rNewState.GetPTOKEN_PRIVILEGES());

	if(pPreviousState)
	{
		DWORD dwLength = offsetof(TOKEN_PRIVILEGES, Privileges) +
			rNewState.GetCount() * sizeof(LUID_AND_ATTRIBUTES);

		TOKEN_PRIVILEGES *pPrevState = static_cast<TOKEN_PRIVILEGES *>(_alloca(dwLength));
		if(!::AdjustTokenPrivileges(m_hToken, FALSE, pNewState, dwLength, pPrevState, &dwLength))
			return false;

		pPreviousState->Add(*pPrevState);
		return true;
	}
	else
		return 0 != ::AdjustTokenPrivileges(m_hToken, FALSE, pNewState, 0, NULL, NULL);
}

inline bool CAccessToken::PrivilegeCheck(PPRIVILEGE_SET RequiredPrivileges, bool *pbResult) const
{
	BOOL bResult;
	if(!::PrivilegeCheck(m_hToken, RequiredPrivileges, &bResult))
		return false;

	*pbResult = 0 != bResult;
	return true;
}

inline bool CAccessToken::GetProcessToken(DWORD dwDesiredAccess, HANDLE hProcess)
{
	if(!hProcess)
		hProcess = ::GetCurrentProcess();

	HANDLE hToken;
	if(!::OpenProcessToken(hProcess, dwDesiredAccess, &hToken))
		return false;

	Clear();
	m_hToken = hToken;
	return true;
}

inline bool CAccessToken::GetThreadToken(DWORD dwDesiredAccess,
										 HANDLE hThread, bool bOpenAsSelf)
{
	if(!hThread)
		hThread = ::GetCurrentThread();

	HANDLE hToken;
	if(!::OpenThreadToken(hThread, dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	return true;
}

inline bool CAccessToken::GetEffectiveToken(DWORD dwDesiredAccess)
{
	if(!GetThreadToken(dwDesiredAccess))
		return GetProcessToken(dwDesiredAccess);
	return true;
}

inline void CAccessToken::CheckImpersonation() const
{
#ifdef _DEBUG
	// You should not be impersonating at this point.  Use GetThreadToken
	// instead of the OpenXXXToken functions or call Revert before
	// calling Impersonate.
	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), 0, false, &hToken) &&
		::GetLastError() != ERROR_NO_TOKEN)
		ATLTRACE(atlTraceSecurity, 2, _T("Caution: replacing thread impersonation token.\n"));
#endif
}

inline bool CAccessToken::OpenThreadToken(DWORD dwDesiredAccess,
										  bool bImpersonate, bool bOpenAsSelf,
										  SECURITY_IMPERSONATION_LEVEL sil)
{
	CheckImpersonation();

	if(!::ImpersonateSelf(sil))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 
inline bool CAccessToken::OpenCOMClientToken(DWORD dwDesiredAccess,
											 bool bImpersonate, bool bOpenAsSelf)
{
	CheckImpersonation();

	if(FAILED(::CoImpersonateClient()))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::CoRevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CCoRevertToSelf);
		if(!m_pRevert)
		{
			::CoRevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 

inline bool CAccessToken::OpenNamedPipeClientToken(HANDLE hPipe, DWORD dwDesiredAccess,
												   bool bImpersonate, bool bOpenAsSelf)
{
	CheckImpersonation();

	if(!::ImpersonateNamedPipeClient(hPipe))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

inline bool CAccessToken::OpenRPCClientToken(RPC_BINDING_HANDLE BindingHandle,
											 DWORD dwDesiredAccess,
											 bool bImpersonate, bool bOpenAsSelf)
{
	CheckImpersonation();

	if(RPC_S_OK != ::RpcImpersonateClient(BindingHandle))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RpcRevertToSelfEx(BindingHandle);
	else
	{
		ATLTRY(m_pRevert = new CRpcRevertToSelfEx(BindingHandle));
		if(!m_pRevert)
		{
			::RpcRevertToSelfEx(BindingHandle);
			Clear();
			return false;
		}
	}
	return true;
}

inline bool CAccessToken::ImpersonateLoggedOnUser() const
{
	CheckImpersonation();

	ATLASSERT(m_hToken);
	if(m_hToken && ::ImpersonateLoggedOnUser(m_hToken))
	{
		ATLASSERT(!m_pRevert);
		delete m_pRevert;
		ATLTRY(m_pRevert = new CRevertToSelf);
		if (!m_pRevert)
		{
			::RevertToSelf();
			return false;
		}
		return true;
	}
	return false;
}

inline bool CAccessToken::Impersonate(HANDLE hThread) const
{
	CheckImpersonation();

	ATLASSERT(m_hToken);
	if(m_hToken)
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, m_hToken);
	return false;
}

inline bool CAccessToken::Revert(HANDLE hThread) const
{
	// REVIEW: What if *this* access token isn't the one that's currently doing
	// the impersonating?

	if(m_pRevert)
	{
		bool bRet = m_pRevert->Revert();
		delete m_pRevert;
		m_pRevert = NULL;
		return bRet;
	}
	else
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, NULL);
}

inline bool CAccessToken::LogonUser(LPCTSTR pszUserName,
									LPCTSTR pszDomain,
									LPCTSTR pszPassword,
									DWORD dwLogonType,
									DWORD dwLogonProvider)
{
	Clear();

	return 0 != ::LogonUser(
		const_cast<LPTSTR>(pszUserName),
		const_cast<LPTSTR>(pszDomain),
		const_cast<LPTSTR>(pszPassword),
		dwLogonType, dwLogonProvider, &m_hToken);
}

inline bool CAccessToken::LoadUserProfile()
{
	ATLASSERT(m_hToken && !m_hProfile);
	if(!m_hToken || m_hProfile)
		return false;

	CSid UserSid;
	PROFILEINFO Profile;

	if(!GetUser(&UserSid))
		return false;

	memset(&Profile, 0x00, sizeof(PROFILEINFO));
	Profile.dwSize = sizeof(PROFILEINFO);
	Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
	if(!::LoadUserProfile(m_hToken, &Profile))
		return false;

	m_hProfile = Profile.hProfile;

	return true;
}

inline bool CAccessToken::SetOwner(const CSid &rSid)

{	TOKEN_OWNER to;
	to.Owner = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenOwner, &to, sizeof(to));
}

inline bool CAccessToken::SetPrimaryGroup(const CSid &rSid)
{
	TOKEN_PRIMARY_GROUP tpg;
	tpg.PrimaryGroup = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenPrimaryGroup, &tpg, sizeof(tpg));
}

inline bool CAccessToken::SetDefaultDacl(const CDacl &rDacl)
{
	TOKEN_DEFAULT_DACL tdd;
	tdd.DefaultDacl = const_cast<ACL *>(rDacl.GetPACL());
	return 0 != ::SetTokenInformation(m_hToken, TokenDefaultDacl, &tdd, sizeof(tdd));
}

inline bool CAccessToken::CreateImpersonationToken(CAccessToken *pImp,
												   SECURITY_IMPERSONATION_LEVEL sil) const
{
	ATLASSERT(pImp);
	if(!pImp)
		return false;

	HANDLE hToken;
	if(!::DuplicateToken(m_hToken, sil, &hToken))
		return false;

	pImp->Clear();
	pImp->m_hToken = hToken;
	return true;
}

inline bool CAccessToken::CreatePrimaryToken(CAccessToken *pPri, DWORD dwDesiredAccess,
											 const CSecurityAttributes *pTokenAttributes) const
{
	ATLASSERT(pPri);
	if(!pPri)
		return false;

	HANDLE hToken;
	if(!::DuplicateTokenEx(m_hToken, dwDesiredAccess,
		const_cast<CSecurityAttributes *>(pTokenAttributes),
		SecurityAnonymous, TokenPrimary, &hToken))
	{
		return false;
	}

	pPri->Clear();
	pPri->m_hToken = hToken;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)

// REVIEW should this be something like
/*
inline bool CAccessToken::CreateRestrictedToken(CAccessToken *pRestrictedToken,
												const CSidArray &SidsToDisable,
												const CLUIDArray &PrivilegesToDelete,
												const CSidArray &SidsToRestrict) const*/
inline bool CAccessToken::CreateRestrictedToken(CAccessToken *pRestrictedToken,
												const CTokenGroups &SidsToDisable,
												const CTokenGroups &SidsToRestrict,
												const CTokenPrivileges &PrivilegesToDelete) const
{
	ATLASSERT(pRestrictedToken);
	if(!pRestrictedToken)
		return false;

	HANDLE hToken;
	SID_AND_ATTRIBUTES *pSidsToDisable;
	SID_AND_ATTRIBUTES *pSidsToRestrict;
	LUID_AND_ATTRIBUTES *pPrivilegesToDelete;

	DWORD dwDisableSidCount;
	DWORD dwDeletePrivilegesCount;
	DWORD dwRestrictedSidCount;
	
	if(dwDisableSidCount = SidsToDisable.GetCount())
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToDisable.GetPTOKEN_GROUPS();
		
		ATLASSERT(pTOKEN_GROUPS != NULL);
		
		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToDisable = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}
		
			
	}
	else
	{
		pSidsToDisable = NULL;
	}
	

	if(dwRestrictedSidCount = SidsToRestrict.GetCount())
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToRestrict.GetPTOKEN_GROUPS();
		
		ATLASSERT(pTOKEN_GROUPS != NULL);
		
		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToRestrict = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}
		
	}
	else
	{
		pSidsToRestrict = NULL;
	}
	
	if(dwDeletePrivilegesCount = PrivilegesToDelete.GetCount())
	{
		const TOKEN_PRIVILEGES * pTOKEN_PRIVILEGES = PrivilegesToDelete.GetPTOKEN_PRIVILEGES();
		
		ATLASSERT(pTOKEN_PRIVILEGES != NULL);
		
		if(pTOKEN_PRIVILEGES != NULL)
		{
			pPrivilegesToDelete = const_cast<LUID_AND_ATTRIBUTES *>
				(pTOKEN_PRIVILEGES->Privileges);
		}
		else
		{
			return false;
		}
		
	}
	else
	{
		pPrivilegesToDelete = NULL;
	}

	if(!::CreateRestrictedToken(m_hToken, 0,
		dwDisableSidCount, pSidsToDisable,
		dwDeletePrivilegesCount, pPrivilegesToDelete,
		dwRestrictedSidCount, pSidsToRestrict, &hToken))
	{
		return false;
	}

	pRestrictedToken->Clear();
	pRestrictedToken->m_hToken = hToken;
	return true;
}

#endif // _WIN32_WINNT >= 0x0500

inline bool CAccessToken::GetLogonSid(CSid *pSid) const
{
	ATLASSERT(pSid);
	if(!pSid)
		return false;

	DWORD dwLen;
	::GetTokenInformation(m_hToken, TokenGroups, NULL, 0, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return false;

	TOKEN_GROUPS *pGroups = static_cast<TOKEN_GROUPS *>(_alloca(dwLen));
	if(::GetTokenInformation(m_hToken, TokenGroups, pGroups, dwLen, &dwLen))
		for(UINT i = 0; i < pGroups->GroupCount; i++)
			if(pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID)
			{
				*pSid = *static_cast<SID *>(pGroups->Groups[i].Sid);
				return true;
			}
	return false;
}

inline bool CAccessToken::GetTokenId(LUID *pluid) const
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics;
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.TokenId;
	return true;
}

inline bool CAccessToken::GetLogonSessionId(LUID *pluid) const
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics;
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.AuthenticationId;
	return true;
}

inline bool CAccessToken::CheckTokenMembership(const CSid &rSid, bool *pbIsMember) const
{
	// "this" must be an impersonation token and NOT a primary token
	BOOL bIsMember;

	ATLASSERT(pbIsMember);
	if (!pbIsMember)
		return false;

#if(_WIN32_WINNT >= 0x0500)
	if(::CheckTokenMembership(m_hToken, const_cast<SID *>(rSid.GetPSID()), &bIsMember))
#else
	GENERIC_MAPPING gm = {0, 0, 0, 1};
	PRIVILEGE_SET ps;
	DWORD cb = sizeof(PRIVILEGE_SET);
	DWORD ga;
	CSecurityDesc sd;
	CDacl dacl;

	if (!dacl.AddAllowedAce(rSid, 1))
		return false;
	sd.SetOwner(rSid);
	sd.SetGroup(rSid);
	sd.SetDacl(dacl);

	if(::AccessCheck(const_cast<SECURITY_DESCRIPTOR *>(sd.GetPSECURITY_DESCRIPTOR()),
		m_hToken, 1, &gm, &ps, &cb, &ga, &bIsMember))
#endif
	{
		*pbIsMember = 0 != bIsMember;
		return true;
	}
	return false;
}

inline bool CAccessToken::CreateProcessAsUser(
		LPCTSTR pApplicationName, LPTSTR pCommandLine,
		LPPROCESS_INFORMATION pProcessInformation,
		LPSTARTUPINFO pStartupInfo,
		DWORD dwCreationFlags,
		bool bLoadProfile,
		const CSecurityAttributes *pProcessAttributes,
		const CSecurityAttributes *pThreadAttributes,
		bool bInherit,
		LPCTSTR pCurrentDirectory)
{
	LPVOID pEnvironmentBlock;
	PROFILEINFO Profile;
	CSid UserSid;

	HANDLE hToken = m_hToken;

	// Straighten out impersonation problems...
	TOKEN_TYPE TokenType;
	if(!GetType(&TokenType) &&
		TokenType != TokenPrimary &&
		!::DuplicateTokenEx(m_hToken, TOKEN_ALL_ACCESS, NULL,
			SecurityAnonymous, TokenPrimary, &hToken))
	{
		return false;
	}

	// Profile
	if(bLoadProfile && !m_hProfile)
	{
		if(!GetUser(&UserSid))
		{
			if(TokenType != TokenPrimary)
				::CloseHandle(hToken);
			return false;
		}
		memset(&Profile, 0x00, sizeof(PROFILEINFO));
		Profile.dwSize = sizeof(PROFILEINFO);
		Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
		if(::LoadUserProfile(hToken, &Profile))
			m_hProfile = Profile.hProfile;
	}

	// Environment block
	if(!::CreateEnvironmentBlock(&pEnvironmentBlock, hToken, bInherit))
		return false;

	BOOL bRetVal = ::CreateProcessAsUser(
		hToken,
		pApplicationName,
		pCommandLine,
		const_cast<CSecurityAttributes *>(pProcessAttributes),
		const_cast<CSecurityAttributes *>(pThreadAttributes),
		bInherit,
		dwCreationFlags,
		pEnvironmentBlock,
		pCurrentDirectory,
		pStartupInfo,
		pProcessInformation);

	if(TokenType != TokenPrimary)
		::CloseHandle(hToken);

	::DestroyEnvironmentBlock(pEnvironmentBlock);

	return bRetVal != 0;
}

//*******************************************
// Private Security
class CPrivateObjectSecurityDesc : public CSecurityDesc
{
public:
	CPrivateObjectSecurityDesc() : m_bPrivate(false), CSecurityDesc(){}
	~CPrivateObjectSecurityDesc() {Clear();}

	bool Create(const CSecurityDesc *pParent, const CSecurityDesc *pCreator,
		bool bIsDirectoryObject, const CAccessToken &Token, PGENERIC_MAPPING GenericMapping);

#if(_WIN32_WINNT >= 0x0500)
	bool Create(const CSecurityDesc *pParent, const CSecurityDesc *pCreator,
		GUID *ObjectType, bool bIsContainerObject, ULONG AutoInheritFlags,
		const CAccessToken &Token, PGENERIC_MAPPING GenericMapping);
#endif

	bool Get(SECURITY_INFORMATION si, CSecurityDesc *pResult) const;
	bool Set(SECURITY_INFORMATION si, const CSecurityDesc &Modification,
		PGENERIC_MAPPING GenericMapping, const CAccessToken &Token);

#if(_WIN32_WINNT >= 0x0500)
	bool Set(SECURITY_INFORMATION si, const CSecurityDesc &Modification,
		ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping,
		const CAccessToken &Token);

	bool ConvertToAutoInherit(const CSecurityDesc *pParent, GUID *ObjectType,
		bool bIsDirectoryObject, PGENERIC_MAPPING GenericMapping);
#endif

protected:
	void Clear();

private:
	bool m_bPrivate;

	CPrivateObjectSecurityDesc(const CPrivateObjectSecurityDesc &rhs);
	CPrivateObjectSecurityDesc &operator=(const CPrivateObjectSecurityDesc &rhs);
};

inline void CPrivateObjectSecurityDesc::Clear()
{
	if(m_bPrivate)
	{
		ATLVERIFY(::DestroyPrivateObjectSecurity(reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor)));
		m_bPrivate = false;
		m_pSecurityDescriptor = NULL;
	}
	else
		CSecurityDesc::Clear();
}

inline bool CPrivateObjectSecurityDesc::Create(const CSecurityDesc *pParent, const CSecurityDesc *pCreator,
											   bool bIsDirectoryObject, const CAccessToken &Token,
											   PGENERIC_MAPPING GenericMapping)
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		bIsDirectoryObject, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Create(const CSecurityDesc *pParent, const CSecurityDesc *pCreator,
											   GUID *ObjectType, bool bIsContainerObject, ULONG AutoInheritFlags,
											   const CAccessToken &Token, PGENERIC_MAPPING GenericMapping)
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurityEx(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		ObjectType, bIsContainerObject, AutoInheritFlags, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}
#endif

inline bool CPrivateObjectSecurityDesc::Get(SECURITY_INFORMATION si, CSecurityDesc *pResult) const
{
	ATLASSERT(pResult);
	if(!pResult)
		return false;

	if(!m_bPrivate)
		return false;

	DWORD dwLength = 0;
	SECURITY_DESCRIPTOR *pSDResult = NULL;

	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength) &&
		::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		return false;
	}

	pSDResult = (SECURITY_DESCRIPTOR *) _alloca(dwLength);
	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength))
		return false;

	*pResult = *pSDResult;

	return true;
}

inline bool CPrivateObjectSecurityDesc::Set(SECURITY_INFORMATION si, const CSecurityDesc &Modification,
											PGENERIC_MAPPING GenericMapping, const CAccessToken &Token)
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurity(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		GenericMapping, Token.GetHandle());
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Set(SECURITY_INFORMATION si, const CSecurityDesc &Modification,
											ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping,
											const CAccessToken &Token)
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurityEx(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		AutoInheritFlags, GenericMapping, Token.GetHandle());
}

inline bool CPrivateObjectSecurityDesc::ConvertToAutoInherit(const CSecurityDesc *pParent, GUID *ObjectType,
															 bool bIsDirectoryObject, PGENERIC_MAPPING GenericMapping)
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	SECURITY_DESCRIPTOR *pSD;

	if(!::ConvertToAutoInheritPrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		m_pSecurityDescriptor,
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD),
		ObjectType, bIsDirectoryObject, GenericMapping))
	{
		return false;
	}

	Clear();
	m_bPrivate = true;
	m_pSecurityDescriptor = pSD;

	return true;
}
#endif // _WIN32_WINNT >= 0x500

//*******************************************
// Globals
inline bool AtlGetSecurityDescriptor(LPCTSTR pszObjectName,
									 SE_OBJECT_TYPE ObjectType,
									 CSecurityDesc *pSecurityDescriptor)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	SECURITY_INFORMATION si =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	// Try SACL
	if(at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) &&
		at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges))
	{
		si |= SACL_SECURITY_INFORMATION;
	}

	// REVIEW: should *we* impersonate, or should we let the user impersonate?
	if(!at.Impersonate())
		return false;

	dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType, si,
		NULL, NULL, NULL, NULL, (PSECURITY_DESCRIPTOR *) &pSD);

	at.EnableDisablePrivileges(TokenPrivileges);

	if(dwErr != ERROR_SUCCESS && (si & SACL_SECURITY_INFORMATION))
	{
		// could be the SACL causing problems... try without
		si &= ~SACL_SECURITY_INFORMATION;
		dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType, si,
			NULL, NULL, NULL, NULL, (PSECURITY_DESCRIPTOR *) &pSD);
	}

	at.Revert();

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetSecurityDescriptor(HANDLE hObject,
									 SE_OBJECT_TYPE ObjectType,
									 CSecurityDesc *pSecurityDescriptor)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	SECURITY_INFORMATION si =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	// Try SACL
	if(at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) &&
		at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges))
	{
		si |= SACL_SECURITY_INFORMATION;
	}

	// REVIEW: should *we* impersonate, or should we let the user impersonate?
	if(!at.Impersonate())
		return false;

	dwErr = ::GetSecurityInfo(hObject, ObjectType, si,
		NULL, NULL, NULL, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD));

	at.EnableDisablePrivileges(TokenPrivileges);

	if(dwErr != ERROR_SUCCESS && (si & SACL_SECURITY_INFORMATION))
	{
		// could be the SACL causing problems... try without
		si &= ~SACL_SECURITY_INFORMATION;
		dwErr = ::GetSecurityInfo(hObject, ObjectType, si,
			NULL, NULL, NULL, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD));
	}

	at.Revert();

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetOwnerSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CSid *pSid)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION,
		(PSID *) &pOwner, NULL, NULL, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CSid &rSid)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION,
		const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetOwnerSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CSid *pSid)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		OWNER_SECURITY_INFORMATION, reinterpret_cast<PSID *>(&pOwner), NULL, NULL, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CSid &rSid)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		OWNER_SECURITY_INFORMATION, const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CSid *pSid)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION,
		NULL, reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CSid &rSid)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION,
		NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CSid *pSid)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName),
		ObjectType, GROUP_SECURITY_INFORMATION, NULL,
		reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CSid &rSid)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		GROUP_SECURITY_INFORMATION, NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CDacl *pDacl)
{
	ATLASSERT(hObject && pDacl);
	if(!hObject || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, DACL_SECURITY_INFORMATION,
		NULL, NULL, &pAcl, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CDacl &rDacl,
					   DWORD dwInheritanceFlowControl = 0)
{
	ATLASSERT(hObject);
	if(!hObject)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CDacl *pDacl)
{
	ATLASSERT(pszObjectName && pDacl);
	if(!pszObjectName || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		DACL_SECURITY_INFORMATION, NULL, NULL, &pAcl, NULL, &pSD);

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CDacl &rDacl,
					   DWORD dwInheritanceFlowControl = 0)
{
	ATLASSERT(pszObjectName);
	if(!pszObjectName)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CSacl *pSacl)
{
	ATLASSERT(hObject && pSacl);
	if(!hObject || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	// REVIEW: A LOT.  I'm wondering whether or not it's absolutely necessary to impersonate
	// the thread token here (rather than let the user do it or something).
	// Furthermore, should SecurityImpersonation be hard-coded?  Maybe it should be a param?
	if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) ||
		!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
		!at.Impersonate())
	{
		return false;
	}

	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, SACL_SECURITY_INFORMATION,
		NULL, NULL, NULL, &pAcl, &pSD);

	at.EnableDisablePrivileges(TokenPrivileges);

	at.Revert();

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CSacl &rSacl,
					   DWORD dwInheritanceFlowControl = 0)
{
	ATLASSERT(hObject);
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	// REVIEW: Should we be impersonating?
	if(!hObject ||
		!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) ||
		!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
		!at.Impersonate())
	{
		return false;
	}

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	at.EnableDisablePrivileges(TokenPrivileges);

	at.Revert();

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CSacl *pSacl)
{
	ATLASSERT(pszObjectName && pSacl);
	if(!pszObjectName || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	// REVIEW: Should we be impersonating?
	if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) ||
		!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
		!at.Impersonate())
	{
		return false;
	}

	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		SACL_SECURITY_INFORMATION, NULL, NULL, NULL, &pAcl, &pSD);

	at.EnableDisablePrivileges(TokenPrivileges);

	at.Revert();

	::SetLastError(dwErr);
	if(dwErr != ERROR_SUCCESS)
		return false;

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CSacl &rSacl,
					   DWORD dwInheritanceFlowControl = 0)
{
	ATLASSERT(pszObjectName);
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	// REVIEW: Should we be impersonating or should the user take care of this?
	if(!pszObjectName ||
		!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
			false, false, SecurityImpersonation) ||
		!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
		!at.Impersonate())
	{
		return false;
	}

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	at.EnableDisablePrivileges(TokenPrivileges);

	at.Revert();

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

} // namespace ATL

#endif // __ATLSECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsession.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSESSION_H__
#define __ATLSESSION_H__

#pragma once
#pragma warning(push)
#pragma warning(disable: 4702) // unreachable code

#include <atldbcli.h>
#include <atlcom.h>
#include <atlstr.h>
#include <stdio.h>
#include <atlcoll.h>
#include <atltime.h>
#include <atlcrypt.h>
#include <atlenc.h>
#include <atlutil.h>
#include <atlcache.h>
#include <atlspriv.h>
#include <atlsiface.h>

#ifndef SESSION_KEY_LENGTH 
	#define SESSION_KEY_LENGTH 37
#endif

#ifndef MAX_SESSION_KEY_LEN 
	#define MAX_SESSION_KEY_LEN 128
#endif

#ifndef MAX_VARIABLE_NAME_LENGTH 
	#define MAX_VARIABLE_NAME_LENGTH 50
#endif

#ifndef MAX_VARIABLE_VALUE_LENGTH 
	#define MAX_VARIABLE_VALUE_LENGTH 128
#endif

#ifndef DEFAULT_SQL_LEN
	#define DEFAULT_SQL_LEN 1024
#endif

#ifndef MAX_CONNECTION_STRING_LEN
	#define MAX_CONNECTION_STRING_LEN 2048
#endif

#ifndef SESSION_COOKIE_NAME
	#define SESSION_COOKIE_NAME "SESSIONID"
#endif

#ifndef ATL_SESSION_TIMEOUT
	#define ATL_SESSION_TIMEOUT 600000 //10 min
#endif

#ifndef ATL_SESSION_SWEEPER_TIMEOUT
	#define ATL_SESSION_SWEEPER_TIMEOUT 1000 // 1sec
#endif

#define INVALID_DB_SESSION_POS 0x0
#define ATL_DBSESSION_ID _T("__ATL_SESSION_DB_CONNECTION")


namespace ATL {

// CSessionNameGenerator
// This is a helper class that generates random data for session key
// names. This class tries to use the CryptoApi to generate random
// bytes for the session key name. If the CryptoApi isn't available
// then the CRT rand() is used to generate the random bytes. This
// class's GetNewSessionName member function is used to actually
// generate the session name.
class CSessionNameGenerator :
	public CCryptProv
{
public:
	bool m_bCryptNotAvailable;
	enum {MIN_SESSION_KEY_LEN=5};

	CSessionNameGenerator() throw() :
		m_bCryptNotAvailable(false)
	{
		// Note that the crypto api is being
		// initialized with no private key
		// information
		HRESULT hr = InitVerifyContext();
		m_bCryptNotAvailable = FAILED(hr) ? true : false;
	}

	// This function creates a new session name and base64 encodes it.
	// The base64 encoding algorithm used needs at least MIN_SESSION_KEY_LEN
	// bytes to work correctly. Since we stack allocate the temporary
	// buffer that holds the key name, the buffer must be less than or equal to
	// the MAX_SESSION_KEY_LEN in size.
	HRESULT GetNewSessionName(LPSTR szNewID, DWORD *pdwSize) throw()
	{
		HRESULT hr = E_FAIL;

		if (!pdwSize)
			return E_POINTER;

		if (*pdwSize < MIN_SESSION_KEY_LEN ||
			*pdwSize > MAX_SESSION_KEY_LEN)
			return E_INVALIDARG;

		if (!szNewID)
			return E_POINTER;
			
		BYTE key[MAX_SESSION_KEY_LEN] = {0x0};


		// calculate the number of bytes that will fit in the
		// buffer we've been passed
		DWORD dwDataSize = CalcMaxInputSize(*pdwSize);

		if (dwDataSize && *pdwSize >= (DWORD)(Base64EncodeGetRequiredLength(dwDataSize,
			ATL_BASE64_FLAG_NOCRLF)))
		{
			int dwKeySize = *pdwSize;
			hr = GenerateRandomName(key, dwDataSize);
			if (SUCCEEDED(hr))
			{
				if( Base64Encode(key,
								dwDataSize,
								szNewID,
                                &dwKeySize,
								ATL_BASE64_FLAG_NOCRLF) )
				{
					//null terminate
					szNewID[dwKeySize]=0;
					*pdwSize = dwKeySize+1;
				}
				else
					hr = E_FAIL;
			}
			else
			{
				*pdwSize = (DWORD)(Base64EncodeGetRequiredLength(dwDataSize,
					ATL_BASE64_FLAG_NOCRLF));
				return E_OUTOFMEMORY;
			}
		}
		return hr;
	}

	DWORD CalcMaxInputSize(DWORD nOutputSize) throw()
	{
		if (nOutputSize < (DWORD)MIN_SESSION_KEY_LEN)
			return 0;
		// subtract one from the output size to make room
		// for the NULL terminator in the output then
		// calculate the biggest number of input bytes that
		// when base64 encoded will fit in a buffer of size
		// nOutputSize (including base64 padding)
		int nInputSize = ((nOutputSize-1)*3)/4;
		int factor = ((nInputSize*4)/3)%4;
		if (factor)
			nInputSize -= factor;
		return nInputSize;
	}


	HRESULT GenerateRandomName(BYTE *pBuff, DWORD dwBuffSize) throw()
	{
		if (!pBuff)
			return E_POINTER;

		if (!dwBuffSize)
			return E_UNEXPECTED;

		if (!m_bCryptNotAvailable && GetHandle())
		{
			// Use the crypto api to generate random data.
			return GenRandom(dwBuffSize, pBuff);
		}

		// CryptoApi isn't available so we generate
		// random data using rand. We seed the random
		// number generator with a seed that is a combination
		// of bytes from an arbitrary number and the system
		// time which changes every millisecond so it will
		// be different for every call to this function.
		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);
		static DWORD dwVal = 0x21;
		DWORD dwSeed = (dwVal++ << 0x18) | (ft.dwLowDateTime & 0x00ffff00) | dwVal++ & 0x000000ff;
		srand(dwSeed);
		BYTE *pCurr = pBuff;
		// fill buffer with random bytes
		for (int i=0; i < (int)dwBuffSize; i++)
		{
			*pCurr = (BYTE) (rand() & 0x000000ff);
			pCurr++;
		}
		return S_OK;
	}
};


//
// CDefaultQueryClass
// returns Query strings for use in SQL queries used 
// by the database persisted session service.
class CDefaultQueryClass
{
public:
	LPCTSTR GetSessionRefDelete() throw()
	{
		return 	_T("DELETE FROM SessionReferences ")
				_T("WHERE SessionID=? AND RefCount <= 0 ")
				_T("AND DATEDIFF(millisecond,  LastAccess, getdate()) > TimeoutMs");
	}

	LPCTSTR GetSessionRefIsExpired() throw()
	{
		return _T("SELECT SessionID FROM SessionReferences ")
			   _T("WHERE (SessionID=?) AND (DATEDIFF(millisecond,  LastAccess, getdate()) > TimeoutMs)");
	}

	LPCTSTR GetSessionRefDeleteFinal() throw()
	{
		return _T("DELETE FROM SessionReferences ")
			   _T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefCreate() throw()
	{
		return _T("INSERT INTO SessionReferences ")
			_T("(SessionID, LastAccess, RefCount, TimeoutMs) ")
			_T("VALUES (?, getdate(), 1, ?)");
	}

	LPCTSTR GetSessionRefUpdateTimeout() throw()
	{
		return _T("UPDATE SessionReferences ")
			   _T("SET TimeoutMs=? WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefAddRef() throw()
	{
		return _T("UPDATE SessionReferences ")
			_T("SET RefCount=RefCount+1, ")
			_T("LastAccess=getdate() ")
			_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefRemoveRef() throw()
	{
		return _T("UPDATE SessionReferences ")
					_T("SET RefCount=RefCount-1, ")
					_T("LastAccess=getdate() ")
					_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefAccess() throw()
	{
		return 	_T("UPDATE SessionReferences ")
				_T("SET LastAccess=getdate() ")
				_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefSelect() throw()
	{
		return _T("SELECT * FROM SessionReferences ")
			   _T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefGetCount() throw()
	{
		return 	_T("SELECT COUNT(*) FROM SessionReferences");
	}


	LPCTSTR GetSessionVarCount() throw()
	{
		return _T("SELECT COUNT(*) FROM SessionVariables WHERE SessionID=?");
	}

	LPCTSTR GetSessionVarInsert() throw()
	{
		return  _T("INSERT INTO SessionVariables ")
				_T("(VariableValue, SessionID, VariableName) ")
				_T("VALUES (?, ?, ?)");
	}

	LPCTSTR GetSessionVarUpdate() throw()
	{
		return 	_T("UPDATE SessionVariables ")
				_T("SET VariableValue=? ")
				_T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarDeleteVar() throw()
	{
		return _T("DELETE FROM SessionVariables ")
				_T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarDeleteAllVars() throw()
	{
		return _T("DELETE FROM SessionVariables WHERE (SessionID=?)");
	}

	LPCTSTR GetSessionVarSelectVar()throw()
	{
		return _T("SELECT SessionID, VariableName, VariableValue ")
			   _T("FROM SessionVariables ")
			   _T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarSelectAllVars() throw()
	{
		return _T("SELECT SessionID, VariableName, VariableValue ")
				_T("FROM SessionVariables ")
				_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionReferencesSet() throw()
	{
		return _T("UPDATE SessionReferences SET TimeoutMs=?");
	}
};


// Contains the data for the session variable accessors
class CSessionDataBase
{
public:
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_VariableName[MAX_VARIABLE_NAME_LENGTH];
	BYTE m_VariableValue[MAX_VARIABLE_VALUE_LENGTH];
	DWORD m_VariableLen;
	CSessionDataBase() throw()
	{
		m_szSessionID[0] = '\0';
		m_VariableName[0] = '\0';
		m_VariableValue[0] = '\0';
		m_VariableLen = 0;
	}
	HRESULT Assign(LPCTSTR szSessionID, LPCTSTR szVarName, VARIANT *pVal) throw()
	{
		HRESULT hr = S_OK;
		CVariantStream stream;
		if ( szSessionID )
		{
			if ( _tcslen(szSessionID)< MAX_SESSION_KEY_LEN)
				_tcscpy(m_szSessionID, szSessionID);
			else
				hr = E_OUTOFMEMORY;
		}
		else
			return E_INVALIDARG;

		if (szVarName)
			if ( _tcslen(szVarName) < MAX_VARIABLE_NAME_LENGTH)
				_tcscpy(m_VariableName, szVarName);
			else
				hr = E_OUTOFMEMORY;
		
		if (pVal)
		{
			hr = stream.InsertVariant(pVal);
			if (hr == S_OK)
			{
				BYTE *pBytes = stream.m_stream;
				size_t size = stream.GetVariantSize();
				if (pBytes && size && size < MAX_VARIABLE_VALUE_LENGTH)
				{
					memcpy(m_VariableValue, pBytes, stream.GetVariantSize());
					m_VariableLen = (DWORD)size;
				}
				else
					hr = E_UNEXPECTED;
			}
		}

		return hr;
	}
};

// Use to select a session variable given the name
// of a session and the name of a variable.
class CSessionDataSelector : public CSessionDataBase
{
public:
	BEGIN_COLUMN_MAP(CSessionDataSelector) 
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
		COLUMN_ENTRY_LENGTH(3, m_VariableValue, m_VariableLen)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionDataSelector) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
	END_PARAM_MAP()
};

// Use to select all session variables given the name of
// of a session.
class CAllSessionDataSelector : public CSessionDataBase
{
public:
	BEGIN_COLUMN_MAP(CAllSessionDataSelector) 
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
		COLUMN_ENTRY_LENGTH(3, m_VariableValue, m_VariableLen)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CAllSessionDataSelector) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};

// Use to update the value of a session variable
class CSessionDataUpdator : public CSessionDataBase
{
public:
	BEGIN_PARAM_MAP(CSessionDataUpdator) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY_LENGTH(1, m_VariableValue, m_VariableLen)
		COLUMN_ENTRY(2, m_szSessionID)
		COLUMN_ENTRY(3, m_VariableName)
	END_PARAM_MAP()
};

// Use to delete a session variable given the
// session name and the name of the variable
class CSessionDataDeletor
{
public:
	CSessionDataDeletor()
	{
		m_szSessionID[0] = '\0';
		m_VariableName[0] = '\0';
	}

	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_VariableName[MAX_VARIABLE_NAME_LENGTH];
	HRESULT Assign(LPCTSTR szSessionID, LPCTSTR szVarName) throw()
	{
		if (szSessionID)
		{
			if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
				_tcscpy(m_szSessionID, szSessionID);
			else
				return E_OUTOFMEMORY;
		}

		if (szVarName)
		{
			if(_tcslen(szVarName) < MAX_VARIABLE_NAME_LENGTH)
				_tcscpy(m_VariableName, szVarName);
			else
				return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionDataDeletor) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
	END_PARAM_MAP()
};

class CSessionDataDeleteAll
{
public:
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_szSessionID, szSessionID);
		else
			return E_OUTOFMEMORY;

		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionDataDeleteAll) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};

// Used for retrieving the count of session variables for
// a given session ID.
class CCountAccessor
{
public:
	LONG m_nCount;
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	CCountAccessor() throw()
	{
		m_szSessionID[0] = '\0';
		m_nCount = 0;
	}

	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_szSessionID, szSessionID);
		else
			return E_OUTOFMEMORY;

		return S_OK;
	}

	BEGIN_COLUMN_MAP(CCountAccessor)
		COLUMN_ENTRY(1, m_nCount)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CCountAccessor)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};


// Used for updating entries in the session
// references table, given a session ID
class CSessionRefUpdator
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_SessionID, szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSessionRefUpdator)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefIsExpired
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_SessionIDOut[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		m_SessionIDOut[0]=0;
		if (!szSessionID)
			return E_INVALIDARG;
		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_SessionID, szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_COLUMN_MAP(CSessionRefIsExpired)
		COLUMN_ENTRY(1, m_SessionIDOut)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionRefIsExpired)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSetAllTimeouts
{
public:
	unsigned __int64 m_dwNewTimeout;
	HRESULT Assign(unsigned __int64 dwNewValue)
	{
		m_dwNewTimeout = dwNewValue;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSetAllTimeouts)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_dwNewTimeout)
	END_PARAM_MAP()
};

class CSessionRefUpdateTimeout
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_nNewTimeout;
	HRESULT Assign(LPCTSTR szSessionID, unsigned __int64 nNewTimeout) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_SessionID, szSessionID);
		else
			return E_OUTOFMEMORY;

		m_nNewTimeout = nNewTimeout;

		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionRefUpdateTimeout)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_nNewTimeout)
		COLUMN_ENTRY(2, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefSelector
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	int m_RefCount;
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
			_tcscpy(m_SessionID, szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_COLUMN_MAP(CSessionRefSelector)
		COLUMN_ENTRY(1, m_SessionID)
		COLUMN_ENTRY(3, m_RefCount)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionRefSelector)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefCount
{
public:
	LONG m_nCount;
	BEGIN_COLUMN_MAP(CSessionRefCount)
		COLUMN_ENTRY(1, m_nCount)
	END_COLUMN_MAP()
};

// Used for creating new entries in the session
// references table.
class CSessionRefCreator
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_TimeoutMs;
	HRESULT Assign(LPCTSTR szSessionID, unsigned __int64 timeout) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (_tcslen(szSessionID) < MAX_SESSION_KEY_LEN)
		{
			_tcscpy(m_SessionID, szSessionID);
			m_TimeoutMs = timeout;
		}
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSessionRefCreator)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
		COLUMN_ENTRY(2, m_TimeoutMs)
	END_PARAM_MAP()
};


// CDBSession
// This session persistance class persists session variables to
// an OLEDB datasource. The following table gives a general description
// of the table schema for the tables this class uses.
//
// TableName: SessionVariables
// Column		Name			Type							Description
// 1			SessionID		char[MAX_SESSION_KEY_LEN]		Session Key name
// 2			VariableName	char[MAX_VARIABLE_NAME_LENGTH]	Variable Name
// 3			VariableValue	varbinary[MAX_VARIABLE_VALUE_LENGTH]	Variable Value

//
// TableName: SessionReferences
// Column		Name			Type							Description
// 1			SessionID		char[MAX_SESSION_KEY_LEN]		Session Key Name.
// 2			LastAccess		datetime						Date and time of last access to this session.
// 3			RefCount		int								Current references on this session.
// 4			TimeoutMS		int								Timeout value for the session in milli seconds

typedef bool (*PFN_GETPROVIDERINFO)(DWORD_PTR, wchar_t **);

template <class QueryClass=CDefaultQueryClass>
class CDBSession:
	public ISession,
	public CComObjectRootEx<CComGlobalsThreadModel>

{
	typedef CCommand<CAccessor<CAllSessionDataSelector> >  iterator_accessor;
public:
	typedef QueryClass DBQUERYCLASS_TYPE;
	BEGIN_COM_MAP(CDBSession)
		COM_INTERFACE_ENTRY(ISession)
	END_COM_MAP()

	CDBSession() throw():
		m_dwTimeout(ATL_SESSION_TIMEOUT)
	{
		m_szSessionName[0] = '\0';
	}

	~CDBSession() throw()
	{
	}

	void FinalRelease()throw()
	{
		SessionUnlock();
	}

	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT Val) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate an updator command and fill out it's input parameters.
		CCommand<CAccessor<CSessionDataUpdator> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name, &Val);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
		if (hr != S_OK)
			return hr;

		// Try an update. Update will fail if the variable is not already there.
		LONG nRows = 0;

		hr = command.Open(dataconn, 
						m_QueryObj.GetSessionVarUpdate(),
						NULL, &nRows, DBGUID_DEFAULT, false);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;
		if (hr != S_OK)
		{
			// Try an insert
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarInsert(), NULL, &nRows, DBGUID_DEFAULT, false);
			if (hr == S_OK && nRows <=0)
				hr = E_UNEXPECTED;
		}

		return hr;
	}

	// Warning: For string data types, depending on the configuration of
	// your database, strings might be returned with trailing white space.
	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;
		if (pVal)
			VariantClear(pVal);
		else
			return E_POINTER;

		// Get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate a command a fill out it's input parameters.
		CCommand<CAccessor<CSessionDataSelector> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name, NULL);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		if (hr == S_OK)
		{
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarSelectVar());
			if (SUCCEEDED(hr))
			{
				if ( S_OK == (hr = command.MoveFirst()))
				{
					CStreamOnByteArray stream(command.m_VariableValue);
					CComVariant vOut;
					hr = vOut.ReadFromStream(static_cast<IStream*>(&stream));
					if (hr == S_OK)
						hr = vOut.Detach(pVal);
				}
			}
		}
		return hr;
	}

	STDMETHOD(RemoveVariable)(LPCSTR szName) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// allocate a command and set it's input parameters
		CCommand<CAccessor<CSessionDataDeletor> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name);
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}

		// execute the command
		long nRows = 0;
		if (hr == S_OK)
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarDeleteVar(),
			NULL, &nRows, DBGUID_DEFAULT, false);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;
		return hr;
	}

	// Gives the count of rows in the table for this session ID.
	STDMETHOD(GetCount)(long *pnCount) throw()
	{
		HRESULT hr = S_OK;
		if (pnCount)
			*pnCount = 0;
		else
			return E_POINTER;

		// Get the database connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;
		hr = Access();
		if (hr != S_OK)
			return hr;
		CCommand<CAccessor<CCountAccessor> > command;
		
		hr = command.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarCount());
			if (hr == S_OK)
			{
				if (S_OK == (hr = command.MoveFirst()))
				{
					*pnCount = command.m_nCount;
					hr = S_OK;
				}
			}
		}
		return hr;
	}

	STDMETHOD(RemoveAllVariables)() throw()
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionDataDeleteAll> > command;
		hr = command.Assign(m_szSessionName);
		if (hr != S_OK)
			return hr;

		// delete all session variables
		hr = command.Open(dataconn, m_QueryObj.GetSessionVarDeleteAllVars(), NULL, NULL, DBGUID_DEFAULT, false);
		return hr;
	}

	// Iteration of variables works by taking a snapshot
	// of the sessions at the point in time BeginVariableEnum
	// is called, and then keeping an index variable that you use to
	// move through the snapshot rowset. It is important to know
	// that the handle returned in phEnum is not thread safe. It
	// should only be used by the calling thread.
	STDMETHOD(BeginVariableEnum)(HSESSIONENUM *phEnum, POSITION *pPOS) throw()
	{
		HRESULT hr = E_FAIL;
		if (!pPOS)
			return E_POINTER;

		if (phEnum)
			*phEnum = NULL;
		else
			return E_POINTER;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session.
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate a new iterator accessor and initialize it's input parameters.
		iterator_accessor *pIteratorAccessor = NULL;
		ATLTRYALLOC(pIteratorAccessor = new iterator_accessor);
		if (!pIteratorAccessor)
			return E_OUTOFMEMORY;

		hr = pIteratorAccessor->Assign(m_szSessionName, NULL, NULL);
		if (hr == S_OK)
		{
			// execute the command and move to the first row of the recordset.
			hr = pIteratorAccessor->Open(dataconn, 
								m_QueryObj.GetSessionVarSelectAllVars());
			if (hr == S_OK)
			{
				hr = pIteratorAccessor->MoveFirst();
				if (hr == S_OK)
				{
					*pPOS = (POSITION) INVALID_DB_SESSION_POS + 1;
					*phEnum = reinterpret_cast<HSESSIONENUM>(pIteratorAccessor);
				}
			}

			if (hr != S_OK)
			{
				*pPOS = INVALID_DB_SESSION_POS;
				*phEnum = NULL;
				delete pIteratorAccessor;
			}
		}
		return hr;
	}

	// The values for hEnum and pPos must have been initialized in a previous
	// call to BeginVariableEnum. On success, the out variant will hold the next
	// variable
	STDMETHOD(GetNextVariable)(HSESSIONENUM hEnum, POSITION *pPOS, LPSTR szName, DWORD dwLen, VARIANT *pVal) throw()
	{
		if (!pPOS)
			return E_INVALIDARG;

		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		if (!hEnum)
			return E_UNEXPECTED;

		if (*pPOS <= INVALID_DB_SESSION_POS)
			return E_UNEXPECTED;

		iterator_accessor *pIteratorAccessor = reinterpret_cast<iterator_accessor*>(hEnum);

		// update the last access time.
		HRESULT hr = Access();

		POSITION posCurrent = *pPOS;
		
		if (szName)
		{
			// caller wants entry name
			size_t nNameLenChars = _tcslen(pIteratorAccessor->m_VariableName);
			if (dwLen > nNameLenChars)
			{
				_ATLTRY
				{
					CT2CA szVarName(pIteratorAccessor->m_VariableName);
					strcpy(szName, szVarName);
				}
				_ATLCATCHALL()
				{
					hr = E_OUTOFMEMORY;
				}
			}
			else
				hr = E_OUTOFMEMORY; // buffer not big enough
		}

		if (hr == S_OK)
		{
			CStreamOnByteArray stream(pIteratorAccessor->m_VariableValue);
			CComVariant vOut;
			hr = vOut.ReadFromStream(static_cast<IStream*>(&stream));
			if (hr == S_OK)
				vOut.Detach(pVal);
			else
				return hr;
		}
		else
			return hr;

		hr = pIteratorAccessor->MoveNext();
		*pPOS = ++posCurrent;

		if (hr == DB_S_ENDOFROWSET)
		{
			// We're done iterating, reset everything
			*pPOS = INVALID_DB_SESSION_POS;
			hr = S_OK;
		}

		if (hr != S_OK)
		{
			VariantClear(pVal);
		}
		return hr;
	}

	// CloseEnum frees up any resources allocated by the iterator
	STDMETHOD(CloseEnum)(HSESSIONENUM hEnum) throw()
	{
		iterator_accessor *pIteratorAccessor = reinterpret_cast<iterator_accessor*>(hEnum);
		if (!pIteratorAccessor)
			return E_INVALIDARG;
		pIteratorAccessor->Close();
		delete pIteratorAccessor;
		return S_OK;
	}

	//
	// Returns S_FALSE if it's not expired
	// S_OK if it is expired and an error HRESULT
	// if an error occurred.
	STDMETHOD(IsExpired)() throw()
	{
		HRESULT hrRet = S_FALSE;
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionRefIsExpired> > command;
		hr = command.Assign(m_szSessionName);
		if (hr != S_OK)
			return hr;

		hr = command.Open(dataconn, m_QueryObj.GetSessionRefIsExpired(), 
							NULL, NULL, DBGUID_DEFAULT, true);
		if (hr == S_OK)
		{
			if (S_OK == command.MoveFirst())
			{
				if (!_tcscmp(command.m_SessionIDOut, m_szSessionName))
					hrRet = S_OK;
			}
		}

		if (hr == S_OK)
			return hrRet;
		return hr;
	}

	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout) throw()
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// allocate a command and set it's input parameters
		CCommand<CAccessor<CSessionRefUpdateTimeout> > command;
		hr = command.Assign(m_szSessionName, dwNewTimeout);
		if (hr != S_OK)
			return hr;

		hr = command.Open(dataconn, m_QueryObj.GetSessionRefUpdateTimeout(),
						NULL, NULL, DBGUID_DEFAULT, false);

		return hr;
	}

	// SessionLock increments the session reference count for this session.
	// If there is not a session by this name in the session references table,
	// a new session entry is created in the the table.
	HRESULT SessionLock() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName || m_szSessionName[0]==0)
			return hr; // no session to lock.

		// retrieve the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// first try to update a session with this name
		LONG nRows = 0;
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		if (S_OK == updator.Assign(m_szSessionName))
		{
			if (S_OK != (hr = updator.Open(dataconn, m_QueryObj.GetSessionRefAddRef(),
				NULL, &nRows, DBGUID_DEFAULT, false)) ||
				nRows == 0)
			{
				// No session to update. Use the creator accessor
				// to create a new session reference.
				CCommand<CAccessor<CSessionRefCreator> > creator;
				hr = creator.Assign(m_szSessionName, m_dwTimeout);
				if (hr == S_OK)
					hr = creator.Open(dataconn, m_QueryObj.GetSessionRefCreate(),
					NULL, &nRows, DBGUID_DEFAULT, false);
			}
		}

		// We should have been able to create or update a session.
		ATLASSERT(nRows > 0);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;

		return hr;
	}

	// SessionUnlock decrements the session RefCount for this session.
	// Sessions cannot be removed from the database unless the session
	// refcount is 0
	HRESULT SessionUnlock() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName ||
			m_szSessionName[0]==0)
			return hr; 

		// get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// The session must exist at this point in order to unlock it
		// so we can just use the session updator here.
		LONG nRows = 0;
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		hr = updator.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = updator.Open(	dataconn,
								m_QueryObj.GetSessionRefRemoveRef(),
								NULL,
								&nRows,
								DBGUID_DEFAULT,
								false);
		}
		if (hr != S_OK)
			return hr;

        // delete the session from the database if 
		// nobody else is using it and it's expired.
		hr = FreeSession();
		return hr;
	}

	// Access updates the last access time for the session. The access
	// time for sessions is updated using the SQL GETDATE function on the
	// database server so that all clients will be using the same clock
	// to compare access times against.
	HRESULT Access() throw()
	{
		HRESULT hr = E_UNEXPECTED;

		if (!m_szSessionName || 
			m_szSessionName[0]==0)
			return hr; // no session to access

		// get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// The session reference entry in the references table must
		// be created prior to calling this function so we can just
		// use an updator to update the current entry.
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		
		LONG nRows = 0;
		hr = updator.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = updator.Open(	dataconn,
								m_QueryObj.GetSessionRefAccess(),
								NULL,
								&nRows,
								DBGUID_DEFAULT,
								false);
		}

		ATLASSERT(nRows > 0);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;
		return hr;
	}

	// If the session is expired and it's reference is 0,
	// it can be deleted. SessionUnlock calls this function to
	// unlock the session and delete it after we release a session
	// lock. Note that our SQL command will only delete the session
	// if it is expired and it's refcount is <= 0
	HRESULT FreeSession() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName ||
			m_szSessionName[0]==0)
			return hr;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionRefUpdator> > updator;

		// The SQL for this command only deletes the
		// session reference from the references table if it's access
		// count is 0 and it has expired.
		return updator.Open(dataconn,
							m_QueryObj.GetSessionRefDelete(),
							NULL,
							NULL,
							DBGUID_DEFAULT,
							false);
	}

	// Initialize is called each time a new session is created.
	HRESULT Initialize( LPCSTR szSessionName, 
						IServiceProvider *pServiceProvider,
						DWORD_PTR dwCookie,
						PFN_GETPROVIDERINFO pfnInfo) throw()
	{
		if (!szSessionName)
			return E_INVALIDARG;

		if (!pServiceProvider)
			return E_INVALIDARG;

		if (!pfnInfo)
			return E_INVALIDARG;

		m_pfnInfo = pfnInfo;
		m_dwProvCookie = dwCookie;
		m_spServiceProvider = pServiceProvider;

		_ATLTRY
		{
			CA2CT tcsSessionName(szSessionName);
			if (_tcslen(tcsSessionName) < MAX_SESSION_KEY_LEN)
				_tcscpy(m_szSessionName, tcsSessionName);
			else
				return E_OUTOFMEMORY;
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}
		return SessionLock();
	}

	HRESULT GetSessionConnection(CDataConnection *pConn,
        					     IServiceProvider *pProv) throw()
	{
		if (!pProv)
			return E_INVALIDARG;
		
		if (!m_pfnInfo || 
			!m_dwProvCookie)
			return E_UNEXPECTED;

		wchar_t *wszProv = NULL;
		if (m_pfnInfo(m_dwProvCookie, &wszProv) && wszProv!=NULL)
		{
			return GetDataSource(pProv,
						ATL_DBSESSION_ID,
						wszProv,
						pConn);
		}
		return E_FAIL;
	}


protected:
	TCHAR m_szSessionName[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_dwTimeout;
	CComPtr<IServiceProvider> m_spServiceProvider;
	DWORD_PTR m_dwProvCookie;
	PFN_GETPROVIDERINFO m_pfnInfo;
	DBQUERYCLASS_TYPE m_QueryObj;
}; // CDBSession


template <class TDBSession=CDBSession<> >
class CDBSessionServiceImplT
{
	wchar_t m_szConnectionString[MAX_CONNECTION_STRING_LEN];
	CComPtr<IServiceProvider> m_spServiceProvider;
	TDBSession::DBQUERYCLASS_TYPE m_QueryObj;
public:
	typedef const wchar_t* SERVICEIMPL_INITPARAM_TYPE;
	CDBSessionServiceImplT() throw()
	{
		m_dwTimeout = ATL_SESSION_TIMEOUT;
		m_szConnectionString[0] = '\0';
	}

	static bool GetProviderInfo(DWORD_PTR dwProvCookie, wchar_t **ppszProvInfo) throw()
	{
		if (dwProvCookie &&
			ppszProvInfo)
		{
			CDBSessionServiceImplT<TDBSession> *pSvc = 
				reinterpret_cast<CDBSessionServiceImplT<TDBSession>*>(dwProvCookie);
			*ppszProvInfo = pSvc->m_szConnectionString;
			return true;
		}
		return false;
	}

	HRESULT GetSessionConnection(CDataConnection *pConn,
        					     IServiceProvider *pProv) throw()
	{
		if (!pProv)
			return E_INVALIDARG;

		if(!m_szConnectionString[0])
			return E_UNEXPECTED;
		
		return GetDataSource(pProv,
					ATL_DBSESSION_ID,
					m_szConnectionString,
					pConn);
	}

	HRESULT Initialize(SERVICEIMPL_INITPARAM_TYPE pData,
						IServiceProvider *pProvider,
						unsigned __int64 dwInitialTimeout) throw()
	{
		if (!pData || !pProvider)
			return E_INVALIDARG;

		if (wcslen(pData) < MAX_CONNECTION_STRING_LEN)
		{
			wcscpy(m_szConnectionString, pData); 
		}
		else
			return E_OUTOFMEMORY;

		m_dwTimeout = dwInitialTimeout;
		m_spServiceProvider = pProvider;
		return S_OK;
	}

	HRESULT CreateNewSession(LPSTR szNewID, DWORD *pdwSize, ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<TDBSession> *pNewSession = NULL;

		if (!pdwSize)
			return E_INVALIDARG;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		if (szNewID)
			*szNewID = NULL;
		else
			return E_INVALIDARG;


		// Create new session
		CComObject<TDBSession>::CreateInstance(&pNewSession);
		if (pNewSession == NULL)
			return E_OUTOFMEMORY;

		// Create a session name and initialize the object
		hr = m_SessionNameGenerator.GetNewSessionName(szNewID, pdwSize);
		if (hr == S_OK)
		{
			hr = pNewSession->Initialize(szNewID, 
										m_spServiceProvider,
										reinterpret_cast<DWORD_PTR>(this),
										GetProviderInfo);
			if (hr == S_OK)
			{
				// we don't hold a reference to the object
				hr = pNewSession->QueryInterface(ppSession);
			}
		}

		if (hr != S_OK)
			delete pNewSession;
		return hr;
	}

	HRESULT GetSession(LPCSTR szID, ISession **ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szID)
			return E_INVALIDARG;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		CComObject<TDBSession> *pNewSession = NULL;

		// Check the DB to see if the session ID is a valid session
		_ATLTRY
		{
			CA2CT session(szID);
			hr = IsValidSession(session);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
		if (hr == S_OK)
		{
			// Create new session object to represent this session
			CComObject<TDBSession>::CreateInstance(&pNewSession);
			if (pNewSession == NULL)
				return E_OUTOFMEMORY;

			hr = pNewSession->Initialize(szID,
										m_spServiceProvider,
										reinterpret_cast<DWORD_PTR>(this),
										GetProviderInfo);
			if (hr == S_OK)
			{
				// we don't hold a reference to the object
				hr = pNewSession->QueryInterface(ppSession);
			}
		}

		if (hr != S_OK && pNewSession)
			delete pNewSession;
		return hr;
	}

	HRESULT CloseSession(LPCSTR szID) throw()
	{
		if (!szID)
			return E_INVALIDARG;

		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
										  m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// set up accessors
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		CCommand<CAccessor<CSessionDataDeleteAll> > command;
		_ATLTRY
		{
			CA2CT session(szID);
			hr = updator.Assign(session);
			if (hr == S_OK)
				hr = command.Assign(session);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		if (hr == S_OK)
		{
			// delete all session variables
			hr = command.Open(conn,
								m_QueryObj.GetSessionVarDeleteAllVars(),
								NULL,
								NULL,
								DBGUID_DEFAULT,
								false);
			if (hr == S_OK)
			{
				// delete references in the session references table
				hr = updator.Open(conn,
							m_QueryObj.GetSessionRefDeleteFinal(),
							NULL,
							NULL,
							DBGUID_DEFAULT,
							false);
			}
		}
		return hr;
	}

	HRESULT SetSessionTimeout(unsigned __int64 nTimeout) throw()
	{
		// Get the data connection for this thread
		CDataConnection conn;
	
		HRESULT hr = GetSessionConnection(&conn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// all sessions get the same timeout
		CCommand<CAccessor<CSetAllTimeouts> > command;
		hr = command.Assign(nTimeout);
		if (hr == S_OK)
		{
			hr = command.Open(conn, m_QueryObj.GetSessionReferencesSet(),
						NULL,
						NULL,
						DBGUID_DEFAULT,
						false);
			if (hr == S_OK)
			{
				m_dwTimeout = nTimeout;
			}
		}
		return hr;
	}


	HRESULT GetSessionTimeout(unsigned __int64* pnTimeout) throw()
	{
		if (pnTimeout)
			*pnTimeout = m_dwTimeout;
		else
			return E_INVALIDARG;

		return S_OK;
	}

	HRESULT GetSessionCount(DWORD *pnCount) throw()
	{
		if (pnCount)
			*pnCount = 0;
		else
			return E_INVALIDARG;

		CCommand<CAccessor<CSessionRefCount> > command;
		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
											m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		hr = command.Open(conn,
							m_QueryObj.GetSessionRefGetCount());
		if (hr == S_OK)
		{
			hr = command.MoveFirst();
			if (hr == S_OK)
			{
				*pnCount = (DWORD)command.m_nCount;
			}
		}

		return hr;
	}

	void ReleaseAllSessions() throw()
	{
		// nothing to do
	}

	void SweepSessions() throw()
	{
		// nothing to do
	}


	// Helpers
	HRESULT IsValidSession(LPCTSTR szID) throw()
	{
		if (!szID)
			return E_INVALIDARG;
		// Look in the sessionreferences table to see if there is an entry
		// for this session.
		if (m_szConnectionString[0] == 0)
			return E_UNEXPECTED;

		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
											m_spServiceProvider);
		if (hr != S_OK)
			return hr;
		
		// Check the session references table to see if
		// this is a valid session
		CCommand<CAccessor<CSessionRefSelector> > selector;
		hr = selector.Assign(szID);
		if (hr != S_OK)
			return hr;

		// The SQL for this command only deletes the
		// session reference from the references table if it's access
		// count is 0 and it has expired.
		hr = selector.Open(conn,
							m_QueryObj.GetSessionRefSelect(),
							NULL,
							NULL,
							DBGUID_DEFAULT,
							true);
		if (hr == S_OK)
			return selector.MoveFirst();
		return hr;
	}

	CSessionNameGenerator m_SessionNameGenerator; // Object for generating session names
	unsigned __int64 m_dwTimeout;
}; // CDBSessionServiceImplT

typedef CDBSessionServiceImplT<> CDBSessionServiceImpl;





//////////////////////////////////////////////////////////////////
//
// In-memory persisted session
//
//////////////////////////////////////////////////////////////////

// In-memory persisted session service keeps a pointer
// to the session obejct around in memory. The pointer is
// contained in a CComPtr, which is stored in a CAtlMap, so
// we have to have a CElementTraits class for that.
typedef CComPtr<ISession> SESSIONPTRTYPE;

template<>
class CElementTraits<SESSIONPTRTYPE> :
	public CElementTraitsBase<SESSIONPTRTYPE>
{
public:
	static ULONG Hash( INARGTYPE obj ) throw()
	{
		return( (ULONG)(ULONG_PTR)obj.p);
	}

	static BOOL CompareElements( OUTARGTYPE element1, OUTARGTYPE element2 ) throw()
	{
		return element1.IsEqualObject(element2.p) ? TRUE : FALSE;
	}

	static int CompareElementsOrdered( INARGTYPE , INARGTYPE ) throw()
	{
		ATLASSERT(0); // NOT IMPLEMENTED
		return 0;
	}
};


// CMemSession
// This session persistance class persists session variables in memory.
// Note that this type of persistance should only be used on single server
// web sites.
class CMemSession :
	public ISession,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CMemSession)
		COM_INTERFACE_ENTRY(ISession)
	END_COM_MAP()

	CMemSession() throw(...)
	{
	}

	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal) throw()
	{
		if (!szName)
			return E_INVALIDARG;

		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			_ATLTRY
			{
				CComVariant val;
				if (m_Variables.Lookup(szName, val))
				{
					hr = VariantCopy(pVal, &val);
				}
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT vNewVal) throw()
	{
		if (!szName)
			return E_INVALIDARG;
		
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			_ATLTRY
			{
				hr = m_Variables.SetAt(szName, vNewVal) ? S_OK : E_FAIL;
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(RemoveVariable)(LPCSTR szName) throw()
	{
		if (!szName)
			return E_INVALIDARG;
		
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			_ATLTRY
			{
				hr = m_Variables.RemoveKey(szName) ? S_OK : E_FAIL;
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(GetCount)(long *pnCount) throw()
	{
		if (pnCount)
			return *pnCount = 0;
		else
			return E_POINTER;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			*pnCount = (long) m_Variables.GetCount();
		}
		return hr;
	}

	STDMETHOD(RemoveAllVariables)() throw()
	{
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			m_Variables.RemoveAll();
		}
		
		return hr;
	}

	STDMETHOD(BeginVariableEnum)(HSESSIONENUM *phEnumHandle,  POSITION *pPOS) throw()
	{
		if (phEnumHandle)
			*phEnumHandle = NULL;
		else
			return E_POINTER;

		if (pPOS)
			*pPOS = NULL;
		else
			return E_POINTER;
		
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			*pPOS = m_Variables.GetStartPosition();
		}
		return hr;
	}

	STDMETHOD(GetNextVariable)(HSESSIONENUM /*hEnum*/,
							   POSITION *pPOS, LPSTR szName,
					           DWORD dwLen, VARIANT *pVal) throw()
	{
		if (!szName)
			return E_INVALIDARG;

		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		if (!pPOS)
			return E_POINTER;

		CComVariant val;
		POSITION pos = *pPOS;
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;

			_ATLTRY
			{
				CStringA strName = m_Variables.GetKeyAt(pos);
				if (strName.GetLength())
				{
					if (dwLen > (DWORD)strName.GetLength())
						strcpy(szName, strName);
					else
						hr = E_OUTOFMEMORY;
				}
				if (hr == S_OK)
				{
					val = m_Variables.GetNextValue(pos);
					hr = VariantCopy(pVal, &val);
					if (hr == S_OK)
						*pPOS = pos;
				}

			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}

		return hr;
	}

	STDMETHOD(CloseEnum)(HSESSIONENUM /*hEnumHandle*/) throw()
	{
		return S_OK;
	}

	STDMETHOD(IsExpired)() throw()
	{
		CTime tmNow = CTime::GetCurrentTime();
		CTimeSpan span = tmNow-m_tLastAccess;
		if ((unsigned __int64)((span.GetTotalSeconds()*1000)) > m_dwTimeout)
			return S_OK;
		return S_FALSE;
	}

	HRESULT Access() throw()
	{
		// We lock here to protect against multiple threads
		// updating the same member concurrently.
		CSLockType lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		m_tLastAccess = CTime::GetCurrentTime();
		return S_OK;
	}

	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout) throw()
	{
		// We lock here to protect against multiple threads
		// updating the same member concurrently
		CSLockType lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		m_dwTimeout = dwNewTimeout;
		return S_OK;
	}

	HRESULT SessionLock() throw()
	{
		Access();
		return S_OK;
	}

	HRESULT SessionUnlock() throw()
	{
		return S_OK;
	}

protected:
	typedef CAtlMap<CStringA,
					CComVariant,
					CStringElementTraits<CStringA> > VarMapType;
	unsigned __int64 m_dwTimeout;
	CTime m_tLastAccess;
	VarMapType m_Variables;
	CComAutoCriticalSection m_cs;
	typedef CComCritSecLock<CComAutoCriticalSection> CSLockType;
}; // CMemSession


//
// CMemSessionServiceImpl
// Implements the service part of in-memory persisted session services.
//
class CMemSessionServiceImpl
{
public:
	typedef void* SERVICEIMPL_INITPARAM_TYPE;
	CMemSessionServiceImpl() throw()
	{
		m_dwTimeout = ATL_SESSION_TIMEOUT;
	}

	HRESULT CreateNewSession(LPSTR szNewID, DWORD *pdwSize, ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<CMemSession> *pNewSession = NULL;

		if (!szNewID)
			return E_INVALIDARG;

		if (!pdwSize)
			return E_POINTER;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		_ATLTRY
		{
			// Create new session
			CComObject<CMemSession>::CreateInstance(&pNewSession);
			if (pNewSession == NULL)
				return E_OUTOFMEMORY;

			// Initialize and add to list of CSessionData
			hr = m_SessionNameGenerator.GetNewSessionName(szNewID, pdwSize);

			if (SUCCEEDED(hr))
			{
				CComPtr<ISession> spSession;
				hr = pNewSession->QueryInterface(&spSession);
				if (SUCCEEDED(hr))
				{
					pNewSession->SetTimeout(m_dwTimeout);
					pNewSession->Access();
					CSLockType lock(m_CritSec, false);
					hr = lock.Lock();
					if (FAILED(hr))
						return hr;
					m_Sessions.SetAt(szNewID, spSession);
					*ppSession = spSession.Detach();
				}
			}
		}
		_ATLCATCHALL()
		{
			hr = E_UNEXPECTED;
		}

		return hr;
	
	}

	HRESULT GetSession(LPCSTR szID, ISession **ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		SessMapType::CPair *pPair = NULL;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		if (!szID)
			return E_INVALIDARG;

		CSLockType lock(m_CritSec, false);
		hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		_ATLTRY
		{
			pPair = m_Sessions.Lookup(szID); 
			if (pPair) // the session exists and is in our local map of sessions
			{
				hr = pPair->m_value.QueryInterface(ppSession);
			}
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}

		return hr;	
	}

	HRESULT CloseSession(LPCSTR szID) throw()
	{
		if (!szID)
			return E_INVALIDARG;

		HRESULT hr = E_FAIL;
		CSLockType lock(m_CritSec, false);
		hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		_ATLTRY
		{
			hr = m_Sessions.RemoveKey(szID) ? S_OK : E_FAIL;
		}
		_ATLCATCHALL()
		{
			hr = E_UNEXPECTED;
		}
		return hr;
	}

	void SweepSessions() throw()
	{
		POSITION posRemove = NULL;
		const SessMapType::CPair *pPair = NULL;
		POSITION pos = NULL;

		CSLockType lock(m_CritSec, false);
		if (FAILED(lock.Lock()))
			return;
		pos = m_Sessions.GetStartPosition();
		while (pos)
		{
			posRemove = pos;
			pPair = m_Sessions.GetNext(pos);
			if (pPair)
			{

				if (pPair->m_value.p &&
					S_OK == pPair->m_value->IsExpired())
				{
					// remove our reference on the session
					m_Sessions.RemoveAtPos(posRemove);
				}
			}
		}
	}

	HRESULT SetSessionTimeout(unsigned __int64 nTimeout) throw()
	{
		HRESULT hr = S_OK;
		CComPtr<ISession> spSession;
		m_dwTimeout = nTimeout;
		POSITION pos = m_Sessions.GetStartPosition();

		CSLockType lock(m_CritSec, false);
		hr = lock.Lock();
		if (FAILED(hr))
			return hr;

		while (pos)
		{
			SessMapType::CPair *pPair = const_cast<SessMapType::CPair*>(m_Sessions.GetNext(pos));
			if (pPair)
			{
				spSession = pPair->m_value;
				if (spSession)
				{
					// if we fail on any of the sets we will return the
					// error code immediately
					hr = spSession->SetTimeout(nTimeout);
					spSession.Release();
					if (hr != S_OK)
						break;
				}
			}
		}

		return hr;
	}

	HRESULT GetSessionTimeout(unsigned __int64* pnTimeout) throw()
	{
		if (pnTimeout)
			*pnTimeout = m_dwTimeout;
		else
			return E_POINTER;
		
		return S_OK;
	}

	HRESULT GetSessionCount(DWORD *pnCount) throw()
	{
		if (pnCount)
			*pnCount = 0;
		else
			return E_POINTER;

		CSLockType lock(m_CritSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		*pnCount = (DWORD)m_Sessions.GetCount();

		return S_OK;
	}

	void ReleaseAllSessions() throw()
	{
		CSLockType lock(m_CritSec, false);
		if (FAILED(lock.Lock()))
			return;
		m_Sessions.RemoveAll();
	}

	HRESULT Initialize(SERVICEIMPL_INITPARAM_TYPE,
					   IServiceProvider*,
					   unsigned __int64 dwNewTimeout) throw()
	{
		m_dwTimeout = dwNewTimeout;
		return m_CritSec.Init();
	}

	typedef CAtlMap<CStringA,
					SESSIONPTRTYPE,
					CStringElementTraits<CStringA>,
					CElementTraitsBase<SESSIONPTRTYPE> > SessMapType;

	SessMapType m_Sessions; // map for holding sessions in memory
	CComCriticalSection m_CritSec; // for synchronizing access to map
	typedef CComCritSecLock<CComCriticalSection> CSLockType;
	CSessionNameGenerator m_SessionNameGenerator; // Object for generating session names
	unsigned __int64 m_dwTimeout;
}; // CMemSessionServiceImpl



//
// CSessionStateService
// This class implements the session state service which can be
// exposed to request handlers.
//
// Template Parameters:
// CMonitorClass: Provides periodic sweeping services for the session service class.
// TServiceImplClass: The class that actually implements the methods of the
//                    ISessionStateService and ISessionStateControl interfaces.
template <class CMonitorClass, class TServiceImplClass >
class CSessionStateService : 
	public ISessionStateService,
	public ISessionStateControl,
	public IWorkerThreadClient,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
protected:
	CMonitorClass m_Monitor;
	HANDLE m_hTimer;
	CComPtr<IServiceProvider> m_spServiceProvider;
	TServiceImplClass m_SessionServiceImpl;
public:
	// Construction/Initialization
	CSessionStateService() throw() :
	  m_hTimer(NULL)
	  {
		
	  }
	~CSessionStateService() throw()
	{
		ATLASSERT(m_hTimer == NULL);
	}
	BEGIN_COM_MAP(CSessionStateService)
		COM_INTERFACE_ENTRY(ISessionStateService)
		COM_INTERFACE_ENTRY(ISessionStateControl)
	END_COM_MAP()

// ISessionStateServie methods
	STDMETHOD(CreateNewSession)(LPSTR szNewID, DWORD *pdwSize, ISession** ppSession) throw()
	{
		return m_SessionServiceImpl.CreateNewSession(szNewID, pdwSize, ppSession);
	}

	STDMETHOD(GetSession)(LPCSTR szID, ISession **ppSession) throw()
	{
		return m_SessionServiceImpl.GetSession(szID, ppSession);
	}

	STDMETHOD(CloseSession)(LPCSTR szSessionID) throw()
	{
		return m_SessionServiceImpl.CloseSession(szSessionID);
	}

	STDMETHOD(SetSessionTimeout)(unsigned __int64 nTimeout) throw()
	{
		return m_SessionServiceImpl.SetSessionTimeout(nTimeout);
	}

	STDMETHOD(GetSessionTimeout)(unsigned __int64 *pnTimeout) throw()
	{
		return m_SessionServiceImpl.GetSessionTimeout(pnTimeout);
	}

	STDMETHOD(GetSessionCount)(DWORD *pnSessionCount) throw()
	{
		return m_SessionServiceImpl.GetSessionCount(pnSessionCount);
	}

	void SweepSessions() throw()
	{
		m_SessionServiceImpl.SweepSessions();
	}

	void ReleaseAllSessions() throw()
	{
		m_SessionServiceImpl.ReleaseAllSessions();
	}

	HRESULT Initialize(
		IServiceProvider *pServiceProvider = NULL,
		unsigned __int64 dwTimeout = ATL_SESSION_TIMEOUT,
		TServiceImplClass::SERVICEIMPL_INITPARAM_TYPE pInitData = NULL) throw()
	{
		HRESULT hr = S_OK;
		if (pServiceProvider)
			m_spServiceProvider = pServiceProvider;

		hr = m_SessionServiceImpl.Initialize(pInitData, pServiceProvider, dwTimeout);

		return hr;
	}

	template <class ThreadTraits>
	HRESULT Initialize(
		CWorkerThread<ThreadTraits> *pWorker,
		IServiceProvider *pServiceProvider = NULL,
		unsigned __int64 dwTimeout = ATL_SESSION_TIMEOUT,
		TServiceImplClass::SERVICEIMPL_INITPARAM_TYPE pInitData = NULL) throw()
	{
		if (!pWorker)
			return E_INVALIDARG;

		HRESULT hr = Initialize(pServiceProvider, dwTimeout, pInitData);
		if (hr == S_OK)
		{
			hr = m_Monitor.Initialize(pWorker);
			if (hr == S_OK)
			{
				//sweep every 500ms
				hr = m_Monitor.AddTimer(ATL_SESSION_SWEEPER_TIMEOUT, this, 0, &m_hTimer);
			}
		}
		return hr;
	}

	HRESULT Execute(DWORD_PTR /*dwParam*/, HANDLE /*hObject*/) throw()
	{
		SweepSessions();
		return S_OK;
	}

	HRESULT CloseHandle(HANDLE hHandle) throw()
	{
		::CloseHandle(hHandle);
		m_hTimer = NULL;
		return S_OK;
	}

	void Shutdown() throw()
	{
		if (m_hTimer)
		{
			m_Monitor.RemoveHandle(m_hTimer);
			m_hTimer = NULL;
		}
		ReleaseAllSessions();
	}
}; // CSessionStateService

} // namespace ATL

#pragma warning(pop)
#endif // __ATLSESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsiface.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIFACE_H__
#define __ATLSIFACE_H__

#pragma once
#include <atlcoll.h>
#include <httpext.h>
#include <atlserr.h>

namespace ATL{

// Forward declarations of custom data types used in 
// interfaces declared in this file.
struct AtlServerRequest;
class CIsapiWorker;
__interface IAtlMemMgr;
class CCookie;

// Forward declarations of all interfaces declared in this file.
__interface IWriteStream;
__interface IHttpFile;
__interface IHttpServerContext;
__interface IHttpRequestLookup;
__interface IRequestHandler;
__interface ITagReplacer;
__interface IIsapiExtension;
__interface IPageCacheControl;
__interface IRequestStats;
__interface IBrowserCaps;
__interface IBrowserCapsSvc;


// ATLS Interface declarations.

// Interface for writing to a stream.
__interface IWriteStream
{
	HRESULT WriteStream(LPCSTR szOut, int nLen, DWORD *pdwWritten);
	HRESULT FlushStream();
};

// This is an interface that provides for basic accessor
// functionality for files (see CHttpRequestFile).
__interface __declspec(uuid("84a2e035-d9e5-4e60-a61b-bcd960897056"))
	IHttpFile : public IUnknown
{
	LPCSTR GetParamName();
	LPCSTR GetFileName();
	LPCSTR GetFullFileName();
	LPCSTR GetContentType();
	LPCSTR GetTempFileName();
	ULONGLONG GetFileSize();
};

// This interface encapsulates the capabilities of the web server and provides information about
// the current request being handled. See CServerContext for implementation.
__interface ATL_NO_VTABLE __declspec(uuid("813F3F00-3881-11d3-977B-00C04F8EE25E")) 
	IHttpServerContext : public IUnknown
{
	HRESULT  STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	LPCSTR GetRequestMethod();
	LPCSTR GetQueryString();
	LPCSTR GetPathInfo();
	LPCSTR GetPathTranslated();
	LPCSTR GetScriptPathTranslated();
	DWORD GetTotalBytes();
	DWORD GetAvailableBytes();
	BYTE *GetAvailableData();
	LPCSTR GetContentType();
	BOOL GetServerVariable(LPCSTR pszVariableName,
									LPSTR pvBuffer, DWORD *pdwSize);
	BOOL GetImpersonationToken(HANDLE * pToken);
	BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes);
	BOOL AsyncWriteClient(void *pvBuffer, DWORD *pdwBytes);
	BOOL ReadClient(void *pvBuffer, DWORD *pdwSize);
	BOOL AsyncReadClient(void *pvBuffer, DWORD *pdwSize);
	BOOL SendRedirectResponse(LPCSTR pszRedirectUrl);
	BOOL SendResponseHeader(LPCSTR pszHeader, LPCSTR pszStatusCode,
							BOOL fKeepConn);
	BOOL DoneWithSession(DWORD dwHttpStatusCode);
	BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION pfn, DWORD *pdwContext);
	BOOL TransmitFile(HANDLE hFile, PFN_HSE_IO_COMPLETION pfn, void *pContext, 
		LPCSTR szStatusCode, DWORD dwBytesToWrite, DWORD dwOffset,
		void *pvHead, DWORD dwHeadLen, void *pvTail,
		DWORD dwTailLen, DWORD dwFlags);
    BOOL AppendToLog(LPCSTR szMessage, DWORD* pdwLen);
	BOOL MapUrlToPathEx(LPCSTR szLogicalPath, DWORD dwLen, HSE_URL_MAPEX_INFO *pumInfo);
};

// This interface is designed to allow one map to chain to another map.
// The interface is implemented by the CHttpThunkMap and CHttpRequest classes.
// Pointers to this interface are passed around by CRequestHandlerT and CHtmlTagReplacer.
// dwType - the type of item being requested
__interface ATL_NO_VTABLE __declspec(uuid("A5990B44-FF74-4bfe-B66D-F9E7E9F42D42")) 
	IHttpRequestLookup : public IUnknown
//interface IHttpRequestLookup
{
	POSITION GetFirstQueryParam(LPCSTR *ppszName, LPCSTR *ppszValue) const;
	POSITION GetNextQueryParam(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const;

	POSITION GetFirstFormVar(LPCSTR *ppszName, LPCSTR *ppszValue) const;
	POSITION GetNextFormVar(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const;

	POSITION GetFirstFile(LPCSTR *ppszName, IHttpFile **ppFile) const;
	POSITION GetNextFile(POSITION pos, LPCSTR *ppszName, IHttpFile **ppFile) const;

	HRESULT GetServerContext(IHttpServerContext **ppOut);
};


__interface ATL_NO_VTABLE __declspec(uuid("D57F8D0C-751A-4223-92BC-0B29F65D2453")) 
IRequestHandler : public IUnknown
{
	HTTP_CODE GetFlags(DWORD *pdwStatus);
	HTTP_CODE InitializeHandler(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
	HTTP_CODE InitializeChild(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider, IHttpRequestLookup *pLookup);
	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
	void UninitializeHandler();
};

// This interface defines the methods necessary for server response file processing.
__interface ATL_NO_VTABLE __declspec(uuid("8FF5E90C-8CE0-43aa-96C4-3BF930837512")) 
	ITagReplacer : public IUnknown
{
public:
	HTTP_CODE FindReplacementOffset(LPCSTR szMethodName, DWORD *pdwMethodOffset, 
						LPCSTR szObjectName, DWORD *pdwObjOffset, DWORD *pdwMap, void **ppvParam, IAtlMemMgr *pMemMgr);
	HTTP_CODE RenderReplacement(DWORD dwFnOffset, DWORD dwObjOffset, DWORD dwMap, void *pvParam);
	HRESULT GetContext(REFIID riid, void** ppv);
	HTTP_CODE FreeParam(void *pvParam);
	IWriteStream *SetStream(IWriteStream *pStream);
};

__interface __declspec(uuid("79DD4A27-D820-4fa6-954D-E1DFC2C05978"))
	IIsapiExtension : public IUnknown
{
public:
	BOOL DispatchStencilCall(AtlServerRequest *pRequestInfo);
	void RequestComplete(AtlServerRequest *pRequestInfo, DWORD hStatus, DWORD dwSubStatus);
	BOOL OnThreadAttach();
	void OnThreadTerminate();
    BOOL QueueRequest(AtlServerRequest *pRequestInfo);
	CIsapiWorker *GetThreadWorker();
	BOOL SetThreadWorker(CIsapiWorker *pWorker);
	HTTP_CODE LoadRequestHandler(LPCSTR szDllPath, LPCSTR szHandlerName, IHttpServerContext *pServerContext,
		HINSTANCE *phInstance, IRequestHandler **ppHandler);
	HRESULT AddService(REFGUID guidService, REFIID riid, IUnknown *punk, HINSTANCE hInstance);
	HRESULT RemoveService(REFGUID guidService, REFIID riid);
	HTTP_CODE LoadDispatchFile(LPCSTR szFileName, AtlServerRequest *pRequestInfo);

	AtlServerRequest* CreateRequest();
	void FreeRequest(AtlServerRequest* pRequest);
	HTTP_CODE TransferRequest(
				AtlServerRequest *pRequest, 
				IServiceProvider *pServiceProvider,
				IWriteStream *pWriteStream,
				IHttpRequestLookup *pLookup,
				LPCSTR szNewUrl,
				WORD nCodePage,
				bool bContinueAfterProcess = false,
				void *pState = NULL
			);
};

// This interface controls the cacheability of the current page
__interface ATL_NO_VTABLE __declspec(uuid("9868BFC0-D44D-4154-931C-D186EC0C45D5")) 
	IPageCacheControl : public IUnknown
{
    HRESULT GetExpiration(FILETIME *pftExpiration);
    HRESULT SetExpiration(FILETIME ftExpiration);
    BOOL IsCached();
    BOOL Cache(BOOL bCache);
};

__interface ATL_NO_VTABLE __declspec(uuid("2B75C68D-0DDF-48d6-B58A-CC7C2387A6F2"))
	IRequestStats : public IUnknown
{
	long GetTotalRequests();
	long GetFailedRequests();
	long GetAvgResponseTime();
	long GetCurrWaiting();
	long GetMaxWaiting();
	long GetActiveThreads();
};

__interface __declspec(uuid("3339FCE2-99BC-4985-A702-4ABC8304A995"))
	IBrowserCaps : public IUnknown
{
public:
    HRESULT GetPropertyString(BSTR bstrProperty, BSTR * pbstrOut);
    HRESULT GetBooleanPropertyValue(BSTR bstrProperty, BOOL* pbOut);
    HRESULT GetBrowserName(BSTR * pbstrName);
    HRESULT GetPlatform(BSTR * pbstrPlatform);
	HRESULT GetVersion(BSTR * pbstrVersion);
	HRESULT GetMajorVer(BSTR * pbstrMajorVer);
	HRESULT GetMinorVer(BSTR * pbstrMinorVer);
    HRESULT SupportsFrames(BOOL* pbFrames);
    HRESULT SupportsTables(BOOL* pbTables);
    HRESULT SupportsCookies(BOOL* pbCookies);
    HRESULT SupportsBackgroundSounds(BOOL* pbBackgroundSounds);
    HRESULT SupportsVBScript(BOOL* pbVBScript);
    HRESULT SupportsJavaScript(BOOL* pbJavaScript);
    HRESULT SupportsJavaApplets(BOOL* pbJavaApplets);
    HRESULT SupportsActiveXControls(BOOL* pbActiveXControls);
    HRESULT SupportsCDF(BOOL* pbCDF);
    HRESULT SupportsAuthenticodeUpdate(BOOL* pbAuthenticodeUpdate);
    HRESULT IsBeta(BOOL* pbIsBeta);
    HRESULT IsCrawler(BOOL* pbIsCrawler);
    HRESULT IsAOL(BOOL* pbIsAOL);
    HRESULT IsWin16(BOOL* pbIsWin16);
    HRESULT IsAK(BOOL* pbIsAK);
    HRESULT IsSK(BOOL* pbIsSK);
    HRESULT IsUpdate(BOOL* pbIsUpdate);
};

__interface __declspec(uuid("391E7418-863B-430e-81BB-1312ED2FF3E9"))
	IBrowserCapsSvc : public IUnknown
{
public:
    HRESULT GetCaps(IHttpServerContext * pContext, IBrowserCaps ** ppOut);
    HRESULT GetCapsUserAgent(BSTR bstrAgent, IBrowserCaps ** ppOut);
};

__interface __declspec(uuid("B1F64757-6E88-4fa2-8886-7848B0D7E660")) 
    IThreadPoolConfig : public IUnknown
{
    HRESULT STDMETHODCALLTYPE SetSize(int nNumThreads);
    HRESULT STDMETHODCALLTYPE GetSize(int *pnNumThreads);
    HRESULT STDMETHODCALLTYPE SetTimeout(DWORD dwMaxWait);
    HRESULT STDMETHODCALLTYPE GetTimeout(DWORD *pdwMaxWait);
};


typedef DWORD_PTR HSESSIONENUM;
__interface ATL_NO_VTABLE __declspec(uuid("DEB69BE3-7AC9-4a13-9519-266C1EA3AB39")) 
ISession : public IUnknown
{
	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT NewVal);
	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal);
	STDMETHOD(GetCount)(long *pnCount);
	STDMETHOD(RemoveVariable)(LPCSTR szName);
	STDMETHOD(RemoveAllVariables)();
	STDMETHOD(BeginVariableEnum)(HSESSIONENUM *phEnumHandle, POSITION *pPOS);
	STDMETHOD(GetNextVariable)(HSESSIONENUM hEnum, POSITION *pPOS, LPSTR szName, DWORD dwLen, VARIANT *pVal);
	STDMETHOD(CloseEnum)(HSESSIONENUM hEnumHandle);
	STDMETHOD(IsExpired)();
	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout);
}; //ISession

__interface ATL_NO_VTABLE __declspec(uuid("C5740C4F-0C6D-4b43-92C4-2AF778F35DDE"))
ISessionStateService : public IUnknown
{
	STDMETHOD(CreateNewSession)(LPSTR szNewID, DWORD *pdwSize, ISession** ppSession);
	STDMETHOD(GetSession)(LPCSTR szID, ISession **ppSession);
	STDMETHOD(CloseSession)(LPCSTR szID);
};

__interface ATL_NO_VTABLE __declspec(uuid("6C7F5F56-6CBD-49ee-9797-4C837D4C527A"))
ISessionStateControl : public IUnknown
{
	STDMETHOD(SetSessionTimeout)(unsigned __int64 nTimeout);
	STDMETHOD(GetSessionTimeout)(unsigned __int64 *pnTimeout);
	STDMETHOD(GetSessionCount)(DWORD *pnSessionCount);
}; 

//
// IWorkerThreadClient
// Interface to be used with CWorkerThread

__interface IWorkerThreadClient
{
	HRESULT Execute(DWORD_PTR dwParam, HANDLE hObject);
	HRESULT CloseHandle(HANDLE hHandle);
};

}; // namespace ATL

#endif // __ATLSIFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsimpstr.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIMPSTR_H__
#define __ATLSIMPSTR_H__

#pragma once

#include <atldef.h>
#include <atlbase.h>
#include <atlexcept.h>
#include <atlmem.h>

namespace ATL
{

struct CStringData;

__interface IAtlStringMgr
{
public:
	// Allocate a new CStringData
	CStringData* Allocate( int nAllocLength, int nCharSize ) throw();
	// Free an existing CStringData
	void Free( CStringData* pData ) throw();
	// Change the size of an existing CStringData
	CStringData* Reallocate( CStringData* pData, int nAllocLength, int nCharSize ) throw();
	// Get the CStringData for a Nil string
	CStringData* GetNilString() throw();
	IAtlStringMgr* Clone() throw();
};

#ifdef _M_IX86
#ifndef _M_CEE
extern "C"
{
	LONG _InterlockedIncrement( LONG* pn );
	LONG _InterlockedDecrement( LONG* pn );
};

#pragma intrinsic( _InterlockedIncrement )
#pragma intrinsic( _InterlockedDecrement )
#else
#define _InterlockedIncrement InterlockedIncrement
#define _InterlockedDecrement InterlockedDecrement
#endif  // !_M_CEE
#endif  // _M_IX86_

struct CStringData
{
	IAtlStringMgr* pStringMgr;  // String manager for this CStringData
	int nDataLength;  // Length of currently used data in XCHARs (not including terminating null)
	int nAllocLength;  // Length of allocated data in XCHARs (not including terminating null)
	long nRefs;     // Reference count: negative == locked
	// XCHAR data[nAllocLength+1]  // A CStringData is always followed in memory by the actual array of character data

	void* data() throw()
	{
		return (this+1);
	}

	void AddRef() throw()
	{
		ATLASSERT(nRefs > 0);
		_InterlockedIncrement(&nRefs);
	}
	bool IsLocked() const throw()
	{
		return nRefs < 0;
	}
	bool IsShared() const throw()
	{
		return( nRefs > 1 ); 
	}
	void Lock() throw()
	{
		ATLASSERT( nRefs <= 1 );
		nRefs--;  // Locked buffers can't be shared, so no interlocked operation necessary
		if( nRefs == 0 )
		{
			nRefs = -1;
		}
	}
	void Release() throw()
	{
		ATLASSERT( nRefs != 0 );

		if( _InterlockedDecrement( &nRefs ) <= 0 )
		{
			pStringMgr->Free( this );
		}
	}
	void Unlock() throw()
	{
		ATLASSERT( IsLocked() );
		nRefs++;  // Locked buffers can't be shared, so no interlocked operation necessary
		if( nRefs == 0 )
		{
			nRefs = 1;
		}
	}
};

class CNilStringData :
	public CStringData
{
public:
	CNilStringData() throw()
	{
		pStringMgr = NULL;
		nRefs = 2;  // Never gets freed by IAtlStringMgr
		nDataLength = 0;
		nAllocLength = 0;
		achNil[0] = 0;
		achNil[1] = 0;
	}

	void SetManager( IAtlStringMgr* pMgr ) throw()
	{
		ATLASSERT( pStringMgr == NULL );
		pStringMgr = pMgr;
	}

public:
	wchar_t achNil[2];
};

class CAtlStringMgr :
	public IAtlStringMgr
{
public:
	CAtlStringMgr( IAtlMemMgr* pMemMgr = NULL ) throw() :
		m_pMemMgr( pMemMgr )
	{
		m_nil.SetManager( this );
	}
	~CAtlStringMgr() throw()
	{
	}

	void SetMemoryManager( IAtlMemMgr* pMemMgr ) throw()
	{
		ATLASSERT( m_pMemMgr == NULL );
		m_pMemMgr = pMemMgr;
	}

// IAtlStringMgr
public:
	virtual CStringData* Allocate( int nChars, int nCharSize ) throw()
	{
		size_t nTotalSize;
		CStringData* pData;
		size_t nDataBytes;

		nChars = AtlAlignUp( nChars + 1, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

		nDataBytes = nChars*nCharSize;
		nTotalSize = sizeof( CStringData )+nDataBytes;
		pData = static_cast< CStringData* >( m_pMemMgr->Allocate( nTotalSize ) );
		if( pData == NULL )
		{
			return( NULL );
		}
		pData->pStringMgr = this;
		pData->nRefs = 1;
		pData->nAllocLength = nChars - 1;
		pData->nDataLength = 0;

		return( pData );
	}
	virtual void Free( CStringData* pData ) throw()
	{
		ATLASSERT( pData->pStringMgr == this );
		m_pMemMgr->Free( pData );
	}
	virtual CStringData* Reallocate( CStringData* pData, int nChars, int nCharSize ) throw()
	{
		CStringData* pNewData;
		ULONG nTotalSize;
		ULONG nDataBytes;

		ATLASSERT( pData->pStringMgr == this );
		nChars = AtlAlignUp( nChars+1, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

		nDataBytes = nChars*nCharSize;
		nTotalSize = sizeof( CStringData )+nDataBytes;
		pNewData = static_cast< CStringData* >( m_pMemMgr->Reallocate( pData, nTotalSize ) );
		if( pNewData == NULL )
		{
			return NULL;
		}
		pNewData->nAllocLength = nChars - 1;

		return pNewData;
	}
	virtual CStringData* GetNilString() throw()
	{
		m_nil.AddRef();
		return &m_nil;
	}
	virtual IAtlStringMgr* Clone() throw()
	{
		return this;
	}

protected:
	IAtlMemMgr* m_pMemMgr;
	CNilStringData m_nil;
};

template< typename BaseType, const int t_nSize >
class CStaticString
{
public:
	CStaticString( const BaseType* psz ) :
		m_psz( psz )
	{
	}

	operator const BaseType*() const
	{
		return m_psz;
	}

	static int GetLength() 
	{
		return (t_nSize/sizeof( BaseType ))-1;
	}

private:
	const BaseType* m_psz;

private:
	CStaticString( const CStaticString& str ) throw();
	CStaticString& operator=( const CStaticString& str ) throw();
};

#define _ST( psz ) ATL::CStaticString< TCHAR, sizeof( _T( psz ) ) >( _T( psz ) )
#define _SA( psz ) ATL::CStaticString< char, sizeof( psz ) >( psz )
#define _SW( psz ) ATL::CStaticString< wchar_t, sizeof( L##psz ) >( L##psz )
#define _SO( psz ) _SW( psz )

template< typename BaseType = char >
class ChTraitsBase
{
public:
	typedef char XCHAR;
	typedef LPSTR PXSTR;
	typedef LPCSTR PCXSTR;
	typedef wchar_t YCHAR;
	typedef LPWSTR PYSTR;
	typedef LPCWSTR PCYSTR;
};

template<>
class ChTraitsBase< wchar_t >
{
public:
	typedef wchar_t XCHAR;
	typedef LPWSTR PXSTR;
	typedef LPCWSTR PCXSTR;
	typedef char YCHAR;
	typedef LPSTR PYSTR;
	typedef LPCSTR PCYSTR;
};

template< typename BaseType >
class CSimpleStringT
{
public:
	typedef ChTraitsBase< BaseType >::XCHAR XCHAR;
	typedef ChTraitsBase< BaseType >::PXSTR PXSTR;
	typedef ChTraitsBase< BaseType >::PCXSTR PCXSTR;
	typedef ChTraitsBase< BaseType >::YCHAR YCHAR;
	typedef ChTraitsBase< BaseType >::PYSTR PYSTR;
	typedef ChTraitsBase< BaseType >::PCYSTR PCYSTR;

public:
	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()
	{
		ATLASSERT( pStringMgr != NULL );
		CStringData* pData = pStringMgr->GetNilString();
		Attach( pData );
	}
	CSimpleStringT( const CSimpleStringT& strSrc )
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pNewData = CloneData( pSrcData );

		Attach( pNewData );
	}
	CSimpleStringT( PCXSTR pszSrc, IAtlStringMgr* pStringMgr )
	{
		ATLASSERT( pStringMgr != NULL );

		int nLength = StringLength( pszSrc );
		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
		if( pData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pData );
		SetLength( nLength );
		CopyChars( m_pszData, pszSrc, nLength );
	}
	CSimpleStringT( const XCHAR* pchSrc, int nLength, IAtlStringMgr* pStringMgr )
	{
		ATLASSERT( pStringMgr != NULL );

		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
		if( pData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pData );
		SetLength( nLength );
		CopyChars( m_pszData, pchSrc, nLength );
	}
	~CSimpleStringT() throw()
	{
		CStringData* pData = GetData();
		pData->Release();
	}

	CSimpleStringT& operator=( const CSimpleStringT& strSrc )
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pOldData = GetData();
		if( pSrcData != pOldData )
		{
			if( pOldData->IsLocked() )
			{
				SetString( strSrc.GetString(), strSrc.GetLength() );
			}
			else
			{
				CStringData* pNewData = CloneData( pSrcData );
				pOldData->Release();
				Attach( pNewData );
			}
		}

		return( *this );
	}
	CSimpleStringT& operator=( PCXSTR pszSrc )
	{
		SetString( pszSrc );

		return( *this );
	}

	CSimpleStringT& operator+=( const CSimpleStringT& strSrc )
	{
		Append( strSrc );

		return( *this );
	}
	CSimpleStringT& operator+=( PCXSTR pszSrc )
	{
		Append( pszSrc );

		return( *this );
	}
	template< int t_nSize >
	CSimpleStringT& operator+=( const CStaticString< XCHAR, t_nSize >& strSrc )
	{
		Append( strSrc.m_psz, strSrc.GetLength() );

		return( *this );
	}
	CSimpleStringT& operator+=( char ch )
	{
		XCHAR chTemp = XCHAR( ch );
		Append( &chTemp, 1 );

		return( *this );
	}
	CSimpleStringT& operator+=( unsigned char ch )
	{
		XCHAR chTemp = XCHAR( ch );
		Append( &chTemp, 1 );
		
		return( *this );
	}
	CSimpleStringT& operator+=( wchar_t ch )
	{
		XCHAR chTemp = XCHAR( ch );
		Append( &chTemp, 1 );

		return( *this );
	}

	XCHAR operator[]( int iChar ) const throw()
	{
		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
		return( m_pszData[iChar] );
	}

	operator PCXSTR() const throw()
	{
		return( m_pszData );
	}

	void Append( PCXSTR pszSrc )
	{
		Append( pszSrc, StringLength( pszSrc ) );
	}
	void Append( PCXSTR pszSrc, int nLength )
	{
		// See comment in SetString() about why we do this
		UINT_PTR nOffset = pszSrc-GetString();

		UINT nOldLength = GetLength();
		int nNewLength = nOldLength+nLength;
		PXSTR pszBuffer = GetBuffer( nNewLength );
		if( nOffset <= nOldLength )
		{
			pszSrc = pszBuffer+nOffset;
			// No need to call CopyCharsOverlapped, since the destination is
			// beyond the end of the original buffer
		}
		CopyChars( pszBuffer+nOldLength, pszSrc, nLength );
		ReleaseBuffer( nNewLength );
	}
	void Append( const CSimpleStringT& strSrc )
	{
		Append( strSrc.GetString(), strSrc.GetLength() );
	}
	void Empty() throw()
	{
		CStringData* pOldData = GetData();
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		if( pOldData->nDataLength == 0 )
		{
			return;
		}

		if( pOldData->IsLocked() )
		{
			// Don't reallocate a locked buffer that's shrinking
			SetLength( 0 );
		}
		else
		{
			pOldData->Release();
			CStringData* pNewData = pStringMgr->GetNilString();
			Attach( pNewData );
		}
	}
	void FreeExtra() throw()
	{
		CStringData* pOldData = GetData();
		int nLength = pOldData->nDataLength;
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		if( pOldData->nAllocLength == nLength )
		{
			return;
		}

		if( !pOldData->IsLocked() )  // Don't reallocate a locked buffer that's shrinking
		{
			CStringData* pNewData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
			if( pNewData == NULL )
			{
				SetLength( nLength );
				return;
			}
			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nLength );
			pOldData->Release();
			Attach( pNewData );
			SetLength( nLength );
		}
	}

	int GetAllocLength() const throw()
	{
		return( GetData()->nAllocLength );
	}
	XCHAR GetAt( int iChar ) const throw()
	{
		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
		return( m_pszData[iChar] );
	}
	PXSTR GetBuffer()
	{
		CStringData* pData = GetData();
		if( pData->IsShared() )
		{
			Fork( pData->nDataLength );
		}

		return( m_pszData );
	}
	PXSTR GetBuffer( int nMinBufferLength )
	{
		return( PrepareWrite( nMinBufferLength ) );
	}
	PXSTR GetBufferSetLength( int nLength )
	{
		PXSTR pszBuffer = GetBuffer( nLength );
		SetLength( nLength );

		return( pszBuffer );
	}
	int GetLength() const throw()
	{
		return( GetData()->nDataLength );
	}
	IAtlStringMgr* GetManager() const throw()
	{
		return( GetData()->pStringMgr->Clone() );
	}

	PCXSTR GetString() const throw()
	{
		return( m_pszData );
	}
	bool IsEmpty() const throw()
	{
		return( GetLength() == 0 );
	}
	PXSTR LockBuffer()
	{
		CStringData* pData = GetData();
		if( pData->IsShared() )
		{
			Fork( pData->nDataLength );
			pData = GetData();  // Do it again, because the fork might have changed it
		}
		pData->Lock();

		return( m_pszData );
	}
	void UnlockBuffer() throw()
	{
		CStringData* pData = GetData();
		pData->Unlock();
	}
	void Preallocate( int nLength )
	{
		PrepareWrite( nLength );
	}
	void ReleaseBuffer( int nNewLength = -1 ) throw()
	{
		if( nNewLength == -1 )
		{
			nNewLength = StringLength( m_pszData );
		}
		SetLength( nNewLength );
	}
	void Truncate( int nNewLength )
	{
		ATLASSERT( nNewLength <= GetLength() );
		GetBuffer( nNewLength );
		ReleaseBuffer( nNewLength );
	}
	void SetAt( int iChar, XCHAR ch )
	{
		ATLASSERT( (iChar >= 0) && (iChar < GetLength()) );
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer();
		pszBuffer[iChar] = ch;
		ReleaseBuffer( nLength );
	}
	void SetManager( IAtlStringMgr* pStringMgr )
	{
		ATLASSERT( IsEmpty() );

		CStringData* pData = GetData();
		pData->Release();
		pData = pStringMgr->GetNilString();
		Attach( pData );
	}
	void SetString( PCXSTR pszSrc )
	{
		SetString( pszSrc, StringLength( pszSrc ) );
	}
	void SetString( PCXSTR pszSrc, int nLength )
	{
		if( nLength == 0 )
		{
			Empty();
		}
		else
		{
			// It is possible that pszSrc points to a location inside of our 
			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
			// is shared or (2) the buffer is too small to hold the new 
			// string.  We detect this aliasing, and modify pszSrc to point
			// into the newly allocated buffer instead.

			UINT nOldLength = GetLength();
			UINT_PTR nOffset = pszSrc-GetString();
			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
			// buffer

			PXSTR pszBuffer = GetBuffer( nLength );
			if( nOffset <= nOldLength )
			{
				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );
			}
			else
			{
				CopyChars( pszBuffer, pszSrc, nLength );
			}
			ReleaseBuffer( nLength );
		}
	}

public:
	friend CSimpleStringT operator+(
		const CSimpleStringT& str1,
		const CSimpleStringT& str2 )
	{
		CSimpleStringT s( str1.GetManager() );

		Concatenate( s, str1, str1.GetLength(), str2, str2.GetLength() );

		return( s );
	}

	friend CSimpleStringT operator+(
		const CSimpleStringT& str1,
		PCXSTR psz2 )
	{
		CSimpleStringT s( str1.GetManager() );

		Concatenate( s, str1, str1.GetLength(), psz2, StringLength( psz2 ) );

		return( s );
	}

	friend CSimpleStringT operator+(
		PCXSTR psz1,
		const CSimpleStringT& str2 )
	{
		CSimpleStringT s( str2.GetManager() );

		Concatenate( s, psz1, StringLength( psz1 ), str2, str2.GetLength() );

		return( s );
	}

	static void CopyChars( XCHAR* pchDest, const XCHAR* pchSrc, int nChars ) throw()
	{
		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );
	}
	static void CopyCharsOverlapped( XCHAR* pchDest, const XCHAR* pchSrc, int nChars ) throw()
	{
		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );
	}
#ifdef _ATL_MIN_CRT
	ATL_NOINLINE static int StringLength( PCXSTR psz ) throw()
	{
		int nLength = 0;
		if( psz != NULL )
		{
			const XCHAR* pch = psz;
			while( *pch != 0 )
			{
				nLength++;
				pch++;
			}
		}

		return( nLength );
	}
#else
	static int StringLength( const char* psz ) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( strlen( psz ) ) );
	}
	template<>
	static int StringLength( const wchar_t* psz ) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( wcslen( psz ) ) );
	}
#endif

protected:
	static void Concatenate( CSimpleStringT& strResult, PCXSTR psz1, int nLength1, PCXSTR psz2, int nLength2 )
	{
		int nNewLength = nLength1+nLength2;
		PXSTR pszBuffer = strResult.GetBuffer( nNewLength );
		CopyChars( pszBuffer, psz1, nLength1 );
		CopyChars( pszBuffer+nLength1, psz2, nLength2 );
		strResult.ReleaseBuffer( nNewLength );
	}
	ATL_NOINLINE static void ThrowMemoryException()
	{
		AtlThrow( E_OUTOFMEMORY );
	}

// Implementation
private:
	void Attach( CStringData* pData ) throw()
	{
		m_pszData = static_cast< PXSTR >( pData->data() );
	}
	ATL_NOINLINE void Fork( int nLength )
	{
		CStringData* pOldData = GetData();
		int nOldLength = pOldData->nDataLength;
		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );
		if( pNewData == NULL )
		{
			ThrowMemoryException();
		}
		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'
		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );
		pNewData->nDataLength = nOldLength;
		pOldData->Release();
		Attach( pNewData );
	}
	CStringData* GetData() const throw()
	{
		return( reinterpret_cast< CStringData* >( m_pszData )-1 );
	}
	PXSTR PrepareWrite( int nLength )
	{
		CStringData* pOldData = GetData();
		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false
		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data
		{
			PrepareWrite2( nLength );
		}

		return( m_pszData );
	}
	ATL_NOINLINE void PrepareWrite2( int nLength )
	{
		CStringData* pOldData = GetData();
		if( pOldData->nDataLength > nLength )
		{
			nLength = pOldData->nDataLength;
		}
		if( pOldData->IsShared() )
		{
			Fork( nLength );
		}
		else if( pOldData->nAllocLength < nLength )
		{
			// Grow exponentially, until we hit 1K.
			int nNewLength = pOldData->nAllocLength;
			if( nNewLength > 1024 )
			{
				nNewLength += 1024;
			}
			else
			{
				nNewLength *= 2;
			}
			if( nNewLength < nLength )
			{
				nNewLength = nLength;
			}
			Reallocate( nNewLength );
		}
	}
	ATL_NOINLINE void Reallocate( int nLength )
	{
		CStringData* pOldData = GetData();
		ATLASSERT( pOldData->nAllocLength < nLength );
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );
		if( pNewData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pNewData );
	}

	void SetLength( int nLength ) throw()
	{
		ATLASSERT( nLength >= 0 );
		ATLASSERT( nLength <= GetData()->nAllocLength );

		GetData()->nDataLength = nLength;
		m_pszData[nLength] = 0;
	}

	static CStringData* CloneData( CStringData* pData )
	{
		CStringData* pNewData = NULL;

		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();
		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )
		{
			pNewData = pData;
			pNewData->AddRef();
		}
		else
		{
			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );
			if( pNewData == NULL )
			{
				ThrowMemoryException();
			}
			pNewData->nDataLength = pData->nDataLength;
			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'
		}

		return( pNewData );
	}

private:
	PXSTR m_pszData;
};

template< typename TCharType >
class CStrBufT
{
public:
	typedef CSimpleStringT< TCharType > StringType;
	typedef StringType::XCHAR XCHAR;
	typedef StringType::PXSTR PXSTR;
	typedef StringType::PCXSTR PCXSTR;

	static const DWORD AUTO_LENGTH = 0x01;  // Automatically determine the new length of the string at release.  The string must be null-terminated.
	static const DWORD SET_LENGTH = 0x02;  // Set the length of the string object at GetBuffer time

public:
	explicit CStrBufT( StringType& str ) throw( ... ) :
		m_str( str ),
		m_pszBuffer( NULL ),
#ifdef _DEBUG
		m_nBufferLength( str.GetLength() ),
#endif
		m_nLength( str.GetLength() )
	{
		m_pszBuffer = m_str.GetBuffer();
	}
	CStrBufT( StringType& str, int nMinLength, DWORD dwFlags = AUTO_LENGTH ) throw( ... ) :
		m_str( str ),
		m_pszBuffer( NULL ),
#ifdef _DEBUG
		m_nBufferLength( nMinLength ),
#endif
		m_nLength( (dwFlags&AUTO_LENGTH) ? -1 : nMinLength )
	{
		if( dwFlags&SET_LENGTH )
		{
			m_pszBuffer = m_str.GetBufferSetLength( nMinLength );
		}
		else
		{
			m_pszBuffer = m_str.GetBuffer( nMinLength );
		}
	}
	~CStrBufT() throw()
	{
		m_str.ReleaseBuffer( m_nLength );
	}

	operator PXSTR() throw()
	{
		return( m_pszBuffer );
	}
	operator PCXSTR() const throw()
	{
		return( m_pszBuffer );
	}

	void SetLength( int nLength ) throw()
	{
		ATLASSERT( nLength <= m_nBufferLength );
		m_nLength = nLength;
	}

// Implementation
private:
	StringType& m_str;
	PXSTR m_pszBuffer;
	int m_nLength;
#ifdef _DEBUG
	int m_nBufferLength;
#endif

// Private copy constructor and copy assignment operator to prevent accidental use
private:
	CStrBufT( const CStrBufT& ) throw();
	CStrBufT& operator=( const CStrBufT& ) throw();
};

typedef CSimpleStringT< TCHAR > CSimpleString;
typedef CSimpleStringT< char > CSimpleStringA;
typedef CSimpleStringT< wchar_t > CSimpleStringW;
typedef CStrBufT< TCHAR > CStrBuf;
typedef CStrBufT< char > CStrBufA;
typedef CStrBufT< wchar_t > CStrBufW;

};  // namespace ATL

#endif  // __ATLSIMPSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsharedsvc.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSHAREDSVC_H__
#define __ATLSHAREDSVC_H__

#pragma once

#include <atltime.h>

namespace ATL{

#ifndef ATL_SHAREDBLOBCACHE_TIMEOUT
	#define ATL_SHAREDBLOBCACHE_TIMEOUT 36000000000 // in 100 nano second intervals
													 // each entry will be free'd if 
													// no access in 1 hour.
#endif

// Interface used by to access the shared blob cache.
[ uuid("AB4AF9CD-8DB1-4974-A617-CF0449578FB9"), object ]
__interface ISharedBlobCache
{
    [id(0)] STDMETHOD(AddItem)([in] BSTR szItemName, [in] BSTR szData);
    [id(1)] STDMETHOD(GetItem)([in] BSTR szItemName, [out,retval] BSTR *szData); 
};

class CSharedCache: 
	public CBlobCache<CWorkerThreadWrapper<>, CStdStatClass >,
	public IMemoryCacheClient,
	public ISharedBlobCache
{
	typedef CBlobCache<CWorkerThreadWrapper<>, CStdStatClass > basecache;
public:

	// IMemoryCacheClient method, frees data in the memory cache.
	STDMETHOD( Free )(const void *pvData)
	{
		if (pvData)
		{
			::SysFreeString((BSTR)pvData);
		}
		return S_OK;
	}


	STDMETHODIMP AddItem(BSTR szItemName, BSTR szData)
	{

		HRESULT hr = E_UNEXPECTED;
		USES_CONVERSION;

		// We make a copy of the BSTR and stick it in the cache.
		// The BSTR will be freed in our IMemoryCacheClient::Free
		// implementation above.
		BSTR szEntry = SysAllocString(szData);
		if(szEntry)
		{
			// create a time span and for the entry
			CFileTime tm = CFileTime::GetCurrentTime();
			CFileTimeSpan span;
			span.SetTimeSpan(ATL_SHAREDBLOBCACHE_TIMEOUT);
			tm += span;
			HANDLE h;
			hr = basecache::Add(OLE2T(szItemName), szEntry, sizeof(BSTR), 
				&tm, _AtlBaseModule.m_hInst, &h, static_cast<IMemoryCacheClient*>(this));

			if (hr == S_OK)
			{
				// On successful add, we have to release our 
				// reference on the entry.
				basecache::ReleaseEntry(h);
			}
		}
		return hr;
	}

    STDMETHODIMP GetItem(BSTR szItemName, BSTR *szData)
	{
		USES_CONVERSION;
		HRESULT hr = E_UNEXPECTED;
		HANDLE hEntry = NULL;

		if (!szItemName || !szData)
			return hr;

		DWORD dwSize = 0;
		hr = basecache::LookupEntry(OLE2T(szItemName), &hEntry);
		if (hr == S_OK)
		{
			void *pData = NULL;
			DWORD dwSize;
			hr = basecache::GetData(hEntry, &pData, &dwSize);
			if (hr == S_OK)
			{
				// make a copy of the string
				*szData = ::SysAllocString((BSTR)pData);
			}
			basecache::ReleaseEntry(hEntry);
		}
		return hr;
	}


	STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
	{
		HRESULT hr = E_NOINTERFACE;
		if (InlineIsEqualGUID(__uuidof(IMemoryCacheClient), riid)||
			InlineIsEqualGUID(__uuidof(IUnknown), riid))
		{
			*ppv = static_cast<void*>(static_cast<IMemoryCacheClient*>(this));
			hr = S_OK;
		}
		else if( InlineIsEqualGUID(__uuidof(ISharedBlobCache), riid))
		{
			*ppv = static_cast<void*>(static_cast<ISharedBlobCache*>(this));
			hr = S_OK;
		}
		return hr;
	}
	ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}
};


// This class implements the SOAP interface for the shared blob cache.
[
	coclass, 
	soap_handler(	name="SharedBlobCache", 
					namespace="http://www.microsoft.com/vc/atlserver/soap/SharedBlobCache",
					protocol="soap"
				),
	uuid("C518C876-7685-4050-9E01-898271C05F88")
]
class CSharedCacheHandler:
	public CSoapHandler<CSharedCacheHandler>,
	public ISharedBlobCache
{
public:
	[soap_method]
    STDMETHOD(AddItem)(BSTR szItemName, BSTR szData)
	{
		if (!m_spMemCache)
			return E_UNEXPECTED;
		return m_spMemCache->AddItem(szItemName, szData);
	}

	[soap_method]
	STDMETHOD(GetItem)(BSTR szItemName, BSTR *szData)
	{	
		if (!m_spMemCache)
			return E_UNEXPECTED;
		return m_spMemCache->GetItem(szItemName, szData);
	}

	DWORD Initialize(IServiceProvider *pProvider)
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spMemCache)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(ISharedBlobCache), &m_spMemCache);
		return m_spMemCache ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

	// override HandleRequest to Initialize our m_spServiceProvider
	// and to handle authorizing the client.
	DWORD HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		DWORD dwErr = Initialize(pProvider);
		if (dwErr != HTTP_SUCCESS)
			return dwErr;

		dwErr = CSoapHandler<CSharedCacheHandler>::HandleRequest(pRequestInfo,
								pProvider);
		return dwErr;
	}
	CComPtr<ISharedBlobCache> m_spMemCache;
};

} //ATL

#endif // __ATLSHAREDSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsmtputil.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSMTPUTIL_H__
#define __ATLSMTPUTIL_H__

#pragma once

#if (defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_))
#error <atlsmtputil.h> requires <winsock2.h> -- include <winsock2.h> before you include <windows.h> or <winsock.h>
#endif
#include <winsock2.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <tchar.h>
#include <atlstr.h>
#include <winnls.h>
#include <atlspriv.h>

//=======================================================================
//defines for SMTPMail module
//=======================================================================

//If overlapped I/O is desired, need 2.0 or greater
#define ATLSMTP_WSA_VERSION  ATL_WINSOCK_VER

//The maximum number of characters on a SMTP line
#define ATLSMTP_MAX_LINE_LENGTH 1000

#define ATLSMTP_MAX_SERVER_NAME_LENGTH 500

//Encoding schemes
#define ATLSMTP_BASE64_ENCODE 0
#define ATLSMTP_UUENCODE      1
#define ATLSMTP_QP_ENCODE     2

//I/O Defines
#define ATLSMTP_READBUFFER_SIZE        4096
#define ATLSMTP_GET_LINES              100


//Miscellaneous defines
#define ATLSMTP_SEND_FILE   1
#define ATLSMTP_FORMAT_SMTP 8

#define ATLSMTP_RETCODE_LEN 3

namespace ATL
{

//=======================================================================
// Miscellaneous Utility Functions
//=======================================================================
//A list of recipients in a string must by separated by one
//of the following characters
inline BOOL AtlSmtpIsRecipientDelimiter(char ch)
{
	return (ch == ',' || ch == ';' || ch == ' ' || ch == '\0');
}

//Send data to hFile and wait for it to finish sending
inline BOOL AtlSmtpSendAndWait(HANDLE hFile, LPCSTR lpData, int nDataLength, LPOVERLAPPED pOverlapped)
{
	ATLASSERT(lpData != NULL);
	ATLASSERT(pOverlapped != NULL);

	DWORD dwWritten = 0, dwErr = 0;
	int nRet = 0, nBufPos = 0;

	//write all the data
	do 
	{
		//Write a chunk of data, offsetting the buffer and amount to write by what's already 
		//been written
		nRet = WriteFile(hFile, (void*)(lpData+nBufPos), nDataLength-nBufPos, &dwWritten, pOverlapped);
		if (!nRet && (dwErr = GetLastError()) != ERROR_IO_INCOMPLETE && dwErr != ERROR_IO_PENDING)
			return FALSE;

		//Get the result of the write operation (wait for it)
		nRet = GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE);
		if (!nRet)
			return FALSE;

		//Need to update offsets when writing to a file
		pOverlapped->Offset += dwWritten;
		nBufPos += dwWritten;

	} while (nBufPos < nDataLength);
	return TRUE;
}


//Read up to nDestLen bytes from hFile, keep reading while there's more data and there's
//room in the buffer
inline BOOL AtlSmtpReadData(HANDLE hFile, LPSTR lpData, int* pnDestLen, LPOVERLAPPED pOverlapped)
{
	ATLASSERT(lpData != NULL);
	ATLASSERT(pnDestLen != NULL);
	ATLASSERT(pOverlapped != NULL);

	DWORD dwRead = 0, dwErr = 0;
	int nBufPos = 0;
	do
	{
		//REad a chunk of data, offsetting the buffer and amount to read by what's already been read
		int nRet = ReadFile(hFile, (void*)(lpData+nBufPos), (*pnDestLen)-nBufPos, &dwRead, pOverlapped);
		if (!nRet && (dwErr = GetLastError()) != ERROR_MORE_DATA && dwErr != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
			return FALSE;

		//Get the result of the read operation (wait for it)
		nRet = GetOverlappedResult(hFile, pOverlapped, &dwRead, TRUE);
		if (!nRet)
			return FALSE;

		//Handle offsets when reading from a file
		pOverlapped->Offset += dwRead;
		nBufPos += dwRead;
	} while (nBufPos < *pnDestLen && dwErr == ERROR_MORE_DATA);
	*pnDestLen = nBufPos;
	return TRUE;
}


//Used in sending encoded data
//lpData is the data to be sent now
//lpPrev is a pointer to the buffer that the previous call was made on
//This allows the new buffer (lpData) to be filled while lpPrev is being sent
//If all the data in lpPrev had not finished sending, we complete the send and wait
inline BOOL AtlSmtpSendOverlapped(HANDLE hFile, LPCSTR lpData, int nDataLength, LPCSTR lpPrev, DWORD dwPrevLength, LPOVERLAPPED pOverlapped)
{
	ATLASSERT(lpData != NULL);
	ATLASSERT(pOverlapped != NULL);

	DWORD dwWritten = 0, dwErr = 0, dwBufPos = 0;
	int nRet = 0;

	//Get the results of the previous call (if any)
	if (lpPrev && (!GetOverlappedResult(hFile, pOverlapped, &dwWritten, FALSE) || dwWritten < dwPrevLength))
	{
		//If any error but IO_INCOMPLETE, return failure
		if ((dwErr = GetLastError()) != ERROR_SUCCESS  && dwErr != ERROR_IO_INCOMPLETE && dwErr != ERROR_IO_PENDING)
		{
			return FALSE;
		}
		//Finish writing lpPrev if we need to
		while (dwBufPos < dwPrevLength)
		{
			//Get the result of the previous write (wait for it)
			nRet = GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE);
			if (!nRet || (dwBufPos += dwWritten) == dwPrevLength)
			{
				if ((dwErr = GetLastError()) != ERROR_IO_INCOMPLETE && dwErr != ERROR_IO_PENDING)
					break;
			}

			//If we are writing to a file, we need to update the offsets
			pOverlapped->Offset += dwWritten;
			//pOverlapped->OffsetHigh = HIWORD(pOverlapped->Offset);
			nRet = WriteFile(hFile, (void*)(lpPrev+dwBufPos), dwPrevLength-dwBufPos, &dwWritten, pOverlapped);

			//If any error but IO_PENDING and IO_INCOMPLETE, break
			if (!nRet && (dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
				break;
		}
		if (dwBufPos < dwPrevLength)
			return FALSE;
	}

	//Now that all the previous data has been sent, start sending the current data
	nRet = WriteFile(hFile, (void*)lpData, nDataLength, &dwWritten, pOverlapped);
	GetOverlappedResult(hFile, pOverlapped, &dwWritten, FALSE);

	pOverlapped->Offset += dwWritten;

	//If any error but IO_PENDING
	if (!nRet && (dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
		return FALSE;
	return TRUE;
}


//Send a SMTP command and read the response
//return TRUE if it matches szResponse, FALSE otherwise
inline BOOL AtlSmtpSendAndCheck(HANDLE hFile, LPCSTR lpData, int nDataLength, LPSTR lpResponse, int* pnResponseLength, int nMaxResponseLength, 
							 LPCSTR szResponse, LPOVERLAPPED pOverlapped)
{
	ATLASSERT(lpData != NULL);
	ATLASSERT(lpResponse != NULL);
	ATLASSERT(pnResponseLength != NULL);

	BOOL bRet = AtlSmtpSendAndWait(hFile, lpData, nDataLength, pOverlapped);
	if (bRet)
	{
		*pnResponseLength = nMaxResponseLength;
		bRet = AtlSmtpReadData(hFile, lpResponse, pnResponseLength, pOverlapped);
	}
	if (!bRet || strncmp((char*)lpResponse, szResponse, ATLSMTP_RETCODE_LEN))
		return FALSE;
	return TRUE;
}

} // namespace ATL

#endif // __ATLSMTPUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlserr.h ===
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSERR_H__
#define __ATLSERR_H__

#pragma once

namespace ATL{

#define VALIDATION_S_OK				0x00000000
#define VALIDATION_S_EMPTY			0x00000001
#define VALIDATION_E_PARAMNOTFOUND	0x00000002
#define VALIDATION_E_LENGTHMIN		0x80000083
#define VALIDATION_E_LENGTHMAX		0x80000084
#define VALIDATION_E_INVALIDLENGTH  0x80000080
#define VALIDATION_E_INVALIDPARAM	0x80000005
#define VALIDATION_E_FAIL			0x80000006

#define VALIDATION_SUCCEEDED(x) (((x == VALIDATION_S_OK) || (x == VALIDATION_S_EMPTY )))

typedef DWORD HTTP_CODE;

#define HTTP_ERROR(err, sub)			((HTTP_CODE)(DWORD_PTR)MAKELONG((WORD)err, (WORD)sub))
#define HTTP_ERROR_CODE(err)			((DWORD)LOWORD(err))
#define HTTP_SUBERROR_CODE(err)			((DWORD)HIWORD(err))
#define HTTP_SUCCESS					HTTP_ERROR(0, 0)

#define SUBERR_NONE								0
#define ISE_SUBERR_BADSRF						1
#define ISE_SUBERR_HNDLFAIL						2
#define ISE_SUBERR_SYSOBJFAIL					3
#define ISE_SUBERR_READFILEFAIL					4
#define ISE_SUBERR_LOADFILEFAIL                 6
#define ISE_SUBERR_LOADLIB						7
#define ISE_SUBERR_HANDLERIF					8
#define ISE_SUBERR_OUTOFMEM						9
#define ISE_SUBERR_UNEXPECTED					10
#define ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET	11
#define ISE_SUBERR_STENCIL_MISMATCHWHILE		12
#define ISE_SUBERR_STENCIL_MISMATCHIF			13
#define ISE_SUBERR_STENCIL_UNEXPECTEDTYPE		14
#define ISE_SUBERR_STENCIL_INVALIDINDEX			15
#define ISE_SUBERR_STENCIL_INDEXOUTOFRANGE		16
#define ISE_SUBERR_STENCIL_PARSE_FAIL			17
#define ISE_SUBERR_STENCIL_LOAD_FAIL			18
#define ISE_SUBERR_HANDLER_NOT_FOUND			19
#define ISE_SUBERR_BAD_HANDLER_TAG				20
#define ISE_SUBERR_NO_HANDLER_TAG				21
#define ISE_SUBERR_LONGMETHODNAME				22
#define ISE_SUBERR_LONGHANDLERNAME				23
#define ISE_SUBERR_IMPERSONATIONFAILED			24
#define ISE_SUBERR_ISAPISTARTUPFAILED			25
#define SUBERR_NO_PROCESS						26
#define SUBERR_S_FALSE							27
#define SUBERR_ASYNC							28
#define SUBERR_ASYNC_DONE						29
#define SUBERR_ASYNC_NOFLUSH					20
#define SUBERR_ASYNC_NOFLUSH_DONE				31
#define SUBERR_NO_CACHE							32
#define DBG_SUBERR_ALREADY_DEBUGGING            33
#define DBG_SUBERR_NOT_DEBUGGING                34
#define DBG_SUBERR_INVALID_SESSION              35
#define DBG_SUBERR_BAD_ID                       36
#define DBG_SUBERR_COCREATE                     37
#define DBG_SUBERR_ATTACH                       38


#define HTTP_FAIL						HTTP_ERROR(500, SUBERR_NONE)
#define HTTP_SUCCESS_NO_PROCESS			HTTP_ERROR(200, SUBERR_NO_PROCESS)
#define HTTP_S_FALSE					HTTP_ERROR(HTTP_ERROR_CODE(HTTP_SUCCESS), SUBERR_S_FALSE)
#define HTTP_SUCCESS_ASYNC				HTTP_ERROR(200, SUBERR_ASYNC)
#define HTTP_SUCCESS_ASYNC_DONE         HTTP_ERROR(200, SUBERR_ASYNC_DONE)
#define HTTP_SUCCESS_ASYNC_NOFLUSH		HTTP_ERROR(200, SUBERR_ASYNC_NOFLUSH)
#define HTTP_SUCCESS_ASYNC_NOFLUSH_DONE HTTP_ERROR(200, SUBERR_ASYNC_NOFLUSH_DONE)
#define HTTP_SUCCESS_NO_CACHE           HTTP_ERROR(200, SUBERR_NO_CACHE)
#define HTTP_OK							HTTP_ERROR(200, SUBERR_NONE)
#define HTTP_CONTINUE					HTTP_ERROR(100, SUBERR_NONE)

#define HTTP_CREATED					HTTP_ERROR(201, SUBERR_NONE)
#define HTTP_ACCEPTED					HTTP_ERROR(202, SUBERR_NONE)
#define HTTP_NON_AUTHORITATIVE			HTTP_ERROR(203, SUBERR_NONE)
#define HTTP_NO_CONTENT					HTTP_ERROR(204, SUBERR_NONE)
#define HTTP_RESET_CONTENT				HTTP_ERROR(205, SUBERR_NONE)
#define HTTP_PARTIAL_CONTENT			HTTP_ERROR(206, SUBERR_NONE)

#define HTTP_MULTIPLE_CHOICES			HTTP_ERROR(300, SUBERR_NONE)
#define HTTP_MOVED_PERMANENTLY			HTTP_ERROR(301, SUBERR_NONE)
#define HTTP_FOUND						HTTP_ERROR(302, SUBERR_NONE)
#define HTTP_SEE_OTHER					HTTP_ERROR(303, SUBERR_NONE)
#define HTTP_NOT_MODIFIED				HTTP_ERROR(304, SUBERR_NONE)
#define HTTP_USE_PROXY					HTTP_ERROR(305, SUBERR_NONE)
#define HTTP_TEMPORARY_REDIRECT			HTTP_ERROR(307, SUBERR_NONE)

#define HTTP_BAD_REQUEST				HTTP_ERROR(400, SUBERR_NONE)
#define HTTP_UNAUTHORIZED				HTTP_ERROR(401, SUBERR_NONE)
#define HTTP_PAYMENT_REQUIRED			HTTP_ERROR(402, SUBERR_NONE)
#define HTTP_FORBIDDEN					HTTP_ERROR(403, SUBERR_NONE)
#define HTTP_NOT_FOUND					HTTP_ERROR(404, SUBERR_NONE)
#define HTTP_METHOD_NOT_ALLOWED			HTTP_ERROR(405, SUBERR_NONE)
#define HTTP_NOT_ACCEPTABLE				HTTP_ERROR(406, SUBERR_NONE)
#define HTTP_PROXY_AUTHENTICATION_REQUIRED	HTTP_ERROR(407, SUBERR_NONE)
#define HTTP_REQUEST_TIMEOUT			HTTP_ERROR(408, SUBERR_NONE)
#define HTTP_CONFLICT					HTTP_ERROR(409, SUBERR_NONE)
#define HTTP_GONE						HTTP_ERROR(410, SUBERR_NONE)
#define HTTP_LENGTH_REQUIRED			HTTP_ERROR(411, SUBERR_NONE)
#define HTTP_PRECONDITION_FAILED		HTTP_ERROR(412, SUBERR_NONE)
#define HTTP_REQUEST_ENTITY_TOO_LONG	HTTP_ERROR(413, SUBERR_NONE)
#define HTTP_REQUEST_URI_TOO_LONG		HTTP_ERROR(414, SUBERR_NONE)
#define HTTP_UNSUPPORTED_MEDIA_TYPE		HTTP_ERROR(415, SUBERR_NONE)
#define HTTP_RANGE_NOT_SATISFIABLE		HTTP_ERROR(416, SUBERR_NONE)
#define HTTP_EXPECTATION_FAILED			HTTP_ERROR(417, SUBERR_NONE)

#define HTTP_INTERNAL_SERVER_ERROR		HTTP_ERROR(500, SUBERR_NONE)
#define HTTP_NOT_IMPLEMENTED			HTTP_ERROR(501, SUBERR_NONE)
#define HTTP_BAD_GATEWAY				HTTP_ERROR(502, SUBERR_NONE)
#define HTTP_SERVICE_UNAVAILABLE		HTTP_ERROR(503, SUBERR_NONE)
#define HTTP_GATEWAY_TIMEOUT			HTTP_ERROR(504, SUBERR_NONE)
#define HTTP_VERSION_NOT_SUPPORTED		HTTP_ERROR(505, SUBERR_NONE)

inline bool IsAsyncStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_DONE ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

inline bool IsAsyncContinueStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH;
}

inline bool IsAsyncDoneStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC_DONE ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

inline bool IsAsyncFlushStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_DONE;
}

inline bool IsAsyncNoFlushStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

}; // namespace ATL

#endif // __ATLSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsmtpconnection.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSMTPCONNECTION_H__
#define __ATLSMTPCONNECTION_H__

#pragma once

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "ws2_32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <atlstr.h>
#include <atlcoll.h>
#include <atlfile.h>
#include <atlmime.h>
#include <atlspriv.h>
#include <atlsmtputil.h>




// SMTP Return Codes
#define ATLSMTP_MAIL_SUCCESS      250
#define ATLSMTP_RCPT_SUCCESS      250
#define ATLSMTP_RCPT_NOT_LOCAL    251
#define ATLSMTP_DATA_INTERMEDIATE 354

#define ATLSMTP_CONN_SUCC "220"
#define ATLSMTP_HELO_SUCC "250"
#define ATLSMTP_MAIL_SUCC "250"
#define ATLSMTP_RCPT_SUCC "250"
#define ATLSMTP_RCPT_NLOC "251"
#define ATLSMTP_DATA_INTM "354"
#define ATLSMTP_DATA_SUCC "250"
#define ATLSMTP_RSET_SUCC "250"

// SMTP flags
#define ATLSMTP_DUMP_SENDER 1
#define ATLSMTP_DUMP_RECIPS 2
#define ATLSMTP_FOR_SEND    4


struct CSMTPWSAStartup
{
private:
	bool m_bInit;

public:
	CSMTPWSAStartup() throw()
		:m_bInit(false)
	{
		Init();
	}

	~CSMTPWSAStartup() throw()
	{
		Uninit();
	}

	bool Init() throw()
	{
		if (m_bInit)
			return true;

		WSADATA wsadata;
		if (WSAStartup(ATLSMTP_WSA_VERSION, &wsadata))
			return false;
		m_bInit = true;
		ATLASSERT(wsadata.wHighVersion >= 2);
		return true;
	}

	bool Uninit() throw()
	{
		if (m_bInit)
			if (WSACleanup())
				return false;
		m_bInit = false;
		return true;
	}
};

__declspec(selectany) CSMTPWSAStartup _g_smtp_init;

namespace ATL {

class CSMTPConnection
{
protected:

	// the socket
	SOCKET m_hSocket;

	// the OVERLAPPED struct
	OVERLAPPED m_Overlapped;

public:

	CSMTPConnection() throw()
		:m_hSocket(INVALID_SOCKET)
	{
		// initialize the OVERLAPPED struct
		memset(&m_Overlapped, 0, sizeof(OVERLAPPED));
	}

	~CSMTPConnection() throw()
	{
		Disconnect();
	}

	// Attempt to connect to the socket
	// lpszHostName - the host name to connect to
	BOOL Connect(LPCTSTR lpszHostName, DWORD dwTimeout = 10000) throw()
	{
		ATLASSERT(lpszHostName != NULL);

		// If we're already connected
		if (Connected())
		{
			return FALSE;
		}

		if (!_g_smtp_init.Init())
		{
			return FALSE;
		}

		CTCPAddrLookup address;
		if (0 != address.GetRemoteAddr(lpszHostName, IPPORT_SMTP))
		{
			return FALSE;
		}

		// create the socket
		m_hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_IP, NULL, 0, WSA_FLAG_OVERLAPPED);
		
		if (m_hSocket == INVALID_SOCKET)
		{
			return FALSE;
		}

		BOOL bRet = FALSE;
		WSAEVENT hEventConnect = WSACreateEvent();
		if (hEventConnect != NULL)
		{
			if (SOCKET_ERROR != WSAEventSelect(m_hSocket, hEventConnect, FD_CONNECT))
			{
				if (WSAConnect(m_hSocket, address.Addr, address.AddrSize, 
						NULL, NULL, NULL, NULL))
				{
					if (WSAGetLastError() == WSAEWOULDBLOCK)
					{
						DWORD dwWait = WaitForSingleObject((HANDLE) hEventConnect, dwTimeout);
						if (dwWait == WAIT_OBJECT_0)
						{
							// make sure there were no connection errors.
							WSANETWORKEVENTS wse;
							ZeroMemory(&wse, sizeof(wse));
							WSAEnumNetworkEvents(m_hSocket, NULL, &wse);
							if (wse.iErrorCode[FD_CONNECT_BIT]==0)
							{
								bRet = TRUE;
							}
						}
					}
				}
			}

			// we're done with the event
			WSACloseEvent(hEventConnect);
		}

		// Create an event for asynchronous I/O
		if (bRet)
		{
			ATLASSERT(m_Overlapped.hEvent == NULL);
			m_Overlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
			if (m_Overlapped.hEvent == NULL)
			{
				bRet = FALSE;
			}
		}

		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];
		int nBufLen = ATLSMTP_MAX_LINE_LENGTH;
		if (bRet)
		{
			// See if the connect returns success
			AtlSmtpReadData((HANDLE)m_hSocket, szBuf, &nBufLen, &m_Overlapped);
			if (strncmp(szBuf, ATLSMTP_CONN_SUCC, ATLSMTP_RETCODE_LEN))
			{
				bRet = FALSE;
			}
		}

		char szLocalHost[ATLSMTP_MAX_SERVER_NAME_LENGTH+1];

		// gethostname should return 0 on success
		if (bRet && gethostname(szLocalHost, ATLSMTP_MAX_SERVER_NAME_LENGTH))
		{
			bRet = FALSE;
		}

		// Send HELO command and get reply
		if (bRet)
		{
			nBufLen = sprintf(szBuf, "HELO %s\r\n", szLocalHost);
			bRet = AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, szBuf, &nBufLen, 
										ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_HELO_SUCC, &m_Overlapped);
		}

		if (!bRet)
		{
			if (m_Overlapped.hEvent != NULL)
				CloseHandle(m_Overlapped.hEvent);
			shutdown(m_hSocket, SD_BOTH);
			closesocket(m_hSocket);
			m_hSocket = INVALID_SOCKET;
		}

		return bRet;
	}

	// Disconnect the socket
	inline BOOL Disconnect() throw()
	{
		if (!Connected())
		{
			return FALSE;
		}

		// shutdown should return 0 on success
		if (shutdown(m_hSocket, SD_BOTH))
		{
			return FALSE;
		}

		// closesocket should return 0 on success
		if (closesocket(m_hSocket))
		{
			return FALSE;
		}

		// close the handle to the overlapped event
		CloseHandle(m_Overlapped.hEvent);
		m_hSocket = INVALID_SOCKET;
		memset((void*)&m_Overlapped, 0, sizeof(OVERLAPPED));
		return TRUE;
	}

	// Are we connected?
	inline BOOL Connected() throw()
	{
		return (m_hSocket != INVALID_SOCKET ? TRUE : FALSE);
	}

	// Send a message from a file
	// lpszFileName - the file containing the message
	// lpszRecipients - the recipients to send to (optional - if not specified, the recipients specified
	//		in the file will be used
	// lpszSender - the sender (optional - if not specified, the recipients specified in the file
	//		will be used
	BOOL SendMessage(LPCTSTR lpszFileName, LPCTSTR lpszRecipients = NULL, LPCTSTR lpszSender = NULL) throw()
	{
		if (!Connected())
		{
			return FALSE;
		}

		//Try to open the file
		CAtlFile readFile;
		if (FAILED(readFile.Create(lpszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL)))
		{
			return FALSE;
		}

		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];
		int nBufLen = ATLSMTP_MAX_LINE_LENGTH;
		BOOL bDumpedSender = FALSE;

		//If the caller specifies the sender, rather than having an existing one in the file...
		if (lpszSender)
		{
			nBufLen = sprintf(szBuf, "MAIL FROM:<%s>\r\n", (LPCSTR) CT2CA(lpszSender));
			if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, 
									ATLSMTP_MAIL_SUCC, &m_Overlapped))
			{
				return FALSE;
			}
			bDumpedSender = TRUE;
		}
		nBufLen = ATLSMTP_MAX_LINE_LENGTH;

#ifdef ATLSMTP_DOUBLE_BUFFERED
		char buffer1[ATLSMTP_READBUFFER_SIZE];
		char buffer2[ATLSMTP_READBUFFER_SIZE];
		char* currBuffer = buffer1;
		char* prevBuffer = NULL;

		int nCurrBuffer = 0;
		DWORD dwPrevLength = 0;
		DWORD dwWritten = 0;
#else
		char bakBuffer[ATLSMTP_READBUFFER_SIZE];
		char* currBuffer = bakBuffer;

#endif // ATLSMTP_DOUBLE_BUFFERED
		DWORD dwRead = 0;
		DWORD dwBytesInBuffer = 0;
		DWORD dwBufPos = 0;

		//first handle the MAIL FROM and RCPT TO commands
		BOOL bDumpedRecipients = FALSE;
		BOOL bRet = TRUE;
		while (bRet)
		{
			int nRetCode = 0;

			//if we have dumped the sender, and we have extra recipients to send,
			//and we haven't alredy done so, do it
			if (lpszRecipients && !bDumpedRecipients && bDumpedSender)
			{
				bRet = DumpRecipients((HANDLE)m_hSocket, CT2A(lpszRecipients), &m_Overlapped, ATLSMTP_FOR_SEND);
			}

			if (bRet)
			{
				dwRead = 0;
				BOOL bFullLine = FALSE;
				bRet = ReadLine(readFile, currBuffer, szBuf, &dwBytesInBuffer, &dwBufPos,
					ATLSMTP_READBUFFER_SIZE, ATLSMTP_MAX_LINE_LENGTH, &dwRead, &bFullLine);
				if (dwRead == 0 || bFullLine == FALSE)
					bRet = FALSE;
			}

			if (bRet)
			{
				bRet = AtlSmtpSendAndWait((HANDLE)m_hSocket, szBuf, (int)(dwRead), &m_Overlapped);
			}

			if (bRet)
			{
				nBufLen = ATLSMTP_MAX_LINE_LENGTH;
				bRet = AtlSmtpReadData((HANDLE)m_hSocket, szBuf, &nBufLen, &m_Overlapped);
			}

			if (bRet)
			{	
				nRetCode = atoi(szBuf);
				//if the command is equal to ATLSMTP_MAIL_SUCC (or RCPT_SUCC: they are equivalent)
				if (nRetCode == ATLSMTP_MAIL_SUCCESS || nRetCode == ATLSMTP_RCPT_NOT_LOCAL || nRetCode == ATLSMTP_RCPT_SUCCESS)
				{
					bDumpedSender = TRUE;
					continue;
				}

				//If the command is equal to the data intermediate success code,
				//break out of the loop
				if (nRetCode == ATLSMTP_DATA_INTERMEDIATE)
					break;
			}

			//otherwise, we got an error code
			CancelMessage();
			return FALSE;
		}

		dwRead = dwBytesInBuffer;
		currBuffer+= dwBufPos;
		DWORD dwErr = 0;
		do
		{
			dwErr = 0;

			//Try to send the data
#ifdef ATLSMTP_DOUBLE_BUFFERED
			if (!AtlSmtpSendOverlapped((HANDLE)m_hSocket, currBuffer, dwRead, prevBuffer, dwPrevLength, &m_Overlapped))
			{
				bRet = FALSE;
				break;
			}
#else
			if (!AtlSmtpSendAndWait((HANDLE)m_hSocket, currBuffer, dwRead, &m_Overlapped))
			{
				bRet = FALSE;
				break;
			}
#endif // ATLSMTP_DOUBLE_BUFFERED

			//swap the current and previous buffer
#ifdef ATLSMTP_DOUBLE_BUFFERED
			prevBuffer = currBuffer;
			currBuffer = (nCurrBuffer == 0 ? buffer2 : buffer1);
			nCurrBuffer = (nCurrBuffer == 0 ? 1 : 0);
			dwPrevLength = dwBytesInBuffer;
#else
			currBuffer = bakBuffer;
#endif // ATLSMTP_DOUBLE_BUFFERED

			if (FAILED(readFile.Read(currBuffer, ATLSMTP_READBUFFER_SIZE, dwRead)))
			{
				bRet = FALSE;
				break;
			}
		} while (dwRead != 0);

		//ensure that the last of the data is sent
#ifdef ATLSMTP_DOUBLE_BUFFERED
		if (!GetOverlappedResult((HANDLE)m_hSocket, &m_Overlapped, &dwWritten, TRUE))
		{
			if ((dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
				bRet = FALSE;
			else if (dwWritten < dwPrevLength)
				bRet = AtlSmtpSendAndWait((HANDLE)m_hSocket, prevBuffer+dwWritten, dwPrevLength-dwWritten, &m_Overlapped);
		}
#endif // ATLSMTP_DOUBLE_BUFFERED


		if (bRet)
		{
			// End the message with a CRLF.CRLF
			nBufLen = sprintf(szBuf, "\r\n.\r\n");
			if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
				szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_DATA_SUCC, &m_Overlapped))
			{
				bRet = FALSE;
			}
		}

		return bRet;
	}

	// Send the message
	// msg - the CMimeMessage to send
	// lpszSender - the sender 
	inline BOOL SendMessage(CMimeMessage& msg, LPCTSTR lpszRecipients = NULL, LPCTSTR lpszSender = NULL) throw()
	{
		if (!Connected())
		{
			return FALSE;
		}

		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];

		//Send MAIL FROM command and get reply
		int nBufLen = sprintf(szBuf, "MAIL FROM:<%s>\r\n", 
			(lpszSender ? (LPCSTR) CT2CA(lpszSender) : msg.GetSender()));
		if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
				szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_MAIL_SUCC, &m_Overlapped))
		{
			return FALSE;
		}

		BOOL bRet = TRUE;
		if (!lpszRecipients)
		{
			LPSTR lpszRecipientsA = NULL;
			DWORD dwLen = msg.GetRequiredRecipientsStringLength();
			lpszRecipientsA = static_cast<LPSTR>(malloc(sizeof(char)*dwLen));
			if (!lpszRecipientsA || msg.GetRecipientsString(lpszRecipientsA, &dwLen) == FALSE)
			{
				bRet = FALSE;
			}
			if (bRet)
				bRet = DumpRecipients((HANDLE)m_hSocket, lpszRecipientsA, &m_Overlapped, ATLSMTP_FOR_SEND);
			free(lpszRecipientsA);
		}
		else
		{
			bRet = DumpRecipients((HANDLE)m_hSocket, CT2CA(lpszRecipients), 
						&m_Overlapped, ATLSMTP_FOR_SEND);
		}

		//Begin the data output
		if (bRet)
		{
			nBufLen = sprintf(szBuf, "DATA\r\n");
			bRet = AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
						szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_DATA_INTM, &m_Overlapped);
		}

		if (!bRet)
			CancelMessage();

		//Attempt to write the data to the socket
		if (bRet)
		{
			bRet = msg.WriteData((HANDLE)m_hSocket, &m_Overlapped, NULL, ATLSMTP_FORMAT_SMTP);
		}

		if (bRet)
		{
			//End the message with a <CRLF>.<CRLF>
			nBufLen = sprintf(szBuf, "\r\n.\r\n");
			if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
					szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_DATA_SUCC, &m_Overlapped))
			{
				return FALSE;
			}
		}

		return bRet;
	}

	// Send a chunk of raw data
	inline BOOL SendRaw(LPCTSTR lpszRawData, DWORD dwLen, LPCTSTR lpszRecipients, LPCTSTR lpszSender) throw()
	{
		ATLASSERT(lpszRawData != NULL);
		ATLASSERT(lpszRecipients != NULL);
		ATLASSERT(lpszSender != NULL);

		if (!Connected())
			return FALSE;

		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];

		//Send MAIL FROM command and get reply
		int nBufLen = sprintf(szBuf, "MAIL FROM:<%s>\r\n", (LPCSTR) CT2CA(lpszSender));
		if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
				szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_MAIL_SUCC, &m_Overlapped))
		{
			return FALSE;
		}

		BOOL bRet = DumpRecipients((HANDLE)m_hSocket, CT2CA(lpszRecipients),
						&m_Overlapped, ATLSMTP_FOR_SEND);

		// Begin the data output
		if (bRet)
		{
			nBufLen = sprintf(szBuf, "DATA\r\n");
			bRet = AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen,
						szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_DATA_INTM, &m_Overlapped);
		}

		if (!bRet)
			CancelMessage();

		if (bRet)
		{
			bRet = AtlSmtpSendAndWait((HANDLE)m_hSocket, (LPSTR)(lpszRawData), dwLen, &m_Overlapped);
		}

		if (bRet)
		{
			//End the message with a <CRLF>.<CRLF>
			nBufLen = sprintf(szBuf, "\r\n.\r\n");
			if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, 
					szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, ATLSMTP_DATA_SUCC, &m_Overlapped))
			{
				return FALSE;
			}
		}

		return bRet;
	}

	inline BOOL SendSimple(LPCTSTR lpszRecipients, LPCTSTR lpszSender, LPCTSTR lpszSubject, LPCTSTR lpszBody, int nTextLen = -1) throw()
	{
		CMimeMessage msg;
		BOOL bRet = msg.SetSubject(lpszSubject);
		if (bRet)
			bRet = msg.AddText(lpszBody, nTextLen);

		CFixedStringT<CString, MAX_PATH> strRecip;
		LPCTSTR szTmp = lpszRecipients;
		LPCTSTR szTmp2 = lpszRecipients;
		while (*szTmp && bRet)
		{
			if (AtlSmtpIsRecipientDelimiter(*szTmp2))
			{
				_ATLTRY
				{
					strRecip.SetString(szTmp, (int)(szTmp2-szTmp));
					bRet = msg.AddRecipient((LPCTSTR) strRecip);
					
					if (*szTmp2)
					{
						while (*szTmp2 && AtlSmtpIsRecipientDelimiter(*szTmp2))
						{
							szTmp2++;
						}
					}
					szTmp = szTmp2;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
			}
			else
			{
				szTmp2++;
			}
		}

		if (bRet)
			bRet = SendMessage(msg, lpszRecipients, lpszSender);

		return bRet;
	}

	// Save a MIME message to a file
	// lpszFileName - the file name
	// lpszRecipients - the recipients string (optional)
	// lpszSender - the sender (optional)
	// dwFlags - the flags (optional)
	inline BOOL WriteToFile(LPCTSTR lpszFileName, CMimeMessage& msg, LPCTSTR lpszRecipients = NULL, 
		LPCTSTR lpszSender = NULL, DWORD dwFlags = 0) throw()
	{
		//Try to create/open the file
		HANDLE hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL,
			CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

		if (hFile == INVALID_HANDLE_VALUE)
		{
			return FALSE;
		}

		// Use CHandle to close the file handle
		// (CAtlFile does not allow for overlapped I/O)
		CHandle hdlFile(hFile);

		//Create and initialize the OVERLAPPED struct
		OVERLAPPED writeOverlapped;
		memset((void*)&writeOverlapped, 0, sizeof(OVERLAPPED));
		writeOverlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
		if (writeOverlapped.hEvent == NULL)
		{
			return FALSE;
		}

		// Use CHandle to close the event handle
		CHandle hdlEvent(writeOverlapped.hEvent);

		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];
		BOOL bRet = TRUE;

		int nBufLen = 0;

		//if writing to file for purposes of sending, write out the
		//commands as well
		if (lpszSender || (dwFlags & ATLSMTP_DUMP_SENDER))
		{
			nBufLen = sprintf(szBuf, "MAIL FROM:<%s>\r\n", 
				(lpszSender ? (LPCSTR) CT2CA(lpszSender) : msg.GetSender()));
			bRet = AtlSmtpSendAndWait(hFile, szBuf, nBufLen, &writeOverlapped);
		}

		if (bRet && (lpszRecipients || (dwFlags & ATLSMTP_DUMP_RECIPS)))
		{
			if (!lpszRecipients)
			{
				LPSTR lpszRecipientsA = NULL;
				DWORD dwLen = msg.GetRequiredRecipientsStringLength();
				lpszRecipientsA = static_cast<LPSTR>(malloc(sizeof(char)*dwLen));
				if (!lpszRecipientsA || msg.GetRecipientsString(lpszRecipientsA, &dwLen) == FALSE)
				{
					bRet = FALSE;
				}
				if (bRet)
					bRet = DumpRecipients(hFile, lpszRecipientsA, &writeOverlapped);
				free(lpszRecipientsA);
			}
			else
			{
				bRet = DumpRecipients(hFile, CT2CA(lpszRecipients), &writeOverlapped);
			}
		}

		if (bRet)
		{
			nBufLen = sprintf(szBuf, "DATA\r\n");
			bRet = AtlSmtpSendAndWait(hFile, szBuf, nBufLen, &writeOverlapped);
		}

		if (bRet)
		{
			bRet = msg.WriteData(hFile, &writeOverlapped, NULL, ATLSMTP_FORMAT_SMTP);
		}

		return bRet;
	}

protected:

	// disallow copy construction
	CSMTPConnection(const CSMTPConnection&) throw()
	{
		ATLASSERT(FALSE);
	}

	// disallow assignment
	const CSMTPConnection& operator=(const CSMTPConnection&) throw()
	{
		ATLASSERT(FALSE);
		return *this;
	}

	// Tell the server we are aborting the message
	inline BOOL CancelMessage() throw()
	{
		char szBuf[ATLSMTP_MAX_LINE_LENGTH+1];
		int nBufLen = sprintf(szBuf, "RSET\r\n");
		if (!AtlSmtpSendAndCheck((HANDLE)m_hSocket, szBuf, nBufLen, szBuf, &nBufLen, ATLSMTP_MAX_LINE_LENGTH, 
			ATLSMTP_RSET_SUCC, &m_Overlapped))
		{
			Disconnect();
			return FALSE;
		}
		return TRUE;
	}

	// Dump the recipients to hFile
	// lpszRecipients - the recipients string
	// pOverlapped - the OVERALAPPED struct
	// dwFlags - the flags
	inline BOOL DumpRecipients(HANDLE hFile, LPCSTR lpszRecipients, LPOVERLAPPED pOverlapped, DWORD dwFlags = 0) throw()
	{
		ATLASSERT(lpszRecipients != NULL);
		ATLASSERT(pOverlapped != NULL);

		char  rcptBuf[ATLSMTP_MAX_LINE_LENGTH-12];
		char  szBuf[ATLSMTP_MAX_LINE_LENGTH];
		LPSTR tmpBuf = rcptBuf;
		char ch;
		BOOL bRet = TRUE;
		int nMaxLength = ATLSMTP_MAX_LINE_LENGTH;
		int nRetCode = 0;
		do
		{
			ch = *lpszRecipients;
			if (ch)
				lpszRecipients++;
			if (AtlSmtpIsRecipientDelimiter(ch))
			{
				*tmpBuf = 0;
				int nBufLen = sprintf(szBuf, "RCPT TO:<%s>\r\n", rcptBuf);
				bRet = AtlSmtpSendAndWait(hFile, szBuf, nBufLen, pOverlapped);
				if (bRet && (dwFlags & ATLSMTP_FOR_SEND))
				{
					bRet = AtlSmtpReadData(hFile, szBuf, &nMaxLength, pOverlapped);
					nRetCode = atoi(szBuf);
					if (!bRet || (nRetCode != ATLSMTP_RCPT_SUCCESS && nRetCode != ATLSMTP_RCPT_NOT_LOCAL))
					{
						bRet = FALSE;
						break;
					}
				}
				tmpBuf = rcptBuf;
				nMaxLength = ATLSMTP_MAX_LINE_LENGTH;
				while (isspace(*lpszRecipients))
					lpszRecipients++;
				continue;
			}
			
			*tmpBuf++ = ch;
		} while (ch != '\0');
		
		return bRet;
	}

	// Implementation - used from ReadLine
	// fills pBuf with up to dwMaxLen bytes
	BOOL FillBuffer(HANDLE hFile, LPSTR pBuf, DWORD dwMaxLen, LPDWORD pdwLen) throw()
	{
		ATLASSERT(hFile != INVALID_HANDLE_VALUE);
		ATLASSERT(pdwLen != NULL);

		DWORD dwRead = 0;
		DWORD dwTotalRead = 0;
		int nRet = 0;

		do 
		{
			nRet = ReadFile(hFile, pBuf, dwMaxLen-dwTotalRead, &dwRead, NULL);
			if (!nRet && GetLastError() != ERROR_HANDLE_EOF)
			{
				return FALSE;
			}

			if (dwRead == 0)
				break;

			dwTotalRead+= dwRead;
		} while (dwTotalRead < dwMaxLen);

		*pdwLen = dwTotalRead;

		return TRUE;
	}

	// Implementation
	// Read a line (terminated by LF) from hFile
	BOOL ReadLine(HANDLE hFile, LPSTR pSrc, LPSTR pDest, LPDWORD pdwSrcLen, LPDWORD pdwBufPos, DWORD dwMaxSrcLen, 
			DWORD dwMaxDestLen, LPDWORD pdwRead=NULL, LPBOOL pbFullLine=NULL) throw()
	{
		ATLASSERT(hFile != INVALID_HANDLE_VALUE);
		ATLASSERT(pSrc != NULL);
		ATLASSERT(pDest != NULL);
		ATLASSERT(pdwSrcLen != NULL);
		ATLASSERT(pdwBufPos != NULL);

		BOOL bRet = TRUE;
		DWORD dwLen = 0;
		DWORD dwBufPos = 0;
		DWORD dwSrcLen = *pdwSrcLen;
		LPSTR pSrcCurrent = pSrc + *pdwBufPos;

		while (bRet && dwLen < dwMaxDestLen)
		{
			if (dwSrcLen == 0)
			{
				if (!FillBuffer(hFile, pSrc, dwMaxSrcLen, pdwSrcLen) || *pdwSrcLen == 0)
					break;

				dwBufPos = 0;
				*pdwBufPos = 0;
				dwSrcLen = *pdwSrcLen;
				pSrcCurrent = pSrc;
			}

			--dwSrcLen;
			*pDest = *pSrcCurrent++;
			dwLen++;
			dwBufPos++;
			if (*pDest == '\n')
			{
				break;
			}
			pDest++;
		}

		*pdwSrcLen = dwSrcLen;

		if (pbFullLine)
		{
			if (*pDest != '\n')
				*pbFullLine = FALSE;
			else
				*pbFullLine = TRUE;
		}

		if (pdwRead)
			*pdwRead = dwLen;

		*pdwBufPos += dwBufPos;

		return bRet;
	}

}; // class CSMTPConnection

} // namespace ATL

#endif // __ATLSMTPCONNECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSNAP_H__
#define __ATLSNAP_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <mmc.h>
#include <commctrl.h>
#include <atlwin.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

namespace ATL
{

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _AtlBaseModule.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_AtlWinModule.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		ATLASSERT(m_psp.lParam == (LPARAM)this);
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LONG_PTR arg,
        LONG_PTR param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,	
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LONG_PTR arg,
        LONG_PTR param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* /*pDataObject*/, CSnapInItem* /*pDefault*/)
	{
		ATLASSERT(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		if (IS_SPECIAL_DATAOBJECT(pDataObj))
		{
			ATLTRACENOTIMPL(_T("CSnapInItem::GetDataClass"));
		}

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, ATL::CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { ATL::CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			ATLASSERT(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return ATL::CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC * /*pformatetcIn*/, STGMEDIUM * /*pmedium*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC * /*pformatetc*/, DWORD /*advf*/, IAdviseSink * /*pAdvSink*/,
		DWORD * /*pdwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD /*dwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** /*ppenumAdvise*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(&m_spConsole);
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(__uuidof(IComponent), (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LONG_PTR arg,
        LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT /*lpDataObjectA*/,
        LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole.QueryInterface(&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(atlTraceSnapin, 0, _T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LONG_PTR arg,
        LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		if (lpDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			// Make sure that the object is derived from CSnapInObjectRoot
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
		}
		return hr;
	}
    
    STDMETHOD(Destroy)(LONG_PTR /*cookie*/)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(LONG_PTR cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::GetResultViewType\n"));

		HRESULT hr = E_FAIL;
		if (cookie == NULL)
		{
			T* pT = static_cast<T*> (this);
			ATLASSERT( pT->m_pComponentData != NULL );
			ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
			hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
		}
		else
		{
			CSnapInItem* pItem = (CSnapInItem*)cookie;
			hr = pItem->GetResultViewType(ppViewType, pViewOptions);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT /*lpDataObjectA*/,
        LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        long cookieA,
        long cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
		}
		return hr;
	}
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
			
			if (SUCCEEDED(hr))
				hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
		}

		return hr;
	}
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		

		HRESULT hr = E_POINTER;
		
		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->QueryPagesFor(type);
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LONG_PTR arg,
        LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type;
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
		{
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
			BOOL bSelect = (BOOL) HIWORD (arg);
			BOOL bScope = (BOOL) LOWORD(arg); 
			if (bSelect)
			{
				int n = pT->m_toolbarMap.GetSize();
				for (int i = 0; i < n; i++)
				{
					IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
					 if (pToolbar != NULL)
						pT->m_spControlbar->Detach(pToolbar);
				}
			}
		}

		if (SUCCEEDED(hr))
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		ATL::CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	void __stdcall CleanUp(DWORD_PTR /*dw*/)
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static ATL::CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static ATL::CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE /*event*/,
        LONG_PTR /*arg*/,
        LONG_PTR /*param*/,
		IComponentData* /*pComponentData*/,
		IComponent* /*pComponent*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM * /*pScopeDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM * /*pResultDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(_AtlBaseModule.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					hr;
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK /*lpProvider*/,
        LONG_PTR /*handle*/, 
		IUnknown* /*pUnk*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::SetControlbar\n"));
		static bool m_bAddTermFunc = false;
		if (!m_bAddTermFunc)
		{
			m_bAddTermFunc = true;
			_pAtlModule->AddTermFunc(CleanUpToolbarInfo, 0);
		}

		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_AtlBaseModule.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				ATLTRY(pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount]);

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons;
			ATLTRY(pButtons = new MMCBUTTON[pData->wItemCount]);
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				ATLTRY(pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount]);
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}
		
			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(_AtlBaseModule.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						ATLTRY(pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1]);
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
		LONG_PTR arg, 
		LONG_PTR param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;
				if (bSelect)
					pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						BOOL bEnable;
						if (bSelect)
							bEnable = pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED);
						else
							bEnable = FALSE;

						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED, bEnable
							);
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		ATLASSERT(pDataObj != NULL);
		if (pDataObj == NULL)
			return E_POINTER;
		*pDataObj = NULL;

		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(__uuidof(IDataObject), (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT /*id*/, LPTSTR /*pBuf*/, UINT * /*flags*/)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT /*id*/, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT /*id*/, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& /*bHandled*/,
		CSnapInObjectRootBase* /*pObj*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}
	static void _stdcall CleanUpToolbarInfo(DWORD_PTR dw)
	{
		for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
		{
			pInfo->CleanUp(dw);
		}
	}


	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool /*bBeforeInsertion*/, long* /*pInsertionAllowed*/)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

}; //namespace ATL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif //__ATLSNAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsimpcoll.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIMPCOLL_H__
#define __ATLSIMPCOLL_H__

#pragma once

#include <atldef.h>
#include <wtypes.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif


#pragma warning(push)
#pragma warning(disable: 4800) // forcing 'int' value to bool

namespace ATL
{

#pragma push_macro("new")
#undef new

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

// template class helpers with functions for comparing elements
// override if using complex types without operator==
//REVIEW: Do we really need to disable warning 4800?
template <class T>
class CSimpleArrayEqualHelper
{
public:
	static bool IsEqual(const T& t1, const T& t2)
	{
		return (t1 == t2);
	}
};

template <class T>
class CSimpleArrayEqualHelperFalse
{
public:
	static bool IsEqual(const T&, const T&)
	{
		ATLASSERT(false);
		return false;
	}
};

template <class TKey, class TVal>
class CSimpleMapEqualHelper
{
public:
	static bool IsEqualKey(const TKey& k1, const TKey& k2)
	{
		return CSimpleArrayEqualHelper<TKey>::IsEqual(k1, k2);
	}

	static bool IsEqualValue(const TVal& v1, const TVal& v2)
	{
		return CSimpleArrayEqualHelper<TVal>::IsEqual(v1, v2);
	}
};

template <class TKey, class TVal>
class CSimpleMapEqualHelperFalse
{
public:
	static bool IsEqualKey(const TKey& k1, const TKey& k2)
	{
		return CSimpleArrayEqualHelper<TKey>::IsEqual(k1, k2);
	}

	static bool IsEqualValue(const TVal&, const TVal&)
	{
		ATLASSERT(FALSE);
		return false;
	}
};

template <class T, class TEqual = CSimpleArrayEqualHelper< T > >
class CSimpleArray
{
public:
// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

	CSimpleArray(const CSimpleArray< T, TEqual >& src) : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{
		m_aT = (T*)malloc(src.GetSize() * sizeof(T));
		if (m_aT != NULL)
		{
			m_nAllocSize = src.GetSize();
			for (int i=0; i<src.GetSize(); i++)
				Add(src[i]);
		}
	}
	CSimpleArray< T, TEqual >& operator=(const CSimpleArray< T, TEqual >& src)
	{
		if (GetSize() != src.GetSize())
		{
			RemoveAll();
			m_aT = (T*)malloc(src.GetSize() * sizeof(T));
			if (m_aT != NULL)
				m_nAllocSize = src.GetSize();
		}
		else
		{
			for (int i = GetSize(); i > 0; i--)
				RemoveAt(i - 1);
		}
		for (int i=0; i<src.GetSize(); i++)
			Add(src[i]);
		return *this;
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(const T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		InternalSetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(const T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		m_aT[nIndex].~T();
		if(nIndex != (m_nSize - 1))
			memmove((void*)(m_aT + nIndex), (void*)(m_aT + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
				m_aT[i].~T();
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	const T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T& operator[] (int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

	int Find(const T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqual(m_aT[i], t))
				return i;
		}
		return -1;  // not found
	}

	BOOL SetAtIndex(int nIndex, const T& t)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		InternalSetAtIndex(nIndex, t);
		return TRUE;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(const T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		template <class _Ty>
		void operator delete(void* /* pv */, _Ty* /* p */)
		{
		}
		T t;
	};
	
// Implementation
	void InternalSetAtIndex(int nIndex, const T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aT + nIndex) Wrapper(t);
	}

	typedef T _ArrayElementType;
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;
	
};

#define CSimpleValArray CSimpleArray 

// intended for small number of simple types or pointers
template <class TKey, class TVal, class TEqual = CSimpleMapEqualHelper< TKey, TVal > >
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

	typedef TKey _ArrayKeyType;
	typedef TVal _ArrayElementType;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(const TKey& key, const TVal& val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		InternalSetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(const TKey& key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)(m_aKey + nIndex), (void*)(m_aKey + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)(m_aVal + nIndex), (void*)(m_aVal + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(const TKey& key, const TVal& val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(const TKey& key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(const TVal& val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

	int FindKey(const TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualKey(m_aKey[i], key))
				return i;
		}
		return -1;  // not found
	}
	int FindVal(const TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualValue(m_aVal[i], val))
				return i;
		}
		return -1;  // not found
	}

	BOOL SetAtIndex(int nIndex, const TKey& key, const TVal& val)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}


// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(const T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		template <class _Ty>
		void operator delete(void* /* pv */, _Ty* /* p */)
		{
		}
		T t;
	};
	void InternalSetAtIndex(int nIndex, const TKey& key, const TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aKey + nIndex) Wrapper<TKey>(key);
		new(m_aVal + nIndex) Wrapper<TVal>(val);
	}
};

#pragma pop_macro("new")

};  // namespace ATL

#pragma warning(pop)

#endif  // __ATLSIMPCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsync.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.


#ifndef __ATLSYNC_H__
#define __ATLSYNC_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(push)
#pragma warning(disable: 4512)  // assignment operator could not be generated
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#include <atlbase.h>

namespace ATL
{

class CCriticalSection :
	public CRITICAL_SECTION
{
public:
	CCriticalSection();
#if (_WIN32_WINNT >= 0x0403)
	explicit CCriticalSection( ULONG nSpinCount );
#endif
	~CCriticalSection() throw();

	// Acquire the critical section
	void Enter();
	// Release the critical section
	void Leave() throw();
#if (_WIN32_WINNT >= 0x0403)
	// Set the spin count for the critical section
	ULONG SetSpinCount( ULONG nSpinCount ) throw();
#endif
#if (_WIN32_WINNT >= 0x0400)
	// Attempt to acquire the critical section
	BOOL TryEnter() throw();
#endif
};

class CEvent :
	public CHandle
{
public:
	CEvent() throw();
	CEvent( CEvent& h ) throw();
	CEvent( BOOL bManualReset, BOOL bInitialState );
	CEvent( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName );
	explicit CEvent( HANDLE h ) throw();

	// Create a new event
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName ) throw();
	// Open an existing named event
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Pulse the event (signals waiting objects, then resets)
	BOOL Pulse() throw();
	// Set the event to the non-signaled state
	BOOL Reset() throw();
	// Set the event to the signaled state
	BOOL Set() throw();
};

class CMutex :
	public CHandle
{
public:
	CMutex() throw();
	CMutex( CMutex& h ) throw();
	explicit CMutex( BOOL bInitialOwner );
	CMutex( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName );
	explicit CMutex( HANDLE h ) throw();

	// Create a new mutex
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName ) throw();
	// Open an existing named mutex
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Release ownership of the mutex
	BOOL Release() throw();
};

class CSemaphore :
	public CHandle
{
public:
	CSemaphore() throw();
	CSemaphore( CSemaphore& h ) throw();
	CSemaphore( LONG nInitialCount, LONG nMaxCount );
	CSemaphore( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName );
	explicit CSemaphore( HANDLE h ) throw();

	// Create a new semaphore
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName ) throw();
	// Open an existing named semaphore
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Increase the count of the semaphore
	BOOL Release( LONG nReleaseCount = 1, LONG* pnOldCount = NULL ) throw();
};

class CMutexLock
{
public:
	CMutexLock( CMutex& mtx, bool bInitialLock = true );
	~CMutexLock() throw();

	void Lock();
	void Unlock() throw();

// Implementation
private:
	CMutex& m_mtx;
	bool m_bLocked;

// Private to prevent accidental use
	CMutexLock( const CMutexLock& ) throw();
	CMutexLock& operator=( const CMutexLock& ) throw();
};

};  // namespace ATL

#include <atlsync.inl>

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(pop)
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#endif  // __ATLSYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlspriv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSPRIV_H__
#define __ATLSPRIV_H__

#pragma once
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif

#ifndef	_WINSOCK2API_
#error Winsock2.h has to be included before including windows.h or use atlbase.h instead of windows.h
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "ws2_32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

#include <svcguid.h>
#include <atlcoll.h>
#include <mlang.h>
#include <atlutil.h>

// ATL_SOCK_TIMEOUT defines the amount of time
// this socket will block the calling thread waiting
// for the socket before the call times out.
#ifndef ATL_SOCK_TIMEOUT
	#define ATL_SOCK_TIMEOUT 10000
#endif

#define ATL_WINSOCK_VER MAKELONG(2,0)

// This file contains unsupported code used in ATL implementation files. Most of 
// this code is support code for various ATL Server functions.

namespace ATL{

	// One of these objects can be created globally to turn
// on the socket stuff at CRT startup and shut it down
// on CRT term.
class _AtlWSAInit
{
public:
	_AtlWSAInit() throw()
	{
		m_dwErr = WSAEFAULT;
	}

	bool Init()
	{
		if (!IsStarted())
			m_dwErr = WSAStartup(ATL_WINSOCK_VER, &m_stData);

		return m_dwErr == 0;
	}

	bool IsStarted(){ return m_dwErr == 0; }

	~_AtlWSAInit() throw()
	{
		if (!m_dwErr)
			WSACleanup();
	}

	WSADATA  m_stData;
	DWORD m_dwErr;
};

#ifndef _ATL_NO_GLOBAL_SOCKET_STARTUP
	__declspec(selectany)_AtlWSAInit g_HttpInit;
#endif


class ZEvtSyncSocket
{
public:
	ZEvtSyncSocket() throw();
	~ZEvtSyncSocket() throw();
	operator SOCKET() throw();
	void Close() throw();
	void Term() throw();
	bool Create(WORD wFlags=0) throw();
	bool Create(short af, short st, short proto, WORD wFlags=0) throw();
	bool Connect(LPCTSTR szAddr, unsigned short nPort) throw();
	bool Connect(const SOCKADDR* psa) throw();
	bool Write(WSABUF *pBuffers, int nCount, DWORD *pdwSize) throw();
	bool Write(const unsigned char *pBuffIn, DWORD *pdwSize) throw();
	bool Read(const unsigned char *pBuff, DWORD *pdwSize) throw();
	bool Init(SOCKET hSocket, void * /*pData=NULL*/) throw();
	DWORD GetSocketTimeout();
	DWORD SetSocketTimeout(DWORD dwNewTimeout);
	bool SupportsScheme(ATL_URL_SCHEME scheme);

protected:
	DWORD m_dwCreateFlags;
	WSAEVENT m_hEventRead;
	WSAEVENT m_hEventWrite;
	WSAEVENT m_hEventConnect;

	CComAutoCriticalSection m_csRead;
	CComAutoCriticalSection m_csWrite;
	SOCKET m_socket;
	bool m_bConnected;
	DWORD m_dwLastError;
	DWORD m_dwSocketTimeout;
};


#define ATL_MAX_QUERYSET (sizeof(WSAQUERYSET) + 4096)

class CTCPAddrLookup
{
public:
	CTCPAddrLookup() throw();
	~CTCPAddrLookup() throw();

	// properties for this class
	__declspec(property(get=GetSockAddr)) const SOCKADDR* Addr;
	__declspec(property(get=GetSockAddrSize)) int AddrSize;
	
	// Takes a string that identifies a TCP service
	// to look up. The szName parameter is either the name
	// of a server (eg microsoft.com) or the dotted IP address
	// of a server (eg 157.24.34.205). This function must succeed
	// before accessing the Addr and AddrSize parameters.
	// This function returns normal socket errors on failure
	int GetRemoteAddr(LPCTSTR szName, short nPort) throw();
	const SOCKADDR* GetSockAddr();
	int GetSockAddrSize();
protected:
	SOCKADDR *m_pAddr;
	int m_nAddrSize;
	sockaddr_in m_saIn;
	WSAQUERYSET *m_pQuerySet;
};

// MIME helper functions

extern __declspec(selectany) const DWORD ATL_MIME_DEFAULT_CP = 28591;

// This function is used to create an CSMTPConnection-compatible recipient string 
// from a recipient string that is in a CMimeMessage object.
inline BOOL AtlMimeMakeRecipientsString(LPCSTR szNames, LPSTR szRecipients, LPDWORD pdwLen = NULL) throw()
{
	ATLASSERT(szNames != NULL);
	ATLASSERT(szRecipients != NULL);

	char ch;
	DWORD dwLen = 0;
	while ((ch = *szNames++) != '\0')
	{
		// Skip everything that is in double quotes
		if (ch == '"')
		{
			while (*szNames && *szNames++ != '"');
		}
		if (ch == '<')
		{
			// Extract the address from within the <>
			while (*szNames && *szNames != '>')
			{
				*szRecipients++ = *szNames++;
				dwLen++;
			}
			// End it with a comma
			*szRecipients++ = ',';
			dwLen++;
		}
		if (ch == '=')
		{
			// Skip any BEncoded or QEncoded parts
			while (*szNames)
			{
				if (*szNames == '?' && *(szNames+1) == '=')
				{
					szNames+=2;
					break;
				}
				szNames++;
			}
		}
		szNames++;
	}
	if (dwLen != 0)
	{
		szRecipients--;
		dwLen--;
	}
	*szRecipients = '\0';

	if (pdwLen)
		*pdwLen = dwLen;

	return TRUE;
}

// AtlMimeCharsetFromCodePage, AtlMimeConvertString
// are MIME multilanguage support functions.

// Get the MIME character set of the of the code page.  The character set is copied
// into szCharset.

#ifndef ATLSMTP_DEFAULT_CSET
	#define ATLSMTP_DEFAULT_CSET "iso-8859-1"
#endif

inline BOOL AtlMimeCharsetFromCodePage(LPSTR szCharset, UINT uiCodePage, IMultiLanguage* pMultiLanguage) throw()
{
	ATLASSERT(szCharset != NULL);

	if (!pMultiLanguage)
	{
		if ((uiCodePage == 0) || (uiCodePage == ATL_MIME_DEFAULT_CP))
		{
			strcpy(szCharset, ATLSMTP_DEFAULT_CSET);
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		if (uiCodePage == 0)
			uiCodePage = GetACP();

		HRESULT hr;
		MIMECPINFO cpInfo;
		memset(&cpInfo, 0x00, sizeof(cpInfo));

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

		// if IMultiLanguage2 is available, use it
		CComPtr<IMultiLanguage2> spMultiLanguage2;
		hr = pMultiLanguage->QueryInterface(__uuidof(IMultiLanguage2), (void **)&spMultiLanguage2);
		if (FAILED(hr) || !spMultiLanguage2.p)
			hr = pMultiLanguage->GetCodePageInfo(uiCodePage, &cpInfo);
		else
			hr = spMultiLanguage2->GetCodePageInfo(uiCodePage, 
				LANGIDFROMLCID(GetThreadLocale()), &cpInfo);

#else // __IMultiLanguage2_INTERFACE_DEFINED__

		hr = pMultiLanguage->GetCodePageInfo(uiCodePage, &cpInfo);

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

		if (hr != S_OK)
			return FALSE;

		_ATLTRY
		{
			strcpy(szCharset, CW2A(cpInfo.wszWebCharset));
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	return TRUE;
}

inline BOOL AtlMimeConvertStringW(
	IMultiLanguage *pMultiLanguage,
	UINT uiCodePage,
	LPCWSTR wszIn, 
	LPSTR *ppszOut, 
	UINT *pnLen) throw()
{
	ATLASSERT( pMultiLanguage != NULL );
	ATLASSERT( wszIn != NULL );
	ATLASSERT( ppszOut != NULL );
	ATLASSERT( pnLen != NULL );

	*ppszOut = NULL;
	*pnLen = 0;

	if (uiCodePage == 0)
	{
		uiCodePage = GetACP();
	}

	DWORD dwMode = 0;
	CHeapPtr<char> pszOut;

	// get the length
	HRESULT hr = pMultiLanguage->ConvertStringFromUnicode(&dwMode, uiCodePage, const_cast<LPWSTR>(wszIn), NULL, NULL, pnLen);
	if (SUCCEEDED(hr))
	{
		// allocate the buffer
		if (pszOut.Allocate(*pnLen))
		{
			dwMode = 0;
			// do the conversion
			hr = pMultiLanguage->ConvertStringFromUnicode(&dwMode, uiCodePage, const_cast<LPWSTR>(wszIn), NULL, pszOut, pnLen);
			if (SUCCEEDED(hr))
			{
				*ppszOut = pszOut.Detach();
				return TRUE;
			}
		}
	}

	return FALSE;
}

inline BOOL AtlMimeConvertStringA(
	IMultiLanguage *pMultiLanguage,
	UINT uiCodePage,
	LPCSTR szIn, 
	LPSTR *ppszOut, 
	UINT *pnLen) throw()
{
	_ATLTRY
	{
		return AtlMimeConvertStringW(pMultiLanguage, uiCodePage, CA2W(szIn), ppszOut, pnLen);
	}
	_ATLCATCHALL()
	{
		return FALSE;
	}
}

#ifdef _UNICODE
	#define AtlMimeConvertString AtlMimeConvertStringW
#else
	#define AtlMimeConvertString AtlMimeConvertStringA
#endif



// SOAP helpers

extern __declspec(selectany) const char * s_szAtlsWSDLSrf =
"<?xml version=\"1.0\"?>\r\n"
"<!-- ATL Server generated Web Service Description -->\r\n"
"<definitions \r\n"
"	xmlns:s=\"http://www.w3.org/2000/10/XMLSchema\" \r\n"
"	xmlns:http=\"http://schemas.xmlsoap.org/wsdl/http/\" \r\n"
"	xmlns:mime=\"http://schemas.xmlsoap.org/wsdl/mime/\" \r\n"
"	xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" \r\n"
"	xmlns:soapenc=\"http://schemas.xmlsoap.org/soap/encoding/\" \r\n"
"	xmlns:s0=\"{{GetNamespace}}\" \r\n"
"	xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\r\n"
"	targetNamespace=\"{{GetNamespace}}\" \r\n"
"	xmlns=\"http://schemas.xmlsoap.org/wsdl/\"\r\n"
">\r\n"
"	<types>\r\n"
"		<s:schema targetNamespace=\"{{GetNamespace}}\" attributeFormDefault=\"qualified\" elementFormDefault=\"qualified\">\r\n"
"{{while GetNextFunction}}\r\n"
"			<s:element name=\"{{GetFunctionName}}\">\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"{{while GetNextParameter}}\r\n"
"{{if IsInParameter}}\r\n"
"						<s:element name=\"{{GetParameterName}}\" {{if NotIsArrayParameter}}type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\"/{{else}}nullable=\"{{if IsParameterDynamicArray}}true{{else}}false{{endif}}\"{{endif}}>\r\n"
"{{if IsArrayParameter}}\r\n"
"							<s:complexType derivedBy=\"restriction\">\r\n"
"								<s:all>\r\n"
"									<s:element name=\"{{GetParameterSoapType}}\" type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\" {{if IsParameterDynamicArray}}minOccurs=\"0\" maxOccurs=\"unbounded\"{{else}}{{if IsParameterOneDimensional}}minOccurs=\"{{GetParameterArraySize}}\" maxOccurs=\"{{GetParameterArraySize}}\"{{else}}soap:arrayType=\"{{GetParameterArraySoapDims}}\"{{endif}}{{endif}}/>\r\n"
"								</s:all>\r\n"
"							</s:complexType>\r\n"
"						</s:element>\r\n"
"{{endif}}\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"			<s:element name=\"{{GetFunctionName}}Response\">\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"{{while GetNextParameter}}\r\n"
"{{if IsOutParameter}}\r\n"
"						<s:element name=\"{{GetParameterName}}\" {{if NotIsArrayParameter}}type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\"/{{else}}nullable=\"{{if IsParameterDynamicArray}}true{{else}}false{{endif}}\"{{endif}}>\r\n"
"{{if IsArrayParameter}}\r\n"
"							<s:complexType derivedBy=\"restriction\">\r\n"
"								<s:all>\r\n"
"									<s:element name=\"{{GetParameterSoapType}}\" type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\" {{if IsParameterDynamicArray}}minOccurs=\"0\" maxOccurs=\"unbounded\"{{else}}{{if IsParameterOneDimensional}}minOccurs=\"{{GetParameterArraySize}}\" maxOccurs=\"{{GetParameterArraySize}}\"{{else}}soap:arrayType=\"{{GetParameterArraySoapDims}}\"{{endif}}{{endif}}/>\r\n"
"								</s:all>\r\n"
"							</s:complexType>\r\n"
"						</s:element>\r\n"
"{{endif}}\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextEnum}}\r\n"
"			<s:simpleType name=\"{{GetEnumName}}\">\r\n"
"				<s:restriction base=\"s:string\">\r\n"
"{{while GetNextEnumElement}}\r\n"
"					<s:enumeration value=\"{{GetEnumElementName}}\"/>\r\n"
"{{endwhile}}\r\n"
"				</s:restriction>\r\n"
"			</s:simpleType>\r\n"
"{{endwhile}}\r\n"
"			<s:complexType name=\"ATLSOAP_BLOB\">\r\n"
"				<s:all>\r\n"
"					<s:element name=\"size\" type=\"unsignedLong\"/>\r\n"
"					<s:element name=\"data\" nullable=\"false\">\r\n"
"						<s:simpleType xmlns:q3=\"http://www.w3.org/2000/10/XMLSchema\" base=\"q3:binary\">\r\n"
"							<s:encoding value=\"base64\"/>\r\n"
"						</s:simpleType>\r\n"
"					</s:element>\r\n"
"				</s:all>\r\n"
"			</s:complexType>\r\n"
"{{while GetNextStruct}}\r\n"
"			<s:complexType name=\"{{GetStructName}}\" derivedBy=\"restriction\">\r\n"
"				<s:all>\r\n"
"{{while GetNextStructField}}\r\n"
"					<s:element name=\"{{GetStructFieldName}}\" {{if NotIsArrayField}}type=\"{{if IsFieldUDT}}s0:{{else}}s:{{endif}}{{GetStructFieldSoapType}}\"/{{else}}nullable=\"false\"{{endif}}>\r\n"
"{{if IsArrayField}}\r\n"
"						<s:complexType derivedBy=\"restriction\">\r\n"
"							<s:all>\r\n"
"								<s:element name=\"{{GetStructFieldSoapType}}\" type=\"{{if IsFieldUDT}}s0:{{else}}s:{{endif}}{{GetStructFieldSoapType}}\" {{if IsFieldOneDimensional}}minOccurs=\"{{GetFieldArraySize}}\" maxOccurs=\"{{GetFieldArraySize}}\"{{else}}soap:arrayType=\"{{GetFieldArraySoapDims}}\"{{endif}}/>\r\n"
"							</s:all>\r\n"
"						</s:complexType>\r\n"
"					</s:element>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"				</s:all>\r\n"
"			</s:complexType>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextHeader}}\r\n"
"			<s:element name=\"{{GetHeaderName}}\" {{if NotIsArrayHeader}}type=\"{{if IsHeaderUDT}}s0:{{else}}s:{{endif}}{{GetHeaderSoapType}}\"/{{else}}nullable=\"false\"{{endif}}>\r\n"
"{{if IsArrayHeader}}\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"						<s:element name=\"{{GetHeaderSoapType}}\" type=\"{{if IsHeaderUDT}}s0:{{else}}s:{{endif}}{{GetHeaderSoapType}}\" {{if IsHeaderOneDimensional}}minOccurs=\"{{GetHeaderArraySize}}\" maxOccurs=\"{{GetHeaderArraySize}}\"{{else}}soap:arrayType=\"{{GetHeaderArraySoapDims}}\"{{endif}}/>\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"		</s:schema>\r\n"
"	</types>\r\n"
"{{while GetNextFunction}}\r\n"
"	<message name=\"{{GetFunctionName}}In\">\r\n"
"		<part name=\"parameters\" element=\"s0:{{GetFunctionName}}\"/>\r\n"
"	</message>\r\n"
"	<message name=\"{{GetFunctionName}}Out\">\r\n"
"		<part name=\"parameters\" element=\"s0:{{GetFunctionName}}Response\"/>\r\n"
"	</message>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextHeader}}\r\n"
"	<message name=\"{{GetHeaderName}}\">\r\n"
"		<part name=\"{{GetHeaderName}}\" element=\"s0:{{GetHeaderName}}\"/>\r\n"
"	</message>\r\n"
"{{endwhile}}\r\n"
"	<portType name=\"{{GetServiceName}}Soap\">\r\n"
"{{while GetNextFunction}}\r\n"
"		<operation name=\"{{GetFunctionName}}\">\r\n"
"			<input message=\"s0:{{GetFunctionName}}In\"/>\r\n"
"			<output message=\"s0:{{GetFunctionName}}Out\"/>\r\n"
"		</operation>\r\n"
"{{endwhile}}\r\n"
"	</portType>\r\n"
"	<binding name=\"{{GetServiceName}}Soap\" type=\"s0:{{GetServiceName}}Soap\">\r\n"
"		<soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" style=\"document\"/>\r\n"
"{{while GetNextFunction}}\r\n"
"		<operation name=\"{{GetFunctionName}}\">\r\n"
"			<soap:operation soapAction=\"#{{GetFunctionName}}\" style=\"document\"/>\r\n"
"			<input>\r\n"
"				<soap:body use=\"literal\"/>\r\n"
"{{while GetNextFunctionHeader}}\r\n"
"{{if IsInHeader}}\r\n"
"				<soap:header message=\"s0:{{GetFunctionHeaderName}}\" part=\"{{GetFunctionHeaderName}}\" use=\"literal\"{{if IsRequiredHeader}} wsdl:required=\"true\"{{endif}}/>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"			</input>\r\n"
"			<output>\r\n"
"				<soap:body use=\"literal\"/>\r\n"
"{{while GetNextFunctionHeader}}\r\n"
"{{if IsOutHeader}}\r\n"
"				<soap:header message=\"s0:{{GetFunctionHeaderName}}\" part=\"{{GetFunctionHeaderName}}\" use=\"literal\"{{if IsRequiredHeader}} wsdl:required=\"true\"{{endif}}/>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"			</output>\r\n"
"		</operation>\r\n"
"{{endwhile}}\r\n"
"	</binding>\r\n"
"	<service name=\"{{GetServiceName}}\">\r\n"
"		<port name=\"{{GetServiceName}}Soap\" binding=\"s0:{{GetServiceName}}Soap\">\r\n"
"			<soap:address location=\"{{GetURL}}\"/>\r\n"
"		</port>\r\n"
"	</service>\r\n"
"</definitions>"
"";

extern __declspec(selectany) const size_t s_nAtlsWSDLSrfLen = strlen(s_szAtlsWSDLSrf);

class CStreamOnSequentialStream : 
	public IStream
{
	CComPtr<ISequentialStream> m_spStream;
public:
	CStreamOnSequentialStream(ISequentialStream *pStream) throw()
	{
		ATLASSERT(pStream);
		m_spStream = pStream;
	}

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!m_spStream)
			return E_UNEXPECTED;
		return m_spStream->Read(pv, cb, pcbRead);
	}

    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten) throw()
	{
		if (!m_spStream)
			return E_UNEXPECTED;
		return m_spStream->Write(pv, cb, pcbWritten);
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
            ::InlineIsEqualGUID(iid, IID_ISequentialStream) ||
			::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) throw() 
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) throw() 
	{
		return (ULONG)1;
	}
};

class CStreamOnByteArray : 
	public IStream
{
public:
	BYTE *m_pArray;
	DWORD m_dwRead;

	CStreamOnByteArray(BYTE *pBytes) throw()
	{
		ATLASSERT(pBytes);
		m_pArray = pBytes;
		m_dwRead = 0;
	}

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!pv)
			return E_INVALIDARG;

		if (cb == 0)
			return S_OK;

		if (!m_pArray)
			return E_UNEXPECTED;

		BYTE *pCurr  = m_pArray;
		pCurr += m_dwRead;
		memcpy(pv, pCurr, cb);
		if (pcbRead)
			*pcbRead = cb;
		m_dwRead += cb;
		return S_OK;
	}

    STDMETHOD(Write)(const void* , ULONG , ULONG* ) throw()
	{
		return E_UNEXPECTED;
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
            ::InlineIsEqualGUID(iid, IID_ISequentialStream) ||
			::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void)  throw()
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void)  throw()
	{
		return (ULONG)1;
	}
};

class CVariantStream : 
	public IStream
{
public:
	CVariantStream() throw()
	{
		m_nCurrRead = 0;
		m_nVariantSize = 0;
		m_nRef = 1;
	}
	
	// input variant is put into contained BYTE array.
	HRESULT InsertVariant(const VARIANT *pVarIn) throw()
	{
		CComVariant vIn;
        HRESULT hr = E_FAIL;
		m_nCurrRead = 0;
		m_nVariantSize = 0;
		hr = vIn.Copy(pVarIn);
		if (hr == S_OK)
			hr = vIn.WriteToStream(static_cast<IStream*>(this));

		return hr;
	}

	// variant is read from contained byte array into
	// out variant.
	HRESULT RetrieveVariant(VARIANT *pVarOut) throw()
	{
		CComVariant vOut;
		HRESULT hr = vOut.ReadFromStream(static_cast<IStream*>(this));
		if (hr == S_OK)
			hr = VariantCopy(pVarOut, &vOut);
		
		m_nCurrRead = 0;
		return hr;
	}

	HRESULT LoadFromStream(ISequentialStream *stream) throw()
	{
		m_nCurrRead = 0;
		CStreamOnSequentialStream stm(stream);
		CComVariant v;
		HRESULT hr = v.ReadFromStream(&stm);
		if (hr == S_OK)
			hr = v.WriteToStream(static_cast<IStream*>(this));
		return hr;
	}

	ISequentialStream* GetStream() throw()
	{
		return static_cast<ISequentialStream*>(this);
	}

	size_t GetVariantSize() throw()
	{
		return m_nVariantSize;
	}

// Implementation
	// IStream implementation;
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!pv)
			return E_INVALIDARG;

		if  (cb == 0)
			return S_OK;

		if (pcbRead)
			*pcbRead = 0;

		if (!m_nVariantSize)
			return S_OK; // nothing to do.

		size_t nLeft = m_nVariantSize - m_nCurrRead;
		if (nLeft > 0)
		{
			size_t nRead = min(nLeft, cb);
			BYTE *pCurr = m_stream;
			pCurr += m_nCurrRead;
			memcpy(pv,
				   pCurr,
				   nRead);
			m_nCurrRead += nRead;
			if (pcbRead)
				*pcbRead = (ULONG)nRead;
		}

		return S_OK;
	}

    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten) throw()
	{
		HRESULT hr = E_OUTOFMEMORY;
		if (!pv)
			return E_INVALIDARG;

		if (cb == 0)
			return S_OK;

		if (pcbWritten)
			*pcbWritten = 0;

		BYTE *pBytes = m_stream.Reallocate(cb);
		if (pBytes)
		{
			pBytes += m_nVariantSize;
			memcpy(pBytes, pv, cb);
			if (pcbWritten)
				*pcbWritten = cb;
			m_nVariantSize += cb;
			hr = S_OK;
		}
		return hr;
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown))
		{
			*ppUnk = (void*)(IUnknown*)this;
		}
		else if (::InlineIsEqualGUID(iid, IID_ISequentialStream))
		{
			*ppUnk = (void*)(ISequentialStream*)this;
		}
		else if (::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
		}

		if (*ppUnk)
		{
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) throw()
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) throw()
	{
		return (ULONG)1;
	}

	CTempBuffer<BYTE> m_stream;
	size_t m_nVariantSize;
	size_t m_nCurrRead;
	long m_nRef;
};

#include <atlspriv.inl>
}; // namespace ATL

#endif // __ATLSPRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsoap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSOAP_H__
#define __ATLSOAP_H__

#pragma once

#if (defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_))
	#error require winsock2.h -- include <winsock2.h> before you include <windows.h>
#endif

#if ((_WIN32_WINNT < 0x0400) && (_WIN32_WINDOWS <= 0x0400))
	#error require _WIN32_WINNT >= 0x0400 or _WIN32_WINDOWS > 0x0400
#endif

[ emitidl("restricted") ];

#include <winsock2.h>
#include <atlstr.h>
#include <atlcoll.h>
#include <atlbase.h>
#include <msxml2.h>
#include <atlenc.h>
#include <fcntl.h>
#include <float.h>
#include <atlisapi.h>
#include <atlstencil.h>
#include <atlhttp.h>
#include <atlhttp.inl>

#ifndef ATLSOAP_NOWININET
	#include <wininet.h>
	#ifndef ATLSOAPINET_CLIENT
		#define ATLSOAPINET_CLIENT _T("VCSoapClient")
	#endif
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "msxml2.lib")
	#ifndef ATLSOAP_NOWININET
		#pragma comment(lib, "wininet.lib")
	#endif
#endif

#define _ATLSOAP_MAKEWIDESTR( str ) L ## str
#define ATLSOAP_MAKEWIDESTR( str ) _ATLSOAP_MAKEWIDESTR( str )

namespace ATL
{

////////////////////////////////////////////////////////////////////////////////
//
// IStreamImpl - stub IStream implementation class
//
////////////////////////////////////////////////////////////////////////////////

class IStreamImpl : public IStream
{
public:

	HRESULT __stdcall Read(void * /*pDest*/, ULONG /*nMaxLen*/, ULONG * /*pnRead*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Write(const void * /*pv*/, ULONG /*cb*/, ULONG * /*pcbWritten*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Seek(LARGE_INTEGER /*dlibMove*/, DWORD /*dwOrigin*/, 
		ULARGE_INTEGER * /*pLibNewPosition*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall SetSize(ULARGE_INTEGER /*libNewSize*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall CopyTo(IStream * /*pStream*/, ULARGE_INTEGER /*cb*/, 
		ULARGE_INTEGER * /*pcbRead*/, ULARGE_INTEGER * /*pcbWritten*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Commit(DWORD /*grfCommitFlags*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Revert() throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall LockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Stat(STATSTG * /*pstatstg*/, DWORD /*grfStatFlag*/) throw()
	{
		return E_NOTIMPL;
	}

	HRESULT __stdcall Clone(IStream ** /*ppstm*/) throw()
	{
		return E_NOTIMPL;
	}
}; // class IStreamImpl

////////////////////////////////////////////////////////////////////////////////
//
// CStreamOnServerContext
//
////////////////////////////////////////////////////////////////////////////////

class CStreamOnServerContext : public IStreamImpl//, public CComObjectRootEx<CComSingleThreadModel>
{
public:
//	BEGIN_COM_MAP(CStreamOnServerContext)
//		COM_INTERFACE_ENTRY(IStream)
//		COM_INTERFACE_ENTRY(ISequentialStream)
//	END_COM_MAP()

	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_IStream) ||
			InlineIsEqualGUID(riid, IID_ISequentialStream))
		{
			*ppv = static_cast<IStream *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	IHttpServerContext * m_pServerContext;
	DWORD m_dwBytesRead;

public:

	CStreamOnServerContext(IHttpServerContext *pServerContext = NULL) throw()
		: m_pServerContext(pServerContext), m_dwBytesRead(0)
	{
	}

	void SetServerContext(IHttpServerContext *pServerContext) throw()
	{
		ATLASSERT( m_pServerContext == NULL );

		m_pServerContext = pServerContext;
	}

	HRESULT __stdcall Read(void *pDest, ULONG nMaxLen, ULONG *pnRead) throw()
	{
		ATLASSERT( pDest != NULL );
		ATLASSERT( m_pServerContext != NULL );

		DWORD dwToRead = min(m_pServerContext->GetTotalBytes()-m_dwBytesRead, nMaxLen);
		if (ReadClientData(m_pServerContext, (LPSTR) pDest, &dwToRead, m_dwBytesRead) != FALSE)
		{
			m_dwBytesRead+= dwToRead;

			if (pnRead != NULL)
			{
				*pnRead = dwToRead;
			}

			return S_OK;
		}

		return E_FAIL;
	}
}; // class CStreamOnServerContext

////////////////////////////////////////////////////////////////////////////////
//
// CReadStreamOnSocket
//
////////////////////////////////////////////////////////////////////////////////

template <typename TSocketClass>
class CReadStreamOnSocket : public IStreamImpl//, public CComObjectRootEx<CComSingleThreadModel>
{
public:

//	BEGIN_COM_MAP(CReadStreamOnSocket)
//		COM_INTERFACE_ENTRY(IStream)
//		COM_INTERFACE_ENTRY(ISequentialStream)
//	END_COM_MAP()

	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_IStream) ||
			InlineIsEqualGUID(riid, IID_ISequentialStream))
		{
			*ppv = static_cast<IStream *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	CAtlHttpClientT<TSocketClass> * m_pSocket;
	LPCSTR m_szBuffer;
	LPCSTR m_szCurr;
	long m_nBodyLen;

public:

	CReadStreamOnSocket() throw()
		: m_pSocket(NULL), m_szBuffer(NULL), m_szCurr(NULL), m_nBodyLen(0)
	{
	}

	BOOL Init(CAtlHttpClientT<TSocketClass> *pSocket) throw()
	{
		ATLASSERT( pSocket != NULL );

		m_pSocket = pSocket;
		m_szBuffer = (LPCSTR) pSocket->GetBody();
		if (m_szBuffer != NULL)
		{
			m_szCurr = m_szBuffer;
			m_nBodyLen = pSocket->GetBodyLength();
			if (m_nBodyLen != 0)
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	HRESULT __stdcall Read(void *pDest, ULONG nMaxLen, ULONG *pnRead) throw()
	{
		ATLASSERT( pDest != NULL );
		ATLASSERT( m_pSocket != NULL );
		ATLASSERT( m_szBuffer != NULL );

		if (pnRead != NULL)
		{
			*pnRead = 0;
		}

		long nRead = (int) (m_szCurr-m_szBuffer);
		if (nRead < m_nBodyLen)
		{
			long nLength = min((int)(m_nBodyLen-nRead), (LONG) nMaxLen);
			memcpy(pDest, m_szCurr, nLength);
			m_szCurr+= nLength;

			if (pnRead != NULL)
			{
				*pnRead = (ULONG) nLength;
			}
		}

		return S_OK;
	}
}; // class CReadStreamOnSocket

////////////////////////////////////////////////////////////////////////////////
//
// CWriteStreamOnCString
//
////////////////////////////////////////////////////////////////////////////////

class CWriteStreamOnCString : public IWriteStream
{

public:

	CStringA m_str;

	HRESULT WriteStream(LPCSTR szOut, int nLen, LPDWORD pdwWritten) throw()
	{
		ATLASSERT( szOut != NULL );

		if (nLen < 0)
		{
			nLen = (int) strlen(szOut);
		}

		_ATLTRY
		{
			m_str.Append(szOut, nLen);
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}

		if (pdwWritten != NULL)
		{
			*pdwWritten = (DWORD) nLen;
		}

		return S_OK;
	}

	HRESULT FlushStream() throw()
	{
		return S_OK;
	}

	void Cleanup() throw()
	{
		m_str.Empty();
	}
}; // class CWriteStreamOnCString

////////////////////////////////////////////////////////////////////////////////
//
// Namespaces
//
////////////////////////////////////////////////////////////////////////////////

#define SOAPENV_NAMESPACEA "http://schemas.xmlsoap.org/soap/envelope/"
#define SOAPENV_NAMESPACEW ATLSOAP_MAKEWIDESTR( SOAPENV_NAMESPACEA )

#define SOAPENC_NAMESPACEA "http://schemas.xmlsoap.org/soap/encoding/"
#define SOAPENC_NAMESPACEW ATLSOAP_MAKEWIDESTR( SOAPENC_NAMESPACEA )

#define XSI_NAMESPACEA  "http://www.w3.org/2000/10/XMLSchema-instance"
#define XSI_NAMESPACEW  ATLSOAP_MAKEWIDESTR( XSI_NAMESPACEA )

#define XSD_NAMESPACEA  "http://www.w3.org/2000/10/XMLSchema"
#define XSD_NAMESPACEW  ATLSOAP_MAKEWIDESTR( XSD_NAMESPACEA )

#ifndef ATLSOAP_GENERIC_NAMESPACE
#define ATLSOAP_GENERIC_NAMESPACE L"http://www.tempuri.org"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// Helpers
//
////////////////////////////////////////////////////////////////////////////////

inline HRESULT GetAttribute(
	ISAXAttributes *pAttributes, 
	const wchar_t *wszAttrName, int cchName, 
	const wchar_t **pwszValue, int *pcchValue,
	wchar_t *wszNamespace = NULL, int cchNamespace = 0) throw()
{
	if (!pAttributes || !wszAttrName || !pwszValue || !pcchValue)
	{
		return E_INVALIDARG;
	}

	*pwszValue = NULL;
	*pcchValue = 0;
	if (!wszNamespace)
	{
		return (pAttributes->getValueFromQName(wszAttrName, cchName, pwszValue, pcchValue) == S_OK ? S_OK : E_FAIL);
	}
	return (pAttributes->getValueFromName(wszNamespace, cchNamespace, 
		wszAttrName, cchName, pwszValue, pcchValue) == S_OK ? S_OK : E_FAIL);
}

inline HRESULT GetAttribute(
	ISAXAttributes *pAttributes, 
	const wchar_t *wszAttrName, int cchName, 
	CStringW &strValue,
	wchar_t *wszNamespace = NULL, int cchNamespace = 0) throw()
{
	const wchar_t *wszValue = NULL;
	int cchValue = 0;

	if (!pAttributes || !wszAttrName)
	{
		return E_INVALIDARG;
	}

	HRESULT hr;
	if (!wszNamespace)
	{
		hr = (pAttributes->getValueFromQName(wszAttrName, cchName, &wszValue, &cchValue) == S_OK ? S_OK : E_FAIL);
	}
	else
	{
		hr = (pAttributes->getValueFromName(wszNamespace, cchNamespace, 
			wszAttrName, cchName, &wszValue, &cchValue) == S_OK ? S_OK : E_FAIL);
	}

	if (hr == S_OK)
	{
		_ATLTRY
		{
			strValue.SetString(wszValue, cchValue);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

inline HRESULT AtlSoapGetArraySize(ISAXAttributes *pAttributes, size_t *pnSize, 
	const wchar_t **pwszTypeStart = NULL, const wchar_t **pwszTypeEnd = NULL) throw()
{
	if (pnSize == NULL)
	{
		return E_POINTER;
	}

	if (pAttributes == NULL)
	{
		return E_INVALIDARG;
	}

	*pnSize = 0;

	const wchar_t *wsz;
	int cch;

	HRESULT hr = GetAttribute(pAttributes, L"arrayType", sizeof("arrayType")-1, 
		&wsz, &cch, SOAPENC_NAMESPACEW, sizeof(SOAPENC_NAMESPACEA)-1);

	if ((SUCCEEDED(hr)) && (wsz != NULL))
	{
		hr = E_FAIL;
		
		const wchar_t *wszTypeStart = NULL;
		const wchar_t *wszTypeEnd = NULL;

		// skip spaces
		while (iswspace(*wsz) != 0)
		{
			wsz++;
		}

		// no need to walk the string if the caller is not interested
		if ((pwszTypeStart != NULL) && (pwszTypeEnd != NULL))
		{
			wszTypeStart = wsz;
			wszTypeEnd = wcschr(wszTypeStart, L':');
			if (wszTypeEnd != NULL)
			{
				wszTypeStart = wszTypeEnd+1;
			}
		}

		// SOAP Section 5 encodings are of the form:
		//   <soap_enc namespace>:arrayType="<type_qname>[dim1(,dim_i)*]
		//   for example: SOAP-ENC:arrayType="xsd:string[2,4]"

		wsz = wcschr(wsz, L'[');
		if (wsz != NULL)
		{
			wszTypeEnd = wsz-1;

			*pnSize = 1;

			// get the size of each dimension
			while (wsz != NULL)
			{
				wsz++;
				*pnSize *= (size_t) _wtoi(wsz);

				wsz = wcschr(wsz, L',');
			}

			if ((pwszTypeStart != NULL) && (pwszTypeEnd != NULL))
			{
				*pwszTypeStart = wszTypeStart;
				*pwszTypeEnd = wszTypeEnd;
			}

			hr = S_OK;
		}
	}
	else
	{
		// not a section-5 encoding
		hr = S_OK;
	}

	return hr;
}

inline size_t AtlSoapGetArrayDims(const int *pDims) throw()
{
	if (pDims == NULL)
	{
		return 0;
	}

	size_t nRet = 1;
	for (int i=1; i<=pDims[0]; i++)
	{
		nRet *= pDims[i];
	}

	return nRet;
}

} // namespace ATL

////////////////////////////////////////////////////////////////////////////////
//
// BLOB data type - use this struct when you want to send BLOB data
//   the attribute provider and proxy generator will only properly special
//   case blob data when using this struct.
//
////////////////////////////////////////////////////////////////////////////////

[ export ]
typedef struct _tagATLSOAP_BLOB
{
	unsigned long size;
	unsigned char *data;
} ATLSOAP_BLOB;


//
// the following function template will not compile
// this is by design to catch types that are not handled
// by specializations
//
template <typename T>
inline HRESULT AtlGetSAXValue(T * /* pVal */, const wchar_t * /* wsz */, int /* cch */) throw()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// AtlGetXMLValue (for IXMLDOMDocument) - get the real type from the XML data
//
///////////////////////////////////////////////////////////////////////////////

//
// generic IXMLDOMNode template function
// delegates to AtlGetSAXValue
//
template <typename T>
inline HRESULT AtlGetXMLValue(IXMLDOMNode *pParam, T *pVal) throw()
{
	CComBSTR bstrVal;
	HRESULT hr = AtlGetXMLValue(pParam, &bstrVal);
	if (SUCCEEDED(hr))
	{
		hr = AtlGetSAXValue(pVal, bstrVal, bstrVal.Length());
	}

	return hr;
}

// specialization for BSTR
inline HRESULT AtlGetXMLValue<BSTR>(IXMLDOMNode *pParam, BSTR *pbstrVal) throw()
{
	if (pParam == NULL)
	{
		return E_INVALIDARG;
	}
	if (pbstrVal == NULL)
	{
		return E_POINTER;
	}

	CComPtr<IXMLDOMNode> spChild;
	if (pParam->get_firstChild(&spChild) == S_OK)
	{
		CComPtr<IXMLDOMNode> spXmlChild;
		if (spChild->get_firstChild(&spXmlChild) == S_OK)
		{
			return (pParam->get_xml(pbstrVal) == S_OK ? S_OK : E_FAIL);
		}
	}

	return (pParam->get_text(pbstrVal) == S_OK) ? S_OK : E_FAIL;
}

////////////////////////////////////////////////////////////////////////////////
//
// AtlGetSAXValue - (for SAX or generic) get the real type from the XML data
//
////////////////////////////////////////////////////////////////////////////////

inline HRESULT AtlGetSAXValue<bool>(bool *pVal, const wchar_t *wsz, int cch) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	*pVal = false;

	HRESULT hr = E_FAIL;
	switch (wsz[0])
	{
		case L'1':
		{
			if (cch==1)
			{
				*pVal = true;
				hr = S_OK;
			}
			break;
		}
		case L'0':
		{
			if (cch==1)
			{
				*pVal = false;
				hr = S_OK;
			}
			break;
		}
		case L't':
		{
			if (cch==sizeof("true")-1 && !wcsncmp(wsz, L"true", cch))
			{
				*pVal = true;
				hr = S_OK;
			}
			break;
		}
		case L'f':
		{
			if (cch==sizeof("false")-1 && !wcsncmp(wsz, L"false", cch))
			{
				*pVal = false;
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}

inline HRESULT AtlGetSAXValue<char>(char *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	*pVal = (char) _wtoi(wsz);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<unsigned char>(unsigned char *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p;
	*pVal = (unsigned char) wcstoul(wsz, &p, 10);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<short>(short *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	*pVal = (short) _wtoi(wsz);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<unsigned short>(unsigned short *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p;
	*pVal = (unsigned short) wcstoul(wsz, &p, 10);

	return S_OK;
}

#ifdef _NATIVE_WCHAR_T_DEFINED
inline HRESULT AtlGetSAXValue<wchar_t>(wchar_t *pVal, const wchar_t *wsz, int cch) throw()
{
	return AtlGetSAXValue((unsigned short *)pVal, wsz, cch);
}
#endif

inline HRESULT AtlGetSAXValue<int>(int *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	*pVal = (int) _wtoi(wsz);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<unsigned int>(unsigned int *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p;
	*pVal = (unsigned int) wcstoul(wsz, &p, 10);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<long>(long *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	*pVal = (long) _wtoi(wsz);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<unsigned long>(unsigned long *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p;
	*pVal = (unsigned long) wcstoul(wsz, &p, 10);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<__int64>(__int64 *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p;
	*pVal = _wcstoi64(wsz, &p, 10);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<unsigned __int64>(unsigned __int64 *pVal, const wchar_t *wsz, int /*cch*/) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	wchar_t *p = NULL;
	*pVal = _wcstoui64(wsz, &p, 10);

	return S_OK;
}

inline HRESULT AtlGetSAXValue<double>(double *pVal, const wchar_t *wsz, int cch) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	if (cch == 3)
	{
		if (wsz[0]==L'I' && !wcsncmp(wsz, L"INF", cch))
		{
			*(((int *) pVal)+0) = 0x0000000;
			*(((int *) pVal)+1) = 0x7FF00000;
		}
		else if (wsz[0]==L'N' && !wcsncmp(wsz, L"NAN", cch))
		{
			*(((int *) pVal)+0) = 0x0000000;
			*(((int *) pVal)+1) = 0xFFF80000;
		}
	}
	else if (cch == 4 && wsz[1]==L'I' && !wcsncmp(wsz, L"-INF", cch))
	{
		*(((int *) pVal)+0) = 0x0000000;
		*(((int *) pVal)+1) = 0xFFF00000;
	}
	else
	{
		wchar_t *p;
		*pVal = wcstod(wsz, &p);
	}

	return S_OK;
}

inline HRESULT AtlGetSAXValue<float>(float *pVal, const wchar_t *wsz, int cch) throw()
{
	ATLASSERT( wsz != NULL );

	if (!pVal)
	{
		return E_POINTER;
	}

	double d = *pVal;
	if (SUCCEEDED(AtlGetSAXValue(&d, wsz, cch)))
	{
		*pVal = (float) d;
		return S_OK;
	}

	return E_FAIL;
}

inline HRESULT AtlGetSAXValue<BSTR>(BSTR *pVal, const wchar_t *wsz, int cch) throw()
{
	ATLASSERT( wsz != NULL );

	if (pVal == NULL)
	{
		return E_POINTER;
	}

	*pVal = SysAllocStringLen(wsz, cch);

	return ((*pVal != NULL) ? S_OK : E_OUTOFMEMORY);
}

////////////////////////////////////////////////////////////////////////////////
//
// AtlGenXMLValue template and specializations
//
////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline HRESULT AtlGenXMLValue(IWriteStream *pStream, T *pVal) throw()
{
	if ((pStream == NULL) || (pVal == NULL))
	{
		return E_INVALIDARG;
	}

	//
	// delegate to CWriteStreamHelper
	//
	CWriteStreamHelper s(pStream);

	return (s.Write(*pVal) == TRUE ? S_OK : E_FAIL);
}

#ifdef _NATIVE_WCHAR_T_DEFINED
inline HRESULT AtlGenXMLValue<wchar_t>(IWriteStream *pStream, wchar_t *pVal) throw()
{
	return AtlGenXMLValue(pStream, (unsigned short *)pVal);
}
#endif

//
// REVIEW: overload on other kinds of string (LPCSTR, etc.)?
//
inline HRESULT AtlGenXMLValue<wchar_t *>(IWriteStream *pStream, wchar_t **pVal) throw()
{
	if ((pStream == NULL) || (*pVal == NULL))
	{
		return E_INVALIDARG;
	}

	wchar_t *wszWrite = *pVal;
	int nSrcLen = (int)wcslen(*pVal);
	int nCnt = EscapeXML(*pVal, nSrcLen, NULL, 0);
	if (nCnt > nSrcLen)
	{
		nCnt++;
		wszWrite = (wchar_t *)malloc((nCnt)*sizeof(wchar_t));
		if (wszWrite == NULL)
		{
			return E_OUTOFMEMORY;
		}
		
		nCnt = EscapeXML(*pVal, nSrcLen, wszWrite, nCnt);
		if (nCnt == 0)
		{
			free(wszWrite);
			return E_FAIL;
		}
		wszWrite[nCnt] = L'\0';
		nSrcLen = nCnt;
	}

	nCnt = AtlUnicodeToUTF8(wszWrite, nSrcLen, NULL, 0);
	HRESULT hr = E_FAIL;
	if ((nCnt == 0) || (nCnt == nSrcLen))
	{
		CWriteStreamHelper s(pStream);

		hr = (s.Write(wszWrite) == TRUE ? S_OK : E_FAIL);
	}
	else
	{
		nCnt++;
		CHeapPtr<char> szWrite;
		szWrite.AllocateBytes((size_t)(nCnt));
		if (szWrite != NULL)
		{
			nCnt = AtlUnicodeToUTF8(wszWrite, nSrcLen, szWrite, nCnt);
			if (nCnt != 0)
			{
				hr = pStream->WriteStream(szWrite, nCnt, NULL);
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if (wszWrite != *pVal)
	{
		free(wszWrite);
	}

	return hr;
}

inline HRESULT AtlGenXMLValue<double>(IWriteStream *pStream, double *pVal) throw()
{
	if ((pStream == NULL) || (pVal == NULL))
	{
		return E_INVALIDARG;
	}

	HRESULT hr;
	switch (_fpclass(*pVal))
	{
		case _FPCLASS_SNAN: 
		case _FPCLASS_QNAN:
		{
			hr = pStream->WriteStream("NAN", 3, NULL);
			break;
		}
		case _FPCLASS_NINF:
		{
			hr = pStream->WriteStream("-INF", 4, NULL);
			break;
		}
		case _FPCLASS_PINF:
		{
			hr = pStream->WriteStream("INF", 3, NULL);
			break;
		}
		case _FPCLASS_NZ:
		{
			hr = pStream->WriteStream("-0", 2, NULL);
			break;
		}
		default:
		{
			CWriteStreamHelper s(pStream);
			hr = (s.Write(*pVal) == TRUE ? S_OK : E_FAIL);
			break;
		}
	}

	return hr;
}

inline HRESULT AtlGenXMLValue<float>(IWriteStream *pStream, float *pVal) throw()
{
	if ((pStream == NULL) || (pVal == NULL))
	{
		return E_INVALIDARG;
	}

	double d = *pVal;

	return AtlGenXMLValue(pStream, &d);
}

inline HRESULT AtlGenXMLValue<bool>(IWriteStream *pStream, bool *pVal) throw()
{
	if ((pStream == NULL) || (pVal == NULL))
	{
		return E_INVALIDARG;
	}

	if (*pVal == true)
	{
		return pStream->WriteStream("true", 4, NULL);
	}

	return pStream->WriteStream("false", 5, NULL);
}

inline HRESULT AtlGenXMLValue<ATLSOAP_BLOB>(IWriteStream *pStream, ATLSOAP_BLOB *pVal) throw()
{
	if ((pStream == NULL) || (pVal == NULL))
	{
		return E_INVALIDARG;
	}

	HRESULT hr = pStream->WriteStream("<size>", sizeof("<size>")-1, NULL);
	if (SUCCEEDED(hr))
	{
		hr = AtlGenXMLValue(pStream, &pVal->size);
		if (SUCCEEDED(hr))
		{
			hr = pStream->WriteStream("</size>", sizeof("</size>")-1, NULL);
			if (SUCCEEDED(hr))
			{
				hr = E_FAIL;
				int nLength = Base64EncodeGetRequiredLength(pVal->size, ATL_BASE64_FLAG_NOCRLF);
				
				char *pEnc = (char *) malloc(nLength*sizeof(char));
				if (pEnc != NULL)
				{
					if (Base64Encode(pVal->data, pVal->size, pEnc, &nLength, ATL_BASE64_FLAG_NOCRLF))
					{
						hr = pStream->WriteStream("<data>", sizeof("<data>")-1, NULL);
						if (SUCCEEDED(hr))
						{
							hr = pStream->WriteStream(pEnc, nLength, NULL);
							if (SUCCEEDED(hr))
							{
								hr = pStream->WriteStream("</data>", sizeof("</data>")-1, NULL);
							}
						}
					}

					free(pEnc);
				}
			}
		}
	}

	return hr;
}

template <typename T>
inline HRESULT AtlCleanupValue(T * /*pVal*/) throw()
{
	return S_OK;
}

inline HRESULT AtlCleanupValue<ATLSOAP_BLOB>(ATLSOAP_BLOB *pVal) throw()
{
	if (pVal == NULL)
	{
		return E_INVALIDARG;
	}

	if (pVal->data != NULL)
	{
		free(pVal->data);
		pVal->data = NULL;
	}

	return S_OK;
}

inline HRESULT AtlCleanupValue<BSTR>(BSTR *pVal) throw()
{
	if (pVal == NULL)
	{
		// should never happen
		ATLASSERT( FALSE );
		return E_INVALIDARG;
	}

	if ((*pVal) != NULL)
	{
		// null strings are okay
		SysFreeString(*pVal);
	}

	return S_OK;
}

// single dimensional arrays
template <typename T>
inline HRESULT AtlCleanupArray(T *pArray, const int nCnt) throw()
{
	if (pArray == NULL)
	{
		return E_INVALIDARG;
	}

	for (int i=0; i<nCnt; i++)
	{
		AtlCleanupValue(&pArray[i]);
	}

	return S_OK;
}

// multi-dimensional arrays
template <typename T>
inline HRESULT AtlCleanupArrayMD(T *pArray, const int *pDims) throw()
{
	if ((pArray == NULL) || (pDims == NULL))
	{
		return E_INVALIDARG;
	}

	// calculate size
	int nCnt = 1;
	for (int i=1; i<=pDims[0]; i++)
	{
		nCnt*= pDims[i];
	}

	return AtlCleanupArray(pArray, nCnt);
}

namespace ATL
{

////////////////////////////////////////////////////////////////////////////////
//
// CSAXSoapErrorHandler
//
////////////////////////////////////////////////////////////////////////////////

class CSAXSoapErrorHandler : public ISAXErrorHandler
{
private:
	
	CStringW m_strParseError;

public:

	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (!ppv)
		{
			return E_POINTER;
		}

		if (InlineIsEqualGUID(riid, __uuidof(ISAXErrorHandler)) ||
			InlineIsEqualGUID(riid, __uuidof(IUnknown)))
		{
			*ppv = static_cast<ISAXErrorHandler*>(this);
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

	const CStringW& GetParseError() throw()
	{
		return m_strParseError;
	}

	HRESULT __stdcall error( 
		ISAXLocator *pLocator,
		const wchar_t *wszErrorMessage,
		HRESULT hrErrorCode) throw()
	{
		pLocator;
		wszErrorMessage;
		hrErrorCode;

		ATLTRACE( _T("%ws\n"), wszErrorMessage );
		_ATLTRY
		{
			m_strParseError = wszErrorMessage;
		}
		_ATLCATCHALL()
		{
			return E_FAIL;
		}

		return hrErrorCode;
	}

	HRESULT __stdcall fatalError(
		ISAXLocator  *pLocator,
		const wchar_t *wszErrorMessage,
		HRESULT hrErrorCode) throw()
	{
		pLocator;
		wszErrorMessage;
		hrErrorCode;

		ATLTRACE( _T("%ws\n"), wszErrorMessage );
		_ATLTRY
		{
			m_strParseError = wszErrorMessage;
		}
		_ATLCATCHALL()
		{
			return E_FAIL;
		}

		return hrErrorCode;
	}

	HRESULT __stdcall ignorableWarning(
		ISAXLocator  *pLocator,
		const wchar_t *wszErrorMessage,
		HRESULT hrErrorCode) throw()
	{
		pLocator;
		wszErrorMessage;
		hrErrorCode;

		ATLTRACE( _T("%ws\n"), wszErrorMessage );

		return hrErrorCode;
	}
};

////////////////////////////////////////////////////////////////////////////////
//
// ISAXContentHandlerImpl
//
////////////////////////////////////////////////////////////////////////////////

class ISAXContentHandlerImpl : 
	public ISAXContentHandler
{
public:

	//
	// ISAXContentHandler interface
	//

	HRESULT __stdcall putDocumentLocator(ISAXLocator  * /*pLocator*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall startDocument() throw()
	{
		return S_OK;
	}

	HRESULT __stdcall endDocument() throw()
	{
		return S_OK;
	}

	HRESULT __stdcall startPrefixMapping(
	     const wchar_t  * /*wszPrefix*/,
	     int /*cchPrefix*/,
	     const wchar_t  * /*wszUri*/,
	     int /*cchUri*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall endPrefixMapping( 
	     const wchar_t  * /*wszPrefix*/,
	     int /*cchPrefix*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall startElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/,
	     ISAXAttributes  * /*pAttributes*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall endElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall characters( 
	     const wchar_t  * /*wszChars*/,
	     int /*cchChars*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall ignorableWhitespace( 
	     const wchar_t  * /*wszChars*/,
	     int /*cchChars*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall processingInstruction( 
	     const wchar_t  * /*wszTarget*/,
	     int /*cchTarget*/,
	     const wchar_t  * /*wszData*/,
	     int /*cchData*/) throw()
	{
		return S_OK;
	}

	HRESULT __stdcall skippedEntity( 
	     const wchar_t  * /*wszName*/,
	     int /*cchName*/) throw()
	{
		return S_OK;
	}
}; // class ISAXContentHandlerImpl

////////////////////////////////////////////////////////////////////////////////
//
// SAX skip element handler utility class
// (skip an element and all its child elements)
//
////////////////////////////////////////////////////////////////////////////////

class CSkipHandler : public ISAXContentHandlerImpl
{
public:
	
	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_ISAXContentHandler))
		{
			*ppv = static_cast<ISAXContentHandler *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	DWORD m_dwReset;
	CComPtr<ISAXXMLReader> m_spReader;
	CComPtr<ISAXContentHandler> m_spParent;

	DWORD DisableReset(DWORD dwCnt = 1) throw()
	{
		m_dwReset += dwCnt;

		return m_dwReset;
	}

	DWORD EnableReset() throw()
	{
		if (m_dwReset > 0)
		{
			--m_dwReset;
		}

		return m_dwReset;
	}

public:

	CSkipHandler(ISAXContentHandler *pParent = NULL, ISAXXMLReader *pReader = NULL) throw()
		: m_spParent(pParent), m_spReader(pReader), m_dwReset(1)
	{
	}

	void SetParent(ISAXContentHandler *pParent) throw()
	{
		m_spParent = pParent;
	}

	void SetReader(ISAXXMLReader *pReader) throw()
	{
		m_spReader = pReader;
	}

	HRESULT __stdcall startElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/,
	     ISAXAttributes  * /*pAttributes*/) throw()
	{
		DisableReset();
		return S_OK;
	}

	HRESULT __stdcall endElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/) throw()
	{
		if (EnableReset() == 0)
		{
			m_spReader->putContentHandler(m_spParent);
		}

		return S_OK;
	}
}; // class CSkipHandler


////////////////////////////////////////////////////////////////////////////////
//
// SAX ATLSOAP_BLOB handler class
//
////////////////////////////////////////////////////////////////////////////////

class CBlobHandler : public ISAXContentHandlerImpl
{
public:
	
	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_ISAXContentHandler))
		{
			*ppv = static_cast<ISAXContentHandler *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	const static DWORD STATE_START             = 0;
	const static DWORD STATE_GOTSIZE           = 1;
	const static DWORD STATE_PARSESIZE         = 2;
	const static DWORD STATE_GOTDATA_PARSESIZE = 3;
	const static DWORD STATE_GOTDATA           = 4;
	const static DWORD STATE_PARSEDATA         = 5;
	const static DWORD STATE_GOTSIZE_PARSEDATA = 6;
	const static DWORD STATE_GOTALL            = 7;

	ATLSOAP_BLOB *m_pBlob;
	ISAXContentHandler *m_pParent;
	ISAXXMLReader *m_pReader;

	DWORD m_dwReset;
	DWORD m_dwState;

	DWORD DisableReset(DWORD dwCnt = 1) throw()
	{
		m_dwReset += dwCnt;

		return m_dwReset;
	}

	DWORD EnableReset() throw()
	{
		if (m_dwReset > 0)
		{
			--m_dwReset;
		}

		return m_dwReset;
	}

public:

	CBlobHandler(ATLSOAP_BLOB *pBlob = NULL, ISAXContentHandler *pParent = NULL, 
		ISAXXMLReader *pReader = NULL) throw()
		: m_pBlob(pBlob), m_pParent(pParent), 
		  m_pReader(pReader), m_dwReset(0), m_dwState(STATE_START)
	{
	}

	void SetParent(ISAXContentHandler *pParent) throw()
	{
		m_pParent = pParent;
	}

	void SetReader(ISAXXMLReader *pReader) throw()
	{
		m_pReader = pReader;
	}

	void SetBlob(ATLSOAP_BLOB *pBlob) throw()
	{
		m_pBlob = pBlob;
	}

	ATLSOAP_BLOB * GetBlob() throw()
	{
		return m_pBlob;
	}

	void Clear() throw()
	{
		m_pBlob = NULL;
		m_pParent = NULL;
		m_pReader = NULL;
		m_dwReset = 0;
		m_dwState = STATE_START;
	}

	HRESULT __stdcall startElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * wszLocalName,
	     int cchLocalName,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/,
	     ISAXAttributes  * /*pAttributes*/) throw()
	{
		DisableReset();

		HRESULT hr = S_OK;

		if (cchLocalName==sizeof("size")-1 && !wcsncmp(wszLocalName, L"size", cchLocalName))
		{
			switch (m_dwState)
			{
				case STATE_GOTDATA :
				{
					m_dwState = STATE_GOTDATA_PARSESIZE;
					break;
				}
				case STATE_START :
				{
					DisableReset();
					m_dwState = STATE_PARSESIZE;
					break;
				}
				default:
				{
					hr = E_FAIL;
				}
			}
		}
		else if (cchLocalName==sizeof("data")-1 && !wcsncmp(wszLocalName, L"data", cchLocalName))
		{
			switch (m_dwState)
			{
				case STATE_GOTSIZE :
				{
					m_dwState = STATE_GOTSIZE_PARSEDATA;
					break;
				}
				case STATE_START :
				{
					DisableReset();
					m_dwState = STATE_PARSEDATA;
					break;
				}
				default:
				{
					hr = E_FAIL;
				}
			}
		}
		else
		{
			hr = E_FAIL;
		}

		return hr;
	}

	HRESULT __stdcall endElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/) throw()
	{
		if (EnableReset() == 0)
		{
			m_dwState = STATE_START;
			m_pReader->putContentHandler(m_pParent);
		}

		return S_OK;
	}

	HRESULT __stdcall characters( 
	     const wchar_t  *wszChars,
	     int cchChars) throw()
	{
		HRESULT hr = S_OK;
		if (m_dwState == STATE_PARSESIZE || m_dwState == STATE_GOTDATA_PARSESIZE)
		{
			hr = E_FAIL;
			//
			// get the size
			//

			ATLASSERT( m_pBlob != NULL );

			hr = AtlGetSAXValue(&m_pBlob->size, wszChars, cchChars);

			if (m_dwState == STATE_PARSESIZE)
			{
				m_dwState = STATE_GOTSIZE;
			}
			else
			{
				m_dwState = STATE_GOTALL;
			}
		}
		else if (m_dwState == STATE_GOTSIZE_PARSEDATA || m_dwState == STATE_PARSEDATA)
		{
			hr = E_FAIL;
			//
			// get the data
			//

			int nLength = WideCharToMultiByte(CP_ACP, 0, wszChars, cchChars, NULL, 0, NULL, NULL);

			if (nLength != 0)
			{
				char * pSrc = (char *) malloc(nLength*sizeof(char));
				if (pSrc != NULL)
				{
					nLength = WideCharToMultiByte(CP_ACP, 0, wszChars, cchChars, pSrc, nLength, NULL, NULL);
					if (nLength != 0)
					{
						ATLASSERT( m_pBlob != NULL );

						m_pBlob->data = (unsigned char *)malloc(nLength*sizeof(unsigned char));
						if (m_pBlob->data != NULL)
						{
							int nDataLength = nLength;
							if (Base64Decode(pSrc, nLength, m_pBlob->data, &nDataLength))
							{
								hr = S_OK;
							}
						}
					}

					free(pSrc);
				}
			}

			if (hr != S_OK)
			{
				if (m_pBlob->data != NULL)
				{
					free(m_pBlob->data);
					m_pBlob->data = NULL;
				}
			}

			if (m_dwState == STATE_PARSEDATA)
			{
				m_dwState = STATE_GOTDATA;
			}
			else
			{
				m_dwState = STATE_GOTALL;
			}
		}
		
		return hr;
	}
}; // class CBlobHandler


////////////////////////////////////////////////////////////////////////////////
//
// SAX string builder class
//
////////////////////////////////////////////////////////////////////////////////

class CSAXStringBuilder : public ISAXContentHandlerImpl
{
public:

	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_ISAXContentHandler))
		{
			*ppv = static_cast<ISAXContentHandler *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	ISAXContentHandler * m_pParent;
	ISAXXMLReader * m_pReader;
	DWORD m_dwReset;
	CStringW m_str;

	DWORD DisableReset(DWORD dwReset = 1) throw()
	{
		m_dwReset+= dwReset;

		return m_dwReset;
	}

	DWORD EnableReset() throw()
	{
		if (m_dwReset > 0)
		{
			--m_dwReset;
		}

		return m_dwReset;
	}

public:

	CSAXStringBuilder(ISAXXMLReader *pReader = NULL, ISAXContentHandler *pParent = NULL) throw()
		:m_pReader(pReader), m_pParent(pParent), m_dwReset(0)
	{
	}

	void SetReader(ISAXXMLReader *pReader) throw()
	{
		m_pReader = pReader;
	}

	void SetParent(ISAXContentHandler *pParent) throw()
	{
		m_pParent = pParent;
	}

	const CStringW& GetString() throw()
	{
		return m_str;
	}

	void Clear() throw()
	{
		m_str.Empty();
	}

	HRESULT __stdcall startElement( 
	     const wchar_t  * /*wszNamespaceUri*/,
	     int /*cchNamespaceUri*/,
	     const wchar_t  * /*wszLocalName*/,
	     int /*cchLocalName*/,
	     const wchar_t  *wszQName,
	     int cchQName,
	     ISAXAttributes  *pAttributes) throw()
	{
		DisableReset();

		int nAttrs = 0;
		HRESULT hr = pAttributes->getLength(&nAttrs);

		_ATLTRY
		{
			if (SUCCEEDED(hr))
			{
				m_str.Append(L"<", 1);
				m_str.Append(wszQName, cchQName);

				const wchar_t *wszAttrNamespaceUri = NULL;
				const wchar_t *wszAttrLocalName = NULL;
				const wchar_t *wszAttrQName = NULL;
				const wchar_t *wszAttrValue = NULL;
				int cchAttrUri = 0;
				int cchAttrLocalName = 0;
				int cchAttrQName = 0;
				int cchAttrValue = 0;

				for (int i=0; i<nAttrs; i++)
				{
					hr = pAttributes->getName(i, &wszAttrNamespaceUri, &cchAttrUri, 
						&wszAttrLocalName, &cchAttrLocalName, &wszAttrQName, &cchAttrQName);

					if (FAILED(hr))
					{
						break;
					}

					m_str.Append(L" ", 1);
					m_str.Append(wszAttrQName, cchAttrQName);

					hr = pAttributes->getValue(i, &wszAttrValue, &cchAttrValue);
					
					if (FAILED(hr))
					{
						break;
					}

					if (cchAttrValue != 0)
					{
						m_str.Append(L"=\"", 1);
						m_str.Append(wszAttrValue, cchAttrValue);
						m_str.Append(L"\"", 1);
					}
				}

				if (SUCCEEDED(hr))
				{
					m_str.Append(L">", 1);
				}
			}
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		return hr;
	}

	HRESULT __stdcall endElement( 
	     const wchar_t  * wszNamespaceUri,
	     int cchNamespaceUri,
	     const wchar_t  * wszLocalName,
	     int cchLocalName,
	     const wchar_t  *wszQName,
	     int cchQName) throw()
	{
		HRESULT hr = S_OK;
		_ATLTRY
		{
			if (m_dwReset > 0)
			{
				m_str.Append(L"</", 2);
				m_str.Append(wszQName, cchQName);
				m_str.Append(L">", 1);
			}

			if (EnableReset() == 0)
			{
				hr = m_pParent->characters((LPCWSTR) m_str, m_str.GetLength());
				if (SUCCEEDED(hr))
				{
					hr = m_pParent->endElement(wszNamespaceUri, cchNamespaceUri,
							wszLocalName, cchLocalName, wszQName, cchQName);
				}

				m_pReader->putContentHandler(m_pParent);
			}
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		return hr;
	}

	HRESULT __stdcall characters(
	     const wchar_t  *wszChars,
	     int cchChars) throw()
	{
		_ATLTRY
		{
			m_str.Append(wszChars, cchChars);
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT __stdcall ignorableWhitespace( 
	     const wchar_t  *wszChars,
	     int cchChars) throw()
	{
		_ATLTRY
		{
			m_str.Append(wszChars, cchChars);
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}
		
		return S_OK;
	}
}; // class CSAXStringBuilder

} // namespace ATL

////////////////////////////////////////////////////////////////////////////////
//
// SOAP data structure definitions
//
////////////////////////////////////////////////////////////////////////////////

//
// *****************************  WARNING  *****************************
// THESE STRUCTURES ARE INTERNAL ONLY, FOR USE WITH THE ATL SERVER SOAP 
// ATTRIBUTES. USERS SHOULD NOT USE THESE TYPES DIRECTLY. ABSOLUTELY NO 
// GUARANTEES ARE MADE ABOUT BACKWARD COMPATIBILITY FOR DIRECT USE OF 
// THESE TYPES.
//

////////////////////////////////////////////////////////////////////////////////
//
// BEGIN PRIVATE DEFINITIONS
//
////////////////////////////////////////////////////////////////////////////////

enum SOAPFLAGS
{
	SOAPFLAG_NONE           = 0x00000000,
	SOAPFLAG_IN             = 0x00000001,
	SOAPFLAG_OUT            = 0x00000002,
	SOAPFLAG_RETVAL         = 0x00000004,
	SOAPFLAG_DYNARR         = 0x00000008,
	SOAPFLAG_FIXEDARR       = 0x00000010,
	SOAPFLAG_MUSTUNDERSTAND = 0x00000020,
	SOAPFLAG_HEX            = 0x00000040,
	SOAPFLAG_BASE64         = 0x00000080,
	SOAPFLAG_UNKSIZE        = 0x00000100,
	SOAPFLAG_READYSTATE     = 0x00000200,
	SOAPFLAG_FIELD          = 0x00000400,
	SOAPFLAG_NOMARSHAL      = 0x00000800,

	SOAPFLAG_DOCUMENT       = 0x00001000,
	SOAPFLAG_RPC            = 0x00002000,
	SOAPFLAG_LITERAL        = 0x00004000,
	SOAPFLAG_ENCODED        = 0x00008000,
	SOAPFLAG_PID            = 0x00010000,
	SOAPFLAG_PAD            = 0x00020000,
	SOAPFLAG_CHAIN          = 0x00040000,
	SOAPFLAG_DISABLEPOP     = 0x00080000
};

enum SOAPMAPTYPE
{
	SOAPMAP_ERR = 0,
	SOAPMAP_ENUM,
	SOAPMAP_FUNC,
	SOAPMAP_STRUCT,
	SOAPMAP_UNION,
	SOAPMAP_HEADER,
	SOAPMAP_PARAM
};

struct _soapmap;

struct _soapmapentry
{
	ULONG nHash;
	const char * szField;
	const WCHAR * wszField;
	int cchField;
	int nVal;
	DWORD dwFlags;

	size_t nOffset;
	const int * pDims;
	
	const _soapmap * pChain;

	int nSizeIs;
};

struct _soapmap
{
	ULONG nHash;
	const char * szName;
	const wchar_t * wszName;
	int cchName;
	int cchWName;
	SOAPMAPTYPE mapType;
	const _soapmapentry * pEntries;
	size_t nElementSize;
	size_t nElements;
	int nRetvalIndex;

	DWORD dwCallFlags;
};

enum SOAPTYPES
{
	SOAPTYPE_ERR = -2,
	SOAPTYPE_UNK = -1,
	SOAPTYPE_STRING = 0,
	SOAPTYPE_BOOLEAN,
	SOAPTYPE_FLOAT,
	SOAPTYPE_DOUBLE,
	SOAPTYPE_DECIMAL,
	SOAPTYPE_TIMEDURATION,
	SOAPTYPE_RECURRINGDURATION,
	SOAPTYPE_BINARY,
	SOAPTYPE_URIREFERENCE,
	SOAPTYPE_ID,
	SOAPTYPE_IDREF,
	SOAPTYPE_ENTITY,
	SOAPTYPE_NOTATION,
	SOAPTYPE_QNAME,
	SOAPTYPE_CDATA,
	SOAPTYPE_TOKEN,
	SOAPTYPE_LANGUAGE,
	SOAPTYPE_IDREFS,
	SOAPTYPE_ENTITIES,
	SOAPTYPE_NMTOKEN,
	SOAPTYPE_NMTOKENS,
	SOAPTYPE_NAME,
	SOAPTYPE_NCNAME,
	SOAPTYPE_INTEGER,
	SOAPTYPE_NONPOSITIVEINTEGER,
	SOAPTYPE_NEGATIVEINTEGER,
	SOAPTYPE_LONG,
	SOAPTYPE_INT,
	SOAPTYPE_SHORT,
	SOAPTYPE_BYTE,
	SOAPTYPE_NONNEGATIVEINTEGER,
	SOAPTYPE_UNSIGNEDLONG,
	SOAPTYPE_UNSIGNEDINT,
	SOAPTYPE_UNSIGNEDSHORT,
	SOAPTYPE_UNSIGNEDBYTE,
	SOAPTYPE_POSITIVEINTEGER,
	SOAPTYPE_TIMEINSTANT,
	SOAPTYPE_TIME,
	SOAPTYPE_TIMEPERIOD,
	SOAPTYPE_DATE,
	SOAPTYPE_MONTH,
	SOAPTYPE_YEAR,
	SOAPTYPE_CENTURY,
	SOAPTYPE_RECURRINGDATE,
	SOAPTYPE_RECURRINGDAY,

	//
	// for ATLSOAP_BLOB
	//
	SOAPTYPE_BLOB,

	SOAPTYPE_USERBASE
};

inline ULONG AtlSoapHashStr(const char * sz) throw()
{
	ULONG nHash = 0;
	while (*sz != 0)
	{
		nHash = (nHash<<5)+nHash+(*sz);
		sz++;
	}

	return nHash;
}

inline ULONG AtlSoapHashStr(const wchar_t * sz) throw()
{
	ULONG nHash = 0;
	while (*sz != 0)
	{
		nHash = (nHash<<5)+nHash+(*sz);
		sz++;
	}

	return nHash;
}

inline ULONG AtlSoapHashStr(const char * sz, int cch) throw()
{
	ULONG nHash = 0;
	for (int i=0; i<cch; i++)
	{
		nHash = (nHash<<5)+nHash+(*sz);
		sz++;
	}

	return nHash;
}

inline ULONG AtlSoapHashStr(const wchar_t * sz, int cch) throw()
{
	ULONG nHash = 0;
	for (int i=0; i<cch; i++)
	{
		nHash = (nHash<<5)+nHash+(*sz);
		sz++;
	}

	return nHash;
}

inline size_t AtlSoapGetElementSize(SOAPTYPES type) throw()
{
	size_t nRet;
	switch (type)
	{
		case SOAPTYPE_BOOLEAN:
			nRet = sizeof(bool);
			break;
		case SOAPTYPE_FLOAT:
			nRet = sizeof(float);
			break;
		case SOAPTYPE_DOUBLE: 
		case SOAPTYPE_DECIMAL:
			nRet = sizeof(double);
			break;
		case SOAPTYPE_BINARY:
			nRet = sizeof(BYTE);
			break;
		case SOAPTYPE_INTEGER: 
		case SOAPTYPE_NONPOSITIVEINTEGER:
		case SOAPTYPE_NEGATIVEINTEGER:
		case SOAPTYPE_LONG:
			nRet = sizeof(__int64);
			break;
		case SOAPTYPE_INT:
			nRet = sizeof(int);
			break;
		case SOAPTYPE_SHORT:
			nRet = sizeof(short);
			break;
		case SOAPTYPE_BYTE:
			nRet = sizeof(char);
			break;
		case SOAPTYPE_NONNEGATIVEINTEGER:
		case SOAPTYPE_UNSIGNEDLONG:
			nRet = sizeof(unsigned __int64);
			break;
		case SOAPTYPE_UNSIGNEDINT:
			nRet = sizeof(unsigned int);
			break;
		case SOAPTYPE_UNSIGNEDSHORT:
			nRet = sizeof(unsigned short);
			break;
		case SOAPTYPE_UNSIGNEDBYTE:
			nRet = sizeof(unsigned char);
			break;
		case SOAPTYPE_BLOB:
			nRet = sizeof(ATLSOAP_BLOB);
			break;
		default:
			if ((type != SOAPTYPE_ERR) && (type != SOAPTYPE_UNK) && (type != SOAPTYPE_USERBASE))
			{
				// treat as string
				nRet = sizeof(BSTR);
			}
			else
			{
				// should never get here
				ATLASSERT( FALSE );
				nRet = 0;
			}
			break;
	}

	return nRet;
}

inline HRESULT AtlSoapGetElementValue(const wchar_t *wsz, int cch, 
	void *pVal, SOAPTYPES type) throw()
{
	HRESULT hr = E_FAIL;

	switch (type)
	{
		case SOAPTYPE_BOOLEAN:
			hr = AtlGetSAXValue((bool *)pVal, wsz, cch);
			break;
		case SOAPTYPE_FLOAT:
			hr = AtlGetSAXValue((float *)pVal, wsz, cch);
			break;
		case SOAPTYPE_DOUBLE: 
		case SOAPTYPE_DECIMAL:
			hr = AtlGetSAXValue((double *)pVal, wsz, cch);
			break;
		case SOAPTYPE_BINARY:
			ATLASSERT( FALSE );
			//
			// TODO: implement
			//
			break;
		case SOAPTYPE_INTEGER: 
		case SOAPTYPE_NONPOSITIVEINTEGER:
		case SOAPTYPE_NEGATIVEINTEGER:
		case SOAPTYPE_LONG:
			hr = AtlGetSAXValue((__int64 *)pVal, wsz, cch);
			break;
		case SOAPTYPE_INT:
			hr = AtlGetSAXValue((int *)pVal, wsz, cch);
			break;
		case SOAPTYPE_SHORT:
			hr = AtlGetSAXValue((short *)pVal, wsz, cch);
			break;
		case SOAPTYPE_BYTE:
			hr = AtlGetSAXValue((char *)pVal, wsz, cch);
			break;
		case SOAPTYPE_NONNEGATIVEINTEGER:
		case SOAPTYPE_UNSIGNEDLONG:
			hr = AtlGetSAXValue((unsigned __int64 *)pVal, wsz, cch);
			break;
		case SOAPTYPE_UNSIGNEDINT:
			hr = AtlGetSAXValue((unsigned int *)pVal, wsz, cch);
			break;
		case SOAPTYPE_UNSIGNEDSHORT:
			hr = AtlGetSAXValue((unsigned short *)pVal, wsz, cch);
			break;
		case SOAPTYPE_UNSIGNEDBYTE:
			hr = AtlGetSAXValue((unsigned char *)pVal, wsz, cch);
			break;
		case SOAPTYPE_BLOB:
			// should never get here
			ATLASSERT( FALSE );
			break;
		default:
			if ((type != SOAPTYPE_ERR) && (type != SOAPTYPE_UNK) && (type != SOAPTYPE_USERBASE))
			{
				hr = AtlGetSAXValue((BSTR *)pVal, wsz, cch);
			}
#ifdef _DEBUG
			else
			{
				// should never get here
				ATLASSERT( FALSE );
			}
#endif
			break;
	}

	return hr;
}

inline HRESULT AtlSoapGenElementValue(void *pVal, IWriteStream *pStream, SOAPTYPES type) throw()
{
	HRESULT hr = E_FAIL;

	switch (type)
	{
		case SOAPTYPE_BOOLEAN:
			hr = AtlGenXMLValue(pStream, (bool *)pVal);
			break;
		case SOAPTYPE_FLOAT:
			hr = AtlGenXMLValue(pStream, (float *)pVal);
			break;
		case SOAPTYPE_DOUBLE: 
		case SOAPTYPE_DECIMAL:
			hr = AtlGenXMLValue(pStream, (double *)pVal);
			break;
		case SOAPTYPE_BINARY:
			ATLASSERT( FALSE );
			//
			// TODO: implement
			//
			break;
		case SOAPTYPE_INTEGER: 
		case SOAPTYPE_NONPOSITIVEINTEGER:
		case SOAPTYPE_NEGATIVEINTEGER:
		case SOAPTYPE_LONG:
			hr = AtlGenXMLValue(pStream, (__int64 *)pVal);
			break;
		case SOAPTYPE_INT:
			hr = AtlGenXMLValue(pStream, (int *)pVal);
			break;
		case SOAPTYPE_SHORT:
			hr = AtlGenXMLValue(pStream, (short *)pVal);
			break;
		case SOAPTYPE_BYTE:
			hr = AtlGenXMLValue(pStream, (char *)pVal);
			break;
		case SOAPTYPE_NONNEGATIVEINTEGER:
		case SOAPTYPE_UNSIGNEDLONG:
			hr = AtlGenXMLValue(pStream, (unsigned __int64 *)pVal);
			break;
		case SOAPTYPE_UNSIGNEDINT:
			hr = AtlGenXMLValue(pStream, (unsigned int *)pVal);
			break;
		case SOAPTYPE_UNSIGNEDSHORT:
			hr = AtlGenXMLValue(pStream, (unsigned short *)pVal);
			break;
		case SOAPTYPE_UNSIGNEDBYTE:
			hr = AtlGenXMLValue(pStream, (unsigned char *)pVal);
			break;
		case SOAPTYPE_BLOB:
			hr = AtlGenXMLValue(pStream, (ATLSOAP_BLOB *)pVal);
			break;
		default:
			if ((type != SOAPTYPE_ERR) && (type != SOAPTYPE_UNK) && (type != SOAPTYPE_USERBASE))
			{
				hr = AtlGenXMLValue(pStream, (BSTR *)pVal);
			}
#ifdef _DEBUG
			else
			{
				// should never get here
				ATLASSERT( FALSE );
			}
#endif
			break;
	}

	return hr;
}

inline HRESULT AtlSoapCleanupElement(void *pVal, SOAPTYPES type) throw()
{
	HRESULT hr = S_OK;

	switch (type)
	{
		case SOAPTYPE_BOOLEAN:
		case SOAPTYPE_FLOAT:
		case SOAPTYPE_DOUBLE: 
		case SOAPTYPE_DECIMAL:
		case SOAPTYPE_INT:
		case SOAPTYPE_INTEGER: 
		case SOAPTYPE_NONPOSITIVEINTEGER:
		case SOAPTYPE_NEGATIVEINTEGER:
		case SOAPTYPE_LONG:
		case SOAPTYPE_SHORT:
		case SOAPTYPE_BYTE:
		case SOAPTYPE_NONNEGATIVEINTEGER:
		case SOAPTYPE_UNSIGNEDLONG:
		case SOAPTYPE_UNSIGNEDINT:
		case SOAPTYPE_UNSIGNEDSHORT:
		case SOAPTYPE_UNSIGNEDBYTE:
			break;

		case SOAPTYPE_BINARY:
			ATLASSERT( FALSE );
			//
			// TODO: implement
			//
			break;
		
		case SOAPTYPE_BLOB:
			// should never get here
			hr = AtlCleanupValue((ATLSOAP_BLOB *)pVal);
			break;
		default:
			if ((type != SOAPTYPE_ERR) && (type != SOAPTYPE_UNK) && (type != SOAPTYPE_USERBASE))
			{
				// treat as string
				hr = AtlCleanupValue((BSTR *)pVal);
			}
#ifdef _DEBUG
			else
			{
				// should never get here
				ATLASSERT( FALSE );
			}
#endif
			break;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// END PRIVATE DEFINITIONS
//
////////////////////////////////////////////////////////////////////////////////

#define SOAP_ENVELOPEA "Envelope"
#define SOAP_ENVELOPEW ATLSOAP_MAKEWIDESTR( SOAP_ENVELOPEA )

#define SOAP_HEADERA   "Header"
#define SOAP_HEADERW   ATLSOAP_MAKEWIDESTR( SOAP_HEADERA )

#define SOAP_BODYA     "Body"
#define SOAP_BODYW     ATLSOAP_MAKEWIDESTR( SOAP_BODYA )

namespace ATL
{

//
// SOAP fault helpers
//

enum SOAP_ERROR_CODE 
{ 
	SOAP_E_UNK=0,
	SOAP_E_VERSION_MISMATCH=100,
	SOAP_E_MUST_UNDERSTAND=200,
	SOAP_E_CLIENT=300,
	SOAP_E_SERVER=400
};

// forward declaration of CSoapFault
class CSoapFault;

class CSoapFaultParser : public ISAXContentHandlerImpl
{
private:

	CSoapFault *m_pFault;

	DWORD m_dwState;

	const static DWORD STATE_ERROR       = 0;
	const static DWORD STATE_ENVELOPE    = 1;
	const static DWORD STATE_BODY        = 2;
	const static DWORD STATE_START       = 4;
	const static DWORD STATE_FAULTCODE   = 8;
	const static DWORD STATE_FAULTSTRING = 16;
	const static DWORD STATE_FAULTACTOR  = 32;
	const static DWORD STATE_DETAIL      = 64;
	const static DWORD STATE_RESET       = 128;
	

	CComPtr<ISAXXMLReader> m_spReader;
	CSAXStringBuilder m_stringBuilder;

	const wchar_t *m_wszSoapPrefix;
	int      m_cchSoapPrefix;

public:

	// IUnknown interface
	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_ISAXContentHandler))
		{
			*ppv = static_cast<ISAXContentHandler *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

	// constructor

	CSoapFaultParser(CSoapFault *pFault, ISAXXMLReader *pReader) throw()
		:m_pFault(pFault), m_dwState(STATE_ERROR), m_spReader(pReader)
	{
		ATLASSERT( pFault != NULL );
		ATLASSERT( pReader != NULL );
	}

	// ISAXContentHandler interface
	HRESULT __stdcall startElement( 
	     const wchar_t  * wszNamespaceUri,
	     int cchNamespaceUri,
	     const wchar_t  * wszLocalName,
	     int cchLocalName,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/,
	     ISAXAttributes  * /*pAttributes*/) throw()
	{
		struct _faultmap
		{
			const wchar_t *wszTag;
			int cchTag;
			DWORD dwState;
		};

		const static _faultmap s_faultParseMap[] =
		{
			{ L"Envelope", sizeof("Envelope")-1, CSoapFaultParser::STATE_ENVELOPE },
			{ L"Body", sizeof("Body")-1, CSoapFaultParser::STATE_BODY },
			{ L"Fault", sizeof("Fault")-1, CSoapFaultParser::STATE_START },
			{ L"faultcode", sizeof("faultcode")-1, CSoapFaultParser::STATE_FAULTCODE },
			{ L"faultstring", sizeof("faultstring")-1, CSoapFaultParser::STATE_FAULTSTRING },
			{ L"faultactor", sizeof("faultactor")-1, CSoapFaultParser::STATE_FAULTACTOR },
			{ L"detail", sizeof("detail")-1, CSoapFaultParser::STATE_DETAIL }
		};

		if (m_spReader.p == NULL)
		{
			return E_INVALIDARG;
		}

		m_dwState &= ~STATE_RESET;
		for (int i=0; i<(sizeof(s_faultParseMap)/sizeof(s_faultParseMap[0])); i++)
		{
			if ((cchLocalName == s_faultParseMap[i].cchTag) &&
				(!wcsncmp(wszLocalName, s_faultParseMap[i].wszTag, cchLocalName)))
			{
				DWORD dwState = s_faultParseMap[i].dwState;
				if ((dwState & (STATE_START | STATE_ENVELOPE | STATE_BODY)) == 0)
				{
					m_stringBuilder.SetReader(m_spReader);
					m_stringBuilder.SetParent(this);

					m_stringBuilder.Clear();
					m_spReader->putContentHandler( &m_stringBuilder );
				}
				else
				{
					if ((dwState <= m_dwState) || 
						(cchNamespaceUri != sizeof(SOAPENV_NAMESPACEA)-1) ||
						(wcsncmp(wszNamespaceUri, SOAPENV_NAMESPACEW, cchNamespaceUri)))
					{
						return E_FAIL;
					}
				}

				m_dwState = dwState;
				return S_OK;
			}
		}

		return E_FAIL;
	}

	HRESULT __stdcall startPrefixMapping(
	     const wchar_t  * wszPrefix,
	     int cchPrefix,
	     const wchar_t  * wszUri,
	     int cchUri) throw()
	{
		if ((cchUri == sizeof(SOAPENV_NAMESPACEA)-1) &&
			(!wcsncmp(wszUri, SOAPENV_NAMESPACEW, cchUri)))
		{
			m_wszSoapPrefix = wszPrefix;
			m_cchSoapPrefix = cchPrefix;
		}

		return S_OK;
	}

	HRESULT __stdcall characters( 
	     const wchar_t  * wszChars,
	     int cchChars) throw();
};

extern __declspec(selectany) const int ATLS_SOAPFAULT_CNT = 4;

class CSoapFault
{
private:

	struct _faultcode
	{
		const wchar_t *wsz;
		int cch;
		const wchar_t *wszFaultString;
		int cchFaultString;
		SOAP_ERROR_CODE errCode;
	};

	static const _faultcode s_faultCodes[];

public:

	// members
	SOAP_ERROR_CODE m_soapErrCode;
	CStringW m_strFaultString;
	CStringW m_strFaultActor;
	CStringW m_strDetail;

	CSoapFault() throw()
		: m_soapErrCode(SOAP_E_UNK)
	{
	}

	HRESULT SetErrorCode(
		const wchar_t *wsz, 
		const wchar_t *wszSoapPrefix,
		int cch = -1, 
		int cchSoapPrefix = -1,
		bool bSetFaultString = true) throw()
	{
		if ((wsz == NULL) || (wszSoapPrefix == NULL))
		{
			return E_INVALIDARG;
		}

		if (cch == -1)
		{
			cch = (int) wcslen(wsz);
		}

		if (cchSoapPrefix == -1)
		{
			cchSoapPrefix = (int) wcslen(wszSoapPrefix);
		}

		const wchar_t *wszLocalName = wcschr(wsz, L':');
		if (wszLocalName == NULL)
		{
			// faultCode must be QName
			return E_FAIL;
		}

		// make sure the the namespace of the fault is the
		// SOAPENV namespace
		if ((cchSoapPrefix != (int)(wszLocalName-wsz)) ||
			(wcsncmp(wsz, wszSoapPrefix, cchSoapPrefix)))
		{
			return E_FAIL;
		}

		wszLocalName++;
		cch -= (int) (wszLocalName-wsz);

		HRESULT hr = E_FAIL;
		_ATLTRY
		{
			for (int i=0; i<ATLS_SOAPFAULT_CNT; i++)
			{
				if ((cch == s_faultCodes[i].cch) &&
					(!wcsncmp(wszLocalName, s_faultCodes[i].wsz, cch)))
				{
					m_soapErrCode = s_faultCodes[i].errCode;
					if (bSetFaultString != false)
					{
						m_strFaultString.SetString(s_faultCodes[i].wszFaultString, s_faultCodes[i].cchFaultString);
					}
					hr = S_OK;
					break;
				}
			}
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
		return hr;
	}

	HRESULT ParseFault(IStream *pStream, ISAXXMLReader *pReader = NULL) throw()
	{
		if (pStream == NULL)
		{
			return E_INVALIDARG;
		}

		CComPtr<ISAXXMLReader> spReader;
		if (pReader != NULL)
		{
			spReader = pReader;
		}
		else
		{
			if (FAILED(spReader.CoCreateInstance(__uuidof(SAXXMLReader30))))
			{
				return E_FAIL;
			}
		}

		Clear();
		CSoapFaultParser parser(const_cast<CSoapFault *>(this), spReader);
		spReader->putContentHandler(&parser);

		CComVariant varStream;
		varStream = static_cast<IUnknown*>(pStream);

		HRESULT hr = spReader->parse(varStream);
		spReader->putContentHandler(NULL);
		return hr;
	}

	HRESULT GenerateFault(IWriteStream *pWriteStream) throw()
	{
		if ((pWriteStream == NULL) || (m_soapErrCode == SOAP_E_UNK))
		{
			return E_INVALIDARG;
		}

		ATLASSERT( (m_soapErrCode == SOAP_E_UNK) || 
		           (m_soapErrCode == SOAP_E_VERSION_MISMATCH) ||
		           (m_soapErrCode == SOAP_E_MUST_UNDERSTAND) || 
				   (m_soapErrCode == SOAP_E_CLIENT) ||
				   (m_soapErrCode == SOAP_E_SERVER) );

		HRESULT hr = S_OK;
		_ATLTRY
		{
			int i;
			for (i=0; i<4; i++)
			{
				if (s_faultCodes[i].errCode == m_soapErrCode)
				{
					if (m_strFaultString.GetLength() == 0)
					{
						m_strFaultString.SetString(s_faultCodes[i].wszFaultString, 
								s_faultCodes[i].cchFaultString);
					}
					break;
				}
			}
		
			const LPCSTR s_szErrorFormat =
				"<SOAP:Envelope xmlns:SOAP=\"" SOAPENV_NAMESPACEA "\">\n"
				"	<SOAP:Body>\n"
				"		<SOAP:Fault>\n"
				"			<faultcode>SOAP:%ws</faultcode>\n"
				"			<faultstring>%ws</faultstring>\n"
				"%s%ws%s"
				"%s%ws%s"
				"		</SOAP:Fault>\n"
				"	</SOAP:Body>\n"
				"</SOAP:Envelope>\n";

			CStringA strFault;
			strFault.Format(s_szErrorFormat, s_faultCodes[i].wsz, m_strFaultString, 
				m_strFaultActor.GetLength() ? "<faultactor>" : "", m_strFaultActor, 
				m_strFaultActor.GetLength() ? "</faultactor>\n" : "",
				m_strDetail.GetLength() ? "<detail>" : "", m_strDetail,
				m_strDetail.GetLength() ? "</detail>\n" : "");

			hr = pWriteStream->WriteStream(strFault, strFault.GetLength(), NULL);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		return hr;
	}

	void Clear() throw()
	{
		m_soapErrCode = SOAP_E_UNK;
		m_strFaultString.Empty();
		m_strFaultActor.Empty();
		m_strDetail.Empty();
	}
}; // class CSoapFault

#define DECLARE_SOAP_FAULT(__name, __faultstring, __errcode) \
	{ L ## __name, sizeof(__name)-1, L ## __faultstring, sizeof(__faultstring), __errcode },

__declspec(selectany) const CSoapFault::_faultcode CSoapFault::s_faultCodes[] =
{
	DECLARE_SOAP_FAULT("VersionMismatch", "SOAP Version Mismatch Error", SOAP_E_VERSION_MISMATCH)
	DECLARE_SOAP_FAULT("MustUnderstand", "SOAP Must Understand Error", SOAP_E_MUST_UNDERSTAND)
	DECLARE_SOAP_FAULT("Client", "SOAP Invalid Request", SOAP_E_CLIENT)
	DECLARE_SOAP_FAULT("Server", "SOAP Server Application Faulted", SOAP_E_SERVER)
};

ATL_NOINLINE inline HRESULT __stdcall CSoapFaultParser::characters( 
	     const wchar_t  * wszChars,
	     int cchChars) throw()
{
	if (m_pFault == NULL)
	{
		return E_INVALIDARG;
	}

	if (m_dwState & STATE_RESET)
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;
	_ATLTRY
	{
		switch (m_dwState)
		{
			case STATE_FAULTCODE:
				if (m_pFault->m_soapErrCode == SOAP_E_UNK)
				{
					hr = m_pFault->SetErrorCode(wszChars, m_wszSoapPrefix, 
						cchChars, m_cchSoapPrefix, false);
				}
				break;
			case STATE_FAULTSTRING:
				if (m_pFault->m_strFaultString.GetLength() == 0)
				{
					m_pFault->m_strFaultString.SetString(wszChars, cchChars);
					hr = S_OK;
				}
				break;
			case STATE_FAULTACTOR:
				if (m_pFault->m_strFaultActor.GetLength() == 0)
				{
					m_pFault->m_strFaultActor.SetString(wszChars, cchChars);
					hr = S_OK;
				}
				break;
			case STATE_DETAIL:
				if (m_pFault->m_strDetail.GetLength() == 0)
				{
					m_pFault->m_strDetail.SetString(wszChars, cchChars);
					hr = S_OK;
				}
				break;
			case STATE_START: case STATE_ENVELOPE : case STATE_BODY :
				hr = S_OK;
				break;
			default:
				// should never get here
				ATLASSERT( FALSE );
				break;
		}
	}
	_ATLCATCHALL()
	{
		hr = E_OUTOFMEMORY;
	}
	
	m_dwState |= STATE_RESET;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CSoapRootHandler - the class that does most of the work
//
////////////////////////////////////////////////////////////////////////////////

#ifndef ATLSOAP_STACKSIZE
// 16 will be plenty for the 99% case
#define ATLSOAP_STACKSIZE 16
#endif

class CSoapRootHandler : public ISAXContentHandlerImpl
{
private:

	friend class _CSDLGenerator;

	//
	// state constants
	//
	const static DWORD SOAP_START        = 0;
	const static DWORD SOAP_ENVELOPE     = 1;
	const static DWORD SOAP_HEADERS      = 2;
	const static DWORD SOAP_BODY         = 3;
	const static DWORD SOAP_PARAMS       = 4;
	const static DWORD SOAP_CALLED       = 5;
	const static DWORD SOAP_RESPONSE     = 6;
	const static DWORD SOAP_HEADERS_DONE = 7;

	//
	// hash values for SOAP namespaces and elements
	//
	const static ULONG SOAP_ENV = 0x5D3574E2;
	const static ULONG SOAP_ENC = 0xBD62724B;
	const static ULONG ENVELOPE = 0xDBE6009E;
	const static ULONG HEADER   = 0xAF4DFFC9;
	const static ULONG BODY     = 0x0026168E;

	//
	// XSD Names
	//
	struct XSDEntry
	{
		wchar_t * wszName;
		char * szName;
		int cchName;
	};

	const static XSDEntry s_xsdNames[];

	//
	// CBitVector - a dynamically sized bit vector class
	//
	class CBitVector
	{
	private:

		// 64 bits will handle the 99% case
		unsigned __int64 m_nBits;

		// when we need to grow
		unsigned __int64 * m_pBits;

		size_t m_nSize;

		bool Grow(size_t nIndex) throw()
		{
			// round up to nearest 64 bits
			size_t nAllocSize = nIndex+(64-(nIndex%64));

			if (m_pBits != &m_nBits)
			{
				m_pBits = (unsigned __int64 *) realloc(m_pBits, nAllocSize/4);
			}
			else
			{
				m_pBits = (unsigned __int64 *) malloc(nAllocSize/4);
				if (m_pBits != NULL)
				{
					memcpy(m_pBits, &m_nBits, sizeof(m_nBits));
				}
			}
			
			if (m_pBits != NULL)
			{
				// set new bits to 0
				memset(m_pBits+(m_nSize/(sizeof(m_nBits)*8)), 0x00, (nAllocSize-m_nSize)/sizeof(m_nBits));
				m_nSize = nAllocSize;
				return true;
			}

			return false;
		}
		
	public:

		CBitVector() throw()
			: m_nBits(0), m_nSize(64)
		{
			m_pBits = &m_nBits;
		}

		CBitVector(const CBitVector&) throw()
		{
			m_pBits = &m_nBits;
		}

		const CBitVector& operator=(const CBitVector& that) throw()
		{
			if (this != &that)
			{
				m_pBits = &m_nBits;
			}

			return *this;
		}

		bool GetBit(size_t nIndex) throw()
		{
			if (nIndex >= m_nSize)
			{
				return false;
			}
			
			size_t i = nIndex/64;
			size_t nBits = nIndex-i*64;
			return ((m_pBits[i] >> nBits) & 0x01);
		}
		
		bool SetBit(size_t nIndex) throw()
		{
			if (nIndex >= m_nSize)
			{
				if (!Grow(nIndex))
				{
					return false;
				}
			}
			
			size_t i = nIndex/64;
			size_t nBits = nIndex-i*64;
			m_pBits[i] |= (((unsigned __int64) 1) << nBits);
			
			return true;
		}

		void Clear() throw()
		{
			if (m_pBits == &m_nBits)
			{
				m_nBits = 0;
			}
			else
			{
				memset(m_pBits, 0x00, (m_nSize/4));
			}
		}
		
		~CBitVector() throw()
		{
			if (m_pBits != &m_nBits)
			{
				free(m_pBits);
			}

			m_pBits = &m_nBits;
			m_nSize = 64;
		}
	}; // class CBitVector

	//
	// Parsing State
	//
	struct ParseState
	{
		void *pvElement;
		DWORD dwFlags;
		size_t nAllocSize;
		size_t nExpectedElements;
		size_t nElement;
		const _soapmap *pMap;
		const _soapmapentry *pEntry;

		// mark when we get an item
		CBitVector vec;

		ParseState(void *pvElement_ = NULL, DWORD dwFlags_ = 0, 
			size_t nAllocSize_ = 0, size_t nExpectedElements_ = 0, 
			size_t nElement_ = 0, const _soapmap *pMap_ = NULL, 
			const _soapmapentry *pEntry_ = NULL) throw()
			: pvElement(pvElement_), dwFlags(dwFlags_), nAllocSize(nAllocSize_),
			  nExpectedElements(nExpectedElements_), nElement(nElement_), pMap(pMap_),
			  pEntry(pEntry_)
		{
			vec.Clear();
		}

		ParseState(const ParseState& that) throw()
		{
			pvElement = that.pvElement;
			dwFlags = that.dwFlags;
			nAllocSize = that.nAllocSize;
			nExpectedElements = that.nExpectedElements;
			nElement = that.nElement;
			pMap = that.pMap;
			pEntry = that.pEntry;

			vec.Clear();
		}

		~ParseState() throw()
		{
			pvElement = NULL;
			dwFlags = 0;
			nAllocSize = 0;
			nExpectedElements = 0;
			nElement = 0;
			pMap = NULL;
			pEntry = NULL;

			vec.Clear();
		}
	}; // struct ParseState

	//
	// members
	//
	CAtlArray<ParseState> m_stateStack;
	size_t m_nState;

	DWORD m_dwState;
	bool m_bErrorsOccurred;

	CComPtr<ISAXXMLReader> m_spReader;

	CSAXStringBuilder m_stringBuilder;
	CBlobHandler m_blobHandler;
	CSkipHandler m_skipHandler;

	IAtlMemMgr * m_pMemMgr;

	static CCRTHeap m_crtHeap;

	bool m_bClient;

	void *m_pvParam;

	typedef CFixedStringT<CStringW, 16> REFSTRING;

	// used for rpc/encoded messages with href's
	typedef CAtlMap<REFSTRING, ParseState, CStringRefElementTraits<REFSTRING> > REFMAP;
	REFMAP m_refMap;

	//
	// Implementation helpers
	//

	HRESULT PushState(void *pvElement = NULL, const _soapmap *pMap = NULL,
			const _soapmapentry *pEntry = NULL, DWORD dwFlags = 0, size_t nAllocSize = 0, 
			size_t nExpectedElements = 0, size_t nElement = 0) throw()
	{
		// REVIEW: CAtlArray::Add() and CAtlArray::SetCount do not throw if the default
		// constructor of the element doesn't throw, but should review with dbartol if
		// he plans to change it.
		if (m_stateStack.IsEmpty())
		{
			// 16 will be plenty for the 99% case
			if (!m_stateStack.SetCount(0, 16))
			{
				// REVIEW: not necessary right now, but might change in the future (?)
				return E_OUTOFMEMORY;
			}
		}

		size_t nCnt = m_stateStack.GetCount();
		m_nState = m_stateStack.Add();
		if (m_stateStack.GetCount() <= nCnt)
		{
			return E_OUTOFMEMORY;
		}

		ParseState &state = m_stateStack[m_nState];

		state.pvElement = pvElement;
		state.dwFlags = dwFlags;
		state.nAllocSize = nAllocSize;
		state.nExpectedElements = nExpectedElements;
		state.nElement = nElement;
		state.pMap = pMap;
		state.pEntry = pEntry;

		return S_OK;
	}

	ParseState& GetState() throw()
	{
		return m_stateStack[m_nState];
	}

	ParseState PopState(bool bForce = false) throw()
	{
		ParseState popState( m_stateStack[m_nState] );

		if ((m_nState != 0) || (bForce != false))
		{
			if ((m_stateStack[m_nState].dwFlags & SOAPFLAG_DISABLEPOP) == 0)
			{
				m_stateStack.RemoveAt(m_nState);
				--m_nState;
			}
		}

		m_stateStack[m_nState].dwFlags &= ~SOAPFLAG_DISABLEPOP;
		return popState;
	}

	BOOL IsEqualElement(int cchLocalNameCheck, const wchar_t *wszLocalNameCheck, 
		int cchNamespaceUriCheck, const wchar_t *wszNamespaceUriCheck,
		int cchLocalName, const wchar_t *wszLocalName,
		int cchNamespaceUri, const wchar_t *wszNamespaceUri) throw()
	{
		if (cchLocalName == cchLocalNameCheck &&
			cchNamespaceUri == cchNamespaceUriCheck &&
			!wcsncmp(wszLocalName, wszLocalNameCheck, cchLocalName) &&
			!wcsncmp(wszNamespaceUri, wszNamespaceUriCheck, cchNamespaceUri))
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsEqualElement(int cchLocalNameCheck, const wchar_t *wszLocalNameCheck, 
		int cchLocalName, const wchar_t *wszLocalName) throw()
	{
		if (cchLocalName == cchLocalNameCheck &&
			!wcsncmp(wszLocalName, wszLocalNameCheck, cchLocalName))
		{
			return TRUE;
		}

		return FALSE;
	}

	void SetOffsetValue(void *pBase, void *pSrc, size_t nOffset) throw()
	{
		void **ppDest = (void **)(((unsigned char *)pBase)+nOffset);
		*ppDest = pSrc;
	}

	HRESULT ValidateArrayEntry(
		const ParseState& state,
	    const wchar_t  *wszLocalName,
	    int cchLocalName) throw()
	{
		ATLASSERT( state.pEntry != NULL );

		// check number of elements
		if (state.nElement == state.nExpectedElements)
		{
			// too many elements
			return E_FAIL;
		}

		// REVIEW: validate namespace?

		// validate element type

		// if UDT
		if (state.pEntry->nVal == SOAPTYPE_UNK)
		{
			ATLASSERT( state.pEntry->pChain != NULL );

			// validate against name in entry

			if ((cchLocalName != state.pEntry->pChain->cchWName) ||
				(wcsncmp(wszLocalName, state.pEntry->pChain->wszName, cchLocalName)))
			{
				return E_FAIL;
			}
		}
		else // simple type or SOAP_BLOB
		{
			ATLASSERT( state.pEntry->nVal != SOAPTYPE_ERR );
			ATLASSERT( state.pEntry->nVal != SOAPTYPE_USERBASE );

			// validate against name s_xsdNames

			if ((cchLocalName != s_xsdNames[state.pEntry->nVal].cchName) ||
				(wcsncmp(wszLocalName, s_xsdNames[state.pEntry->nVal].wszName, cchLocalName)))
			{
				return E_FAIL;
			}
		}

		return S_OK;
	}

	HRESULT CheckID(
		const wchar_t *wszNamespaceUri,
		const wchar_t *wszLocalName,
		int cchLocalName,
		ISAXAttributes *pAttributes) throw()
	{
		wszNamespaceUri;
		ATLASSERT( pAttributes != NULL );

		const wchar_t *wsz = NULL;
		int cch = 0;

		HRESULT hr = GetAttribute(pAttributes, L"id", sizeof("id")-1, &wsz, &cch);
		if ((hr == S_OK) && (wsz != NULL))
		{
			const REFMAP::CPair *p = NULL;
			_ATLTRY
			{
				REFSTRING strRef(wsz, cch);
				p = m_refMap.Lookup(strRef);
				if (p == NULL)
				{
					// not referenced
					// REVIEW: just skip element?
					return E_FAIL;
				}
			}
			_ATLCATCHALL()
			{
				return E_OUTOFMEMORY;
			}
			const ParseState& state = p->m_value;

			// make sure it's the right element
			// REVIEW (jasjitg): some namespace stuff is screwed up
			if ((cchLocalName == state.pMap->cchWName) &&
				(!wcsncmp(wszLocalName, state.pMap->wszName, cchLocalName)))/* &&
				(!wcscmp(wszNamespaceUri, GetNamespaceUri())))*/
			{
				// REVIEW: should check the current state to make sure we push only at valid times
				if (S_OK != PushState(state.pvElement, state.pMap, state.pEntry, state.dwFlags, 0, state.pMap->nElements))
				{
					return E_OUTOFMEMORY;
				}

				m_refMap.RemoveAtPos(const_cast<REFMAP::CPair*>(p));
				return S_OK;
			}

			// not the right type
			return E_FAIL;
		}

		return S_FALSE;
	}

	HRESULT GetElementEntry(
		ParseState& state,
		const wchar_t *wszNamespaceUri,
	    const wchar_t *wszLocalName,
	    int cchLocalName,
		ISAXAttributes *pAttributes,
		const _soapmapentry **ppEntry) throw()
	{
		ATLASSERT( state.pMap != NULL );
		ATLASSERT( ppEntry != NULL );

		*ppEntry = NULL;
		const _soapmapentry *pEntries = state.pMap->pEntries;
		DWORD dwIncludeFlags;
		DWORD dwExcludeFlags;

		HRESULT hr = CheckID(wszNamespaceUri, wszLocalName, cchLocalName, pAttributes);
		if (hr != S_FALSE)
		{
			if (hr == S_OK)
			{
				hr = S_FALSE;
			}
			return hr;
		}

		if (m_bClient != false)
		{
			dwIncludeFlags = SOAPFLAG_OUT;
			dwExcludeFlags = SOAPFLAG_IN;
		}
		else
		{
			dwIncludeFlags = SOAPFLAG_IN;
			dwExcludeFlags = SOAPFLAG_OUT;
		}

		ULONG nHash = AtlSoapHashStr(wszLocalName, cchLocalName);

		for (size_t i=0; pEntries[i].nHash != 0; i++)
		{
			//
			// TODO: check flags here (?)
			//

			if (nHash == pEntries[i].nHash && 
				((pEntries[i].dwFlags & dwIncludeFlags) || 
				 ((pEntries[i].dwFlags & dwExcludeFlags) == 0)) &&
				IsEqualElement(pEntries[i].cchField, pEntries[i].wszField, 
				cchLocalName, wszLocalName)/* &&
				!wcscmp(wszNamespaceUri, wszNamespace)*/)
			{
				// check bit vector

				if (state.vec.GetBit(i) == false)
				{
					if (state.vec.SetBit(i) == false)
					{
						return E_OUTOFMEMORY;
					}
				}
				else
				{
					// already received this element

					return E_FAIL;
				}

				state.nElement++;
				*ppEntry = &pEntries[i];

				return S_OK;
			}
		}

		return E_FAIL;
	}

	HRESULT CheckMustUnderstandHeader(ISAXAttributes *pAttributes) throw()
	{
		ATLASSERT( pAttributes != NULL );

		const wchar_t* wszMustUnderstand;
		int cchMustUnderstand;
		bool bMustUnderstand= false;
		
		if (SUCCEEDED(GetAttribute(pAttributes, L"mustUnderstand", sizeof("mustUnderstand")-1, 
				&wszMustUnderstand, &cchMustUnderstand,
				SOAPENV_NAMESPACEW, sizeof(SOAPENV_NAMESPACEA)-1)) && 
				(wszMustUnderstand != NULL))
		{
			if (FAILED(AtlGetSAXValue(&bMustUnderstand, wszMustUnderstand, cchMustUnderstand)))
			{
				bMustUnderstand = true;
			}
		}

		if (bMustUnderstand == false)
		{
			ATLASSERT( GetReader() != NULL );

			m_skipHandler.SetReader(GetReader());
			m_skipHandler.SetParent(this);

			return GetReader()->putContentHandler( &m_skipHandler );
		}
//		else
//		{
//			// TODO: SOAP Fault with mustUnderstand
//		}

		return E_FAIL;
	}

	HRESULT GetSection5Info(
		const ParseState& state,
		const _soapmapentry *pEntry,
		ISAXAttributes *pAttributes) throw()
	{
		ATLASSERT( pEntry != NULL );
		ATLASSERT( pAttributes != NULL );

		size_t nElements;
		DWORD dwFlags = 0;
		HRESULT hr = AtlSoapGetArraySize(pAttributes, &nElements);
		if (SUCCEEDED(hr))
		{
			// do any allocations if necessary

			size_t nElementSize;
			if (pEntry->dwFlags & SOAPFLAG_DYNARR)
			{
				if (pEntry->nVal != SOAPTYPE_UNK)
				{
					nElementSize = AtlSoapGetElementSize((SOAPTYPES) pEntry->nVal);
				}
				else // UDT
				{
					ATLASSERT( pEntry->pChain != NULL );

					nElementSize = pEntry->pChain->nElementSize;
				}

				if (nElementSize != 0)
				{
					ATLASSERT( nElements != 0 );

					void *p = m_pMemMgr->Allocate(nElementSize*nElements);
					if (p == NULL)
					{
						return E_OUTOFMEMORY;
					}

					memset(p, 0x00, nElementSize*nElements);

					SetOffsetValue(state.pvElement, p, pEntry->nOffset);
				}
				else
				{
					// fatal internal error

					ATLASSERT( FALSE );

					return E_FAIL;
				}

				// set size_is value

				ATLASSERT( GetState().pMap != NULL );

				int *pnSizeIs = (int *)(((unsigned char *)state.pvElement)+
					(state.pMap->pEntries[pEntry->nSizeIs].nOffset));
				*pnSizeIs = (int)nElements;
			}
			else
			{
				ATLASSERT( pEntry->dwFlags & SOAPFLAG_FIXEDARR );

				// for fixed size arrays, we know the number of elements

				if (nElements != AtlSoapGetArrayDims(pEntry->pDims))
				{
					return E_FAIL;
				}
			}
		}
		else if (pEntry->dwFlags & SOAPFLAG_DYNARR)
		{
			// TODO: missing section-5 info: allocate as necessary

			// dwFlags |= SOAPFLAG_UNKSIZE;

			return E_FAIL;
		}
		else
		{
			ATLASSERT( pEntry->dwFlags & SOAPFLAG_FIXEDARR );

			nElements = AtlSoapGetArrayDims(pEntry->pDims);
		}

		dwFlags |= pEntry->dwFlags;

		// push element with array flag

		if (S_OK != PushState(((unsigned char *)state.pvElement)+pEntry->nOffset, 
			NULL, pEntry, dwFlags & ~SOAPFLAG_READYSTATE, 0, nElements))
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	void * UpdateArray(ParseState& state, const _soapmapentry *pEntry) throw()
	{
		size_t nSize;
		void *pVal = NULL;
		if (pEntry->nVal != SOAPTYPE_UNK)
		{
			nSize = AtlSoapGetElementSize((SOAPTYPES) pEntry->nVal);
		}
		else
		{
			ATLASSERT( pEntry->pChain != NULL );

			nSize = pEntry->pChain->nElementSize;
		}

		if (state.dwFlags & SOAPFLAG_FIXEDARR)
		{
			unsigned char *ppArr = (unsigned char *)state.pvElement;
			pVal = ppArr+(state.nElement*nSize);
		}
		else
		{
			ATLASSERT( state.dwFlags & SOAPFLAG_DYNARR );

			unsigned char **ppArr = (unsigned char **)state.pvElement;
			pVal = (*ppArr)+(state.nElement*nSize);
		}

		state.nElement++;

		return pVal;
	}

	HRESULT ProcessString(const _soapmapentry *pEntry, ISAXAttributes *pAttributes, void *pVal) throw()
	{
		ATLASSERT( pEntry != NULL );
		ATLASSERT( pAttributes != NULL );

		// check for the xsi:null attribute
		const wchar_t *wszNull;
		int cchNull;

		DWORD dwFlags = SOAPFLAG_NONE;
		if (SUCCEEDED(GetAttribute(pAttributes, L"null", sizeof("null")-1, &wszNull, &cchNull,
				XSI_NAMESPACEW, sizeof(XSI_NAMESPACEA)-1)) && 
				(wszNull != NULL) && 
				(cchNull == sizeof("true")-1) &&
				(!wcsncmp(wszNull, L"true", cchNull)))
		{
			*((unsigned char *)pVal) = NULL;
		}
		else
		{
			//  set to the string builder class

			ATLASSERT( GetReader() != NULL );

			m_stringBuilder.SetReader(GetReader());
			m_stringBuilder.SetParent(this);

			m_stringBuilder.Clear();
			GetReader()->putContentHandler( &m_stringBuilder );

			dwFlags = SOAPFLAG_READYSTATE;
		}

		if (S_OK != PushState(pVal, NULL, pEntry, dwFlags | pEntry->dwFlags))
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT ProcessBlob(void *pVal) throw()
	{
		ATLASSERT( GetReader() != NULL );
		ATLASSERT( pVal != NULL );

		m_blobHandler.SetBlob((ATLSOAP_BLOB *) pVal);
		m_blobHandler.SetReader(GetReader());
		m_blobHandler.SetParent(this);
		return GetReader()->putContentHandler( &m_blobHandler );
	}

	HRESULT CheckHref(
		const _soapmapentry *pEntry,
		void *pVal,
		ISAXAttributes *pAttributes) throw()
	{
		ATLASSERT( pEntry != NULL );
		ATLASSERT( pVal != NULL );
		ATLASSERT( pAttributes != NULL );
		ATLASSERT( pEntry->pChain != NULL );

		const _soapmap *pMap = pEntry->pChain;
		if (pMap->mapType != SOAPMAP_STRUCT)
		{
			// can only be used on structs
			return E_FAIL;
		}

		const wchar_t *wsz = NULL;
		int cch = 0;

		HRESULT hr = GetAttribute(pAttributes, L"href", sizeof("href")-1, &wsz, &cch);
		if ((hr == S_OK) && (wsz != NULL))
		{
			_ATLTRY
			{
				if (*wsz == L'#')
				{
					wsz++;
					cch--;
				}

				REFSTRING strRef(wsz, cch);
				if (m_refMap.Lookup(strRef) != NULL)
				{
					// ATL Server does not support multi-reference objects 
					ATLASSERT( FALSE );
					return E_FAIL;
				}

				ParseState state;
				state.pvElement = pVal;
				state.dwFlags = pEntry->dwFlags;
				state.nExpectedElements = pMap->nElements;
				state.nElement = 0;
				state.pMap = pMap;
				state.pEntry = pEntry;

				if (!m_refMap.SetAt(strRef, state))
				{
					return E_OUTOFMEMORY;
				}

				GetState().dwFlags |= SOAPFLAG_DISABLEPOP;
				return S_OK;
			}
			_ATLCATCHALL()
			{
				return E_OUTOFMEMORY;
			}
		}

		return S_FALSE;
	}

	HRESULT ProcessUDT(
		const _soapmapentry *pEntry, 
		void *pVal, 
		ISAXAttributes *pAttributes) throw()
	{
		ATLASSERT( pEntry != NULL );
		ATLASSERT( pVal != NULL );
		ATLASSERT( pAttributes != NULL );
		ATLASSERT( pEntry->nVal != SOAPTYPE_ERR );
		ATLASSERT( pEntry->nVal != SOAPTYPE_USERBASE );

		if ((pEntry->dwFlags & (SOAPFLAG_RPC | SOAPFLAG_ENCODED)) ==
			 (SOAPFLAG_RPC | SOAPFLAG_ENCODED))
		{
			// check for href
			// we ONLY do this for rpc/encoded (required for interop)
			// NOTE: ATL Server does not support object graphs, so 
			// only single-reference elements are allowed
			HRESULT hr = CheckHref(pEntry, pVal, pAttributes);
			if (hr != S_FALSE)
			{
				return hr;
			}
		}

		// if it is a complex type, get the chain entry
		// and push the new state on the stack

		DWORD dwFlags = pEntry->dwFlags;
		if (pEntry->pChain->mapType != SOAPMAP_ENUM)
		{
			dwFlags &= ~(SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR);
		}
		else
		{
			// enum
			dwFlags |= SOAPFLAG_READYSTATE;
		}

		if (S_OK != PushState(pVal, pEntry->pChain, pEntry, dwFlags, 0, pEntry->pChain->nElements))
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT ChainEntry(
		const ParseState& state,
		const wchar_t  *wszNamespaceUri,
		int cchNamespaceUri,
	    const wchar_t  *wszLocalName,
	    int cchLocalName,
	    ISAXAttributes  *pAttributes) throw()
	{
		ATLASSERT( state.pMap != NULL );

		// PAD is only supported on the client
		const _soapmap *pMap = state.pMap;
		if ((pMap->dwCallFlags & SOAPFLAG_CHAIN)==0)
		{
			return S_FALSE;
		}
		
		ATLASSERT( pMap->dwCallFlags & SOAPFLAG_PAD );
		ATLASSERT( pMap->nElements == 1 );
		const _soapmapentry *pEntries = pMap->pEntries;
		ATLASSERT( pEntries != NULL );

//		if (m_bClient != false)
//		{
//			dwIncludeFlags = SOAPFLAG_OUT;
//			dwExcludeFlags = SOAPFLAG_IN;
//		}
//		else
//		{
//			dwIncludeFlags = SOAPFLAG_IN;
//			dwExcludeFlags = SOAPFLAG_OUT;
//		}

		int nIndex;
		if (pEntries[0].dwFlags & SOAPFLAG_OUT)
		{
			nIndex = 0;
		}
		else
		{
			nIndex = 1;
		}

		const _soapmapentry *pEntry = &pEntries[nIndex];
		ATLASSERT( pEntry->nHash != 0 );
		ATLASSERT( pEntry->pChain != NULL );

		if (S_OK != PushState(state.pvElement, pEntry->pChain, pEntry, pEntry->dwFlags, 0, pEntry->pChain->nElements))
		{
			return E_OUTOFMEMORY;
		}

		return ProcessParams(wszNamespaceUri, cchNamespaceUri, wszLocalName, cchLocalName, pAttributes);
	}

	HRESULT ProcessParams(
		const wchar_t  *wszNamespaceUri,
		int cchNamespaceUri,
	    const wchar_t  *wszLocalName,
	    int cchLocalName,
	    ISAXAttributes  *pAttributes) throw()
	{
		wszNamespaceUri;
		cchNamespaceUri;

		if (m_stateStack.IsEmpty())
		{
			// fatal internal error
			ATLASSERT( FALSE );

			return E_FAIL;
		}

		ParseState &state = GetState();

		ATLASSERT( state.pvElement != NULL );

//		const wchar_t * wszNamespace = GetNamespaceUri();
		HRESULT hr = E_FAIL;
		const _soapmapentry *pEntry = NULL;

		// if array element
		if (state.dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR))
		{
			hr = ValidateArrayEntry(state, wszLocalName, cchLocalName);
			
			if (SUCCEEDED(hr))
			{
				pEntry = state.pEntry;
			}
			else
			{
				return hr;
			}
		}
		else // not an array element
		{
			// special-case for PAD with type=
			hr = ChainEntry(state, wszNamespaceUri, cchNamespaceUri,
				wszLocalName, cchLocalName, pAttributes);

			if (hr == S_FALSE)
			{
				hr = GetElementEntry(state, wszNamespaceUri, wszLocalName, cchLocalName, pAttributes, &pEntry);
				if (hr != S_OK)
				{
					if (hr == S_FALSE)
					{
						hr = S_OK;
					}
					return hr;
				}

				ATLASSERT( pEntry != NULL );
			}
			else
			{
				return hr;
			}
		}

		if (pEntry == NULL)
		{
			if (m_dwState == SOAP_HEADERS)
			{
				return CheckMustUnderstandHeader(pAttributes);
			}
			return E_FAIL;
		}

		// if is array
		if (((pEntry->pDims != NULL) || (pEntry->dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR))) && 
			((state.dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR)) == 0))
		{
			// get SOAP section-5 info (if it is there)
			return GetSection5Info(state, pEntry, pAttributes);
		}
		else
		{
			// if it is a simple type, push a new (ready) state on the stack
			void *pVal;
			if (state.dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR))
			{
				pVal = UpdateArray(state, pEntry);
				ATLASSERT( pVal != NULL );
			}
			else
			{
				pVal = (((unsigned char *)state.pvElement)+pEntry->nOffset);
			}

			if (pEntry->nVal != SOAPTYPE_UNK)
			{
				// if it is a string
				if (pEntry->nVal == SOAPTYPE_STRING)
				{
					hr = ProcessString(pEntry, pAttributes, pVal);
				}
				else if (pEntry->nVal == SOAPTYPE_BLOB)
				{
					// if it is a BLOB, set to the CBlobHandler class
					hr = ProcessBlob(pVal);
				}
				else
				{
					// basic simple type
					if (S_OK != PushState(pVal, NULL, pEntry, SOAPFLAG_READYSTATE | pEntry->dwFlags))
					{
						hr = E_OUTOFMEMORY;
					}
				}
			}
			else
			{
				hr = ProcessUDT(pEntry, pVal, pAttributes);
			}
		}

		return hr;
	}

	size_t GetSizeIsValue(void *pvParam, const _soapmap *pMap, const _soapmapentry *pEntry) throw()
	{
		ATLASSERT( pvParam != NULL );
		ATLASSERT( pMap != NULL );
		ATLASSERT( pEntry != NULL );

		int nSizeIs = pEntry->nSizeIs;
		size_t nOffset = pMap->pEntries[nSizeIs].nOffset;
		void *pVal = ((unsigned char *)pvParam)+nOffset;

		__int64 nVal = 0;
		switch(pMap->pEntries[nSizeIs].nVal)
		{
			case SOAPTYPE_INTEGER: 
			case SOAPTYPE_NONPOSITIVEINTEGER:
			case SOAPTYPE_NEGATIVEINTEGER:
			case SOAPTYPE_LONG:
				nVal = *((__int64 *)pVal);
				break;
			case SOAPTYPE_INT:
				nVal = *((int *)pVal);
				break;
			case SOAPTYPE_SHORT:
				nVal = *((short *)pVal);
				break;
			case SOAPTYPE_BYTE:
				nVal = *((char *)pVal);
				break;
			case SOAPTYPE_NONNEGATIVEINTEGER:
			case SOAPTYPE_UNSIGNEDLONG:
				unsigned __int64 n;
				n = *((unsigned __int64 *)pVal);
				if (n > _I64_MAX)
				{
					// come on ...
					nVal = 0;
				}
				else
				{
					nVal = (__int64)n;
				}
				break;
			case SOAPTYPE_UNSIGNEDINT:
				nVal = *((unsigned int *)pVal);
				break;
			case SOAPTYPE_UNSIGNEDSHORT:
				nVal = *((unsigned short *)pVal);
				break;
			case SOAPTYPE_UNSIGNEDBYTE:
				nVal = *((unsigned char *)pVal);
				break;
			default:
				nVal = 0;
		}

		if (nVal < 0)
		{
			nVal = 0;
		}

		return (size_t) nVal;
	}

	HRESULT GenerateArrayInfo(const _soapmapentry *pEntry, const int *pDims, IWriteStream *pStream) throw()
	{
		ATLASSERT( pEntry != NULL );
		ATLASSERT( pStream != NULL );

		HRESULT hr = S_OK;
		if ((pEntry->nVal != SOAPTYPE_UNK) && (pEntry->nVal != SOAPTYPE_BLOB))
		{
			// xsd type
			hr = pStream->WriteStream(" soapenc:arrayType=\"xsd:", 
				sizeof("  soapenc:arrayType=\"xsd:")-1, NULL);
		}
		else
		{
			hr = pStream->WriteStream(" xmlns:q1=\"", sizeof(" xmlns:q1=\"")-1, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(GetNamespaceUriA(), -1, NULL);
				if (SUCCEEDED(hr))
				{
					hr = pStream->WriteStream(" soapenc:arrayType=\"q1:", 
						sizeof("  soapenc:arrayType=\"q1:")-1, NULL);
				}
			}
		}

		if (FAILED(hr))
		{
			return hr;
		}

		if (pEntry->nVal != SOAPTYPE_UNK)
		{
			hr = pStream->WriteStream(s_xsdNames[pEntry->nVal].szName , 
				s_xsdNames[pEntry->nVal].cchName, NULL);
		}
		else
		{
			ATLASSERT( pEntry->pChain != NULL );

			hr = pStream->WriteStream(pEntry->pChain->szName, pEntry->pChain->cchName, NULL);
		}

		if (FAILED(hr))
		{
			return hr;
		}

		hr = pStream->WriteStream("[", 1, NULL);
		if (FAILED(hr))
		{
			return hr;
		}

		CWriteStreamHelper s( pStream );
		for (int i=1; i<=pDims[0]; i++)
		{
			if (!s.Write(pDims[i]) || 
				((i < pDims[0]) && (S_OK != pStream->WriteStream(", ", 2, NULL))))
			{
				return E_FAIL;
			}
		}

		hr = pStream->WriteStream("]\"", 2, NULL);
		if (FAILED(hr))
		{
			return hr;
		}

		return S_OK;
	}

	HRESULT GenerateXSDWrapper(bool bStart, int nVal, IWriteStream *pStream) throw()
	{
		ATLASSERT( pStream != NULL );

		HRESULT hr = pStream->WriteStream((bStart != false) ? "<" : "</", 
			(bStart != false) ? 1 : 2, NULL);
		if (SUCCEEDED(hr))
		{
			hr = pStream->WriteStream(s_xsdNames[nVal].szName, 
				s_xsdNames[nVal].cchName, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(">", 1, NULL);
			}
		}

		return hr;
	}

	HRESULT GenerateGenericWrapper(bool bStart, const _soapmap *pMap, IWriteStream *pStream) throw()
	{
		ATLASSERT( pStream != NULL );
		ATLASSERT( pMap != NULL );

		HRESULT hr = pStream->WriteStream((bStart != false) ? "<" : "</", 
			(bStart != false) ? 1 : 2, NULL);
		if (SUCCEEDED(hr))
		{
			hr = pStream->WriteStream(pMap->szName, pMap->cchName, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(">", 1, NULL);
			}
		}

		return hr;
	}

	HRESULT GenerateHeaders(const _soapmap *pMap, IWriteStream *pStream) throw()
	{
		ATLASSERT( pStream != NULL );
		
		if (pMap == NULL)
		{
			// REVIEW: fail?
			return S_OK;
		}

		DWORD dwIncludeFlags = SOAPFLAG_OUT;
		if (m_bClient != false)
		{
			dwIncludeFlags = SOAPFLAG_IN;
		}

		// TODO: precalculate this in provider/sproxy
		size_t nCnt = 0;
		for (size_t i=0; pMap->pEntries[i].nHash != 0; i++)
		{
			if (pMap->pEntries[i].dwFlags & dwIncludeFlags)
			{
				nCnt++;
			}
		}

		// no headers to be sent
		if (nCnt == 0)
		{
			return S_OK;
		}

		HRESULT hr = pStream->WriteStream("<soap:Header ", sizeof("<soap:Header ")-1, NULL);
		if (SUCCEEDED(hr))
		{
			hr = pStream->WriteStream(" xmlns=\"", sizeof(" xmlns=\"")-1, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(GetNamespaceUriA(), -1, NULL);
				if (SUCCEEDED(hr))
				{
					hr = pStream->WriteStream("\">", 1, NULL);
					if (SUCCEEDED(hr))
					{
						hr = GenerateResponseHelper(pMap, GetHeaderValue(), pStream);
						if (SUCCEEDED(hr))
						{
							hr = pStream->WriteStream("</soap:Header>", 
								sizeof("</soap:Header>")-1, NULL);
						}
					}
				}
			}
		}

		return hr;
	}

	HRESULT GenerateResponseHelper(const _soapmap *pMap, void *pvParam, IWriteStream *pStream, 
		bool bArrayElement = false) throw()
	{
		ATLASSERT( pMap != NULL );
		ATLASSERT( pvParam != NULL );
		ATLASSERT( pStream != NULL );

		HRESULT hr = S_OK;
		if ((bArrayElement != false) && 
			((pMap->dwCallFlags & SOAPFLAG_PAD)==0))
		{
			// output type name
			hr = pStream->WriteStream("<", 1, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(pMap->szName, pMap->cchName, NULL);
				if (SUCCEEDED(hr))
				{
					if ((pMap->mapType == SOAPMAP_FUNC) && 
						(m_bClient == false) && 
						(pMap->dwCallFlags & SOAPFLAG_PID))
					{
						hr = pStream->WriteStream("Response", sizeof("Response")-1, NULL);
						if (FAILED(hr))
						{
							return hr;
						}
					}

					hr = pStream->WriteStream(" xmlns=\"", sizeof(" xmlns=\"")-1, NULL);
					if (SUCCEEDED(hr))
					{
						hr = pStream->WriteStream(GetNamespaceUriA(), -1, NULL);
						if (SUCCEEDED(hr))
						{
							hr = pStream->WriteStream("\">", sizeof("\">")-1, NULL);
						}
					}
				}

				if (FAILED(hr))
				{
					return hr;
				}
			}
		}

		ATLASSERT( pMap->pEntries != NULL );

		const _soapmapentry *pEntries = pMap->pEntries;
		size_t i;

		DWORD dwIncludeFlags;
		DWORD dwExcludeFlags;
		if (m_bClient != false)
		{
			dwIncludeFlags = SOAPFLAG_IN;
			dwExcludeFlags = SOAPFLAG_OUT;
		}
		else
		{
			dwIncludeFlags = SOAPFLAG_OUT;
			dwExcludeFlags = SOAPFLAG_IN;
		}

		for (i=0; pEntries[i].nHash != 0; i++)
		{
			if (((pEntries[i].dwFlags & dwIncludeFlags) ||
				((pEntries[i].dwFlags & dwExcludeFlags)==0)) &&
				((pEntries[i].dwFlags & SOAPFLAG_NOMARSHAL)==0))
			{
				// output name
				hr = pStream->WriteStream("<", 1, NULL);
				if (SUCCEEDED(hr))
				{
					if ((pEntries[i].dwFlags & SOAPFLAG_RETVAL)==0)
					{
						hr = pStream->WriteStream(pEntries[i].szField, pEntries[i].cchField, NULL);
					}
					else
					{
						// REVIEW: can probably remove this
						hr = pStream->WriteStream("return", sizeof("return")-1, NULL);
					}
				}
				if (FAILED(hr))
				{
					return hr;
				}
				if (pEntries[i].dwFlags & SOAPFLAG_MUSTUNDERSTAND)
				{
					// output mustUnderstand
					hr = pStream->WriteStream(" soap:mustUnderstand=\"1\"", sizeof(" soap:mustUnderstand=\"1\"")-1, NULL);
					if (FAILED(hr))
					{
						return hr;
					}
				}
				if (pEntries[i].dwFlags & SOAPFLAG_PAD)
				{
					// output mustUnderstand
					hr = pStream->WriteStream(" xmlns=\"", sizeof(" xmlns=\"")-1, NULL);
					if (SUCCEEDED(hr))
					{
						hr = pStream->WriteStream(GetNamespaceUriA(), -1, NULL);
						if (SUCCEEDED(hr))
						{
							hr = pStream->WriteStream("\"", sizeof("\"")-1, NULL);
						}
					}
					if (FAILED(hr))
					{
						return hr;
					}
				}
				
				size_t nElementSize = 0;
				size_t nCnt = 1;

				const int *pDims = NULL;
				int arrDims[2] = { 0 };

				bool bArray = (pEntries[i].dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR)) != 0;

				if (bArray != false)
				{
					if (pEntries[i].dwFlags & SOAPFLAG_FIXEDARR)
					{
						pDims = pEntries[i].pDims;
					}
					else
					{
						ATLASSERT( pEntries[i].dwFlags & SOAPFLAG_DYNARR );

//						unsigned char **ppArr = (unsigned char **)GetState().pvElement;
//						// REVIEW: check for null here?
//						pVal = *ppArr;
						nCnt = GetSizeIsValue(pvParam, pMap, &pEntries[i]);

						if (nCnt == 0)
						{
							// REVIEW: should we fail here, or do something else?
							return E_FAIL;
						}

						arrDims[0] = 1;
						arrDims[1] = (int) nCnt;

						pDims = arrDims;
					}

					// output array information
					hr = GenerateArrayInfo(&pEntries[i], pDims, pStream);
					if (FAILED(hr))
					{
						return hr;
					}

					nCnt = AtlSoapGetArrayDims(pDims);

					ATLASSERT( nCnt != 0 );

					if (pEntries[i].nVal != SOAPTYPE_UNK)
					{
						nElementSize = AtlSoapGetElementSize((SOAPTYPES) pEntries[i].nVal);
					}
					else
					{
						ATLASSERT( pEntries[i].pChain != NULL );

						nElementSize = pEntries[i].pChain->nElementSize;
					}					
				}

				hr = pStream->WriteStream(">", 1, NULL);
				if (FAILED(hr))
				{
					return hr;
				}

				void *pvCurrent = ((unsigned char *)pvParam)+pEntries[i].nOffset;

				for (size_t nElement=0; nElement<nCnt; nElement++)
				{
					void *pVal;

					// get updated value
					if (bArray != false)
					{
						if (pEntries[i].dwFlags & SOAPFLAG_FIXEDARR)
						{
							unsigned char *ppArr = (unsigned char *)pvCurrent;
							pVal = ppArr+(nElement*nElementSize);
						}
						else
						{
							ATLASSERT( pEntries[i].dwFlags & SOAPFLAG_DYNARR );

							unsigned char **ppArr = (unsigned char **)pvCurrent;
							pVal = (*ppArr)+(nElement*nElementSize);
						}
					}
					else
					{
						pVal = pvCurrent;
					}

					if (pEntries[i].nVal != SOAPTYPE_UNK)
					{
						if (bArray != false)
						{
							hr = GenerateXSDWrapper(true, pEntries[i].nVal, pStream);
							if (FAILED(hr))
							{
								return hr;
							}
						}
						// TODO: generate xsi:null where appropriate
						hr = AtlSoapGenElementValue(pVal, pStream, (SOAPTYPES) pEntries[i].nVal);
						if ((SUCCEEDED(hr)) && (bArray != false))
						{
							hr = GenerateXSDWrapper(false, pEntries[i].nVal, pStream);
						}

						if (FAILED(hr))
						{
							return hr;
						}
					}
					else
					{
						ATLASSERT( pEntries[i].pChain != NULL );

						if (pEntries[i].pChain->mapType != SOAPMAP_ENUM)
						{
							// struct
							hr = GenerateResponseHelper(pEntries[i].pChain, pVal, pStream, bArray);
						}
						else
						{
							if (bArray != false)
							{
								hr = GenerateGenericWrapper(true, pEntries[i].pChain, pStream);
								if (FAILED(hr))
								{
									return hr;
								}
							}

							// enum
							int nVal = *((int *)pVal);
							const _soapmapentry *pEnumEntries = pEntries[i].pChain->pEntries;
							
							ATLASSERT( pEnumEntries != NULL );
							size_t j;
							for (j=0; pEnumEntries[j].nHash != 0; j++)
							{
								if (nVal == pEnumEntries[j].nVal)
								{
									hr = pStream->WriteStream(pEnumEntries[j].szField, pEnumEntries[j].cchField, NULL);
									if ((bArray != false) && (SUCCEEDED(hr)))
									{
										hr = GenerateGenericWrapper(false, pEntries[i].pChain, pStream);
									}
									break;
								}
							}
							if (pEnumEntries[j].nHash == 0)
							{
								hr = E_FAIL;
							}
						}
					}
				}

				// output element close
				if (SUCCEEDED(hr))
				{
					hr = pStream->WriteStream("</", 2, NULL);
					if (SUCCEEDED(hr))
					{
						if ((pEntries[i].dwFlags & SOAPFLAG_RETVAL)==0)
						{
							hr = pStream->WriteStream(pEntries[i].szField, pEntries[i].cchField, NULL);
						}
						else
						{
							// REVIEW: can probably remove this
							hr = pStream->WriteStream("return", sizeof("return")-1, NULL);
						}
						if (SUCCEEDED(hr))
						{
							hr = pStream->WriteStream(">", 1, NULL);
						}
					}
				}
			}

			if (FAILED(hr))
			{
				return hr;
			}
		}

		if ((bArrayElement != false) && 
			((pMap->dwCallFlags & SOAPFLAG_PAD)==0))
		{
			// output type name
			hr = pStream->WriteStream("</", 2, NULL);
			if (SUCCEEDED(hr))
			{
				hr = pStream->WriteStream(pMap->szName, pMap->cchName, NULL);
				if (SUCCEEDED(hr))
				{
					if ((pMap->mapType == SOAPMAP_FUNC) && 
						(m_bClient == false) && 
						(pMap->dwCallFlags & SOAPFLAG_PID))
					{
						hr = pStream->WriteStream("Response", sizeof("Response")-1, NULL);
						if (FAILED(hr))
						{
							return hr;
						}
					}
					hr = pStream->WriteStream(">", 1, NULL);
				}

				if (FAILED(hr))
				{
					return hr;
				}
			}
		}

		return S_OK;
	}

	void CleanupHelper(const _soapmap *pMap, void *pvParam) throw()
	{
		ATLASSERT( pMap != NULL );
		ATLASSERT( pvParam != NULL );

		ATLASSERT( pMap->pEntries != NULL );

		const _soapmapentry *pEntries = pMap->pEntries;
		size_t i;

		for (i=0; pEntries[i].nHash != 0; i++)
		{	
			if ((m_bClient != false) && (pEntries[i].dwFlags & SOAPFLAG_IN))
			{
				continue;
			}

			size_t nElementSize = 0;
			size_t nCnt = 1;

			const int *pDims = NULL;
			int arrDims[2] = { 0 };

			bool bArray = (pEntries[i].dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR)) != 0;

			if (bArray != false)
			{
				if (pEntries[i].dwFlags & SOAPFLAG_FIXEDARR)
				{
					pDims = pEntries[i].pDims;
				}
				else
				{
					ATLASSERT( pEntries[i].dwFlags & SOAPFLAG_DYNARR );

//					unsigned char **ppArr = (unsigned char **)GetState().pvElement;
//					// REVIEW: check for null here?
//					pVal = *ppArr;
					nCnt = GetSizeIsValue(pvParam, pMap, &pEntries[i]);

//					if (nCnt == 0)
//					{
//						// REVIEW: should we fail here, or do something else?
//						return;
//					}

					arrDims[0] = 1;
					arrDims[1] = (int) nCnt;

					pDims = arrDims;
				}

				nCnt = AtlSoapGetArrayDims(pDims);

				ATLASSERT( nCnt != 0 );

				if (pEntries[i].nVal != SOAPTYPE_UNK)
				{
					nElementSize = AtlSoapGetElementSize((SOAPTYPES) pEntries[i].nVal);
				}
				else
				{
					ATLASSERT( pEntries[i].pChain != NULL );

					nElementSize = pEntries[i].pChain->nElementSize;
				}					
			}

			void *pvCurrent = ((unsigned char *)pvParam)+pEntries[i].nOffset;

			for (size_t nElement=0; nElement<nCnt; nElement++)
			{
				void *pVal;

				// get updated value
				if (bArray != false)
				{
					if (pEntries[i].dwFlags & SOAPFLAG_FIXEDARR)
					{
						unsigned char *ppArr = (unsigned char *)pvCurrent;
						pVal = ppArr+(nElement*nElementSize);
					}
					else
					{
						ATLASSERT( pEntries[i].dwFlags & SOAPFLAG_DYNARR );

						unsigned char **ppArr = (unsigned char **)pvCurrent;
						pVal = (*ppArr)+(nElement*nElementSize);
					}
				}
				else
				{
					pVal = pvCurrent;
				}

				if (pEntries[i].nVal != SOAPTYPE_UNK)
				{
					AtlSoapCleanupElement(pVal, (SOAPTYPES) pEntries[i].nVal);
				}
				else
				{
					ATLASSERT( pEntries[i].pChain != NULL );

					if (pEntries[i].pChain->mapType != SOAPMAP_ENUM)
					{
						CleanupHelper(pEntries[i].pChain, pVal);
					}
				}
			}

			if (pEntries[i].dwFlags & SOAPFLAG_DYNARR)
			{
				// free it
				unsigned char **ppArr = (unsigned char **)pvCurrent;
				
				ATLASSERT( ppArr != NULL );

				if (*ppArr != NULL)
				{
					m_pMemMgr->Free(*ppArr);
				}
			}
		}
	}

	const _soapmap * GetSoapMapFromName(
		const wchar_t * wszName, 
		int cchName = -1, 
		const wchar_t * wszNamespaceUri = NULL,
		int cchNamespaceUri = -1,
		int *pnVal = NULL,
		bool bHeader = false) throw()
	{
		cchNamespaceUri;

		const _soapmap ** pEntry = NULL;

		if (bHeader == false)
		{
			pEntry = GetFunctionMap();
		}
		else
		{
			pEntry = GetHeaderMap();
		}

		if (pEntry == NULL)
		{
			return NULL;
		}

		if (cchName < 0)
		{
			cchName = (int)wcslen(wszName);
		}

		ULONG nFunctionHash = AtlSoapHashStr(wszName, cchName);

		int i;
		for (i=0; pEntry[i] != NULL; i++)
		{
			if (nFunctionHash == pEntry[i]->nHash && 
				cchName == pEntry[i]->cchWName &&
				!wcsncmp(wszName, pEntry[i]->wszName, 
					cchName) && 
				!wcscmp(GetNamespaceUri(), wszNamespaceUri))
			{
				break;
			}
		}

		if (pnVal != NULL)
		{
			*pnVal = i;
		}
		return pEntry[i];
	}

protected:

	virtual const _soapmap ** GetFunctionMap() = 0;
	virtual const _soapmap ** GetHeaderMap() = 0;
	virtual const wchar_t * GetNamespaceUri() = 0;
	virtual const char * GetServiceName() = 0;
	virtual const char * GetNamespaceUriA() = 0;
	virtual HRESULT CallFunction(
		void *pvParam, 
		const wchar_t *wszLocalName, int cchLocalName,
		size_t nItem) = 0;
	virtual void * GetHeaderValue() = 0;

	ISAXXMLReader * SetReader(ISAXXMLReader *pReader) throw()
	{
		ISAXXMLReader *pPrevRdr = m_spReader;
		m_spReader = pReader;

		return pPrevRdr;
	}

	ISAXXMLReader * GetReader() throw()
	{
		return m_spReader;
	}

	HRESULT SetSoapMapFromName(
		const wchar_t * wszName, 
		int cchName = -1, 
		const wchar_t * wszNamespaceUri = NULL,
		int cchNamespaceUri = -1,
		bool bHeader = false) throw()
	{
		cchNamespaceUri;

		int nVal;
		const _soapmap *pMap = NULL;
		if (m_stateStack.GetCount() == 1)
		{
			ATLASSERT( GetState().pMap != NULL );
			nVal = (int) GetState().nAllocSize;
			ATLASSERT( GetFunctionMap() != NULL );
			pMap = GetFunctionMap()[nVal];
		}
		else
		{
			pMap = GetSoapMapFromName(wszName, cchName,
				wszNamespaceUri, cchNamespaceUri, &nVal, bHeader);
		}

		if (pMap == NULL)
		{
			return E_FAIL;
		}

		HRESULT hr = E_OUTOFMEMORY;

		// allocate the parameter struct

		void *pvParam = NULL;
		if (bHeader != false)
		{
			pvParam = GetHeaderValue();
		}
		else 
		{
			if (m_bClient == false)
			{
				m_pvParam = m_pMemMgr->Allocate(pMap->nElementSize);
			}
			pvParam = m_pvParam;
		}

		if (pvParam != NULL)
		{
			if (bHeader == false)
			{
				memset(pvParam, 0x00, pMap->nElementSize);
			}

			// push initial state

			if (m_stateStack.GetCount() != 0)
			{
				m_stateStack.RemoveAll();
			}

			hr = PushState(pvParam, pMap, NULL, 0, nVal, pMap->nElements);
			
			if (FAILED(hr))
			{
				if ((m_bClient == false) && (bHeader == false))
				{
					m_pMemMgr->Free(pvParam);
				}
			}
		}

		return hr;
	}

public:

	CSoapRootHandler(ISAXXMLReader *pReader = NULL) throw()
		: m_dwState(SOAP_START), m_nState(0), m_bErrorsOccurred(false), 
		m_pMemMgr(&m_crtHeap), m_spReader(pReader), m_bClient(false),
		m_pvParam(NULL)
	{
	}

	~CSoapRootHandler() throw()
	{
//		ATLASSERT( m_stateStack.IsEmpty() == true );
	}

	IAtlMemMgr * SetMemMgr(IAtlMemMgr *pMemMgr) throw()
	{
		IAtlMemMgr *pPrevMgr = m_pMemMgr;
		m_pMemMgr = pMemMgr;

		return pPrevMgr;
	}
	
	IAtlMemMgr * GetMemMgr() throw()
	{
		return m_pMemMgr;
	}

	//
	// implementation
	//

	HRESULT __stdcall startElement( 
	     const wchar_t  *wszNamespaceUri,
	     int cchNamespaceUri,
	     const wchar_t  *wszLocalName,
	     int cchLocalName,
	     const wchar_t  * wszQName,
	     int cchQName,
	     ISAXAttributes  *pAttributes) throw()
	{
		HRESULT hr = S_OK;
		switch (m_dwState)
		{
			case SOAP_PARAMS: case SOAP_HEADERS:
			{
				hr = ProcessParams(wszNamespaceUri, cchNamespaceUri, wszLocalName, 
					cchLocalName, pAttributes);

				break;
			}
			case SOAP_START: case SOAP_ENVELOPE: case SOAP_HEADERS_DONE:
			{
				ULONG nNamespaceHash = AtlSoapHashStr(wszNamespaceUri, 
					cchNamespaceUri);
				if (nNamespaceHash != SOAP_ENV)
				{
					return E_FAIL;
				}

				ULONG nElementHash = AtlSoapHashStr(wszLocalName, cchLocalName);

				if (nElementHash == ENVELOPE && 
					IsEqualElement(
						sizeof(SOAP_ENVELOPEA)-1, SOAP_ENVELOPEW,
						sizeof(SOAPENV_NAMESPACEA)-1, SOAPENV_NAMESPACEW,
						cchLocalName, wszLocalName,
						cchNamespaceUri, wszNamespaceUri))
				{
					// Envelope must be first element in package

					if (m_dwState != SOAP_START)
					{
						hr = E_FAIL;
					}
					m_dwState = SOAP_ENVELOPE;
				}
				else if (nElementHash == HEADER &&
					IsEqualElement(sizeof(SOAP_HEADERA)-1, SOAP_HEADERW,
						sizeof(SOAPENV_NAMESPACEA)-1, SOAPENV_NAMESPACEW,
						cchLocalName, wszLocalName,
						cchNamespaceUri, wszNamespaceUri))
				{
					// header map should have alredy been set
					if ((m_stateStack.GetCount() == 0) ||
						(m_dwState != SOAP_ENVELOPE))
					{
						hr = E_FAIL;
					}

					m_dwState = SOAP_HEADERS;
				}
				else if (nElementHash == BODY &&
					IsEqualElement(sizeof(SOAP_BODYA)-1, SOAP_BODYW,
						sizeof(SOAPENV_NAMESPACEA)-1, SOAPENV_NAMESPACEW,
						cchLocalName, wszLocalName,
						cchNamespaceUri, wszNamespaceUri))
				{
					// TODO: REVIEW: NOTE: depending on flags (RPC/PAD/PID), might
					// set to SOAP_PARAMS right here
					if (m_dwState == SOAP_START)
					{
						hr = E_FAIL;
					}
					m_dwState = SOAP_BODY;
				}

				break;
			}
			case SOAP_BODY:
			{
				hr = DispatchSoapCall(wszNamespaceUri, cchNamespaceUri,
						wszLocalName, cchLocalName);

				m_dwState = SOAP_PARAMS;

				if (SUCCEEDED(hr))
				{
					if (GetState().pMap->dwCallFlags & SOAPFLAG_PAD)
					{
						hr = startElement(wszNamespaceUri, cchNamespaceUri,
								wszLocalName, cchLocalName, wszQName, cchQName,
								pAttributes);
					}
				}
				
				break;
			}
			default:
			{
				__assume( 0 );
			}
		}

		return hr;
	}

	HRESULT __stdcall characters( 
	     const wchar_t  *wszChars,
	     int cchChars) throw()
	{
		// if it is a ready state, get the value
		if (m_stateStack.IsEmpty() == false)
		{
			ParseState& state = GetState();
			if (state.dwFlags & SOAPFLAG_READYSTATE)
			{
				if ((state.pMap == NULL) || (state.pMap->mapType != SOAPMAP_ENUM))
				{
					return AtlSoapGetElementValue(wszChars, cchChars, 
						state.pvElement, (SOAPTYPES)state.pEntry->nVal);
				}
				else
				{
					// enum

					ATLASSERT( state.pMap != NULL );
					ATLASSERT( state.pMap->pEntries != NULL );

					ULONG nHash = AtlSoapHashStr(wszChars, cchChars);
					const _soapmapentry *pEntries = state.pMap->pEntries;

					size_t i;
					for (i=0; pEntries[i].nHash != 0; i++)
					{
						if ((nHash == pEntries[i].nHash) &&
							(cchChars == pEntries[i].cchField) &&
							(!wcsncmp(wszChars, pEntries[i].wszField, cchChars)))
						{
							break;
						}
					}

					if (pEntries[i].nHash != 0)
					{
						*((int *)state.pvElement) = pEntries[i].nVal;
						state.nElement++;
						return S_OK;
					}

					// no matching enum entry found
					return E_FAIL;
				}
			}
		}
		
		// otherwise, ignore

		return S_OK;
	}

	HRESULT __stdcall endElement( 
	     const wchar_t  * wszNamespaceUri,
	     int cchNamespaceUri,
	     const wchar_t  * wszLocalName,
	     int cchLocalName,
	     const wchar_t  * /*wszQName*/,
	     int /*cchQName*/) throw()
	{
		// pop if appropriate

		if (m_stateStack.IsEmpty() != false)
		{
			return S_OK;
		}

		const ParseState& state = GetState();

		if ((m_dwState == SOAP_HEADERS) && (m_stateStack.GetCount() == 1))
		{
			if (IsEqualElement(sizeof(SOAP_HEADERA)-1, SOAP_HEADERW,
					sizeof(SOAPENV_NAMESPACEA)-1, SOAPENV_NAMESPACEW,
					cchLocalName, wszLocalName,
					cchNamespaceUri, wszNamespaceUri))
			{
				m_dwState = SOAP_HEADERS_DONE;
				if (m_bClient != false)
				{
					// set the param entry
					size_t nEntry = state.nAllocSize;
					const _soapmap ** pEntries = GetFunctionMap();
					ATLASSERT( pEntries != NULL );
					PopState();
					return PushState(m_pvParam, pEntries[nEntry], NULL, 0, nEntry, pEntries[nEntry]->nElements);
				}
				return S_OK;
			}

			// some sort of error
			return E_FAIL;
		}

		if (state.dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR))
		{
			if (state.dwFlags & SOAPFLAG_READYSTATE)
			{
				PopState();
			}

			const ParseState& currstate = GetState();
			ATLASSERT( currstate.pEntry != NULL );

			if (currstate.pEntry->cchField == cchLocalName &&
				!wcsncmp(currstate.pEntry->wszField, wszLocalName, cchLocalName))
			{
				if (currstate.nExpectedElements != currstate.nElement)
				{
					// invalid number of elements
					return E_FAIL;
				}

				PopState();
			}
		}
		else
		{
			if (state.pMap != NULL)
			{
				if (state.nExpectedElements != state.nElement)
				{
					return E_FAIL;
				}
			}	
			PopState();
		}

		return S_OK;
	}

	HRESULT SetClientStruct(void *pvParam, int nMapIndex /*const _soapmap *pMap*/) throw()
	{
		ATLASSERT( pvParam != NULL );
		ATLASSERT( nMapIndex >= 0 );

		// this is the params struct
		// store for later use
		m_pvParam = pvParam;

		const _soapmap ** pEntries = GetHeaderMap();
		ATLASSERT( pEntries != NULL );

		// push header value
		return PushState(GetHeaderValue(), pEntries[nMapIndex], NULL, 0, nMapIndex, pEntries[nMapIndex]->nElements);
	}

	void ResetClientState(bool bFull = false) throw()
	{
		m_stateStack.RemoveAll();
		m_nState = 0;
		if (bFull != false)
		{
			m_dwState = SOAP_START;
			m_pvParam = NULL;
		}
	}

	HRESULT CreateReader() throw()
	{
		return m_spReader.CoCreateInstance(CLSID_SAXXMLReader30);
	}

	HRESULT InitializeSOAP(IServiceProvider *pProvider) throw()
	{
		HRESULT hr = S_OK;
		
		if (m_spReader.p == NULL)
		{
			hr = E_FAIL;
			if (pProvider != NULL)
			{
				IAtlMemMgr *pMemMgr = NULL;
				hr = pProvider->QueryService(__uuidof(IAtlMemMgr), 
					__uuidof(IAtlMemMgr), (void **)&pMemMgr);
				if ((SUCCEEDED(hr)) && (pMemMgr != NULL))
				{
					SetMemMgr(pMemMgr);
				}
	
				hr = pProvider->QueryService(__uuidof(ISAXXMLReader), 
					__uuidof(ISAXXMLReader), (void **)&m_spReader);
			}
	
			if (FAILED(hr))
			{
				hr = CreateReader();
			}
		}
		
		if (SUCCEEDED(hr))
		{
			hr = m_spReader->putContentHandler(this);
		}

		return hr;
	}

	void UninitializeSOAP() throw()
	{
		if (m_spReader.p != NULL)
		{
			m_spReader->putContentHandler(NULL);
			m_spReader.Release();
		}
	}

	virtual HRESULT DispatchSoapCall(const wchar_t *wszNamespaceUri,
		int cchNamespaceUri, const wchar_t *wszLocalName,
		int cchLocalName) throw()
	{
		return SetSoapMapFromName(wszLocalName, cchLocalName, 
			wszNamespaceUri, cchNamespaceUri);
	}

	virtual HRESULT BeginParse(IStream *pStream) throw()
	{
		ATLASSERT( pStream != NULL );

		CComVariant varStream;
		varStream = static_cast<IUnknown*>(pStream);

		return m_spReader->parse(varStream);
	}

	HRESULT CallFunctionInternal() throw()
	{
		HRESULT hr = E_FAIL;
		_ATLTRY
		{
			const ParseState& state = m_stateStack[0];
			hr = CallFunction(
				state.pvElement, 
				state.pMap->wszName,
				state.pMap->cchWName,
				state.nAllocSize);
		}
		_ATLCATCHALL()
		{
			hr = E_FAIL;
		}

		return hr;
	}

	virtual HRESULT GenerateResponse(IWriteStream *pStream) throw()
	{
		ATLASSERT( m_stateStack.IsEmpty() == false );
		ATLASSERT( m_nState == 0 );
		ATLASSERT( GetState().pMap != NULL );
		ATLASSERT( GetState().pvElement != NULL );

		const ParseState& state = GetState();

		
		const _soapmap *pHeaderMap = NULL;
		if (m_bClient == false)
		{
			const _soapmap **ppHeaderMap = GetHeaderMap();
			if (ppHeaderMap != NULL)
			{
				pHeaderMap = ppHeaderMap[state.nAllocSize];
			}
		}
		else
		{
			pHeaderMap = state.pMap;
		}

		const _soapmap *pFuncMap = NULL;
		if (m_bClient == false)
		{
			pFuncMap = state.pMap;
		}
		else
		{
			const _soapmap **ppFuncMap = GetFunctionMap();
			ATLASSERT( ppFuncMap != NULL );
			pFuncMap = ppFuncMap[state.nAllocSize];
		}

		HRESULT hr = pStream->WriteStream("<soap:Envelope "
			"xmlns:soap=\"" SOAPENV_NAMESPACEA "\" "
			"xmlns:xsi=\"" XSI_NAMESPACEA "\" "
			"xmlns:xsd=\"" XSD_NAMESPACEA "\"",
			sizeof("<soap:Envelope "
				"xmlns:soap=\"" SOAPENV_NAMESPACEA "\" "
				"xmlns:xsi=\"" XSI_NAMESPACEA "\" "
				"xmlns:xsd=\"" XSD_NAMESPACEA "\"")-1,
			NULL);

		if ((pFuncMap->dwCallFlags & SOAPFLAG_RPC) && (SUCCEEDED(hr)))
		{
			ATLASSERT( pFuncMap->dwCallFlags & SOAPFLAG_ENCODED );
			hr = pStream->WriteStream(" xmlns:soapenc=\"" SOAPENC_NAMESPACEA "\"", 
				sizeof(" xmlns:soapenc=\"" SOAPENC_NAMESPACEA "\"")-1, NULL);
		}

		if (SUCCEEDED(hr))
		{
			hr = pStream->WriteStream(">", 1, NULL);

			if (SUCCEEDED(hr))
			{
				// generate headers if necessary
				hr = GenerateHeaders(pHeaderMap, pStream);

				if (SUCCEEDED(hr))
				{
					hr = pStream->WriteStream("<soap:Body", sizeof("<soap:Body")-1, NULL);
					if ((pFuncMap->dwCallFlags & SOAPFLAG_RPC) && (SUCCEEDED(hr)))
					{
						hr = pStream->WriteStream(" soap:encodingStyle=\"" SOAPENC_NAMESPACEA "\"", 
							sizeof(" soap:encodingStyle=\"" SOAPENC_NAMESPACEA "\"")-1, NULL);
					}
					if (SUCCEEDED(hr))
					{
						hr = pStream->WriteStream(">", 1, NULL);
						if (SUCCEEDED(hr))
						{
							hr = GenerateResponseHelper(pFuncMap, m_pvParam, pStream, true);
							if (SUCCEEDED(hr))
							{
								hr = pStream->WriteStream("</soap:Body></soap:Envelope>", 
									sizeof("</soap:Body></soap:Envelope>")-1, NULL);
							}
						}
					}
				}
			}
		}

		return hr;
	}

	virtual void Cleanup() throw()
	{
		if (m_stateStack.IsEmpty() == false)
		{
			CleanupHelper(GetState().pMap, GetState().pvElement);
			if ((m_pvParam != NULL) && (m_bClient == false))
			{
				m_pMemMgr->Free(m_pvParam);
			}
			m_stateStack.RemoveAll();
		}
	}

	void SetClient(bool bClient) throw()
	{
		m_bClient = bClient;
	}

}; // class CSoapRootHandler

#define DECLARE_XSD_ENTRY( __name ) \
	{ L ## __name, __name, sizeof(__name)-1 },

__declspec(selectany) const CSoapRootHandler::XSDEntry CSoapRootHandler::s_xsdNames[] =
{
	DECLARE_XSD_ENTRY("string")
	DECLARE_XSD_ENTRY("boolean")
	DECLARE_XSD_ENTRY("float")
	DECLARE_XSD_ENTRY("double")
	DECLARE_XSD_ENTRY("decimal")
	DECLARE_XSD_ENTRY("timeDuration")
	DECLARE_XSD_ENTRY("recurringDuration")
	DECLARE_XSD_ENTRY("binary")
	DECLARE_XSD_ENTRY("URIReference")
	DECLARE_XSD_ENTRY("ID")
	DECLARE_XSD_ENTRY("IDREF")
	DECLARE_XSD_ENTRY("ENTITY")
	DECLARE_XSD_ENTRY("NOTATION")
	DECLARE_XSD_ENTRY("QName")
	DECLARE_XSD_ENTRY("CDATA")
	DECLARE_XSD_ENTRY("token")
	DECLARE_XSD_ENTRY("language")
	DECLARE_XSD_ENTRY("IDREFS")
	DECLARE_XSD_ENTRY("ENTITIES")
	DECLARE_XSD_ENTRY("NMTOKEN")
	DECLARE_XSD_ENTRY("NMTOKENS")
	DECLARE_XSD_ENTRY("Name")
	DECLARE_XSD_ENTRY("NCName")
	DECLARE_XSD_ENTRY("integer")
	DECLARE_XSD_ENTRY("nonPositiveInteger")
	DECLARE_XSD_ENTRY("negativeInteger")
	DECLARE_XSD_ENTRY("long")
	DECLARE_XSD_ENTRY("int")
	DECLARE_XSD_ENTRY("short")
	DECLARE_XSD_ENTRY("byte")
	DECLARE_XSD_ENTRY("nonNegativeInteger")
	DECLARE_XSD_ENTRY("unsignedLong")
	DECLARE_XSD_ENTRY("unsignedInt")
	DECLARE_XSD_ENTRY("unsignedShort")
	DECLARE_XSD_ENTRY("unsignedByte")
	DECLARE_XSD_ENTRY("positiveInteger")
	DECLARE_XSD_ENTRY("timeInstant")
	DECLARE_XSD_ENTRY("time")
	DECLARE_XSD_ENTRY("timePeriod")
	DECLARE_XSD_ENTRY("date")
	DECLARE_XSD_ENTRY("month")
	DECLARE_XSD_ENTRY("year")
	DECLARE_XSD_ENTRY("century")
	DECLARE_XSD_ENTRY("recurringDate")
	DECLARE_XSD_ENTRY("recurringDay")
	DECLARE_XSD_ENTRY("ATLSOAP_BLOB")
};

__declspec(selectany) CCRTHeap CSoapRootHandler::m_crtHeap;

template <typename THandler>
class CSoapHandler : 
	public CSoapRootHandler, 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IRequestHandlerImpl<THandler>
{
private:

	HTTP_CODE m_hcErr;

public:

	void SetHttpError(HTTP_CODE hcErr) throw()
	{
		m_hcErr = hcErr;
	}

	HTTP_CODE SoapFault(CHttpResponse &HttpResponse, SOAP_ERROR_CODE errCode) throw()
	{
		HttpResponse.ClearHeaders();
		HttpResponse.ClearContent();
		HttpResponse.SetContentType("text/xml");
		HttpResponse.SetStatusCode(500);
		CSoapFault fault;
		fault.m_soapErrCode = errCode;
		fault.GenerateFault(&HttpResponse);
		return HTTP_ERROR(500, SUBERR_NO_PROCESS);
	}

	BEGIN_COM_MAP(CSoapHandler<THandler>)
		COM_INTERFACE_ENTRY(ISAXContentHandler)
		COM_INTERFACE_ENTRY(IRequestHandler)
	END_COM_MAP()

	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider) throw()
	{
		m_hcErr = HTTP_SUCCESS;
		m_spServiceProvider = pProvider;

		CHttpResponse HttpResponse(pRequestInfo->pServerContext);
		HRESULT hr = InitializeSOAP(m_spServiceProvider);
		if (FAILED(hr))
		{
			return SoapFault(HttpResponse, SOAP_E_SERVER);
		}

		// set the header map

		// REVIEW: technically not compliant here: we will allow omission of the 
		//         SOAPAction header and attempt to continue processing.
		//         We will fail iff the client attempts to send headers without
		//         sending the SOAPAction header

		char szBuf[ATL_URL_MAX_URL_LENGTH+1];
		szBuf[0] = '\0';
		DWORD dwLen = ATL_URL_MAX_URL_LENGTH;
		if (m_spServerContext->GetServerVariable("HTTP_SOAPACTION", szBuf, &dwLen) != FALSE)
		{
			// drop the last "
			szBuf[dwLen-2] = '\0';
			char *szMethod = strrchr(szBuf, '#');
			if (szMethod != NULL)
			{
				_ATLTRY
				{
					// ignore return code here (REVIEW above)
					SetSoapMapFromName(CA2W( szMethod+1 ), -1, GetNamespaceUri(), -1, true);
				}
				_ATLCATCHALL()
				{
					return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
				}
			}
		}

		CStreamOnServerContext s(pRequestInfo->pServerContext);

		// REVIEW: add these in under #ifdef _DEBUG ?
//		CSAXSoapErrorHandler err;
//		GetReader()->putErrorHandler(&err);

		hr = BeginParse(&s);
		if (FAILED(hr))
		{
			return SoapFault(HttpResponse, SOAP_E_CLIENT);
		}

		hr = CallFunctionInternal();
		if (FAILED(hr))
		{
			Cleanup();
			HttpResponse.ClearHeaders();
			HttpResponse.ClearContent();
			if (m_hcErr != HTTP_SUCCESS)
			{
				HttpResponse.SetStatusCode(HTTP_ERROR_CODE(m_hcErr));
				return HTTP_SUCCESS_NO_PROCESS;
			}
			HttpResponse.SetStatusCode(500);
			GenerateAppError(&HttpResponse, hr);
			return HTTP_ERROR(500, SUBERR_NO_PROCESS);
		}

		HttpResponse.SetContentType("text/xml");
		hr = GenerateResponse(&HttpResponse);
		Cleanup();
		if (FAILED(hr))
		{
			return SoapFault(HttpResponse, SOAP_E_SERVER);
		}

		return HTTP_SUCCESS;
	}

	virtual ATL_NOINLINE HRESULT GenerateAppError(IWriteStream *pStream, HRESULT hr) throw()
	{
		if (pStream == NULL)
		{
			return E_INVALIDARG;
		}

		LPWSTR pwszMessage = NULL;
		DWORD dwLen = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, hr, 0, (LPWSTR) &pwszMessage, 0, NULL);
		
		if (dwLen == 0)
		{
			pwszMessage = L"Application Error";
		}

		_ATLTRY
		{
			CSoapFault fault;
			fault.m_soapErrCode = SOAP_E_SERVER;
			fault.m_strDetail = (L"<detail xmlns:e=\"" ATLSOAP_GENERIC_NAMESPACE L"\"\n"
	            L"xmlns:xsd=\"" XSD_NAMESPACEW L"\"\n"
				L"xsd:type=\"e:ApplicationFault\">"
				L"<message>");
			fault.m_strDetail += pwszMessage;
			fault.m_strDetail.AppendFormat(L"</message>\n<errorcode>0x%08X</errorcode>\n</detail>\n", hr);
			hr = fault.GenerateFault(pStream);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		if (dwLen != 0)
		{
			::LocalFree(pwszMessage);
		}

		return hr;
	}

	void UninitializeHandler() throw()
	{
		UninitializeSOAP();
	}
};

template <typename TSocketClass = ZEvtSyncSocket>
class CSoapSocketClientT
{
private:

	CUrl m_url;
	CWriteStreamOnCString m_writeStream;
	CReadStreamOnSocket<TSocketClass> m_readStream;
	DWORD m_dwTimeout;

protected:

	virtual HRESULT GetClientReader(ISAXXMLReader **pReader) throw()
	{
		if (pReader == NULL)
		{
			return E_POINTER;
		}
		*pReader = NULL;

		CComPtr<ISAXXMLReader> spReader;
		HRESULT hr = spReader.CoCreateInstance(__uuidof(SAXXMLReader30));
		if (SUCCEEDED(hr))
		{
			*pReader = spReader.Detach();
		}
		return hr;
	}

public:

	// note : not shared across stock client implementations
	CAtlHttpClientT<TSocketClass> m_socket;

	CSoapFault m_fault;

	// constructor
	CSoapSocketClientT(LPCTSTR szUrl) throw()
		: m_dwTimeout(0)
	{
		m_url.CrackUrl(szUrl);
	}

	CSoapSocketClientT(LPCTSTR szServer, LPCTSTR szUri, ATL_URL_PORT nPort=80) throw()
	{
		ATLASSERT( szServer != NULL );
		ATLASSERT( szUri != NULL );

		m_url.SetUrlPath(szUri);
		m_url.SetHostName(szServer);
		m_url.SetPortNumber(nPort);
	}

	~CSoapSocketClientT() throw()
	{
		CleanupClient();
	}

	IWriteStream * GetWriteStream() throw()
	{
		return &m_writeStream;
	}

	HRESULT GetReadStream(IStream **ppStream) throw()
	{
		if (ppStream == NULL)
		{
			return E_POINTER;
		}

		*ppStream = &m_readStream;
		return S_OK;
	}

	void CleanupClient() throw()
	{
		m_writeStream.Cleanup();
	}

	HRESULT SendRequest(LPCTSTR szAction) throw()
	{
		HRESULT hr = E_FAIL;
		_ATLTRY
		{
			m_fault.Clear();
			// create extra headers to send with request
			CString strExtraHeaders(szAction);
			strExtraHeaders.Append(_T("Accept: text/xml\r\n"), sizeof("Accept: text/xml\r\n")-1);
			CAtlNavigateData navData;
			navData.SetMethod(ATL_HTTP_METHOD_POST);
			navData.SetPort(m_url.GetPortNumber());
			navData.SetExtraHeaders(strExtraHeaders);
			navData.SetData((LPBYTE)(LPCSTR)m_writeStream.m_str, m_writeStream.m_str.GetLength(), _T("text/xml"));
			
			if (m_dwTimeout != 0)
			{
				navData.SetSocketTimeout(m_dwTimeout);
			}

			if (m_socket.Navigate(&m_url, &navData) != false)
			{
				hr = (m_readStream.Init(&m_socket) != FALSE ? S_OK : E_FAIL);
			}
			else if (GetStatusCode() == 500)
			{
				// if returned 500, get the SOAP fault
				if (m_readStream.Init(&m_socket) != FALSE)
				{
					CComPtr<ISAXXMLReader> spReader;
					if (SUCCEEDED(GetClientReader(&spReader)))
					{
						CComPtr<IStream> spReadStream;
						if (SUCCEEDED(GetReadStream(&spReadStream)))
						{
							m_fault.ParseFault(spReadStream, spReader);
						}
					}
				}
			}
		}
		_ATLCATCHALL()
		{
			hr = E_FAIL;
		}

		return hr;
	}

	HRESULT SetUrl(LPCTSTR szUrl) throw()
	{
		return (m_url.CrackUrl(szUrl) != FALSE) ? S_OK : E_FAIL;
	}

	HRESULT GetUrl(LPTSTR szUrl, LPDWORD pdwLen) throw()
	{
		if ((szUrl == NULL) || (pdwLen == NULL))
		{
			return E_INVALIDARG;
		}

		return (m_url.CreateUrl(szUrl, pdwLen) != FALSE) ? S_OK : E_FAIL;
	}


	HRESULT SetProxy(LPCTSTR szProxy = NULL, short nProxyPort = 80) throw()
	{
		BOOL bRet;
		_ATLTRY
		{
			bRet = m_socket.SetProxy(szProxy, nProxyPort);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return (bRet != FALSE) ? S_OK : E_FAIL;
	}

	void SetTimeout(DWORD dwTimeout) throw()
	{
		m_dwTimeout = dwTimeout;
	}

	int GetStatusCode() throw()
	{
		return m_socket.GetStatus();
	}

}; // CSoapSocketClientT

#ifndef ATLSOAP_NOWININET

class CReadStreamOnInet : public IStreamImpl
{
public:

	HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (ppv == NULL)
		{
			return E_POINTER;
		}

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
			InlineIsEqualGUID(riid, IID_IStream) ||
			InlineIsEqualGUID(riid, IID_ISequentialStream))
		{
			*ppv = static_cast<IStream *>(this);
			return S_OK;
		}

		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef() throw()
	{
		return 1;
	}

	ULONG __stdcall Release() throw()
	{
		return 1;
	}

private:

	HINTERNET m_hFile;

public:

	CReadStreamOnInet() throw()
		:m_hFile(NULL)
	{
	}

	void Init(HINTERNET hFile) throw()
	{
		m_hFile = hFile;
	}

	HRESULT STDMETHODCALLTYPE Read(void *pDest, ULONG dwMaxLen, ULONG *pdwRead) throw()
	{
		BOOL bRet = InternetReadFile(m_hFile, pDest, dwMaxLen, pdwRead);
		return (bRet != FALSE) ? S_OK : E_FAIL;
	}

}; // CStreamOnInet

class CSoapWininetClient
{
private:
	
	CUrl m_url;
	CWriteStreamOnCString m_writeStream;
	CReadStreamOnInet m_readStream;
	CString m_strProxy;
	DWORD m_dwTimeout;

	void CloseAll() throw()
	{
		if (m_hRequest != NULL)
		{
			InternetCloseHandle(m_hRequest);
			m_hRequest = NULL;
		}
		if (m_hConnection != NULL)
		{
			InternetCloseHandle(m_hConnection);
			m_hConnection = NULL;
		}
		if (m_hInternet != NULL)
		{
			InternetCloseHandle(m_hInternet);
			m_hInternet = NULL;
		}
	}

	HRESULT ConnectToServer() throw()
	{
		if (m_hConnection != NULL)
		{
			return S_OK;
		}

		m_hInternet = InternetOpen(ATLSOAPINET_CLIENT, INTERNET_OPEN_TYPE_PRECONFIG,
			m_strProxy.GetLength() ? (LPCTSTR) m_strProxy : NULL,
			NULL, 0);

		if (m_hInternet != NULL)
		{
			if (m_dwTimeout != 0)
			{
				InternetSetOption(m_hInternet, INTERNET_OPTION_CONNECT_TIMEOUT,
					&m_dwTimeout, sizeof(m_dwTimeout)/sizeof(TCHAR));
				InternetSetOption(m_hInternet, INTERNET_OPTION_RECEIVE_TIMEOUT,
					&m_dwTimeout, sizeof(m_dwTimeout)/sizeof(TCHAR));
				InternetSetOption(m_hInternet, INTERNET_OPTION_SEND_TIMEOUT,
					&m_dwTimeout, sizeof(m_dwTimeout)/sizeof(TCHAR));
			}
			m_hConnection = InternetConnect(m_hInternet, m_url.GetHostName(), 
				(INTERNET_PORT) m_url.GetPortNumber(), NULL, NULL,
				INTERNET_SERVICE_HTTP, INTERNET_FLAG_NO_UI, NULL);

			if (m_hConnection != NULL)
			{
				return S_OK;
			}
		}
		CloseAll();
		return E_FAIL;
	}

protected:

	virtual HRESULT GetClientReader(ISAXXMLReader **pReader) throw()
	{
		if (pReader == NULL)
		{
			return E_POINTER;
		}
		*pReader = NULL;

		CComPtr<ISAXXMLReader> spReader;
		HRESULT hr = spReader.CoCreateInstance(__uuidof(SAXXMLReader30));
		if (SUCCEEDED(hr))
		{
			*pReader = spReader.Detach();
		}
		return hr;
	}

public:

	// note : not shared across stock client implementations
	HINTERNET m_hInternet;
	HINTERNET m_hConnection;
	HINTERNET m_hRequest;

	CSoapFault m_fault;

	CSoapWininetClient(LPCTSTR szUrl) throw()
		:m_hInternet(NULL), m_hConnection(NULL), m_hRequest(NULL), m_dwTimeout(0)
	{
		m_url.CrackUrl(szUrl);
		SetProxy();
	}

	CSoapWininetClient(LPCTSTR szServer, LPCTSTR szUri, short nPort=80) throw()
		:m_hInternet(NULL), m_hConnection(NULL), m_hRequest(NULL)
	{
		m_url.SetHostName(szServer);
		m_url.SetUrlPath(szUri);
		m_url.SetPortNumber((ATL_URL_PORT) nPort);
	}

	~CSoapWininetClient() throw()
	{
		CleanupClient();
	}

	IWriteStream * GetWriteStream() throw()
	{
		return &m_writeStream;
	}

	HRESULT GetReadStream(IStream **ppStream) throw()
	{
		if (ppStream == NULL)
		{
			return E_POINTER;
		}

		*ppStream = &m_readStream;
		return S_OK;
	}

	void CleanupClient() throw()
	{
		m_writeStream.Cleanup();
		InternetCloseHandle(m_hRequest);
		m_hRequest = NULL;
	}

	HRESULT SendRequest(LPCTSTR szAction) throw()
	{
		m_fault.Clear();
		if (ConnectToServer() != S_OK)
		{
			return E_FAIL;
		}

		static LPCTSTR s_szAcceptTypes[] = { _T("text/*"), NULL };
		m_hRequest = HttpOpenRequest(m_hConnection, _T("POST"), 
			m_url.GetUrlPath(), _T("HTTP/1.0"), NULL,
			s_szAcceptTypes, 
			INTERNET_FLAG_NO_UI | ((m_url.GetPortNumber() == ATL_URL_DEFAULT_HTTPS_PORT) ? INTERNET_FLAG_SECURE : 0)
			, NULL);

		if (m_hRequest != NULL)
		{
			if (FALSE != HttpSendRequest(m_hRequest, szAction, (DWORD) _tcslen(szAction),
				(void *)(LPCSTR)m_writeStream.m_str, m_writeStream.m_str.GetLength()))
			{
				m_readStream.Init(m_hRequest);
				if (GetStatusCode() != HTTP_STATUS_SERVER_ERROR)
				{
					return S_OK;
				}
				else
				{
					CComPtr<ISAXXMLReader> spReader;
					if (SUCCEEDED(GetClientReader(&spReader)))
					{
						CComPtr<IStream> spReadStream;
						if (SUCCEEDED(GetReadStream(&spReadStream)))
						{
							m_fault.ParseFault(spReadStream, spReader);
						}
					}
				}
			}
		}

		return E_FAIL;
	}

	HRESULT SetUrl(LPCTSTR szUrl) throw()
	{
		CloseAll();
		return (m_url.CrackUrl(szUrl) != FALSE ? S_OK : E_FAIL);
	}

	HRESULT GetUrl(LPTSTR szUrl, LPDWORD pdwLen) throw()
	{
		if ((szUrl == NULL) || (pdwLen == NULL))
		{
			return E_INVALIDARG;
		}

		return (m_url.CreateUrl(szUrl, pdwLen) != FALSE) ? S_OK : E_FAIL;
	}

	HRESULT SetProxy(LPCTSTR szProxy = NULL, short nProxyPort = 80) throw()
	{
		nProxyPort;
		_ATLTRY
		{
			m_strProxy = szProxy;
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	void SetTimeout(DWORD dwTimeout) throw()
	{
		m_dwTimeout = dwTimeout;
	}

	int GetStatusCode() throw()
	{
		DWORD dwLen = 256;
		TCHAR szBuf[256];
		if (HttpQueryInfo(m_hRequest, HTTP_QUERY_STATUS_CODE, szBuf, &dwLen, NULL))
		{
			return _ttoi(szBuf);
		}
		return 0;
	}
}; // CSoapWininetClient
#endif

#ifndef ATLSOAP_NOMSXML_INET
class CSoapMSXMLInetClient
{
	CUrl m_url;
	CWriteStreamOnCString m_writeStream;
	DWORD m_dwTimeout;

	HRESULT ConnectToServer() throw()
	{
		TCHAR szURL[ATL_URL_MAX_URL_LENGTH];
		DWORD dwLen = ATL_URL_MAX_URL_LENGTH;
		HRESULT hr = E_FAIL;

		if (m_spHttpRequest)
			return S_OK;

		if (!m_url.CreateUrl(szURL, &dwLen))
			return E_FAIL;


		hr = m_spHttpRequest.CoCreateInstance(__uuidof(ServerXMLHTTP30));
		if (hr != S_OK)
			return hr;
	
		CComVariant vEmpty;
		hr = m_spHttpRequest->open( CComBSTR(L"POST"),
									CComBSTR(szURL),
									CComVariant(VARIANT_BOOL(VARIANT_FALSE)),
									vEmpty,
									vEmpty );
		if (hr != S_OK)
		{
			m_spHttpRequest.Release();
		   return hr;
		}
		
		return S_OK;
	}

protected:

	virtual HRESULT GetClientReader(ISAXXMLReader **pReader) throw()
	{
		if (pReader == NULL)
		{
			return E_POINTER;
		}
		*pReader = NULL;

		CComPtr<ISAXXMLReader> spReader;
		HRESULT hr = spReader.CoCreateInstance(__uuidof(SAXXMLReader30));
		if (SUCCEEDED(hr))
		{
			*pReader = spReader.Detach();
		}
		return hr;
	}

public:

	// note : not shared across stock client implementations
	CComPtr<IServerXMLHTTPRequest> m_spHttpRequest;

	CSoapFault m_fault;

	CSoapMSXMLInetClient(LPCTSTR szUrl) throw()
		:m_dwTimeout(0)
	{
		m_url.CrackUrl(szUrl);
	}

	CSoapMSXMLInetClient(LPCTSTR szServer, LPCTSTR szUri, short nPort=80) throw()
	{
		m_url.SetHostName(szServer);
		m_url.SetUrlPath(szUri);
		m_url.SetPortNumber((ATL_URL_PORT) nPort);
	}

	~CSoapMSXMLInetClient() throw()
	{
		CleanupClient();
	}

	IWriteStream * GetWriteStream() throw()
	{
		return &m_writeStream;
	}

	HRESULT GetReadStream(IStream **ppStream) throw()
	{
		if (ppStream == NULL)
		{
			return E_POINTER;
		}

		*ppStream = NULL;
		HRESULT hr = E_FAIL;

		if (m_spHttpRequest)
		{
			VARIANT vResponseStream;
			VariantInit(&vResponseStream);
			hr = m_spHttpRequest->get_responseStream(&vResponseStream);
			if (S_OK == hr)
			{
				hr = E_FAIL;
				if (vResponseStream.punkVal != NULL)
				{
					// we return the refcount with the pointer!
					*ppStream = (IStream*)vResponseStream.punkVal;
					hr = S_OK;
				}
			}
		}
		return hr;
	}

	void CleanupClient() throw()
	{
		m_writeStream.Cleanup();
		m_spHttpRequest.Release();
	}

	HRESULT SendRequest(LPCTSTR szAction) throw()
	{
		m_fault.Clear();

		if (ConnectToServer() != S_OK)
		{
			return E_FAIL;
		}
		
		// set the action header
		LPCTSTR szColon = _tcschr(szAction, _T(':'));
		if (szColon != NULL)
		{
			do
			{
				szColon++;
			} while (_istspace(*szColon));

			if (FAILED(m_spHttpRequest->setRequestHeader(
						CComBSTR( L"SOAPAction" ), CComBSTR( szColon ))))
			{
				return E_FAIL;
			}
		} // if SOAPAction header not properly formed, attempt to send anyway
		
		// set timeout
		if (m_dwTimeout != 0)
		{
			long nTimeout = (long) m_dwTimeout;
			m_spHttpRequest->setTimeouts(nTimeout, nTimeout, nTimeout, nTimeout);
			// reset timeout
			m_dwTimeout = 0;
		}

		CComVariant vBody(m_writeStream.m_str);
		HRESULT hr = m_spHttpRequest->send(vBody);
		if ((SUCCEEDED(hr)) && (GetStatusCode() == 500))
		{
			hr = E_FAIL;
			CComPtr<ISAXXMLReader> spReader;
			if (SUCCEEDED(GetClientReader(&spReader)))
			{
				CComPtr<IStream> spReadStream;
				if (SUCCEEDED(GetReadStream(&spReadStream)))
				{
					m_fault.ParseFault(spReadStream, spReader);
				}
			}
		}

		return hr;
	}

	HRESULT SetUrl(LPCTSTR szUrl) throw()
	{
		CleanupClient();
		return (m_url.CrackUrl(szUrl) != FALSE ? S_OK : E_FAIL);
	}

	HRESULT GetUrl(LPTSTR szUrl, LPDWORD pdwLen) throw()
	{
		if ((szUrl == NULL) || (pdwLen == NULL))
		{
			return E_INVALIDARG;
		}

		return (m_url.CreateUrl(szUrl, pdwLen) != FALSE) ? S_OK : E_FAIL;
	}

	void SetTimeout(DWORD dwTimeout) throw()
	{
		m_dwTimeout = dwTimeout;
	}

	int GetStatusCode() throw()
	{
		long lStatus;
		if (m_spHttpRequest->get_status(&lStatus) == S_OK)
		{
			return (int) lStatus;
		}
		return 0;
	}
}; // CSoapMSXMLInetClient
#endif


class _CSDLGenerator : public ITagReplacerImpl<_CSDLGenerator>
{
private:

	typedef CAtlMap<CStringA, const _soapmap *, CStringElementTraits<CStringA> >  WSDLMAP;
	typedef CAtlMap<CStringA, const _soapmapentry *, CStringElementTraits<CStringA> > HEADERMAP;

	HRESULT GenerateWSDLHelper(const _soapmap *pMap, WSDLMAP& structMap, WSDLMAP& enumMap) throw()
	{
		ATLASSERT( pMap != NULL );

		const _soapmapentry *pEntries = pMap->pEntries;
		ATLASSERT( pEntries != NULL );

		HRESULT hr = S_OK;

		for (int i=0; pEntries[i].nHash != 0; i++)
		{
			if (pEntries[i].nVal == SOAPTYPE_UNK)
			{
				ATLASSERT( pEntries[i].pChain != NULL );

				_ATLTRY
				{
					POSITION pos = NULL;
					CStringA strName(pEntries[i].pChain->szName, pEntries[i].pChain->cchName);
					if (pEntries[i].pChain->mapType == SOAPMAP_STRUCT)
					{
						pos = structMap.SetAt(strName, pEntries[i].pChain);
					}
					else if (pEntries[i].pChain->mapType == SOAPMAP_ENUM)
					{
						pos = enumMap.SetAt(strName, pEntries[i].pChain);
					}
					if (pos == NULL)
					{
						hr = E_OUTOFMEMORY;
						break;
					}
				}
				_ATLCATCHALL()
				{
					hr = E_OUTOFMEMORY;
					break;
				}

				hr = GenerateWSDLHelper(pEntries[i].pChain, structMap, enumMap);
				if (FAILED(hr))
				{
					break;
				}
			}
		}

		return hr;
	}

	HTTP_CODE IsUDT(const _soapmapentry *pEntry) throw()
	{
		ATLASSERT( pEntry != NULL );
		return ( (pEntry->nVal != SOAPTYPE_UNK) && (pEntry->nVal != SOAPTYPE_BLOB) ) ? HTTP_S_FALSE : HTTP_SUCCESS;
	}

	HTTP_CODE GetSoapDims(const _soapmapentry *pEntry) throw()
	{
		ATLASSERT( pEntry != NULL );
		if (pEntry->pDims[0] != 0)
		{
			if (SUCCEEDED(m_pWriteStream->WriteStream("[", 1, NULL)))
			{
				for (int i=1; i<=pEntry->pDims[0]; i++)
				{
					if (m_writeHelper.Write(pEntry->pDims[i]) != FALSE)
					{
						if (i < pEntry->pDims[0])
						{
							if (FAILED(m_pWriteStream->WriteStream(", ", 2, NULL)))
							{
								return HTTP_FAIL;
							}
						}
					}
				}
				if (SUCCEEDED(m_pWriteStream->WriteStream("]", 1, NULL)))
				{
					return HTTP_SUCCESS;
				}
			}
		}
		return HTTP_FAIL;
	}

	const _soapmap **m_pFuncs;
	const _soapmap **m_pHeaders;
	int m_nFunc;
	int m_nParam;
	int m_nHeader;
	WSDLMAP m_structMap;
	WSDLMAP m_enumMap;
	POSITION m_currUDTPos;
	int m_nCurrUDTField;

	HEADERMAP m_headerMap;
	POSITION m_currHeaderPos;

	CWriteStreamHelper m_writeHelper;

	CStringA m_strServiceName;
	CStringA m_strNamespaceUri;

	IWriteStream *m_pWriteStream;

	CComPtr<IHttpServerContext> m_spHttpServerContext;

protected:

	void SetWriteStream(IWriteStream *pStream) throw()
	{
		m_pWriteStream = pStream;
		m_writeHelper.Attach(m_pWriteStream);
	}

	void SetHttpServerContext(IHttpServerContext *pServerContext) throw()
	{
		m_spHttpServerContext = pServerContext;
	}

	static HTTP_CODE GetSoapType(int nVal, IWriteStream *pStream) throw()
	{
		return (pStream->WriteStream(CSoapRootHandler::s_xsdNames[nVal].szName, 
			CSoapRootHandler::s_xsdNames[nVal].cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
	}
	

	HRESULT InitializeSDL(CSoapRootHandler *pHdlr) throw()
	{
		m_pFuncs = pHdlr->GetFunctionMap();

		if (m_pFuncs == NULL)
		{
			return E_FAIL;
		}

		size_t i;
		for (i=0; m_pFuncs[i] != NULL; i++)
		{
			const _soapmap *pMap = m_pFuncs[i];
			HRESULT hr = GenerateWSDLHelper(pMap, m_structMap, m_enumMap);
			if (FAILED(hr))
			{
				return hr;
			}
		}

		m_pHeaders = pHdlr->GetHeaderMap();
		if (m_pHeaders != NULL)
		{
			for (i=0; m_pHeaders[i] != NULL; i++)
			{
				const _soapmap *pMap = m_pHeaders[i];
				HRESULT hr = GenerateWSDLHelper(pMap, m_structMap, m_enumMap);
				if (FAILED(hr))
				{
					return hr;
				}
			}

			for (i=0; m_pHeaders[i] != NULL; i++)
			{
				const _soapmap *pMap = m_pHeaders[i];
				for (size_t j=0; pMap->pEntries[j].nHash != 0; j++)
				{
					HRESULT hr = S_OK;
					_ATLTRY
					{
						if (m_headerMap.SetAt(pMap->pEntries[j].szField, &pMap->pEntries[j]) == NULL)
						{
							hr = E_OUTOFMEMORY;
						}
					}
					_ATLCATCHALL()
					{
						hr = E_OUTOFMEMORY;
					}
					if (FAILED(hr))
					{
						return hr;
					}
				}
			}
		}

		_ATLTRY
		{
			m_strServiceName = pHdlr->GetServiceName();
			m_strNamespaceUri = pHdlr->GetNamespaceUriA();
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	virtual const char * GetHandlerName() throw() = 0;

public:

	_CSDLGenerator() throw()
		:m_pFuncs(NULL), m_nFunc(-1), m_nParam(-1),
		 m_currUDTPos(NULL), m_nCurrUDTField(-1),
		 m_pWriteStream(NULL), m_nHeader(-1), m_currHeaderPos(NULL)
	{
	}

	HTTP_CODE OnGetURL() throw()
	{
		char szURL[ATL_URL_MAX_URL_LENGTH];
		DWORD dwUrlSize = sizeof(szURL);
		char szServer[ATL_URL_MAX_HOST_NAME_LENGTH];
		DWORD dwServerSize = sizeof(szServer);
		char szHttps[16];
		DWORD dwHttpsLen = sizeof(szHttps);

		if (m_spHttpServerContext->GetServerVariable("URL", szURL, &dwUrlSize) != FALSE)
		{
			if (m_spHttpServerContext->GetServerVariable("SERVER_NAME", szServer, &dwServerSize) != FALSE)
			{
				bool bHttps = false;
				if ((m_spHttpServerContext->GetServerVariable("HTTPS", szHttps, &dwHttpsLen) != FALSE) &&
					(!_stricmp(szHttps, "ON")))
				{
					bHttps = true;
				}
				_ATLTRY
				{
					CStringA strUrl;
					strUrl.Format("http%s://%s%s?Handler=%s", bHttps ? "s" : "", szServer, szURL, GetHandlerName());
					if (S_OK == m_pWriteStream->WriteStream(strUrl, strUrl.GetLength(), NULL))
					{
						return HTTP_SUCCESS;
					}
				}
				_ATLCATCHALL()
				{
					return HTTP_FAIL;
				}
			}
		}
		return HTTP_FAIL;
	}

	HTTP_CODE OnGetNamespace() throw()
	{
		return (m_pWriteStream->WriteStream(m_strNamespaceUri, 
			m_strNamespaceUri.GetLength(), NULL) == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
	}

	HTTP_CODE OnGetNextFunction() throw()
	{
		m_nFunc++;
		if (m_pFuncs[m_nFunc] == NULL)
		{
			m_nFunc = -1;
			return HTTP_S_FALSE;
		}
		return HTTP_SUCCESS;
	}

	HTTP_CODE OnGetFunctionName() throw()
	{
		return (m_pWriteStream->WriteStream(m_pFuncs[m_nFunc]->szName, 
			m_pFuncs[m_nFunc]->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE; 
	}

	HTTP_CODE OnGetNextParameter() throw()
	{
		++m_nParam;
		if (m_pFuncs[m_nFunc]->pEntries[m_nParam].nHash != 0)
		{
			if (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & SOAPFLAG_NOMARSHAL)
			{
				return OnGetNextParameter();
			}
			return HTTP_SUCCESS;
		}
		m_nParam = -1;
		return HTTP_S_FALSE;
	}

	HTTP_CODE OnIsInParameter() throw()
	{
		return (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & SOAPFLAG_IN) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetParameterName() throw()
	{
		HRESULT hr = S_OK;
		if (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & SOAPFLAG_RETVAL)
		{
			hr = m_pWriteStream->WriteStream("return", sizeof("return")-1, NULL);
		}
		else
		{
			hr = m_pWriteStream->WriteStream(m_pFuncs[m_nFunc]->pEntries[m_nParam].szField, 
					m_pFuncs[m_nFunc]->pEntries[m_nParam].cchField, NULL);
		}
		
		return (hr == S_OK) ? HTTP_SUCCESS : HTTP_FAIL; 
	}

	HTTP_CODE OnNotIsArrayParameter() throw()
	{
		return (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & (SOAPFLAG_FIXEDARR | SOAPFLAG_DYNARR)) 
			? HTTP_S_FALSE: HTTP_SUCCESS;
	}

	HTTP_CODE OnIsParameterUDT() throw()
	{
		return IsUDT(&m_pFuncs[m_nFunc]->pEntries[m_nParam]);
	}

	HTTP_CODE OnGetParameterSoapType() throw()
	{
		if (m_pFuncs[m_nFunc]->pEntries[m_nParam].nVal != SOAPTYPE_UNK)
		{
			return GetSoapType(m_pFuncs[m_nFunc]->pEntries[m_nParam].nVal, m_pWriteStream);
		}
		ATLASSERT( m_pFuncs[m_nFunc]->pEntries[m_nParam].pChain != NULL );
		return (m_pWriteStream->WriteStream(m_pFuncs[m_nFunc]->pEntries[m_nParam].pChain->szName, 
			m_pFuncs[m_nFunc]->pEntries[m_nParam].pChain->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE; 
	}

	HTTP_CODE OnIsParameterDynamicArray() throw()
	{
		return (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & SOAPFLAG_DYNARR) ? HTTP_SUCCESS: HTTP_S_FALSE;
	}

	HTTP_CODE OnIsArrayParameter() throw()
	{
		return (OnNotIsArrayParameter() != HTTP_SUCCESS) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnIsParameterOneDimensional() throw()
	{
		return (m_pFuncs[m_nFunc]->pEntries[m_nParam].pDims[0] == 1) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetParameterArraySize() throw()
	{
		return (m_writeHelper.Write(m_pFuncs[m_nFunc]->pEntries[m_nParam].pDims[1]) != FALSE)
			? HTTP_SUCCESS : HTTP_FAIL;
	}

	HTTP_CODE OnGetParameterArraySoapDims() throw()
	{
		return GetSoapDims(&m_pFuncs[m_nFunc]->pEntries[m_nParam]);
	}

	HTTP_CODE OnIsOutParameter() throw()
	{
		return (m_pFuncs[m_nFunc]->pEntries[m_nParam].dwFlags & SOAPFLAG_OUT) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetNextEnum() throw()
	{
		if (m_currUDTPos == NULL)
		{
			m_currUDTPos = m_enumMap.GetStartPosition();
		}
		else
		{
			m_enumMap.GetNext(m_currUDTPos);
		}

		return (m_currUDTPos != NULL) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetEnumName() throw()
	{
		const _soapmap *pMap = m_enumMap.GetValueAt(m_currUDTPos);
		return (m_pWriteStream->WriteStream(pMap->szName, pMap->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetNextEnumElement() throw()
	{
		const _soapmap *pMap = m_enumMap.GetValueAt(m_currUDTPos);
		++m_nCurrUDTField;
		if (pMap->pEntries[m_nCurrUDTField].nHash != 0)
		{
			return HTTP_SUCCESS;
		}
		m_nCurrUDTField = -1;
		return HTTP_S_FALSE;
	}

	HTTP_CODE OnGetEnumElementName() throw()
	{
		const _soapmap *pMap = m_enumMap.GetValueAt(m_currUDTPos);
		return (m_pWriteStream->WriteStream(pMap->pEntries[m_nCurrUDTField].szField,
			pMap->pEntries[m_nCurrUDTField].cchField, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetNextStruct() throw()
	{
		if (m_currUDTPos == NULL)
		{
			m_currUDTPos = m_structMap.GetStartPosition();
		}
		else
		{
			m_structMap.GetNext(m_currUDTPos);
		}

		return (m_currUDTPos != NULL) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetStructName() throw()
	{
		const _soapmap *pMap = m_enumMap.GetValueAt(m_currUDTPos);
		return (m_pWriteStream->WriteStream(pMap->szName, pMap->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetNextStructField() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		++m_nCurrUDTField;
		if (pMap->pEntries[m_nCurrUDTField].nHash != 0)
		{
			return HTTP_SUCCESS;
		}
		m_nCurrUDTField = -1;
		return HTTP_S_FALSE;
	}

	HTTP_CODE OnGetStructFieldName() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return (m_pWriteStream->WriteStream(pMap->pEntries[m_nCurrUDTField].szField,
			pMap->pEntries[m_nCurrUDTField].cchField, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnNotIsArrayField() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return (pMap->pEntries[m_nCurrUDTField].dwFlags & SOAPFLAG_FIXEDARR) ? HTTP_S_FALSE : HTTP_SUCCESS;
	}

	HTTP_CODE OnIsFieldUDT() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return IsUDT(&pMap->pEntries[m_nCurrUDTField]);
	}

	HTTP_CODE OnGetStructFieldSoapType() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		if (pMap->pEntries[m_nCurrUDTField].nVal != SOAPTYPE_UNK)
		{
			return GetSoapType(pMap->pEntries[m_nCurrUDTField].nVal, m_pWriteStream);
		}
		ATLASSERT( pMap->pEntries[m_nCurrUDTField].pChain != NULL );
		return (m_pWriteStream->WriteStream(pMap->pEntries[m_nCurrUDTField].pChain->szName, 
			pMap->pEntries[m_nCurrUDTField].pChain->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE; 
	}

	HTTP_CODE OnIsArrayField() throw()
	{
		return (OnNotIsArrayField() != HTTP_SUCCESS) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnIsFieldOneDimensional() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return (pMap->pEntries[m_nCurrUDTField].pDims[0] == 1) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetFieldArraySize() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return (m_writeHelper.Write(pMap->pEntries[m_nCurrUDTField].pDims[1]) != FALSE) ? 
				HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetFieldArraySoapDims() throw()
	{
		const _soapmap *pMap = m_structMap.GetValueAt(m_currUDTPos);
		return GetSoapDims(&pMap->pEntries[m_nCurrUDTField]);
	}

	HTTP_CODE OnGetServiceName() throw()
	{
		return (m_pWriteStream->WriteStream(m_strServiceName, 
			m_strServiceName.GetLength(), NULL) == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
	}

	HTTP_CODE OnGetNextHeader() throw()
	{	
		if (m_currHeaderPos == NULL)
		{
			m_currHeaderPos = m_headerMap.GetStartPosition();
		}
		else
		{
			m_headerMap.GetNext(m_currHeaderPos);
		}

		return (m_currHeaderPos != NULL) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnIsInHeader() throw()
	{
		return (m_pHeaders[m_nFunc]->pEntries[m_nHeader].dwFlags & SOAPFLAG_IN) 
			? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnIsOutHeader() throw()
	{
		return (m_pHeaders[m_nFunc]->pEntries[m_nHeader].dwFlags & SOAPFLAG_OUT) 
			? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnIsRequiredHeader() throw()
	{
		return (m_pHeaders[m_nFunc]->pEntries[m_nHeader].dwFlags & SOAPFLAG_MUSTUNDERSTAND) 
			? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetHeaderName() throw()
	{
		const _soapmapentry *pEntry = m_headerMap.GetValueAt(m_currHeaderPos);
		return (m_pWriteStream->WriteStream(pEntry->szField, 
			pEntry->cchField, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
	}

	HTTP_CODE OnNotIsArrayHeader() throw()
	{
		const _soapmapentry *pEntry = m_headerMap.GetValueAt(m_currHeaderPos);
		return (pEntry->dwFlags & SOAPFLAG_FIXEDARR) ? HTTP_S_FALSE : HTTP_SUCCESS;
	}

	HTTP_CODE OnIsHeaderUDT() throw()
	{
		return IsUDT(m_headerMap.GetValueAt(m_currHeaderPos));
	}

	HTTP_CODE OnGetHeaderSoapType() throw()
	{
		const _soapmapentry *pEntry = m_headerMap.GetValueAt(m_currHeaderPos);
		if (pEntry->nVal != SOAPTYPE_UNK)
		{
			return GetSoapType(pEntry->nVal, m_pWriteStream);
		}
		ATLASSERT( pEntry->pChain != NULL );
		return (m_pWriteStream->WriteStream(pEntry->pChain->szName, 
			pEntry->pChain->cchName, NULL) == S_OK) ? HTTP_SUCCESS : HTTP_S_FALSE; 
	}

	HTTP_CODE OnIsHeaderOneDimensional() throw()
	{
		const _soapmapentry *pEntry = m_headerMap.GetValueAt(m_currHeaderPos);
		return (pEntry->pDims[0] == 1) ? HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetHeaderArraySize() throw()
	{
		const _soapmapentry *pEntry = m_headerMap.GetValueAt(m_currHeaderPos);
		return (m_writeHelper.Write(pEntry->pDims[1]) != FALSE) ? 
				HTTP_SUCCESS : HTTP_S_FALSE;
	}

	HTTP_CODE OnGetHeaderArraySoapDims() throw()
	{
		return GetSoapDims(m_headerMap.GetValueAt(m_currHeaderPos));
	}

	HTTP_CODE OnGetNextFunctionHeader() throw()
	{
		++m_nHeader;
		if (m_pHeaders[m_nFunc]->pEntries[m_nHeader].nHash != 0)
		{
			if (m_pHeaders[m_nFunc]->pEntries[m_nHeader].dwFlags & SOAPFLAG_NOMARSHAL)
			{
				return OnGetNextHeader();
			}
			return HTTP_SUCCESS;
		}
		m_nHeader = -1;
		return HTTP_S_FALSE;
	}

	HTTP_CODE OnGetFunctionHeaderName() throw()
	{
		return (m_pWriteStream->WriteStream(
					m_pHeaders[m_nFunc]->pEntries[m_nHeader].szField,
					m_pHeaders[m_nFunc]->pEntries[m_nHeader].cchField,
					NULL) == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
	}

	HTTP_CODE OnIsArrayHeader() throw()
	{
		return (OnNotIsArrayHeader() == HTTP_SUCCESS) ? HTTP_S_FALSE : HTTP_SUCCESS;
	}

	BEGIN_REPLACEMENT_METHOD_MAP(_CSDLGenerator)
		REPLACEMENT_METHOD_ENTRY("GetNamespace", OnGetNamespace)
		REPLACEMENT_METHOD_ENTRY("GetNextFunction", OnGetNextFunction)
		REPLACEMENT_METHOD_ENTRY("GetFunctionName", OnGetFunctionName)
		REPLACEMENT_METHOD_ENTRY("GetNextParameter", OnGetNextParameter)
		REPLACEMENT_METHOD_ENTRY("IsInParameter", OnIsInParameter)
		REPLACEMENT_METHOD_ENTRY("GetParameterName", OnGetParameterName)
		REPLACEMENT_METHOD_ENTRY("NotIsArrayParameter", OnNotIsArrayParameter)
		REPLACEMENT_METHOD_ENTRY("IsParameterUDT", OnIsParameterUDT)
		REPLACEMENT_METHOD_ENTRY("GetParameterSoapType", OnGetParameterSoapType)
		REPLACEMENT_METHOD_ENTRY("IsParameterDynamicArray", OnIsParameterDynamicArray)
		REPLACEMENT_METHOD_ENTRY("IsArrayParameter", OnIsArrayParameter)
		REPLACEMENT_METHOD_ENTRY("IsParameterOneDimensional", OnIsParameterOneDimensional)
		REPLACEMENT_METHOD_ENTRY("GetParameterArraySize", OnGetParameterArraySize)
		REPLACEMENT_METHOD_ENTRY("GetParameterArraySoapDims", OnGetParameterArraySoapDims)
		REPLACEMENT_METHOD_ENTRY("IsOutParameter", OnIsOutParameter)
		REPLACEMENT_METHOD_ENTRY("GetNextEnum", OnGetNextEnum)
		REPLACEMENT_METHOD_ENTRY("GetEnumName", OnGetEnumName)
		REPLACEMENT_METHOD_ENTRY("GetNextEnumElement", OnGetNextEnumElement)
		REPLACEMENT_METHOD_ENTRY("GetEnumElementName", OnGetEnumElementName)
		REPLACEMENT_METHOD_ENTRY("GetNextStruct", OnGetNextStruct)
		REPLACEMENT_METHOD_ENTRY("GetStructName", OnGetStructName)
		REPLACEMENT_METHOD_ENTRY("GetNextStructField", OnGetNextStructField)
		REPLACEMENT_METHOD_ENTRY("GetStructFieldName", OnGetStructFieldName)
		REPLACEMENT_METHOD_ENTRY("NotIsArrayField", OnNotIsArrayField)
		REPLACEMENT_METHOD_ENTRY("IsFieldUDT", OnIsFieldUDT)
		REPLACEMENT_METHOD_ENTRY("GetStructFieldSoapType", OnGetStructFieldSoapType)
		REPLACEMENT_METHOD_ENTRY("IsArrayField", OnIsArrayField)
		REPLACEMENT_METHOD_ENTRY("IsFieldOneDimensional", OnIsFieldOneDimensional)
		REPLACEMENT_METHOD_ENTRY("GetFieldArraySize", OnGetFieldArraySize)
		REPLACEMENT_METHOD_ENTRY("GetFieldArraySoapDims", OnGetFieldArraySoapDims)
		REPLACEMENT_METHOD_ENTRY("GetServiceName", OnGetServiceName)
		REPLACEMENT_METHOD_ENTRY("GetURL", OnGetURL)

		REPLACEMENT_METHOD_ENTRY("GetNextHeader", OnGetNextHeader)
		REPLACEMENT_METHOD_ENTRY("GetHeaderName", OnGetHeaderName)
		REPLACEMENT_METHOD_ENTRY("NotIsArrayHeader", OnNotIsArrayHeader)
		REPLACEMENT_METHOD_ENTRY("IsArrayHeader", OnIsArrayHeader)
		REPLACEMENT_METHOD_ENTRY("IsHeaderUDT", OnIsHeaderUDT)
		REPLACEMENT_METHOD_ENTRY("GetHeaderSoapType", OnGetHeaderSoapType)
		REPLACEMENT_METHOD_ENTRY("IsHeaderOneDimensional", OnIsHeaderOneDimensional)
		REPLACEMENT_METHOD_ENTRY("GetHeaderArraySize", OnGetHeaderArraySize)
		REPLACEMENT_METHOD_ENTRY("GetHeaderArraySoapDims", OnGetHeaderArraySoapDims)
		REPLACEMENT_METHOD_ENTRY("GetNextFunctionHeader", OnGetNextFunctionHeader)
		REPLACEMENT_METHOD_ENTRY("GetFunctionHeaderName", OnGetFunctionHeaderName)
		REPLACEMENT_METHOD_ENTRY("IsInHeader", OnIsInHeader)
		REPLACEMENT_METHOD_ENTRY("IsOutHeader", OnIsOutHeader)
		REPLACEMENT_METHOD_ENTRY("IsRequiredHeader", OnIsRequiredHeader)
	END_REPLACEMENT_METHOD_MAP()
}; // class _CSDLGenerator

template <class THandler, const char *szHandlerName>
class CSDLGenerator :
	public _CSDLGenerator,
	public IRequestHandlerImpl<CSDLGenerator>,
	public CComObjectRootEx<CComSingleThreadModel>
{
private:

public:
	typedef CSDLGenerator<THandler, szHandlerName> _sdlGenerator;

	BEGIN_COM_MAP(_sdlGenerator)
		COM_INTERFACE_ENTRY(IRequestHandler)
		COM_INTERFACE_ENTRY(ITagReplacer)
	END_COM_MAP()

	inline BOOL CachePage() throw()
	{
		// cache the page since it's never going to change until the DLL is unloaded
		return TRUE;
	}

	HTTP_CODE InitializeHandler(AtlServerRequest *pRequestInfo, IServiceProvider *pServiceProvider) throw()
	{
		IRequestHandlerImpl<CSDLGenerator>::InitializeHandler(pRequestInfo, pServiceProvider);

		CComObjectStack<THandler> handler;
		if (FAILED(InitializeSDL(&handler)))
		{
			return HTTP_FAIL;
		}

		CStencil s;
		HTTP_CODE hcErr = s.LoadFromString(s_szAtlsWSDLSrf, (DWORD) s_nAtlsWSDLSrfLen);
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = HTTP_FAIL;
			CHttpResponse HttpResponse(pRequestInfo->pServerContext);
			HttpResponse.SetContentType("text/xml");
			if (s.ParseReplacements(this) != false)
			{
				s.FinishParseReplacements();
				SetStream(&HttpResponse);
				SetWriteStream(&HttpResponse);
				SetHttpServerContext(m_spServerContext);
				hcErr = s.Render(this, &HttpResponse);
			}
		}

		return hcErr;
	}

	const char * GetHandlerName() throw()
	{
		return szHandlerName;
	}
}; // class CSDLGenerator

} // namespace ATL

#endif // __ATLSOAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlspriv.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

/////////////////////////////////////////////////////////////////////////////////
//
// ZEvtSyncSocket
// ************ This is an implementation only class ************
// Class ZEvtSyncSocket is a non-supported, implementation only 
// class used by the ATL HTTP client class CAtlHttpClient. Do not
// use this class in your code. Use of this class is not supported by Microsoft.
//
/////////////////////////////////////////////////////////////////////////////////

#ifndef __ATLSPRIV_INL__
#define __ATLSPRIV_INL__

#pragma once

inline ZEvtSyncSocket::ZEvtSyncSocket() 
{
	m_dwCreateFlags = WSA_FLAG_OVERLAPPED;
	m_hEventRead = m_hEventWrite = m_hEventConnect = NULL;
	m_socket = INVALID_SOCKET;
	m_bConnected = false;
	m_dwLastError = 0;
	m_dwSocketTimeout = ATL_SOCK_TIMEOUT;
	g_HttpInit.Init();
}

inline ZEvtSyncSocket::~ZEvtSyncSocket() 
{
	Close();
}

inline ZEvtSyncSocket::operator SOCKET() 
{
	return m_socket;
}

inline void ZEvtSyncSocket::Close()
{
	if (m_socket != INVALID_SOCKET)
	{
		m_bConnected = false;
		closesocket(m_socket);
		m_socket = INVALID_SOCKET;
		Term();
	}
}

inline void ZEvtSyncSocket::Term() 
{
	if (m_hEventRead)
	{
		WSACloseEvent(m_hEventRead);
		m_hEventRead = NULL;
	}
	if (m_hEventWrite)
	{
		WSACloseEvent(m_hEventWrite);
		m_hEventWrite = NULL;
	}
	if (m_hEventConnect)
	{
		WSACloseEvent(m_hEventConnect);
		m_hEventConnect = NULL;
	}
	m_socket = INVALID_SOCKET;
}

inline bool ZEvtSyncSocket::Create(WORD wFlags)
{
	return Create(PF_INET, SOCK_STREAM, IPPROTO_TCP, wFlags);
}

inline bool ZEvtSyncSocket::Create(short af, short st, short proto, WORD wFlags) 
{
	bool bRet = true;
	if (m_socket != INVALID_SOCKET)
	{
		m_dwLastError = WSAEALREADY;
		return false; // Must close this socket first
	}

	m_socket = WSASocket(af, st, proto, NULL, 0,
		wFlags | m_dwCreateFlags);
	if (m_socket == INVALID_SOCKET)
	{
		m_dwLastError = ::WSAGetLastError();
		bRet = false;
	}
	else
		bRet = Init(m_socket, NULL);
	return bRet;
}

inline bool ZEvtSyncSocket::Connect(LPCTSTR szAddr, unsigned short nPort) 
{
	if (m_bConnected)
		return true;

	bool bRet = true;
	CTCPAddrLookup address;
	if (SOCKET_ERROR == address.GetRemoteAddr(szAddr, nPort))
	{
		m_dwLastError = WSAGetLastError();
		bRet = false;
	}
	else
	{
		bRet = Connect(address.Addr);
	}
	return bRet;
}

inline bool ZEvtSyncSocket::Connect(const SOCKADDR* psa) 
{
	if (m_bConnected)
		return true; // already connected

	DWORD dwLastError;
	bool bRet = true;

	// if you try to connect the socket without
	// creating it first it's reasonable to automatically
	// try the create for you.
	if (m_socket == INVALID_SOCKET &&
		!Create())
		return false;

	if (WSAConnect(m_socket, 
		psa, sizeof(SOCKADDR),
		NULL, NULL, NULL, NULL))
	{
		dwLastError = WSAGetLastError();
		if (dwLastError != WSAEWOULDBLOCK)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
		else
		{
			dwLastError = WaitForSingleObject((HANDLE)m_hEventConnect, 10000);
			if (dwLastError == WAIT_OBJECT_0)
			{
				// make sure there were no connection errors.
				WSANETWORKEVENTS wse;
				ZeroMemory(&wse, sizeof(wse));
				WSAEnumNetworkEvents(m_socket, NULL, &wse);
				if (wse.iErrorCode[FD_CONNECT_BIT]!=0)
				{
					m_dwLastError = (DWORD)(wse.iErrorCode[FD_CONNECT_BIT]);
					return false;
				}
			}
		}

	}

	m_bConnected = bRet;
	return bRet;
}

inline bool ZEvtSyncSocket::Write(WSABUF *pBuffers, int nCount, DWORD *pdwSize) 
{
	// if we aren't already connected we'll wait to see if the connect
	// event happens
	if (WAIT_OBJECT_0 != WaitForSingleObject((HANDLE)m_hEventConnect , m_dwSocketTimeout))
	{
		m_dwLastError = WSAENOTCONN;
		return false; // not connected
	}

	// make sure we aren't already writing
	if (WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_hEventWrite, 0))
	{
		m_dwLastError = WSAEINPROGRESS;
		return false; // another write on is blocking this socket
	}

	bool bRet = true;
	*pdwSize = 0;
	WSAOVERLAPPED o;
	m_csWrite.Lock();
	o.hEvent = m_hEventWrite;
	WSAResetEvent(o.hEvent);
	if (WSASend(m_socket, pBuffers, nCount, pdwSize, 0, &o, 0))
	{	
		DWORD dwLastError = WSAGetLastError();
		if (dwLastError != WSA_IO_PENDING)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
	}
	
	// wait for write to complete
	if (bRet && WAIT_OBJECT_0 == WaitForSingleObject((HANDLE)m_hEventWrite, m_dwSocketTimeout))
	{
		DWORD dwFlags = 0;
		if (WSAGetOverlappedResult(m_socket, &o, pdwSize, FALSE, &dwFlags))
			bRet = true;
		else
		{
			m_dwLastError = ::GetLastError();
			bRet = false;
		}
	}
	
	m_csWrite.Unlock();
	return bRet;

}

inline bool ZEvtSyncSocket::Write(const unsigned char *pBuffIn, DWORD *pdwSize) 
{
	WSABUF buff;
	buff.buf = (char*)pBuffIn;
	buff.len = *pdwSize;
	return Write(&buff, 1, pdwSize);
}

inline bool ZEvtSyncSocket::Read(const unsigned char *pBuff, DWORD *pdwSize) 
{
	// if we aren't already connected we'll wait to see if the connect
	// event happens
	if (WAIT_OBJECT_0 != WaitForSingleObject((HANDLE)m_hEventConnect , m_dwSocketTimeout))
	{
		m_dwLastError = WSAENOTCONN;
		return false; // not connected
	}

	if (WAIT_ABANDONED == WaitForSingleObject((HANDLE)m_hEventRead, 0))
	{
		m_dwLastError = WSAEINPROGRESS;
		return false; // another write on is blocking this socket
	}

	bool bRet = true;
	WSABUF buff;
	buff.buf = (char*)pBuff;
	buff.len = *pdwSize;
	*pdwSize = 0;
	DWORD dwFlags = 0;
	WSAOVERLAPPED o;
	ZeroMemory(&o, sizeof(o));

	// protect against re-entrency
	m_csRead.Lock();
	o.hEvent = m_hEventRead;
	WSAResetEvent(o.hEvent);
	if (WSARecv(m_socket, &buff, 1, pdwSize, &dwFlags, &o, 0))
	{
		DWORD dwLastError = WSAGetLastError();
		if (dwLastError != WSA_IO_PENDING)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
	}

	// wait for the read to complete
	if (bRet && WAIT_OBJECT_0 == WaitForSingleObject((HANDLE)o.hEvent, m_dwSocketTimeout))
	{
		dwFlags = 0;
		if (WSAGetOverlappedResult(m_socket, &o, pdwSize, FALSE, &dwFlags))
			bRet = true;
		else
		{
			m_dwLastError = ::GetLastError();
			bRet = false;
		}

	}

	m_csRead.Unlock();
	return bRet;
}

inline bool ZEvtSyncSocket::Init(SOCKET hSocket, void * /*pData=NULL*/) 
{
	ATLASSERT(hSocket != INVALID_SOCKET);

	if (hSocket == INVALID_SOCKET)
	{
		m_dwLastError = WSAENOTSOCK;
		return false;
	}

	m_socket = hSocket;
	
	// Allocate Events. On error, any open event handles will be closed
	// in the destructor
	if (NULL != (m_hEventRead = WSACreateEvent()))
		if (NULL != (m_hEventWrite = WSACreateEvent()))
			if (NULL != (m_hEventConnect = WSACreateEvent()))
	{
		if (!WSASetEvent(m_hEventWrite) || !WSASetEvent(m_hEventRead))
		{
			m_dwLastError = ::GetLastError();
			return false;
		}

		if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventRead, FD_READ))
			if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventWrite, FD_WRITE))
				if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventConnect, FD_CONNECT))
					return true;
	}
	m_dwLastError = ::GetLastError();
	return false;
}

inline DWORD ZEvtSyncSocket::GetSocketTimeout()
{
	return m_dwSocketTimeout;
}

inline DWORD ZEvtSyncSocket::SetSocketTimeout(DWORD dwNewTimeout)
{
	DWORD dwOldTimeout = m_dwSocketTimeout;
	m_dwSocketTimeout = dwNewTimeout;
	return dwOldTimeout;
}

inline bool ZEvtSyncSocket::SupportsScheme(ATL_URL_SCHEME scheme)
{
	// default only supports HTTP
	return scheme == ATL_URL_SCHEME_HTTP ? true : false;
}

inline CTCPAddrLookup::CTCPAddrLookup() 
{
	m_pQuerySet = NULL;
	m_pAddr = NULL;
	ZeroMemory(&m_saIn, sizeof(m_saIn));
	m_saIn.sin_family = PF_INET;
	m_saIn.sin_zero[0] = 0;
	m_saIn.sin_addr.s_addr = INADDR_NONE;
	m_nAddrSize = sizeof(m_saIn);
}

inline CTCPAddrLookup::~CTCPAddrLookup() 
{
	if (m_pQuerySet)
		free ((void*)m_pQuerySet);
}

inline int CTCPAddrLookup::GetRemoteAddr(LPCTSTR szName, short nPort) 
{
	int nErr = WSAEFAULT;

	m_nAddrSize = sizeof(m_saIn);
	// first try for the dotted IP address
	if (SOCKET_ERROR != WSAStringToAddress(	(LPTSTR)szName,
											AF_INET,
											NULL,
											(SOCKADDR*)&m_saIn,
											&m_nAddrSize))
	{
		// Address was a dotted IP address
		m_saIn.sin_port = htons(nPort);
		m_pAddr = (SOCKADDR*)&m_saIn;
		return 0;
	}

	// else, try to lookup the service
	m_nAddrSize = 0;
	ATLTRY(m_pQuerySet = (WSAQUERYSET*)malloc(ATL_MAX_QUERYSET));
	if (m_pQuerySet)
	{
		ZeroMemory(m_pQuerySet, sizeof(WSAQUERYSET));
		GUID guidsvc = SVCID_TCP(nPort);
		AFPROTOCOLS afinet = {PF_INET, IPPROTO_TCP};
		m_pQuerySet->dwSize = sizeof(WSAQUERYSET);
		m_pQuerySet->dwNameSpace = NS_ALL;
		m_pQuerySet->lpafpProtocols = &afinet;
		m_pQuerySet->dwNumberOfProtocols = 1;
		m_pQuerySet->lpServiceClassId = &guidsvc;
		m_pQuerySet->lpszServiceInstanceName = (LPTSTR)szName;
		DWORD dwSize = ATL_MAX_QUERYSET;
		HANDLE hLookup = NULL;

		if (SOCKET_ERROR != WSALookupServiceBegin(m_pQuerySet, LUP_RETURN_ADDR, &hLookup))
		{
			ATLASSERT(hLookup != NULL);

			if (SOCKET_ERROR != WSALookupServiceNext(hLookup, 0, (DWORD*)&dwSize, m_pQuerySet))
			{
				m_pAddr = m_pQuerySet->lpcsaBuffer[0].RemoteAddr.lpSockaddr;
				m_nAddrSize = m_pQuerySet->lpcsaBuffer[0].RemoteAddr.iSockaddrLength;
				nErr = 0;
			}
			else
				nErr = (int)GetLastError();
			WSALookupServiceEnd(hLookup);
		}
	}

	if (nErr != 0)
	{
		if (m_pQuerySet)
		{
			free(m_pQuerySet);
			m_pQuerySet = NULL;
		}
	
		m_pAddr = NULL;
		m_nAddrSize = 0;
	}
	return nErr;
}


inline const SOCKADDR* CTCPAddrLookup::GetSockAddr()
{
	return const_cast<const SOCKADDR*>(m_pAddr);
}

inline int CTCPAddrLookup::GetSockAddrSize()
{
	return m_nAddrSize;
}

#endif // __ATLSPRIV_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlstencilres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlstencil.rc
//
#define IDS_ATLSTENCIL_ERROR            101
#define ATLSTENCIL_RESID_BASE           0x6200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlstr.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTR_H__
#define __ATLSTR_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlbase.h>

#include <winnls.h>
#include <limits.h>

#include <cstringt.h>

namespace ATL
{

extern CAtlStringMgr g_strmgr;

template< typename _BaseType = char, class StringIterator = ChTraitsOS< _BaseType > >
class StrTraitATL : public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance(UINT /* nID */) throw()
	{
		return( _AtlBaseModule.GetResourceInstance() );
	}

	static IAtlStringMgr* GetDefaultManager() throw()
	{
		return( &g_strmgr );
	}
};

#if !defined(_ATL_CSTRING_NO_CRT) && defined(_ATL_MIN_CRT)
#define _ATL_CSTRING_NO_CRT
#endif

#ifndef _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t, ChTraitsCRT< wchar_t > > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char, ChTraitsCRT< char > > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR, ChTraitsCRT< TCHAR > > > CAtlString;
#else  // _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR > > CAtlString;
#endif  // _ATL_CSTRING_NO_CRT

#ifndef _AFX
typedef CAtlStringW CStringW;
typedef CAtlStringA CStringA;
typedef CAtlString CString;
#endif

#ifdef __ATLCOLL_H__

template<>
class CElementTraits< ATL::CAtlStringA > :
	public CStringElementTraits< ATL::CAtlStringA >
{
};

template<>
class CElementTraits< ATL::CAtlStringW > :
	public CStringElementTraits< ATL::CAtlStringW >
{
};

#endif  // __ATLCOLL_H__

}; //namespace ATL

#endif // __ATLSTR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsrvres.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// Used by atlsrv.rc
//
#ifndef ATLSRV_RESID_BASE
#define ATLSRV_RESID_BASE 	0x6000
#endif

#ifndef PERFMON_RESID_BASE
#define PERFMON_RESID_BASE   0x6100
#endif

#define IDS_ATLSRV_BAD_REQUEST          (ATLSRV_RESID_BASE+1)
#define IDS_ATLSRV_AUTH_REQUIRED        (ATLSRV_RESID_BASE+2)
#define IDS_ATLSRV_FORBIDDEN            (ATLSRV_RESID_BASE+3)
#define IDS_ATLSRV_NOT_FOUND            (ATLSRV_RESID_BASE+4)
#define IDS_ATLSRV_SERVER_ERROR         (ATLSRV_RESID_BASE+5)
#define IDS_ATLSRV_NOT_IMPLEMENTED      (ATLSRV_RESID_BASE+6)
#define IDS_ATLSRV_BAD_GATEWAY          (ATLSRV_RESID_BASE+7)
#define IDS_ATLSRV_SERVICE_NOT_AVAILABLE (ATLSRV_RESID_BASE+8)
#define IDS_ATLSRV_SERVER_ERROR_BADSRF (ATLSRV_RESID_BASE+9)
#define IDS_ATLSRV_SERVER_ERROR_HNDLFAIL (ATLSRV_RESID_BASE+10)
#define IDS_ATLSRV_SERVER_ERROR_SYSOBJFAIL (ATLSRV_RESID_BASE+11)
#define IDS_ATLSRV_SERVER_ERROR_READFILEFAIL (ATLSRV_RESID_BASE+12)
#define IDS_ATLSRV_SERVER_ERROR_LOADLIB (ATLSRV_RESID_BASE+13)
#define IDS_ATLSRV_SERVER_ERROR_HANDLERIF (ATLSRV_RESID_BASE+14)
#define IDS_ATLSRV_SERVER_ERROR_OUTOFMEM (ATLSRV_RESID_BASE+15)
#define IDS_ATLSRV_SERVER_ERROR_UNEXPECTED	(ATLSRV_RESID_BASE+16)
#define IDS_ATLSRV_SERVER_ERROR_STENCILPARSEFAIL (ATLSRV_RESID_BASE+17)
#define IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL (ATLSRV_RESID_BASE+18)
#define IDS_ATLSRV_SERVER_ERROR_HANDLERNOTFOUND (ATLSRV_RESID_BASE+19)
#define IDS_ATLSRV_SERVER_ERROR_BADHANDLERTAG (ATLSRV_RESID_BASE+20)
#define IDS_ATLSRV_SERVER_ERROR_NOHANDLERTAG (ATLSRV_RESID_BASE+21)
#define IDS_ATLSRV_SERVER_ERROR_LONGMETHODNAME (ATLSRV_RESID_BASE+22)
#define IDS_ATLSRV_SERVER_ERROR_LONGHANDLERNAME (ATLSRV_RESID_BASE+23)
#define IDS_ATLSRV_SERVER_ERROR_IMPERSONATIONFAILED (ATLSRV_RESID_BASE+24)
#define IDS_ATLSRV_SERVER_ERROR_ISAPISTARTUPFAILED (ATLSRV_RESID_BASE+25)
#define IDS_ATLSRV_SERVER_ERROR_LOADFILEFAIL (ATLSRV_RESID_BASE+26)
#define IDS_PERFMON_CACHE                       (PERFMON_RESID_BASE+1)
#define IDS_PERFMON_CACHE_HELP                  (PERFMON_RESID_BASE+2)
#define IDS_PERFMON_HITCOUNT                    (PERFMON_RESID_BASE+3)
#define IDS_PERFMON_HITCOUNT_HELP               (PERFMON_RESID_BASE+4)
#define IDS_PERFMON_MISSCOUNT                   (PERFMON_RESID_BASE+5)
#define IDS_PERFMON_MISSCOUNT_HELP              (PERFMON_RESID_BASE+6)
#define IDS_PERFMON_CURRENTALLOCATIONS          (PERFMON_RESID_BASE+7)
#define IDS_PERFMON_CURRENTALLOCATIONS_HELP     (PERFMON_RESID_BASE+8)
#define IDS_PERFMON_MAXALLOCATIONS              (PERFMON_RESID_BASE+9)
#define IDS_PERFMON_MAXALLOCATIONS_HELP         (PERFMON_RESID_BASE+10)
#define IDS_PERFMON_CURRENTENTRIES              (PERFMON_RESID_BASE+11)
#define IDS_PERFMON_CURRENTENTRIES_HELP         (PERFMON_RESID_BASE+12)
#define IDS_PERFMON_MAXENTRIES                  (PERFMON_RESID_BASE+13)
#define IDS_PERFMON_MAXENTRIES_HELP             (PERFMON_RESID_BASE+14)
#define IDS_PERFMON_HITCOUNTRATE                (PERFMON_RESID_BASE+15)
#define IDS_PERFMON_HITCOUNTRATE_HELP           (PERFMON_RESID_BASE+16)

#define IDS_PERFMON_REQUEST						(PERFMON_RESID_BASE+17)
#define IDS_PERFMON_REQUEST_HELP				(PERFMON_RESID_BASE+18)
#define IDS_PERFMON_REQUEST_TOTAL				(PERFMON_RESID_BASE+19)
#define IDS_PERFMON_REQUEST_TOTAL_HELP			(PERFMON_RESID_BASE+20)
#define IDS_PERFMON_REQUEST_FAILED				(PERFMON_RESID_BASE+21)
#define IDS_PERFMON_REQUEST_FAILED_HELP			(PERFMON_RESID_BASE+22)
#define IDS_PERFMON_REQUEST_RATE				(PERFMON_RESID_BASE+23)
#define IDS_PERFMON_REQUEST_RATE_HELP			(PERFMON_RESID_BASE+24)
#define IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME		(PERFMON_RESID_BASE+25)
#define IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME_HELP	(PERFMON_RESID_BASE+26)
#define IDS_PERFMON_REQUEST_CURR_WAITING (PERFMON_RESID_BASE+27)
#define IDS_PERFMON_REQUEST_CURR_WAITING_HELP	(PERFMON_RESID_BASE+28)
#define IDS_PERFMON_REQUEST_MAX_WAITING (PERFMON_RESID_BASE+29)
#define IDS_PERFMON_REQUEST_MAX_WAITING_HELP	(PERFMON_RESID_BASE+30)
#define IDS_PERFMON_REQUEST_ACTIVE_THREADS		(PERFMON_RESID_BASE+31)
#define IDS_PERFMON_REQUEST_ACTIVE_THREADS_HELP	(PERFMON_RESID_BASE+32)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlsync.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLSYNC_INL__
#define __ATLSYNC_INL__

#pragma once

#ifndef __ATLSYNC_H__
	#error atlsync.inl requires atlsync.h to be included first
#endif

namespace ATL
{

inline CCriticalSection::CCriticalSection()
{
	__try
	{
		::InitializeCriticalSection( this );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

#if (_WIN32_WINNT >= 0x0403)
inline CCriticalSection::CCriticalSection( ULONG nSpinCount )
{
	__try
	{
		::InitializeCriticalSectionAndSpinCount( this, nSpinCount );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}
#endif

inline CCriticalSection::~CCriticalSection()
{
	::DeleteCriticalSection( this );
}

inline void CCriticalSection::Enter()
{
	__try
	{
		::EnterCriticalSection( this );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline void CCriticalSection::Leave()
{
	::LeaveCriticalSection( this );
}

#if (_WIN32_WINNT >= 0x0403)
inline ULONG CCriticalSection::SetSpinCount( ULONG nSpinCount )
{
	return( ::SetCriticalSectionSpinCount( this, nSpinCount ) );
}
#endif

#if(_WIN32_WINNT >= 0x0400)
inline BOOL CCriticalSection::TryEnter()
{
	return( ::TryEnterCriticalSection( this ) );
}
#endif

inline CEvent::CEvent()
{
}

inline CEvent::CEvent( CEvent& hEvent ) :
	CHandle( hEvent )
{
}

inline CEvent::CEvent( BOOL bManualReset, BOOL bInitialState )
{
	BOOL bSuccess;
	
	bSuccess = Create( NULL, bManualReset, bInitialState, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CEvent::CEvent( LPSECURITY_ATTRIBUTES pAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName )
{
	BOOL bSuccess;

	bSuccess = Create( pAttributes, bManualReset, bInitialState, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}


inline CEvent::CEvent( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CEvent::Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateEvent( pSecurity, bManualReset, bInitialState, pszName );

	return( m_h != NULL );
}

inline BOOL CEvent::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenEvent( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CEvent::Pulse()
{
	ATLASSERT( m_h != NULL );

	return( ::PulseEvent( m_h ) );
}

inline BOOL CEvent::Reset()
{
	ATLASSERT( m_h != NULL );

	return( ::ResetEvent( m_h ) );
}

inline BOOL CEvent::Set()
{
	ATLASSERT( m_h != NULL );

	return( ::SetEvent( m_h ) );
}


inline CMutex::CMutex()
{
}

inline CMutex::CMutex( CMutex& hMutex ) :
	CHandle( hMutex )
{
}

inline CMutex::CMutex( BOOL bInitialOwner )
{
	BOOL bSuccess;

	bSuccess = Create( NULL, bInitialOwner, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName )
{
	BOOL bSuccess;

	bSuccess = Create( pSecurity, bInitialOwner, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CMutex::Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateMutex( pSecurity, bInitialOwner, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenMutex( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Release()
{
	ATLASSERT( m_h != NULL );

	return( ::ReleaseMutex( m_h ) );
}


inline CSemaphore::CSemaphore()
{
}

inline CSemaphore::CSemaphore( CSemaphore& hSemaphore ) :
	CHandle( hSemaphore )
{
}

inline CSemaphore::CSemaphore( LONG nInitialCount, LONG nMaxCount )
{
	BOOL bSuccess;

	bSuccess = Create( NULL, nInitialCount, nMaxCount, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CSemaphore::CSemaphore( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName )
{
	BOOL bSuccess;
	
	bSuccess = Create( pSecurity, nInitialCount, nMaxCount, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}


inline CSemaphore::CSemaphore( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CSemaphore::Create( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateSemaphore( pSecurity, nInitialCount, nMaxCount, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenSemaphore( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Release( LONG nReleaseCount, LONG* pnOldCount )
{
	ATLASSERT( m_h != NULL );

	return( ::ReleaseSemaphore( m_h, nReleaseCount, pnOldCount ) );
}


inline CMutexLock::CMutexLock( CMutex& mtx, bool bInitialLock ) :
	m_mtx( mtx ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		Lock();
	}
}

inline CMutexLock::~CMutexLock()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

inline void CMutexLock::Lock()
{
	DWORD dwResult;

	ATLASSERT( !m_bLocked );
	dwResult = ::WaitForSingleObject( m_mtx, INFINITE );
	if( dwResult == WAIT_ABANDONED )
	{
		ATLTRACE(atlTraceSync, 0, _T("Warning: abandoned mutex 0x%x\n"), (HANDLE)m_mtx);
	}
	m_bLocked = true;
}

inline void CMutexLock::Unlock()
{
	ATLASSERT( m_bLocked );

	m_mtx.Release();
}

};  // namespace ATL

#endif  // __ATLSYNC_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atltmp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// atltmp.h - temporary location for these classes


#pragma message("ATLTMP.H is obsolete. Please fix your build")
#pragma message("to use ATLTYPES and AFXSTR directly.")

namespace ATL
{
#include <atltypes.h>
};

#include <afxstr.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atlstencil.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTENCIL_H__
#define __ATLSTENCIL_H__

#pragma once

#ifdef _ATL_MIN_CRT
#error "_ATL_MIN_CRT cannot be used with atlstencil.h"
#endif

#include <atlisapi.h>
#include <atlfile.h>
#include <atlutil.h>

#ifndef ATL_NO_MLANG
#include <mlang.h>
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "shlwapi.lib")
#endif // !_ATL_NO_DEFAULT_LIBS

#pragma warning( push )
#pragma warning( disable: 4127 )
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#pragma warning(disable: 4702) // assignment operator could not be generated

namespace ATL {

// Token types
// These tags are token tags for the standard tag replacer implementation
extern __declspec(selectany) const DWORD STENCIL_TEXTTAG             = 0x00000000;
extern __declspec(selectany) const DWORD STENCIL_REPLACEMENT         = 0x00000001;
extern __declspec(selectany) const DWORD STENCIL_ITERATORSTART       = 0x00000002;
extern __declspec(selectany) const DWORD STENCIL_ITERATOREND         = 0x00000003;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALSTART    = 0x00000004;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALELSE     = 0x00000005;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALEND      = 0x00000006;
extern __declspec(selectany) const DWORD STENCIL_STENCILINCLUDE      = 0x00000007;
extern __declspec(selectany) const DWORD STENCIL_STATICINCLUDE       = 0x00000008;
extern __declspec(selectany) const DWORD STENCIL_LOCALE              = 0x00000009;
extern __declspec(selectany) const DWORD STENCIL_CODEPAGE            = 0x0000000a;

// The base for user defined token types
extern __declspec(selectany) const DWORD STENCIL_USER_TOKEN_BASE     = 0x00001000;
   
// Symbols to use in error handling in the stencil processor
#define STENCIL_INVALIDINDEX            0xFFFFFFFF
#define STENCIL_INVALIDOFFSET           0xFFFFFFFF

// error codes
#define STENCIL_SUCCESS     HTTP_SUCCESS
#define STENCL_FAIL         HTTP_FAIL

#define STENCIL_BASIC_MAP 0
#define STENCIL_ATTR_MAP 1

#ifndef ATL_MAX_METHOD_NAME_LEN
    #define ATL_MAX_METHOD_NAME_LEN 64
#endif

#ifndef ATL_MAX_BLOCK_STACK
    #define ATL_MAX_BLOCK_STACK 128
#endif

template <class TBase, typename T>
struct CTagReplacerMethodsEx
{
    typedef HTTP_CODE (TBase::*REPLACE_FUNC)();
    typedef HTTP_CODE (TBase::*REPLACE_FUNC_EX)(T*);
    typedef HTTP_CODE (TBase::*PARSE_FUNC)(IAtlMemMgr *, LPCSTR, T**);
    typedef HTTP_CODE (TBase::*REPLACE_FUNC_EX_V)(void *);
    typedef HTTP_CODE (TBase::*PARSE_FUNC_V)(IAtlMemMgr *, LPCSTR, void**);

    static REPLACE_FUNC_EX_V CheckRepl(REPLACE_FUNC p) throw()
    {
        return (REPLACE_FUNC_EX_V) p;
    }

    static REPLACE_FUNC_EX_V CheckReplEx(REPLACE_FUNC_EX p) throw()
    {
        return (REPLACE_FUNC_EX_V) p;
    }

    static PARSE_FUNC_V CheckParse(PARSE_FUNC p) throw()
    {
        return (PARSE_FUNC_V) p;
    }
};

template <class TBase>
struct CTagReplacerMethods
{
    union
    {
    HTTP_CODE (TBase::*pfnMethodEx)(void *);
    HTTP_CODE (TBase::*pfnMethod)();
    };
    HTTP_CODE (TBase::*pfnParse)(IAtlMemMgr *pMemMgr, LPCSTR, void **);
};

#define REPLACEMENT_ENTRY_DEFAULT   0
#define REPLACEMENT_ENTRY_ARGS      1

template <class TBase>
struct CTagReplacerMethodEntry
{
    int nType;  // REPLACEMENT_ENTRY_*
    LPCSTR szMethodName;
    CTagReplacerMethods<TBase> Methods;
};


#define BEGIN_REPLACEMENT_METHOD_MAP(className)\
public:\
    void GetReplacementMethodMap(const ATL::CTagReplacerMethodEntry<className> ** ppOut) const throw()\
    {\
        typedef className __className;\
        static const ATL::CTagReplacerMethodEntry<className> methods[] = {

#define REPLACEMENT_METHOD_ENTRY(methodName, methodFunc)\
    { 0, methodName,  {  ATL::CTagReplacerMethodsEx<__className, void>::CheckRepl(methodFunc), NULL }   },

#define REPLACEMENT_METHOD_ENTRY_EX(methodName, methodFunc, paramType, parseFunc)\
    { 1, methodName,  { ATL::CTagReplacerMethodsEx<__className, paramType>::CheckReplEx(methodFunc), ATL::CTagReplacerMethodsEx<__className, paramType>::CheckParse(parseFunc) } },

#define REPLACEMENT_METHOD_ENTRY_EX_STR(methodName, methodFunc) \
    { 1, methodName,  { ATL::CTagReplacerMethodsEx<__className, char>::CheckReplEx(methodFunc), ATL::CTagReplacerMethodsEx<__className, char>::CheckParse(DefaultParseString) } },

#define END_REPLACEMENT_METHOD_MAP()\
        { 0, NULL, NULL } };\
        *ppOut = methods;\
    }

#define BEGIN_ATTR_REPLACEMENT_METHOD_MAP(className)\
public:\
    void GetAttrReplacementMethodMap(const CTagReplacerMethodEntry<className> ** ppOut) const throw()\
    {\
        typedef className __className;\
        static const ATL::CTagReplacerMethodEntry<className> methods[] = {

#define END_ATTR_REPLACEMENT_METHOD_MAP()\
        { NULL, NULL, NULL } };\
        *ppOut = methods;\
    }

template <class T>
class ITagReplacerImpl : public ITagReplacer
{
protected:
    IWriteStream *m_pStream;

public:
    typedef HTTP_CODE (T::*REPLACEMENT_METHOD)();
    typedef HTTP_CODE (T::*REPLACEMENT_METHOD_EX)(void *pvParam);

    ITagReplacerImpl() throw()
        :m_pStream(NULL)
    {
    }

    IWriteStream *SetStream(IWriteStream *pStream) throw()
    {
        IWriteStream *pRetStream = m_pStream;
        m_pStream = pStream;
        return pRetStream;
    }

    // Looks up the replacement method offset. Optionally, it will 
    // look up the replacement method and object offset of an alternate
    // tag replacer.
    HTTP_CODE FindReplacementOffset(
        LPCSTR szMethodName,
        DWORD *pdwMethodOffset,
        LPCSTR szHandlerName,
        DWORD *pdwHandlerOffset,
        DWORD *pdwMap, void **ppvParam, IAtlMemMgr *pMemMgr) throw(...)
    {
        // we at least have to be looking up a method offset
        if (!pdwMethodOffset || !szMethodName)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        *pdwMethodOffset = STENCIL_INVALIDOFFSET;
        HTTP_CODE hcErr = HTTP_FAIL;
        T *pT = static_cast<T *>(this);

        char szName[ATL_MAX_METHOD_NAME_LEN];

        // if a handler name was supplied, we will try to
        // find a different object to handle the method
        if (szHandlerName && *szHandlerName)
        {
            if (!pdwHandlerOffset)
                return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

            hcErr = pT->GetHandlerOffset(szHandlerName, pdwHandlerOffset);
            // got the alternate handler, now look up the method offset on 
            // the handler.
            if (!hcErr)
            {
                CComPtr<ITagReplacer> spAltTagReplacer;
                hcErr = pT->GetReplacementObject(*pdwHandlerOffset, &spAltTagReplacer);
                if (!hcErr)
                    hcErr = spAltTagReplacer->FindReplacementOffset(szMethodName, pdwMethodOffset,
                        NULL, NULL, pdwMap, ppvParam, pMemMgr);
                return hcErr;
            }
            else
                return hcErr;
        }
        strcpy(szName, szMethodName);

        // check for params
        char *szLeftPar = strchr(szName, '(');
        if (szLeftPar)
        {
            *szLeftPar = '\0';
            szLeftPar++;

            char *szRightPar = strchr(szLeftPar, ')');
            if (!szRightPar)
                return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

            *szRightPar = '\0';

            szMethodName = szName;

        }

        // No handler name is specified, so we look up the method name in
        // T's replacement method map
        const CTagReplacerMethodEntry<T> *pEntry;
        pT->GetReplacementMethodMap(&pEntry);

        hcErr = FindReplacementOffsetInMap(szMethodName, pdwMethodOffset, pEntry);
        if (hcErr != HTTP_SUCCESS)
        {
            pT->GetAttrReplacementMethodMap(&pEntry);
            hcErr = FindReplacementOffsetInMap(szMethodName, pdwMethodOffset, pEntry);
            if (hcErr == HTTP_SUCCESS)
                *pdwMap = STENCIL_ATTR_MAP;
        }
        else
        {
            *pdwMap = STENCIL_BASIC_MAP;
        }

        // This assert will be triggered if arguments are passed to a replacement method that doesn't handle them
        ATLASSERT( szLeftPar == NULL || (szLeftPar != NULL && (pEntry != NULL && pEntry[*pdwMethodOffset].Methods.pfnParse) != NULL) );

        if (hcErr == HTTP_SUCCESS && pEntry && pEntry[*pdwMethodOffset].Methods.pfnParse)
            hcErr = (pT->*pEntry[*pdwMethodOffset].Methods.pfnParse)(pMemMgr, szLeftPar, ppvParam);
        return hcErr;

    }

    HTTP_CODE FindReplacementOffsetInMap(
        LPCSTR szMethodName,
        LPDWORD pdwMethodOffset,
        const CTagReplacerMethodEntry<T> *pEntry) throw()
    {
        if (pEntry == NULL)
            return HTTP_FAIL;

        const CTagReplacerMethodEntry<T> *pEntryHead = pEntry;

        while (pEntry->szMethodName)
        {
            if (strcmp(pEntry->szMethodName, szMethodName) == 0)
            {
                if (pEntry->Methods.pfnMethod)
                {
                    *pdwMethodOffset = (DWORD)(pEntry-pEntryHead);
                    return HTTP_SUCCESS;
                }
            }
            pEntry++;
        }

        return HTTP_FAIL;
    }


    // Used to render a single replacement tag into a stream.
    // Looks up a pointer to a member function in user code by offseting into the users
    // replacement map. Much faster than the other overload of this function since
    // no string compares are performed.
    HTTP_CODE RenderReplacement(DWORD dwFnOffset, DWORD dwObjOffset, DWORD dwMap, void *pvParam) throw(...)
    {
        HTTP_CODE hcErr = HTTP_FAIL;
        T *pT = static_cast<T *>(this);

        // if we were not passed an object offset, then we assume
        // that the function at dwFnOffset is in T's replacement
        // map
        if (dwObjOffset == STENCIL_INVALIDOFFSET)
        {
            // call a function in T's replacement map
            ATLASSERT(dwFnOffset != STENCIL_INVALIDOFFSET);
            const CTagReplacerMethodEntry<T> *pEntry;
            if (dwMap == STENCIL_BASIC_MAP)
                pT->GetReplacementMethodMap(&pEntry);
            else
                pT->GetAttrReplacementMethodMap(&pEntry);
            if (pEntry)
            {
                if (pEntry[dwFnOffset].nType == REPLACEMENT_ENTRY_DEFAULT)
                {
                    REPLACEMENT_METHOD pfn = NULL;
                    pfn = pEntry[dwFnOffset].Methods.pfnMethod;
                    ATLASSERT(pfn);
                    if (pfn)
                    {
                        hcErr = (pT->*pfn)();
                    }
                }
                else if (pEntry[dwFnOffset].nType == REPLACEMENT_ENTRY_ARGS)
                {
                    REPLACEMENT_METHOD_EX pfn = NULL;
                    pfn = pEntry[dwFnOffset].Methods.pfnMethodEx;
                    ATLASSERT(pfn);
                    if (pfn)
                    {
                        hcErr = (pT->*pfn)(pvParam);
                    }
                }
                else
                {
                    // unknown entry type
                    ATLASSERT(FALSE);
                }
            }
        }
        else
        {
            // otherwise, we were passed an object offset. The object
            // offset is a dword ID that T can use to look up the
            // ITagReplacer* of a tag replacer that will render this
            // replacement.
            CComPtr<ITagReplacer> spAltReplacer = NULL;
            if (!pT->GetReplacementObject(dwObjOffset, &spAltReplacer))
            {
                spAltReplacer->SetStream(m_pStream);
                hcErr = spAltReplacer->RenderReplacement(dwFnOffset, STENCIL_INVALIDOFFSET, dwMap, pvParam);
            }
        }
        return hcErr;
    }

    // Default GetHandlerOffset, does nothing
    HTTP_CODE GetHandlerOffset(LPCSTR /*szHandlerName*/, DWORD* pdwOffset) throw()
    {
        if (pdwOffset)
            *pdwOffset = 0;
        return HTTP_FAIL;
    }

    // Default GetReplacementObject, does nothing
    HTTP_CODE GetReplacementObject(DWORD /*dwObjOffset*/, ITagReplacer **ppReplacer) throw()
    {
        if (ppReplacer)
            *ppReplacer = NULL;
        return HTTP_FAIL;
    }

    void GetReplacementMethodMap(const CTagReplacerMethodEntry<T> ** ppOut) const throw()
    {
        static const CTagReplacerMethodEntry<T> methods[] = { { NULL, NULL } };
        *ppOut = methods;
    }

    void GetAttrReplacementMethodMap(const CTagReplacerMethodEntry<T> **ppOut) const throw()
    {
        static const CTagReplacerMethodEntry<T> methods[] = { { NULL, NULL } };
        *ppOut = methods;
    }

    HRESULT GetContext(REFIID, void**) throw()
    {
        return E_NOINTERFACE;
    }

    HTTP_CODE FreeParam(void * /*pvParam*/) throw()
    {
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseString(IAtlMemMgr *pMemMgr, LPCSTR szParams, char **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        size_t nLen = strlen(szParams);
        if (nLen)
        {
            nLen++;
            *ppParam = (char *) pMemMgr->Allocate(nLen);
            if (*ppParam)
                memcpy(*ppParam, szParams, nLen);
            else
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUChar(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned char **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned char *) pMemMgr->Allocate(sizeof(unsigned char));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = (unsigned char) strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseShort(IAtlMemMgr *pMemMgr, LPCSTR szParams, short **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (short *) pMemMgr->Allocate(sizeof(short));
        if (*ppParam)
        {
            **ppParam = (short)atoi(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUShort(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned short **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned short *) pMemMgr->Allocate(sizeof(short));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = (unsigned short) strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseInt(IAtlMemMgr *pMemMgr, LPCSTR szParams, int **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (int *) pMemMgr->Allocate(sizeof(int));
        if (*ppParam)
        {
            **ppParam = atoi(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUInt(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned int **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned int *) pMemMgr->Allocate(sizeof(unsigned int));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseInt64(IAtlMemMgr *pMemMgr, LPCSTR szParams, __int64 **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (__int64 *) pMemMgr->Allocate(sizeof(__int64));
        if (*ppParam)
        {
            **ppParam = _atoi64(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUInt64(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned __int64 **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned __int64 *) pMemMgr->Allocate(sizeof(unsigned __int64));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = _strtoui64(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseBool(IAtlMemMgr *pMemMgr, LPCSTR szParams, bool **ppParam) throw(...)
    {
        ATLASSERT(szParams);
        
        *ppParam = (bool *) pMemMgr->Allocate(sizeof(bool));
        if (*ppParam)
        {
            if (!_strnicmp(szParams, "true", sizeof("true")-sizeof('\0')))
                **ppParam = true;
            else
                **ppParam = false;
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseDouble(IAtlMemMgr *pMemMgr, LPCSTR szParams, double **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (double *) pMemMgr->Allocate(sizeof(double));
        if (*ppParam)
        {
            **ppParam = atof(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseFloat(IAtlMemMgr *pMemMgr, LPCSTR szParams, float **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (float *) pMemMgr->Allocate(sizeof(float));
        if (*ppParam)
        {
            **ppParam = (float) atof(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }
};

inline LPSTR SkipSpace(LPSTR sz, WORD nCodePage)
{
    while (_istspace(*sz))
        sz = CharNextExA(nCodePage, sz, 0);
    return sz;
}

inline LPSTR RSkipSpace(LPSTR pStart, LPSTR sz, WORD nCodePage) throw()
{
    while (_istspace(*sz))
        sz = CharPrevExA(nCodePage, pStart, sz, 0);
    return sz;
}

//
// StencilToken
// The stencil class will create an array of these tokens during the parse
// phase and use them during rendering to render the stencil
struct StencilToken
{
    LPSTR pStart; // Start of fragment to be rendered
    LPSTR pEnd; // End of fragment to be rendered
    DWORD type; // Type of token
    DWORD dwFnOffset; // Offset into the replacement map for the handler function.
    DWORD dwMap;
    DWORD dwObjOffset; // An identifier for the caller to use in identifiying the
                       // object that will render this token.
    CHAR szHandlerName[ATL_MAX_HANDLER_NAME_LEN + 1]; // Name of handler object. 
    CHAR szMethodName[ATL_MAX_METHOD_NAME_LEN + 1]; // Name of handler method.
    DWORD dwLoopIndex; // Offset into array of StencilTokens of the other loop tag
	DWORD_PTR dwData;
    BOOL bDynamicAlloc;
};


// Specialization of CElementTraitsBase so you can put a StencilToken safely in
// a collection object.
template<>
class CElementTraits< StencilToken > :
    public CElementTraitsBase< StencilToken >
{
public:
	static ULONG Hash( INARGTYPE t ) throw()
    {
        return( ULONG( ULONG_PTR( &t ) ) );
    }

    static bool CompareElements( INARGTYPE element1, INARGTYPE element2 ) throw()
    {
        return( (element1.pStart == element2.pStart) && (element1.pEnd == element2.pEnd) );
    }

    static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 ) throw()
    {
        if( element1.pStart < element2.pStart )
        {
            return( -1 );
        }
        else if( CompareElements(element1,element2) )
        {
            return( 0 );
        }
        else
        {
            ATLASSERT( element1.pStart > element2.pStart );
            return( 1 );
        }
    }
};

//
// Class CStencil
// The CStencil class is used to map in a stencil from a file or resource
// and parse the stencil into an array of StencilTokens. We then render
// the stencil from the array of tokens. This class's parse and render
// functions depend on an IReplacementHandlerLookup interface pointer to be
// passed so it can retrieve the IReplacementHandler interface pointer of the
// handler object that will be called to render replacement tags
class CStencil :
    public IMemoryCacheClient
{
private:
    LPSTR m_pBufferStart; // Beginning of CHAR buffer that holds the stencil.
                          // For mapped files this is the beginning of the mapping.
    LPSTR m_pBufferEnd; // End of CHAR buffer that holds the stencil.
    CAtlArray<StencilToken> m_arrTokens; //An array of tokens.
    FILETIME m_ftLastModified;  // Last modified time (0 for resource)
    FILETIME m_ftLastChecked;   // Last time we retrieved last modified time (0 for resource)
    HCACHEITEM m_hCacheItem;
    WORD m_nCodePage;
    BOOL m_bUseLocaleACP;
    char m_szDllPath[MAX_PATH+1];
    char m_szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];  // Room for the path, the handler
                                                                  // the '/' and the '\0'
#ifdef ATL_DEBUG_STENCILS
    struct ParseError
    {
        char m_szError[256];
        LPCSTR m_szPosition;
        LPCSTR m_szStartLine;
        LPCSTR m_szEndLine;
        int m_nLineNumber;

        bool operator==(const ParseError& that) const throw()
        {
            return (m_nLineNumber == that.m_nLineNumber);
        }
    };

    CSimpleArray<ParseError> m_Errors;

	class CParseErrorProvider : public ITagReplacerImpl<CParseErrorProvider>,
        public CComObjectRootEx<CComSingleThreadModel>           
    {
    public:
        BEGIN_COM_MAP(CParseErrorProvider)
            COM_INTERFACE_ENTRY(ITagReplacer)
        END_COM_MAP()
        CSimpleArray<ParseError> *m_pErrors;
        int m_nCurrentError;

        CParseErrorProvider() throw() :
            m_pErrors(NULL),
            m_nCurrentError(-1)
        {
        }

        void Initialize(CSimpleArray<ParseError> *pErrors) throw()
        {
            m_pErrors = pErrors;
        }

        HTTP_CODE OnGetNextError() throw()
        {
            m_nCurrentError++;
            if (m_nCurrentError >= m_pErrors->GetSize() ||
                m_nCurrentError < 0 )
            {
                m_nCurrentError = -1;
                return HTTP_S_FALSE;
            }
            else
                return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorLineNumber() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            CWriteStreamHelper c(m_pStream);
            if (!c.Write((*m_pErrors)[m_nCurrentError].m_nLineNumber))
				return HTTP_FAIL;

            return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorText() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            CWriteStreamHelper c(m_pStream);

            if (!c.Write((*m_pErrors)[m_nCurrentError].m_szError))
				return HTTP_FAIL;

            return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorLine() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            m_pStream->WriteStream((*m_pErrors)[m_nCurrentError].m_szStartLine, 
                (int)((*m_pErrors)[m_nCurrentError].m_szEndLine - (*m_pErrors)[m_nCurrentError].m_szStartLine), NULL);

            return HTTP_SUCCESS;
        }

        BEGIN_REPLACEMENT_METHOD_MAP(CParseErrorProvider)
            REPLACEMENT_METHOD_ENTRY("GetNextError", OnGetNextError)
            REPLACEMENT_METHOD_ENTRY("GetErrorText", OnGetErrorText)
            REPLACEMENT_METHOD_ENTRY("GetErrorLine", OnGetErrorLine)
            REPLACEMENT_METHOD_ENTRY("GetErrorLineNumber", OnGetErrorLineNumber)
        END_REPLACEMENT_METHOD_MAP()
    };

#else
	bool m_bErrorsOccurred;
#endif

    class CSaveThreadLocale
    {
        LCID m_locale;
    public:
        CSaveThreadLocale() throw()
        {
            m_locale = GetThreadLocale();
        }
        ~CSaveThreadLocale() throw()
        {
            SetThreadLocale(m_locale);
        }
    };

protected:
    ITagReplacer *m_pReplacer;
    IAtlMemMgr *m_pMemMgr;
    static CCRTHeap m_crtHeap;

public:

    enum PARSE_TOKEN_RESULT { INVALID_TOKEN, NORMAL_TOKEN, RESERVED_TOKEN };

    CStencil(IAtlMemMgr *pMemMgr=NULL) throw()
    {
        m_pBufferStart = NULL;
        m_pBufferEnd = NULL;
        m_hCacheItem = NULL;
        m_ftLastModified.dwLowDateTime = 0;
        m_ftLastModified.dwHighDateTime = 0;
        m_ftLastChecked.dwLowDateTime = 0;
        m_ftLastChecked.dwHighDateTime = 0;
        m_arrTokens.SetCount(0, 128);
        m_nCodePage = CP_ACP;
        m_bUseLocaleACP = TRUE;
        m_szHandlerName[0] = '\0';
        m_szDllPath[0] = '\0';
        m_pMemMgr = pMemMgr;
        if (!pMemMgr)
            m_pMemMgr = &m_crtHeap;
#ifdef ATL_DEBUG_STENCILS
//        m_pErrorStencil = NULL;
#else
        m_bErrorsOccurred = false;
#endif

    }

#ifdef ATL_DEBUG_STENCILS

	virtual LPCSTR GetErrorStencil() throw()
	{
		static LPCSTR s_szString = 
			"<h1><font color=#ff0000> While trying to parse a stencil file, "
			"the following errors occurred:</font></h1>\r\n"
			"{{while GetNextError}}"
			"<table border=1 width=50%>\r\n"
			"<tr><td width=25%>Error type</td><td>{{GetErrorText}}</td></tr>\r\n"
			"<tr><td>Line number</td><td>{{GetErrorLineNumber}}</td></tr>\r\n"
			"<tr><td>Error text</td><td><pre>{{GetErrorLine}}</pre></td></tr>\r\n"
			"</table>\r\n"
			"{{endwhile}}"
			"<br>Stencil output follows:\r\n"
			"<hr>";

		return s_szString;
	}

    bool RenderErrors(IWriteStream *pStream) throw(...)
    {
        if (!pStream)
            return false;

		LPCSTR szString = GetErrorStencil();
		if (szString == NULL)
		{
			// assume user doesn't want errors rendered
			return true;
		}

        CComObjectStackEx<CParseErrorProvider> Errors;

        Errors.Initialize(&m_Errors);
		CStencil ErrorStencil;

		HTTP_CODE hcRet = ErrorStencil.LoadFromString(szString, (DWORD)strlen(szString));
        
		if (hcRet != HTTP_SUCCESS)
        {
            return false;
        }

        if (!ErrorStencil.ParseReplacements(static_cast<ITagReplacer *>(&Errors)))
        {
            return false;
        }

        ErrorStencil.FinishParseReplacements();

        HTTP_CODE hcErrorCode = ErrorStencil.Render(static_cast<ITagReplacer *>(&Errors), pStream);
        
        if (HTTP_ERROR_CODE(hcErrorCode) >= 400)
            return false;

        return true;
    }

    bool ParseSuccessful() throw()
    {
        return (m_Errors.GetSize() == 0);
    }

    bool AddError(LPCSTR szErrorText, LPCSTR szPosition) throw()
    {
        int nLineNum = 0;
        LPCSTR szStartLine = NULL;
        LPCSTR szPtr = m_pBufferStart;
        while (szPtr < szPosition)
        {
            if (*szPtr == '\n')
            {
                szStartLine = szPtr + 1;
                nLineNum++;
            }

            LPSTR szNext = CharNextExA(m_nCodePage, szPtr, 0);
            if (szNext == szPtr)
            {
                break;
            }
            szPtr = szNext;
        }
        LPCSTR szEndLine = szPtr;
        while (*szPtr)
        {
            if (*szPtr == '\n')
                break;
            szEndLine = szPtr;
            LPSTR szNext = CharNextExA(m_nCodePage, szPtr, 0);
            if (szNext == szPtr)
            {
                break;
            }
            szPtr = szNext;
        }

        ParseError p;
        strcpy(p.m_szError, szErrorText);
        p.m_szPosition = szPosition;
        p.m_nLineNumber = nLineNum;
        p.m_szStartLine = szStartLine;
        p.m_szEndLine = szEndLine;

        return (m_Errors.Add(p) == TRUE);
    }
#else

    bool ParseSuccessful() throw()
    {
        return m_bErrorsOccurred;
    }

    void AddError(LPCSTR /*szErrorText*/, LPCSTR /*szPosition*/) throw()
    {
        m_bErrorsOccurred = true;
    }
#endif

    // Call Uninitialize if you want to re-use an already initialized CStencil
    void Uninitialize() throw(...)
    {
        int nSize = (int) m_arrTokens.GetCount();
        for (int nIndex = 0; nIndex < nSize; nIndex++)
        {
            if (m_arrTokens[nIndex].bDynamicAlloc)
                delete [] m_arrTokens[nIndex].pStart;
            if (m_arrTokens[nIndex].dwData != 0 && m_arrTokens[nIndex].type != STENCIL_LOCALE)
                m_pMemMgr->Free((void *) m_arrTokens[nIndex].dwData);
        }

        m_arrTokens.RemoveAll();
        if ((m_ftLastModified.dwLowDateTime || m_ftLastModified.dwHighDateTime) && m_pBufferStart)
            delete [] m_pBufferStart;
        m_pBufferStart = NULL;
        m_pBufferEnd = NULL;
    }

    void GetLastModified(FILETIME *pftLastModified) throw()
    {
        ATLASSERT(pftLastModified);
        *pftLastModified = m_ftLastModified;
    }

    void GetLastChecked(FILETIME *pftLastChecked) throw()
    {
        ATLASSERT(pftLastChecked);
        *pftLastChecked = m_ftLastChecked;
    }

    void SetLastChecked(FILETIME *pftLastChecked) throw()
    {
        ATLASSERT(pftLastChecked);
        m_ftLastChecked = *pftLastChecked;
    }

    HCACHEITEM GetCacheItem() throw()
    {
        return m_hCacheItem;
    }

    void SetCacheItem(HCACHEITEM hCacheItem) throw()
    {
        ATLASSERT(m_hCacheItem == NULL);
        m_hCacheItem = hCacheItem;
    }

    void GetHandlerName(LPSTR szDllPath, LPSTR szHandlerName) throw()
    {
        strcpy(szDllPath, m_szDllPath);
        strcpy(szHandlerName, m_szHandlerName);
    }

    // Adds a token to the token array, handler name, method name
    // and handler function offset are optional
    ATL_NOINLINE DWORD AddToken(
        LPSTR pStart,
        LPSTR pEnd,
        DWORD dwType,
        LPCSTR szHandlerName = NULL,
        LPCSTR szMethodName = NULL,
        DWORD dwFnOffset = STENCIL_INVALIDOFFSET,
        DWORD dwObjOffset = STENCIL_INVALIDOFFSET,
        DWORD_PTR dwData = 0,
        DWORD dwMap = 0,
        BOOL bDynamicAlloc = 0) throw()
    {
        StencilToken t;

        memset(&t, 0x00, sizeof(t));

        t.pStart = pStart;
        t.pEnd = pEnd;
        t.type = dwType;
        t.dwLoopIndex = STENCIL_INVALIDINDEX;
        t.dwFnOffset = dwFnOffset;
        t.dwObjOffset = dwObjOffset;
        t.dwData = dwData;
        t.dwMap = dwMap;
        t.bDynamicAlloc = bDynamicAlloc;

        if (szHandlerName && (sizeof(t.szHandlerName) > strlen(szHandlerName)))
            strcpy(t.szHandlerName, szHandlerName);
        else
            t.szHandlerName[0] = '\0';

        if (szMethodName && (sizeof(t.szMethodName) > strlen(szMethodName)))
            strcpy(t.szMethodName, szMethodName);
        else
            t.szMethodName[0] = '\0';

		_ATLTRY
		{
			return (DWORD) m_arrTokens.Add(t);
		}
		_ATLCATCHALL()
		{
			return STENCIL_INVALIDINDEX;
		}
    }

    // maps a stencil file into memory
    HTTP_CODE LoadFile(LPCSTR szFileName) throw()
    {
        HRESULT hr = E_FAIL;
        ULONGLONG dwLen = 0;
        CAtlFile file;

        hr = file.Create(CA2CTEX<MAX_PATH+1>(szFileName), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
        if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
            return HTTP_ERROR(500, ISE_SUBERR_STENCIL_LOAD_FAIL); // couldn't load SRF!

        if (GetFileTime(file, NULL, NULL, &m_ftLastModified))
        {
            if (SUCCEEDED(file.GetSize(dwLen)))
            {
                ATLASSERT(!m_pBufferStart);
            
                GetSystemTimeAsFileTime(&m_ftLastChecked);

                m_pBufferStart = NULL;
                ATLTRY(m_pBufferStart = new CHAR[(UINT) dwLen]);
                if (m_pBufferStart == NULL)
                    return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM); // out of memory

                DWORD dwRead;
                hr = file.Read(m_pBufferStart, (DWORD) dwLen, dwRead);
                if (FAILED(hr))
                {
                    delete [] m_pBufferStart;
                    m_pBufferStart = NULL;
                    return HTTP_ERROR(500, ISE_SUBERR_READFILEFAIL); // ReadFile failed
                }

                m_pBufferEnd = m_pBufferStart + dwRead;
            }
        }
        return HTTP_SUCCESS;
    }

    // loads a stencil from the specified resource.
    HTTP_CODE LoadFromResource(HINSTANCE hInstRes, LPCSTR szID, LPCSTR szType = NULL) throw()
    {
        if (!szType)
            szType = (LPCSTR) RT_HTML;

        HRSRC hRsrc = FindResourceA(hInstRes, szID, szType);
        HGLOBAL hgResource = NULL;
        if (hRsrc)
        {
            hgResource = LoadResource(hInstRes, hRsrc);
            if (!hgResource)
                return HTTP_FAIL;
        }
        else
            return HTTP_FAIL;

        DWORD dwSize = SizeofResource(hInstRes, hRsrc);
        m_pBufferStart = (LPSTR)LockResource(hgResource);
        m_pBufferEnd = m_pBufferStart+dwSize;       
        return HTTP_SUCCESS;
    }

    // loads a stencil from the specified resource
    HTTP_CODE LoadFromResource(HINSTANCE hInstRes, UINT nId, LPCSTR szType = NULL) throw()
    {
        return LoadFromResource(hInstRes, MAKEINTRESOURCEA(nId), szType);
    }

    // loads a stencil from a string
    HTTP_CODE LoadFromString(LPCSTR szString, DWORD dwSize) throw()
    {
        m_pBufferStart = (LPSTR) szString;
        m_pBufferEnd = m_pBufferStart+dwSize;
        return HTTP_SUCCESS;
    }

    inline BOOL CheckTag(LPCSTR szTag, DWORD dwTagLen, LPSTR szStart, DWORD dwLen) throw()
    {
        if (dwLen < dwTagLen)
            return FALSE;

        if (memcmp(szStart, szTag, dwTagLen))
            return FALSE;

        if (_istspace(szStart[dwTagLen]) || szStart[dwTagLen] == '}')
            return TRUE;

        return FALSE;
    }

    inline void FindTagArgs(LPSTR& szstart, LPSTR& szend, int nKeywordChars) throw()
    {
        if (*szstart == '{')
            szstart += 2; // move past {{
        szstart = SkipSpace(szstart, m_nCodePage); // move past whitespace
        szstart += nKeywordChars; // move past keyword
        szstart = SkipSpace(szstart, m_nCodePage); // move past whitespace after keyword
        if (*szend == '}')
            szend -=2; // chop off }}
        szend = RSkipSpace(szstart, szend, m_nCodePage); // chop of trailing whitespace
    }

    // Cracks the loaded stencil into an array of StencilTokens in preparation for
    // rendering. LoadStencil must be called prior to calling this function.
    virtual bool ParseReplacements(ITagReplacer* pReplacer) throw(...)
    {
        return ParseReplacements(pReplacer, GetBufferStart(), GetBufferEnd());
    }

    virtual void FinishParseReplacements() throw(...)
    {
        DWORD dwSize = (DWORD) m_arrTokens.GetCount();
        for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++)
        {
            StencilToken& token = m_arrTokens[dwIndex];
            bool bUnclosedBlock = ((token.type == STENCIL_CONDITIONALSTART || 
									token.type == STENCIL_CONDITIONALELSE ||
                                    token.type == STENCIL_ITERATORSTART) && 
                                    token.dwLoopIndex == STENCIL_INVALIDINDEX);
            if (token.szMethodName[0] && 
                (token.dwFnOffset == STENCIL_INVALIDOFFSET || bUnclosedBlock))
            {
                if (bUnclosedBlock || 
                    m_pReplacer->FindReplacementOffset(
                        token.szMethodName, &token.dwFnOffset, 
                        token.szHandlerName, &token.dwObjOffset, 
                        &token.dwMap, (void **)(&token.dwData), m_pMemMgr) != HTTP_SUCCESS)
                {
                    if (bUnclosedBlock && token.type == STENCIL_CONDITIONALSTART)
                        AddError("{{if}} without {{endif}}", token.pStart);
					else if (bUnclosedBlock && token.type == STENCIL_CONDITIONALELSE)
                        AddError("{{else}} without {{endif}}", token.pStart);
                    else if (bUnclosedBlock && token.type == STENCIL_ITERATORSTART)
                        AddError("{{while}} without {{endwhile}}", token.pStart);
                    else          
                    {
                        char szBuf[ATL_MAX_METHOD_NAME_LEN+sizeof("Unresolved replacement : ''")];
                        _snprintf(szBuf, 
							ATL_MAX_METHOD_NAME_LEN+sizeof("Unresolved replacement : ''")-1,
							"Unresolved replacement : '%s'", token.szMethodName);

                        AddError(szBuf, token.pStart);
                    }

                    // unresolved replacement, convert it to a text token
                    token.type = STENCIL_TEXTTAG;

                    // convert all linked tokens to text tokens as well
                    // this includes: endif, else, endwhile
                    DWORD dwLoopIndex = token.dwLoopIndex;
                    while (dwLoopIndex != dwIndex && dwLoopIndex != STENCIL_INVALIDINDEX)
                    {
                        m_arrTokens[dwLoopIndex].type = STENCIL_TEXTTAG;
                        dwLoopIndex = m_arrTokens[dwLoopIndex].dwLoopIndex;
                    }
                }
            }
        }
    }

	virtual bool Parse(ITagReplacer *pReplacer) throw( ... )
	{
		if (ParseReplacements(pReplacer))
		{
			FinishParseReplacements();
			return true;
		}
		return false;
	}
    
    DWORD CheckTopAndPop(DWORD *pBlockStack, DWORD *pdwTop, DWORD dwToken) throw()
    {
        if (*pdwTop == 0)
            return STENCIL_INVALIDINDEX;
        if (m_arrTokens[pBlockStack[*pdwTop]].type == dwToken)
        {
            *pdwTop = (*pdwTop) - 1;
            return pBlockStack[(*pdwTop)+1];
        }
        return STENCIL_INVALIDINDEX;
    }

    DWORD ParseReplacement( LPSTR szTokenStart, 
							LPSTR szTokenEnd, 
							DWORD * /*pBlockStack*/,
							DWORD * /*pdwTop*/,
							DWORD dwTokenType = STENCIL_REPLACEMENT,
							DWORD dwKeywordLen = 0) throw()
    {
        // hold on to the start and end pointers (before removing curlies and whitespace)
        // this is needed so that we can convert the token to a text token if the method
        // is not resolved (in FinishParseReplacements)
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        FindTagArgs(szTokenStart, szTokenEnd, dwKeywordLen);

        char szMethodName[ATL_MAX_METHOD_NAME_LEN+1];
        char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];

        DWORD dwIndex;
        //look up the handler name, method name and handler interface
        if (HTTP_SUCCESS == GetHandlerAndMethodNames(szTokenStart, szTokenEnd,
                                            szMethodName, 
                                            szHandlerName))
            dwIndex = AddToken(szStart, szEnd, dwTokenType, 
                               szHandlerName, szMethodName, 
                               STENCIL_INVALIDINDEX, STENCIL_INVALIDINDEX, 
                               0, STENCIL_BASIC_MAP);
        else
            dwIndex = STENCIL_INVALIDINDEX;
        return dwIndex;
    }

    DWORD PushToken(DWORD *pBlockStack, DWORD *pdwTop, DWORD dwIndex) throw()
    {
        if (*pdwTop < (ATL_MAX_BLOCK_STACK-1))
        {
            *pdwTop = (*pdwTop) + 1;
            pBlockStack[*pdwTop] = dwIndex;
        }
        else
        {
            dwIndex = STENCIL_INVALIDINDEX;
        }

        return dwIndex;
    }

    DWORD ParseWhile(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_ITERATORSTART, 5);
        if (dwIndex == STENCIL_INVALIDINDEX)
            return dwIndex;
        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseEndWhile(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_ITERATORSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            AddError("{{endwhile}} without {{while}}", szTokenStart);
            return dwTopIndex;
        }

        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_ITERATOREND);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;
        m_arrTokens[dwIndex].dwLoopIndex = dwTopIndex;
        return dwIndex;
    }

    DWORD ParseIf(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_CONDITIONALSTART, 2);
        if (dwIndex == STENCIL_INVALIDINDEX)
            return dwIndex;
        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseElse(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            AddError("{{else}} without {{if}}", szTokenStart);
            return dwTopIndex;
        }

        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_CONDITIONALELSE);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;


        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseEndIf(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALELSE);
            if (dwTopIndex == STENCIL_INVALIDINDEX)
            {
                AddError("{{endif}} without {{if}}", szTokenStart);
                return dwTopIndex;
            }
        }
        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_CONDITIONALEND);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;
        return dwIndex;
    }

    DWORD ParseLocale(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;
        LCID locale = 0xFFFFFFFF;
        FindTagArgs(szstart, szend, 6);
#ifndef ATL_NO_MLANG
        if (isdigit(szstart[0]))
        {
            locale = (LCID) atoi(szstart);
        }
        else
        {
            HRESULT hr;

            CComPtr<IMultiLanguage> pML;
            hr = pML.CoCreateInstance(__uuidof(CMultiLanguage));
            if (FAILED(hr))
            {
                ATLTRACE(atlTraceStencil, 0, _T("Couldn't create CMultiLanguage object. check MLANG installation."));
                AddError("Couldn't create CMultiLanguage", szTokenStart);
            }
            else
            {
                CStringW str(szstart, (int)((szend-szstart)+1));

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

                // use IMultiLanguage2 if possible
                CComPtr<IMultiLanguage2> spML2;
                hr = pML.QueryInterface(&spML2);
                if (FAILED(hr) || !spML2.p)
                    hr = pML->GetLcidFromRfc1766(&locale, CComBSTR(str));
                else
                    hr = spML2->GetLcidFromRfc1766(&locale, CComBSTR(str));

#else // __IMultiLanguage2_INTERFACE_DEFINED__

                hr = pML->GetLcidFromRfc1766(&locale, CComBSTR(str));

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

                if (FAILED(hr))
                    AddError("Error getting lcid", szTokenStart);
            }
            if (FAILED(hr))
                locale = 0xFFFFFFFF;
        }
#else
        locale = (LCID) atoi(szstart);
#endif

        if (m_bUseLocaleACP)
        {
            TCHAR szACP[7];
            if (GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)
            {
                m_nCodePage = (WORD) _ttoi(szACP);
            }
            else
            {
                AddError("GetLocaleInfo failed", szTokenStart);
            }
        }
        DWORD dwCurrentTokenIndex = STENCIL_INVALIDINDEX;
        if (locale != 0xFFFFFFFF)
            dwCurrentTokenIndex = AddToken(NULL, NULL, STENCIL_LOCALE, 
                NULL, NULL, STENCIL_INVALIDOFFSET, STENCIL_INVALIDOFFSET, locale);
        else
            return STENCIL_INVALIDINDEX;
        return dwCurrentTokenIndex;
    }

    DWORD ParseCodepage(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;
        WORD nCodePage = 0xFFFF;

        FindTagArgs(szstart, szend, 8);
#ifndef ATL_NO_MLANG
        if (isdigit(szstart[0]))
        {
            nCodePage = (WORD) atoi(szstart);
        }
        else
        {
            HRESULT hr;

            CComPtr<IMultiLanguage> pML;
            hr = pML.CoCreateInstance(__uuidof(CMultiLanguage));
            if (FAILED(hr))
            {
                ATLTRACE(atlTraceStencil, 0, _T("Couldn't create CMultiLanguage object. check MLANG installation."));
                AddError("Couldn't CoCreate CMultiLanguage object", szTokenStart);
            }
            else
            {
                CStringW str(szstart, (int)((szend-szstart)+1));
                MIMECSETINFO info;

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

                // use IMultiLanguage2 if possible
                CComPtr<IMultiLanguage2> spML2;
                hr = pML.QueryInterface(&spML2);
                if (FAILED(hr) || !spML2.p)
                    hr = pML->GetCharsetInfo(CComBSTR(str), &info);
                else
                    hr = spML2->GetCharsetInfo(CComBSTR(str), &info);

#else // __IMultiLanguage2_INTERFACE_DEFINED__

                hr = pML->GetCharsetInfo(CComBSTR(str), &info);

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

                // for most character sets, uiCodePage and uiInternetEncoding
                // are the same. UTF-8 is the exception that we're concerned about.
                // for that character set, we want uiInternetEncoding (65001 - UTF-8)
                // instead of uiCodePage (1200 - UCS-2)
                if (SUCCEEDED(hr))
                    nCodePage = (WORD) info.uiInternetEncoding;
                else
                    AddError("GetCharsetInfo failed", szTokenStart);
            }
            if (FAILED(hr))
                nCodePage = 0xFFFF;
        }
#else
        nCodePage = (WORD) atoi(szstart);
#endif
        if (nCodePage != 0xFFFF)
            m_nCodePage = nCodePage;
        m_bUseLocaleACP = FALSE;

        return STENCIL_INVALIDINDEX;
    }

    PARSE_TOKEN_RESULT ParseHandler(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;

        if (m_szHandlerName[0] && m_szDllPath[0])
            return RESERVED_TOKEN; // already found the handler and path dll names

        FindTagArgs(szstart, szend, 7);
        size_t nlen = (szend-szstart)+1;
        char szHandlerDllName[MAX_PATH + ATL_MAX_HANDLER_NAME_LEN + 2];
        if (nlen < MAX_PATH + ATL_MAX_HANDLER_NAME_LEN + 2)
        {
            memcpy(szHandlerDllName, szstart, szend-szstart+1);
            szHandlerDllName[szend-szstart+1] = '\0';

            DWORD dwDllPathLen = MAX_PATH+1;
            DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;

            if (!_AtlCrackHandler(szHandlerDllName, m_szDllPath, &dwDllPathLen, m_szHandlerName, &dwHandlerNameLen))
            {
                return INVALID_TOKEN;
            }
        }
        
        return RESERVED_TOKEN;
    }

    virtual PARSE_TOKEN_RESULT ParseToken(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        LPSTR pStart = szTokenStart;
        pStart += 2; //skip curlies
        pStart = SkipSpace(pStart, m_nCodePage);
        DWORD dwLen = (DWORD)(szTokenEnd - szTokenStart);

        DWORD dwIndex = STENCIL_INVALIDINDEX;
        PARSE_TOKEN_RESULT ret = RESERVED_TOKEN;
    

        if (CheckTag("endwhile", 8, pStart, dwLen))
            dwIndex = ParseEndWhile(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("while", 5, pStart, dwLen))
            dwIndex = ParseWhile(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("endif", 5, pStart, dwLen))
            dwIndex = ParseEndIf(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("else", 4, pStart, dwLen))
            dwIndex = ParseElse(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("if", 2, pStart, dwLen))
            dwIndex = ParseIf(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("locale", 6, pStart, dwLen))
            dwIndex = ParseLocale(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("handler", 7, pStart, dwLen))
        {
            return ParseHandler(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        else if (CheckTag("codepage", 8, pStart, dwLen))
        {
            ParseCodepage(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
            return RESERVED_TOKEN;
        }
        else
        {
            dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_REPLACEMENT);
            if (dwIndex == STENCIL_INVALIDINDEX)
                return INVALID_TOKEN;
            ret = NORMAL_TOKEN;
        }
        if (dwIndex == STENCIL_INVALIDINDEX)
            return INVALID_TOKEN;
        return ret;
    }

    virtual bool ParseReplacements(ITagReplacer* pReplacer, LPSTR pStart, LPSTR pEnd) throw()
    {
        LPSTR szCurr = pStart;
        DWORD BlockStack[ATL_MAX_BLOCK_STACK];
        DWORD dwTop = 0;

        m_pReplacer = pReplacer;

        DWORD dwCurrentTokenIndex = 0;

        if (!szCurr)
        {
            ATLASSERT(FALSE);
            AddError("NULL parameter to ParseReplacements", NULL);
            return false;  
        }

        LPSTR szEnd = pEnd;
        if (szEnd <= szCurr)
        {
            ATLASSERT(FALSE);
            AddError("Empty or negative string passed to ParseReplacements", NULL);
            return true;
        }

        while(szCurr < szEnd)
        {
            //mark the start of this block, then find the end of the block
            //the end is denoted by an opening curly
            LPSTR szStart = szCurr;
            while (szCurr < szEnd && (*szCurr != '{' || szCurr[1] != '{'))
            {
                LPSTR szNext = CharNextExA(m_nCodePage, szCurr, 0);
                if (szNext == szCurr)
                {
                    // embedded null
                    AddError("Embedded null character in stencil", NULL);
                    return true;
                }
                szCurr = szNext;
            }

            //special case for the last text block, if there is one
            if (szCurr >= szEnd)
            {
                // add the last token. This is everything after the last
                // double curly block, which is text.
                dwCurrentTokenIndex = AddToken(szStart, szEnd-1, STENCIL_TEXTTAG);
                break;
            }

            //if there are any characters between szStart and szCurr inclusive,
            //copy them to a text token.
            if (szCurr-1 >= szStart)
                dwCurrentTokenIndex = AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);

            //find the end of the tag
            LPSTR szEndTag;
            szStart = szCurr;
            szCurr += 2; // Skip over the two '{' s
            while (szCurr < szEnd)
            {
                if (szCurr[0] == '}' && szCurr[1] == '}')
                    break;
				else if (szCurr[0] == '{')
                    break;

                LPSTR szNext = CharNextExA(m_nCodePage, szCurr, 0);
                if (szNext == szCurr)
                {
                    // embedded null
                    AddError("Embedded null character in stencil", NULL);
                    return true;
                }
                szCurr = szNext;
            }

            if (szCurr >= szEnd)
            {
                AddError("Unmatched {{", szStart);
                AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);
                break;
            }

            if (szCurr[0] == '{')
            {
				if (szCurr[1] != '{')
				{
					szCurr--;
				}
                AddError("Mismatched {{", szStart);
                AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);
                continue;
            }

            szEndTag = CharNextExA(m_nCodePage, szCurr, 0);
            if (szEndTag == szCurr)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return true;
            }

            PARSE_TOKEN_RESULT ret = ParseToken(szStart, szEndTag, BlockStack, &dwTop);
            if (ret == INVALID_TOKEN)
            {
                dwCurrentTokenIndex = AddToken(szStart, szEndTag, STENCIL_TEXTTAG); 
                szCurr = CharNextExA(m_nCodePage, szEndTag, 0);
                continue;
            }

            szCurr = CharNextExA(m_nCodePage, szEndTag, 0);
            if (szEndTag == szCurr)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return true;
            }

            if (ret == RESERVED_TOKEN)
            {
                // REVIEW: should these be using CharNextExA
                if (szCurr < szEnd  && *szCurr == '\n')
                    szCurr++;
                else if ((szCurr+1 < szEnd && *szCurr == '\r' && *(szCurr+1) == '\n'))
                    szCurr += 2;
            }
        }

        return true;
    }

    HTTP_CODE GetHandlerAndMethodNames(
        LPSTR pStart,
        LPSTR pEnd,
        LPSTR pszMethodName,
        LPSTR pszHandlerName) throw()
    {
        if (!pszMethodName || !pszHandlerName)
        {
            ATLASSERT(FALSE);
            AddError("Bad parameter", pStart);
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
        }

        *pszMethodName = '\0';
        *pszHandlerName = '\0';
        CHAR szMethodString[ATL_MAX_METHOD_NAME_LEN + ATL_MAX_HANDLER_NAME_LEN+1]; //*2 in case the tag is an id.tag and +1 for the dot
        HTTP_CODE hcErr = HTTP_SUCCESS;
        //
        // copy the method string
        //
        size_t nMethodLen = (pEnd-pStart)+1;
        if (nMethodLen >= (ATL_MAX_METHOD_NAME_LEN + ATL_MAX_HANDLER_NAME_LEN+1))
        {
            AddError("Method name too long", pStart);
            return HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
        }

        memcpy(szMethodString, pStart, nMethodLen);
        szMethodString[nMethodLen] = '\0';

        //
        // now crack the method string and get the handler
        // id and function name
        //
        LPSTR szParen = strchr(szMethodString, '(');
        LPSTR szDot = strchr(szMethodString, '.');
        if (szDot && (!szParen || (szDot < szParen)))
        {
            *szDot = '\0';
            szDot++;

            // copy method name
            if (strlen(szDot)<ATL_MAX_METHOD_NAME_LEN)
                strcpy(pszMethodName, szDot);
            else
            {
                AddError("Method name too long", pStart + (szDot - szMethodString));
                hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
            }
            // copy handler name
            if (!hcErr)
            {
                if (strlen(szMethodString) < ATL_MAX_METHOD_NAME_LEN)
                    strcpy(pszHandlerName, szMethodString);
                else
                {
                    AddError("Handler name too long", pStart); 
                    hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGHANDLERNAME);
                }
            }
        }
        else
        {
            // only a method name so just copy it.
            if (strlen(szMethodString) < ATL_MAX_METHOD_NAME_LEN)
                strcpy(pszMethodName, szMethodString);
            else
            {
                AddError("Method name too long", pStart);
                hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
            }
        }
        return hcErr;
    }

    virtual HTTP_CODE Render(
        ITagReplacer *pReplacer,
        IWriteStream *pWriteStream,
        void* pState = NULL) const throw(...)
    {
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;
        DWORD dwIndex = 0;
        DWORD dwArraySize = GetTokenCount();
        CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);

        // set up locale info
        CSaveThreadLocale lcidSave;

        if (_pState)
        {
            dwIndex = _pState->dwIndex;

            // restore the locale if we're restarting rendering
            if (_pState->locale != CP_ACP)
                SetThreadLocale(_pState->locale);
        }

        pReplacer->SetStream(pWriteStream);
        while (dwIndex < dwArraySize)
        {
            // RenderToken advances dwIndex appropriately for us.
            dwIndex = RenderToken(dwIndex, pReplacer, pWriteStream, &hcErrorCode, pState);

            if (dwIndex == STENCIL_INVALIDINDEX ||
                hcErrorCode != HTTP_SUCCESS)
                break;
        }

        if (IsAsyncStatus(hcErrorCode))
        {
            ATLASSERT(_pState); // state is required for async
            _pState->dwIndex = dwIndex;
        }
        // lcidSave destructor will restore the locale info in case it was changed

        return hcErrorCode;
    }

    inline BOOL IsValidIndex(DWORD dwIndex) const throw()
    {
        if (dwIndex == STENCIL_INVALIDINDEX)
            return FALSE;
        if (dwIndex < GetTokenCount())
            return TRUE;
        else
            return FALSE;
    }

    virtual DWORD RenderToken(
        DWORD dwIndex,
        ITagReplacer *pReplacer,
        IWriteStream *pWriteStream,
        HTTP_CODE *phcErrorCode,
        void* pState = NULL) const throw(...)
    {
        const StencilToken* pToken = GetToken(dwIndex);
        DWORD dwNextToken = 0;
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;

        if (!pToken)
            return STENCIL_INVALIDINDEX;

        switch (pToken->type)
        {
        case STENCIL_ITERATORSTART:
            {
                HTTP_CODE hcErr = STENCIL_SUCCESS;  

                // A 'while' token has to at least be followed by an endwhile!
                if (!IsValidIndex(dwIndex+1))
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDINDEX);
                    ATLASSERT(FALSE);
                    break;
                }
                    
                // End of loop should be valid
                if (!IsValidIndex(pToken->dwLoopIndex))
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHWHILE);
                    ATLASSERT(FALSE);
                    break;
                }

                if (pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    ATLASSERT(FALSE);
                    break;
                }
            
                DWORD dwLoopIndex = pToken->dwLoopIndex; // points to the end of the loop

                // Call the replacement method
                // if it returns HTTP_SUCCESS, enter the loop
                // if it returns HTTP_S_FALSE, terminate the loop
                hcErr = pReplacer->RenderReplacement(pToken->dwFnOffset,
                    pToken->dwObjOffset, pToken->dwMap, (void *) pToken->dwData);

                if (hcErr == HTTP_SUCCESS)
                {
                    dwNextToken = dwIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else if (hcErr == HTTP_S_FALSE)
                {
                    dwNextToken = dwLoopIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else
                {
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = hcErr;
                    break;
                }
            }
            break;
        case STENCIL_ITERATOREND:
            {
                dwNextToken = pToken->dwLoopIndex;
                hcErrorCode = HTTP_SUCCESS;
                ATLASSERT(GetToken(dwNextToken)->type == STENCIL_ITERATORSTART);
            }
            break;
        case STENCIL_CONDITIONALSTART:
            {
                if (pToken->type == STENCIL_CONDITIONALSTART && pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    break;
                }
            
                if (pToken->dwLoopIndex == STENCIL_INVALIDINDEX)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHIF);
                    break;
                }

                DWORD dwLoopIndex = pToken->dwLoopIndex; // points to the end of the loop

                HTTP_CODE hcErr;
                // Call the replacement method.
                // If it returns HTTP_SUCCESS, we render everything up to
                //  the end of the conditional. 
                // if it returns HTTP_S_FALSE, the condition is not met and we
                //  render the else part if it exists or jump past the endif otherwise
                hcErr = pReplacer->RenderReplacement(pToken->dwFnOffset, 
                    pToken->dwObjOffset, pToken->dwMap, (void *)pToken->dwData);

                if (hcErr == HTTP_SUCCESS)
                {
                    dwNextToken = dwIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else if (hcErr == HTTP_S_FALSE)
                {
                    dwNextToken = dwLoopIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else
                {
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = hcErr;
                    break;
                }
            }
            break;
        case STENCIL_CONDITIONALELSE:
            {
                if (pToken->dwLoopIndex == STENCIL_INVALIDINDEX)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHIF);
                    break;
                }
                dwNextToken = pToken->dwLoopIndex+1;
                hcErrorCode = HTTP_SUCCESS;
            }
            break;
        case STENCIL_CONDITIONALEND:
            {
                dwNextToken = dwIndex+1;
                hcErrorCode = HTTP_SUCCESS;
            }
            break;
        case STENCIL_TEXTTAG:
            {
                pWriteStream->WriteStream(pToken->pStart,
                                        (int)((pToken->pEnd-pToken->pStart)+1), NULL);
                dwNextToken = dwIndex+1;
            }
            break;
        case STENCIL_REPLACEMENT:
            {
                if (pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    break;
                }

                hcErrorCode = pReplacer->RenderReplacement(pToken->dwFnOffset, 
                            pToken->dwObjOffset, pToken->dwMap, (void *)pToken->dwData);

                if (IsAsyncContinueStatus(hcErrorCode))
                    dwNextToken = dwIndex; // call the tag again after we get back
                else
                {
                    dwNextToken = dwIndex + 1;

                    // when returned from a handler, these indicate that the handler is done
                    // and that we should move on to the next handler when called back
                    if (hcErrorCode == HTTP_SUCCESS_ASYNC_DONE)
                        hcErrorCode = HTTP_SUCCESS_ASYNC;
                    else if (hcErrorCode == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE)
                        hcErrorCode = HTTP_SUCCESS_ASYNC_NOFLUSH;
                }
            }
            break;
        case STENCIL_LOCALE:
            {
                if (pState)
                {
                    CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
                    _pState->locale = (LCID) pToken->dwData;
                }
                SetThreadLocale((LCID) pToken->dwData);
                dwNextToken = dwIndex + 1;
            }
            break;
        default:
            {
                ATLASSERT(FALSE);
                dwNextToken = STENCIL_INVALIDINDEX;
                hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_UNEXPECTEDTYPE);
                break;
            }
        }
        ATLASSERT(dwNextToken != dwIndex || IsAsyncContinueStatus(hcErrorCode));

        if (phcErrorCode)
            *phcErrorCode = hcErrorCode;

        return dwNextToken;
    }

    DWORD GetTokenCount() const throw()
    {
        return (DWORD) m_arrTokens.GetCount();
    }

    const StencilToken* GetToken(DWORD dwIndex) const throw()
    {
        return &(m_arrTokens[dwIndex]);
    }

	StencilToken* GetToken(DWORD dwIndex) throw()
    {
        return &(m_arrTokens[dwIndex]);
    }

    LPSTR GetBufferStart() const throw()
    {
        return m_pBufferStart;
    }

    LPSTR GetBufferEnd() const throw()
    {
        return m_pBufferEnd;
    }

    WORD GetCodePage() const throw()
    {
        return m_nCodePage;
    }

    // IMemoryCacheClient
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;

        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IMemoryCacheClient)))
        {
            *ppv = static_cast<void*>(this);
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)() throw()
    {
        return 1;
    }

    STDMETHOD_(ULONG, Release)() throw()
    {
        return 1;
    }

    STDMETHOD(Free)(const void *pData) throw()
    {
        if (!pData)
            return E_UNEXPECTED;

        ATLASSERT(*((void **) pData) == static_cast<void*>(this));
        
        Uninitialize();

        delete this;
        return S_OK;
    }
}; // class CStencil

struct StencilIncludeInfo
{
public:
    CHAR m_szQueryString[2048];
    CHAR m_szFileName[MAX_PATH];
};


class CIncludeServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    BEGIN_COM_MAP(CIncludeServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    IWriteStream * m_pStream;
    const StencilIncludeInfo * m_pIncludeInfo;

    CIncludeServerContext() throw()
    {
        m_pStream = NULL;
        m_pIncludeInfo = NULL;
    }

    void Initialize(
        IWriteStream *pStream,
        IHttpServerContext* pServerContext,
        const StencilIncludeInfo * pIncludeInfo) throw()
    {
        m_pStream = pStream;
        m_spParent = pServerContext;
        m_pIncludeInfo = pIncludeInfo;
    }

    LPCSTR GetRequestMethod() throw()
    {
        return "GET";
    }

    LPCSTR GetQueryString() throw()
    {
        return m_pIncludeInfo->m_szQueryString;
    }

    LPCSTR GetPathTranslated() throw()
    {
        return m_pIncludeInfo->m_szFileName;
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        return m_pIncludeInfo->m_szFileName;
    }

    DWORD GetTotalBytes() throw()
    {
        return 0;
    }

    DWORD GetAvailableBytes() throw()
    {
        return 0;
    }

    BYTE *GetAvailableData() throw()
    {
        return NULL;
    }

    LPCSTR GetContentType() throw()
    {
        return 0;
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw(...)
    {
        HRESULT hr = m_pStream->WriteStream((LPCSTR) pvBuffer, *pdwBytes, pdwBytes);
        return SUCCEEDED(hr);
    }

    BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }
    
    BOOL SendRedirectResponse(LPCSTR /*pszRedirectURL*/) throw()
    {
        return FALSE;
    }

    BOOL SendResponseHeader(
        LPCSTR /*pszHeader*/,
        LPCSTR /*pszStatusCode*/,
        BOOL /*fKeepConn*/) throw()
    {
        return TRUE;
    }

    BOOL DoneWithSession(DWORD /*dwHttpStatusCode*/) throw()
    {
        return TRUE;
    }

    BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION /*pfn*/, DWORD * /*pdwContext*/) throw()
    {
        return FALSE;
    }
}; // class CIncludeServerContext

class CIDServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    CHttpResponse *m_pResponse;
    CHttpRequest *m_pRequest;

    BEGIN_COM_MAP(CIDServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    CIDServerContext() throw()
        : m_pResponse(NULL), m_pRequest(NULL)
    {
    }

    BOOL Initialize(
        CHttpResponse *pResponse,
        CHttpRequest *pRequest) throw()
    {
        m_pResponse = pResponse;
        m_pRequest = pRequest;
        HRESULT hr = m_pRequest->GetServerContext(&m_spParent);
        return (SUCCEEDED(hr));
    }

    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetMethodString();
    }

    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetQueryString();
    }

    LPCSTR GetPathInfo() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetPathInfo();
    }

    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetPathTranslated();
    }

    DWORD GetTotalBytes() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetTotalBytes();
    }

    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetAvailableBytes();
    }

    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetAvailableData();
    }

    LPCSTR GetContentType() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetContentType();
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetScriptPathTranslated();
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        ATLASSERT(m_pResponse != NULL);
        return m_pResponse->WriteLen((LPCSTR)pvBuffer, *pdwBytes);
    }

    BOOL ReadClient(void *pvBuffer, DWORD *pdwSize) throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->ReadData((LPSTR)pvBuffer, pdwSize);
    }

    BOOL SendRedirectResponse(LPCSTR pszRedirectURL) throw()
    {
        ATLASSERT(m_pResponse != NULL);
        return m_pResponse->Redirect(pszRedirectURL);
    }

    BOOL TransmitFile(
        HANDLE hFile,
        PFN_HSE_IO_COMPLETION pfn,
        void *pContext,
        LPCSTR szStatusCode,
        DWORD dwBytesToWrite,
        DWORD dwOffset,
        void *pvHead,
        DWORD dwHeadLen,
        void *pvTail,
        DWORD dwTailLen,
        DWORD dwFlags) throw(...)
    {
        ATLASSERT(m_pResponse != NULL);
        ATLASSERT(m_spParent != NULL);

        m_pResponse->Flush();
        return m_spParent->TransmitFile(hFile, pfn, pContext, szStatusCode, 
            dwBytesToWrite, dwOffset, pvHead, dwHeadLen, pvTail, dwTailLen, dwFlags);
    }

}; // class CIDServerContext

//
// CHtmlStencil
// CHtmlStencil is a specialization of CStencil. CHtmlStencil adds the following
// capabilities to CStencil:
// 
// Support for rendering {{include }} tags
// The {{include }}  tags specify another stencil to be included in-place during
// stencil rendering. The {{include }} tag takes a single parameter which is the 
// URL of the stencil to include. That URL can optionally include parameters. 
// An example:
// {{include mystencil.srf?param1=value1}}
//
// We also grab the handler name and the name of any subhandlers.  A handler must be
// the first tag in the .srf file.  The syntax for the handler specification is:
// {{handler MyDynamicHandler.dll/Default}}
// which would cause the MyDynamicHandler.dll to be loaded. Once loaded, the stencil 
// processor will ask for the IReplacementHandler interface of the object named "Default".
//
// Additional handlers can be specified after the default handler.  An example of an 
// additional handler would be:
// {{subhandler OtherHandler MyOtherHandler.dll/Default}}
// would cause the MyOtherHandler.dll to be loaded. Once loaded, the stencil processor will
// ask for the IReplacementHandler interface of the object named "Default" and use it in
// processing the stencil anywhere it sees a stencil tag of the form 
// {{OtherHandler.RenderReplacement}}

struct CStringPair
{
    CStringA strDllPath;
    CStringA strHandlerName;

    CStringPair()throw()
	{
	}

    CStringPair(CStringA &strDllPath_, CStringA &strHandlerName_) throw(...)
        :strDllPath(strDllPath_), strHandlerName(strHandlerName_)
    {
    }
};

class CStringPairElementTraits :
    public CElementTraitsBase< CStringPair >
{
public:
    static ULONG Hash( INARGTYPE pair ) throw()
    {
        return CStringElementTraits<CStringA>::Hash( pair.strDllPath );
    }

    static bool CompareElements( INARGTYPE pair1, INARGTYPE pair2 ) throw()
    {
        return( (pair1.strDllPath == pair2.strDllPath) && (pair1.strHandlerName == pair2.strHandlerName) );
    }

    static int CompareElementsOrdered( INARGTYPE pair1, INARGTYPE pair2 ) throw()
    {
        return( pair1.strDllPath.Compare( pair2.strDllPath ) );
    }
};

class CHtmlStencil : public CStencil
{
protected:
    CAtlMap<CStringA, CStringPair, 
        CStringElementTraits<CStringA>, CStringPairElementTraits > m_arrExtraHandlers;
    CHAR m_szBaseDir[MAX_PATH];
    CComPtr<IServiceProvider> m_spServiceProvider;
    CComPtr<IIsapiExtension> m_spExtension;
    CComPtr<IStencilCache> m_spStencilCache;
    CComPtr<IDllCache> m_spDllCache;

public:
    typedef CAtlMap<CStringA, CStringPair, 
        CStringElementTraits<CStringA>, CStringPairElementTraits > mapType;
    typedef CStencil baseType;

    CHtmlStencil(IAtlMemMgr *pMemMgr=NULL) throw() :
        CStencil(pMemMgr)
    {

    }
    
    void Initialize(IServiceProvider *pProvider) throw(...)
    {
        ATLASSERT(pProvider);
        if (m_spServiceProvider)
            m_spServiceProvider.Release();

        m_spServiceProvider = pProvider;
        if (!m_spDllCache)
            pProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache), (void **) &m_spDllCache);

        if (!m_spExtension)
            pProvider->QueryInterface(__uuidof(IIsapiExtension), (void **) &m_spExtension);
    }

    BOOL GetIncludeInfo(LPCSTR szParamBegin, LPCSTR szParamEnd, StencilIncludeInfo *pInfo) const throw()
    {
        LPCSTR szQueryBegin = szParamBegin;

        while (*szQueryBegin && *szQueryBegin != '?' && *szQueryBegin != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szQueryBegin, 0);
            if (szNext == szQueryBegin)
            {
                return FALSE;
            }

            szQueryBegin = szNext;
        }

        char szPath[MAX_PATH];
		szPath[0] = '\0';
        DWORD dwPrefixLen = 0;
		if (*szParamBegin == '"')
		{
			szParamBegin++;
		}
        if (!IsFullPathA(szParamBegin))
		{	
			if (*szParamBegin != '\\')
			{
				strcpy(szPath, m_szBaseDir);
			}
			else
			{
				LPCSTR szBackslash = strchr(m_szBaseDir, '\\');
				if (szBackslash)
				{
					strncpy(szPath, m_szBaseDir, szBackslash-m_szBaseDir);
					szPath[szBackslash-m_szBaseDir] = '\0';
				}
				else
				{
					strcpy(szPath, m_szBaseDir);
				}
			}
            dwPrefixLen = (DWORD)strlen(szPath);
        }

        if (*szQueryBegin=='?')
        {
			size_t nMinus = (*(szQueryBegin-1) == '"') ? 1 : 0;
            strncat(szPath, szParamBegin, szQueryBegin-szParamBegin-nMinus);
            szPath[dwPrefixLen + szQueryBegin - szParamBegin] = '\0';
            memcpy(pInfo->m_szQueryString, szQueryBegin + 1, szParamEnd - szQueryBegin);
            pInfo->m_szQueryString[szParamEnd - szQueryBegin] = '\0';
        }
        else
        {
            pInfo->m_szQueryString[0] = '\0';
			size_t nAdd = (*szParamEnd == '"') ? 0 : 1;
            strncat(szPath, szParamBegin, szParamEnd - szParamBegin + nAdd);
            szPath[dwPrefixLen + szParamEnd - szParamBegin + 1] = '\0';
        }
        
        PathCanonicalizeA(pInfo->m_szFileName, szPath);

        return HTTP_SUCCESS;
    }

    int ParseInclude(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw(...)
    {
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        FindTagArgs(szStart, szEnd, 7);
        
		CHeapPtr<char> szFileNameRelative;
		CHeapPtr<TCHAR> szFileName;

		ATLTRY(szFileNameRelative.AllocateBytes(max(MAX_PATH, szEnd-szStart+3)))
		ATLTRY(szFileName.AllocateBytes(((szEnd-szStart)+MAX_PATH+3)*sizeof(TCHAR)))

		if ((char*)szFileNameRelative == NULL ||
			(TCHAR*)szFileName == NULL)
		{
			AddError("Out of memory", szTokenStart);
            return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
		}


        memcpy(szFileNameRelative, szStart, szEnd-szStart + 1);
        szFileNameRelative[szEnd-szStart + 1] = '\0';

        if (!IsFullPathA(szFileNameRelative))
        {
			CHeapPtr<CHAR> szTemp;
			ATLTRY(szTemp.AllocateBytes((szEnd-szStart)+MAX_PATH+3));
			if ((CHAR*)szTemp == NULL)
			{
				AddError("Out of memory", szTokenStart);
				return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
			}
			if (*szFileNameRelative != '\\')
			{
				strcpy(szTemp, m_szBaseDir);
			}
			else
			{
				LPCSTR szBackslash = strchr(m_szBaseDir, '\\');
				if (szBackslash)
				{
					strncpy(szTemp, m_szBaseDir, szBackslash-m_szBaseDir);
					szTemp[szBackslash-m_szBaseDir] = '\0';
				}
				else
				{
					strcpy(szTemp, m_szBaseDir);
				}
			}

            strcat(szTemp, szFileNameRelative);
            PathCanonicalize(szFileName, CA2CT(szTemp));
        }
        else
        {
            _tcscpy(szFileName, CA2CTEX<MAX_PATH>(szFileNameRelative));
        }

		LPTSTR szDot = NULL;
		LPTSTR szExtra = _tcschr(szFileName, '?');
		if (!szExtra)
		{
			szExtra = _tcschr(szFileName, '#');
			if (!szExtra)
			{
				szDot = _tcsrchr(szFileName, '.');
			}
		}

		if (szExtra != NULL)
		{
			// there is some extra information
			LPTSTR szDotTmp = szFileName;
			do
			{
				szDot = szDotTmp;
				szDotTmp = _tcschr(szDotTmp+1, '.');
			} while (szDotTmp && szDotTmp < szExtra);
		}

		if (!szDot || *szDot != '.')
		{
			AddError("Unexpected error", szTokenStart);
            return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
		}

		LPTSTR szExtEnd = szDot;

        while (true)
        {
            szExtEnd++;
            if (!*szExtEnd || *szExtEnd == '/' || *szExtEnd == '\\' || *szExtEnd == '?' || *szExtEnd == '#' || *szExtEnd == '"')
                break;
        }

        if (szDot && szExtEnd-szDot == sizeof(".dll")-sizeof('\0') &&
            !_tcsnicmp(szDot, _T(".dll"), sizeof(".dll")-sizeof('\0')))
        {
            // Do .dll stuff
            DWORD dwIndex = AddToken(szStart, szEnd, STENCIL_STENCILINCLUDE);
            StencilIncludeInfo *pInfo = (StencilIncludeInfo *)m_pMemMgr->Allocate(sizeof(StencilIncludeInfo));
            if (!pInfo)
                return -1;

            GetIncludeInfo(szStart, szEnd, pInfo);
//            m_arrTokens[dwIndex].pvParam = pInfo;
			GetToken(dwIndex)->dwData = (DWORD_PTR) pInfo;
            return dwIndex;
        }
        else if (szDot && (size_t)(szExtEnd-szDot) == _tcslen(c_tAtlSRFExtension) &&
            !_tcsnicmp(szDot, c_tAtlSRFExtension, _tcslen(c_tAtlSRFExtension)))
        {
            // Do .srf stuff
            DWORD dwIndex = AddToken(szStart, szEnd, STENCIL_STENCILINCLUDE);
            StencilIncludeInfo *pInfo = (StencilIncludeInfo *)m_pMemMgr->Allocate(sizeof(StencilIncludeInfo));
            if (!pInfo)
                return -1;

            GetIncludeInfo(szStart, szEnd, pInfo);
//            m_arrTokens[dwIndex].pvParam = pInfo;
			GetToken(dwIndex)->dwData = (DWORD_PTR) pInfo;
            return dwIndex;
        }
        else
        {
            // Assume static content
            CAtlFile file;

            HRESULT hr = file.Create(szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
            if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
			{
				if (FAILED(hr))
					AddError("Could not open included file", szTokenStart);
				else
					AddError("Included file is not a disk file", szTokenStart);
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
			}

            CAutoVectorPtr<CHAR> szBufferStart;
            LPSTR szBufferEnd = NULL;
            ULONGLONG dwLen = 0;
            if (FAILED(file.GetSize(dwLen)))
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);

            if (!szBufferStart.Allocate((size_t) dwLen))
				AtlThrow(E_OUTOFMEMORY);

            DWORD dwRead;
            if (FAILED(file.Read(szBufferStart, (DWORD) dwLen, dwRead)))
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);

            szBufferEnd = szBufferStart + dwRead-1;

			DWORD dwIndex = AddToken(szBufferStart, szBufferEnd, STENCIL_STATICINCLUDE);
//            m_arrTokens[dwIndex].bDynamicAlloc = TRUE;
			GetToken(dwIndex)->bDynamicAlloc = TRUE;
			szBufferStart.Detach();
            return dwIndex;
        }
    }

    PARSE_TOKEN_RESULT ParseSubhandler(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        // move to the start of the arguments
        // (the first char past 'subhandler'
        FindTagArgs(szStart, szEnd, 10);

        // skip any space to bring us to the start
        // of the id for the subhandler.
        szStart = SkipSpace(szStart, GetCodePage());

        // id names cannot contain spaces. Mark the
        // beginning and end if the subhandler id
        LPCSTR szIdStart = szStart;
        while (!isspace(*szStart) && *szStart != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szStart, 0);
            if (szNext == szStart)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return INVALID_TOKEN;
            }
            szStart = szNext;
        }
        LPCSTR szIdEnd = szStart;

        // skip space to bring us to the beginning of the
        // the dllpath/handlername
        szStart = SkipSpace(szStart, GetCodePage());

        // everything up to the end if the tag is
        // part of the dllpath/handlername
        LPSTR szHandlerStart = szStart;
        while (*szStart != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szStart, 0);
            if (szNext == szStart)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return INVALID_TOKEN;
            }
            szStart = szNext;
        }
        LPCSTR szHandlerEnd = szStart;

		_ATLTRY
		{
        CStringA strName(szIdStart, (int)(szIdEnd-szIdStart));
        CStringA strPath(szHandlerStart, (int)(szHandlerEnd-szHandlerStart));

        CStringA strDllPath;
        CStringA strHandlerName;
        DWORD dwDllPathLen = MAX_PATH+1;
        DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;

        LPSTR szDllPath = strDllPath.GetBuffer(dwDllPathLen);
        LPSTR szHandlerName = strHandlerName.GetBuffer(dwHandlerNameLen);

        if (!_AtlCrackHandler(strPath, szDllPath, &dwDllPathLen, szHandlerName, &dwHandlerNameLen))
        {
            strDllPath.ReleaseBuffer();
            strHandlerName.ReleaseBuffer();
            return INVALID_TOKEN;
        }
        
        strDllPath.ReleaseBuffer(dwDllPathLen);
        strHandlerName.ReleaseBuffer(dwHandlerNameLen);

        m_arrExtraHandlers.SetAt(strName, CStringPair(strDllPath, strHandlerName));
		}
		_ATLCATCHALL()
		{
			return INVALID_TOKEN;
		}
        return RESERVED_TOKEN;
    }

    virtual PARSE_TOKEN_RESULT ParseToken(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        LPSTR pStart = szTokenStart;
        pStart += 2; //skip curlies
        pStart = SkipSpace(pStart, GetCodePage());
        DWORD dwLen = (DWORD)(szTokenEnd - szTokenStart);

        int nIndex = -1;

        if (CheckTag("include", 7, pStart, dwLen))
            nIndex = ParseInclude(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (dwLen > 3 && !memcmp("!--", pStart, 3))
            return RESERVED_TOKEN;
        else if (dwLen > 2 && !memcmp("//", pStart, 2))
            return RESERVED_TOKEN;
        else if (CheckTag("subhandler", 10, pStart, dwLen))
        {
            return ParseSubhandler(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        else
        {
            return CStencil::ParseToken(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        if (nIndex < 0)
            return INVALID_TOKEN;
        return RESERVED_TOKEN;
    }

    mapType* GetExtraHandlers() throw()
    {
        return &m_arrExtraHandlers;
    }

    void SetBaseDirFromFile(LPCSTR szBaseDir) throw()
    {
        strcpy(m_szBaseDir, szBaseDir);
        LPSTR szSlash = strrchr(m_szBaseDir, '\\');
        if (szSlash)
        {
            szSlash++;
            *szSlash = '\0';
        }
        else
        {
            *m_szBaseDir = '\0';
        }
    }

    LPCSTR GetBaseDir() throw()
    {
        return m_szBaseDir;
    }


    // Any value returned from a replacement method other than HTTP_SUCCESS
    // will stop the rendering of the stencil.
    DWORD RenderToken(
        DWORD dwIndex,
        ITagReplacer* pReplacer,
        IWriteStream *pWriteStream,
        HTTP_CODE *phcErrorCode,
        void* pState = NULL) const throw(...)
    {
        DWORD dwNextToken = STENCIL_INVALIDINDEX;
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;
        const StencilToken* pToken = GetToken(dwIndex);
        if (pToken)
        {
            if (pToken->type == STENCIL_STENCILINCLUDE)
            {
                ATLASSERT(m_spServiceProvider);
                CComPtr<IHttpServerContext> spServerContext;
                CComPtr<IHttpRequestLookup> spLookup;
                if (FAILED(pReplacer->GetContext(__uuidof(IHttpServerContext), (VOID**) &spServerContext)))
                    return HTTP_ERROR(500, 0);
                if (FAILED(pReplacer->GetContext(__uuidof(IHttpRequestLookup), (VOID**) &spLookup)))
                    return HTTP_ERROR(500, 0);
                hcErrorCode = RenderInclude(m_spServiceProvider, pWriteStream, 
                    (StencilIncludeInfo *)pToken->dwData, spServerContext, spLookup,
                    pState);
                if (hcErrorCode == HTTP_SUCCESS || IsAsyncDoneStatus(hcErrorCode))
                    dwNextToken = dwIndex+1;
                else if (IsAsyncContinueStatus(hcErrorCode))
                    dwNextToken = dwIndex;
            }
            else if (pToken->type == STENCIL_STATICINCLUDE)
            {
                pWriteStream->WriteStream(pToken->pStart,
                    (int)((pToken->pEnd-pToken->pStart)+1), NULL);
                dwNextToken = dwIndex+1;
            }
            else
                dwNextToken = baseType::RenderToken(dwIndex, pReplacer,
                        pWriteStream, &hcErrorCode, pState);
        }

        if (hcErrorCode == HTTP_SUCCESS_NO_CACHE)
        {
            hcErrorCode = HTTP_SUCCESS;
            CComPtr<IHttpServerContext> spContext;
            HRESULT hr = pReplacer->GetContext(__uuidof(IHttpServerContext), (void **)&spContext);
            if (hr == S_OK && spContext)
            {
                CComQIPtr<IPageCacheControl> spControl;
                spControl = spContext;
                if (spControl)
                    spControl->Cache(FALSE);
            }
        }

        if (phcErrorCode)
            *phcErrorCode = hcErrorCode;
        return dwNextToken;
    }

    ATL_NOINLINE HTTP_CODE RenderInclude(
        IServiceProvider *pServiceProvider,
        IWriteStream *pWriteStream,
        const StencilIncludeInfo *pIncludeInfo,
        IHttpServerContext *pServerContext,
        IHttpRequestLookup *pLookup,
        void* pState = NULL) const throw(...)
    {
        AtlServerRequest* pRequestInfo = NULL;
        HTTP_CODE hcErr = HTTP_SUCCESS;


        CComObjectStackEx<CIncludeServerContext> serverContext;
        serverContext.Initialize(pWriteStream, pServerContext, pIncludeInfo);

#ifdef _DEBUG
        bool bAsyncAllowed = false;
#endif

        CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
        if (_pState && _pState->pIncludeInfo)
        {
            pRequestInfo = _pState->pIncludeInfo;
            _pState->pIncludeInfo = NULL;
#ifdef _DEBUG
            bAsyncAllowed = true;
#endif
        }
        else
        {
            if (!m_spStencilCache)
                m_spServiceProvider->QueryService(__uuidof(IStencilCache), __uuidof(IStencilCache), (void **) &m_spStencilCache);
            ATLASSERT(m_spStencilCache);

            if (!m_spDllCache)
                pServiceProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache), (void **) &m_spDllCache);
            ATLASSERT(m_spDllCache);

            pRequestInfo = m_spExtension->CreateRequest();
            if (pRequestInfo == NULL)
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

            pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
            pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
            pRequestInfo->pDllCache = m_spDllCache;
            pRequestInfo->pExtension = m_spExtension;
            pRequestInfo->pServerContext = &serverContext;
            if (_pState && _pState->pParentInfo)
                pRequestInfo->pUserData = _pState->pParentInfo->pUserData;

            // Extract the file extension of the included file by searching
            // for the first '.' from the right.
            // Can't use _tcsrchr because we have to use the stencil's codepage
            LPCSTR szDot = NULL;
            LPCSTR szMark = pIncludeInfo->m_szFileName;
            while (*szMark)
            {
                if (*szMark == '.')
                    szDot = szMark;

                LPCSTR szNext = CharNextExA(GetCodePage(), szMark, 0);
                if (szNext == szMark)
                {
                    // embedded null
                    return HTTP_FAIL;
                }
                szMark = szNext;
            }

            if (szDot && _stricmp(szDot, c_AtlSRFExtension) == 0)
            {
                hcErr = m_spExtension->LoadDispatchFile(pIncludeInfo->m_szFileName, pRequestInfo);
                if (hcErr)
                    return hcErr;
            }
            else if (szDot && _stricmp(szDot, ".dll") == 0)
            {
                // Get the handler name if they used the asdf.dll?Handler=Default notation
                // REVIEW : case sensitivity on the "Handler"?
                char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1] = { '\0' };

                LPSTR szStart = strstr(pIncludeInfo->m_szQueryString, "Handler=");
                if (szStart && 
					((szStart == pIncludeInfo->m_szQueryString) || 
					 ((szStart > pIncludeInfo->m_szQueryString) && (*(szStart-1) == '&'))))
                {
                    szStart += 8;  // Skip past "Handler" and the "="
                    LPSTR szEnd = strchr(szStart, '&');
                    if (szEnd)
                    {
                        memcpy(szHandlerName, szStart, min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN));
                        szHandlerName[min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN)] = '\0';
                    }
                    else
                    {
                        strcpy(szHandlerName, szStart);
                    }
                }
                else
                {
                    memcpy(szHandlerName, "Default", sizeof("Default"));
                }

                pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;

                hcErr = m_spExtension->LoadRequestHandler(pIncludeInfo->m_szFileName, szHandlerName, pRequestInfo->pServerContext, 
                    &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
                if (hcErr)
                    return hcErr;
            }

            DWORD dwStatus;
            hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);

            if (hcErr)
                return hcErr;

            if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
            {
#ifdef _DEBUG
                bAsyncAllowed = true;
#endif
                CComObjectNoLock<CIncludeServerContext>* pNewServerContext = NULL;
                ATLTRY(pNewServerContext = new CComObjectNoLock<CIncludeServerContext>);
                if (pNewServerContext == NULL)
                    return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
                pNewServerContext->Initialize(pWriteStream, pServerContext, pIncludeInfo);
                pNewServerContext->AddRef();
                pRequestInfo->pServerContext = pNewServerContext;
            }

            _ATLTRY
            {
                hcErr = pRequestInfo->pHandler->InitializeChild(pRequestInfo, m_spServiceProvider, pLookup);
                if (hcErr)
                    return hcErr;
            }
            _ATLCATCHALL()
            {
                return HTTP_FAIL;
            }

            pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;
        }

        if (pRequestInfo)
        {
            if (!hcErr)
            {
                if (pRequestInfo->pServerContext == NULL)
                    pRequestInfo->pServerContext = &serverContext;

                _ATLTRY
                {
                    ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);
                    hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, pServiceProvider);
                }
                _ATLCATCHALL()
                {
                    hcErr = HTTP_FAIL;
                }

                if (pRequestInfo->pServerContext == &serverContext)
                    pRequestInfo->pServerContext = NULL;

#ifdef _DEBUG
                // must use ATLSRV_INIT_USEASYNC to use ASYNC returns
                if (IsAsyncStatus(hcErr))
                    ATLASSERT(bAsyncAllowed);
#endif

                if (IsAsyncStatus(hcErr))
                {
                    ATLASSERT(pState); // state is required for async
                    if (IsAsyncContinueStatus(hcErr))
                    {
                        _pState->pIncludeInfo = pRequestInfo;
                        pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;
                    }
                    else if (IsAsyncDoneStatus(hcErr))
                        m_spExtension->FreeRequest(pRequestInfo);
                }
                else
                    m_spExtension->FreeRequest(pRequestInfo);
            }
        }
        else
            hcErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        return hcErr;
    }
}; // class CHtmlStencil


__declspec(selectany) CCRTHeap CStencil::m_crtHeap;

// 
// CHtmlTagReplacer
// This class manages CStencil based objects for HTTP requests. This class will retrieve
// CStencil based objects from the stencil cache, store CStencil based objects in the
// stencil cache and allocate and initialize CStencil based objects on a per reqeust
// basis. Typically, one instance of this class is created for each HTTP request. The
// instance is destroyed once the request has been completed.
template <class THandler, class StencilType=CHtmlStencil>
class CHtmlTagReplacer : 
    public ITagReplacerImpl<THandler>
{
protected:
    typedef StencilType StencilType;

    CSimpleArray<HINSTANCE> m_hInstHandlers;
    typedef CAtlMap<CStringA, IRequestHandler*, CStringElementTraits<CStringA> > mapType;
    mapType m_Handlers;
    StencilType *m_pLoadedStencil;
    WORD m_nCodePage;
    CComPtr<IStencilCache> m_spStencilCache;

    AtlServerRequest m_RequestInfo;

public:
    // public members

    CHtmlTagReplacer() throw() :
      m_pLoadedStencil(NULL)
    {
        memset(&m_RequestInfo, 0x00, sizeof(m_RequestInfo));
        m_nCodePage = CP_THREAD_ACP;
    }

    ~CHtmlTagReplacer() throw()
    {
        // you should call FreeHandlers before
        // the object is destructed
        ATLASSERT(m_hInstHandlers.GetSize() == 0);
    }

    HTTP_CODE Initialize(AtlServerRequest *pRequestInfo, IHttpServerContext *pSafeSrvCtx=NULL) throw(...)
    {
        CComPtr<IServiceProvider> spServiceProvider;
        THandler *pT = static_cast<THandler*>(this);
        HRESULT hr = pT->GetContext(__uuidof(IServiceProvider), (void **)&spServiceProvider);
        if (FAILED(hr))
            return HTTP_FAIL;

        spServiceProvider->QueryService(__uuidof(IStencilCache), __uuidof(IStencilCache), (void **) &m_spStencilCache);
        if (!m_spStencilCache)
        {
            ATLASSERT(FALSE);
            return HTTP_FAIL;
        }

        m_RequestInfo.cbSize = sizeof(m_RequestInfo);
        m_RequestInfo.pServerContext = pSafeSrvCtx;
        m_RequestInfo.pUserData = pRequestInfo->pUserData;

        return HTTP_SUCCESS;
    }

    HTTP_CODE LoadStencilResource(
        HINSTANCE hInstResource,
        LPCSTR szResourceID,
        LPCSTR szResourceType = NULL, LPCSTR szStencilName=NULL) throw(...)
    {
        if (!szResourceType)
            szResourceType = (LPCSTR) (RT_HTML);
        // look up stencil in cache
        HTTP_CODE hcErr = HTTP_SUCCESS;

        // check the cache first
        StencilType *pStencil = FindCacheStencil(szStencilName ? szStencilName : szResourceID);
        if (!pStencil)
        {
            // create a new stencil
            pStencil = GetNewCacheStencil();
            THandler *pT = static_cast<THandler*>(this);
            LPCSTR szFileName = pT->m_spServerContext->GetScriptPathTranslated();

            if (!szFileName)
                return HTTP_FAIL;

            pStencil->SetBaseDirFromFile(szFileName);
            if (!pStencil)
                return HTTP_ERROR(500,ISE_SUBERR_OUTOFMEM);
        
            // load the stencil and parse its replacements
            if (HTTP_SUCCESS == pStencil->LoadFromResource(hInstResource, 
                                            szResourceID, szResourceType))
            {
                _ATLTRY
                {
                    if (!pStencil->ParseReplacements(static_cast<ITagReplacer*>(this),
                                pStencil->GetBufferStart(), pStencil->GetBufferEnd()))
                            return HTTP_ERROR(500, ISE_SUBERR_BADSRF);

                    hcErr = FinishLoadStencil(pStencil, NULL);
                    if (!hcErr)
                    {
                        pStencil->FinishParseReplacements();
                    }
                }
                _ATLCATCHALL()
                {
                    return HTTP_FAIL;
                }
            }
            else
            {
                hcErr = HTTP_FAIL;
            }

            // if everything went OK, put the stencil in the stencil cache.
            if (!hcErr)
            {
                hcErr = CacheStencil(szStencilName ? szStencilName : szResourceID, pStencil);
            }
                
            if (pStencil && hcErr) // something went wrong, free the stencil data
                FreeCacheStencil(pStencil);
        }
        else
        {
            hcErr = FinishLoadStencil(pStencil);
        }

        return hcErr;
    }

    HTTP_CODE LoadStencilResource(HINSTANCE hInstResource, UINT nID, LPCSTR szResourceType = NULL) throw(...)
    {
        if (!szResourceType)
            szResourceType = (LPCSTR) RT_HTML;
        char szName[80];
        sprintf(szName, "%p/%u", hInstResource, nID);
        return LoadStencilResource(hInstResource, MAKEINTRESOURCEA(nID), szResourceType, szName);
    }

    HTTP_CODE LoadStencil(LPCSTR szFileName, IHttpRequestLookup * pLookup = NULL) throw(...)
    {
        if (!szFileName)
        {
            return HTTP_FAIL;
        }

        HTTP_CODE hcErr = HTTP_FAIL;
        // try to find the stencil in the cache
        StencilType *pStencil = FindCacheStencil(szFileName);

        if (!pStencil)
        {
            // not in cache. Create a new one
            pStencil = GetNewCacheStencil();
            if (!pStencil)
            {
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM); // out of memory!
            }

            pStencil->SetBaseDirFromFile(szFileName);

            // finish loading
            hcErr = pStencil->LoadFile(szFileName);
            if ( !hcErr )
            {
                _ATLTRY
                {
                    if (!pStencil->ParseReplacements(static_cast<ITagReplacer*>(this),
                                pStencil->GetBufferStart(), pStencil->GetBufferEnd()))
                            return HTTP_ERROR(500, ISE_SUBERR_BADSRF);

                    hcErr = FinishLoadStencil(pStencil, pLookup);
                    if (!hcErr)
                    {
                        pStencil->FinishParseReplacements();
                    }
                }
                _ATLCATCHALL()
                {
                    return HTTP_FAIL;
                }
            }

            // if everything is OK, cache the stencil
            if (!hcErr)
            {
                hcErr = CacheStencil(szFileName, pStencil);
            }
        
            if (pStencil && hcErr) // something went wrong, free stencil data
                FreeCacheStencil(pStencil);
        }
        else
        {
            hcErr = FinishLoadStencil(pStencil, pLookup);
        }
        return hcErr;
    }

    HTTP_CODE RenderStencil(IWriteStream* pStream, void* pState = NULL) throw(...)
    {
        if (!m_pLoadedStencil)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        WORD nCodePage = m_pLoadedStencil->GetCodePage();
        if (nCodePage != CP_ACP)
            m_nCodePage = nCodePage;

        HTTP_CODE hcErr = HTTP_FAIL;
        
        hcErr = m_pLoadedStencil->Render(static_cast<ITagReplacer*>(this),
                    pStream, pState);

        if (!IsAsyncStatus(hcErr) && m_pLoadedStencil->GetCacheItem())
            m_spStencilCache->ReleaseStencil(m_pLoadedStencil->GetCacheItem());

        return hcErr;
    }


    HTTP_CODE AddHandler(LPCSTR szName, IRequestHandler *pHandler, HINSTANCE hInstHandler) throw()
    {
        _ATLTRY
        {
            ATLASSERT(szName);
            ATLASSERT(pHandler);
            ATLASSERT(hInstHandler);
            HTTP_CODE hcErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
            if (szName && *szName && pHandler)
            {
                if (m_Handlers.SetAt(szName, pHandler))
                {
                    if (hInstHandler && m_hInstHandlers.Add(hInstHandler))
                        hcErr = HTTP_SUCCESS;
                }
            }
            return hcErr;
        }
        _ATLCATCHALL()
        {
            return HTTP_FAIL;
        }
    }

    void SendHandlerError(LPCSTR szHandlerName) throw()
    {
#ifndef _ATL_STENCIL_SLIENT_ERRORS
            m_pStream->WriteStream("Handler ");
            m_pStream->WriteStream(szHandlerName);
            m_pStream->WriteStream(" was not found");
#endif
    }

//Implementation

    void FreeHandlers() throw(...)
    {
        POSITION pos = m_Handlers.GetStartPosition();
        while (pos)
        {
            m_Handlers.GetNextValue(pos)->Release();
        }
        m_Handlers.RemoveAll();
        
        int nLen = m_hInstHandlers.GetSize();
        THandler *pT = static_cast<THandler *>(this);
        CComPtr<IDllCache> spDllCache;
        pT->m_spServiceProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache),
            (void **)&spDllCache);
        for (int i=0; i<nLen; i++)
        {
            spDllCache->Free(m_hInstHandlers[i]);
        }
        m_hInstHandlers.RemoveAll();
    }

    StencilType* GetNewCacheStencil() throw(...)
    {
        StencilType *pStencil = NULL;
        THandler *pT = static_cast<THandler *>(this);
        IAtlMemMgr *pMemMgr;
        if (FAILED(pT->m_spServiceProvider->QueryService(__uuidof(IAtlMemMgr), __uuidof(IAtlMemMgr), (void **)&pMemMgr)))
            pMemMgr = NULL;
        
        ATLTRY(pStencil = new StencilType(pMemMgr));
        if (pStencil != NULL)
            pStencil->Initialize(pT->m_spServiceProvider);
        return pStencil;
    }

    HTTP_CODE CacheStencil(
        LPCSTR szName, 
        StencilType* pStencilData) throw()
    {
        THandler *pT = static_cast<THandler *>(this);
        HRESULT hr = E_FAIL;

        HCACHEITEM hCacheItem = NULL;

        hr = m_spStencilCache->CacheStencil(szName,
                        pStencilData,
                        sizeof(StencilType*),
                        &hCacheItem,
                        pT->m_hInstHandler,
                        static_cast<IMemoryCacheClient*>(pStencilData));

        if (hr == S_OK && hCacheItem)
            pStencilData->SetCacheItem(hCacheItem);

        return  (hr == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
    }

    StencilType *FindCacheStencil(LPCSTR szName) throw()
    {
        if (!szName || !m_spStencilCache)
            return NULL;

        StencilType *pStencilData = NULL;

        HCACHEITEM hStencil;

        if (m_spStencilCache->LookupStencil(szName, &hStencil) != S_OK)
            return NULL;

        m_spStencilCache->GetStencil(hStencil, reinterpret_cast<void **>(&pStencilData));

        return pStencilData;
    }

    void FreeCacheStencil(StencilType* pStencilData) throw()
    {
        CComPtr<IMemoryCacheClient> spCacheClient;

        if (m_spStencilCache->QueryInterface(__uuidof(IMemoryCacheClient), (void **) &spCacheClient) == S_OK)
            spCacheClient->Free(pStencilData);
    }

    HTTP_CODE GetHandlerOffset(LPCSTR szHandlerName, DWORD* pdwOffset) throw()
    {
        if (!pdwOffset)
            return HTTP_FAIL;

        mapType::CPair *p = m_Handlers.Lookup(szHandlerName);
        if (p)
        {
            DWORD dwIndex = 0;
            POSITION pos = m_Handlers.GetStartPosition();
            while (pos)
            {
                const mapType::CPair *p1 = m_Handlers.GetNext(pos);
                if (p1 == p)
                {
                    *pdwOffset = dwIndex;
                    return HTTP_SUCCESS;
                }
                dwIndex++;
            }
            ATLASSERT(FALSE);
            return HTTP_SUCCESS;
        }
        *pdwOffset = 0;
        return HTTP_FAIL;
    }

    HTTP_CODE GetReplacementObject(DWORD dwObjOffset, ITagReplacer **ppReplacer) throw(...)
    {
        HRESULT hr = E_FAIL;

        POSITION pos = m_Handlers.GetStartPosition();
        for (DWORD dwIndex=0; dwIndex < dwObjOffset; dwIndex++)
            m_Handlers.GetNext(pos);

        ATLASSERT(pos != NULL);

        IRequestHandler *pHandler = NULL;
        pHandler = m_Handlers.GetValueAt(pos);

        ATLASSERT(pHandler != NULL);
 
        hr = pHandler->QueryInterface(__uuidof(ITagReplacer), (void**)ppReplacer);

        if (hr != S_OK)
            return HTTP_FAIL;

        return HTTP_SUCCESS;
    }

    // This is where we would actually load any extra request
    // handlers the HTML stencil might have parsed for us.
    HTTP_CODE FinishLoadStencil(StencilType *pStencil, IHttpRequestLookup * pLookup = NULL) throw(...)
    {
        THandler *pT = static_cast<THandler *>(this);
        ATLASSERT(pStencil);
        if (!pStencil)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED); // unexpected condition
        m_pLoadedStencil = pStencil;
        //load extra handlers if there are any
        StencilType::mapType *pExtraHandlersMap = 
            pStencil->GetExtraHandlers();
        
        if (pExtraHandlersMap)
        {
            POSITION pos = pExtraHandlersMap->GetStartPosition();
            CStringA name;
            CStringPair path;
            IRequestHandler *pHandler;
            HINSTANCE hInstHandler;
            while(pos)
            {
                pExtraHandlersMap->GetNextAssoc(pos, name, path);
                pHandler = NULL;
                hInstHandler = NULL;
                HTTP_CODE hcErr = pT->m_spExtension->LoadRequestHandler(path.strDllPath, path.strHandlerName,
                    pT->m_spServerContext,
                    &hInstHandler,
                    &pHandler);
                if (!hcErr)
                {
                    _ATLTRY
                    {
                        //map the name to the pointer to request handler
                        m_Handlers.SetAt(name, pHandler);
                        //store HINSTANCE of handler
                        m_hInstHandlers.Add(hInstHandler);
					}
                    _ATLCATCHALL()
                    {
                        return HTTP_FAIL;
                    }

                    if (pLookup)
                    {
						hcErr = pHandler->InitializeChild(&m_RequestInfo, pT->m_spServiceProvider, pLookup);
                        if (hcErr != HTTP_SUCCESS)
                            return hcErr;
                    }
    
                }
                else
                    return hcErr;
            }
        }
        return HTTP_SUCCESS;
    }
}; // class CHtmlTagReplacer


// CRequestHandlerT
// This is the base class for all user request handlers. This class implements
// the IReplacementHandler interface whose methods will be called to render HTML 
// into a stream. The stream will be returned as the HTTP response upon completion
// of the HTTP request.
template <	class THandler,
			class ThreadModel=CComSingleThreadModel,
			class TagReplacerType=CHtmlTagReplacer<THandler>
         >
class CRequestHandlerT : 
    public TagReplacerType,
    public CComObjectRootEx<ThreadModel>,
    public IRequestHandlerImpl<THandler>
{
protected:
    CStencilState m_state;
    CComObjectStackEx<CIDServerContext> m_SafeSrvCtx;
	typedef CRequestHandlerT<THandler, ThreadModel, TagReplacerType> _requestHandler;
   
public:
    BEGIN_COM_MAP(_requestHandler)
        COM_INTERFACE_ENTRY(IRequestHandler)
        COM_INTERFACE_ENTRY(ITagReplacer)
    END_COM_MAP()

    // public CRequestHandlerT members
    CHttpResponse m_HttpResponse;
    CHttpRequest m_HttpRequest;
    ATLSRV_REQUESTTYPE m_dwRequestType;
    AtlServerRequest* m_pRequestInfo;

    CRequestHandlerT() throw()
    {
        m_hInstHandler = NULL;
        m_dwAsyncFlags = 0;
        m_pRequestInfo = NULL;
    }

    ~CRequestHandlerT() throw()
    {
        FreeHandlers(); // free handlers held by CTagReplacer
    }

    void ClearResponse() throw()
    {
        m_HttpResponse.ClearResponse();
    }
    // Where user initialization should take place
    HTTP_CODE ValidateAndExchange() throw()
    {
        return HTTP_SUCCESS; // continue processing request
    }

    // Where user Uninitialization should take place
    HTTP_CODE Uninitialize(HTTP_CODE hcError) throw()
    {
        return hcError;
    }

    HTTP_CODE InitializeInternal(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider) throw()
    {
		// Initialize our internal references to required services
        m_pRequestInfo = pRequestInfo;
        m_state.pParentInfo = pRequestInfo;
        m_hInstHandler = pRequestInfo->hInstDll;
        m_spServerContext = pRequestInfo->pServerContext;
        m_spServiceProvider = pProvider;
        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeHandler(
        AtlServerRequest *pRequestInfo, 
        IServiceProvider *pProvider) throw(...)
    {
		HTTP_CODE hcErr = HTTP_FAIL;
        ATLASSERT(pRequestInfo);
        ATLASSERT(pProvider);

        THandler* pT = static_cast<THandler*>(this);
        hcErr = pT->InitializeInternal(pRequestInfo, pProvider);
        if (!hcErr)
		{
			m_HttpResponse.Initialize(m_spServerContext);
			hcErr = pT->CheckValidRequest();
			if (!hcErr)
			{
				hcErr = HTTP_FAIL;
				if (m_HttpRequest.Initialize(m_spServerContext, 
											 pT->MaxFormSize(),
											 pT->FormFlags()))
				{
					if (m_SafeSrvCtx.Initialize(&m_HttpResponse, &m_HttpRequest))
					{
						hcErr = TagReplacerType::Initialize(pRequestInfo, &m_SafeSrvCtx);
						if (!hcErr)
						{
							hcErr = pT->ValidateAndExchange();
						}
					}
				}
			}
		}
        return hcErr;
    }

    HTTP_CODE InitializeChild(
        AtlServerRequest *pRequestInfo, 
        IServiceProvider *pProvider, 
        IHttpRequestLookup *pRequestLookup) throw(...)
    {
        ATLASSERT(pRequestInfo);
        ATLASSERT(pProvider);

        THandler *pT = static_cast<THandler*>(this);
        HTTP_CODE hcErr = pT->InitializeInternal(pRequestInfo, pProvider);
        if (hcErr)
            return hcErr;

        if (pRequestLookup)
        {
            // initialize with the pRequestLookup
            m_HttpResponse.Initialize(pRequestLookup);

            // REVIEW: Initialize with the IHttpServerContext if it exists
            // the only time this is different than the previous call to 
            // initialize is if the user passes a different IHttpServerContext
            // in pRequestInfo than the one extracted from pRequestLookup.
            if (m_spServerContext)
                m_HttpResponse.Initialize(m_spServerContext);
            hcErr = pT->CheckValidRequest();
            if (hcErr)
                return hcErr;

            // initialize with the pRequestLookup to chain query parameters
            m_HttpRequest.Initialize(pRequestLookup);

            // initialize with the m_spServerContext to get additional query params
            // if they exist.
            if (m_spServerContext)
                m_HttpRequest.Initialize(m_spServerContext);
        }

        m_HttpResponse.SetBufferOutput(false); // child cannot buffer

        // initialize the safe server context
        // REVIEW: necessary?
        if (!m_SafeSrvCtx.Initialize(&m_HttpResponse, &m_HttpRequest))
            return HTTP_FAIL;
        hcErr = TagReplacerType::Initialize(pRequestInfo, &m_SafeSrvCtx);
        if (hcErr)
            return hcErr;

        return pT->ValidateAndExchange();
    }

    // HandleRequest is called to perform default processing of HTTP requests. Users
    // can override this function in their derived classes if they need to perform
    // specific initialization prior to processing this request or want to change the
    // way the request is processed.
    HTTP_CODE HandleRequest(
        AtlServerRequest *pRequestInfo,
        IServiceProvider* /*pServiceProvider*/) throw(...)
    {
        ATLASSERT(pRequestInfo);

        THandler *pT = static_cast<THandler *>(this);
        HTTP_CODE hcErr = HTTP_SUCCESS;

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN)
        {
            m_dwRequestType = pRequestInfo->dwRequestType;

            if (pRequestInfo->dwRequestType==ATLSRV_REQUEST_STENCIL)
            {
                LPCSTR szFileName = pRequestInfo->pServerContext->GetScriptPathTranslated();
                hcErr = HTTP_FAIL;
                if (szFileName)
                    hcErr = pT->LoadStencil(szFileName, static_cast<IHttpRequestLookup *>(&m_HttpRequest));
            }
        }
        else if (pRequestInfo->dwRequestState == ATLSRV_STATE_CONTINUE)
            m_HttpResponse.ClearContent();

#ifdef ATL_DEBUG_STENCILS
        if (m_pLoadedStencil && !m_pLoadedStencil->ParseSuccessful())
        {
            // An error or series of errors occurred in parsing the stencil
            m_pLoadedStencil->RenderErrors(static_cast<IWriteStream*>(&m_HttpResponse));
        }
#endif

        if (hcErr == HTTP_SUCCESS && m_pLoadedStencil)
        {
            // if anything other than HTTP_SUCCESS is returned during
            // the rendering of replacement tags, we return that value
            // here.
            hcErr = pT->RenderStencil(static_cast<IWriteStream*>(&m_HttpResponse), &m_state);

            if (hcErr == HTTP_SUCCESS && !m_HttpResponse.Flush(TRUE))
                hcErr = HTTP_FAIL;
        }

        if (IsAsyncFlushStatus(hcErr))
        {
            pRequestInfo->pszBuffer = LPCSTR(m_HttpResponse.m_strContent);
            pRequestInfo->dwBufferLen = m_HttpResponse.m_strContent.GetLength();
        }

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN || IsAsyncDoneStatus(hcErr))
            return pT->Uninitialize(hcErr);

        else if (!IsAsyncStatus(hcErr))
            m_HttpResponse.ClearContent();

        return hcErr;
    }

    HTTP_CODE ServerTransferRequest(LPCSTR szRequest, bool bContinueAfterTransfer=false,
        int nCodePage = 0, void *pState = NULL) throw(...)
    {
        return m_spExtension->TransferRequest(
                m_pRequestInfo,
                m_spServiceProvider,
                static_cast<IWriteStream*>(&m_HttpResponse),
                static_cast<IHttpRequestLookup*>(&m_HttpRequest),
                szRequest,
                nCodePage == 0 ? m_nCodePage : nCodePage,
                bContinueAfterTransfer,
                pState);
    }

    inline DWORD MaxFormSize() throw()
    {
        return DEFAULT_MAX_FORM_SIZE;
    }

    inline DWORD FormFlags() throw()
    {
        return ATL_FORM_FLAG_IGNORE_FILES;
    }

    // Override this function to check if the request
    // is valid. This function is called after m_HttpResponse
    // has been initialized, so you can use it if you need
    // to return an error to the client. This is also a
    // good place to initialize any internal class data needed
    // to handle the request. CRequestHandlerT::CheckValidRequest
    // is called after CRequestHandlerT::InitializeInternal is 
    // called, so your override of this method will have access to
    // m_pRequestInfo (this request's AtlServerRequest structure),
    // m_hInstHandler (the HINSTANCE of this handler dll),
    // m_spServerContext (the IHttpServerContext interface for this request),
    // m_spServiceProvider (the IServiceProvider interface for this request).
    // You should call CRequestHandlerT::CheckValidRequest in your override
    // if you override this function.
    // 
    // Note that m_HttpRequest has not been initialized, so
    // you cannot use it.  This function is intended to
    // do simple checking throught IHttpServerContext to avoid
    // expensive initialization of m_HttpRequest. 
    HTTP_CODE CheckValidRequest() throw()
    {
        LPCSTR szMethod = NULL;
        ATLASSERT(m_pRequestInfo);
        szMethod = m_pRequestInfo->pServerContext->GetRequestMethod();
        if (strcmp(szMethod, "GET") && strcmp(szMethod, "POST") && strcmp(szMethod, "HEAD"))
            return HTTP_NOT_IMPLEMENTED;

        return HTTP_SUCCESS;
    }

    HRESULT GetContext(REFIID riid, void** ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IHttpServerContext)))
        {
            return m_spServerContext.CopyTo((IHttpServerContext **)ppv);
        }
        if (InlineIsEqualGUID(riid, __uuidof(IHttpRequestLookup)))
        {
            *ppv = static_cast<IHttpRequestLookup*>(&m_HttpRequest);
            m_HttpRequest.AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IServiceProvider)))
        {
            *ppv = m_spServiceProvider;
            m_spServiceProvider.p->AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    template <typename Interface>
    HRESULT GetContext(Interface** ppInterface) throw()
    {
        return GetContext(__uuidof(Interface), reinterpret_cast<void**>(ppInterface));
    }
}; // class CRequestHandlerT

} // namespace ATL

#pragma warning( pop )

#endif // __ATLSTENCIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atltime.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_INL__
#define __ATLTIME_INL__

#pragma once

#ifndef __ATLTIME_H__
	#error atltime.inl requires atltime.h to be included first
#endif

#include <math.h>

namespace ATL
{
// Used only if these strings could not be found in resources.
__declspec(selectany) const TCHAR *szInvalidDateTime = _T("Invalid DateTime");
__declspec(selectany) const TCHAR *szInvalidDateTimeSpan = _T("Invalid DateTimeSpan");

const int maxTimeBufferSize = 128;
const long maxDaysInSpan  =	3615897L;

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline CTimeSpan::CTimeSpan() :
	m_timeSpan(0)
{
}

inline CTimeSpan::CTimeSpan( __time64_t time ) :
	m_timeSpan( time )
{
}

inline CTimeSpan::CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
 	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));
}

inline LONGLONG CTimeSpan::GetDays() const
{
	return( m_timeSpan/(24*3600) );
}

inline LONGLONG CTimeSpan::GetTotalHours() const
{
	return( m_timeSpan/3600 );
}

inline LONG CTimeSpan::GetHours() const
{
	return( LONG( GetTotalHours()-(GetDays()*24) ) );
}

inline LONGLONG CTimeSpan::GetTotalMinutes() const
{
	return( m_timeSpan/60 );
}

inline LONG CTimeSpan::GetMinutes() const
{
	return( LONG( GetTotalMinutes()-(GetTotalHours()*60) ) );
}

inline LONGLONG CTimeSpan::GetTotalSeconds() const
{
	return( m_timeSpan );
}

inline LONG CTimeSpan::GetSeconds() const
{
	return( LONG( GetTotalSeconds()-(GetTotalMinutes()*60) ) );
}

inline __time64_t CTimeSpan::GetTimeSpan() const
{
	return( m_timeSpan );
}

inline CTimeSpan CTimeSpan::operator+( CTimeSpan span ) const
{
	return( CTimeSpan( m_timeSpan+span.m_timeSpan ) );
}

inline CTimeSpan CTimeSpan::operator-( CTimeSpan span ) const
{
	return( CTimeSpan( m_timeSpan-span.m_timeSpan ) );
}

inline CTimeSpan& CTimeSpan::operator+=( CTimeSpan span )
{
	m_timeSpan += span.m_timeSpan;
	return( *this );
}

inline CTimeSpan& CTimeSpan::operator-=( CTimeSpan span )
{
	m_timeSpan -= span.m_timeSpan;
	return( *this );
}

inline bool CTimeSpan::operator==( CTimeSpan span ) const
{
	return( m_timeSpan == span.m_timeSpan );
}

inline bool CTimeSpan::operator!=( CTimeSpan span ) const
{
	return( m_timeSpan != span.m_timeSpan );
}

inline bool CTimeSpan::operator<( CTimeSpan span ) const
{
	return( m_timeSpan < span.m_timeSpan );
}

inline bool CTimeSpan::operator>( CTimeSpan span ) const
{
	return( m_timeSpan > span.m_timeSpan );
}

inline bool CTimeSpan::operator<=( CTimeSpan span ) const
{
	return( m_timeSpan <= span.m_timeSpan );
}

inline bool CTimeSpan::operator>=( CTimeSpan span ) const
{
	return( m_timeSpan >= span.m_timeSpan );
}

#ifndef _ATL_MIN_CRT
inline CString CTimeSpan::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
	TCHAR szBuffer[maxTimeBufferSize];
	TCHAR ch;
	LPTSTR pch = szBuffer;

	while ((ch = *pFormat++) != _T('\0'))
	{
		ATLASSERT(pch < &szBuffer[maxTimeBufferSize-1]);
		if (ch == _T('%'))
		{
			switch (ch = *pFormat++)
			{
			default:
				ATLASSERT(FALSE);      // probably a bad format character
				break;
			case '%':
				*pch++ = ch;
				break;
			case 'D':
				pch += _stprintf(pch, _T("%I64d"), GetDays());
				break;
			case 'H':
				pch += _stprintf(pch, _T("%02ld"), GetHours());
				break;
			case 'M':
				pch += _stprintf(pch, _T("%02ld"), GetMinutes());
				break;
			case 'S':
				pch += _stprintf(pch, _T("%02ld"), GetSeconds());
				break;
			}
		}
		else
		{
			*pch++ = ch;
			if (_istlead(ch))
			{
				ATLASSERT(pch < &szBuffer[maxTimeBufferSize]);
				*pch++ = *pFormat++;
			}
		}
	}

	*pch = '\0';
	return szBuffer;
}

inline CString CTimeSpan::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

#if defined(_AFX) && defined(_UNICODE)
inline CString CTimeSpan::Format(LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CTime
/////////////////////////////////////////////////////////////////////////////

inline CTime CTime::GetCurrentTime()
{
	return( CTime( ::_time64( NULL ) ) );
}

inline CTime::CTime() :
	m_time(0)
{
}

inline CTime::CTime( __time64_t time ) :
	m_time( time )
{
}

inline CTime::CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
	int nDST)
{
	struct tm atm;
	atm.tm_sec = nSec;
	atm.tm_min = nMin;
	atm.tm_hour = nHour;
	ATLASSERT(nDay >= 1 && nDay <= 31);
	atm.tm_mday = nDay;
	ATLASSERT(nMonth >= 1 && nMonth <= 12);
	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
	ATLASSERT(nYear >= 1900);
	atm.tm_year = nYear - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}

inline CTime::CTime(WORD wDosDate, WORD wDosTime, int nDST)
{
	struct tm atm;
	atm.tm_sec = (wDosTime & ~0xFFE0) << 1;
	atm.tm_min = (wDosTime & ~0xF800) >> 5;
	atm.tm_hour = wDosTime >> 11;

	atm.tm_mday = wDosDate & ~0xFFE0;
	atm.tm_mon = ((wDosDate & ~0xFE00) >> 5) - 1;
	atm.tm_year = (wDosDate >> 9) + 80;
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}

inline CTime::CTime(const SYSTEMTIME& sysTime, int nDST)
{
	if (sysTime.wYear < 1900)
	{
		__time64_t time0 = 0L;
		CTime timeT(time0);
		*this = timeT;
	}
	else
	{
		CTime timeT(
			(int)sysTime.wYear, (int)sysTime.wMonth, (int)sysTime.wDay,
			(int)sysTime.wHour, (int)sysTime.wMinute, (int)sysTime.wSecond,
			nDST);
		*this = timeT;
	}
}

inline CTime::CTime(const FILETIME& fileTime, int nDST)
{
	// first convert file time (UTC time) to local time
	FILETIME localTime;
	if (!FileTimeToLocalFileTime(&fileTime, &localTime))
	{
		m_time = 0;
		return;
	}

	// then convert that time to system time
	SYSTEMTIME sysTime;
	if (!FileTimeToSystemTime(&localTime, &sysTime))
	{
		m_time = 0;
		return;
	}

	// then convert the system time to a time_t (C-runtime local time)
	CTime timeT(sysTime, nDST);
	*this = timeT;
}

#ifdef __oledb_h__
inline CTime::CTime( const DBTIMESTAMP& dbts, int nDST )
{
	struct tm atm;
	atm.tm_sec = dbts.second;
	atm.tm_min = dbts.minute;
	atm.tm_hour = dbts.hour;
	atm.tm_mday = dbts.day;
	atm.tm_mon = dbts.month - 1;        // tm_mon is 0 based
	ATLASSERT(dbts.year >= 1900);
	atm.tm_year = dbts.year - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}
#endif

inline CTime& CTime::operator=( __time64_t time )
{
	m_time = time;

	return( *this );
}

inline CTime& CTime::operator+=( CTimeSpan span )
{
	m_time += span.GetTimeSpan();

	return( *this );
}

inline CTime& CTime::operator-=( CTimeSpan span )
{
	m_time -= span.GetTimeSpan();

	return( *this );
}

inline CTimeSpan CTime::operator-( CTime time ) const
{
	return( CTimeSpan( m_time-time.m_time ) );
}

inline CTime CTime::operator-( CTimeSpan span ) const
{
	return( CTime( m_time-span.GetTimeSpan() ) );
}

inline CTime CTime::operator+( CTimeSpan span ) const
{
	return( CTime( m_time+span.GetTimeSpan() ) );
}

inline bool CTime::operator==( CTime time ) const
{
	return( m_time == time.m_time );
}

inline bool CTime::operator!=( CTime time ) const
{
	return( m_time != time.m_time );
}

inline bool CTime::operator<( CTime time ) const
{
	return( m_time < time.m_time );
}

inline bool CTime::operator>( CTime time ) const
{
	return( m_time > time.m_time );
}

inline bool CTime::operator<=( CTime time ) const
{
	return( m_time <= time.m_time );
}

inline bool CTime::operator>=( CTime time ) const
{
	return( m_time >= time.m_time );
}

inline struct tm* CTime::GetGmtTm(struct tm* ptm) const
{
	if (ptm != NULL)
	{
		*ptm = *_gmtime64(&m_time);
		return ptm;
	}
	else
		return _gmtime64(&m_time);
}

inline struct tm* CTime::GetLocalTm(struct tm* ptm) const
{
	if (ptm != NULL)
	{
		struct tm* ptmTemp = _localtime64(&m_time);
		if (ptmTemp == NULL)
			return NULL;    // indicates the m_time was not initialized!

		*ptm = *ptmTemp;
		return ptm;
	}
	else
		return _localtime64(&m_time);
}

inline bool CTime::GetAsSystemTime(SYSTEMTIME& timeDest) const
{
	struct tm* ptm = GetLocalTm(NULL);
	if (!ptm)
		return false;

	timeDest.wYear = (WORD) (1900 + ptm->tm_year);
	timeDest.wMonth = (WORD) (1 + ptm->tm_mon);
	timeDest.wDayOfWeek = (WORD) ptm->tm_wday;
	timeDest.wDay = (WORD) ptm->tm_mday;
	timeDest.wHour = (WORD) ptm->tm_hour;
	timeDest.wMinute = (WORD) ptm->tm_min;
	timeDest.wSecond = (WORD) ptm->tm_sec;
	timeDest.wMilliseconds = 0;

	return true;
}

#ifdef __oledb_h__
inline bool CTime::GetAsDBTIMESTAMP( DBTIMESTAMP& dbts ) const
{
	struct tm* ptm = GetLocalTm(NULL);
	if (!ptm)
		return false;

	dbts.year = (SHORT) (1900 + ptm->tm_year);
	dbts.month = (USHORT) (1 + ptm->tm_mon);
	dbts.day = (USHORT) ptm->tm_mday;
	dbts.hour = (USHORT) ptm->tm_hour;
	dbts.minute = (USHORT) ptm->tm_min;
	dbts.second = (USHORT) ptm->tm_sec;
	dbts.fraction = 0;

	return true;
}
#endif

inline __time64_t CTime::GetTime() const
{
	return( m_time );
}

inline int CTime::GetYear() const
{ 
	return( GetLocalTm()->tm_year+1900 ); 
}

inline int CTime::GetMonth() const
{ 
	return( GetLocalTm()->tm_mon+1 ); 
}

inline int CTime::GetDay() const
{ 
	return( GetLocalTm()->tm_mday ); 
}

inline int CTime::GetHour() const
{ 
	return( GetLocalTm()->tm_hour ); 
}

inline int CTime::GetMinute() const
{ 
	return( GetLocalTm()->tm_min ); 
}

inline int CTime::GetSecond() const
{ 
	return( GetLocalTm()->tm_sec ); 
}

inline int CTime::GetDayOfWeek() const
{ 
	return( GetLocalTm()->tm_wday+1 ); 
}

#ifndef _ATL_MIN_CRT
inline CString CTime::Format(LPCTSTR pFormat) const
{
	TCHAR szBuffer[maxTimeBufferSize];

	struct tm* ptmTemp = _localtime64(&m_time);
	if (ptmTemp == NULL ||
		!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, ptmTemp))
		szBuffer[0] = '\0';
	return szBuffer;
}

inline CString CTime::FormatGmt(LPCTSTR pFormat) const
{
	TCHAR szBuffer[maxTimeBufferSize];

	struct tm* ptmTemp = _gmtime64(&m_time);
	if (ptmTemp == NULL ||
		!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, ptmTemp))
		szBuffer[0] = '\0';
	return szBuffer;
}

inline CString CTime::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}

inline CString CTime::FormatGmt(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return FormatGmt(strFormat);
}
#endif // !_ATL_MIN_CRT

#if defined (_AFX) && defined(_UNICODE)
inline CString CTime::Format(LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}

inline CString CTime::FormatGmt(LPCSTR pFormat) const
{
	return FormatGmt(CString(pFormat));
}
#endif // _AFX && _UNICODE

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline COleDateTimeSpan::COleDateTimeSpan() : m_span(0), m_status(valid)
{
}

inline COleDateTimeSpan::COleDateTimeSpan(double dblSpanSrc) : m_span(dblSpanSrc), m_status(valid)
{
	CheckRange();
}

inline COleDateTimeSpan::COleDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
	SetDateTimeSpan(lDays, nHours, nMins, nSecs);
}

inline void COleDateTimeSpan::SetStatus(DateTimeSpanStatus status)
{
	m_status = status;
}

inline COleDateTimeSpan::DateTimeSpanStatus COleDateTimeSpan::GetStatus() const
{
	return m_status;
}

__declspec(selectany) const double
	COleDateTimeSpan::OLE_DATETIME_HALFSECOND =
	1.0 / (2.0 * (60.0 * 60.0 * 24.0));

inline double COleDateTimeSpan::GetTotalDays() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG(m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND));
}

inline double COleDateTimeSpan::GetTotalHours() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG((m_span + (m_span < 0 ? 
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * 24);
}

inline double COleDateTimeSpan::GetTotalMinutes() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60));
}

inline double COleDateTimeSpan::GetTotalSeconds() const
{
	ATLASSERT(GetStatus() == valid);
	
	return LONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60 * 60));
}

inline LONG COleDateTimeSpan::GetDays() const
{
	ATLASSERT(GetStatus() == valid);
	return LONG(m_span);
}

inline LONG COleDateTimeSpan::GetHours() const
{
	return LONG(GetTotalHours()) % 24;
}

inline LONG COleDateTimeSpan::GetMinutes() const
{
	return LONG(GetTotalMinutes()) % 60;
}

inline LONG COleDateTimeSpan::GetSeconds() const
{
	return LONG(GetTotalSeconds()) % 60;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
	m_span = dblSpanSrc;
	m_status = valid;
	CheckRange();
	return *this;
}

inline bool COleDateTimeSpan::operator==(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return (m_status == dateSpan.m_status &&
		m_span == dateSpan.m_span);
}

inline bool COleDateTimeSpan::operator!=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return (m_status != dateSpan.m_status ||
		m_span != dateSpan.m_span);
}

inline bool COleDateTimeSpan::operator<(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span < dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator>(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span > dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator<=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span <= dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator>=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span >= dateSpan.m_span;
}

inline COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Add spans and validate within legal range
	dateSpanTemp.m_span = m_span + dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

inline COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Subtract spans and validate within legal range
	dateSpanTemp.m_span = m_span - dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator+=(const COleDateTimeSpan dateSpan)
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this + dateSpan;
	CheckRange();
	return *this;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator-=(const COleDateTimeSpan dateSpan)
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this - dateSpan;
	CheckRange();
	return *this;
}

inline COleDateTimeSpan COleDateTimeSpan::operator-() const
{
	return -this->m_span;
}

inline COleDateTimeSpan::operator double() const
{
	return m_span;
}

inline void COleDateTimeSpan::SetDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
	// Set date span by breaking into fractional days (all input ranges valid)
	m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
		((double)nSecs)/(24*60*60);
	m_status = valid;
	CheckRange();
}

#ifndef _ATL_MIN_CRT
inline CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	CTimeSpan tmp(GetDays(), GetHours(), GetMinutes(), GetSeconds());
	return tmp.Format(pFormat);
}

inline CString COleDateTimeSpan::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

inline void COleDateTimeSpan::CheckRange()
{
	if(m_span < -maxDaysInSpan || m_span > maxDaysInSpan)
		m_status = invalid;
}

/////////////////////////////////////////////////////////////////////////////
// COleDateTime
/////////////////////////////////////////////////////////////////////////////

inline COleDateTime COleDateTime::GetCurrentTime()
{
	return COleDateTime(::_time64(NULL));
}

inline COleDateTime::COleDateTime() :
	m_dt( 0 ), m_status(valid)
{
}

inline COleDateTime::COleDateTime( const VARIANT& varSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = varSrc;
}

inline COleDateTime::COleDateTime( DATE dtSrc ) :
	m_dt( dtSrc ), m_status(valid)
{
}

#ifndef  _WIN64

inline COleDateTime::COleDateTime( time_t timeSrc) :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

#endif

inline COleDateTime::COleDateTime( __time64_t timeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

inline COleDateTime::COleDateTime( const SYSTEMTIME& systimeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = systimeSrc;
}

inline COleDateTime::COleDateTime( const FILETIME& filetimeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = filetimeSrc;
}

inline COleDateTime::COleDateTime(int nYear, int nMonth, int nDay,
	int nHour, int nMin, int nSec)
{
	SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec);
}

inline COleDateTime::COleDateTime(WORD wDosDate, WORD wDosTime)
{
	m_status = ::DosDateTimeToVariantTime(wDosDate, wDosTime, &m_dt) ?
		valid : invalid;
}

inline void COleDateTime::SetStatus(DateTimeStatus status)
{
	m_status = status;
}

inline COleDateTime::DateTimeStatus COleDateTime::GetStatus() const
{
	return m_status;
}

inline bool COleDateTime::GetAsSystemTime(SYSTEMTIME& sysTime) const
{
	return GetStatus() == valid && ::VariantTimeToSystemTime(m_dt, &sysTime);
}

inline bool COleDateTime::GetAsUDATE(UDATE &udate) const
{
	return SUCCEEDED(::VarUdateFromDate(m_dt, 0, &udate));
}

inline int COleDateTime::GetYear() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wYear : error;
}

inline int COleDateTime::GetMonth() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMonth : error;
}

inline int COleDateTime::GetDay() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDay : error;
}

inline int COleDateTime::GetHour() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wHour : error;
}

inline int COleDateTime::GetMinute() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMinute : error;
}

inline int COleDateTime::GetSecond() const
{ 
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wSecond : error;
}

inline int COleDateTime::GetDayOfWeek() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDayOfWeek + 1 : error;
}

inline int COleDateTime::GetDayOfYear() const
{
	UDATE udate;
	return GetAsUDATE(udate) ? udate.wDayOfYear : error;
}

inline COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
	if (varSrc.vt != VT_DATE)
	{
		VARIANT varDest;
		varDest.vt = VT_EMPTY;
		if(SUCCEEDED(::VariantChangeType(&varDest, const_cast<VARIANT *>(&varSrc), 0, VT_DATE)))
		{
			m_dt = varDest.date;
			m_status = valid;
		}
		else
			m_status = invalid;
	}
	else
	{
		m_dt = varSrc.date;
		m_status = valid;
	}

	return *this;
}

inline COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
	m_dt = dtSrc;
	m_status = valid;
	return *this;
}

#ifndef  _WIN64

inline COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
	return operator=(static_cast<__time64_t>(timeSrc));
}

#endif // _WIN64

inline COleDateTime& COleDateTime::operator=(const __time64_t& timeSrc)
{
	SYSTEMTIME st;
	CTime tmp(timeSrc);
	
	m_status = tmp.GetAsSystemTime(st) &&
		::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;

	return *this;
}

inline COleDateTime &COleDateTime::operator=(const SYSTEMTIME &systimeSrc)
{
	m_status = ::SystemTimeToVariantTime(const_cast<SYSTEMTIME *>(&systimeSrc), &m_dt) ?
		valid : invalid;
	return *this;
}

inline COleDateTime &COleDateTime::operator=(const FILETIME &filetimeSrc)
{
	SYSTEMTIME st;
	m_status = ::FileTimeToSystemTime(&filetimeSrc, &st) &&
				::SystemTimeToVariantTime(&st, &m_dt) ?
		valid : invalid;

	return *this;
}

inline COleDateTime &COleDateTime::operator=(const UDATE &udate)
{
	m_status = (S_OK == VarDateFromUdate((UDATE*)&udate, 0, &m_dt)) ? valid : invalid;

	return *this;
}

inline bool COleDateTime::operator==( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( m_dt == date.m_dt );
}

inline bool COleDateTime::operator!=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( m_dt != date.m_dt );
}

inline bool COleDateTime::operator<( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) < DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator>( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) > DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator<=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) <= DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator>=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) >= DoubleFromDate( date.m_dt ) );
}

inline COleDateTime COleDateTime::operator+( COleDateTimeSpan dateSpan ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan ) ) );
}

inline COleDateTime COleDateTime::operator-( COleDateTimeSpan dateSpan ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan ) ) );
}
	
inline COleDateTime& COleDateTime::operator+=( COleDateTimeSpan dateSpan )
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan );
	return( *this );
}

inline COleDateTime& COleDateTime::operator-=( COleDateTimeSpan dateSpan )
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan );
	return( *this );
}

inline COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

inline COleDateTime::operator DATE() const
{
	ATLASSERT(GetStatus() == valid);
	return( m_dt );
}

inline int COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
	int nHour, int nMin, int nSec)
{
	SYSTEMTIME st;
	::ZeroMemory(&st, sizeof(SYSTEMTIME));

	st.wYear = WORD(nYear);
	st.wMonth = WORD(nMonth);
	st.wDay = WORD(nDay);
	st.wHour = WORD(nHour);
	st.wMinute = WORD(nMin);
	st.wSecond = WORD(nSec);

	return m_status = ::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;
}

inline int COleDateTime::SetDate(int nYear, int nMonth, int nDay)
{
	return SetDateTime(nYear, nMonth, nDay, 0, 0, 0);
}

inline int COleDateTime::SetTime(int nHour, int nMin, int nSec)
{
	// Set date to zero date - 12/30/1899
	return SetDateTime(1899, 12, 30, nHour, nMin, nSec);
}

inline bool COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
	USES_CONVERSION;
	CString strDate = lpszDate;

	HRESULT hr;
	if (FAILED(hr = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
		dwFlags, &m_dt)))
	{
		if (hr == DISP_E_TYPEMISMATCH)
		{
			// Can't convert string to date, set 0 and invalidate
			m_dt = 0;
			m_status = invalid;
			return false;
		}
		else if (hr == DISP_E_OVERFLOW)
		{
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
		else
		{
			ATLTRACE(atlTraceTime, 0, _T("\nCOleDateTime VarDateFromStr call failed.\n\t"));
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
	}

	m_status = valid;
	return true;
}

#ifndef _ATL_MIN_CRT
inline CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if (GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CComBSTR bstr;
	if (FAILED(::VarBstrFromDate(m_dt, lcid, dwFlags, &bstr)))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CString tmp = CString(bstr);
	return tmp;
}

inline CString COleDateTime::Format(LPCTSTR pFormat) const
{
	// If null, return empty string
	if(GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if(GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	UDATE ud;
	if (S_OK != VarUdateFromDate(m_dt, 0, &ud))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	struct tm tmTemp;
	tmTemp.tm_sec	= ud.st.wSecond;
	tmTemp.tm_min	= ud.st.wMinute;
	tmTemp.tm_hour	= ud.st.wHour;
	tmTemp.tm_mday	= ud.st.wDay;
	tmTemp.tm_mon	= ud.st.wMonth - 1;
	tmTemp.tm_year	= ud.st.wYear - 1900;
	tmTemp.tm_wday	= ud.st.wDayOfWeek;
	tmTemp.tm_yday	= ud.wDayOfYear - 1;
	tmTemp.tm_isdst	= 0;

	CString strDate;
	LPTSTR lpszTemp = strDate.GetBufferSetLength(256);
	_tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
	strDate.ReleaseBuffer();

	return strDate;
}

inline CString COleDateTime::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

inline double COleDateTime::DoubleFromDate( DATE date )
{
	double fTemp;

	// No problem if positive
	if( date >= 0 )
	{
		return( date );
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
	fTemp = ceil( date );

	return( fTemp-(date-fTemp) );
}

inline DATE COleDateTime::DateFromDouble( double f )
{
	double fTemp;

	// No problem if positive
	if( f >= 0 )
	{
		return( f );
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
	fTemp = floor( f ); // fTemp is now whole part
	
	return( fTemp+(fTemp-f) );
}

/////////////////////////////////////////////////////////////////////////////
// CFileTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline CFileTimeSpan::CFileTimeSpan() :
	m_nSpan( 0 )
{
}

// REVIEW
inline CFileTimeSpan::CFileTimeSpan( const CFileTimeSpan& span ) :
	m_nSpan( span.m_nSpan )
{
}

inline CFileTimeSpan::CFileTimeSpan( LONGLONG nSpan ) :
	m_nSpan( nSpan )
{
}

inline CFileTimeSpan& CFileTimeSpan::operator=( const CFileTimeSpan& span )
{
	m_nSpan = span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan& CFileTimeSpan::operator+=( CFileTimeSpan span )
{
	m_nSpan += span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan& CFileTimeSpan::operator-=( CFileTimeSpan span )
{
	m_nSpan -= span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan CFileTimeSpan::operator+( CFileTimeSpan span ) const
{
	return( CFileTimeSpan( m_nSpan+span.m_nSpan ) );
}

inline CFileTimeSpan CFileTimeSpan::operator-( CFileTimeSpan span ) const
{
	return( CFileTimeSpan( m_nSpan-span.m_nSpan ) );
}

inline bool CFileTimeSpan::operator==( CFileTimeSpan span ) const
{
	return( m_nSpan == span.m_nSpan );
}

inline bool CFileTimeSpan::operator!=( CFileTimeSpan span ) const
{
	return( m_nSpan != span.m_nSpan );
}

inline bool CFileTimeSpan::operator<( CFileTimeSpan span ) const
{
	return( m_nSpan < span.m_nSpan );
}

inline bool CFileTimeSpan::operator>( CFileTimeSpan span ) const
{
	return( m_nSpan > span.m_nSpan );
}

inline bool CFileTimeSpan::operator<=( CFileTimeSpan span ) const
{
	return( m_nSpan <= span.m_nSpan );
}

inline bool CFileTimeSpan::operator>=( CFileTimeSpan span ) const
{
	return( m_nSpan >= span.m_nSpan );
}

inline LONGLONG CFileTimeSpan::GetTimeSpan() const
{
	return( m_nSpan );
}

inline void CFileTimeSpan::SetTimeSpan( LONGLONG nSpan )
{
	m_nSpan = nSpan;
}


/////////////////////////////////////////////////////////////////////////////
// CFileTime
/////////////////////////////////////////////////////////////////////////////

inline CFileTime::CFileTime()
{
	dwLowDateTime = 0;
	dwHighDateTime = 0;
}

inline CFileTime::CFileTime( const FILETIME& ft )
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;
}

inline CFileTime::CFileTime( ULONGLONG nTime )
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

inline CFileTime& CFileTime::operator=( const FILETIME& ft )
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;

	return( *this );
}

inline CFileTime CFileTime::GetCurrentTime()
{
	CFileTime ft;
	GetSystemTimeAsFileTime(&ft);
	return ft;
}

inline CFileTime& CFileTime::operator+=( CFileTimeSpan span )
{
	SetTime( GetTime()+span.GetTimeSpan() );

	return( *this );
}

inline CFileTime& CFileTime::operator-=( CFileTimeSpan span )
{
	SetTime( GetTime()-span.GetTimeSpan() );

	return( *this );
}

inline CFileTime CFileTime::operator+( CFileTimeSpan span ) const
{
	return( CFileTime( GetTime()+span.GetTimeSpan() ) );
}

inline CFileTime CFileTime::operator-( CFileTimeSpan span ) const
{
	return( CFileTime( GetTime()-span.GetTimeSpan() ) );
}

inline CFileTimeSpan CFileTime::operator-( CFileTime ft ) const
{
	return( CFileTimeSpan( GetTime()-ft.GetTime() ) );
}

inline bool CFileTime::operator==( CFileTime ft ) const
{
	return( GetTime() == ft.GetTime() );
}

inline bool CFileTime::operator!=( CFileTime ft ) const
{
	return( GetTime() != ft.GetTime() );
}

inline bool CFileTime::operator<( CFileTime ft ) const
{
	return( GetTime() < ft.GetTime() );
}

inline bool CFileTime::operator>( CFileTime ft ) const
{
	return( GetTime() > ft.GetTime() );
}

inline bool CFileTime::operator<=( CFileTime ft ) const
{
	return( GetTime() <= ft.GetTime() );
}

inline bool CFileTime::operator>=( CFileTime ft ) const
{
	return( GetTime() >= ft.GetTime() );
}

inline ULONGLONG CFileTime::GetTime() const
{
	return( (ULONGLONG( dwHighDateTime )<<32)|dwLowDateTime );
}

inline void CFileTime::SetTime( ULONGLONG nTime )
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

inline CFileTime CFileTime::UTCToLocal() const
{
	CFileTime ftLocal;

	::FileTimeToLocalFileTime( this, &ftLocal );

	return( ftLocal );
}

inline CFileTime CFileTime::LocalToUTC() const
{
	CFileTime ftUTC;

	::LocalFileTimeToFileTime( this, &ftUTC );

	return( ftUTC );
}

}  // namespace ATL
#endif //__ATLTIME_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\atlmfc\atltime.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_H__
#define __ATLTIME_H__

#pragma once

#include <atldef.h>

#ifndef _ATL_MIN_CRT
#include <time.h>

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif
#endif

namespace ATL
{
class CTimeSpan
{
public:
	CTimeSpan() throw();
	CTimeSpan( __time64_t time ) throw();
	CTimeSpan( LONG lDays, int nHours, int nMins, int nSecs ) throw();

	LONGLONG GetDays() const throw();
	LONGLONG GetTotalHours() const throw();
	LONG GetHours() const throw();
	LONGLONG GetTotalMinutes() const throw();
	LONG GetMinutes() const throw();
	LONGLONG GetTotalSeconds() const throw();
	LONG GetSeconds() const throw();

	__time64_t GetTimeSpan() const throw();

	CTimeSpan operator+( CTimeSpan span ) const throw();
	CTimeSpan operator-( CTimeSpan span ) const throw();
	CTimeSpan& operator+=( CTimeSpan span ) throw();
	CTimeSpan& operator-=( CTimeSpan span ) throw();
	bool operator==( CTimeSpan span ) const throw();
	bool operator!=( CTimeSpan span ) const throw();
	bool operator<( CTimeSpan span ) const throw();
	bool operator>( CTimeSpan span ) const throw();
	bool operator<=( CTimeSpan span ) const throw();
	bool operator>=( CTimeSpan span ) const throw();

#ifndef _ATL_MIN_CRT
public:
	CString Format( LPCTSTR pszFormat ) const;
	CString Format( UINT nID ) const;
#endif
#if defined(_AFX) && defined(_UNICODE)
	// REVIEW
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(CArchive& ar);
#endif

private:
	__time64_t m_timeSpan;
};

class CTime
{
public:
	static CTime GetCurrentTime() throw();

	CTime() throw();
	CTime( __time64_t time ) throw();
	CTime( int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
		int nDST = -1 ) throw();
	CTime( WORD wDosDate, WORD wDosTime, int nDST = -1 ) throw();
	CTime( const SYSTEMTIME& st, int nDST = -1 ) throw();
	CTime( const FILETIME& ft, int nDST = -1 ) throw();
#ifdef __oledb_h__
	CTime( const DBTIMESTAMP& dbts, int nDST = -1 ) throw();
#endif

	CTime& operator=( __time64_t time ) throw();

	CTime& operator+=( CTimeSpan span ) throw();
	CTime& operator-=( CTimeSpan span ) throw();

	CTimeSpan operator-( CTime time ) const throw();
	CTime operator-( CTimeSpan span ) const throw();
	CTime operator+( CTimeSpan span ) const throw();

	bool operator==( CTime time ) const throw();
	bool operator!=( CTime time ) const throw();
	bool operator<( CTime time ) const throw();
	bool operator>( CTime time ) const throw();
	bool operator<=( CTime time ) const throw();
	bool operator>=( CTime time ) const throw();

	struct tm* GetGmtTm( struct tm* ptm = NULL ) const throw();
	struct tm* GetLocalTm( struct tm* ptm = NULL ) const throw();
	bool GetAsSystemTime( SYSTEMTIME& st ) const throw();
#ifdef __oledb_h__
	bool GetAsDBTIMESTAMP( DBTIMESTAMP& dbts ) const throw();
#endif

	__time64_t GetTime() const throw();

	int GetYear() const throw();
	int GetMonth() const throw();
	int GetDay() const throw();
	int GetHour() const throw();
	int GetMinute() const throw();
	int GetSecond() const throw();
	int GetDayOfWeek() const throw();

#ifndef _ATL_MIN_CRT
	// formatting using "C" strftime
	CString Format( LPCTSTR pszFormat ) const;
	CString FormatGmt( LPCTSTR pszFormat ) const;
	CString Format( UINT nFormatID ) const;
	CString FormatGmt( UINT nFormatID ) const;
#endif

#if defined(_AFX) && defined(_UNICODE)
	// REVIEW
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
	CString FormatGmt(LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(CArchive& ar);
#endif

private:
	__time64_t m_time;
};

class COleDateTimeSpan
{
// Constructors
public:
	COleDateTimeSpan() throw();

	COleDateTimeSpan(double dblSpanSrc) throw();
	COleDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs) throw();

// Attributes
	enum DateTimeSpanStatus
	{
		valid = 0,
		invalid = 1,    // Invalid span (out of range, etc.)
		null = 2,       // Literally has no value
	};

	double m_span;
	DateTimeSpanStatus m_status;

	void SetStatus(DateTimeSpanStatus status) throw();
	DateTimeSpanStatus GetStatus() const throw();

	double GetTotalDays() const throw();    // span in days (about -3.65e6 to 3.65e6)
	double GetTotalHours() const throw();   // span in hours (about -8.77e7 to 8.77e6)
	double GetTotalMinutes() const throw(); // span in minutes (about -5.26e9 to 5.26e9)
	double GetTotalSeconds() const throw(); // span in seconds (about -3.16e11 to 3.16e11)

	LONG GetDays() const throw();       // component days in span
	LONG GetHours() const throw();      // component hours in span (-23 to 23)
	LONG GetMinutes() const throw();    // component minutes in span (-59 to 59)
	LONG GetSeconds() const throw();    // component seconds in span (-59 to 59)

// Operations
	COleDateTimeSpan& operator=(double dblSpanSrc) throw();

	bool operator==(const COleDateTimeSpan& dateSpan) const throw();
	bool operator!=(const COleDateTimeSpan& dateSpan) const throw();
	bool operator<(const COleDateTimeSpan& dateSpan) const throw();
	bool operator>(const COleDateTimeSpan& dateSpan) const throw();
	bool operator<=(const COleDateTimeSpan& dateSpan) const throw();
	bool operator>=(const COleDateTimeSpan& dateSpan) const throw();

	// DateTimeSpan math
	COleDateTimeSpan operator+(const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan operator-(const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan& operator+=(const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan& operator-=(const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan operator-() const throw();

	operator double() const throw();

	void SetDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs) throw();

#ifndef _ATL_MIN_CRT
	// formatting
	CString Format(LPCTSTR pFormat) const;
	CString Format(UINT nID) const;
#endif

// Implementation
	void CheckRange();

private:
	static const double OLE_DATETIME_HALFSECOND;
};

class COleDateTime
{
// Constructors
public:
	static COleDateTime GetCurrentTime() throw();

	COleDateTime() throw();

	COleDateTime(const VARIANT& varSrc) throw();
	COleDateTime(DATE dtSrc) throw();

#ifndef  _WIN64

	COleDateTime(time_t timeSrc) throw();

#endif // _WIN64

	COleDateTime(__time64_t timeSrc) throw();

	COleDateTime(const SYSTEMTIME& systimeSrc) throw();
	COleDateTime(const FILETIME& filetimeSrc) throw();

	COleDateTime(int nYear, int nMonth, int nDay,
		int nHour, int nMin, int nSec) throw();
	COleDateTime(WORD wDosDate, WORD wDosTime) throw();

// Attributes
	enum DateTimeStatus
	{
		error = -1,
		valid = 0,
		invalid = 1,    // Invalid date (out of range, etc.)
		null = 2,       // Literally has no value
	};

	DATE m_dt;
	DateTimeStatus m_status;

	void SetStatus(DateTimeStatus status) throw();
	DateTimeStatus GetStatus() const throw();

	bool GetAsSystemTime(SYSTEMTIME& sysTime) const throw();
	bool GetAsUDATE( UDATE& udate ) const throw();

	int GetYear() const throw();
	// Month of year (1 = January)
	int GetMonth() const throw();
	// Day of month (1-31)
	int GetDay() const throw();
	// Hour in day (0-23)
	int GetHour() const throw();
	// Minute in hour (0-59)
	int GetMinute() const throw();
	// Second in minute (0-59)
	int GetSecond() const throw();
	// Day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
	int GetDayOfWeek() const throw();
	// Days since start of year (1 = January 1)
	int GetDayOfYear() const throw();

// Operations
	COleDateTime& operator=(const VARIANT& varSrc) throw();
	COleDateTime& operator=(DATE dtSrc) throw();

#ifndef  _WIN64

	COleDateTime& operator=(const time_t& timeSrc) throw();
	
#endif // _WIN64

	COleDateTime& operator=(const __time64_t& timeSrc) throw();

	COleDateTime& operator=(const SYSTEMTIME& systimeSrc) throw();
	COleDateTime& operator=(const FILETIME& filetimeSrc) throw();
	COleDateTime& operator=(const UDATE& udate) throw();

	bool operator==(const COleDateTime& date) const throw();
	bool operator!=(const COleDateTime& date) const throw();
	bool operator<(const COleDateTime& date) const throw();
	bool operator>(const COleDateTime& date) const throw();
	bool operator<=(const COleDateTime& date) const throw();
	bool operator>=(const COleDateTime& date) const throw();

	// DateTime math
	COleDateTime operator+(COleDateTimeSpan dateSpan) const throw();
	COleDateTime operator-(COleDateTimeSpan dateSpan) const throw();
	COleDateTime& operator+=(COleDateTimeSpan dateSpan) throw();
	COleDateTime& operator-=(COleDateTimeSpan dateSpan) throw();

	// DateTimeSpan math
	COleDateTimeSpan operator-(const COleDateTime& date) const throw();

	operator DATE() const throw();

	int SetDateTime(int nYear, int nMonth, int nDay,
		int nHour, int nMin, int nSec) throw();
	int SetDate(int nYear, int nMonth, int nDay) throw();
	int SetTime(int nHour, int nMin, int nSec) throw();
	bool ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags = 0,
		LCID lcid = LANG_USER_DEFAULT) throw();

#ifndef _ATL_MIN_CRT
	// formatting
	CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
	CString Format(LPCTSTR lpszFormat) const;
	CString Format(UINT nFormatID) const;
#endif

protected:
	static double DoubleFromDate( DATE date ) throw();
	static DATE DateFromDouble( double f ) throw();

	void CheckRange();
};

class CFileTimeSpan
{
public:
	CFileTimeSpan() throw();
	CFileTimeSpan( const CFileTimeSpan& span ) throw();
	CFileTimeSpan( LONGLONG nSpan ) throw();

	CFileTimeSpan& operator=( const CFileTimeSpan& span ) throw();

	CFileTimeSpan& operator+=( CFileTimeSpan span ) throw();
	CFileTimeSpan& operator-=( CFileTimeSpan span ) throw();

	CFileTimeSpan operator+( CFileTimeSpan span ) const throw();
	CFileTimeSpan operator-( CFileTimeSpan span ) const throw();

	bool operator==( CFileTimeSpan span ) const throw();
	bool operator!=( CFileTimeSpan span ) const throw();
	bool operator<( CFileTimeSpan span ) const throw(